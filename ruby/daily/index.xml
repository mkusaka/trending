<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-04T01:32:48Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rswag/rswag</title>
    <updated>2022-08-04T01:32:48Z</updated>
    <id>tag:github.com,2022-08-04:/rswag/rswag</id>
    <link href="https://github.com/rswag/rswag" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Seamlessly adds a Swagger to Rails-based API&#39;s&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rswag&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rswag/rswag/actions/workflows/ruby.yml?query=branch%3Amaster+&#34;&gt;&lt;img src=&#34;https://github.com/rswag/rswag/actions/workflows/ruby.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/rswag/rswag/maintainability&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/1175b984edc4610f82ab/maintainability&#34; alt=&#34;Maintainability&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;OpenApi 3.0 and Swagger 2.0 compatible!&lt;/p&gt; &#xA;&lt;p&gt;Seeking maintainers! Got a pet-bug that needs fixing? Just let us know in your issue/pr that you&#39;d like to step up to help.&lt;/p&gt; &#xA;&lt;p&gt;Rswag extends rspec-rails &#34;request specs&#34; with a Swagger-based DSL for describing and testing API operations. You describe your API operations with a succinct, intuitive syntax, and it automaticaly runs the tests. Once you have green tests, run a rake task to auto-generate corresponding Swagger files and expose them as YAML or JSON endpoints. Rswag also provides an embedded version of the awesome &lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;swagger-ui&lt;/a&gt; that&#39;s powered by the exposed file. This toolchain makes it seamless to go from integration specs, which youre probably doing in some form already, to living documentation for your API consumers.&lt;/p&gt; &#xA;&lt;p&gt;Api Rswag creates &lt;a href=&#34;http://swagger.io&#34;&gt;Swagger&lt;/a&gt; tooling for Rails API&#39;s. Generate beautiful API documentation, including a UI to explore and test operations, directly from your rspec integration tests.&lt;/p&gt; &#xA;&lt;p&gt;And that&#39;s not all ...&lt;/p&gt; &#xA;&lt;p&gt;Once you have an API that can describe itself in Swagger, you&#39;ve opened the treasure chest of Swagger-based tools including a client generator that can be targeted to a wide range of popular platforms. See &lt;a href=&#34;https://github.com/swagger-api/swagger-codegen&#34;&gt;swagger-codegen&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Rswag Version&lt;/th&gt; &#xA;   &lt;th&gt;Swagger (OpenAPI) Spec.&lt;/th&gt; &#xA;   &lt;th&gt;swagger-ui&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/rswag/rswag/tree/master&#34;&gt;master&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;3.0.3&lt;/td&gt; &#xA;   &lt;td&gt;3.52.5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/rswag/rswag/tree/2.5.0&#34;&gt;2.5.1&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;3.0.3&lt;/td&gt; &#xA;   &lt;td&gt;3.52.5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/rswag/rswag/tree/2.3.0&#34;&gt;2.3.0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;3.0.3&lt;/td&gt; &#xA;   &lt;td&gt;3.23.11&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/rswag/rswag/tree/2.2.0&#34;&gt;2.2.0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2.0&lt;/td&gt; &#xA;   &lt;td&gt;3.18.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/rswag/rswag/tree/1.6.0&#34;&gt;1.6.0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;2.0&lt;/td&gt; &#xA;   &lt;td&gt;2.2.5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#rswag&#34;&gt;rswag&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#compatibility&#34;&gt;Compatibility&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#the-rspec-dsl&#34;&gt;The rspec DSL&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#paths-operations-and-responses&#34;&gt;Paths, Operations and Responses&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#null-values&#34;&gt;Null Values&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#support-for-oneof-anyof-or-allof-schemas&#34;&gt;Support for oneOf, anyOf or AllOf schemas&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#global-metadata&#34;&gt;Global Metadata&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#supporting-multiple-versions-of-api&#34;&gt;Supporting multiple versions of API&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#formatting-the-description-literals&#34;&gt;Formatting the description literals:&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#specifyingtesting-api-security&#34;&gt;Specifying/Testing API Security&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#configuration--customization&#34;&gt;Configuration &amp;amp; Customization&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#output-location-for-generated-swagger-files&#34;&gt;Output Location for Generated Swagger Files&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#input-location-for-rspec-tests&#34;&gt;Input Location for Rspec Tests&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#referenced-parameters-and-schema-definitions&#34;&gt;Referenced Parameters and Schema Definitions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#response-headers&#34;&gt;Response headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#response-examples&#34;&gt;Response examples&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#enable-auto-generation-examples-from-responses&#34;&gt;Enable auto generation examples from responses&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#running-tests-without-documenting&#34;&gt;Running tests without documenting&lt;/a&gt; &#xA;        &lt;ul&gt; &#xA;         &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#rswag-helper-methods&#34;&gt;rswag helper methods&lt;/a&gt;&lt;/li&gt; &#xA;         &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#rswag-response-examples&#34;&gt;rswag response examples&lt;/a&gt;&lt;/li&gt; &#xA;        &lt;/ul&gt; &lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#route-prefix-for-swagger-json-endpoints&#34;&gt;Route Prefix for Swagger JSON Endpoints&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#root-location-for-swagger-files&#34;&gt;Root Location for Swagger Files&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#dynamic-values-for-swagger-json&#34;&gt;Dynamic Values for Swagger JSON&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#custom-headers-for-swagger-files&#34;&gt;Custom Headers for Swagger Files&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#enable-swagger-endpoints-for-swagger-ui&#34;&gt;Enable Swagger Endpoints for swagger-ui&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#enable-simple-basic-auth-for-swagger-ui&#34;&gt;Enable Simple Basic Auth for swagger-ui&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#route-prefix-for-the-swagger-ui&#34;&gt;Route Prefix for the swagger-ui&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#customizing-the-swagger-ui&#34;&gt;Customizing the swagger-ui&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rswag/rswag/master/#serve-ui-assets-directly-from-your-web-server&#34;&gt;Serve UI Assets Directly from your Web Server&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- END doctoc generated TOC please keep comment here to allow auto update --&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Add this line to your applications &lt;em&gt;Gemfile&lt;/em&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;rswag&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or if you like to avoid loading rspec in other bundler groups load the rswag-specs component separately. Note: Adding it to the :development group is not strictly necessary, but without it, generators and rake tasks must be preceded by RAILS_ENV=test.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Gemfile&#xA;gem &#39;rswag-api&#39;&#xA;gem &#39;rswag-ui&#39;&#xA;&#xA;group :development, :test do&#xA;  gem &#39;rspec-rails&#39;&#xA;  gem &#39;rswag-specs&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the install generator&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rails g rswag:install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Or run the install generators for each package separately if you installed Rswag as separate gems, as indicated above:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rails g rswag:api:install&#xA;rails g rswag:ui:install&#xA;RAILS_ENV=test rails g rswag:specs:install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create an integration spec to describe and test your API. There is also a generator which can help get you started &lt;code&gt;rails generate rspec:swagger API::MyController&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/integration/blogs_spec.rb&#xA;require &#39;swagger_helper&#39;&#xA;&#xA;describe &#39;Blogs API&#39; do&#xA;&#xA;  path &#39;/blogs&#39; do&#xA;&#xA;    post &#39;Creates a blog&#39; do&#xA;      tags &#39;Blogs&#39;&#xA;      consumes &#39;application/json&#39;&#xA;      parameter name: :blog, in: :body, schema: {&#xA;        type: :object,&#xA;        properties: {&#xA;          title: { type: :string },&#xA;          content: { type: :string }&#xA;        },&#xA;        required: [ &#39;title&#39;, &#39;content&#39; ]&#xA;      }&#xA;&#xA;      response &#39;201&#39;, &#39;blog created&#39; do&#xA;        let(:blog) { { title: &#39;foo&#39;, content: &#39;bar&#39; } }&#xA;        run_test!&#xA;      end&#xA;&#xA;      response &#39;422&#39;, &#39;invalid request&#39; do&#xA;        let(:blog) { { title: &#39;foo&#39; } }&#xA;        run_test!&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  path &#39;/blogs/{id}&#39; do&#xA;&#xA;    get &#39;Retrieves a blog&#39; do&#xA;      tags &#39;Blogs&#39;, &#39;Another Tag&#39;&#xA;      produces &#39;application/json&#39;, &#39;application/xml&#39;&#xA;      parameter name: :id, in: :path, type: :string&#xA;&#xA;      response &#39;200&#39;, &#39;blog found&#39; do&#xA;        schema type: :object,&#xA;          properties: {&#xA;            id: { type: :integer },&#xA;            title: { type: :string },&#xA;            content: { type: :string }&#xA;          },&#xA;          required: [ &#39;id&#39;, &#39;title&#39;, &#39;content&#39; ]&#xA;&#xA;        let(:id) { Blog.create(title: &#39;foo&#39;, content: &#39;bar&#39;).id }&#xA;        run_test!&#xA;      end&#xA;&#xA;      response &#39;404&#39;, &#39;blog not found&#39; do&#xA;        let(:id) { &#39;invalid&#39; }&#xA;        run_test!&#xA;      end&#xA;&#xA;      response &#39;406&#39;, &#39;unsupported accept header&#39; do&#xA;        let(:&#39;Accept&#39;) { &#39;application/foo&#39; }&#xA;        run_test!&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate the Swagger JSON file(s)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rake rswag:specs:swaggerize&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This common command is also aliased as &lt;code&gt;rake rswag&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Or if you installed your gems separately:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;RAILS_ENV=test rails rswag&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Spin up your app and check out the awesome, auto-generated docs at &lt;em&gt;/api-docs&lt;/em&gt;!&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;The rspec DSL&lt;/h2&gt; &#xA;&lt;h3&gt;Paths, Operations and Responses&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;ve used &lt;a href=&#34;http://swagger.io/specification&#34;&gt;Swagger&lt;/a&gt; before, then the syntax should be very familiar. To describe your API operations, start by specifying a path and then list the supported operations (i.e. HTTP verbs) for that path. Path parameters must be surrounded by curly braces ({}). Within an operation block (see &#34;post&#34; or &#34;get&#34; in the example above), most of the fields supported by the &lt;a href=&#34;http://swagger.io/specification/#operationObject&#34;&gt;Swagger &#34;Operation&#34; object&lt;/a&gt; are available as methods on the example group. To list (and test) the various responses for an operation, create one or more response blocks. Again, you can reference the &lt;a href=&#34;http://swagger.io/specification/#responseObject&#34;&gt;Swagger &#34;Response&#34; object&lt;/a&gt; for available fields.&lt;/p&gt; &#xA;&lt;p&gt;Take special note of the &lt;strong&gt;run_test!&lt;/strong&gt; method that&#39;s called within each response block. This tells rswag to create and execute a corresponding example. It builds and submits a request based on parameter descriptions and corresponding values that have been provided using the rspec &#34;let&#34; syntax. For example, the &#34;post&#34; description in the example above specifies a &#34;body&#34; parameter called &#34;blog&#34;. It also lists 2 different responses. For the success case (i.e. the 201 response), notice how &#34;let&#34; is used to set the blog parameter to a value that matches the provided schema. For the failure case (i.e. the 422 response), notice how it&#39;s set to a value that does not match the provided schema. When the test is executed, rswag also validates the actual response code and, where applicable, the response body against the provided &lt;a href=&#34;http://json-schema.org/documentation.html&#34;&gt;JSON Schema&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to do additional validation on the response, pass a block to the &lt;strong&gt;run_test!&lt;/strong&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response &#39;201&#39;, &#39;blog created&#39; do&#xA;  run_test! do |response|&#xA;    data = JSON.parse(response.body)&#xA;    expect(data[&#39;title&#39;]).to eq(&#39;foo&#39;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you&#39;d like your specs to be a little more explicit about what&#39;s going on here, you can replace the call to &lt;strong&gt;run_test!&lt;/strong&gt; with equivalent &#34;before&#34; and &#34;it&#34; blocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;response &#39;201&#39;, &#39;blog created&#39; do&#xA;  let(:blog) { { title: &#39;foo&#39;, content: &#39;bar&#39; } }&#xA;&#xA;  before do |example|&#xA;    submit_request(example.metadata)&#xA;  end&#xA;&#xA;  it &#39;returns a valid 201 response&#39; do |example|&#xA;    assert_response_matches_metadata(example.metadata)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Null Values&lt;/h3&gt; &#xA;&lt;p&gt;This library is currently using JSON::Draft4 for validation of response models. Nullable properties can be supported with the non-standard property &#39;x-nullable&#39; to a definition to allow null/nil values to pass. Or you can add the new standard &lt;code&gt;nullable&lt;/code&gt; property to a definition.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe &#39;Blogs API&#39; do&#xA;  path &#39;/blogs&#39; do&#xA;    post &#39;Creates a blog&#39; do&#xA;      ...&#xA;&#xA;      response &#39;200&#39;, &#39;blog found&#39; do&#xA;        schema type: :object,&#xA;          properties: {&#xA;            id: { type: :integer },&#xA;            title: { type: :string, nullable: true }, # preferred syntax&#xA;            content: { type: :string, &#39;x-nullable&#39;: true } # legacy syntax, but still works&#xA;          }&#xA;        ....&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Support for oneOf, anyOf or AllOf schemas&lt;/h3&gt; &#xA;&lt;p&gt;Open API 3.0 now supports more flexible schema validation with the &lt;code&gt;oneOf&lt;/code&gt;, &lt;code&gt;anyOf&lt;/code&gt; and &lt;code&gt;allOf&lt;/code&gt; directives. rswag will handle these definitions and validate them properly.&lt;/p&gt; &#xA;&lt;p&gt;Notice the &lt;code&gt;schema&lt;/code&gt; inside the &lt;code&gt;response&lt;/code&gt; section. Placing a &lt;code&gt;schema&lt;/code&gt; method inside the response will validate (and fail the tests) if during the integration test run the endpoint response does not match the response schema. This test validation can handle anyOf and allOf as well. See below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&#xA;  path &#39;/blogs/flexible&#39; do&#xA;    post &#39;Creates a blog flexible body&#39; do&#xA;      tags &#39;Blogs&#39;&#xA;      description &#39;Creates a flexible blog from provided data&#39;&#xA;      operationId &#39;createFlexibleBlog&#39;&#xA;      consumes &#39;application/json&#39;&#xA;      produces &#39;application/json&#39;&#xA;&#xA;      parameter name: :blog, in: :body, schema: {&#xA;          oneOf: [&#xA;            { &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/blog&#39; },&#xA;            { &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/flexible_blog&#39; }&#xA;          ]&#xA;        }&#xA;&#xA;      response &#39;201&#39;, &#39;flexible blog created&#39; do&#xA;        schema oneOf: [{ &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/blog&#39; }, { &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/flexible_blog&#39; }]&#xA;        run_test!&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This automatic schema validation is a powerful feature of rswag.&lt;/p&gt; &#xA;&lt;h3&gt;Global Metadata&lt;/h3&gt; &#xA;&lt;p&gt;In addition to paths, operations and responses, Swagger also supports global API metadata. When you install rswag, a file called &lt;em&gt;swagger_helper.rb&lt;/em&gt; is added to your spec folder. This is where you define one or more Swagger documents and provide global metadata. Again, the format is based on Swagger so most of the global fields supported by the top level &lt;a href=&#34;http://swagger.io/specification/#swaggerObject&#34;&gt;&#34;Swagger&#34; object&lt;/a&gt; can be provided with each document definition. As an example, you could define a Swagger document for each version of your API and in each case specify a title, version string. In Open API 3.0 the pathing and server definitions have changed a bit &lt;a href=&#34;https://swagger.io/docs/specification/api-host-and-base-path/&#34;&gt;Swagger host/basePath&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/swagger_helper.rb&#xA;RSpec.configure do |config|&#xA;  config.swagger_root = Rails.root.to_s + &#39;/swagger&#39;&#xA;&#xA;  config.swagger_docs = {&#xA;    &#39;v1/swagger.json&#39; =&amp;gt; {&#xA;      openapi: &#39;3.0.1&#39;,&#xA;      info: {&#xA;        title: &#39;API V1&#39;,&#xA;        version: &#39;v1&#39;,&#xA;        description: &#39;This is the first version of my API&#39;&#xA;      },&#xA;      servers: [&#xA;        {&#xA;          url: &#39;https://{defaultHost}&#39;,&#xA;          variables: {&#xA;            defaultHost: {&#xA;                default: &#39;www.example.com&#39;&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    },&#xA;&#xA;    &#39;v2/swagger.yaml&#39; =&amp;gt; {&#xA;      openapi: &#39;3.0.1&#39;,&#xA;      info: {&#xA;        title: &#39;API V2&#39;,&#xA;        version: &#39;v2&#39;,&#xA;        description: &#39;This is the second version of my API&#39;&#xA;      },&#xA;      servers: [&#xA;        {&#xA;          url: &#39;https://{defaultHost}&#39;,&#xA;          variables: {&#xA;            defaultHost: {&#xA;                default: &#39;www.example.com&#39;&#xA;            }&#xA;          }&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Supporting multiple versions of API&lt;/h4&gt; &#xA;&lt;p&gt;By default, the paths, operations and responses defined in your spec files will be associated with the first Swagger document in &lt;em&gt;swagger_helper.rb&lt;/em&gt;. If your API has multiple versions, you should be using separate documents to describe each of them. In order to assign a file with a given version of API, you&#39;ll need to add the &lt;code&gt;swagger_doc&lt;/code&gt; tag to each spec specifying its target document name:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/integration/v2/blogs_spec.rb&#xA;describe &#39;Blogs API&#39;, swagger_doc: &#39;v2/swagger.yaml&#39; do&#xA;&#xA;  path &#39;/blogs&#39; do&#xA;  ...&#xA;&#xA;  path &#39;/blogs/{id}&#39; do&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Formatting the description literals:&lt;/h4&gt; &#xA;&lt;p&gt;Swagger supports the Markdown syntax to format strings. This can be especially handy if you were to provide a long description of a given API version or endpoint. Use &lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&#34;&gt;this guide&lt;/a&gt; for reference.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; There is one difference between the official Markdown syntax and Swagger interpretation, namely tables. To create a table like this:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Column1&lt;/th&gt; &#xA;   &lt;th&gt;Collumn2&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;cell1&lt;/td&gt; &#xA;   &lt;td&gt;cell2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;you should use the folowing syntax, making sure there are no whitespaces at the start of any of the lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;amp;#13;&#xA;| Column1 | Collumn2 |&amp;amp;#13;&#xA;| ------- | -------- |&amp;amp;#13;&#xA;| cell1   | cell2    |&amp;amp;#13;&#xA;&amp;amp;#13;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying/Testing API Security&lt;/h3&gt; &#xA;&lt;p&gt;Swagger allows for the specification of different security schemes and their applicability to operations in an API. To leverage this in rswag, you define the schemes globally in &lt;em&gt;swagger_helper.rb&lt;/em&gt; and then use the &#34;security&#34; attribute at the operation level to specify which schemes, if any, are applicable to that operation. Swagger supports :basic, :bearer, :apiKey and :oauth2 and :openIdConnect scheme types. See &lt;a href=&#34;https://swagger.io/docs/specification/authentication/&#34;&gt;the spec&lt;/a&gt; for more info, as this underwent major changes between Swagger 2.0 and Open API 3.0&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/swagger_helper.rb&#xA;RSpec.configure do |config|&#xA;  config.swagger_root = Rails.root.to_s + &#39;/swagger&#39;&#xA;&#xA;  config.swagger_docs = {&#xA;    &#39;v1/swagger.json&#39; =&amp;gt; {&#xA;      ...  # note the new Open API 3.0 compliant security structure here, under &#34;components&#34;&#xA;      components: {&#xA;        securitySchemes: {&#xA;          basic_auth: {&#xA;            type: :http,&#xA;            scheme: :basic&#xA;          },&#xA;          api_key: {&#xA;            type: :apiKey,&#xA;            name: &#39;api_key&#39;,&#xA;            in: :query&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;end&#xA;&#xA;# spec/integration/blogs_spec.rb&#xA;describe &#39;Blogs API&#39; do&#xA;&#xA;  path &#39;/blogs&#39; do&#xA;&#xA;    post &#39;Creates a blog&#39; do&#xA;      tags &#39;Blogs&#39;&#xA;      security [ basic_auth: [] ]&#xA;      ...&#xA;&#xA;      response &#39;201&#39;, &#39;blog created&#39; do&#xA;        let(:Authorization) { &#34;Basic #{::Base64.strict_encode64(&#39;jsmith:jspass&#39;)}&#34; }&#xA;        run_test!&#xA;      end&#xA;&#xA;      response &#39;401&#39;, &#39;authentication failed&#39; do&#xA;        let(:Authorization) { &#34;Basic #{::Base64.strict_encode64(&#39;bogus:bogus&#39;)}&#34; }&#xA;        run_test!&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;# example of documenting an endpoint that handles basic auth and api key based security&#xA;describe &#39;Auth examples API&#39; do&#xA;  path &#39;/auth-tests/basic-and-api-key&#39; do&#xA;    post &#39;Authenticates with basic auth and api key&#39; do&#xA;      tags &#39;Auth Tests&#39;&#xA;      operationId &#39;testBasicAndApiKey&#39;&#xA;      security [{ basic_auth: [], api_key: [] }]&#xA;&#xA;      response &#39;204&#39;, &#39;Valid credentials&#39; do&#xA;        let(:Authorization) { &#34;Basic #{::Base64.strict_encode64(&#39;jsmith:jspass&#39;)}&#34; }&#xA;        let(:api_key) { &#39;foobar&#39; }&#xA;        run_test!&#xA;      end&#xA;&#xA;      response &#39;401&#39;, &#39;Invalid credentials&#39; do&#xA;        let(:Authorization) { &#34;Basic #{::Base64.strict_encode64(&#39;jsmith:jspass&#39;)}&#34; }&#xA;        let(:api_key) { &#39;barfoo&#39; }&#xA;        run_test!&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Depending on the scheme types, you&#39;ll be required to assign a corresponding parameter value with each example. For example, :basic auth is required above and so the :Authorization (header) parameter must be set accordingly&lt;/p&gt; &#xA;&lt;h2&gt;Configuration &amp;amp; Customization&lt;/h2&gt; &#xA;&lt;p&gt;The steps described above will get you up and running with minimal setup. However, rswag offers a lot of flexibility to customize as you see fit. Before exploring the various options, you&#39;ll need to be aware of it&#39;s different components. The following table lists each of them and the files that get added/updated as part of a standard install.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Gem&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Added/Updated&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;rswag-specs&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Swagger-based DSL for rspec &amp;amp; accompanying rake task for generating Swagger files&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;spec/swagger_helper.rb&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;rswag-api&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Rails Engine that exposes your Swagger files as JSON endpoints&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;config/initializers/rswag_api.rb, config/routes.rb&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;rswag-ui&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Rails Engine that includes &lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;swagger-ui&lt;/a&gt; and powers it from your Swagger endpoints&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;config/initializers/rswag-ui.rb, config/routes.rb&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Output Location for Generated Swagger Files&lt;/h3&gt; &#xA;&lt;p&gt;You can adjust this in the &lt;em&gt;swagger_helper.rb&lt;/em&gt; that&#39;s installed with &lt;strong&gt;rswag-specs&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/swagger_helper.rb&#xA;RSpec.configure do |config|&#xA;  config.swagger_root = Rails.root.to_s + &#39;/your-custom-folder-name&#39;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If you do change this, you&#39;ll also need to update the rswag_api.rb initializer (assuming you&#39;re using rswag-api). More on this later.&lt;/p&gt; &#xA;&lt;h3&gt;Input Location for Rspec Tests&lt;/h3&gt; &#xA;&lt;p&gt;By default, rswag will search for integration tests in &lt;em&gt;spec/requests&lt;/em&gt;, &lt;em&gt;spec/api&lt;/em&gt; and &lt;em&gt;spec/integration&lt;/em&gt;. If you want to use tests from other locations, provide the PATTERN argument to rake:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# search for tests in spec/swagger&#xA;rake rswag:specs:swaggerize PATTERN=&#34;spec/swagger/**/*_spec.rb&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Referenced Parameters and Schema Definitions&lt;/h3&gt; &#xA;&lt;p&gt;Swagger allows you to describe JSON structures inline with your operation descriptions OR as referenced globals. For example, you might have a standard response structure for all failed operations. Again, this is a structure that changed since swagger 2.0. Notice the new &#34;schemas&#34; section for these. Rather than repeating the schema in every operation spec, you can define it globally and provide a reference to it in each spec:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/swagger_helper.rb&#xA;config.swagger_docs = {&#xA;  &#39;v1/swagger.json&#39; =&amp;gt; {&#xA;    openapi: &#39;3.0.0&#39;,&#xA;    info: {&#xA;      title: &#39;API V1&#39;&#xA;    },&#xA;    components: {&#xA;      schemas: {&#xA;        errors_object: {&#xA;          type: &#39;object&#39;,&#xA;          properties: {&#xA;            errors: { &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/errors_map&#39; }&#xA;          }&#xA;        },&#xA;        errors_map: {&#xA;          type: &#39;object&#39;,&#xA;          additionalProperties: {&#xA;            type: &#39;array&#39;,&#xA;            items: { type: &#39;string&#39; }&#xA;          }&#xA;        },&#xA;        blog: {&#xA;          type: &#39;object&#39;,&#xA;          properties: {&#xA;            id: { type: &#39;integer&#39; },&#xA;            title: { type: &#39;string&#39; },&#xA;            content: { type: &#39;string&#39;, nullable: true },&#xA;            thumbnail: { type: &#39;string&#39;, nullable: true }&#xA;          },&#xA;          required: %w[id title]&#xA;        },&#xA;        new_blog: {&#xA;          type: &#39;object&#39;,&#xA;          properties: {&#xA;            title: { type: &#39;string&#39; },&#xA;            content: { type: &#39;string&#39;, nullable: true },&#xA;            thumbnail: { type: &#39;string&#39;, format: &#39;binary&#39;, nullable: true }&#xA;          },&#xA;          required: %w[title]&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;# spec/integration/blogs_spec.rb&#xA;describe &#39;Blogs API&#39; do&#xA;&#xA;  path &#39;/blogs&#39; do&#xA;&#xA;    post &#39;Creates a blog&#39; do&#xA;&#xA;      parameter name: :new_blog, in: :body, schema: { &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/new_blog&#39; }&#xA;&#xA;      response 422, &#39;invalid request&#39; do&#xA;        schema &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/errors_object&#39;&#xA;  ...&#xA;end&#xA;&#xA;# spec/integration/comments_spec.rb&#xA;describe &#39;Blogs API&#39; do&#xA;&#xA;  path &#39;/blogs/{blog_id}/comments&#39; do&#xA;&#xA;    post &#39;Creates a comment&#39; do&#xA;&#xA;      response 422, &#39;invalid request&#39; do&#xA;        schema &#39;$ref&#39; =&amp;gt; &#39;#/components/schemas/errors_object&#39;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response headers&lt;/h3&gt; &#xA;&lt;p&gt;In Rswag, you could use &lt;code&gt;header&lt;/code&gt; method inside the response block to specify header objects for this response. Rswag will validate your response headers with those header objects and inject them into the generated swagger file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/integration/comments_spec.rb&#xA;describe &#39;Blogs API&#39; do&#xA;&#xA;  path &#39;/blogs/{blog_id}/comments&#39; do&#xA;&#xA;    post &#39;Creates a comment&#39; do&#xA;&#xA;      response 422, &#39;invalid request&#39; do&#xA;        header &#39;X-Rate-Limit-Limit&#39;, type: :integer, description: &#39;The number of allowed requests in the current period&#39;&#xA;        header &#39;X-Rate-Limit-Remaining&#39;, type: :integer, description: &#39;The number of remaining requests in the current period&#39;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Response examples&lt;/h3&gt; &#xA;&lt;p&gt;You can provide custom response examples to the generated swagger file by calling the method &lt;code&gt;examples&lt;/code&gt; inside the response block: However, auto generated example responses are now enabled by default in rswag. See below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# spec/integration/blogs_spec.rb&#xA;describe &#39;Blogs API&#39; do&#xA;&#xA;  path &#39;/blogs/{blog_id}&#39; do&#xA;&#xA;    get &#39;Retrieves a blog&#39; do&#xA;&#xA;      response 200, &#39;blog found&#39; do&#xA;        example &#39;application/json&#39;, :example_key, {&#xA;            id: 1,&#xA;            title: &#39;Hello world!&#39;,&#xA;            content: &#39;...&#39;&#xA;          }&#xA;        example &#39;application/json&#39;, :example_key_2, {&#xA;            id: 1,&#xA;            title: &#39;Hello world!&#39;,&#xA;            content: &#39;...&#39;&#xA;          }, &#34;Summary of the example&#34;, &#34;Longer description of the example&#34;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enable auto generation examples from responses&lt;/h3&gt; &#xA;&lt;p&gt;To enable examples generation from responses add callback above run_test! like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  after do |example|&#xA;    content = example.metadata[:response][:content] || {}&#xA;    example_spec = {&#xA;      &#34;application/json&#34;=&amp;gt;{&#xA;        examples: {&#xA;          test_example: {&#xA;            value: JSON.parse(response.body, symbolize_names: true)&#xA;          }&#xA;        }&#xA;      }&#xA;    }&#xA;    example.metadata[:response][:content] = content.deep_merge(example_spec)&#xA;  end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Dry Run Option&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;--dry-run&lt;/code&gt; option is enabled by default for Rspec 3, but if you need to disable it you can use the environment varible &lt;code&gt;SWAGGER_DRY_RUN=0&lt;/code&gt; during the generation command or add the following to your &lt;code&gt;config/environments/test.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;RSpec.configure do |config|&#xA;  config.swagger_dry_run = false&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Running tests without documenting&lt;/h4&gt; &#xA;&lt;p&gt;If you want to use Rswag for testing without adding it to you swagger docs, you can provide the document tag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe &#39;Blogs API&#39; do&#xA;  path &#39;/blogs/{blog_id}&#39; do&#xA;    get &#39;Retrieves a blog&#39; do&#xA;      # documentation is now disabled for this response only&#xA;      response 200, &#39;blog found&#39;, document: false do&#xA;        ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also reenable documentation for specific responses only:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# documentation is now disabled&#xA;describe &#39;Blogs API&#39;, document: false do&#xA;  path &#39;/blogs/{blog_id}&#39; do&#xA;    get &#39;Retrieves a blog&#39; do&#xA;      # documentation is reenabled for this response only&#xA;      response 200, &#39;blog found&#39;, document: true do&#xA;        ...&#xA;      end&#xA;&#xA;      response 401, &#39;special case&#39; do&#xA;        ...&#xA;      end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;rswag helper methods&lt;/h5&gt; &#xA;&lt;!--&#xA;There are some helper methods to help with documenting request bodies.&#xA;```ruby&#xA;describe &#39;Blogs API&#39;, type: :request, swagger_doc: &#39;v1/swagger.json&#39; do&#xA;  let(:api_key) { &#39;fake_key&#39; }&#xA;&#xA;  path &#39;/blogs&#39; do&#xA;    post &#39;Creates a blog&#39; do&#xA;      tags &#39;Blogs&#39;&#xA;      description &#39;Creates a new blog from provided data&#39;&#xA;      operationId &#39;createBlog&#39;&#xA;      consumes &#39;application/json&#39;&#xA;      produces &#39;application/json&#39;&#xA;&#xA;      request_body_json schema: { &#39;$ref&#39; =&gt; &#39;#/components/schemas/blog&#39; },&#xA;                        examples: :blog&#xA;&#xA;      request_body_text_plain&#xA;      request_body_xml schema: { &#39;$ref&#39; =&gt; &#39;#/components/schemas/blog&#39; }&#xA;&#xA;      let(:blog) { { blog: { title: &#39;foo&#39;, content: &#39;bar&#39; } } }&#xA;&#xA;      response &#39;201&#39;, &#39;blog created&#39; do&#xA;        schema &#39;$ref&#39; =&gt; &#39;#/components/schemas/blog&#39;&#xA;        run_test!&#xA;      end&#xA;&#xA;      response &#39;422&#39;, &#39;invalid request&#39; do&#xA;        schema &#39;$ref&#39; =&gt; &#39;#/components/schemas/errors_object&#39;&#xA;        let(:blog) { { blog: { title: &#39;foo&#39; } } }&#xA;&#xA;        run_test! do |response|&#xA;          expect(response.body).to include(&#34;can&#39;t be blank&#34;)&#xA;        end&#xA;      end&#xA;    end&#xA;  end&#xA;end&#xA;```&#xA;&#xA;In the above example, we see methods ```request_body_json``` ```request_body_plain``` ```request_body_xml```.&#xA;These methods can be used to describe json, plain text and xml body. They are just wrapper methods to setup posting JSON, plain text or xml into your endpoint.&#xA;The simplest most common usage is for json formatted body to use the schema: to specify the location of the schema for the request body&#xA;and the examples: :blog which will create a named example &#34;blog&#34; under the &#34;requestBody / content / application/json / examples&#34; section.&#xA;Again, documenting request response examples changed in Open API 3.0. The example above would generate a swagger.json snippet that looks like this:&#xA;&#xA;```json&#xA;        ...&#xA;        {&#34;requestBody&#34;: {&#xA;          &#34;required&#34;: true,&#xA;          &#34;content&#34;: {&#xA;            &#34;application/json&#34;: {&#xA;              &#34;examples&#34;: {&#xA;                &#34;blog&#34;: {  // takes the name from  examples: :blog above&#xA;                  &#34;value&#34;: {  //this is open api 3.0 structure -&gt; https://swagger.io/docs/specification/adding-examples/&#xA;                    &#34;blog&#34;: { // here is the actual JSON payload that is submitted to the service, and shows up in swagger UI as an example&#xA;                      &#34;title&#34;: &#34;foo&#34;,&#xA;                      &#34;content&#34;: &#34;bar&#34;&#xA;                    }&#xA;                  }&#xA;                }&#xA;              },&#xA;              &#34;schema&#34;: {&#xA;                &#34;$ref&#34;: &#34;#/components/schemas/blog&#34;&#xA;              }&#xA;            },&#xA;            &#34;test/plain&#34;: {&#xA;              &#34;schema&#34;: {&#xA;                &#34;type&#34;: &#34;string&#34;&#xA;              }&#xA;            },&#xA;            &#34;application/xml&#34;: {&#xA;              &#34;schema&#34;: {&#xA;                &#34;$ref&#34;: &#34;#/components/schemas/blog&#34;&#xA;              }&#xA;            }&#xA;          }&#xA;        },&#xA;        }&#xA;```&#xA;&#xA;*NOTE:* for this example request body to work in the tests properly, you need to ``let`` a variable named *blog*.&#xA;The variable with the matching name (blog in this case) is eval-ed and captured to be placed in the examples section.&#xA;This ```let``` value is used in the integration test to run the test AND captured and injected into the requestBody section.&#xA;&#xA;##### rswag response examples #####&#xA;&#xA;In the same way that requestBody examples can be captured and injected into the swagger output, response examples can also be captured.&#xA;Using the above example, when the integration test is run - the swagger would include the following snippet providing more useful real world examples&#xA;capturing the response from the execution of the integration test. Again 3.0 swagger changed the structure of how these are documented.&#xA;&#xA;```json&#xA;       ...  &#34;responses&#34;: {&#xA;          &#34;201&#34;: {&#xA;            &#34;description&#34;: &#34;blog created&#34;,&#xA;            &#34;content&#34;: {&#xA;              &#34;application/json&#34;: {&#xA;                &#34;example&#34;: {&#xA;                  &#34;id&#34;: 1,&#xA;                  &#34;title&#34;: &#34;foo&#34;,&#xA;                  &#34;content&#34;: &#34;bar&#34;,&#xA;                  &#34;thumbnail&#34;: null&#xA;                },&#xA;                &#34;schema&#34;: {&#xA;                  &#34;$ref&#34;: &#34;#/components/schemas/blog&#34;&#xA;                }&#xA;              }&#xA;            }&#xA;          },&#xA;          &#34;422&#34;: {&#xA;            &#34;description&#34;: &#34;invalid request&#34;,&#xA;            &#34;content&#34;: {&#xA;              &#34;application/json&#34;: {&#xA;                &#34;example&#34;: {&#xA;                  &#34;errors&#34;: {&#xA;                    &#34;content&#34;: [&#xA;                      &#34;can&#39;t be blank&#34;&#xA;                    ]&#xA;                  }&#xA;                },&#xA;                &#34;schema&#34;: {&#xA;                  &#34;$ref&#34;: &#34;#/components/schemas/errors_object&#34;&#xA;                }&#xA;              }&#xA;            }&#xA;          }&#xA;        }&#xA;```&#xA; --&gt; &#xA;&lt;h3&gt;Route Prefix for Swagger JSON Endpoints&lt;/h3&gt; &#xA;&lt;p&gt;The functionality to expose Swagger files, such as those generated by rswag-specs, as JSON endpoints is implemented as a Rails Engine. As with any Engine, you can change it&#39;s mount prefix in &lt;em&gt;routes.rb&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;TestApp::Application.routes.draw do&#xA;  ...&#xA;&#xA;  mount Rswag::Api::Engine =&amp;gt; &#39;your-custom-prefix&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Assuming a Swagger file exists at &amp;lt;swagger_root&amp;gt;/v1/swagger.json, this configuration would expose the file as the following JSON endpoint:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;GET http://&amp;lt;hostname&amp;gt;/your-custom-prefix/v1/swagger.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Root Location for Swagger Files&lt;/h3&gt; &#xA;&lt;p&gt;You can adjust this in the &lt;em&gt;rswag_api.rb&lt;/em&gt; initializer that&#39;s installed with &lt;strong&gt;rspec-api&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rswag::Api.configure do |c|&#xA;  c.swagger_root = Rails.root.to_s + &#39;/your-custom-folder-name&#39;&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If you&#39;re using rswag-specs to generate Swagger files, you&#39;ll want to ensure they both use the same &amp;lt;swagger_root&amp;gt;. The reason for separate settings is to maintain independence between the two gems. For example, you could install rswag-api independently and create your Swagger files manually.&lt;/p&gt; &#xA;&lt;h3&gt;Dynamic Values for Swagger JSON&lt;/h3&gt; &#xA;&lt;p&gt;There may be cases where you need to add dynamic values to the Swagger JSON that&#39;s returned by rswag-api. For example, you may want to provide an explicit host name. Rather than hardcoding it, you can configure a filter that&#39;s executed prior to serializing every Swagger document:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rswag::Api.configure do |c|&#xA;  ...&#xA;&#xA;  c.swagger_filter = lambda { |swagger, env| swagger[&#39;host&#39;] = env[&#39;HTTP_HOST&#39;] }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note how the filter is passed the rack env for the current request. This provides a lot of flexibilty. For example, you can assign the &#34;host&#34; property (as shown) or you could inspect session information or an Authorization header and remove operations based on user permissions.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Headers for Swagger Files&lt;/h3&gt; &#xA;&lt;p&gt;You can specify custom headers for serving your generated Swagger JSON. For example you may want to force a specific charset for the &#39;Content-Type&#39; header. You can configure a hash of headers to be sent with the request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rswag::Api.configure do |c|&#xA;  ...&#xA;&#xA;  c.swagger_headers = { &#39;Content-Type&#39; =&amp;gt; &#39;application/json; charset=UTF-8&#39; }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Take care when overriding Content-Type if you serve both YAML and JSON files as it will no longer switch the Content-Type header correctly.&lt;/p&gt; &#xA;&lt;h3&gt;Enable Swagger Endpoints for swagger-ui&lt;/h3&gt; &#xA;&lt;p&gt;You can update the &lt;em&gt;rswag_ui.rb&lt;/em&gt; initializer, installed with rswag-ui, to specify which Swagger endpoints should be available to power the documentation UI. If you&#39;re using rswag-api, these should correspond to the Swagger endpoints it exposes. When the UI is rendered, you&#39;ll see these listed in a drop-down to the top right of the page:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rswag::Ui.configure do |c|&#xA;  c.swagger_endpoint &#39;/api-docs/v1/swagger.json&#39;, &#39;API V1 Docs&#39;&#xA;  c.swagger_endpoint &#39;/api-docs/v2/swagger.json&#39;, &#39;API V2 Docs&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Enable Simple Basic Auth for swagger-ui&lt;/h3&gt; &#xA;&lt;p&gt;You can also update the &lt;em&gt;rswag_ui.rb&lt;/em&gt; initializer, installed with rswag-ui to specify a username and password should you want to keep your documentation private.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rswag::Ui.configure do |c|&#xA;  c.basic_auth_enabled = true&#xA;  c.basic_auth_credentials &#39;username&#39;, &#39;password&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Route Prefix for the swagger-ui&lt;/h3&gt; &#xA;&lt;p&gt;Similar to rswag-api, you can customize the swagger-ui path by changing it&#39;s mount prefix in &lt;em&gt;routes.rb&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;TestApp::Application.routes.draw do&#xA;  ...&#xA;&#xA;  mount Rswag::Api::Engine =&amp;gt; &#39;api-docs&#39;&#xA;  mount Rswag::Ui::Engine =&amp;gt; &#39;your-custom-prefix&#39;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Customizing the swagger-ui&lt;/h3&gt; &#xA;&lt;p&gt;The swagger-ui provides several options for customizing it&#39;s behavior, all of which are documented here &lt;a href=&#34;https://github.com/swagger-api/swagger-ui/tree/2.x#swaggerui&#34;&gt;https://github.com/swagger-api/swagger-ui/tree/2.x#swaggerui&lt;/a&gt;. If you need to tweak these or customize the overall look and feel of your swagger-ui, then you&#39;ll need to provide your own version of index.html. You can do this with the following generator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;rails g rswag:ui:custom&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will add a local version that you can modify at &lt;em&gt;app/views/rswag/ui/home/index.html.erb&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Serve UI Assets Directly from your Web Server&lt;/h3&gt; &#xA;&lt;p&gt;Rswag ships with an embedded version of the &lt;a href=&#34;https://github.com/swagger-api/swagger-ui&#34;&gt;swagger-ui&lt;/a&gt;, which is a static collection of JavaScript and CSS files. These assets are served by the rswag-ui middleware. However, for optimal performance you may want to serve them directly from your web server (e.g. Apache or NGINX). To do this, you&#39;ll need to copy them to the web server root. This is the &#34;public&#34; folder in a typical Rails application.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake rswag:ui:copy_assets[public/api-docs]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;: The provided subfolder MUST correspond to the UI mount prefix - &#34;api-docs&#34; by default.&lt;/p&gt; &#xA;&lt;p&gt;Notes to test swagger output locally with swagger editor&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker pull swaggerapi/swagger-editor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -d -p 80:8080 swaggerapi/swagger-editor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will run the swagger editor in the docker daemon and can be accessed at &lt;code&gt;http://localhost&lt;/code&gt;. From here, you can use the UI to load the generated swagger.json to validate the output.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>fnando/i18n-js</title>
    <updated>2022-08-04T01:32:48Z</updated>
    <id>tag:github.com,2022-08-04:/fnando/i18n-js</id>
    <link href="https://github.com/fnando/i18n-js" rel="alternate"></link>
    <summary type="html">&lt;p&gt;It&#39;s a small library to provide the I18n translations on the Javascript. It comes with Rails support.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;250&#34; height=&#34;58&#34; src=&#34;https://github.com/fnando/i18n-js/raw/main/images/i18njs.png&#34; alt=&#34;i18n.js&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Export &lt;a href=&#34;https://rubygems.org/gems/i18n&#34;&gt;i18n&lt;/a&gt; translations to JSON. &lt;br&gt; A perfect fit if you want to export translations to JavaScript. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;small&gt; Oh, you don&#39;t use Ruby? No problem! You can still use i18n-js &lt;br&gt; and the &lt;a href=&#34;https://www.npmjs.com/package/i18n-js/v/latest&#34;&gt;companion JavaScript package&lt;/a&gt;. &lt;/small&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/fnando/i18n-js&#34;&gt;&lt;img src=&#34;https://github.com/fnando/i18n-js/workflows/ruby-tests/badge.svg?sanitize=true&#34; alt=&#34;Tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rubygems.org/gems/i18n-js&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/v/i18n-js.svg?sanitize=true&#34; alt=&#34;Gem&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rubygems.org/gems/i18n-js&#34;&gt;&lt;img src=&#34;https://img.shields.io/gem/dt/i18n-js.svg?sanitize=true&#34; alt=&#34;Gem&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://tldrlegal.com/license/mit-license&#34;&gt;&lt;img src=&#34;https://img.shields.io/:License-MIT-blue.svg?sanitize=true&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gem install i18n-js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or add the following line to your project&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;i18n-js&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;About patterns:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Patterns can use &lt;code&gt;*&lt;/code&gt; as a wildcard and can appear more than once. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;*&lt;/code&gt; will include everything&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;*.messages.*&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Patterns starting with &lt;code&gt;!&lt;/code&gt; are excluded. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;!*.activerecord.*&lt;/code&gt; will exclude all ActiveRecord translations.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;You can use groups: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;{pt-BR,en}.js.*&lt;/code&gt; will include only &lt;code&gt;pt-BR&lt;/code&gt; and &lt;code&gt;en&lt;/code&gt; translations, even if more languages are available.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt; &#xA; &lt;p&gt;Patterns use &lt;a href=&#34;https://rubygems.org/gems/glob&#34;&gt;glob&lt;/a&gt;, so check it out for the most up-to-date documentation about what&#39;s available.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---&#xA;translations:&#xA;  - file: app/frontend/locales/en.json&#xA;    patterns:&#xA;      - &#34;*&#34;&#xA;      - &#34;!*.activerecord&#34;&#xA;      - &#34;!*.errors&#34;&#xA;      - &#34;!*.number.nth&#34;&#xA;&#xA;  - file: app/frontend/locales/:locale.:digest.json&#xA;    patterns:&#xA;      - &#34;*&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output path can use the following placeholders:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;:locale&lt;/code&gt;: the language that&#39;s being exported.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;:digest&lt;/code&gt;: the MD5 hex digest of the exported file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Ruby API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;i18n-js&#34;&#xA;&#xA;I18nJS.call(config_file: &#34;config/i18n.yml&#34;)&#xA;I18nJS.call(config: config)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The CLI API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ i18n --help&#xA;Usage: i18n COMMAND FLAGS&#xA;&#xA;Commands:&#xA;&#xA;- init: Initialize a project&#xA;- export: Export translations as JSON files&#xA;- version: Show package version&#xA;- check: Check for missing translations&#xA;&#xA;Run `i18n COMMAND --help` for more information on specific commands.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;i18n&lt;/code&gt; will use &lt;code&gt;config/i18n.yml&lt;/code&gt; and &lt;code&gt;config/environment.rb&lt;/code&gt; as the configuration files. If you don&#39;t have these files, then you&#39;ll need to specify both &lt;code&gt;--config&lt;/code&gt; and &lt;code&gt;--require&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Listing missing translations&lt;/h3&gt; &#xA;&lt;p&gt;To list missing and extraneous translations, you can use &lt;code&gt;i18n check&lt;/code&gt;. This command will load your translations similarly to how &lt;code&gt;i18n export&lt;/code&gt; does, but will output the list of keys that don&#39;t have a matching translation against the default locale. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/fnando/i18n-js/raw/main/images/i18njs-check.gif&#34; alt=&#34;i18n check command in action&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This command will exist with status 1 whenever there are missing translations. This way you can use it as a CI linting.&lt;/p&gt; &#xA;&lt;p&gt;You can ignore keys by adding a list to the config file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---&#xA;translations:&#xA;  - file: app/frontend/locales/en.json&#xA;    patterns:&#xA;      - &#34;*&#34;&#xA;      - &#34;!*.activerecord&#34;&#xA;      - &#34;!*.errors&#34;&#xA;      - &#34;!*.number.nth&#34;&#xA;&#xA;  - file: app/frontend/locales/:locale.:digest.json&#xA;    patterns:&#xA;      - &#34;*&#34;&#xA;&#xA;check:&#xA;  ignore:&#xA;    - en.mailer.login.subject&#xA;    - en.mailer.login.body&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt; &#xA; &lt;p&gt;In order to avoid mistakenly ignoring keys, this configuration option only accepts the full translation scope, rather than accepting a pattern like &lt;code&gt;pt.ignored.scope.*&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Automatically export translations&lt;/h2&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://facebook.github.io/watchman/&#34;&gt;watchman&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Create a script at &lt;code&gt;bin/i18n-watch&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash&#xA;&#xA;root=`pwd`&#xA;&#xA;watchman watch-del &#34;$root&#34;&#xA;watchman watch-project &#34;$root&#34;&#xA;watchman trigger-del &#34;$root&#34; i18n&#xA;&#xA;watchman -j &amp;lt;&amp;lt;-JSON&#xA;[&#xA;  &#34;trigger&#34;,&#xA;  &#34;$root&#34;,&#xA;  {&#xA;    &#34;name&#34;: &#34;i18n&#34;,&#xA;    &#34;expression&#34;: [&#xA;      &#34;anyof&#34;,&#xA;      [&#34;match&#34;, &#34;config/locales/**/*.yml&#34;, &#34;wholename&#34;],&#xA;      [&#34;match&#34;, &#34;config/i18n.yml&#34;, &#34;wholename&#34;]&#xA;    ],&#xA;    &#34;command&#34;: [&#34;i18n&#34;, &#34;export&#34;]&#xA;  }&#xA;]&#xA;JSON&#xA;&#xA;# If you&#39;re running this through Foreman,&#xA;# the uncomment the following lines:&#xA;# while true; do&#xA;#   sleep 1&#xA;# done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make it executable with &lt;code&gt;chmod +x bin/i18n-watch&lt;/code&gt;. To watch for changes, run &lt;code&gt;./bin/i18n-watch&lt;/code&gt;. If you&#39;re using Foreman, make sure you uncommented the lines that keep the process running (&lt;code&gt;while..&lt;/code&gt;), and add something like the following line to your Procfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;i18n: ./bin/i18n-watch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://rubygems.org/gems/guard&#34;&gt;guard&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://rubygems.org/gems/guard&#34;&gt;guard&lt;/a&gt; and &lt;a href=&#34;https://rubygems.org/gems/guard-compat&#34;&gt;guard-compat&lt;/a&gt;. Then create a Guardfile with the following configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;guard(:&#34;i18n-js&#34;,&#xA;      run_on_start: true,&#xA;      config_file: &#34;./config/i18n.yml&#34;,&#xA;      require_file: &#34;./config/environment.rb&#34;) do&#xA;  watch(%r{^(app|config)/locales/.+\.(yml|po)$})&#xA;  watch(%r{^config/i18n.yml$})&#xA;  watch(&#34;Gemfile&#34;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your files are located in a different path, remember to configure file paths accordingly.&lt;/p&gt; &#xA;&lt;p&gt;Now you can run &lt;code&gt;guard start -i&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Using &lt;a href=&#34;https://rubygems.org/gems/listen&#34;&gt;listen&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Create a file under &lt;code&gt;config/initializers/i18n.rb&lt;/code&gt; with the following content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rails.application.config.after_initialize do&#xA;  require &#34;i18n-js/listen&#34;&#xA;  I18nJS.listen&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code above will watch for changes based on &lt;code&gt;config/i18n.yml&lt;/code&gt; and &lt;code&gt;config/locales&lt;/code&gt;. You can customize these options with &lt;code&gt;I18nJS.listen(config_file: &#34;config/i18n.yml&#34;, locales_dir: &#34;config/locales&#34;)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Integrating with your frontend&lt;/h3&gt; &#xA;&lt;p&gt;You&#39;re done exporting files, now what? Well, go to &lt;a href=&#34;https://github.com/fnando/i18n&#34;&gt;i18n&lt;/a&gt; to discover how to use the NPM package that loads all the exported translation.&lt;/p&gt; &#xA;&lt;h3&gt;FAQ&lt;/h3&gt; &#xA;&lt;h4&gt;I&#39;m running v3. Is there a migration plan?&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fnando/i18n-js/tree/main/MIGRATING_FROM_V3_TO_V4.md&#34;&gt;There&#39;s a document&lt;/a&gt; outlining some of the things you need to do to migrate from v3 to v4. It may not be as complete as we&#39;d like it to be, so let&#39;s know if you face any issues during the migration is not outline is that document.&lt;/p&gt; &#xA;&lt;h4&gt;How can I export translations without having a database around?&lt;/h4&gt; &#xA;&lt;p&gt;Some people may have a build process using something like Docker that don&#39;t necessarily have a database available. In this case, you may define your own loading file by using something like &lt;code&gt;i18n export --require ./config/i18n_export.rb&lt;/code&gt;, where &lt;code&gt;i18n_export.rb&lt;/code&gt; may look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# frozen_string_literal: true&#xA;&#xA;require &#34;bundler/setup&#34;&#xA;require &#34;rails&#34;&#xA;require &#34;active_support/railtie&#34;&#xA;require &#34;action_view/railtie&#34;&#xA;&#xA;I18n.load_path += Dir[&#34;./config/locales/**/*.yml&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt; &#xA; &lt;p&gt;You may not need to load ActiveSupport and ActionView lines, or even may need to add additional requires for other libs. With this approach you have full control on what&#39;s going to be loaded.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Maintainer&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fnando&#34;&gt;Nando Vieira&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fnando/i18n-js/contributors&#34;&gt;https://github.com/fnando/i18n-js/contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;For more details about how to contribute, please read &lt;a href=&#34;https://github.com/fnando/i18n-js/raw/main/CONTRIBUTING.md&#34;&gt;https://github.com/fnando/i18n-js/blob/main/CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The gem is available as open source under the terms of the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;. A copy of the license can be found at &lt;a href=&#34;https://github.com/fnando/i18n-js/raw/main/LICENSE.md&#34;&gt;https://github.com/fnando/i18n-js/blob/main/LICENSE.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;Everyone interacting in the i18n-js project&#39;s codebases, issue trackers, chat rooms and mailing lists is expected to follow the &lt;a href=&#34;https://github.com/fnando/i18n-js/raw/main/CODE_OF_CONDUCT.md&#34;&gt;code of conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rails/jsbundling-rails</title>
    <updated>2022-08-04T01:32:48Z</updated>
    <id>tag:github.com,2022-08-04:/rails/jsbundling-rails</id>
    <link href="https://github.com/rails/jsbundling-rails" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Bundle and transpile JavaScript in Rails with esbuild, rollup.js, or Webpack.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;JavaScript Bundling for Rails&lt;/h1&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://esbuild.github.io&#34;&gt;esbuild&lt;/a&gt;, &lt;a href=&#34;https://rollupjs.org&#34;&gt;rollup.js&lt;/a&gt;, or &lt;a href=&#34;https://webpack.js.org&#34;&gt;Webpack&lt;/a&gt; to bundle your JavaScript, then deliver it via the asset pipeline in Rails. This gem provides installers to get you going with the bundler of your choice in a new Rails application, and a convention to use &lt;code&gt;app/assets/builds&lt;/code&gt; to hold your bundled output as artifacts that are not checked into source control (the installer adds this directory to &lt;code&gt;.gitignore&lt;/code&gt; by default).&lt;/p&gt; &#xA;&lt;p&gt;You develop using this approach by running the bundler in watch mode in a terminal with &lt;code&gt;yarn build --watch&lt;/code&gt; (and your Rails server in another, if you&#39;re not using something like &lt;a href=&#34;https://github.com/puma/puma-dev&#34;&gt;puma-dev&lt;/a&gt;). You can also use &lt;code&gt;./bin/dev&lt;/code&gt;, which will start both the Rails server and the JS build watcher (along with a CSS build watcher, if you&#39;re also using &lt;code&gt;cssbundling-rails&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Whenever the bundler detects changes to any of the JavaScript files in your project, it&#39;ll bundle &lt;code&gt;app/javascript/application.js&lt;/code&gt; into &lt;code&gt;app/assets/builds/application.js&lt;/code&gt; (and all other entry points configured). You can refer to the build output in your layout using the standard asset pipeline approach with &lt;code&gt;&amp;lt;%= javascript_include_tag &#34;application&#34;, defer: true %&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When you deploy your application to production, the &lt;code&gt;javascript:build&lt;/code&gt; task attaches to the &lt;code&gt;assets:precompile&lt;/code&gt; task to ensure that all your package dependencies from &lt;code&gt;package.json&lt;/code&gt; have been installed via yarn, and then runs &lt;code&gt;yarn build&lt;/code&gt; to process all the entry points, as it would in development. The latter files are then picked up by the asset pipeline, digested, and copied into public/assets, as any other asset pipeline file.&lt;/p&gt; &#xA;&lt;p&gt;This also happens in testing where the bundler attaches to the &lt;code&gt;test:prepare&lt;/code&gt; task to ensure the JavaScript has been bundled before testing commences. (Note that this currently only applies to rails &lt;code&gt;test:*&lt;/code&gt; tasks (like &lt;code&gt;test:all&lt;/code&gt; or &lt;code&gt;test:controllers&lt;/code&gt;), not &#34;rails test&#34;, as that doesn&#39;t load &lt;code&gt;test:prepare&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If your testing library of choice does not define a &lt;code&gt;test:prepare&lt;/code&gt; Rake task, ensure that your test suite runs &lt;code&gt;javascript:build&lt;/code&gt; to bundle JavaScript before testing commences.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s it!&lt;/p&gt; &#xA;&lt;p&gt;You can configure your bundler options in the &lt;code&gt;build&lt;/code&gt; script in &lt;code&gt;package.json&lt;/code&gt; or via the installer-generated &lt;code&gt;rollup.config.js&lt;/code&gt; for rollup.js or &lt;code&gt;webpack.config.json&lt;/code&gt; for Webpack (esbuild does not have a default configuration format, and we don&#39;t intend to use esbuild as an API in order to hack around it).&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re already using &lt;a href=&#34;https://github.com/rails/webpacker&#34;&gt;&lt;code&gt;webpacker&lt;/code&gt;&lt;/a&gt; and you&#39;re wondering if you should migrate to &lt;code&gt;jsbundling-rails&lt;/code&gt;, have a look at &lt;a href=&#34;https://raw.githubusercontent.com/rails/jsbundling-rails/main/docs/comparison_with_webpacker.md&#34;&gt;the high-level comparison&lt;/a&gt;. If you&#39;re looking to migrate from webpacker, see the &lt;a href=&#34;https://github.com/rails/jsbundling-rails/raw/main/docs/switch_from_webpacker.md&#34;&gt;migration guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use webpack features like &lt;a href=&#34;https://webpack.js.org/guides/code-splitting/&#34;&gt;code splitting&lt;/a&gt; and &lt;a href=&#34;https://webpack.js.org/concepts/hot-module-replacement/&#34;&gt;hot module reloading&lt;/a&gt;, consider using the official fork of &lt;code&gt;webpacker&lt;/code&gt;, &lt;a href=&#34;https://github.com/shakacode/shakapacker&#34;&gt;&lt;code&gt;shakapacker&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;You must already have node and yarn installed on your system. You will also need npx version 7.1.0 or later. Then:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run &lt;code&gt;./bin/bundle add jsbundling-rails&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;./bin/rails javascript:install:[esbuild|rollup|webpack]&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Or, in Rails 7+, you can preconfigure your new application to use a specific bundler with &lt;code&gt;rails new myapp -j [esbuild|rollup|webpack]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Is there a work-around for lack of glob syntax on Windows?&lt;/h3&gt; &#xA;&lt;p&gt;The default build script for esbuild relies on the &lt;code&gt;app/javascript/*.*&lt;/code&gt; glob pattern to compile multiple entrypoints automatically. This glob pattern is not available by default on Windows, so you need to change the build script in &lt;code&gt;package.json&lt;/code&gt; to manually list the entrypoints you wish to compile.&lt;/p&gt; &#xA;&lt;h3&gt;Why does esbuild overwrite my application.css?&lt;/h3&gt; &#xA;&lt;p&gt;If you &lt;a href=&#34;https://esbuild.github.io/content-types/#css-from-js&#34;&gt;import CSS&lt;/a&gt; in your application.js while using esbuild, you&#39;ll be creating both an &lt;code&gt;app/assets/builds/application.js&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; &lt;code&gt;app/assets/builds/application.css&lt;/code&gt; file when bundling. The latter can conflict with the &lt;code&gt;app/assets/builds/application.css&lt;/code&gt; produced by &lt;a href=&#34;https://github.com/rails/cssbundling-rails&#34;&gt;cssbundling-rails&lt;/a&gt;. The solution is to either change the output file for esbuild (and the references for that) or for cssbundling. Both are specified in &lt;code&gt;package.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How can I reference static assets in JavaScript code?&lt;/h3&gt; &#xA;&lt;p&gt;Suppose you have an image &lt;code&gt;app/javascript/images/example.png&lt;/code&gt; that you need to reference in frontend code built with esbuild.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create the image at &lt;code&gt;app/javascript/images/example.png&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In &lt;code&gt;package.json&lt;/code&gt;, under &lt;code&gt;&#34;scripts&#34;&lt;/code&gt; and &lt;code&gt;&#34;build&#34;&lt;/code&gt;, add the option &lt;code&gt;--loader:.png=file&lt;/code&gt; to the esbuild script, which instructs esbuild to copy png files to the build directory.&lt;/li&gt; &#xA; &lt;li&gt;When esbuild runs, it will copy the png file to something like &lt;code&gt;app/assets/builds/example-5SRKKTLZ.png&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In frontend code, the image is available for import by its original name: &lt;code&gt;import Example from &#34;../images/example.png&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The image itself can now be referenced by its imported name, e.g. in React, &lt;code&gt;&amp;lt;img src={Example} /&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The path of the image resolves to &lt;code&gt;/assets/example-5SRKKTLZ.png&lt;/code&gt;, which is served by the asset pipeline.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;JavaScript Bundling for Rails is released under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>