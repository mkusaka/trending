<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-17T01:43:41Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Shopify/bootsnap</title>
    <updated>2024-01-17T01:43:41Z</updated>
    <id>tag:github.com,2024-01-17:/Shopify/bootsnap</id>
    <link href="https://github.com/Shopify/bootsnap" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Boot large Ruby/Rails apps faster&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bootsnap &lt;a href=&#34;https://github.com/Shopify/bootsnap/actions&#34;&gt;&lt;img src=&#34;https://github.com/Shopify/bootsnap/workflows/ci/badge.svg?sanitize=true&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Bootsnap is a library that plugs into Ruby, with optional support for &lt;code&gt;YAML&lt;/code&gt; and &lt;code&gt;JSON&lt;/code&gt;, to optimize and cache expensive computations. See &lt;a href=&#34;https://raw.githubusercontent.com/Shopify/bootsnap/main/#how-does-this-work&#34;&gt;How Does This Work&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Performance&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/discourse/discourse&#34;&gt;Discourse&lt;/a&gt; reports a boot time reduction of approximately 50%, from roughly 6 to 3 seconds on one machine;&lt;/li&gt; &#xA; &lt;li&gt;One of our smaller internal apps also sees a reduction of 50%, from 3.6 to 1.8 seconds;&lt;/li&gt; &#xA; &lt;li&gt;The core Shopify platform -- a rather large monolithic application -- boots about 75% faster, dropping from around 25s to 6.5s.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;In Shopify core (a large app), about 25% of this gain can be attributed to &lt;code&gt;compile_cache_*&lt;/code&gt; features; 75% to path caching. This is fairly representative.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;This gem works on macOS and Linux.&lt;/p&gt; &#xA;&lt;p&gt;Add &lt;code&gt;bootsnap&lt;/code&gt; to your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;bootsnap&#39;, require: false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using Rails, add this to &lt;code&gt;config/boot.rb&lt;/code&gt; immediately after &lt;code&gt;require &#39;bundler/setup&#39;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;bootsnap/setup&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that bootsnap writes to &lt;code&gt;tmp/cache&lt;/code&gt; (or the path specified by &lt;code&gt;ENV[&#39;BOOTSNAP_CACHE_DIR&#39;]&lt;/code&gt;), and that directory &lt;em&gt;must&lt;/em&gt; be writable. Rails will fail to boot if it is not. If this is unacceptable (e.g. you are running in a read-only container and unwilling to mount in a writable tmpdir), you should remove this line or wrap it in a conditional.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note also that bootsnap will never clean up its own cache: this is left up to you. Depending on your deployment strategy, you may need to periodically purge &lt;code&gt;tmp/cache/bootsnap*&lt;/code&gt;. If you notice deploys getting progressively slower, this is almost certainly the cause.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s technically possible to simply specify &lt;code&gt;gem &#39;bootsnap&#39;, require: &#39;bootsnap/setup&#39;&lt;/code&gt;, but it&#39;s important to load Bootsnap as early as possible to get maximum performance improvement.&lt;/p&gt; &#xA;&lt;p&gt;You can see how this require works &lt;a href=&#34;https://github.com/Shopify/bootsnap/raw/main/lib/bootsnap/setup.rb&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are not using Rails, or if you are but want more control over things, add this to your application setup immediately after &lt;code&gt;require &#39;bundler/setup&#39;&lt;/code&gt; (i.e. as early as possible: the sooner this is loaded, the sooner it can start optimizing things)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;bootsnap&#39;&#xA;env = ENV[&#39;RAILS_ENV&#39;] || &#34;development&#34;&#xA;Bootsnap.setup(&#xA;  cache_dir:            &#39;tmp/cache&#39;,          # Path to your cache&#xA;  ignore_directories:   [&#39;node_modules&#39;],     # Directory names to skip.&#xA;  development_mode:     env == &#39;development&#39;, # Current working environment, e.g. RACK_ENV, RAILS_ENV, etc&#xA;  load_path_cache:      true,                 # Optimize the LOAD_PATH with a cache&#xA;  compile_cache_iseq:   true,                 # Compile Ruby code into ISeq cache, breaks coverage reporting.&#xA;  compile_cache_yaml:   true,                 # Compile YAML into a cache&#xA;  compile_cache_json:   true,                 # Compile JSON into a cache&#xA;  readonly:             true,                 # Use the caches but don&#39;t update them on miss or stale entries.&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Protip:&lt;/strong&gt; You can replace &lt;code&gt;require &#39;bootsnap&#39;&lt;/code&gt; with &lt;code&gt;BootLib::Require.from_gem(&#39;bootsnap&#39;, &#39;bootsnap&#39;)&lt;/code&gt; using &lt;a href=&#34;https://github.com/Shopify/bootsnap/wiki/Bootlib::Require&#34;&gt;this trick&lt;/a&gt;. This will help optimize boot time further if you have an extremely large &lt;code&gt;$LOAD_PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: Bootsnap and &lt;a href=&#34;https://github.com/rails/spring&#34;&gt;Spring&lt;/a&gt; are orthogonal tools. While Bootsnap speeds up the loading of individual source files, Spring keeps a copy of a pre-booted Rails process on hand to completely skip parts of the boot process the next time it&#39;s needed. The two tools work well together.&lt;/p&gt; &#xA;&lt;h3&gt;Environment variables&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;require &#39;bootsnap/setup&#39;&lt;/code&gt; behavior can be changed using environment variables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;BOOTSNAP_CACHE_DIR&lt;/code&gt; allows to define the cache location.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DISABLE_BOOTSNAP&lt;/code&gt; allows to entirely disable bootsnap.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DISABLE_BOOTSNAP_LOAD_PATH_CACHE&lt;/code&gt; allows to disable load path caching.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DISABLE_BOOTSNAP_COMPILE_CACHE&lt;/code&gt; allows to disable ISeq and YAML caches.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BOOTSNAP_READONLY&lt;/code&gt; configure bootsnap to not update the cache on miss or stale entries.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BOOTSNAP_LOG&lt;/code&gt; configure bootsnap to log all caches misses to STDERR.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BOOTSNAP_IGNORE_DIRECTORIES&lt;/code&gt; a comma separated list of directories that shouldn&#39;t be scanned. Useful when you have large directories of non-ruby files inside &lt;code&gt;$LOAD_PATH&lt;/code&gt;. It defaults to ignore any directory named &lt;code&gt;node_modules&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Environments&lt;/h3&gt; &#xA;&lt;p&gt;All Bootsnap features are enabled in development, test, production, and all other environments according to the configuration in the setup. At Shopify, we use this gem safely in all environments without issue.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to disable any feature for a certain environment, we suggest changing the configuration to take into account the appropriate ENV var or configuration according to your needs.&lt;/p&gt; &#xA;&lt;h3&gt;Instrumentation&lt;/h3&gt; &#xA;&lt;p&gt;Bootsnap cache misses can be monitored though a callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Bootsnap.instrumentation = -&amp;gt;(event, path) { puts &#34;#{event} #{path}&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;event&lt;/code&gt; is either &lt;code&gt;:miss&lt;/code&gt; or &lt;code&gt;:stale&lt;/code&gt;. You can also call &lt;code&gt;Bootsnap.log!&lt;/code&gt; as a shortcut to log all events to STDERR.&lt;/p&gt; &#xA;&lt;p&gt;To turn instrumentation back off you can set it to nil:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Bootsnap.instrumentation = nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How does this work?&lt;/h2&gt; &#xA;&lt;p&gt;Bootsnap optimizes methods to cache results of expensive computations, and can be grouped into two broad categories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/bootsnap/main/#path-pre-scanning&#34;&gt;Path Pre-Scanning&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;Kernel#require&lt;/code&gt; and &lt;code&gt;Kernel#load&lt;/code&gt; are modified to eliminate &lt;code&gt;$LOAD_PATH&lt;/code&gt; scans.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Shopify/bootsnap/main/#compilation-caching&#34;&gt;Compilation caching&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;RubyVM::InstructionSequence.load_iseq&lt;/code&gt; is implemented to cache the result of ruby bytecode compilation.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;YAML.load_file&lt;/code&gt; is modified to cache the result of loading a YAML object in MessagePack format (or Marshal, if the message uses types unsupported by MessagePack).&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;JSON.load_file&lt;/code&gt; is modified to cache the result of loading a JSON object in MessagePack format&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Path Pre-Scanning&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;(This work is a minor evolution of &lt;a href=&#34;https://github.com/byroot/bootscale&#34;&gt;bootscale&lt;/a&gt;).&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Upon initialization of bootsnap or modification of the path (e.g. &lt;code&gt;$LOAD_PATH&lt;/code&gt;), &lt;code&gt;Bootsnap::LoadPathCache&lt;/code&gt; will fetch a list of requirable entries from a cache, or, if necessary, perform a full scan and cache the result.&lt;/p&gt; &#xA;&lt;p&gt;Later, when we run (e.g.) &lt;code&gt;require &#39;foo&#39;&lt;/code&gt;, ruby &lt;em&gt;would&lt;/em&gt; iterate through every item on our &lt;code&gt;$LOAD_PATH&lt;/code&gt; &lt;code&gt;[&#39;x&#39;, &#39;y&#39;, ...]&lt;/code&gt;, looking for &lt;code&gt;x/foo.rb&lt;/code&gt;, &lt;code&gt;y/foo.rb&lt;/code&gt;, and so on. Bootsnap instead looks at all the cached requirables for each &lt;code&gt;$LOAD_PATH&lt;/code&gt; entry and substitutes the full expanded path of the match ruby would have eventually chosen.&lt;/p&gt; &#xA;&lt;p&gt;If you look at the syscalls generated by this behaviour, the net effect is that what would previously look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open  x/foo.rb # (fail)&#xA;# (imagine this with 500 $LOAD_PATH entries instead of two)&#xA;open  y/foo.rb # (success)&#xA;close y/foo.rb&#xA;open  y/foo.rb&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;becomes this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open y/foo.rb&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following diagram flowcharts the overrides that make the &lt;code&gt;*_path_cache&lt;/code&gt; features work.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/3074765/24532120/eed94e64-158b-11e7-9137-438d759b2ac8.png&#34; alt=&#34;Flowchart explaining Bootsnap&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Bootsnap classifies path entries into two categories: stable and volatile. Volatile entries are scanned each time the application boots, and their caches are only valid for 30 seconds. Stable entries do not expire -- once their contents has been scanned, it is assumed to never change.&lt;/p&gt; &#xA;&lt;p&gt;The only directories considered &#34;stable&#34; are things under the Ruby install prefix (&lt;code&gt;RbConfig::CONFIG[&#39;prefix&#39;]&lt;/code&gt;, e.g. &lt;code&gt;/usr/local/ruby&lt;/code&gt; or &lt;code&gt;~/.rubies/x.y.z&lt;/code&gt;), and things under the &lt;code&gt;Gem.path&lt;/code&gt; (e.g. &lt;code&gt;~/.gem/ruby/x.y.z&lt;/code&gt;) or &lt;code&gt;Bundler.bundle_path&lt;/code&gt;. Everything else is considered &#34;volatile&#34;.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the &lt;a href=&#34;https://github.com/Shopify/bootsnap/raw/main/lib/bootsnap/load_path_cache/cache.rb&#34;&gt;&lt;code&gt;Bootsnap::LoadPathCache::Cache&lt;/code&gt; source&lt;/a&gt;, this diagram may help clarify how entry resolution works:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/3074765/25388270/670b5652-299b-11e7-87fb-975647f68981.png&#34; alt=&#34;How path searching works&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also important to note how expensive &lt;code&gt;LoadError&lt;/code&gt;s can be. If ruby invokes &lt;code&gt;require &#39;something&#39;&lt;/code&gt;, but that file isn&#39;t on &lt;code&gt;$LOAD_PATH&lt;/code&gt;, it takes &lt;code&gt;2 * $LOAD_PATH.length&lt;/code&gt; filesystem accesses to determine that. Bootsnap caches this result too, raising a &lt;code&gt;LoadError&lt;/code&gt; without touching the filesystem at all.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation Caching&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;(A more readable implementation of this concept can be found in &lt;a href=&#34;https://github.com/ko1/yomikomu&#34;&gt;yomikomu&lt;/a&gt;).&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ruby has complex grammar and parsing it is not a particularly cheap operation. Since 1.9, Ruby has translated ruby source to an internal bytecode format, which is then executed by the Ruby VM. Since 2.3.0, Ruby &lt;a href=&#34;https://ruby-doc.org/core-2.3.0/RubyVM/InstructionSequence.html&#34;&gt;exposes an API&lt;/a&gt; that allows caching that bytecode. This allows us to bypass the relatively-expensive compilation step on subsequent loads of the same file.&lt;/p&gt; &#xA;&lt;p&gt;We also noticed that we spend a lot of time loading YAML and JSON documents during our application boot, and that MessagePack and Marshal are &lt;em&gt;much&lt;/em&gt; faster at deserialization than YAML and JSON, even with a fast implementation. We use the same strategy of compilation caching for YAML and JSON documents, with the equivalent of Ruby&#39;s &#34;bytecode&#34; format being a MessagePack document (or, in the case of YAML documents with types unsupported by MessagePack, a Marshal stream).&lt;/p&gt; &#xA;&lt;p&gt;These compilation results are stored in a cache directory, with filenames generated by taking a hash of the full expanded path of the input file (FNV1a-64).&lt;/p&gt; &#xA;&lt;p&gt;Whereas before, the sequence of syscalls generated to &lt;code&gt;require&lt;/code&gt; a file would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open    /c/foo.rb -&amp;gt; m&#xA;fstat64 m&#xA;close   m&#xA;open    /c/foo.rb -&amp;gt; o&#xA;fstat64 o&#xA;fstat64 o&#xA;read    o&#xA;read    o&#xA;...&#xA;close   o&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With bootsnap, we get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open      /c/foo.rb -&amp;gt; n&#xA;fstat64   n&#xA;close     n&#xA;open      /c/foo.rb -&amp;gt; n&#xA;fstat64   n&#xA;open      (cache) -&amp;gt; m&#xA;read      m&#xA;read      m&#xA;close     m&#xA;close     n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This may look worse at a glance, but underlies a large performance difference.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;(The first three syscalls in both listings -- &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;fstat64&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; -- are not inherently useful. &lt;a href=&#34;https://bugs.ruby-lang.org/issues/13378&#34;&gt;This ruby patch&lt;/a&gt; optimizes them out when coupled with bootsnap.)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Bootsnap writes a cache file containing a 64 byte header followed by the cache contents. The header is a cache key including several fields:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;version&lt;/code&gt;, hardcoded in bootsnap. Essentially a schema version;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ruby_platform&lt;/code&gt;, A hash of &lt;code&gt;RUBY_PLATFORM&lt;/code&gt; (e.g. x86_64-linux-gnu) variable.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;compile_option&lt;/code&gt;, which changes with &lt;code&gt;RubyVM::InstructionSequence.compile_option&lt;/code&gt; does;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ruby_revision&lt;/code&gt;, A hash of &lt;code&gt;RUBY_REVISION&lt;/code&gt;, the exact version of Ruby;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;size&lt;/code&gt;, the size of the source file;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mtime&lt;/code&gt;, the last-modification timestamp of the source file when it was compiled; and&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;data_size&lt;/code&gt;, the number of bytes following the header, which we need to read it into a buffer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If the key is valid, the result is loaded from the value. Otherwise, it is regenerated and clobbers the current cache.&lt;/p&gt; &#xA;&lt;h3&gt;Putting it all together&lt;/h3&gt; &#xA;&lt;p&gt;Imagine we have this file structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/&#xA;├── a&#xA;├── b&#xA;└── c&#xA;    └── foo.rb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And this &lt;code&gt;$LOAD_PATH&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[&#34;/a&#34;, &#34;/b&#34;, &#34;/c&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When we call &lt;code&gt;require &#39;foo&#39;&lt;/code&gt; without bootsnap, Ruby would generate this sequence of syscalls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open    /a/foo.rb -&amp;gt; -1&#xA;open    /b/foo.rb -&amp;gt; -1&#xA;open    /c/foo.rb -&amp;gt; n&#xA;close   n&#xA;open    /c/foo.rb -&amp;gt; m&#xA;fstat64 m&#xA;close   m&#xA;open    /c/foo.rb -&amp;gt; o&#xA;fstat64 o&#xA;fstat64 o&#xA;read    o&#xA;read    o&#xA;...&#xA;close   o&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With bootsnap, we get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open      /c/foo.rb -&amp;gt; n&#xA;fstat64   n&#xA;close     n&#xA;open      /c/foo.rb -&amp;gt; n&#xA;fstat64   n&#xA;open      (cache) -&amp;gt; m&#xA;read      m&#xA;read      m&#xA;close     m&#xA;close     n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we call &lt;code&gt;require &#39;nope&#39;&lt;/code&gt; without bootsnap, we get:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;open    /a/nope.rb -&amp;gt; -1&#xA;open    /b/nope.rb -&amp;gt; -1&#xA;open    /c/nope.rb -&amp;gt; -1&#xA;open    /a/nope.bundle -&amp;gt; -1&#xA;open    /b/nope.bundle -&amp;gt; -1&#xA;open    /c/nope.bundle -&amp;gt; -1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...and if we call &lt;code&gt;require &#39;nope&#39;&lt;/code&gt; &lt;em&gt;with&lt;/em&gt; bootsnap, we get...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# (nothing!)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Precompilation&lt;/h2&gt; &#xA;&lt;p&gt;In development environments the bootsnap compilation cache is generated on the fly when source files are loaded. But in production environments, such as docker images, you might need to precompile the cache.&lt;/p&gt; &#xA;&lt;p&gt;To do so you can use the &lt;code&gt;bootsnap precompile&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle exec bootsnap precompile --gemfile app/ lib/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;When not to use Bootsnap&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Alternative engines&lt;/em&gt;: Bootsnap is pretty reliant on MRI features, and parts are disabled entirely on alternative ruby engines.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Non-local filesystems&lt;/em&gt;: Bootsnap depends on &lt;code&gt;tmp/cache&lt;/code&gt; (or whatever you set its cache directory to) being on a relatively fast filesystem. If you put it on a network mount, bootsnap is very likely to slow your application down quite a lot.&lt;/p&gt;</summary>
  </entry>
</feed>