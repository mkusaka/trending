<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-18T01:44:12Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>alexreisner/geocoder</title>
    <updated>2023-05-18T01:44:12Z</updated>
    <id>tag:github.com,2023-05-18:/alexreisner/geocoder</id>
    <link href="https://github.com/alexreisner/geocoder" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Complete Ruby geocoding solution.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Geocoder&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Complete geocoding solution for Ruby.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://badge.fury.io/rb/geocoder&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/geocoder.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/alexreisner/geocoder&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/alexreisner/geocoder/badges/gpa.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://travis-ci.com/alexreisner/geocoder&#34;&gt;&lt;img src=&#34;https://travis-ci.com/alexreisner/geocoder.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Key features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Forward and reverse geocoding.&lt;/li&gt; &#xA; &lt;li&gt;IP address geocoding.&lt;/li&gt; &#xA; &lt;li&gt;Connects to more than 40 APIs worldwide.&lt;/li&gt; &#xA; &lt;li&gt;Performance-enhancing features like caching.&lt;/li&gt; &#xA; &lt;li&gt;Integrates with ActiveRecord and Mongoid.&lt;/li&gt; &#xA; &lt;li&gt;Basic geospatial queries: search within radius (or rectangle, or ring).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compatibility:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruby versions: 2.1+, and JRuby.&lt;/li&gt; &#xA; &lt;li&gt;Databases: MySQL, PostgreSQL, SQLite, and MongoDB.&lt;/li&gt; &#xA; &lt;li&gt;Rails: 5.x, 6.x, and 7.x.&lt;/li&gt; &#xA; &lt;li&gt;Works outside of Rails with the &lt;code&gt;json&lt;/code&gt; (for MRI) or &lt;code&gt;json_pure&lt;/code&gt; (for JRuby) gem.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;p&gt;Basic Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#basic-search&#34;&gt;Basic Search&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#geocoding-objects&#34;&gt;Geocoding Objects&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#geospatial-database-queries&#34;&gt;Geospatial Database Queries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#geocoding-http-requests&#34;&gt;Geocoding HTTP Requests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#geocoding-service-lookup-configuration&#34;&gt;Geocoding Service (&#34;Lookup&#34;) Configuration&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Advanced Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#performance-and-optimization&#34;&gt;Performance and Optimization&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#advanced-model-configuration&#34;&gt;Advanced Model Configuration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#advanced-database-queries&#34;&gt;Advanced Database Queries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#geospatial-calculations&#34;&gt;Geospatial Calculations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#batch-geocoding&#34;&gt;Batch Geocoding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#testing&#34;&gt;Testing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#error-handling&#34;&gt;Error Handling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#command-line-interface&#34;&gt;Command Line Interface&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Rest:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#technical-discussions&#34;&gt;Technical Discussions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#known-issues&#34;&gt;Known Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/CONTRIBUTING.md#reporting-bugs&#34;&gt;Reporting Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/CONTRIBUTING.md#making-changes&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See Also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/README_API_GUIDE.md&#34;&gt;Guide to Geocoding APIs&lt;/a&gt; (formerly part of this README)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Basic Search&lt;/h2&gt; &#xA;&lt;p&gt;In its simplest form, Geocoder takes an address and searches for its latitude/longitude coordinates:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results = Geocoder.search(&#34;Paris&#34;)&#xA;results.first.coordinates&#xA;# =&amp;gt; [48.856614, 2.3522219]  # latitude and longitude&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reverse is possible too. Given coordinates, it finds an address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results = Geocoder.search([48.856614, 2.3522219])&#xA;results.first.address&#xA;# =&amp;gt; &#34;HÃ´tel de Ville, 75004 Paris, France&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also look up the location of an IP address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;results = Geocoder.search(&#34;172.56.21.89&#34;)&#xA;results.first.coordinates&#xA;# =&amp;gt; [30.267153, -97.7430608]&#xA;results.first.country&#xA;# =&amp;gt; &#34;United States&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;The success and accuracy of geocoding depends entirely on the API being used to do these lookups.&lt;/strong&gt; Most queries work fairly well with the default configuration, but every application has different needs and every API has its particular strengths and weaknesses. If you need better coverage for your application you&#39;ll want to get familiar with the large number of supported APIs, listed in the &lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/README_API_GUIDE.md&#34;&gt;API Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Geocoding Objects&lt;/h2&gt; &#xA;&lt;p&gt;To automatically geocode your objects:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; Your model must provide a method that returns an address to geocode. This can be a single attribute, but it can also be a method that returns a string assembled from different attributes (eg: &lt;code&gt;city&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, and &lt;code&gt;country&lt;/code&gt;). For example, if your model has &lt;code&gt;street&lt;/code&gt;, &lt;code&gt;city&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, and &lt;code&gt;country&lt;/code&gt; attributes you might do something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def address&#xA;  [street, city, state, country].compact.join(&#39;, &#39;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Your model must have a way to store latitude/longitude coordinates. With ActiveRecord, add two attributes/columns (of type float or decimal) called &lt;code&gt;latitude&lt;/code&gt; and &lt;code&gt;longitude&lt;/code&gt;. For MongoDB, use a single field (of type Array) called &lt;code&gt;coordinates&lt;/code&gt; (i.e., &lt;code&gt;field :coordinates, type: Array&lt;/code&gt;). (See &lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#advanced-model-configuration&#34;&gt;Advanced Model Configuration&lt;/a&gt; for using different attribute names.)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; In your model, tell geocoder where to find the object&#39;s address:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;geocoded_by :address&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This adds a &lt;code&gt;geocode&lt;/code&gt; method which you can invoke via callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;after_validation :geocode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reverse geocoding (given lat/lon coordinates, find an address) is similar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;reverse_geocoded_by :latitude, :longitude&#xA;after_validation :reverse_geocode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With any geocoded objects, you can do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;obj.distance_to([43.9,-98.6])  # distance from obj to point&#xA;obj.bearing_to([43.9,-98.6])   # bearing from obj to point&#xA;obj.bearing_from(obj2)         # bearing from obj2 to obj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;bearing_from/to&lt;/code&gt; methods take a single argument which can be: a &lt;code&gt;[lat,lon]&lt;/code&gt; array, a geocoded object, or a geocodable address (string). The &lt;code&gt;distance_from/to&lt;/code&gt; methods also take a units argument (&lt;code&gt;:mi&lt;/code&gt;, &lt;code&gt;:km&lt;/code&gt;, or &lt;code&gt;:nm&lt;/code&gt; for nautical miles). See &lt;a href=&#34;https://raw.githubusercontent.com/alexreisner/geocoder/master/#distance-and-bearing&#34;&gt;Distance and Bearing&lt;/a&gt; below for more info.&lt;/p&gt; &#xA;&lt;h3&gt;One More Thing for MongoDB!&lt;/h3&gt; &#xA;&lt;p&gt;Before you can call &lt;code&gt;geocoded_by&lt;/code&gt; you&#39;ll need to include the necessary module using one of the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;include Geocoder::Model::Mongoid&#xA;include Geocoder::Model::MongoMapper&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Latitude/Longitude Order in MongoDB&lt;/h3&gt; &#xA;&lt;p&gt;Everywhere coordinates are passed to methods as two-element arrays, Geocoder expects them to be in the order: &lt;code&gt;[lat, lon]&lt;/code&gt;. However, as per &lt;a href=&#34;http://geojson.org/geojson-spec.html#positions&#34;&gt;the GeoJSON spec&lt;/a&gt;, MongoDB requires that coordinates be stored longitude-first (&lt;code&gt;[lon, lat]&lt;/code&gt;), so internally they are stored &#34;backwards.&#34; Geocoder&#39;s methods attempt to hide this, so calling &lt;code&gt;obj.to_coordinates&lt;/code&gt; (a method added to the object by Geocoder via &lt;code&gt;geocoded_by&lt;/code&gt;) returns coordinates in the conventional order:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;obj.to_coordinates  # =&amp;gt; [37.7941013, -122.3951096] # [lat, lon]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;whereas calling the object&#39;s coordinates attribute directly (&lt;code&gt;obj.coordinates&lt;/code&gt; by default) returns the internal representation which is probably the reverse of what you want:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;obj.coordinates     # =&amp;gt; [-122.3951096, 37.7941013] # [lon, lat]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, be careful.&lt;/p&gt; &#xA;&lt;h3&gt;Use Outside of Rails&lt;/h3&gt; &#xA;&lt;p&gt;To use Geocoder with ActiveRecord and a framework other than Rails (like Sinatra or Padrino), you will need to add this in your model before calling Geocoder methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;extend Geocoder::Model::ActiveRecord&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Geospatial Database Queries&lt;/h2&gt; &#xA;&lt;h3&gt;For ActiveRecord models:&lt;/h3&gt; &#xA;&lt;p&gt;To find objects by location, use the following scopes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Venue.near(&#39;Omaha, NE, US&#39;)                   # venues within 20 miles of Omaha&#xA;Venue.near([40.71, -100.23], 50)              # venues within 50 miles of a point&#xA;Venue.near([40.71, -100.23], 50, units: :km)  # venues within 50 kilometres of a point&#xA;Venue.geocoded                                # venues with coordinates&#xA;Venue.not_geocoded                            # venues without coordinates&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With geocoded objects you can do things like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if obj.geocoded?&#xA;  obj.nearbys(30)                       # other objects within 30 miles&#xA;  obj.distance_from([40.714,-100.234])  # distance from arbitrary point to object&#xA;  obj.bearing_to(&#34;Paris, France&#34;)       # direction from object to arbitrary point&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;For MongoDB-backed models:&lt;/h3&gt; &#xA;&lt;p&gt;Please do not use Geocoder&#39;s &lt;code&gt;near&lt;/code&gt; method. Instead use MongoDB&#39;s built-in &lt;a href=&#34;https://docs.mongodb.org/manual/reference/command/geoNear/&#34;&gt;geospatial query language&lt;/a&gt;, which is faster. Mongoid also provides &lt;a href=&#34;http://mongoid.github.io/en/mongoid/docs/querying.html#geo_near&#34;&gt;a DSL&lt;/a&gt; for geospatial queries.&lt;/p&gt; &#xA;&lt;h2&gt;Geocoding HTTP Requests&lt;/h2&gt; &#xA;&lt;p&gt;Geocoder adds &lt;code&gt;location&lt;/code&gt; and &lt;code&gt;safe_location&lt;/code&gt; methods to the standard &lt;code&gt;Rack::Request&lt;/code&gt; object so you can easily look up the location of any HTTP request by IP address. For example, in a Rails controller or a Sinatra app:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# returns Geocoder::Result object&#xA;result = request.location&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;The &lt;code&gt;location&lt;/code&gt; method is vulnerable to trivial IP address spoofing via HTTP headers.&lt;/strong&gt; If that&#39;s a problem for your application, use &lt;code&gt;safe_location&lt;/code&gt; instead, but be aware that &lt;code&gt;safe_location&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; try to trace a request&#39;s originating IP through proxy headers; you will instead get the location of the last proxy the request passed through, if any (excepting any proxies you have explicitly whitelisted in your Rack config).&lt;/p&gt; &#xA;&lt;p&gt;Note that these methods will usually return &lt;code&gt;nil&lt;/code&gt; in test and development environments because things like &#34;localhost&#34; and &#34;0.0.0.0&#34; are not geocodable IP addresses.&lt;/p&gt; &#xA;&lt;h2&gt;Geocoding Service (&#34;Lookup&#34;) Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Geocoder supports a variety of street and IP address geocoding services. The default lookups are &lt;code&gt;:nominatim&lt;/code&gt; for street addresses and &lt;code&gt;:ipinfo_io&lt;/code&gt; for IP addresses. Please see the &lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/README_API_GUIDE.md&#34;&gt;API Guide&lt;/a&gt; for details on specific geocoding services (not all settings are supported by all services).&lt;/p&gt; &#xA;&lt;p&gt;To create a Rails initializer with sample configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails generate geocoder:config&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some common options are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/initializers/geocoder.rb&#xA;Geocoder.configure(&#xA;  # street address geocoding service (default :nominatim)&#xA;  lookup: :yandex,&#xA;&#xA;  # IP address geocoding service (default :ipinfo_io)&#xA;  ip_lookup: :maxmind,&#xA;&#xA;  # to use an API key:&#xA;  api_key: &#34;...&#34;,&#xA;&#xA;  # geocoding service request timeout, in seconds (default 3):&#xA;  timeout: 5,&#xA;&#xA;  # set default units to kilometers:&#xA;  units: :km,&#xA;&#xA;  # caching (see Caching section below for details):&#xA;  cache: Redis.new,&#xA;  cache_options: {&#xA;    expiration: 1.day, # Defaults to `nil`&#xA;    prefix: &#34;another_key:&#34; # Defaults to `geocoder:`&#xA;  }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/lib/geocoder/configuration.rb&#34;&gt;&lt;code&gt;lib/geocoder/configuration.rb&lt;/code&gt;&lt;/a&gt; for a complete list of configuration options. Additionally, some lookups have their own special configuration options which are directly supported by Geocoder. For example, to specify a value for Google&#39;s &lt;code&gt;bounds&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# with Google:&#xA;Geocoder.search(&#34;Middletown&#34;, bounds: [[40.6,-77.9], [39.9,-75.9]])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://github.com/alexreisner/geocoder/tree/master/lib/geocoder/lookups&#34;&gt;source code for each lookup&lt;/a&gt; to learn about directly supported parameters. Parameters which are not directly supported can be specified using the &lt;code&gt;:params&lt;/code&gt; option, which appends options to the query string of the geocoding request. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Nominatim&#39;s `countrycodes` parameter:&#xA;Geocoder.search(&#34;Rome&#34;, params: {countrycodes: &#34;us,ca&#34;})&#xA;&#xA;# Google&#39;s `region` parameter:&#xA;Geocoder.search(&#34;Rome&#34;, params: {region: &#34;...&#34;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuring Multiple Services&lt;/h3&gt; &#xA;&lt;p&gt;You can configure multiple geocoding services at once by using the service&#39;s name as a key for a sub-configuration hash, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(&#xA;&#xA;  timeout: 2,&#xA;  cache: Redis.new,&#xA;&#xA;  yandex: {&#xA;    api_key: &#34;...&#34;,&#xA;    timeout: 5&#xA;  },&#xA;&#xA;  baidu: {&#xA;    api_key: &#34;...&#34;&#xA;  },&#xA;&#xA;  maxmind: {&#xA;    api_key: &#34;...&#34;,&#xA;    service: :omni&#xA;  }&#xA;&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lookup-specific settings override global settings so, in this example, the timeout for all lookups is 2 seconds, except for Yandex which is 5.&lt;/p&gt; &#xA;&lt;h2&gt;Performance and Optimization&lt;/h2&gt; &#xA;&lt;h3&gt;Database Indices&lt;/h3&gt; &#xA;&lt;p&gt;In MySQL and Postgres, queries use a bounding box to limit the number of points over which a more precise distance calculation needs to be done. To take advantage of this optimisation, you need to add a composite index on latitude and longitude. In your Rails migration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;add_index :table, [:latitude, :longitude]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In MongoDB, by default, the methods &lt;code&gt;geocoded_by&lt;/code&gt; and &lt;code&gt;reverse_geocoded_by&lt;/code&gt; create a geospatial index. You can avoid index creation with the &lt;code&gt;:skip_index option&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;include Geocoder::Model::Mongoid&#xA;geocoded_by :address, skip_index: true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Avoiding Unnecessary API Requests&lt;/h3&gt; &#xA;&lt;p&gt;Geocoding only needs to be performed under certain conditions. To avoid unnecessary work (and quota usage) you will probably want to geocode an object only when:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;an address is present&lt;/li&gt; &#xA; &lt;li&gt;the address has been changed since last save (or it has never been saved)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The exact code will vary depending on the method you use for your geocodable string, but it would be something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;after_validation :geocode, if: -&amp;gt;(obj){ obj.address.present? and obj.address_changed? }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Caching&lt;/h3&gt; &#xA;&lt;p&gt;When relying on any external service, it&#39;s always a good idea to cache retrieved data. When implemented correctly, it improves your app&#39;s response time and stability. It&#39;s easy to cache geocoding results with Geocoder -- just configure a cache store:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(cache: Redis.new)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example uses Redis, but the cache store can be any object that supports these methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;store#[](key)&lt;/code&gt; or &lt;code&gt;#get&lt;/code&gt; or &lt;code&gt;#read&lt;/code&gt; - retrieves a value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;store#[]=(key, value)&lt;/code&gt; or &lt;code&gt;#set&lt;/code&gt; or &lt;code&gt;#write&lt;/code&gt; - stores a value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;store#del(url)&lt;/code&gt; - deletes a value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;store#keys&lt;/code&gt; - (Optional) Returns array of keys. Used if you wish to expire the entire cache (see below).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Even a plain Ruby hash will work, though it&#39;s not a great choice (cleared out when app is restarted, not shared between app instances, etc).&lt;/p&gt; &#xA;&lt;p&gt;When using Rails use the Generic cache store as an adapter around &lt;code&gt;Rails.cache&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(cache: Geocoder::CacheStore::Generic.new(Rails.cache, {}))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also set a custom prefix to be used for cache keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(cache_options: { prefix: &#34;...&#34; })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default the prefix is &lt;code&gt;geocoder:&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you need to expire cached content:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Lookup.get(Geocoder.config[:lookup]).cache.expire(:all)  # expire cached results for current Lookup&#xA;Geocoder::Lookup.get(:nominatim).cache.expire(&#34;http://...&#34;)        # expire cached result for a specific URL&#xA;Geocoder::Lookup.get(:nominatim).cache.expire(:all)                # expire cached results for Google Lookup&#xA;# expire all cached results for all Lookups.&#xA;# Be aware that this methods spawns a new Lookup object for each Service&#xA;Geocoder::Lookup.all_services.each{|service| Geocoder::Lookup.get(service).cache.expire(:all)}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt; include the prefix when passing a URL to be expired. Expiring &lt;code&gt;:all&lt;/code&gt; will only expire keys with the configured prefix -- it will &lt;em&gt;not&lt;/em&gt; expire every entry in your key/value store.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Before you implement caching in your app please be sure that doing so does not violate the Terms of Service for your geocoding service.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Advanced Model Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You are not stuck with the &lt;code&gt;latitude&lt;/code&gt; and &lt;code&gt;longitude&lt;/code&gt; database column names (with ActiveRecord) or the &lt;code&gt;coordinates&lt;/code&gt; array (Mongo) for storing coordinates. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;geocoded_by :address, latitude: :lat, longitude: :lon  # ActiveRecord&#xA;geocoded_by :address, coordinates: :coords             # MongoDB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For reverse geocoding, you can specify the attribute where the address will be stored. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;reverse_geocoded_by :latitude, :longitude, address: :loc    # ActiveRecord&#xA;reverse_geocoded_by :coordinates, address: :street_address  # MongoDB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To specify geocoding parameters in your model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;geocoded_by :address, params: {region: &#34;...&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported parameters: &lt;code&gt;:lookup&lt;/code&gt;, &lt;code&gt;:ip_lookup&lt;/code&gt;, &lt;code&gt;:language&lt;/code&gt;, and &lt;code&gt;:params&lt;/code&gt;. You can specify an anonymous function if you want to set these on a per-request basis. For example, to use different lookups for objects in different regions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;geocoded_by :address, lookup: lambda{ |obj| obj.geocoder_lookup }&#xA;&#xA;def geocoder_lookup&#xA;  if country_code == &#34;RU&#34;&#xA;    :yandex&#xA;  elsif country_code == &#34;CN&#34;&#xA;    :baidu&#xA;  else&#xA;    :nominatim&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom Result Handling&lt;/h3&gt; &#xA;&lt;p&gt;So far we have seen examples where geocoding results are assigned automatically to predefined object attributes. However, you can skip the auto-assignment by providing a block which handles the parsed geocoding results any way you like, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;reverse_geocoded_by :latitude, :longitude do |obj,results|&#xA;  if geo = results.first&#xA;    obj.city    = geo.city&#xA;    obj.zipcode = geo.postal_code&#xA;    obj.country = geo.country_code&#xA;  end&#xA;end&#xA;&#xA;after_validation :reverse_geocode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every &lt;code&gt;Geocoder::Result&lt;/code&gt; object, &lt;code&gt;result&lt;/code&gt;, provides the following data:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;result.latitude&lt;/code&gt; - float&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.longitude&lt;/code&gt; - float&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.coordinates&lt;/code&gt; - array of the above two in the form of &lt;code&gt;[lat,lon]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.address&lt;/code&gt; - string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.city&lt;/code&gt; - string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.state&lt;/code&gt; - string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.state_code&lt;/code&gt; - string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.postal_code&lt;/code&gt; - string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.country&lt;/code&gt; - string&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;result.country_code&lt;/code&gt; - string&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most APIs return other data in addition to these globally-supported attributes. To directly access the full response, call the &lt;code&gt;#data&lt;/code&gt; method of any Geocoder::Result object. See the &lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/README_API_GUIDE.md&#34;&gt;API Guide&lt;/a&gt; for links to documentation for all geocoding services.&lt;/p&gt; &#xA;&lt;h3&gt;Forward and Reverse Geocoding in the Same Model&lt;/h3&gt; &#xA;&lt;p&gt;You can apply both forward and reverse geocoding to the same model (i.e. users can supply an address or coordinates and Geocoder fills in whatever&#39;s missing) but you&#39;ll need to provide two different address methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;one for storing the fetched address (when reverse geocoding)&lt;/li&gt; &#xA; &lt;li&gt;one for providing an address to use when fetching coordinates (forward geocoding)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Venue&#xA;  # build an address from street, city, and state attributes&#xA;  geocoded_by :address_from_components&#xA;&#xA;  # store the fetched address in the full_address attribute&#xA;  reverse_geocoded_by :latitude, :longitude, address: :full_address&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same goes for latitude/longitude. However, for purposes of querying the database, there can be only one authoritative set of latitude/longitude attributes for use in database queries. This is whichever you specify last. For example, here the attributes &lt;em&gt;without&lt;/em&gt; the &lt;code&gt;fetched_&lt;/code&gt; prefix will be authoritative:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Venue&#xA;  geocoded_by :address,&#xA;    latitude: :fetched_latitude,&#xA;    longitude: :fetched_longitude&#xA;  reverse_geocoded_by :latitude, :longitude&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced Database Queries&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;The following apply to ActiveRecord only. For MongoDB, please use the built-in geospatial features.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The default &lt;code&gt;near&lt;/code&gt; search looks for objects within a circle. To search within a doughnut or ring use the &lt;code&gt;:min_radius&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Venue.near(&#34;Austin, TX&#34;, 200, min_radius: 40)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To search within a rectangle (note that results will &lt;em&gt;not&lt;/em&gt; include &lt;code&gt;distance&lt;/code&gt; and &lt;code&gt;bearing&lt;/code&gt; attributes):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;sw_corner = [40.71, 100.23]&#xA;ne_corner = [36.12, 88.65]&#xA;Venue.within_bounding_box(sw_corner, ne_corner)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To search for objects near a certain point where each object has a different distance requirement (which is defined in the database), you can pass a column name for the radius:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Venue.near([40.71, 99.23], :effective_radius)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you store multiple sets of coordinates for each object, you can specify latitude and longitude columns to use for a search:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Venue.near(&#34;Paris&#34;, 50, latitude: :secondary_latitude, longitude: :secondary_longitude)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Distance and Bearing&lt;/h3&gt; &#xA;&lt;p&gt;When you run a geospatial query, the returned objects have two attributes added:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;obj.distance&lt;/code&gt; - number of miles from the search point to this object&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;obj.bearing&lt;/code&gt; - direction from the search point to this object&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Results are automatically sorted by distance from the search point, closest to farthest. Bearing is given as a number of degrees clockwise from due north, for example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;0&lt;/code&gt; - due north&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;180&lt;/code&gt; - due south&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;90&lt;/code&gt; - due east&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;270&lt;/code&gt; - due west&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;230.1&lt;/code&gt; - southwest&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;359.9&lt;/code&gt; - almost due north&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can convert these to compass point names via provided method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Calculations.compass_point(355) # =&amp;gt; &#34;N&#34;&#xA;Geocoder::Calculations.compass_point(45)  # =&amp;gt; &#34;NE&#34;&#xA;Geocoder::Calculations.compass_point(208) # =&amp;gt; &#34;SW&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: when running queries on SQLite, &lt;code&gt;distance&lt;/code&gt; and &lt;code&gt;bearing&lt;/code&gt; are provided for consistency only. They are not very accurate.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;For more advanced geospatial querying, please see the &lt;a href=&#34;https://github.com/rgeo/rgeo&#34;&gt;rgeo gem&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Geospatial Calculations&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;Geocoder::Calculations&lt;/code&gt; module contains some useful methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# find the distance between two arbitrary points&#xA;Geocoder::Calculations.distance_between([47.858205,2.294359], [40.748433,-73.985655])&#xA; =&amp;gt; 3619.77359999382 # in configured units (default miles)&#xA;&#xA;# find the geographic center (aka center of gravity) of objects or points&#xA;Geocoder::Calculations.geographic_center([city1, city2, [40.22,-73.99], city4])&#xA; =&amp;gt; [35.14968, -90.048929]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/alexreisner/geocoder/raw/master/lib/geocoder/calculations.rb&#34;&gt;the code&lt;/a&gt; for more!&lt;/p&gt; &#xA;&lt;h2&gt;Batch Geocoding&lt;/h2&gt; &#xA;&lt;p&gt;If you have just added geocoding to an existing application with a lot of objects, you can use this Rake task to geocode them all:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake geocode:all CLASS=YourModel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need reverse geocoding instead, call the task with REVERSE=true:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake geocode:all CLASS=YourModel REVERSE=true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In either case, it won&#39;t try to geocode objects that are already geocoded. The task will print warnings if you exceed the rate limit for your geocoding service. Some services enforce a per-second limit in addition to a per-day limit. To avoid exceeding the per-second limit, you can add a &lt;code&gt;SLEEP&lt;/code&gt; option to pause between requests for a given amount of time. You can also load objects in batches to save memory, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake geocode:all CLASS=YourModel SLEEP=0.25 BATCH=100&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To avoid exceeding per-day limits you can add a &lt;code&gt;LIMIT&lt;/code&gt; option. However, this will ignore the &lt;code&gt;BATCH&lt;/code&gt; value, if provided.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rake geocode:all CLASS=YourModel LIMIT=1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;When writing tests for an app that uses Geocoder it may be useful to avoid network calls and have Geocoder return consistent, configurable results. To do this, configure the &lt;code&gt;:test&lt;/code&gt; lookup and/or &lt;code&gt;:ip_lookup&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(lookup: :test, ip_lookup: :test)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add stubs to define the results that will be returned:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Lookup::Test.add_stub(&#xA;  &#34;New York, NY&#34;, [&#xA;    {&#xA;      &#39;coordinates&#39;  =&amp;gt; [40.7143528, -74.0059731],&#xA;      &#39;address&#39;      =&amp;gt; &#39;New York, NY, USA&#39;,&#xA;      &#39;state&#39;        =&amp;gt; &#39;New York&#39;,&#xA;      &#39;state_code&#39;   =&amp;gt; &#39;NY&#39;,&#xA;      &#39;country&#39;      =&amp;gt; &#39;United States&#39;,&#xA;      &#39;country_code&#39; =&amp;gt; &#39;US&#39;&#xA;    }&#xA;  ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the above stub defined, any query for &#34;New York, NY&#34; will return the results array that follows. You can also set a default stub, to be returned when no other stub matches a given query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Lookup::Test.set_default_stub(&#xA;  [&#xA;    {&#xA;      &#39;coordinates&#39;  =&amp;gt; [40.7143528, -74.0059731],&#xA;      &#39;address&#39;      =&amp;gt; &#39;New York, NY, USA&#39;,&#xA;      &#39;state&#39;        =&amp;gt; &#39;New York&#39;,&#xA;      &#39;state_code&#39;   =&amp;gt; &#39;NY&#39;,&#xA;      &#39;country&#39;      =&amp;gt; &#39;United States&#39;,&#xA;      &#39;country_code&#39; =&amp;gt; &#39;US&#39;&#xA;    }&#xA;  ]&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also delete a single stub, or reset all stubs &lt;em&gt;including the default stub&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Lookup::Test.delete_stub(&#39;New York, NY&#39;)&#xA;Geocoder::Lookup::Test.reset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keys must be strings (not symbols) when calling &lt;code&gt;add_stub&lt;/code&gt; or &lt;code&gt;set_default_stub&lt;/code&gt;. For example &lt;code&gt;&#39;country&#39; =&amp;gt;&lt;/code&gt; not &lt;code&gt;:country =&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The stubbed result objects returned by the Test lookup do not support all the methods real result objects do. If you need to test interaction with real results it may be better to use an external stubbing tool and something like WebMock or VCR to prevent network calls.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;By default Geocoder will rescue any exceptions raised by calls to a geocoding service and return an empty array. You can override this on a per-exception basis, and also have Geocoder raise its own exceptions for certain events (eg: API quota exceeded) by using the &lt;code&gt;:always_raise&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(always_raise: [SocketError, Timeout::Error])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also do this to raise all exceptions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder.configure(always_raise: :all)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The raise-able exceptions are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;SocketError&#xA;Timeout::Error&#xA;Geocoder::OverQueryLimitError&#xA;Geocoder::RequestDenied&#xA;Geocoder::InvalidRequest&#xA;Geocoder::InvalidApiKey&#xA;Geocoder::ServiceUnavailable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that only a few of the above exceptions are raised by any given lookup, so there&#39;s no guarantee if you configure Geocoder to raise &lt;code&gt;ServiceUnavailable&lt;/code&gt; that it will actually be raised under those conditions (because most APIs don&#39;t return 503 when they should; you may get a &lt;code&gt;Timeout::Error&lt;/code&gt; instead). Please see the source code for your particular lookup for details.&lt;/p&gt; &#xA;&lt;h2&gt;Command Line Interface&lt;/h2&gt; &#xA;&lt;p&gt;When you install the Geocoder gem it adds a &lt;code&gt;geocode&lt;/code&gt; command to your shell. You can search for a street address, IP address, postal code, coordinates, etc just like you can with the Geocoder.search method for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ geocode 29.951,-90.081&#xA;Latitude:         29.952211&#xA;Longitude:        -90.080563&#xA;Full address:     1500 Sugar Bowl Dr, New Orleans, LA 70112, USA&#xA;City:             New Orleans&#xA;State/province:   Louisiana&#xA;Postal code:      70112&#xA;Country:          United States&#xA;Map:              http://maps.google.com/maps?q=29.952211,-90.080563&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are also a number of options for setting the geocoding API, key, and language, viewing the raw JSON response, and more. Please run &lt;code&gt;geocode -h&lt;/code&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Technical Discussions&lt;/h2&gt; &#xA;&lt;h3&gt;Distance Queries in SQLite&lt;/h3&gt; &#xA;&lt;p&gt;SQLite&#39;s lack of trigonometric functions requires an alternate implementation of the &lt;code&gt;near&lt;/code&gt; scope. When using SQLite, Geocoder will automatically use a less accurate algorithm for finding objects near a given point. Results of this algorithm should not be trusted too much as it will return objects that are outside the given radius, along with inaccurate distance and bearing calculations.&lt;/p&gt; &#xA;&lt;p&gt;There are few options for finding objects near a given point in SQLite without installing extensions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Use a square instead of a circle for finding nearby points. For example, if you want to find points near 40.71, 100.23, search for objects with latitude between 39.71 and 41.71 and longitude between 99.23 and 101.23. One degree of latitude or longitude is at most 69 miles so divide your radius (in miles) by 69.0 to get the amount to add and subtract from your center coordinates to get the upper and lower bounds. The results will not be very accurate (you&#39;ll get points outside the desired radius), but you will get all the points within the required radius.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Load all objects into memory and compute distances between them using the &lt;code&gt;Geocoder::Calculations.distance_between&lt;/code&gt; method. This will produce accurate results but will be very slow (and use a lot of memory) if you have a lot of objects in your database.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you have a large number of objects (so you can&#39;t use approach #2) and you need accurate results (better than approach #1 will give), you can use a combination of the two. Get all the objects within a square around your center point, and then eliminate the ones that are too far away using &lt;code&gt;Geocoder::Calculations.distance_between&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Because Geocoder needs to provide this functionality as a scope, we must go with option #1, but feel free to implement #2 or #3 if you need more accuracy.&lt;/p&gt; &#xA;&lt;h3&gt;Numeric Data Types and Precision&lt;/h3&gt; &#xA;&lt;p&gt;Geocoder works with any numeric data type (e.g. float, double, decimal) on which trig (and other mathematical) functions can be performed.&lt;/p&gt; &#xA;&lt;p&gt;A summary of the relationship between geographic precision and the number of decimal places in latitude and longitude degree values is available on &lt;a href=&#34;http://en.wikipedia.org/wiki/Decimal_degrees#Accuracy&#34;&gt;Wikipedia&lt;/a&gt;. As an example: at the equator, latitude/longitude values with 4 decimal places give about 11 metres precision, whereas 5 decimal places gives roughly 1 metre precision.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;Mongoid&lt;/h3&gt; &#xA;&lt;p&gt;If you get one of these errors:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;uninitialized constant Geocoder::Model::Mongoid&#xA;uninitialized constant Geocoder::Model::Mongoid::Mongo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you should check your Gemfile to make sure the Mongoid gem is listed &lt;em&gt;before&lt;/em&gt; Geocoder. If Mongoid isn&#39;t loaded when Geocoder is initialized, Geocoder will not load support for Mongoid.&lt;/p&gt; &#xA;&lt;h3&gt;ActiveRecord&lt;/h3&gt; &#xA;&lt;p&gt;A lot of debugging time can be saved by understanding how Geocoder works with ActiveRecord. When you use the &lt;code&gt;near&lt;/code&gt; scope or the &lt;code&gt;nearbys&lt;/code&gt; method of a geocoded object, Geocoder creates an ActiveModel::Relation object which adds some attributes (eg: distance, bearing) to the SELECT clause. It also adds a condition to the WHERE clause to check that distance is within the given radius. Because the SELECT clause is modified, anything else that modifies the SELECT clause may produce strange results, for example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;using the &lt;code&gt;pluck&lt;/code&gt; method (selects only a single column)&lt;/li&gt; &#xA; &lt;li&gt;specifying another model through &lt;code&gt;includes&lt;/code&gt; (selects columns from other tables)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Geocoding is Slow&lt;/h3&gt; &#xA;&lt;p&gt;With most lookups, addresses are translated into coordinates via an API that must be accessed through the Internet. These requests are subject to the same bandwidth constraints as every other HTTP request, and will vary in speed depending on network conditions. Furthermore, many of the services supported by Geocoder are free and thus very popular. Often they cannot keep up with demand and their response times become quite bad.&lt;/p&gt; &#xA;&lt;p&gt;If your application requires quick geocoding responses you will probably need to pay for a non-free service, or--if you&#39;re doing IP address geocoding--use a lookup that doesn&#39;t require an external (network-accessed) service.&lt;/p&gt; &#xA;&lt;p&gt;For IP address lookups in Rails applications, it is generally NOT a good idea to run &lt;code&gt;request.location&lt;/code&gt; during a synchronous page load without understanding the speed/behavior of your configured lookup. If the lookup becomes slow, so will your website.&lt;/p&gt; &#xA;&lt;p&gt;For the most part, the speed of geocoding requests has little to do with the Geocoder gem. Please take the time to learn about your configured lookup before posting performance-related issues.&lt;/p&gt; &#xA;&lt;h3&gt;Unexpected Responses from Geocoding Services&lt;/h3&gt; &#xA;&lt;p&gt;Take a look at the server&#39;s raw response. You can do this by getting the request URL in an app console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Lookup.get(:nominatim).query_url(Geocoder::Query.new(&#34;...&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &lt;code&gt;:nominatim&lt;/code&gt; with the lookup you are using and replace &lt;code&gt;...&lt;/code&gt; with the address you are trying to geocode. Then visit the returned URL in your web browser. Often the API will return an error message that helps you resolve the problem. If, after reading the raw response, you believe there is a problem with Geocoder, please post an issue and include both the URL and raw response body.&lt;/p&gt; &#xA;&lt;p&gt;You can also fetch the response in the console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Geocoder::Lookup.get(:nominatim).send(:fetch_raw_data, Geocoder::Query.new(&#34;...&#34;))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Known Issues&lt;/h2&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;count&lt;/code&gt; with Rails 4.1+&lt;/h3&gt; &#xA;&lt;p&gt;Due to &lt;a href=&#34;https://github.com/rails/rails/pull/10710&#34;&gt;a change in ActiveRecord&#39;s &lt;code&gt;count&lt;/code&gt; method&lt;/a&gt; you will need to use &lt;code&gt;count(:all)&lt;/code&gt; to explicitly count all columns (&#34;*&#34;) when using a &lt;code&gt;near&lt;/code&gt; scope. Using &lt;code&gt;near&lt;/code&gt; and calling &lt;code&gt;count&lt;/code&gt; with no argument will cause exceptions in many cases.&lt;/p&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;near&lt;/code&gt; with &lt;code&gt;includes&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You cannot use the &lt;code&gt;near&lt;/code&gt; scope with another scope that provides an &lt;code&gt;includes&lt;/code&gt; option because the &lt;code&gt;SELECT&lt;/code&gt; clause generated by &lt;code&gt;near&lt;/code&gt; will overwrite it (or vice versa).&lt;/p&gt; &#xA;&lt;p&gt;Instead of using &lt;code&gt;includes&lt;/code&gt; to reduce the number of database queries, try using &lt;code&gt;joins&lt;/code&gt; with either the &lt;code&gt;:select&lt;/code&gt; option or a call to &lt;code&gt;preload&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Pass a :select option to the near scope to get the columns you want.&#xA;# Instead of City.near(...).includes(:venues), try:&#xA;City.near(&#34;Omaha, NE&#34;, 20, select: &#34;cities.*, venues.*&#34;).joins(:venues)&#xA;&#xA;# This preload call will normally trigger two queries regardless of the&#xA;# number of results; one query on hotels, and one query on administrators.&#xA;# Instead of Hotel.near(...).includes(:administrator), try:&#xA;Hotel.near(&#34;London, UK&#34;, 50).joins(:administrator).preload(:administrator)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If anyone has a more elegant solution to this problem I am very interested in seeing it.&lt;/p&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;near&lt;/code&gt; with objects close to the 180th meridian&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;near&lt;/code&gt; method will not look across the 180th meridian to find objects close to a given point. In practice this is rarely an issue outside of New Zealand and certain surrounding islands. This problem does not exist with the zero-meridian. The problem is due to a shortcoming of the Haversine formula which Geocoder uses to calculate distances.&lt;/p&gt; &#xA;&lt;p&gt;Copyright &lt;span&gt;Â©&lt;/span&gt; 2009-2021 Alex Reisner, released under the MIT license.&lt;/p&gt;</summary>
  </entry>
</feed>