<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-23T01:46:05Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>shayonj/pg_easy_replicate</title>
    <updated>2023-06-23T01:46:05Z</updated>
    <id>tag:github.com,2023-06-23:/shayonj/pg_easy_replicate</id>
    <link href="https://github.com/shayonj/pg_easy_replicate" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Easily setup logical replication and switchover to new database with minimal downtime&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;pg_easy_replicate&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/shayonj/pg_easy_replicate/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/shayonj/pg_easy_replicate/actions/workflows/ci.yaml/badge.svg?branch=main&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/rb/pg_easy_replicate&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/pg_easy_replicate.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pg_easy_replicate&lt;/code&gt; is a CLI orchestrator tool that simplifies the process of setting up &lt;a href=&#34;https://www.postgresql.org/docs/current/logical-replication.html&#34;&gt;logical replication&lt;/a&gt; between two PostgreSQL databases. &lt;code&gt;pg_easy_replicate&lt;/code&gt; also supports switchover. After the source (primary database) is fully replicating, &lt;code&gt;pg_easy_replicate&lt;/code&gt; puts it into read-only mode and via logical replication flushes all data to the new target database. This ensures zero data loss and minimal downtime for the application. This method can be useful for performing minimal downtime (up to &amp;lt;1min, depending) major version upgrades between two PostgreSQL databases, load testing with blue/green database setup and other similar use cases.&lt;/p&gt; &#xA;&lt;p&gt;Battle tested in production at &lt;a href=&#34;https://www.tines.com/&#34;&gt;Tines&lt;/a&gt; ðŸš€&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#limits&#34;&gt;Limits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#cli&#34;&gt;CLI&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#replicating-all-tables-with-a-single-group&#34;&gt;Replicating all tables with a single group&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#config-check&#34;&gt;Config check&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#bootstrap&#34;&gt;Bootstrap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#start-sync&#34;&gt;Start sync&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#stats&#34;&gt;Stats&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#performing-switchover&#34;&gt;Performing switchover&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#replicating-single-database-with-custom-tables&#34;&gt;Replicating single database with custom tables&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#switchover-strategies-with-minimal-downtime&#34;&gt;Switchover strategies with minimal downtime&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#rolling-restart-strategy&#34;&gt;Rolling restart strategy&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shayonj/pg_easy_replicate/main/#dns-failover-strategy&#34;&gt;DNS Failover strategy&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this line to your application&#39;s Gemfile:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#34;pg_easy_replicate&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And then execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ bundle install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it yourself as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gem install pg_easy_replicate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will include all dependencies accordingly as well. Make sure the following requirements are satisfied.&lt;/p&gt; &#xA;&lt;p&gt;Or via Docker:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker pull shayonj/pg_easy_replicate:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hub.docker.com/r/shayonj/pg_easy_replicate&#34;&gt;https://hub.docker.com/r/shayonj/pg_easy_replicate&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PostgreSQL 10 and later&lt;/li&gt; &#xA; &lt;li&gt;Ruby 2.7 and later&lt;/li&gt; &#xA; &lt;li&gt;Database user should have permissions for &lt;code&gt;SUPERUSER&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Both databases should have the same schema&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Limits&lt;/h2&gt; &#xA;&lt;p&gt;All &lt;a href=&#34;https://www.postgresql.org/docs/current/logical-replication-restrictions.html&#34;&gt;Logical Replication Restrictions&lt;/a&gt; apply.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Ensure &lt;code&gt;SOURCE_DB_URL&lt;/code&gt; and &lt;code&gt;TARGET_DB_URL&lt;/code&gt; are present as environment variables in the runtime environment. The URL are of the postgres connection string format. Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export SOURCE_DB_URL=&#34;postgres://USERNAME:PASSWORD@localhost:5432/DATABASE_NAME&#34;&#xA;$ export TARGET_DB_URL=&#34;postgres://USERNAME:PASSWORD@localhost:5433/DATABASE_NAME&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any &lt;code&gt;pg_easy_replicate&lt;/code&gt; command can be run the same way with the docker image as well. As long the container is running in an environment where it has access to both the databases. Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -e SOURCE_DB_URL=&#34;postgres://USERNAME:PASSWORD@localhost:5432/DATABASE_NAME&#34;  \&#xA;  -e TARGET_DB_URL=&#34;postgres://USERNAME:PASSWORD@localhost:5433/DATABASE_NAME&#34; \&#xA;  -it --rm shayonj/pg_easy_replicate:latest \&#xA;  pg_easy_replicate config_check&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;CLI&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$  pg_easy_replicate&#xA;pg_easy_replicate commands:&#xA;  pg_easy_replicate bootstrap -g, --group-name=GROUP_NAME    # Sets up temporary tables for information required during runtime&#xA;  pg_easy_replicate cleanup -g, --group-name=GROUP_NAME      # Cleans up all bootstrapped data for the respective group&#xA;  pg_easy_replicate config_check                             # Prints if source and target database have the required config&#xA;  pg_easy_replicate help [COMMAND]                           # Describe available commands or one specific command&#xA;  pg_easy_replicate start_sync -g, --group-name=GROUP_NAME   # Starts the logical replication from source database to target database provisioned in the group&#xA;  pg_easy_replicate stats  -g, --group-name=GROUP_NAME       # Prints the statistics in JSON for the group&#xA;  pg_easy_replicate stop_sync -g, --group-name=GROUP_NAME    # Stop the logical replication from source database to target database provisioned in the group&#xA;  pg_easy_replicate switchover  -g, --group-name=GROUP_NAME  # Puts the source database in read only mode after all the data is flushed and written&#xA;  pg_easy_replicate version                                  # Prints the version&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Replicating all tables with a single group&lt;/h2&gt; &#xA;&lt;p&gt;You can create as many groups as you want for a single database. Groups are just a logical isolation of a single replication.&lt;/p&gt; &#xA;&lt;h3&gt;Config check&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pg_easy_replicate config_check&#xA;&#xA;âœ… Config is looking good.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Bootstrap&lt;/h3&gt; &#xA;&lt;p&gt;Every sync will need to be bootstrapped before you can set up the sync between two databases. Bootstrap creates a new super user to perform the orchestration required during the rest of the process. It also creates some internal metadata tables for record keeping.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pg_easy_replicate bootstrap --group-name database-cluster-1&#xA;&#xA;{&#34;name&#34;:&#34;pg_easy_replicate&#34;,&#34;hostname&#34;:&#34;PKHXQVK6DW&#34;,&#34;pid&#34;:21485,&#34;level&#34;:30,&#34;time&#34;:&#34;2023-06-19T15:51:11.015-04:00&#34;,&#34;v&#34;:0,&#34;msg&#34;:&#34;Setting up schema&#34;,&#34;version&#34;:&#34;0.1.0&#34;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Start sync&lt;/h3&gt; &#xA;&lt;p&gt;Once the bootstrap is complete, you can start the sync. Starting the sync sets up the publication, subscription and performs other minor housekeeping things.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pg_easy_replicate start_sync --group-name database-cluster-1&#xA;&#xA;{&#34;name&#34;:&#34;pg_easy_replicate&#34;,&#34;hostname&#34;:&#34;PKHXQVK6DW&#34;,&#34;pid&#34;:22113,&#34;level&#34;:30,&#34;time&#34;:&#34;2023-06-19T15:54:54.874-04:00&#34;,&#34;v&#34;:0,&#34;msg&#34;:&#34;Setting up publication&#34;,&#34;publication_name&#34;:&#34;pger_publication_database_cluster_1&#34;,&#34;version&#34;:&#34;0.1.0&#34;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Stats&lt;/h3&gt; &#xA;&lt;p&gt;You can inspect or watch stats any time during the sync process. The stats give you can an idea of when the sync started, current flush/write lag, how many tables are in &lt;code&gt;replicating&lt;/code&gt;, &lt;code&gt;copying&lt;/code&gt; or other stages, and more.&lt;/p&gt; &#xA;&lt;p&gt;You can poll these stats to perform any other after the switchover is done. The stats include a &lt;code&gt;switchover_completed_at&lt;/code&gt; which is updated once the switch over is complete.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pg_easy_replicate stats --group-name database-cluster-1&#xA;&#xA;{&#xA;  &#34;lag_stats&#34;: [&#xA;    {&#xA;      &#34;pid&#34;: 66,&#xA;      &#34;client_addr&#34;: &#34;192.168.128.2&#34;,&#xA;      &#34;user_name&#34;: &#34;jamesbond&#34;,&#xA;      &#34;application_name&#34;: &#34;pger_subscription_database_cluster_1&#34;,&#xA;      &#34;state&#34;: &#34;streaming&#34;,&#xA;      &#34;sync_state&#34;: &#34;async&#34;,&#xA;      &#34;write_lag&#34;: &#34;0.0&#34;,&#xA;      &#34;flush_lag&#34;: &#34;0.0&#34;,&#xA;      &#34;replay_lag&#34;: &#34;0.0&#34;&#xA;    }&#xA;  ],&#xA;  &#34;message_lsn_receipts&#34;: [&#xA;    {&#xA;      &#34;received_lsn&#34;: &#34;0/1674688&#34;,&#xA;      &#34;last_msg_send_time&#34;: &#34;2023-06-19 19:56:35 UTC&#34;,&#xA;      &#34;last_msg_receipt_time&#34;: &#34;2023-06-19 19:56:35 UTC&#34;,&#xA;      &#34;latest_end_lsn&#34;: &#34;0/1674688&#34;,&#xA;      &#34;latest_end_time&#34;: &#34;2023-06-19 19:56:35 UTC&#34;&#xA;    }&#xA;  ],&#xA;  &#34;sync_started_at&#34;: &#34;2023-06-19 19:54:54 UTC&#34;,&#xA;  &#34;sync_failed_at&#34;: null,&#xA;  &#34;switchover_completed_at&#34;: null&#xA;&#xA;  ....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Performing switchover&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;pg_easy_replicate&lt;/code&gt; doesn&#39;t kick off the switchover on its own. When you start the sync via &lt;code&gt;start_sync&lt;/code&gt;, it starts the replication between the two databases. Once you have had the time to monitor stats and any other key metrics, you can kick off the &lt;code&gt;switchover&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;switchover&lt;/code&gt; will wait until all tables in the group are replicating and the delta for lag is &amp;lt;200kb (by calculating the &lt;code&gt;pg_wal_lsn_diff&lt;/code&gt; between &lt;code&gt;sent_lsn&lt;/code&gt; and &lt;code&gt;write_lsn&lt;/code&gt;) and then perform the switch.&lt;/p&gt; &#xA;&lt;p&gt;The switch is made by putting the user on the source database in &lt;code&gt;READ ONLY&lt;/code&gt; mode, so that it is not accepting any more writes and waits for the flush lag to be &lt;code&gt;0&lt;/code&gt;. It is up to user to kick of a rolling restart of your application containers or failover DNS (more on these below in strategies) after the switchover is complete, so that your application isn&#39;t sending any read/write requests to the old/source database.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pg_easy_replicate switchover  --group-name database-cluster-1&#xA;&#xA;{&#34;name&#34;:&#34;pg_easy_replicate&#34;,&#34;hostname&#34;:&#34;PKHXQVK6DW&#34;,&#34;pid&#34;:24192,&#34;level&#34;:30,&#34;time&#34;:&#34;2023-06-19T16:05:23.033-04:00&#34;,&#34;v&#34;:0,&#34;msg&#34;:&#34;Watching lag stats&#34;,&#34;version&#34;:&#34;0.1.0&#34;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Replicating single database with custom tables&lt;/h2&gt; &#xA;&lt;p&gt;By default all tables are added for replication but you can create multiple groups with custom tables for the same database. Example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&#xA;$ pg_easy_replicate bootstrap --group-name database-cluster-1&#xA;$ pg_easy_replicate start_sync --group-name database-cluster-1 --schema-name public --tables &#34;users, posts, events&#34;&#xA;&#xA;...&#xA;&#xA;$ pg_easy_replicate bootstrap --group-name database-cluster-2&#xA;$ pg_easy_replicate start_sync --group-name database-cluster-2 --schema-name public --tables &#34;comments, views&#34;&#xA;&#xA;...&#xA;$ pg_easy_replicate switchover  --group-name database-cluster-1&#xA;$ pg_easy_replicate switchover  --group-name database-cluster-2&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Switchover strategies with minimal downtime&lt;/h2&gt; &#xA;&lt;p&gt;For minimal downtime, it&#39;d be best to watch/tail the stats and wait until &lt;code&gt;switchover_completed_at&lt;/code&gt; is updated with a timestamp. Once that happens you can perform any of the following strategies. Note: These are just suggestions and &lt;code&gt;pg_easy_replicate&lt;/code&gt; doesn&#39;t provide any functionalities for this.&lt;/p&gt; &#xA;&lt;h3&gt;Rolling restart strategy&lt;/h3&gt; &#xA;&lt;p&gt;In this strategy, you have a change ready to go which instructs your application to start connecting to the new database. Either using an environment variable or similar. Depending on the application type, it may or may not require a rolling restart.&lt;/p&gt; &#xA;&lt;p&gt;Next, you can set up a program that watches the &lt;code&gt;stats&lt;/code&gt; and waits until &lt;code&gt;switchover_completed_at&lt;/code&gt; is reporting as &lt;code&gt;true&lt;/code&gt;. Once that happens it kicks off a rolling restart of your application containers so they can start making connections to the DNS of the new database.&lt;/p&gt; &#xA;&lt;h3&gt;DNS Failover strategy&lt;/h3&gt; &#xA;&lt;p&gt;In this strategy, you have a weighted based DNS system (example &lt;a href=&#34;https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-weighted.html&#34;&gt;AWS Route53 weighted records&lt;/a&gt;) where 100% of traffic goes to a primary origin and 0% to a secondary origin. The primary origin here is the DNS host for your source database and secondary origin is the DNS host for your target database. You can set up your application ahead of time to interact with the database using DNS from the weighted group.&lt;/p&gt; &#xA;&lt;p&gt;Next, you can set up a program that watches the &lt;code&gt;stats&lt;/code&gt; and waits until &lt;code&gt;switchover_completed_at&lt;/code&gt; is reporting as &lt;code&gt;true&lt;/code&gt;. Once that happens it updates the weight in the DNS weighted group where 100% of the requests now go to the new/target database. Note: Keeping a low &lt;code&gt;ttl&lt;/code&gt; is recommended.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;PRs most welcome. You can get started locally by&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker compose down -v &amp;amp;&amp;amp; docker compose up --remove-orphans --build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install ruby &lt;code&gt;3.1.4&lt;/code&gt; using RVM (&lt;a href=&#34;https://rvm.io/rvm/install#any-other-system&#34;&gt;instruction&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bundle exec rspec&lt;/code&gt; for specs&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>