<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-29T01:45:25Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>drapergem/draper</title>
    <updated>2023-01-29T01:45:25Z</updated>
    <id>tag:github.com,2023-01-29:/drapergem/draper</id>
    <link href="https://github.com/drapergem/draper" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Decorators/View-Models for Rails Applications&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Draper: View Models for Rails&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/drapergem/draper/actions?query=workflow%3Aci+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/drapergem/draper/workflows/CI/badge.svg?branch=master&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/drapergem/draper&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/drapergem/draper.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/drapergem/draper/test_coverage&#34;&gt;&lt;img src=&#34;https://api.codeclimate.com/v1/badges/0d40c43951d516bf6985/test_coverage&#34; alt=&#34;Test Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/drapergem/draper&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/drapergem/draper.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Draper adds an object-oriented layer of presentation logic to your Rails application.&lt;/p&gt; &#xA;&lt;p&gt;Without Draper, this functionality might have been tangled up in procedural helpers or adding bulk to your models. With Draper decorators, you can wrap your models with presentation-related logic to organise - and test - this layer of your app much more effectively.&lt;/p&gt; &#xA;&lt;h2&gt;Why Use a Decorator?&lt;/h2&gt; &#xA;&lt;p&gt;Imagine your application has an &lt;code&gt;Article&lt;/code&gt; model. With Draper, you&#39;d create a corresponding &lt;code&gt;ArticleDecorator&lt;/code&gt;. The decorator wraps the model, and deals &lt;em&gt;only&lt;/em&gt; with presentational concerns. In the controller, you decorate the article before handing it off to the view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/articles_controller.rb&#xA;def show&#xA;  @article = Article.find(params[:id]).decorate&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the view, you can use the decorator in exactly the same way as you would have used the model. But whenever you start needing logic in the view or start thinking about a helper method, you can implement a method on the decorator instead.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s look at how you could convert an existing Rails helper to a decorator method. You have this existing helper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/helpers/articles_helper.rb&#xA;def publication_status(article)&#xA;  if article.published?&#xA;    &#34;Published at #{article.published_at.strftime(&#39;%A, %B %e&#39;)}&#34;&#xA;  else&#xA;    &#34;Unpublished&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But it makes you a little uncomfortable. &lt;code&gt;publication_status&lt;/code&gt; lives in a nebulous namespace spread across all controllers and view. Down the road, you might want to display the publication status of a &lt;code&gt;Book&lt;/code&gt;. And, of course, your design calls for a slightly different formatting to the date for a &lt;code&gt;Book&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Now your helper method can either switch based on the input class type (poor Ruby style), or you break it out into two methods, &lt;code&gt;book_publication_status&lt;/code&gt; and &lt;code&gt;article_publication_status&lt;/code&gt;. And keep adding methods for each publication type...to the global helper namespace. And you&#39;ll have to remember all the names. Ick.&lt;/p&gt; &#xA;&lt;p&gt;Ruby thrives when we use Object-Oriented style. If you didn&#39;t know Rails&#39; helpers existed, you&#39;d probably imagine that your view template could feature something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;%= @article.publication_status %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Without a decorator, you&#39;d have to implement the &lt;code&gt;publication_status&lt;/code&gt; method in the &lt;code&gt;Article&lt;/code&gt; model. That method is presentation-centric, and thus does not belong in a model.&lt;/p&gt; &#xA;&lt;p&gt;Instead, you implement a decorator:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/decorators/article_decorator.rb&#xA;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  delegate_all&#xA;&#xA;  def publication_status&#xA;    if published?&#xA;      &#34;Published at #{published_at}&#34;&#xA;    else&#xA;      &#34;Unpublished&#34;&#xA;    end&#xA;  end&#xA;&#xA;  def published_at&#xA;    object.published_at.strftime(&#34;%A, %B %e&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Within the &lt;code&gt;publication_status&lt;/code&gt; method we use the &lt;code&gt;published?&lt;/code&gt; method. Where does that come from? It&#39;s a method of the source &lt;code&gt;Article&lt;/code&gt;, whose methods have been made available on the decorator by the &lt;code&gt;delegate_all&lt;/code&gt; call above.&lt;/p&gt; &#xA;&lt;p&gt;You might have heard this sort of decorator called a &#34;presenter&#34;, an &#34;exhibit&#34;, a &#34;view model&#34;, or even just a &#34;view&#34; (in that nomenclature, what Rails calls &#34;views&#34; are actually &#34;templates&#34;). Whatever you call it, it&#39;s a great way to replace procedural helpers like the one above with &#34;real&#34; object-oriented programming.&lt;/p&gt; &#xA;&lt;p&gt;Decorators are the ideal place to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;format complex data for user display&lt;/li&gt; &#xA; &lt;li&gt;define commonly-used representations of an object, like a &lt;code&gt;name&lt;/code&gt; method that combines &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt; attributes&lt;/li&gt; &#xA; &lt;li&gt;mark up attributes with a little semantic HTML, like turning a &lt;code&gt;url&lt;/code&gt; field into a hyperlink&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;As of version 4.0.0, Draper only officially supports Rails 5.2 / Ruby 2.4 and later. Add Draper to your Gemfile.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  gem &#39;draper&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, run &lt;code&gt;bundle install&lt;/code&gt; within your app&#39;s directory.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re upgrading from a 0.x release, the major changes are outlined &lt;a href=&#34;https://github.com/drapergem/draper/wiki/Upgrading-to-1.0&#34;&gt;in the wiki&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Writing Decorators&lt;/h2&gt; &#xA;&lt;p&gt;Decorators inherit from &lt;code&gt;Draper::Decorator&lt;/code&gt;, live in your &lt;code&gt;app/decorators&lt;/code&gt; directory, and are named for the model that they decorate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/decorators/article_decorator.rb&#xA;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;# ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generators&lt;/h3&gt; &#xA;&lt;p&gt;To create an &lt;code&gt;ApplicationDecorator&lt;/code&gt; that all generated decorators inherit from, run...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails generate draper:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you have Draper installed and generate a controller...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails generate resource Article&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...you&#39;ll get a decorator for free!&lt;/p&gt; &#xA;&lt;p&gt;But if the &lt;code&gt;Article&lt;/code&gt; model already exists, you can run...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rails generate decorator Article&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...to create the &lt;code&gt;ArticleDecorator&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Accessing Helpers&lt;/h3&gt; &#xA;&lt;p&gt;Normal Rails helpers are still useful for lots of tasks. Both Rails&#39; provided helpers and those defined in your app can be accessed within a decorator via the &lt;code&gt;h&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  def emphatic&#xA;    h.content_tag(:strong, &#34;Awesome&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If writing &lt;code&gt;h.&lt;/code&gt; frequently is getting you down, you can add...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;include Draper::LazyHelpers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...at the top of your decorator class - you&#39;ll mix in a bazillion methods and never have to type &lt;code&gt;h.&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;p&gt;(&lt;em&gt;Note&lt;/em&gt;: the &lt;code&gt;capture&lt;/code&gt; method is only available through &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;helpers&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h3&gt;Accessing the model&lt;/h3&gt; &#xA;&lt;p&gt;When writing decorator methods you&#39;ll usually need to access the wrapped model. While you may choose to use delegation (&lt;a href=&#34;https://raw.githubusercontent.com/drapergem/draper/master/#delegating-methods&#34;&gt;covered below&lt;/a&gt;) for convenience, you can always use the &lt;code&gt;object&lt;/code&gt; (or its alias &lt;code&gt;model&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  def published_at&#xA;    object.published_at.strftime(&#34;%A, %B %e&#34;)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Decorating Objects&lt;/h2&gt; &#xA;&lt;h3&gt;Single Objects&lt;/h3&gt; &#xA;&lt;p&gt;Ok, so you&#39;ve written a sweet decorator, now you&#39;re going to want to put it into action! A simple option is to call the &lt;code&gt;decorate&lt;/code&gt; method on your model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@article = Article.first.decorate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This infers the decorator from the object being decorated. If you want more control - say you want to decorate a &lt;code&gt;Widget&lt;/code&gt; with a more general &lt;code&gt;ProductDecorator&lt;/code&gt; - then you can instantiate a decorator directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@widget = ProductDecorator.new(Widget.first)&#xA;# or, equivalently&#xA;@widget = ProductDecorator.decorate(Widget.first)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Collections&lt;/h3&gt; &#xA;&lt;h4&gt;Decorating Individual Elements&lt;/h4&gt; &#xA;&lt;p&gt;If you have a collection of objects, you can decorate them all in one fell swoop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@articles = ArticleDecorator.decorate_collection(Article.all)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your collection is an ActiveRecord query, you can use this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@articles = Article.popular.decorate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; In Rails 3, the &lt;code&gt;.all&lt;/code&gt; method returns an array and not a query. Thus you &lt;em&gt;cannot&lt;/em&gt; use the technique of &lt;code&gt;Article.all.decorate&lt;/code&gt; in Rails 3. In Rails 4, &lt;code&gt;.all&lt;/code&gt; returns a query so this techique would work fine.&lt;/p&gt; &#xA;&lt;h4&gt;Decorating the Collection Itself&lt;/h4&gt; &#xA;&lt;p&gt;If you want to add methods to your decorated collection (for example, for pagination), you can subclass &lt;code&gt;Draper::CollectionDecorator&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/decorators/articles_decorator.rb&#xA;class ArticlesDecorator &amp;lt; Draper::CollectionDecorator&#xA;  def page_number&#xA;    42&#xA;  end&#xA;end&#xA;&#xA;# elsewhere...&#xA;@articles = ArticlesDecorator.new(Article.all)&#xA;# or, equivalently&#xA;@articles = ArticlesDecorator.decorate(Article.all)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Draper decorates each item by calling the &lt;code&gt;decorate&lt;/code&gt; method. Alternatively, you can specify a decorator by overriding the collection decorator&#39;s &lt;code&gt;decorator_class&lt;/code&gt; method, or by passing the &lt;code&gt;:with&lt;/code&gt; option to the constructor.&lt;/p&gt; &#xA;&lt;h4&gt;Using pagination&lt;/h4&gt; &#xA;&lt;p&gt;Some pagination gems add methods to &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;. For example, &lt;a href=&#34;https://github.com/amatsuda/kaminari&#34;&gt;Kaminari&lt;/a&gt;&#39;s &lt;code&gt;paginate&lt;/code&gt; helper method requires the collection to implement &lt;code&gt;current_page&lt;/code&gt;, &lt;code&gt;total_pages&lt;/code&gt;, and &lt;code&gt;limit_value&lt;/code&gt;. To expose these on a collection decorator, you can delegate to the &lt;code&gt;object&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PaginatingDecorator &amp;lt; Draper::CollectionDecorator&#xA;  delegate :current_page, :total_pages, :limit_value, :entry_name, :total_count, :offset_value, :last_page?&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;delegate&lt;/code&gt; method used here is the same as that added by &lt;a href=&#34;http://api.rubyonrails.org/classes/Module.html#method-i-delegate&#34;&gt;Active Support&lt;/a&gt;, except that the &lt;code&gt;:to&lt;/code&gt; option is not required; it defaults to &lt;code&gt;:object&lt;/code&gt; when omitted.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mislav/will_paginate&#34;&gt;will_paginate&lt;/a&gt; needs the following delegations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;delegate :current_page, :per_page, :offset, :total_entries, :total_pages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If needed, you can then set the collection_decorator_class of your CustomDecorator as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  def self.collection_decorator_class&#xA;    PaginatingDecorator&#xA;  end&#xA;end&#xA;&#xA;ArticleDecorator.decorate_collection(@articles.paginate)&#xA;# =&amp;gt; Collection decorated by PaginatingDecorator&#xA;# =&amp;gt; Members decorated by ArticleDecorator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Decorating Associated Objects&lt;/h3&gt; &#xA;&lt;p&gt;You can automatically decorate associated models when the primary model is decorated. Assuming an &lt;code&gt;Article&lt;/code&gt; model has an associated &lt;code&gt;Author&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates_association :author&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When &lt;code&gt;ArticleDecorator&lt;/code&gt; decorates an &lt;code&gt;Article&lt;/code&gt;, it will also use &lt;code&gt;AuthorDecorator&lt;/code&gt; to decorate the associated &lt;code&gt;Author&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Decorated Finders&lt;/h3&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;decorates_finders&lt;/code&gt; in a decorator...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates_finders&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;...which allows you to then call all the normal ActiveRecord-style finders on your &lt;code&gt;ArticleDecorator&lt;/code&gt; and they&#39;ll return decorated objects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@article = ArticleDecorator.find(params[:id])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Decorated Query Methods&lt;/h3&gt; &#xA;&lt;p&gt;By default, Draper will decorate all &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html&#34;&gt;QueryMethods&lt;/a&gt; of ActiveRecord. If you&#39;re using another ORM, in order to support it, you can tell Draper to use a custom strategy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Draper.configure do |config|&#xA;  config.default_query_methods_strategy = :mongoid&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;When to Decorate Objects&lt;/h3&gt; &#xA;&lt;p&gt;Decorators are supposed to behave very much like the models they decorate, and for that reason it is very tempting to just decorate your objects at the start of your controller action and then use the decorators throughout. &lt;em&gt;Don&#39;t&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Because decorators are designed to be consumed by the view, you should only be accessing them there. Manipulate your models to get things ready, then decorate at the last minute, right before you render the view. This avoids many of the common pitfalls that arise from attempting to modify decorators (in particular, collection decorators) after creating them.&lt;/p&gt; &#xA;&lt;p&gt;To help you make your decorators read-only, we have the &lt;code&gt;decorates_assigned&lt;/code&gt; method in your controller. It adds a helper method that returns the decorated version of an instance variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/articles_controller.rb&#xA;class ArticlesController &amp;lt; ApplicationController&#xA;  decorates_assigned :article&#xA;&#xA;  def show&#xA;    @article = Article.find(params[:id])&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;decorates_assigned :article&lt;/code&gt; bit is roughly equivalent to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def article&#xA;  @decorated_article ||= @article.decorate&#xA;end&#xA;helper_method :article&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that you can just replace &lt;code&gt;@article&lt;/code&gt; with &lt;code&gt;article&lt;/code&gt; in your views and you&#39;ll have access to an ArticleDecorator object instead. In your controller you can continue to use the &lt;code&gt;@article&lt;/code&gt; instance variable to manipulate the model - for example, &lt;code&gt;@article.comments.build&lt;/code&gt; to add a new blank comment for a form.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Draper works out the box well, but also provides a hook for you to configure its default functionality. For example, Draper assumes you have a base &lt;code&gt;ApplicationController&lt;/code&gt;. If your base controller is named something different (e.g. &lt;code&gt;BaseController&lt;/code&gt;), you can tell Draper to use it by adding the following to an initializer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Draper.configure do |config|&#xA;  config.default_controller = BaseController&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Draper supports RSpec, MiniTest::Rails, and Test::Unit, and will add the appropriate tests when you generate a decorator.&lt;/p&gt; &#xA;&lt;h3&gt;RSpec&lt;/h3&gt; &#xA;&lt;p&gt;Your specs are expected to live in &lt;code&gt;spec/decorators&lt;/code&gt;. If you use a different path, you need to tag them with &lt;code&gt;type: :decorator&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In a controller spec, you might want to check whether your instance variables are being decorated properly. You can use the handy predicate matchers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;assigns(:article).should be_decorated&#xA;&#xA;# or, if you want to be more specific&#xA;assigns(:article).should be_decorated_with ArticleDecorator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;model.decorate == model&lt;/code&gt;, so your existing specs shouldn&#39;t break when you add the decoration.&lt;/p&gt; &#xA;&lt;h4&gt;Spork Users&lt;/h4&gt; &#xA;&lt;p&gt;In your &lt;code&gt;Spork.prefork&lt;/code&gt; block of &lt;code&gt;spec_helper.rb&lt;/code&gt;, add this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;draper/test/rspec_integration&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Custom Draper Controller ViewContext&lt;/h4&gt; &#xA;&lt;p&gt;If running tests in an engine setting with a controller other than &#34;ApplicationController,&#34; set a custom controller in &lt;code&gt;spec_helper.rb&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.before(:each, type: :decorator) do |example|&#xA;  Draper::ViewContext.controller = ExampleEngine::CustomRootController.new&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Isolated Tests&lt;/h3&gt; &#xA;&lt;p&gt;In tests, Draper needs to build a view context to access helper methods. By default, it will create an &lt;code&gt;ApplicationController&lt;/code&gt; and then use its view context. If you are speeding up your test suite by testing each component in isolation, you can eliminate this dependency by putting the following in your &lt;code&gt;spec_helper&lt;/code&gt; or similar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Draper::ViewContext.test_strategy :fast&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In doing so, your decorators will no longer have access to your application&#39;s helpers. If you need to selectively include such helpers, you can pass a block:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Draper::ViewContext.test_strategy :fast do&#xA;  include ApplicationHelper&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Stubbing Route Helper Functions&lt;/h4&gt; &#xA;&lt;p&gt;If you are writing isolated tests for Draper methods that call route helper methods, you can stub them instead of needing to require Rails.&lt;/p&gt; &#xA;&lt;p&gt;If you are using RSpec, minitest-rails, or the Test::Unit syntax of minitest, you already have access to the Draper &lt;code&gt;helpers&lt;/code&gt; in your tests since they inherit from &lt;code&gt;Draper::TestCase&lt;/code&gt;. If you are using minitest&#39;s spec syntax without minitest-rails, you can explicitly include the Draper &lt;code&gt;helpers&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe YourDecorator do&#xA;  include Draper::ViewHelpers&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can stub the specific route helper functions you need using your preferred stubbing technique. This examples uses Rspec currently recommended API available in RSpec 3.6+&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;without_partial_double_verification do&#xA;  allow(helpers).to receive(:users_path).and_return(&#39;/users&#39;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;View context leakage&lt;/h3&gt; &#xA;&lt;p&gt;As mentioned before, Draper needs to build a view context to access helper methods. In MiniTest, the view context is cleared during &lt;code&gt;before_setup&lt;/code&gt; preventing any view context leakage. In RSpec, the view context is cleared before each &lt;code&gt;decorator&lt;/code&gt;, &lt;code&gt;controller&lt;/code&gt;, and &lt;code&gt;mailer&lt;/code&gt; spec. However, if you use decorators in other types of specs (e.g. &lt;code&gt;job&lt;/code&gt;), you may still experience the view context leaking from the previous spec. To solve this, add the following to your &lt;code&gt;spec_helper&lt;/code&gt; for each type of spec you are experiencing the leakage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;config.before(:each, type: :type) { Draper::ViewContext.clear! }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: The &lt;code&gt;:type&lt;/code&gt; above is just a placeholder. Replace &lt;code&gt;:type&lt;/code&gt; with the type of spec you are experiencing the leakage from.&lt;/p&gt; &#xA;&lt;h2&gt;Advanced usage&lt;/h2&gt; &#xA;&lt;h3&gt;Shared Decorator Methods&lt;/h3&gt; &#xA;&lt;p&gt;You might have several decorators that share similar needs. Since decorators are just Ruby objects, you can use any normal Ruby technique for sharing functionality.&lt;/p&gt; &#xA;&lt;p&gt;In Rails controllers, common functionality is organized by having all controllers inherit from &lt;code&gt;ApplicationController&lt;/code&gt;. You can apply this same pattern to your decorators:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/decorators/application_decorator.rb&#xA;class ApplicationDecorator &amp;lt; Draper::Decorator&#xA;# ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then modify your decorators to inherit from that &lt;code&gt;ApplicationDecorator&lt;/code&gt; instead of directly from &lt;code&gt;Draper::Decorator&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; ApplicationDecorator&#xA;  # decorator methods&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Delegating Methods&lt;/h3&gt; &#xA;&lt;p&gt;When your decorator calls &lt;code&gt;delegate_all&lt;/code&gt;, any method called on the decorator not defined in the decorator itself will be delegated to the decorated object. This includes calling &lt;code&gt;super&lt;/code&gt; from within the decorator. A call to &lt;code&gt;super&lt;/code&gt; from within the decorator will first try to call the method on the parent decorator class. If the method does not exist on the parent decorator class, it will then try to call the method on the decorated &lt;code&gt;object&lt;/code&gt;. This is a very permissive interface.&lt;/p&gt; &#xA;&lt;p&gt;If you want to strictly control which methods are called within views, you can choose to only delegate certain methods from the decorator to the source model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  delegate :title, :body&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We omit the &lt;code&gt;:to&lt;/code&gt; argument here as it defaults to the &lt;code&gt;object&lt;/code&gt; being decorated. You could choose to delegate methods to other places like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  delegate :title, :body&#xA;  delegate :name, :title, to: :author, prefix: true&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From your view template, assuming &lt;code&gt;@article&lt;/code&gt; is decorated, you could do any of the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;@article.title # Returns the article&#39;s `.title`&#xA;@article.body  # Returns the article&#39;s `.body`&#xA;@article.author_name  # Returns the article&#39;s `author.name`&#xA;@article.author_title # Returns the article&#39;s `author.title`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adding Context&lt;/h3&gt; &#xA;&lt;p&gt;If you need to pass extra data to your decorators, you can use a &lt;code&gt;context&lt;/code&gt; hash. Methods that create decorators take it as an option, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Article.first.decorate(context: {role: :admin})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The value passed to the &lt;code&gt;:context&lt;/code&gt; option is then available in the decorator through the &lt;code&gt;context&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;If you use &lt;code&gt;decorates_association&lt;/code&gt;, the context of the parent decorator is passed to the associated decorators. You can override this with the &lt;code&gt;:context&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates_association :author, context: {foo: &#34;bar&#34;}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, if you want to modify the parent&#39;s context, use a lambda that takes a hash and returns a new hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates_association :author,&#xA;    context: -&amp;gt;(parent_context){ parent_context.merge(foo: &#34;bar&#34;) }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying Decorators&lt;/h3&gt; &#xA;&lt;p&gt;When you&#39;re using &lt;code&gt;decorates_association&lt;/code&gt;, Draper uses the &lt;code&gt;decorate&lt;/code&gt; method on the associated record(s) to perform the decoration. If you want use a specific decorator, you can use the &lt;code&gt;:with&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates_association :author, with: FancyPersonDecorator&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a collection association, you can specify a &lt;code&gt;CollectionDecorator&lt;/code&gt; subclass, which is applied to the whole collection, or a singular &lt;code&gt;Decorator&lt;/code&gt; subclass, which is applied to each item individually.&lt;/p&gt; &#xA;&lt;h3&gt;Scoping Associations&lt;/h3&gt; &#xA;&lt;p&gt;If you want your decorated association to be ordered, limited, or otherwise scoped, you can pass a &lt;code&gt;:scope&lt;/code&gt; option to &lt;code&gt;decorates_association&lt;/code&gt;, which will be applied to the collection &lt;em&gt;before&lt;/em&gt; decoration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates_association :comments, scope: :recent&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Proxying Class Methods&lt;/h3&gt; &#xA;&lt;p&gt;If you want to proxy class methods to the wrapped model class, including when using &lt;code&gt;decorates_finders&lt;/code&gt;, Draper needs to know the model class. By default, it assumes that your decorators are named &lt;code&gt;SomeModelDecorator&lt;/code&gt;, and then attempts to proxy unknown class methods to &lt;code&gt;SomeModel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If your model name can&#39;t be inferred from your decorator name in this way, you need to use the &lt;code&gt;decorates&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MySpecialArticleDecorator &amp;lt; Draper::Decorator&#xA;  decorates :article&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is only necessary when proxying class methods.&lt;/p&gt; &#xA;&lt;p&gt;Once this association between the decorator and the model is set up, you can call &lt;code&gt;SomeModel.decorator_class&lt;/code&gt; to access class methods defined in the decorator. If necessary, you can check if your model is decorated with &lt;code&gt;SomeModel.decorator_class?&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Making Models Decoratable&lt;/h3&gt; &#xA;&lt;p&gt;Models get their &lt;code&gt;decorate&lt;/code&gt; method from the &lt;code&gt;Draper::Decoratable&lt;/code&gt; module, which is included in &lt;code&gt;ActiveRecord::Base&lt;/code&gt; and &lt;code&gt;Mongoid::Document&lt;/code&gt; by default. If you&#39;re using another ORM, or want to decorate plain old Ruby objects, you can include this module manually.&lt;/p&gt; &#xA;&lt;h3&gt;Active Job Integration&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://edgeguides.rubyonrails.org/active_job_basics.html&#34;&gt;Active Job&lt;/a&gt; allows you to pass ActiveRecord objects to background tasks directly and performs the necessary serialization and deserialization. In order to do this, arguments to a background job must implement &lt;a href=&#34;https://github.com/rails/globalid&#34;&gt;Global ID&lt;/a&gt;. Decorated objects implement Global ID by delegating to the object they are decorating. This means you can pass decorated objects to background jobs, however, the object won&#39;t be decorated when it is deserialized.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Draper was conceived by Jeff Casimir and heavily refined by Steve Klabnik and a great community of open source &lt;a href=&#34;https://github.com/drapergem/draper/contributors&#34;&gt;contributors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Current maintainers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cliff Braton (&lt;a href=&#34;mailto:cliff.braton@gmail.com&#34;&gt;cliff.braton@gmail.com&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Historical maintainers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Jeff Casimir (&lt;a href=&#34;mailto:jeff@jumpstartlab.com&#34;&gt;jeff@jumpstartlab.com&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Steve Klabnik (&lt;a href=&#34;mailto:steve@jumpstartlab.com&#34;&gt;steve@jumpstartlab.com&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Vasiliy Ermolovich&lt;/li&gt; &#xA; &lt;li&gt;Andrew Haines&lt;/li&gt; &#xA; &lt;li&gt;Sean Linsley&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>