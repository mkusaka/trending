<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-04T01:47:30Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>gregnavis/active_record_doctor</title>
    <updated>2023-06-04T01:47:30Z</updated>
    <id>tag:github.com,2023-06-04:/gregnavis/active_record_doctor</id>
    <link href="https://github.com/gregnavis/active_record_doctor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Identify database issues before they hit production.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Active Record Doctor&lt;/h1&gt; &#xA;&lt;p&gt;Active Record Doctor helps to keep the database in a good shape. Currently, it can detect:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;extraneous indexes - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#removing-extraneous-indexes&#34;&gt;&lt;code&gt;active_record_doctor:extraneous_indexes&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;unindexed &lt;code&gt;deleted_at&lt;/code&gt; columns - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-unindexed-deleted_at-columns&#34;&gt;&lt;code&gt;active_record_doctor:unindexed_deleted_at&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;missing foreign key constraints - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-missing-foreign-key-constraints&#34;&gt;&lt;code&gt;active_record_doctor:missing_foreign_keys&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;models referencing undefined tables - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-models-referencing-undefined-tables&#34;&gt;&lt;code&gt;active_record_doctor:undefined_table_references&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;uniqueness validations not backed by an unique index - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-uniqueness-validations-not-backed-by-an-index&#34;&gt;&lt;code&gt;active_record_doctor:missing_unique_indexes&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;missing non-&lt;code&gt;NULL&lt;/code&gt; constraints - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-missing-non-null-constraints&#34;&gt;&lt;code&gt;active_record_doctor:missing_non_null_constraint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;missing presence validations - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-missing-presence-validations&#34;&gt;&lt;code&gt;active_record_doctor:missing_presence_validation&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;incorrect presence validations on boolean columns - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-incorrect-presence-validations-on-boolean-columns&#34;&gt;&lt;code&gt;active_record_doctor:incorrect_boolean_presence_validation&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;mismatches between model length validations and database validation constraints - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-incorrect-length-validation&#34;&gt;&lt;code&gt;active_record_doctor:incorrect_length_validation&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;incorrect values of &lt;code&gt;dependent&lt;/code&gt; on associations - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-incorrect-dependent-option-on-associations&#34;&gt;&lt;code&gt;active_record_doctor:incorrect_dependent_option&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;primary keys having short integer types - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-primary-keys-having-short-integer-types&#34;&gt;&lt;code&gt;active_record_doctor:short_primary_key_type&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;mismatched foreign key types - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#detecting-mismatched-foreign-key-types&#34;&gt;&lt;code&gt;active_record_doctor:mismatched_foreign_key_type&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It can also:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;index unindexed foreign keys - &lt;a href=&#34;https://raw.githubusercontent.com/gregnavis/active_record_doctor/master/#indexing-unindexed-foreign-keys&#34;&gt;&lt;code&gt;active_record_doctor:unindexed_foreign_keys&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/gregnavis/active_record_doctor/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/gregnavis/active_record_doctor/actions/workflows/test.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;In order to use the latest production release, please add the following to your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;active_record_doctor&#39;, group: :development&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and run &lt;code&gt;bundle install&lt;/code&gt;. If you&#39;d like to use the most recent development version then use this instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;active_record_doctor&#39;, github: &#39;gregnavis/active_record_doctor&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s it when it comes to Rails projects. If your project doesn&#39;t use Rails then you can use &lt;code&gt;active_record_doctor&lt;/code&gt; via &lt;code&gt;Rakefile&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Additional Installation Steps for non-Rails Projects&lt;/h3&gt; &#xA;&lt;p&gt;If your project uses Rake then you can add the following to &lt;code&gt;Rakefile&lt;/code&gt; in order to use &lt;code&gt;active_record_doctor&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;active_record_doctor&#34;&#xA;&#xA;ActiveRecordDoctor::Rake::Task.new do |task|&#xA;  # Add project-specific Rake dependencies that should be run before running&#xA;  # active_record_doctor.&#xA;  task.deps = []&#xA;&#xA;  # A path to your active_record_doctor configuration file.&#xA;  task.config_path = ::Rails.root.join(&#34;.active_record_doctor&#34;)&#xA;&#xA;  # A Proc called right before running detectors that should ensure your Active&#xA;  # Record models are preloaded and a database connection is ready.&#xA;  task.setup = -&amp;gt; { ::Rails.application.eager_load! }&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;. &lt;code&gt;active_record_doctor&lt;/code&gt; expects that after running &lt;code&gt;deps&lt;/code&gt; and calling &lt;code&gt;setup&lt;/code&gt; your Active Record models are loaded and a database connection is established.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;active_record_doctor&lt;/code&gt; can be used via &lt;code&gt;rake&lt;/code&gt; or &lt;code&gt;rails&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can run all available detectors via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run a specific detector via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:extraneous_indexes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Continuous Integration&lt;/h3&gt; &#xA;&lt;p&gt;If you want to use &lt;code&gt;active_record_doctor&lt;/code&gt; in a Continuous Integration setting then ensure the configuration file is committed and run the tool as one of your build steps -- it returns a non-zero exit status if any errors were reported.&lt;/p&gt; &#xA;&lt;h3&gt;Obtaining Help&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;d like to obtain help on a specific detector then use the &lt;code&gt;help&lt;/code&gt; sub-task:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:extraneous_indexes:help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will show the detector help text in the terminal, along with supported configuration options, their meaning, and whether they&#39;re global or local.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;active_record_doctor&lt;/code&gt; can be configured to better suit your project&#39;s needs. For example, if it complains about a model that you want ignored then you can add that model to the configuration file.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use the default configuration then you don&#39;t have to do anything. Just run &lt;code&gt;active_record_doctor&lt;/code&gt; in your project directory.&lt;/p&gt; &#xA;&lt;p&gt;If you want to customize the tool you should create a file named &lt;code&gt;.active_record_doctor&lt;/code&gt; in your project root directory with content like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;ActiveRecordDoctor.configure do&#xA;  # Global settings affect all detectors.&#xA;  global :ignore_tables, [&#xA;    # Ignore internal Rails-related tables.&#xA;    &#34;ar_internal_metadata&#34;,&#xA;    &#34;schema_migrations&#34;,&#xA;    &#34;active_storage_blobs&#34;,&#xA;    &#34;active_storage_attachments&#34;,&#xA;    &#34;action_text_rich_texts&#34;,&#xA;&#xA;    # Add project-specific tables here.&#xA;    &#34;legacy_users&#34;&#xA;  ]&#xA;&#xA;  # Detector-specific settings affect only one specific detector.&#xA;  detector :extraneous_indexes,&#xA;    ignore_tables: [&#34;users&#34;],&#xA;    ignore_indexes: [&#34;accounts_on_email_organization_id&#34;]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The configuration file above will make &lt;code&gt;active_record_doctor&lt;/code&gt; ignore internal Rails tables (which are ignored by default) and also the &lt;code&gt;legacy_users&lt;/code&gt; table. It&#39;ll also make the &lt;code&gt;extraneous_indexes&lt;/code&gt; detector skip the &lt;code&gt;users&lt;/code&gt; table entirely and will not report the index named &lt;code&gt;accounts_on_email_organization_id&lt;/code&gt; as extraneous.&lt;/p&gt; &#xA;&lt;p&gt;Configuration options for each detector are listed below. They can also be obtained via the help mechanism described in the previous section.&lt;/p&gt; &#xA;&lt;h3&gt;Indexing Unindexed Foreign Keys&lt;/h3&gt; &#xA;&lt;p&gt;Foreign keys should be indexed unless it&#39;s proven ineffective. However, Rails makes it easy to create an unindexed foreign key. Active Record Doctor can automatically generate database migrations that add the missing indexes. It&#39;s a three-step process:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Generate a list of unindexed foreign keys by running&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec rake active_record_doctor:unindexed_foreign_keys &amp;gt; unindexed_foreign_keys.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Remove columns that should &lt;em&gt;not&lt;/em&gt; be indexed from &lt;code&gt;unindexed_foreign_keys.txt&lt;/code&gt; as a column can look like a foreign key (i.e. end with &lt;code&gt;_id&lt;/code&gt;) without being one.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Generate the migrations&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;rails generate active_record_doctor:add_indexes unindexed_foreign_keys.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Run the migrations&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec rake db:migrate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose foreign keys should not be checked&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - columns, written as table.column, that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Removing Extraneous Indexes&lt;/h3&gt; &#xA;&lt;p&gt;Let me illustrate with an example. Consider a &lt;code&gt;users&lt;/code&gt; table with columns &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt;. If there are two indexes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A two-column index on &lt;code&gt;last_name, first_name&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A single-column index on &lt;code&gt;last_name&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then the latter index can be dropped as the former can play its role. In general, a multi-column index on &lt;code&gt;column_1, column_2, ..., column_n&lt;/code&gt; can replace indexes on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;column_1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;column_1, column_2&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;...&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;column_1, column_2, ..., column_(n - 1)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To discover such indexes automatically just follow these steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;List extraneous indexes by running:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec rake active_record_doctor:extraneous_indexes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Confirm that each of the indexes can be indeed dropped.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a migration to drop the indexes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The indexes aren&#39;t dropped automatically because there&#39;s usually just a few of them and it&#39;s a good idea to double-check that you won&#39;t drop something necessary.&lt;/p&gt; &#xA;&lt;p&gt;Also, extra indexes on primary keys are considered extraneous too and will be reported.&lt;/p&gt; &#xA;&lt;p&gt;Note that a unique index can &lt;em&gt;never be replaced by a non-unique one&lt;/em&gt;. For example, if there&#39;s a unique index on &lt;code&gt;users.login&lt;/code&gt; and a non-unique index on &lt;code&gt;users.login, users.domain&lt;/code&gt; then the tool will &lt;em&gt;not&lt;/em&gt; suggest dropping &lt;code&gt;users.login&lt;/code&gt; as it could violate the uniqueness assumption. However, a unique index on &lt;code&gt;users.login, user.domain&lt;/code&gt; might be replaceable with &lt;code&gt;users.login&lt;/code&gt; as the uniqueness of the latter implies the uniqueness of the former (if a given &lt;code&gt;login&lt;/code&gt; can appear only once then it can be present in only one &lt;code&gt;login, domain&lt;/code&gt; pair).&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose indexes should never be reported as extraneous.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - indexes that should never be reported as extraneous.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Unindexed &lt;code&gt;deleted_at&lt;/code&gt; Columns&lt;/h3&gt; &#xA;&lt;p&gt;If you soft-delete some models (e.g. with &lt;code&gt;paranoia&lt;/code&gt;) then you need to modify your indexes to include only non-deleted rows. Otherwise they will include logically non-existent rows. This will make them larger and slower to use. Most of the time they should only cover columns satisfying &lt;code&gt;deleted_at IS NULL&lt;/code&gt; (to cover existing records) or &lt;code&gt;deleted_at IS NOT NULL&lt;/code&gt; (to cover deleted records).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;active_record_doctor&lt;/code&gt; can automatically detect indexes on tables with a &lt;code&gt;deleted_at&lt;/code&gt; column. Just run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:unindexed_deleted_at&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will print a list of indexes that don&#39;t have the &lt;code&gt;deleted_at IS NULL&lt;/code&gt; clause. Currently, &lt;code&gt;active_record_doctor&lt;/code&gt; cannot automatically generate appropriate migrations. You need to do that manually.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose indexes should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - specific columns, written as table.column, that should not be reported as unindexed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_indexes&lt;/code&gt; - specific indexes that should not be reported as excluding a timestamp column.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;column_names&lt;/code&gt; - deletion timestamp column names.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Missing Foreign Key Constraints&lt;/h3&gt; &#xA;&lt;p&gt;If &lt;code&gt;users.profile_id&lt;/code&gt; references a row in &lt;code&gt;profiles&lt;/code&gt; then this can be expressed at the database level with a foreign key constraint. It &lt;em&gt;forces&lt;/em&gt; &lt;code&gt;users.profile_id&lt;/code&gt; to point to an existing row in &lt;code&gt;profiles&lt;/code&gt;. The problem is that in many legacy Rails apps the constraint isn&#39;t enforced at the database level.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;active_record_doctor&lt;/code&gt; can automatically detect foreign keys that could benefit from a foreign key constraint (a future version will generate a migrations that add the constraint; for now, it&#39;s your job). You can obtain the list of foreign keys with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bundle exec rake active_record_doctor:missing_foreign_keys&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order to add a foreign key constraint to &lt;code&gt;users.profile_id&lt;/code&gt; use a migration like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AddForeignKeyConstraintToUsersProfileId &amp;lt; ActiveRecord::Migration&#xA;  def change&#xA;    add_foreign_key :users, :profiles&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose columns should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - columns, written as table.column, that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Models Referencing Undefined Tables&lt;/h3&gt; &#xA;&lt;p&gt;Active Record guesses the table name based on the class name. There are a few cases where the name can be wrong (e.g. you forgot to commit a migration or changed the table name). Active Record Doctor can help you identify these cases before they hit production.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;. Models backed by views are supported only in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rails 5+ and &lt;em&gt;any&lt;/em&gt; database or&lt;/li&gt; &#xA; &lt;li&gt;Rails 4.2 with PostgreSQL.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The only think you need to do is run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:undefined_table_references&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there a model references an undefined table then you&#39;ll see a message like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Contract references a non-existent table or view named contract_records&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On top of that &lt;code&gt;rake&lt;/code&gt; will exit with status code of 1. This allows you to use this check as part of your Continuous Integration pipeline.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_models&lt;/code&gt; - models whose underlying tables should not be checked for existence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Uniqueness Validations not Backed by an Index&lt;/h3&gt; &#xA;&lt;p&gt;Model-level uniqueness validations and &lt;code&gt;has_one&lt;/code&gt; associations should be backed by a database index in order to be robust. Otherwise you risk inserting duplicate values under heavy load.&lt;/p&gt; &#xA;&lt;p&gt;In order to detect such validations run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:missing_unique_indexes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If there are such indexes then the command will print:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;add a unique index on users(email) - validating uniqueness in the model without an index can lead to duplicates&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that you should create a unique index on &lt;code&gt;users.email&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_models&lt;/code&gt; - models whose uniqueness validators should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - specific validators, written as Model(column1, ...), that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Missing Non-&lt;code&gt;NULL&lt;/code&gt; Constraints&lt;/h3&gt; &#xA;&lt;p&gt;If there&#39;s an unconditional presence validation on a column then it should be marked as non-&lt;code&gt;NULL&lt;/code&gt;-able at the database level or should have a &lt;code&gt;IS NOT NULL&lt;/code&gt; constraint.&lt;/p&gt; &#xA;&lt;p&gt;In order to detect columns whose presence is required but that are marked &lt;code&gt;null: true&lt;/code&gt; in the database run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:missing_non_null_constraint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command is similar to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;add `NOT NULL` to users.name - models validates its presence but it&#39;s not non-NULL in the database&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can mark the columns mentioned in the output as &lt;code&gt;null: false&lt;/code&gt; by creating a migration and calling &lt;code&gt;change_column_null&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This validator skips models whose corresponding database tables don&#39;t exist.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose columns should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - columns, written as table.column, that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Missing Presence Validations&lt;/h3&gt; &#xA;&lt;p&gt;If a column is marked as &lt;code&gt;null: false&lt;/code&gt; then it&#39;s likely it should have the corresponding presence validator.&lt;/p&gt; &#xA;&lt;p&gt;In order to detect models lacking these validations run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:missing_presence_validation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;add a `presence` validator to User.email - it&#39;s NOT NULL but lacks a validator&#xA;add a `presence` validator to User.name - it&#39;s NOT NULL but lacks a validator&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means &lt;code&gt;User&lt;/code&gt; should have a presence validator on &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This validator skips models whose corresponding database tables don&#39;t exist.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_models&lt;/code&gt; - models whose underlying tables&#39; columns should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_attributes&lt;/code&gt; - specific attributes, written as Model.attribute, that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Incorrect Presence Validations on Boolean Columns&lt;/h3&gt; &#xA;&lt;p&gt;A boolean column&#39;s presence should be validated using inclusion or exclusion validators instead of the usual presence validator.&lt;/p&gt; &#xA;&lt;p&gt;In order to detect boolean columns whose presence is validated incorrectly run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:incorrect_boolean_presence_validation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;replace the `presence` validator on User.active with `inclusion` - `presence` can&#39;t be used on booleans&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means &lt;code&gt;active&lt;/code&gt; is validated with &lt;code&gt;presence: true&lt;/code&gt; instead of &lt;code&gt;inclusion: { in: [true, false] }&lt;/code&gt; or &lt;code&gt;exclusion: { in: [nil] }&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This validator skips models whose corresponding database tables don&#39;t exist.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_models&lt;/code&gt; - models whose validators should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - attributes, written as Model.attribute, whose validators should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Incorrect Length Validations&lt;/h3&gt; &#xA;&lt;p&gt;String length can be enforced by both the database and the application. If there&#39;s a database limit then it&#39;s a good idea to add a model validation to ensure user-friendly error messages. Similarly, if there&#39;s a model validator without the corresponding database constraint then it&#39;s a good idea to add one to avoid saving invalid models.&lt;/p&gt; &#xA;&lt;p&gt;In order to detect columns whose length isn&#39;t validated properly run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:incorrect_length_validation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;set the maximum length in the validator of User.email (currently 32) and the database limit on users.email (currently 64) to the same value&#xA;add a length validator on User.address to enforce a maximum length of 64 defined on users.address&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first message means the validator on &lt;code&gt;User.email&lt;/code&gt; is checking for a different maximum than the database limit on &lt;code&gt;users.email&lt;/code&gt;. The second message means there&#39;s a database limit on &lt;code&gt;users.address&lt;/code&gt; without the corresponding model validation.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_models&lt;/code&gt; - models whose validators should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - attributes, written as Model.attribute, whose validators should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Incorrect &lt;code&gt;dependent&lt;/code&gt; Option on Associations&lt;/h3&gt; &#xA;&lt;p&gt;Cascading model deletions can be sped up with &lt;code&gt;dependent: :delete_all&lt;/code&gt; (to delete all dependent models with one SQL query) but only if the deleted models have no callbacks as they&#39;re skipped.&lt;/p&gt; &#xA;&lt;p&gt;This can lead to two types of errors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using &lt;code&gt;delete_all&lt;/code&gt; when dependent models define callbacks - they will NOT be invoked.&lt;/li&gt; &#xA; &lt;li&gt;Using &lt;code&gt;destroy&lt;/code&gt; when dependent models define no callbacks - dependent models will be loaded one-by-one with no reason&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In order to detect associations affected by the two aforementioned problems run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:incorrect_dependent_option&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;use `dependent: :delete_all` or similar on Company.users - associated models have no validations and can be deleted in bulk&#xA;use `dependent: :destroy` or similar on Post.comments - the associated model has callbacks that are currently skipped&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_models&lt;/code&gt; - models whose associations should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_associations&lt;/code&gt; - associations, written as Model.association, that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Primary Keys Having Short Integer Types&lt;/h3&gt; &#xA;&lt;p&gt;Active Record 5.1 changed the default primary and foreign key type from INTEGER to BIGINT. The reason is to reduce the risk of running out of IDs on inserts.&lt;/p&gt; &#xA;&lt;p&gt;In order to detect primary keys using shorter integer types, for example created before migrating to 5.1, you can run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:short_primary_key_type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;change the type of companies.id to bigint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above means &lt;code&gt;comanies.id&lt;/code&gt; should be migrated to a wider integer type. An example migration to accomplish this looks likes this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ChangeCompaniesPrimaryKeyType &amp;lt; ActiveRecord::Migration[5.1]&#xA;  def change&#xA;    change_column :companies, :id, :bigint&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt;. Running the above migration on a large table can cause downtime as all rows need to be rewritten.&lt;/p&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose primary keys should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Detecting Mismatched Foreign Key Types&lt;/h3&gt; &#xA;&lt;p&gt;Foreign keys should be of the same type as the referenced primary key. Otherwise, there&#39;s a risk of bugs caused by IDs representable by one type but not the other.&lt;/p&gt; &#xA;&lt;p&gt;Running the command below will list all foreign keys whose type is different from the referenced primary key:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bundle exec rake active_record_doctor:mismatched_foreign_key_type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the command looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;companies.user_id references a column of different type - foreign keys should be of the same type as the referenced column&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supported configuration options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;enabled&lt;/code&gt; - set to &lt;code&gt;false&lt;/code&gt; to disable the detector altogether&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_tables&lt;/code&gt; - tables whose foreign keys should not be checked.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignore_columns&lt;/code&gt; - foreign keys, written as table.column, that should not be checked.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ruby and Rails Compatibility Policy&lt;/h2&gt; &#xA;&lt;p&gt;The goal of the policy is to ensure proper functioning in reasonable combinations of Ruby and Rails versions. Specifically:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;If a Rails version is officially supported by the Rails Core Team then it&#39;s supported by &lt;code&gt;active_record_doctor&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If a Ruby version is compatible with a supported Rails version then it&#39;s also supported by &lt;code&gt;active_record_doctor&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Only most recent teeny Ruby versions and patch Rails versions are supported.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;This gem is developed and maintained by &lt;a href=&#34;http://www.gregnavis.com&#34;&gt;Greg Navis&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>