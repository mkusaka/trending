<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-27T01:43:52Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>rportella/blog</title>
    <updated>2023-02-27T01:43:52Z</updated>
    <id>tag:github.com,2023-02-27:/rportella/blog</id>
    <link href="https://github.com/rportella/blog" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;== Welcome to Rails&lt;/p&gt; &#xA;&lt;p&gt;Rails is a web-application framework that includes everything needed to create database-backed web applications according to the Model-View-Control pattern.&lt;/p&gt; &#xA;&lt;p&gt;This pattern splits the view (also called the presentation) into &#34;dumb&#34; templates that are primarily responsible for inserting pre-built data in between HTML tags. The model contains the &#34;smart&#34; domain objects (such as Account, Product, Person, Post) that holds all the business logic and knows how to persist themselves to a database. The controller handles the incoming requests (such as Save New Account, Update Product, Show Post) by manipulating the model and directing data to the view.&lt;/p&gt; &#xA;&lt;p&gt;In Rails, the model is handled by what&#39;s called an object-relational mapping layer entitled Active Record. This layer allows you to present the data from database rows as objects and embellish these data objects with business logic methods. You can read more about Active Record in link:files/vendor/rails/activerecord/README.html.&lt;/p&gt; &#xA;&lt;p&gt;The controller and view are handled by the Action Pack, which handles both layers by its two parts: Action View and Action Controller. These two layers are bundled in a single package due to their heavy interdependence. This is unlike the relationship between the Active Record and Action Pack that is much more separate. Each of these packages can be used independently outside of Rails. You can read more about Action Pack in link:files/vendor/rails/actionpack/README.html.&lt;/p&gt; &#xA;&lt;p&gt;== Getting Started&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;At the command prompt, create a new Rails application: &lt;tt&gt;rails new myapp&lt;/tt&gt; (where &lt;tt&gt;myapp&lt;/tt&gt; is the application name)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Change directory to &lt;tt&gt;myapp&lt;/tt&gt; and start the web server: &lt;tt&gt;cd myapp; rails server&lt;/tt&gt; (run with --help for options)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Go to &lt;a href=&#34;http://localhost:3000/&#34;&gt;http://localhost:3000/&lt;/a&gt; and you&#39;ll see: &#34;Welcome aboard: You&#39;re riding Ruby on Rails!&#34;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Follow the guidelines to start developing your application. You can find the following resources handy:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Getting Started Guide: &lt;a href=&#34;http://guides.rubyonrails.org/getting_started.html&#34;&gt;http://guides.rubyonrails.org/getting_started.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ruby on Rails Tutorial Book: &lt;a href=&#34;http://www.railstutorial.org/&#34;&gt;http://www.railstutorial.org/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;== Debugging Rails&lt;/p&gt; &#xA;&lt;p&gt;Sometimes your application goes wrong. Fortunately there are a lot of tools that will help you debug it and get it back on the rails.&lt;/p&gt; &#xA;&lt;p&gt;First area to check is the application log files. Have &#34;tail -f&#34; commands running on the server.log and development.log. Rails will automatically display debugging and runtime information to these files. Debugging info will also be shown in the browser on requests from 127.0.0.1.&lt;/p&gt; &#xA;&lt;p&gt;You can also log your own messages directly into the log file from your code using the Ruby logger class from inside your controllers. Example:&lt;/p&gt; &#xA;&lt;p&gt;class WeblogController &amp;lt; ActionController::Base def destroy @weblog = Weblog.find(params[:id]) @weblog.destroy logger.info(&#34;#{Time.now} Destroyed Weblog ID ##{@weblog.id}!&#34;) end end&lt;/p&gt; &#xA;&lt;p&gt;The result will be a message in your log file along the lines of:&lt;/p&gt; &#xA;&lt;p&gt;Mon Oct 08 14:22:29 +1000 2007 Destroyed Weblog ID #1!&lt;/p&gt; &#xA;&lt;p&gt;More information on how to use the logger is at &lt;a href=&#34;http://www.ruby-doc.org/core/&#34;&gt;http://www.ruby-doc.org/core/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also, Ruby documentation can be found at &lt;a href=&#34;http://www.ruby-lang.org/&#34;&gt;http://www.ruby-lang.org/&lt;/a&gt;. There are several books available online as well:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Programming Ruby: &lt;a href=&#34;http://www.ruby-doc.org/docs/ProgrammingRuby/&#34;&gt;http://www.ruby-doc.org/docs/ProgrammingRuby/&lt;/a&gt; (Pickaxe)&lt;/li&gt; &#xA; &lt;li&gt;Learn to Program: &lt;a href=&#34;http://pine.fm/LearnToProgram/&#34;&gt;http://pine.fm/LearnToProgram/&lt;/a&gt; (a beginners guide)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These two books will bring you up to speed on the Ruby language and also on programming in general.&lt;/p&gt; &#xA;&lt;p&gt;== Debugger&lt;/p&gt; &#xA;&lt;p&gt;Debugger support is available through the debugger command when you start your Mongrel or WEBrick server with --debugger. This means that you can break out of execution at any point in the code, investigate and change the model, and then, resume execution! You need to install ruby-debug to run the server in debugging mode. With gems, use &lt;tt&gt;sudo gem install ruby-debug&lt;/tt&gt;. Example:&lt;/p&gt; &#xA;&lt;p&gt;class WeblogController &amp;lt; ActionController::Base def index @posts = Post.all debugger end end&lt;/p&gt; &#xA;&lt;p&gt;So the controller will accept the action, run the first line, then present you with a IRB prompt in the server window. Here you can do things like:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;@posts.inspect =&amp;gt; &#34;[#&amp;lt;Post:0x14a6be8 @attributes={&#34;title&#34;=&amp;gt;nil, &#34;body&#34;=&amp;gt;nil, &#34;id&#34;=&amp;gt;&#34;1&#34;}&amp;gt;, #&amp;lt;Post:0x14a6620 @attributes={&#34;title&#34;=&amp;gt;&#34;Rails&#34;, &#34;body&#34;=&amp;gt;&#34;Only ten..&#34;, &#34;id&#34;=&amp;gt;&#34;2&#34;}&amp;gt;]&#34; @posts.first.title = &#34;hello from a debugger&#34; =&amp;gt; &#34;hello from a debugger&#34;&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;...and even better, you can examine how your runtime objects actually work:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;f = @posts.first =&amp;gt; #&amp;lt;Post:0x13630c4 @attributes={&#34;title&#34;=&amp;gt;nil, &#34;body&#34;=&amp;gt;nil, &#34;id&#34;=&amp;gt;&#34;1&#34;}&amp;gt; f. Display all 152 possibilities? (y or n)&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Finally, when you&#39;re ready to resume execution, you can enter &#34;cont&#34;.&lt;/p&gt; &#xA;&lt;p&gt;== Console&lt;/p&gt; &#xA;&lt;p&gt;The console is a Ruby shell, which allows you to interact with your application&#39;s domain model. Here you&#39;ll have all parts of the application configured, just like it is when the application is running. You can inspect domain models, change values, and save to the database. Starting the script without arguments will launch it in the development environment.&lt;/p&gt; &#xA;&lt;p&gt;To start the console, run &lt;tt&gt;rails console&lt;/tt&gt; from the application directory.&lt;/p&gt; &#xA;&lt;p&gt;Options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Passing the &lt;tt&gt;-s, --sandbox&lt;/tt&gt; argument will rollback any modifications made to the database.&lt;/li&gt; &#xA; &lt;li&gt;Passing an environment name as an argument will load the corresponding environment. Example: &lt;tt&gt;rails console production&lt;/tt&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To reload your controllers and models after launching the console run &lt;tt&gt;reload!&lt;/tt&gt;&lt;/p&gt; &#xA;&lt;p&gt;More information about irb can be found at: link:&lt;a href=&#34;http://www.rubycentral.org/pickaxe/irb.html&#34;&gt;http://www.rubycentral.org/pickaxe/irb.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;== dbconsole&lt;/p&gt; &#xA;&lt;p&gt;You can go to the command line of your database directly through &lt;tt&gt;rails dbconsole&lt;/tt&gt;. You would be connected to the database with the credentials defined in database.yml. Starting the script without arguments will connect you to the development database. Passing an argument will connect you to a different database, like &lt;tt&gt;rails dbconsole production&lt;/tt&gt;. Currently works for MySQL, PostgreSQL and SQLite 3.&lt;/p&gt; &#xA;&lt;p&gt;== Description of Contents&lt;/p&gt; &#xA;&lt;p&gt;The default directory structure of a generated Ruby on Rails application:&lt;/p&gt; &#xA;&lt;p&gt;|-- app | |-- assets | |-- images | |-- javascripts | &lt;code&gt;-- stylesheets | |-- controllers | |-- helpers | |-- mailers | |-- models | &lt;/code&gt;-- views | &lt;code&gt;-- layouts |-- config | |-- environments | |-- initializers | &lt;/code&gt;-- locales |-- db |-- doc |-- lib | &lt;code&gt;-- tasks |-- log |-- public |-- script |-- test | |-- fixtures | |-- functional | |-- integration | |-- performance | &lt;/code&gt;-- unit |-- tmp | |-- cache | |-- pids | |-- sessions | &lt;code&gt;-- sockets &lt;/code&gt;-- vendor |-- assets &lt;code&gt;-- stylesheets &lt;/code&gt;-- plugins&lt;/p&gt; &#xA;&lt;p&gt;app Holds all the code that&#39;s specific to this particular application.&lt;/p&gt; &#xA;&lt;p&gt;app/assets Contains subdirectories for images, stylesheets, and JavaScript files.&lt;/p&gt; &#xA;&lt;p&gt;app/controllers Holds controllers that should be named like weblogs_controller.rb for automated URL mapping. All controllers should descend from ApplicationController which itself descends from ActionController::Base.&lt;/p&gt; &#xA;&lt;p&gt;app/models Holds models that should be named like post.rb. Models descend from ActiveRecord::Base by default.&lt;/p&gt; &#xA;&lt;p&gt;app/views Holds the template files for the view that should be named like weblogs/index.html.erb for the WeblogsController#index action. All views use eRuby syntax by default.&lt;/p&gt; &#xA;&lt;p&gt;app/views/layouts Holds the template files for layouts to be used with views. This models the common header/footer method of wrapping views. In your views, define a layout using the &lt;tt&gt;layout :default&lt;/tt&gt; and create a file named default.html.erb. Inside default.html.erb, call &amp;lt;% yield %&amp;gt; to render the view using this layout.&lt;/p&gt; &#xA;&lt;p&gt;app/helpers Holds view helpers that should be named like weblogs_helper.rb. These are generated for you automatically when using generators for controllers. Helpers can be used to wrap functionality for your views into methods.&lt;/p&gt; &#xA;&lt;p&gt;config Configuration files for the Rails environment, the routing map, the database, and other dependencies.&lt;/p&gt; &#xA;&lt;p&gt;db Contains the database schema in schema.rb. db/migrate contains all the sequence of Migrations for your schema.&lt;/p&gt; &#xA;&lt;p&gt;doc This directory is where your application documentation will be stored when generated using &lt;tt&gt;rake doc:app&lt;/tt&gt;&lt;/p&gt; &#xA;&lt;p&gt;lib Application specific libraries. Basically, any kind of custom code that doesn&#39;t belong under controllers, models, or helpers. This directory is in the load path.&lt;/p&gt; &#xA;&lt;p&gt;public The directory available for the web server. Also contains the dispatchers and the default HTML files. This should be set as the DOCUMENT_ROOT of your web server.&lt;/p&gt; &#xA;&lt;p&gt;script Helper scripts for automation and generation.&lt;/p&gt; &#xA;&lt;p&gt;test Unit and functional tests along with fixtures. When using the rails generate command, template test files will be generated for you and placed in this directory.&lt;/p&gt; &#xA;&lt;p&gt;vendor External libraries that the application depends on. Also includes the plugins subdirectory. If the app has frozen rails, those gems also go here, under vendor/rails/. This directory is in the load path.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-chatterbox-sinatra-react-lab</title>
    <updated>2023-02-27T01:43:52Z</updated>
    <id>tag:github.com,2023-02-27:/learn-co-curriculum/phase-3-chatterbox-sinatra-react-lab</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-chatterbox-sinatra-react-lab" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sinatra React Lab: Chatterbox&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create an API with Sinatra for a React frontend application&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;So far, we&#39;ve seen how to build a Sinatra API and perform various CRUD actions using Active Record. In this lab, you&#39;ll work on creating an API in Sinatra once more — but this time, you&#39;ll also have code for a React frontend application, so you can get a taste of full-stack development!&lt;/p&gt; &#xA;&lt;p&gt;This project is separated into two applications:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A React frontend, in the &lt;code&gt;chatterbox-client&lt;/code&gt; directory&lt;/li&gt; &#xA; &lt;li&gt;A Sinatra backend, in the &lt;code&gt;chatterbox-server&lt;/code&gt; directory&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of the features for the React frontend are built out, and we have a simple &lt;code&gt;json-server&lt;/code&gt; API that you can run to see what the completed version of the app will look like. Your main goal with this lab is to build out a Sinatra API server to replace &lt;code&gt;json-server&lt;/code&gt;, so most of your coding will be done in the backend.&lt;/p&gt; &#xA;&lt;h2&gt;Frontend Setup&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s take a quick tour of what we have so far.&lt;/p&gt; &#xA;&lt;p&gt;To get started, &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;chatterbox-client&lt;/code&gt; directory. Then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ npm install&#xA;$ npm run server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will install the React project dependencies, and run a demo API server using &lt;code&gt;json-server&lt;/code&gt;. Next, run this in a new terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ npm start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then visit &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt; in the browser and interact with the demo application to get a sense of its features.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a demo of the what the React app should look like when using &lt;code&gt;json-server&lt;/code&gt; as the API:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-3/chatterbox-sinatra-react-lab/chatterbox-demo.gif&#34; alt=&#34;Chatterbox demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Take a look at the components provided in the &lt;code&gt;chatterbox-client&lt;/code&gt; directory. Explore the code and pay special attention to where the React application is interacting with &lt;code&gt;json-server&lt;/code&gt;. Where are the &lt;code&gt;fetch&lt;/code&gt; requests being written? What routes are needed to handle these requests? What HTTP verbs? What data is being sent in the body of the requests?&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve familiarized yourself yourself with the code, turn off &lt;code&gt;json-server&lt;/code&gt; with &lt;code&gt;control + c&lt;/code&gt; in the terminal where &lt;code&gt;json-server&lt;/code&gt; is running (you can keep the React application running, though). Next, let&#39;s see what we have in the backend.&lt;/p&gt; &#xA;&lt;h2&gt;Backend Setup&lt;/h2&gt; &#xA;&lt;p&gt;In another terminal, &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;chatterbox-server&lt;/code&gt; directory, and run &lt;code&gt;bundle install&lt;/code&gt; to install the dependencies.&lt;/p&gt; &#xA;&lt;p&gt;In this directory, you&#39;re given a bare-bones template for a Sinatra API application. It should look familiar to other Sinatra labs you&#39;ve seen and has all the code set up so you can focus on building out your model and API routes.&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll be responsible for:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Creating a model and migrations&lt;/li&gt; &#xA; &lt;li&gt;Setting up the necessary routes to handle requests&lt;/li&gt; &#xA; &lt;li&gt;Performing CRUD actions with Active Records&lt;/li&gt; &#xA; &lt;li&gt;Sending the necessary JSON data in the responses&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Allowing Frontend Requests: CORS&lt;/h3&gt; &#xA;&lt;p&gt;The only new code for the server is the &lt;a href=&#34;https://github.com/cyu/rack-cors&#34;&gt;Rack CORS gem&lt;/a&gt;. This gem provides some Rack middleware which we need to configure so that applications running in the browser, like our React client, can make requests to the backend.&lt;/p&gt; &#xA;&lt;p&gt;If we didn&#39;t use this gem, any requests from our React frontend in the browser would result in an error message like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Access to fetch at &#39;http://localhost:9292/messages&#39; from origin&#xA;&#39;http://localhost:3000&#39; has been blocked by CORS policy: No&#xA;&#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. If an&#xA;opaque response serves your needs, set the request&#39;s mode to &#39;no-cors&#39; to fetch&#xA;the resource with CORS disabled.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for this warning message is due to a browser security feature known as &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt;. When we use JavaScript from one domain (aka origin) to make a request to a server on a different domain, the default behavior of the browser is to block those requests from going through.&lt;/p&gt; &#xA;&lt;p&gt;For example, if I own the website &lt;code&gt;definitelynotahacker.com&lt;/code&gt;, I can&#39;t use JavaScript to make a network request to &lt;code&gt;api.yourbankaccount.com&lt;/code&gt;, unless &lt;code&gt;api.yourbankaccount.com&lt;/code&gt; explicitly gives permission to my website.&lt;/p&gt; &#xA;&lt;p&gt;To give that permission, any server that we want to make requests to using JavaScript must add some special &lt;strong&gt;headers&lt;/strong&gt; to the response that tell the browser that the request was permitted.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s what the CORS configuration looks like (in the &lt;code&gt;config.ru&lt;/code&gt; file):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# Allow CORS (Cross-Origin Resource Sharing) requests&#xA;use Rack::Cors do&#xA;  allow do&#xA;    # origins &#39;*&#39; allows requests from ALL frontend origins&#xA;    # (if you deploy your application, change this to&#xA;    # ONLY allow requests from YOUR frontend origin, like:&#xA;    # origins &#39;my-react-app.netlify.app&#39;)&#xA;    origins &#39;*&#39;&#xA;    resource &#39;*&#39;, headers: :any, methods: [:get, :post, :delete, :put, :patch, :options, :head]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You don&#39;t have to make any changes to this configuration to complete this lab, but CORS warnings are a very common thing to encounter in web development, so next time you see them, you&#39;ll know what this means!&lt;/p&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;Work through the deliverables below. There are tests in the &lt;code&gt;chatterbox-server&lt;/code&gt; folder. Because of this lab&#39;s project structure, running &lt;code&gt;learn test&lt;/code&gt; won&#39;t work — instead, you&#39;ll need to &lt;code&gt;cd&lt;/code&gt; into the &lt;code&gt;chatterbox-server&lt;/code&gt; directory and run &lt;code&gt;rspec&lt;/code&gt; (or &lt;code&gt;bundle exec rspec&lt;/code&gt;) to run the tests for the Sinatra backend.&lt;/p&gt; &#xA;&lt;p&gt;Make sure to try out your routes from the React frontend application as well once you have everything set up. You can run your Sinatra server with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to change the &lt;code&gt;fetch&lt;/code&gt; requests in React to use &lt;code&gt;http://localhost:9292&lt;/code&gt; as well.&lt;/p&gt; &#xA;&lt;h3&gt;Model&lt;/h3&gt; &#xA;&lt;p&gt;Start by generating a &lt;code&gt;Message&lt;/code&gt; model and the necessary migration code to create messages with the following attributes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;body: string&lt;/li&gt; &#xA; &lt;li&gt;username: string&lt;/li&gt; &#xA; &lt;li&gt;created_at: timestamp&lt;/li&gt; &#xA; &lt;li&gt;updated_at: timestamp&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After creating the model and migrations, run the migrations and use the provided &lt;code&gt;seeds.rb&lt;/code&gt; file to seed the database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake db:migrate db:seed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Routes&lt;/h3&gt; &#xA;&lt;p&gt;Build out the following routes to handle the necessary CRUD actions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;GET /messages&lt;/code&gt;: returns an array of all messages as JSON, ordered by &lt;code&gt;created_at&lt;/code&gt; in ascending order.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;POST /messages&lt;/code&gt;: creates a new message with a &lt;code&gt;body&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; from params, and returns the newly created post as JSON.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PATCH /messages/:id&lt;/code&gt;: updates the &lt;code&gt;body&lt;/code&gt; of the message using params, and returns the updated message as JSON.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DELETE /messages/:id&lt;/code&gt;: deletes the message from the database.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&#34;&gt;CORS Explained&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cyu/rack-cors&#34;&gt;The rack-cors Gem&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-sinatra-with-active-record-post-patch-delete</title>
    <updated>2023-02-27T01:43:52Z</updated>
    <id>tag:github.com,2023-02-27:/learn-co-curriculum/phase-3-sinatra-with-active-record-post-patch-delete</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-sinatra-with-active-record-post-patch-delete" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Sinatra with Active Record: POST/PATCH/DELETE Requests&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle non-&lt;code&gt;GET&lt;/code&gt; requests in a controller&lt;/li&gt; &#xA; &lt;li&gt;Access data in the request body with the params hash&lt;/li&gt; &#xA; &lt;li&gt;Perform CRUD actions with Active Record from the controller&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;So far, we&#39;ve seen how to set up an API with Sinatra to allow frontend applications to access data from a database in a JSON format. For many applications, just being able to access/read data isn&#39;t enough — what kind of app would Twitter be if you couldn&#39;t write posts? What would Instagram be if you couldn&#39;t like photos? How embarrassing would Facebook be if you couldn&#39;t go back and delete those regrettable high school photos?&lt;/p&gt; &#xA;&lt;p&gt;All of those applications, and most web apps, can be broadly labeled as CRUD applications — they allow users to Create, Read, Update, and Delete information.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;ve seen a few ways to Read data in an API. We&#39;ve also already seen how to Create/Update/Delete records from a database using Active Record. All that&#39;s left is to connect what we know from Active Record with some new techniques for establishing routes and accessing data in our Sinatra application.&lt;/p&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ll continue working on the game review application from the previous lessons. To get set up, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ bundle exec rake db:migrate db:seed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a reminder, here&#39;s what the relationships will look like in our ERD:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-3/active-record-associations-many-to-many/games-reviews-users-erd.png&#34; alt=&#34;Game Reviews ERD&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then, run the server with our new Rake task:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle exec rake server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With that set up, let&#39;s start working on some CRUD!&lt;/p&gt; &#xA;&lt;h2&gt;Handling DELETE Requests&lt;/h2&gt; &#xA;&lt;p&gt;Let&#39;s start with the simplest action: the DELETE request. Imagine we&#39;re building a new feature in our frontend React application. Our users want some way to delete their reviews, in case they change their minds. In React, our component for handling this delete action might look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function ReviewItem({ review, onDeleteReview }) {&#xA;  function handleDeleteClick() {&#xA;    fetch(`http://localhost:9292/reviews/${review.id}`, {&#xA;      method: &#34;DELETE&#34;,&#xA;    })&#xA;      .then((r) =&amp;gt; r.json())&#xA;      .then((deletedReview) =&amp;gt; onDeleteReview(deletedReview));&#xA;  }&#xA;&#xA;  return (&#xA;    &amp;lt;div&amp;gt;&#xA;      &amp;lt;p&amp;gt;Score: {review.score}&amp;lt;/p&amp;gt;&#xA;      &amp;lt;p&amp;gt;{review.comment}&amp;lt;/p&amp;gt;&#xA;      &amp;lt;button onClick={handleDeleteClick}&amp;gt;Delete Review&amp;lt;/button&amp;gt;&#xA;    &amp;lt;/div&amp;gt;&#xA;  );&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So, it looks like our server needs to handle a few new things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle requests with the &lt;code&gt;DELETE&lt;/code&gt; HTTP verb to &lt;code&gt;/reviews/:id&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Find the review to delete using the ID&lt;/li&gt; &#xA; &lt;li&gt;Delete the review from the database&lt;/li&gt; &#xA; &lt;li&gt;Send a response with the deleted review as JSON to confirm that it was deleted successfully, so the frontend can show the successful deletion to the user&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s take things one step at a time. First, we&#39;ll need to handle requests by adding a new route in the controller. We can write out a route for a DELETE request just like we would for a GET request, just by changing the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class ApplicationController &amp;lt; Sinatra::Base&#xA;  set :default_content_type, &#39;application/json&#39;&#xA;&#xA;  delete &#39;/reviews/:id&#39; do&#xA;    # find the review using the ID&#xA;    # delete the review&#xA;    # send a response with the deleted review as JSON&#xA;  end&#xA;&#xA;  # ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, let&#39;s use Active Record to find and delete the review, and send back the appropriate JSON response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;delete &#39;/reviews/:id&#39; do&#xA;  # find the review using the ID&#xA;  review = Review.find(params[:id])&#xA;  # delete the review&#xA;  review.destroy&#xA;  # send a response with the deleted review as JSON&#xA;  review.to_json&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great! Now, in order to test out this route, we won&#39;t be able to use the browser, since we can only make GET requests from the browser&#39;s URL bar. Let&#39;s use Postman instead. Try it out:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-3/sinatra-with-active-record-post-patch-delete/postman-delete.png&#34; alt=&#34;Postman Delete Request&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is essentially doing the same thing as this &lt;code&gt;fetch&lt;/code&gt; call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fetch(`http://localhost:9292/reviews/1`, {&#xA;  method: &#34;DELETE&#34;,&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should get a response with the deleted review as JSON, and if you check the server logs, you should also see that Active Record ran the SQL code to delete the record from the database:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DELETE FROM &#34;reviews&#34; WHERE &#34;reviews&#34;.&#34;id&#34; = 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; You can seed the database again by running &lt;code&gt;rake db:seed&lt;/code&gt; if you wish to play around with the initial data.&lt;/p&gt; &#xA;&lt;h2&gt;Handling POST Requests&lt;/h2&gt; &#xA;&lt;p&gt;For our next feature, let&#39;s give our users the ability to &lt;strong&gt;Create&lt;/strong&gt; new reviews. From the frontend, here&#39;s how our React component might look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function ReviewForm({ userId, gameId, onAddReview }) {&#xA;  const [comment, setComment] = useState(&#34;&#34;);&#xA;  const [score, setScore] = useState(&#34;0&#34;);&#xA;&#xA;  function handleSubmit(e) {&#xA;    e.preventDefault();&#xA;    fetch(&#34;http://localhost:9292/reviews&#34;, {&#xA;      method: &#34;POST&#34;,&#xA;      headers: {&#xA;        &#34;Content-Type&#34;: &#34;application/json&#34;,&#xA;      },&#xA;      body: JSON.stringify({&#xA;        comment: comment,&#xA;        score: score,&#xA;        user_id: userId,&#xA;        game_id: gameId,&#xA;      }),&#xA;    })&#xA;      .then((r) =&amp;gt; r.json())&#xA;      .then((newReview) =&amp;gt; onAddReview(newReview));&#xA;  }&#xA;&#xA;  return &amp;lt;form onSubmit={handleSubmit}&amp;gt;{/* controlled form code here*/}&amp;lt;/form&amp;gt;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This request is a bit trickier than the last: in order to create a review in the database, we need some way of getting all the data that the user entered into the form. From the code above, you can see that we&#39;ll have access to that data in the &lt;strong&gt;body&lt;/strong&gt; of the request, as a JSON-formatted string. So in terms of the steps for our server, we need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle requests with the &lt;code&gt;POST&lt;/code&gt; HTTP verb to &lt;code&gt;/reviews&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Access the data in the body of the request&lt;/li&gt; &#xA; &lt;li&gt;Use that data to create a new review in the database&lt;/li&gt; &#xA; &lt;li&gt;Send a response with newly created review as JSON&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Let&#39;s start with the easy part. We can create a new route like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;post &#39;/reviews&#39; do&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this route, we&#39;ll need some way of getting access to the data in the body of the request. Sinatra gives us access to the raw data in the request body by calling &lt;code&gt;request.body.read&lt;/code&gt;, which will return a string. We could then convert this data from a JSON string to a Ruby hash by using &lt;code&gt;JSON.parse(request.body.read)&lt;/code&gt;. Luckily though, there&#39;s an even easier way!&lt;/p&gt; &#xA;&lt;p&gt;This application is set up to use some additional &lt;a href=&#34;https://github.com/rack/rack-contrib&#34;&gt;Rack middleware&lt;/a&gt; in the &lt;code&gt;config.ru&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require_relative &#39;./config/environment&#39;&#xA;&#xA;# Parse JSON from the request body into the params hash&#xA;use Rack::JSONBodyParser&#xA;&#xA;run ApplicationController&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&#34;Middleware&#34; is a category of code that runs on every single request-response cycle, and does some work to transform the request and make it easier to work with once it reaches the controller. In this case, the &lt;code&gt;Rack::JSONBodyParser&lt;/code&gt; middleware does the work of reading the body of the request, parsing it from a JSON string into a Ruby hash, and adding it to the &lt;code&gt;params&lt;/code&gt; hash.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see what that looks like in action. Add a breakpoint to your new route, and require Pry at the top of the file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require &#39;pry&#39;&#xA;&#xA;class ApplicationController &amp;lt; Sinatra::Base&#xA;  set :default_content_type, &#39;application/json&#39;&#xA;&#xA;  post &#39;/reviews&#39; do&#xA;    binding.pry&#xA;  end&#xA;&#xA;  # ... rest of routes here&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, use Postman to send a request like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-3/sinatra-with-active-record-post-patch-delete/postman-post.png&#34; alt=&#34;Postman POST request&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Make sure to match these settings exactly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set the HTTP verb to POST&lt;/li&gt; &#xA; &lt;li&gt;Set the URL to &lt;code&gt;http://localhost:9292/reviews&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;In the request &lt;strong&gt;body&lt;/strong&gt; tab, select the &#34;Raw&#34; and &#34;JSON&#34; options from the two dropdown menus&lt;/li&gt; &#xA; &lt;li&gt;Then paste in this JSON data in the request body area:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;score&#34;: 10,&#xA;  &#34;comment&#34;: &#34;Great game.&#34;,&#xA;  &#34;game_id&#34;: 1,&#xA;  &#34;user_id&#34;: 1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, click Send to make the request. You should enter the Pry breakpoint from your POST route, where you can interact with the request and inspect the params hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;params&#xA;# =&amp;gt; {&#34;score&#34;=&amp;gt;10, &#34;comment&#34;=&amp;gt;&#34;Great game.&#34;, &#34;game_id&#34;=&amp;gt;1, &#34;user_id&#34;=&amp;gt;1}&#xA;params[:score]&#xA;# =&amp;gt; 10&#xA;params[:user_id]&#xA;# =&amp;gt; 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Great! As you can see, we now have access to the data from the body of the request that we need in order to create a new &lt;code&gt;Review&lt;/code&gt; instance. Exit the Pry session with &lt;code&gt;exit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If we were using &lt;code&gt;fetch&lt;/code&gt; instead of Postman to make this request, the params hash would be whatever data was sent in the body of the fetch request:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;fetch(&#34;http://localhost:9292/reviews&#34;, {&#xA;  method: &#34;POST&#34;,&#xA;  headers: {&#xA;    &#34;Content-Type&#34;: &#34;application/json&#34;,&#xA;  },&#xA;  body: JSON.stringify({&#xA;    score: 10,&#xA;    comment: &#34;Great game.&#34;,&#xA;    game_id: 1,&#xA;    user_id: 1,&#xA;  }),&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we have access to that data, all that&#39;s left is to use the data with Active Record to create a new &lt;code&gt;Review&lt;/code&gt; and send a JSON response back. All together, here&#39;s how this route should look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;post &#39;/reviews&#39; do&#xA;  review = Review.create(&#xA;    score: params[:score],&#xA;    comment: params[:comment],&#xA;    game_id: params[:game_id],&#xA;    user_id: params[:user_id]&#xA;  )&#xA;  review.to_json&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Try running the request through Postman again. Your new review should be added to the database and you should get back a JSON response with the review data. Nice!&lt;/p&gt; &#xA;&lt;h2&gt;Handling PATCH Requests&lt;/h2&gt; &#xA;&lt;p&gt;Onto the last HTTP verb: &lt;code&gt;PATCH&lt;/code&gt;! Now that you&#39;ve learned about &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; requests, this should be more straightforward. From the frontend, we might need to use a &lt;code&gt;PATCH&lt;/code&gt; request to handle a feature that would allow a user to update their review, in case they change their minds:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function EditReviewForm({ review, onUpdateReview }) {&#xA;  const [comment, setComment] = useState(&#34;&#34;);&#xA;  const [score, setScore] = useState(&#34;0&#34;);&#xA;&#xA;  function handleSubmit(e) {&#xA;    e.preventDefault();&#xA;    fetch(`http://localhost:9292/reviews/${review.id}`, {&#xA;      method: &#34;PATCH&#34;,&#xA;      headers: {&#xA;        &#34;Content-Type&#34;: &#34;application/json&#34;,&#xA;      },&#xA;      body: JSON.stringify({&#xA;        comment: comment,&#xA;        score: score,&#xA;      }),&#xA;    })&#xA;      .then((r) =&amp;gt; r.json())&#xA;      .then((updatedReview) =&amp;gt; onUpdateReview(updatedReview));&#xA;  }&#xA;&#xA;  return &amp;lt;form onSubmit={handleSubmit}&amp;gt;{/* controlled form code here*/}&amp;lt;/form&amp;gt;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The steps we&#39;ll need to handle on the server for this request are basically a combination of DELETE and POST. We&#39;ll need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Handle requests with the &lt;code&gt;PATCH&lt;/code&gt; HTTP verb to &lt;code&gt;/reviews/:id&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Find the review to update using the ID&lt;/li&gt; &#xA; &lt;li&gt;Access the data in the body of the request&lt;/li&gt; &#xA; &lt;li&gt;Use that data to update the review in the database&lt;/li&gt; &#xA; &lt;li&gt;Send a response with updated review as JSON&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Give it a shot yourself before looking at the solution! You have all the tools you need to get this request working. When you&#39;re ready, keep scrolling...&lt;/p&gt; &#xA;&lt;p&gt;...&lt;/p&gt; &#xA;&lt;p&gt;...&lt;/p&gt; &#xA;&lt;p&gt;...&lt;/p&gt; &#xA;&lt;p&gt;...&lt;/p&gt; &#xA;&lt;p&gt;...&lt;/p&gt; &#xA;&lt;p&gt;...&lt;/p&gt; &#xA;&lt;p&gt;Ok, here&#39;s how the code for this route would look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;patch &#39;/reviews/:id&#39; do&#xA;  review = Review.find(params[:id])&#xA;  review.update(&#xA;    score: params[:score],&#xA;    comment: params[:comment]&#xA;  )&#xA;  review.to_json&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And here&#39;s how you could test it out in Postman:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/phase-3/sinatra-with-active-record-post-patch-delete/postman-patch.png&#34; alt=&#34;Postman PATCH request&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Notice we&#39;re only updating the score and comment: it would be strange to change which user left a review, or which game a review was left for.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;re at the point now where you can create a JSON API that handles all four CRUD actions: Create, Read, Update, and Delete. With just these four actions, you can build just about any application you can think of!&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods&#34;&gt;HTTP Verbs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.postman.com/downloads/&#34;&gt;Download Postman&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>