<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-12T01:46:59Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-ruby-oo-basics-setter-and-getter-methods</title>
    <updated>2023-06-12T01:46:59Z</updated>
    <id>tag:github.com,2023-06-12:/learn-co-curriculum/phase-3-ruby-oo-basics-setter-and-getter-methods</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-ruby-oo-basics-setter-and-getter-methods" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Setter and Getter Methods&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Learn more about setter and getter methods&lt;/li&gt; &#xA; &lt;li&gt;Build and use setter and getter methods&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;So far, we&#39;ve learned how to build classes and give them instance methods. We also learned how to create instance variables and use setter and getter methods to set and retrieve their values, respectively. In this lesson, we&#39;ll learn more about these methods and why they&#39;re important.&lt;/p&gt; &#xA;&lt;h2&gt;Setters and Getters&lt;/h2&gt; &#xA;&lt;p&gt;Setter and getter methods are integral to object-oriented programming in Ruby. They are what enable us to assign attributes to our objects (e.g., &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;breed&lt;/code&gt;) and retrieve the value of those attributes.&lt;/p&gt; &#xA;&lt;p&gt;To review, if we have a &lt;code&gt;Person&lt;/code&gt; class, our setter and getter for the &lt;code&gt;name&lt;/code&gt; attribute will look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person&#xA;&#xA;  # setter method&#xA;  def name=(name)&#xA;    @name = name&#xA;  end&#xA;&#xA;  # getter method&#xA;  def name&#xA;    @name&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the setter method is defined with an &lt;code&gt;=&lt;/code&gt; (equals sign) appended to the name of the method. The &lt;code&gt;=&lt;/code&gt; is then followed by the parameter, &lt;code&gt;name&lt;/code&gt;, in parentheses. The &lt;code&gt;=&lt;/code&gt; in the method definition line is part of the method&#39;s name; it is simply a &lt;em&gt;character&lt;/em&gt; that identifies this method as a setter method. The actual assignment — the use of the &lt;em&gt;operator&lt;/em&gt; &lt;code&gt;=&lt;/code&gt; to set a value — happens inside the method.&lt;/p&gt; &#xA;&lt;p&gt;What this means is that, if we were to create a &lt;code&gt;Person&lt;/code&gt; instance and then use the usual Ruby syntax to call the setter method and pass it an argument, our code would look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;brennan = Person.new&#xA;brennan.name=(&#34;Brennan&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this is exactly the same as calling any method that takes an argument on any object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;any_object.any_method(arg)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only difference is the &lt;code&gt;=&lt;/code&gt; that is part of our method&#39;s name, identifying it as a setter method.&lt;/p&gt; &#xA;&lt;p&gt;We don&#39;t have to use this syntax to call our setter method, however. Instead, Ruby provides us a bit of syntactic sugar for setter methods that enables us to do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;brennan = Person.new&#xA;brennan.name = &#34;Brennan&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This syntax is easier to read and more intuitive and is therefore preferred.&lt;/p&gt; &#xA;&lt;p&gt;Finally, to ask our &lt;code&gt;brennan&lt;/code&gt; object to return the value of its &lt;code&gt;name&lt;/code&gt; attribute, we would do this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;brennan.name #=&amp;gt; &#34;Brennan&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we are calling the getter method, &lt;code&gt;name&lt;/code&gt;, that belongs to every instance of our &lt;code&gt;Person&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;Fork and clone the lab and run &lt;code&gt;learn test&lt;/code&gt;. To get the tests passing, you will need to complete the following tasks:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;lib/dog.rb&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a &lt;code&gt;name&lt;/code&gt; getter and a &lt;code&gt;name=&lt;/code&gt; setter method for the instance variable &lt;code&gt;@name&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Define a &lt;code&gt;breed&lt;/code&gt; getter and a &lt;code&gt;breed=&lt;/code&gt; setter method for the instance variable &lt;code&gt;@breed&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://curriculum-content.s3.amazonaws.com/module-1/ruby-oo-fundamentals/object-attributes-lab/Image_142_CommonDogBreeds.png&#34; alt=&#34;Dog Breeds&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;lib/person.rb&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Define a &lt;code&gt;name&lt;/code&gt; getter and a &lt;code&gt;name=&lt;/code&gt; setter method for the instance variable &lt;code&gt;@name&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Define a &lt;code&gt;job&lt;/code&gt; getter and a &lt;code&gt;job=&lt;/code&gt; setter method for the instance variable &lt;code&gt;@job&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>BraydenCleary/demo_app</title>
    <updated>2023-06-12T01:46:59Z</updated>
    <id>tag:github.com,2023-06-12:/BraydenCleary/demo_app</id>
    <link href="https://github.com/BraydenCleary/demo_app" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby on Rails Tutorial demo application&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Ruby on Rails Tutorial: demo_app I&#39;m pretty pumped to be crushing this tutorial and continue learning more!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-4-controller-exception-handling</title>
    <updated>2023-06-12T01:46:59Z</updated>
    <id>tag:github.com,2023-06-12:/learn-co-curriculum/phase-4-controller-exception-handling</id>
    <link href="https://github.com/learn-co-curriculum/phase-4-controller-exception-handling" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Controller Exception Handling&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use exception handling techniques like &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;rescue_from&lt;/code&gt; in a Rails controller&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In this lesson, we&#39;ll finish work on our Bird API by refactoring the controller to add in some helpful reusable error handling code. To get set up, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ bundle install&#xA;$ rails db:migrate db:seed&#xA;$ rails s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will download all the dependencies for our app, set up the database, and run the Rails server.&lt;/p&gt; &#xA;&lt;h2&gt;Video Walkthrough&lt;/h2&gt; &amp;lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/evlSdyGoE3s?rel=0&amp;amp;showinfo=0&#34; frameborder=&#34;0&#34; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt; &#xA;&lt;h2&gt;DRYing Up Controller Code&lt;/h2&gt; &#xA;&lt;p&gt;In the current implementation of our &lt;code&gt;BirdsController&lt;/code&gt;, we&#39;ve defined actions to handle all five RESTful routes plus one additional custom route. You&#39;ll notice there is some common behavior between a lot of the methods. For all the routes that include a route parameter (&lt;code&gt;/birds/:id&lt;/code&gt;), we&#39;re using the ID in the params hash to look up a bird; if the bird is found, we&#39;re performing some action with it, and if not, we&#39;re sending an error message back.&lt;/p&gt; &#xA;&lt;p&gt;For example, have a look at the &lt;code&gt;show&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; actions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# GET /birds/:id&#xA;def show&#xA;  bird = Bird.find_by(id: params[:id])&#xA;  if bird&#xA;    render json: bird&#xA;  else&#xA;    render json: { error: &#34;Bird not found&#34; }, status: :not_found&#xA;  end&#xA;end&#xA;&#xA;# PATCH /birds/:id&#xA;def update&#xA;  bird = Bird.find_by(id: params[:id])&#xA;  if bird&#xA;    bird.update(bird_params)&#xA;    render json: bird&#xA;  else&#xA;    render json: { error: &#34;Bird not found&#34; }, status: :not_found&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Between these two methods, there&#39;s a good amount of repeated code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Finding a bird based on the ID&lt;/li&gt; &#xA; &lt;li&gt;Performing control flow (if/else) based on whether or not the bird exists&lt;/li&gt; &#xA; &lt;li&gt;Returning an error message with a status of &lt;code&gt;:not_found&lt;/code&gt; if the bird doesn&#39;t exist&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That same code also exists in the &lt;code&gt;increment_likes&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; actions. That makes this a good opportunity for a refactor to DRY up some of this repeated logic!&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s start by making a private method for generating the &lt;code&gt;:not_found&lt;/code&gt; response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;private&#xA;&#xA;def render_not_found_response&#xA;  render json: { error: &#34;Bird not found&#34; }, status: :not_found&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can then update our actions to use this method instead of implementing the rendering logic directly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# GET /birds/:id&#xA;def show&#xA;  bird = Bird.find_by(id: params[:id])&#xA;  if bird&#xA;    render json: bird&#xA;  else&#xA;    render_not_found_response&#xA;  end&#xA;end&#xA;&#xA;# PATCH /birds/:id&#xA;def update&#xA;  bird = Bird.find_by(id: params[:id])&#xA;  if bird&#xA;    bird.update(bird_params)&#xA;    render json: bird&#xA;  else&#xA;    render_not_found_response&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also make a helper method to find a bird based on the ID in the params hash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;private&#xA;&#xA;def find_bird&#xA;  Bird.find_by(id: params[:id])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, our controller actions don&#39;t need to worry about how the &lt;code&gt;find_bird&lt;/code&gt; method is implemented, as long as it returns a bird from the database. This frees us up to change how the bird finding logic is implemented in the future (for example, using something other than the ID to look up a bird in the database, like a URL slug or &lt;a href=&#34;https://en.wikipedia.org/wiki/Universally_unique_identifier&#34;&gt;UUID&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s how our controller actions can use this method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;# GET /birds/:id&#xA;def show&#xA;  bird = find_bird&#xA;  if bird&#xA;    render json: bird&#xA;  else&#xA;    render_not_found_response&#xA;  end&#xA;end&#xA;&#xA;# PATCH /birds/:id&#xA;def update&#xA;  bird = find_bird&#xA;  if bird&#xA;    bird.update(bird_params)&#xA;    render json: bird&#xA;  else&#xA;    render_not_found_response&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Handling Exceptions&lt;/h2&gt; &#xA;&lt;p&gt;We can also shorten up the code in each of our controller methods by using a different approach to finding a bird using the ID. This will also help us improve our error handling. Currently, we&#39;re using the &lt;a href=&#34;https://api.rubyonrails.org/v6.1.3.2/classes/ActiveRecord/FinderMethods.html#method-i-find_by&#34;&gt;&lt;code&gt;find_by&lt;/code&gt;&lt;/a&gt; method to look up a bird. &lt;code&gt;find_by&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if the record isn&#39;t found in the database, which makes it useful for &lt;code&gt;if/else&lt;/code&gt; control flow, since &lt;code&gt;nil&lt;/code&gt; is a false-y value in Ruby.&lt;/p&gt; &#xA;&lt;p&gt;If we use the &lt;a href=&#34;https://api.rubyonrails.org/v6.1.3.2/classes/ActiveRecord/FinderMethods.html#method-i-find&#34;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt; method instead, we&#39;ll get an &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; exception instead of &lt;code&gt;nil&lt;/code&gt; when the record doesn&#39;t exist. Try updating the &lt;code&gt;find_bird&lt;/code&gt; action like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def find_bird&#xA;  Bird.find(params[:id])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then make a request for an ID that doesn&#39;t exist in the database, like &lt;code&gt;localhost:3000/birds/9999&lt;/code&gt;. You should see an error message like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;ActiveRecord::RecordNotFound (Couldn&#39;t find Bird with &#39;id&#39;=9999)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can handle this error in our controller method by using a &lt;a href=&#34;https://ruby-doc.org/core-2.7.3/doc/syntax/exceptions_rdoc.html&#34;&gt;&lt;code&gt;rescue&lt;/code&gt; block in our method&lt;/a&gt;, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def show&#xA;  bird = find_bird&#xA;  render json: bird&#xA;rescue ActiveRecord::RecordNotFound&#xA;  render_not_found_response&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Not only is this code shorter than the previous implementation, it also gives a clearer separation between the &#34;happy path&#34; of our code (no exceptions/errors) and the logic for handling exceptions/errors. Try making the same request in the browser to &lt;code&gt;localhost:3000/birds/9999&lt;/code&gt; — now that we&#39;re handling the exception in the controller, you should see a 404 status code in the console with the &lt;code&gt;{ &#34;error&#34;: &#34;Bird not found&#34; }&lt;/code&gt; JSON response instead of a 500 server error.&lt;/p&gt; &#xA;&lt;p&gt;We use the same approach to our &lt;code&gt;update&lt;/code&gt; action as well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def update&#xA;  bird = find_bird&#xA;  bird.update(bird_params)&#xA;  render json: bird&#xA;rescue ActiveRecord::RecordNotFound&#xA;  render_not_found_response&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The tradeoff to this approach of using exception handling rather than an if/else control flow is that it may be less apparent to other developers looking at our code at first what code in the &lt;code&gt;update&lt;/code&gt; block would cause that exception to be thrown.&lt;/p&gt; &#xA;&lt;p&gt;We can take this one step further, and use the &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html#method-i-rescue_from&#34;&gt;&lt;code&gt;rescue_from&lt;/code&gt; method&lt;/a&gt; to handle the &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; exception from &lt;strong&gt;all&lt;/strong&gt; of our controller actions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class BirdsController &amp;lt; ApplicationController&#xA;  rescue_from ActiveRecord::RecordNotFound, with: :render_not_found_response&#xA;&#xA;  # rest of controller...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By using the &lt;code&gt;rescue_from&lt;/code&gt; method this way, if &lt;em&gt;any&lt;/em&gt; of our controller actions throw an &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; exception, our &lt;code&gt;render_not_found_response&lt;/code&gt; method will return the appropriate JSON response.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s the fully refactored version of the controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;class BirdsController &amp;lt; ApplicationController&#xA;  rescue_from ActiveRecord::RecordNotFound, with: :render_not_found_response&#xA;&#xA;  # GET /birds&#xA;  def index&#xA;    birds = Bird.all&#xA;    render json: birds&#xA;  end&#xA;&#xA;  # POST /birds&#xA;  def create&#xA;    bird = Bird.create(bird_params)&#xA;    render json: bird, status: :created&#xA;  end&#xA;&#xA;  # GET /birds/:id&#xA;  def show&#xA;    bird = find_bird&#xA;    render json: bird&#xA;  end&#xA;&#xA;  # PATCH /birds/:id&#xA;  def update&#xA;    bird = find_bird&#xA;    bird.update(bird_params)&#xA;    render json: bird&#xA;  end&#xA;&#xA;  # PATCH /birds/:id/like&#xA;  def increment_likes&#xA;    bird = find_bird&#xA;    bird.update(likes: bird.likes + 1)&#xA;    render json: bird&#xA;  end&#xA;&#xA;  # DELETE /birds/:id&#xA;  def destroy&#xA;    bird = find_bird&#xA;    bird.destroy&#xA;    head :no_content&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def find_bird&#xA;    Bird.find(params[:id])&#xA;  end&#xA;&#xA;  def bird_params&#xA;    params.permit(:name, :species, :likes)&#xA;  end&#xA;&#xA;  def render_not_found_response&#xA;    render json: { error: &#34;Bird not found&#34; }, status: :not_found&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Using exception handling techniques like &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;rescue_from&lt;/code&gt; opens up a lot of possibilities in terms of how you structure your code. For our controller actions in particular, it allows us to isolate the &#34;happy path&#34; of our code (performing CRUD actions and rendering a response to the users) from the exception handling logic. It also lets us handle exceptions in a consistent way, so that users of our API get the same response for common errors, like not being able to find a particular resource.&lt;/p&gt; &#xA;&lt;h2&gt;Check For Understanding&lt;/h2&gt; &#xA;&lt;p&gt;Before you move on, make sure you can answer the following questions:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;What is the difference in behavior between the &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;find_by&lt;/code&gt; methods? Why is that difference important for how we handle not-found errors?&lt;/li&gt; &#xA; &lt;li&gt;Looking at the final version of the controller code, what sequence of events would happen if we tried to submit a &lt;code&gt;PATCH&lt;/code&gt; request for a bird that doesn&#39;t exist?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html#method-i-rescue_from&#34;&gt;&lt;code&gt;rescue_from&lt;/code&gt; method&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>