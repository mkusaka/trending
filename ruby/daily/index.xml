<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-23T01:43:53Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-ruby-oo-inheritance-modules</title>
    <updated>2023-05-23T01:43:53Z</updated>
    <id>tag:github.com,2023-05-23:/learn-co-curriculum/phase-3-ruby-oo-inheritance-modules</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-ruby-oo-inheritance-modules" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Modules&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use modules to share functionality across classes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;In the previous lesson, we discussed the concept of inheritance. We learned that through &lt;strong&gt;subclasses&lt;/strong&gt; (a certain class under a &lt;strong&gt;super class&lt;/strong&gt;), the subclass has access to all of the methods of its parent class. Inheriting one class from another makes sense. The subclass can be understood as a child or subordinate of the super class. For example, a car is a type of vehicle, so it makes sense for the &lt;code&gt;Car&lt;/code&gt; class to &lt;em&gt;inherit&lt;/em&gt; from the &lt;code&gt;Vehicle&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s think about a slightly different type of example, one that is less hierarchical. We could easily envision writing an app that models the environment of a dance performance. Such an app might have a &lt;code&gt;Dancer&lt;/code&gt; class. Dancers, we know, perform dances. Similarly, we could imagine a little kid going to see the Nutcracker ballet one Christmas, coming home and wanting to practice all of the ballet moves from the show. So, we might write a &lt;code&gt;Kid&lt;/code&gt; class in which an instance of that class, our little kid who has gone to see the ballet, should have access to all those ballet moves (their performance skill notwithstanding).&lt;/p&gt; &#xA;&lt;p&gt;This situation is not hierarchical, like our &lt;code&gt;Car&lt;/code&gt; and &lt;code&gt;Vehicle&lt;/code&gt; example. Instead, &lt;code&gt;Kid&lt;/code&gt; and &lt;code&gt;Dancer&lt;/code&gt; simply need to share some functionality, without being related in any other meaningful way.&lt;/p&gt; &#xA;&lt;p&gt;This is where &lt;strong&gt;modules&lt;/strong&gt; come in. Modules allow us to collect and bundle a group of methods and make those methods available to any number of classes. In this exercise, we&#39;ll be defining a &lt;code&gt;Dance&lt;/code&gt; module and making it available to both the &lt;code&gt;Dancer&lt;/code&gt; and &lt;code&gt;Kid&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;h2&gt;Code Along 1: Including Module Methods as Instance Methods&lt;/h2&gt; &#xA;&lt;p&gt;Fork and clone this repo, and follow along with the walk-through below to get your code working. Get the tests to pass.&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Defining Our Module&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;ll code our &lt;code&gt;Dance&lt;/code&gt; module inside the &lt;code&gt;lib/dance_module.rb&lt;/code&gt; file. Open up that file and define your module with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Dance&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s give our &lt;code&gt;Dance&lt;/code&gt; module some fabulous moves:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module Dance&#xA;  def twirl&#xA;    &#34;I&#39;m twirling!&#34;&#xA;  end&#xA;&#xA;  def jump&#xA;    &#34;Look how high I&#39;m jumping!&#34;&#xA;  end&#xA;&#xA;  def pirouette&#xA;    &#34;I&#39;m doing a pirouette&#34;&#xA;  end&#xA;&#xA;  def take_a_bow&#xA;    &#34;Thank you, thank you. It was a pleasure to dance for you all.&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Okay, now we&#39;ll define our &lt;code&gt;Kid&lt;/code&gt; class and tell it to &lt;em&gt;include&lt;/em&gt; the capabilities of the &lt;code&gt;Dance&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;h3&gt;Step 2: Defining the Classes&lt;/h3&gt; &#xA;&lt;p&gt;Open up &lt;code&gt;lib/kid.rb&lt;/code&gt; and define your &lt;code&gt;Kid&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Kid&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s do the same for the &lt;code&gt;Dancer&lt;/code&gt; class in &lt;code&gt;lib/dancer.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Dancer&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re ready to include our module in our classes:&lt;/p&gt; &#xA;&lt;h3&gt;Step 3: Including the Module&lt;/h3&gt; &#xA;&lt;p&gt;To lend our two classes all of the methods of the &lt;code&gt;Dance&lt;/code&gt; module, we use the &lt;code&gt;include&lt;/code&gt; keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Kid&#xA;  include Dance&#xA;&#xA;  attr_accessor :name&#xA;&#xA;  def initialize(name)&#xA;    @name = name&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Dancer&#xA;  include Dance&#xA;&#xA;  attr_accessor :name&#xA;&#xA;  def initialize(name)&#xA;    @name = name&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we use the &lt;code&gt;include&lt;/code&gt; keyword, we allow our classes to use all of the methods of the included module as &lt;em&gt;instance&lt;/em&gt; methods. We&#39;ll talk about how to lend a module&#39;s methods as &lt;em&gt;class&lt;/em&gt; methods in a minute.&lt;/p&gt; &#xA;&lt;p&gt;Now that we&#39;ve included the module, open up &lt;code&gt;bin/dance_party&lt;/code&gt; and get familiar with following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby&#xA;&#xA;require_relative &#34;../lib/kid.rb&#34;&#xA;require_relative &#34;../lib/dancer.rb&#34;&#xA;&#xA;angelina = Kid.new(&#34;Angelina&#34;)&#xA;mikhail_baryshnikov = Dancer.new(&#34;Mikhail&#34;)&#xA;&#xA;puts &#34;#{angelina.name} says: #{angelina.twirl}&#34;&#xA;puts &#34;#{mikhail_baryshnikov.name} says: #{mikhail_baryshnikov.take_a_bow}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, run the file by typing &lt;code&gt;ruby bin/dance_party&lt;/code&gt; and you should see the following output in your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Angelina says: I&#39;m twirling!&#xA;Mikhail says: Thank you, thank you. It was a pleasure to dance for you all.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, we were able to &lt;strong&gt;include&lt;/strong&gt; the &lt;code&gt;#twirl&lt;/code&gt; instance method with our &lt;code&gt;Kid&lt;/code&gt; instance, and the &lt;code&gt;#take_a_bow&lt;/code&gt; method with our &lt;code&gt;Dancer&lt;/code&gt; instance, even though those methods weren&#39;t defined directly in the classes! This is the benefit of using modules: we can share behavior between multiple classes without relying on inheritance.&lt;/p&gt; &#xA;&lt;h2&gt;Code Along 2: Extending Module Methods as Class Methods&lt;/h2&gt; &#xA;&lt;p&gt;In order to lend a module&#39;s methods to a class as &lt;em&gt;class methods&lt;/em&gt;, we use the &lt;code&gt;extend&lt;/code&gt; keyword. Let&#39;s write yet another module that we can extend into our classes as class methods. For the purposes of this example, let&#39;s create a shareable class method, &lt;code&gt;metadata&lt;/code&gt;, which will report on some pertinent (shared) information regarding both classes.&lt;/p&gt; &#xA;&lt;p&gt;Open up the &lt;code&gt;lib/meta_dancing_module.rb&lt;/code&gt; and define the following module and methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module MetaDancing&#xA;&#xA;  def metadata&#xA;    &#34;This class produces objects that love to dance.&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s &lt;code&gt;extend&lt;/code&gt; this module into both the &lt;code&gt;Kid&lt;/code&gt; and &lt;code&gt;Dancer&lt;/code&gt; classes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Dancer&#xA;  extend MetaDancing&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Kid&#xA;  extend MetaDancing&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, open up the bin/extending file and familiarize yourself with the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/usr/bin/env ruby&#xA;&#xA;require_relative &#34;../lib/kid&#34;&#xA;require_relative &#34;../lib/dancer&#34;&#xA;&#xA;puts Kid.metadata&#xA;puts Dancer.metadata&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the file with &lt;code&gt;ruby bin/extending&lt;/code&gt; and you should see the following output in your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;This class produces objects that love to dance.&#xA;This class produces objects that love to dance.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run the tests to make sure some of your tests are passing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Run the &lt;code&gt;learn test&lt;/code&gt; command at this point, and you will pass &lt;em&gt;almost&lt;/em&gt; all of the tests!&lt;/p&gt; &#xA;&lt;h2&gt;Code Along 3: Namespacing Modules&lt;/h2&gt; &#xA;&lt;p&gt;In the first code along, we built a module called &lt;code&gt;Dance&lt;/code&gt;, which contained methods that we intended to be used as instance methods in the &lt;code&gt;Dancer&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;In the second code along, we built the module &lt;code&gt;MetaDancing&lt;/code&gt;, whose methods were intended to be used as class methods in the &lt;code&gt;Kid&lt;/code&gt; and &lt;code&gt;Dancer&lt;/code&gt; classes.&lt;/p&gt; &#xA;&lt;p&gt;There are two drawbacks to this approach. First, if another developer looks at your modules, there is absolutely no way to determine how those methods are intended to be used. Are they class methods? Are they instance methods? Nobody knows!&lt;/p&gt; &#xA;&lt;p&gt;Secondly, we had to build two separate modules that contained methods that were all related to the same functionality (dancing). But because there was no way to designate class methods versus instance methods, we were forced to define two separate modules, which violates the single responsibility principle. Wouldn&#39;t it be great if there was a way to define one module and specify which methods were intended as class methods and which methods as instance methods.&lt;/p&gt; &#xA;&lt;p&gt;Guess what? There is! We&#39;re going to refactor the two modules into one, and use &lt;strong&gt;module namespacing&lt;/strong&gt; to clarify how our code should be used. Let&#39;s update the code in &lt;code&gt;lib/fancy_dance.rb&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;module FancyDance&#xA;  module InstanceMethods&#xA;&#xA;    def twirl&#xA;      &#34;I&#39;m twirling!&#34;&#xA;    end&#xA;&#xA;    def jump&#xA;      &#34;Look how high I&#39;m jumping!&#34;&#xA;    end&#xA;&#xA;    def pirouette&#xA;      &#34;I&#39;m doing a pirouette&#34;&#xA;    end&#xA;&#xA;    def take_a_bow&#xA;      &#34;Thank you, thank you. It was a pleasure to dance for you all.&#34;&#xA;    end&#xA;  end&#xA;&#xA;  module ClassMethods&#xA;&#xA;    def metadata&#xA;      &#34;This class produces objects that love to dance.&#34;&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First, we define our &lt;code&gt;FancyDance&lt;/code&gt; module. Then, inside the &lt;code&gt;FancyDance&lt;/code&gt; module, we define a second module, &lt;code&gt;InstanceMethods&lt;/code&gt;. Inside the &lt;code&gt;InstanceMethods&lt;/code&gt; module, we place all our methods that we intend to be used as instance methods (&lt;code&gt;twirl&lt;/code&gt;, &lt;code&gt;jump&lt;/code&gt;, &lt;code&gt;pirouette&lt;/code&gt;, &lt;code&gt;take_a_bow&lt;/code&gt;). Next, we define a second nested module (nested inside of &lt;code&gt;FancyDance&lt;/code&gt;) called &lt;code&gt;ClassMethods&lt;/code&gt;. Inside, we place the &lt;code&gt;metadata&lt;/code&gt; method, which we intend to be used as a class method.&lt;/p&gt; &#xA;&lt;p&gt;So how do we use these nested modules?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Dancer&#xA;  extend FancyDance::ClassMethods&#xA;  include FancyDance::InstanceMethods&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Kid&#xA;  extend FancyDance::ClassMethods&#xA;  include FancyDance::InstanceMethods&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: remember to require the &lt;code&gt;fancy_dance.rb&lt;/code&gt; file inside the &lt;code&gt;dancer.rb&lt;/code&gt; and &lt;code&gt;kid.rb&lt;/code&gt;, just like we did with our other file requirements.&lt;/p&gt; &#xA;&lt;p&gt;We refer to the namespaced modules or classes with the &lt;code&gt;::&lt;/code&gt; operator. This syntax references the parent and child relationship of the nested modules.&lt;/p&gt; &#xA;&lt;p&gt;Remember, &lt;code&gt;include&lt;/code&gt; is used to add functionality to our classes via instance methods. The &lt;code&gt;InstanceMethods&lt;/code&gt; module inside the &lt;code&gt;FancyDance&lt;/code&gt; module contains the methods &lt;code&gt;twirl&lt;/code&gt;, &lt;code&gt;jump&lt;/code&gt;, &lt;code&gt;pirouette&lt;/code&gt;, and &lt;code&gt;take_a_bow&lt;/code&gt;, which any instance of the &lt;code&gt;Dancer&lt;/code&gt; or &lt;code&gt;Kid&lt;/code&gt; class can do.&lt;/p&gt; &#xA;&lt;p&gt;We can call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;angelina = Dancer.new&#xA;angelina.twirl&#xA;# =&amp;gt; &#34;I&#39;m twirling!&#34;&#xA;angelina.jump&#xA;# =&amp;gt; &#34;Look how high I&#39;m jumping!&#34;&#xA;&#xA;buster = Kid.new&#xA;buster.jump&#xA;# =&amp;gt; &#34;Look how high I&#39;m jumping!&#34;&#xA;buster.take_a_bow&#xA;# =&amp;gt; &#34;Thank you, thank you. It was a pleasure to dance for you all.&#34;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because we &lt;em&gt;included&lt;/em&gt; the &lt;code&gt;FancyDance::InstanceMethods&lt;/code&gt; nested module, we can call those instance methods on instances of our classes.&lt;/p&gt; &#xA;&lt;p&gt;And &lt;code&gt;extend&lt;/code&gt; is used to add functionality to our classes via class methods. We can now call the &lt;code&gt;metadata&lt;/code&gt; class method on the &lt;code&gt;Dancer&lt;/code&gt; and &lt;code&gt;Kid&lt;/code&gt; classes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Dancer.metadata&#xA;# =&amp;gt; &#34;This class produces objects that love to dance.&#34;&#xA;Kid.metadata&#xA;# =&amp;gt; &#34;This class produces objects that love to dance.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Namespacing Class Definitions&lt;/h2&gt; &#xA;&lt;p&gt;The same module namespacing syntax we used above can also be used to namespace classes. You&#39;ll encounter syntax like this when working with other Ruby libraries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;module ActiveRecord&#xA;  class Base&#xA;    # migration class definition&#xA;  end&#xA;&#xA;  class Migration&#xA;    # migration class definition&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for this namespacing is to avoid variable collision: what if our application also happened to have a class definition for &lt;code&gt;Base&lt;/code&gt; or &lt;code&gt;Migration&lt;/code&gt;? Thanks to namespacing, we can tell that these class definitions are specific to the &lt;code&gt;ActiveRecord&lt;/code&gt; module.&lt;/p&gt; &#xA;&lt;p&gt;To use those class definitions, we refer to them using the &lt;code&gt;::&lt;/code&gt; syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;ActiveRecord::Base&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Namespacing vs Inheritance&lt;/h2&gt; &#xA;&lt;p&gt;Inheritance using the &lt;code&gt;&amp;lt;&lt;/code&gt; syntax implies that a class is a &lt;em&gt;type&lt;/em&gt; of another class. A &lt;code&gt;BMW&lt;/code&gt; class should inherit from a &lt;code&gt;Car&lt;/code&gt; class because a BMW is a &lt;em&gt;type&lt;/em&gt; of car: &lt;code&gt;class BMW &amp;lt; Car&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But what about the &lt;code&gt;::&lt;/code&gt; that we&#39;re using for our modules? The &lt;code&gt;::&lt;/code&gt; syntax just denotes a namespace. Doing &lt;code&gt;BMW::Car&lt;/code&gt; just gives the &lt;code&gt;BMW&lt;/code&gt; class access to all constants, instance methods, etc, without stating that a BMW is a type of car. The &lt;code&gt;::&lt;/code&gt; syntax carries all public items over to the inheriting class or module.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s it! Now that we are familiar with several methods of sharing code between classes, you&#39;re ready to move on to the next few labs.&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;If you have a module whose methods you would like to be used in another class as &lt;strong&gt;instance methods&lt;/strong&gt;, then you must &lt;strong&gt;include&lt;/strong&gt; the module.&lt;/p&gt; &#xA;&lt;p&gt;If you want a module&#39;s methods to be used in another class as &lt;strong&gt;class methods&lt;/strong&gt;, you must &lt;strong&gt;extend&lt;/strong&gt; the module.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-ruby-oo-inheritance-defining-inheritance</title>
    <updated>2023-05-23T01:43:53Z</updated>
    <id>tag:github.com,2023-05-23:/learn-co-curriculum/phase-3-ruby-oo-inheritance-defining-inheritance</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-ruby-oo-inheritance-defining-inheritance" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Defining Object Inheritance&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Learn about inheritance in object oriented Ruby.&lt;/li&gt; &#xA; &lt;li&gt;Write classes that inherit from another class.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction: Why Inheritance?&lt;/h2&gt; &#xA;&lt;p&gt;In the real-world, different entities (people, animals, cars, you name it) are related in various ways. Within a single entity or group, there exist systems of classification. For example, the &#34;dogs&#34; entity or category includes pugs, corgis, labs, etc. All of these breeds share common features because they are all dogs. But they all have certain unique traits as well.&lt;/p&gt; &#xA;&lt;p&gt;Another example: you are writing a web application in which users are either admins, instructors or students. All of these entities are &#34;users&#34; and have common features, but they all have some unique traits as well.&lt;/p&gt; &#xA;&lt;p&gt;How can our code reflect the fact that these different categories of things all share some, or even many, characteristics but all have some unique attributes as well? Well, we could write separate &lt;code&gt;Admin&lt;/code&gt;, &lt;code&gt;Instructor&lt;/code&gt; and &lt;code&gt;Student&lt;/code&gt; classes that each contain repetitious code to lend each of these classes shared attributes and behaviors. We know, however, that repetitive code is always something to be avoided. Not only is it time consuming, but what happens when we need to make a change to this shared behavior? We&#39;d have to code the same change in three places.&lt;/p&gt; &#xA;&lt;p&gt;Instead, we can use &lt;strong&gt;inheritance&lt;/strong&gt;. The use of inheritance allows us to create a family of classes with shared behavior, while still differentiating those classes. With inheritance, we could &lt;em&gt;inherit&lt;/em&gt; the &lt;code&gt;Admin&lt;/code&gt;, &lt;code&gt;Instructor&lt;/code&gt; and &lt;code&gt;Student&lt;/code&gt; classes from a &lt;code&gt;User&lt;/code&gt; class. Then, any changes made to the &lt;code&gt;User&lt;/code&gt; class would apply to the other class.&lt;/p&gt; &#xA;&lt;p&gt;While you may not write your own classes that use inheritance very frequently, you will encounter it frequently as a developer, particularly when working with other libraries (such as Active Record, which you&#39;ll learn later in this phase). Once we introduce the use of databases and the challenge of connecting our programs to our database, you&#39;ll encounter inheritance in nearly every program you write for the web. More on that later.&lt;/p&gt; &#xA;&lt;h2&gt;What is Inheritance?&lt;/h2&gt; &#xA;&lt;p&gt;In Ruby, classes can inherit from one another. This means that they adopt all of the attributes and behaviors (i.e. all of the methods) of the parent, also called the &lt;strong&gt;super&lt;/strong&gt; class. In this exercise, we&#39;ll be building our own chain of inheritance.&lt;/p&gt; &#xA;&lt;h2&gt;Code Along: Basic Inheritance&lt;/h2&gt; &#xA;&lt;p&gt;In this domain model, we have class &lt;code&gt;Vehicle&lt;/code&gt; that will act as the parent, or super, class. We will create child classes, also known as &lt;strong&gt;subclasses&lt;/strong&gt; for different types of &lt;code&gt;Vehicle&lt;/code&gt;s, such as car.&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Defining the Super Class&lt;/h3&gt; &#xA;&lt;p&gt;Open up &lt;code&gt;lib/vehicle.rb&lt;/code&gt;. We&#39;re going to define some methods in this parent class so that our subclasses, when we make them, will have access to them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Vehicle&#xA;&#xA;  attr_accessor :wheel_size, :wheel_number&#xA;&#xA;  def initialize(wheel_size, wheel_number)&#xA;    @wheel_size = wheel_size&#xA;    @wheel_number = wheel_number&#xA;  end&#xA;&#xA;  def go&#xA;    &#34;vrrrrrrrooom!&#34;&#xA;  end&#xA;&#xA;  def fill_up_tank&#xA;    &#34;filling up!&#34;&#xA;  end&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instances of &lt;code&gt;Vehicle&lt;/code&gt; initialize with a wheel size and number. We also have &lt;code&gt;#go&lt;/code&gt; and &lt;code&gt;#fill_up_tank&lt;/code&gt; instance methods that describe some common vehicle behavior.&lt;/p&gt; &#xA;&lt;p&gt;Go ahead and paste the above Vehicle class code into your Vehicle class, and run the test suite and you&#39;ll see that you are passing all of the tests for the &lt;code&gt;Vehicle&lt;/code&gt; class but none of the tests for the &lt;code&gt;Car&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;h3&gt;Step 2: Defining the Subclass&lt;/h3&gt; &#xA;&lt;p&gt;Open up &lt;code&gt;lib/car.rb&lt;/code&gt;. Notice that we are requiring &lt;code&gt;lib/vehicle.rb&lt;/code&gt;. That is because our &lt;code&gt;Car&lt;/code&gt; class will need access to the &lt;code&gt;Vehicle&lt;/code&gt; class and will therefore need access to the file that contains that class.&lt;/p&gt; &#xA;&lt;p&gt;Go ahead and define the class in the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Car &amp;lt; Vehicle&#xA;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;&amp;lt;&lt;/code&gt; to inherit the &lt;code&gt;Car&lt;/code&gt; class from &lt;code&gt;Vehicle&lt;/code&gt;. Notice that there are &lt;em&gt;no methods defined in the &lt;code&gt;Car&lt;/code&gt; class&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Run the test suite again and you&#39;ll see that you are passing a number of tests for the &lt;code&gt;Car&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;Wow! We didn&#39;t write &lt;em&gt;anything&lt;/em&gt; in our &lt;code&gt;Car&lt;/code&gt; class but instances of &lt;code&gt;Car&lt;/code&gt; class &lt;em&gt;inherit&lt;/em&gt; all of the &lt;code&gt;Vehicle&lt;/code&gt; methods and therefore have access to them. We&#39;re still failing the &lt;code&gt;#go&lt;/code&gt; test however. Looks like the test is expecting the &lt;code&gt;#go&lt;/code&gt; method on an individual car to return the phrase: &lt;code&gt;&#34;VRRROOOOOOOOOOOOOOOOOOOOOOOM!!!!!&#34;&lt;/code&gt;. This is different than the return value of the &lt;code&gt;#go&lt;/code&gt; method that we inherited from the &lt;code&gt;Vehicle&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s overwrite the inherited &lt;code&gt;#go&lt;/code&gt; method with one specific to &lt;code&gt;Car&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Step 3: Overwriting Inherited Methods&lt;/h3&gt; &#xA;&lt;p&gt;In &lt;code&gt;lib/car.rb&lt;/code&gt;, write the following method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Car &amp;lt; Vehicle&#xA;  def go&#xA;    &#34;VRRROOOOOOOOOOOOOOOOOOOOOOOM!!!!!&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, run the tests again and you should be passing all of them.&lt;/p&gt; &#xA;&lt;h2&gt;Method Look-Up in Ruby&lt;/h2&gt; &#xA;&lt;p&gt;How does our above example work? Well, when your program is being executed, at the point at which the &lt;code&gt;#go&lt;/code&gt; method is invoked, the compiler will first look in the class to which the instance of car that we are calling the method on belongs. If it finds a &lt;code&gt;#go&lt;/code&gt; method there, it will execute &lt;em&gt;that method&lt;/em&gt;. If it doesn&#39;t find such a method there, it will move on to look in the parent class that this class inherits from.&lt;/p&gt; &#xA;&lt;p&gt;You can see how Ruby classes inherit from one another by using Ruby to do some &lt;em&gt;introspection&lt;/em&gt; on our classes.&lt;/p&gt; &#xA;&lt;p&gt;Open up IRB, and start by requiring the files from the &lt;code&gt;lib&lt;/code&gt; folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;require_relative &#39;lib/vehicle&#39;&#xA;# =&amp;gt; true&#xA;require_relative &#39;lib/car&#39;&#xA;# =&amp;gt; true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will let you interact with the code you&#39;ve written in those files from within IRB.&lt;/p&gt; &#xA;&lt;p&gt;We can ask the &lt;code&gt;Car&lt;/code&gt; class what its parent, or &#34;superclass&#34; is (what class the &lt;code&gt;Car&lt;/code&gt; class inherits from) with the &lt;code&gt;.superclass&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Car.superclass&#xA;# =&amp;gt; Vehicle&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can even see what the parent class of &lt;code&gt;Vehicle&lt;/code&gt; is, and up as far as we can go on the inheritance chain to the very top (&lt;code&gt;BasicObject&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Car.superclass.superclass&#xA;# =&amp;gt; Object&#xA;Car.superclass.superclass.superclass&#xA;# =&amp;gt; BasicObject&#xA;Car.superclass.superclass.superclass.superclass&#xA;# =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;How does this work? How can we call the &lt;code&gt;.superclass&lt;/code&gt; class method method on our &lt;code&gt;Car&lt;/code&gt; class, even though we didn&#39;t define it ourselves? The &lt;code&gt;.superclass&lt;/code&gt; method is available on all Ruby classes, even built-in ones like the &lt;code&gt;Integer&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Integer.superclass&#xA;# =&amp;gt; Numeric&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s because all Ruby classes share the same class: the &lt;a href=&#34;https://ruby-doc.org/core-2.7.3/Class.html&#34;&gt;&lt;code&gt;Class&lt;/code&gt; class&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;Car.class&#xA;# =&amp;gt; Class&#xA;String.class&#xA;# =&amp;gt; Class&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve seen how to set up inheritance to share behavior from one class to another using the &lt;code&gt;&amp;lt;&lt;/code&gt; syntax in our class definition (&lt;code&gt;class Child &amp;lt; Parent&lt;/code&gt;), which lets the subclass use methods that are defined on the parent class. We also discussed how &lt;strong&gt;method lookup&lt;/strong&gt; works in Ruby, when multiple classes define the same method.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>learn-co-curriculum/phase-3-metaprogramming-custom-errors</title>
    <updated>2023-05-23T01:43:53Z</updated>
    <id>tag:github.com,2023-05-23:/learn-co-curriculum/phase-3-metaprogramming-custom-errors</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-metaprogramming-custom-errors" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Custom Errors&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create and raise custom error messages in Ruby&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Ruby has a hierarchy of error, or &lt;code&gt;Exception&lt;/code&gt;, classes, all of which inherit from the Exception class. You&#39;ll become familiar with these error types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;NoMethodError&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And these are just a few! Let&#39;s say, however, that we&#39;re creating a new feature for an application being worked on by a team of other developers. If another developer uses some of our code incorrectly (such as calling a method with the wrong kind of data), it would be helpful for them to know what they did wrong so they can fix it. We can use custom error messages and custom error handling to save the day!&lt;/p&gt; &#xA;&lt;p&gt;By defining custom error messages and handling, we can show other developers a specific error message in the event they use some of our code incorrectly. In this reading and the following lab, we&#39;ll practice building simple custom errors.&lt;/p&gt; &#xA;&lt;p&gt;Code along with the instructions below.&lt;/p&gt; &#xA;&lt;h2&gt;A Refresher on Inheritance&lt;/h2&gt; &#xA;&lt;p&gt;If one class inherits from another, that means it takes on all of the methods and behaviors of the class from which it inherits. In the below example, the &lt;code&gt;Child&lt;/code&gt; class inherits from the &lt;code&gt;Parent&lt;/code&gt; class. Consequently, all instances of &lt;code&gt;Child&lt;/code&gt; have not only the behaviors and methods defined directly in the &lt;code&gt;Child&lt;/code&gt; class itself but also all of the methods and behaviors defined in the &lt;code&gt;Parent&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Child &amp;lt; Parent&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building a Custom Error&lt;/h2&gt; &#xA;&lt;p&gt;To build a custom error, we define an error class that inherits from the Exception class. Which class your custom error inherits from will likely depend on the situation in which you want to raise it. However, it is usually a pretty safe bet to inherit your custom error class from the StandardError class. For more info on error class hierarchies, you can review this chart of error class inheritance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Exception&#xA; NoMemoryError&#xA; ScriptError&#xA;   LoadError&#xA;   NotImplementedError&#xA;   SyntaxError&#xA; SignalException&#xA;   Interrupt&#xA; StandardError&#xA;   ArgumentError&#xA;   IOError&#xA;     EOFError&#xA;   IndexError&#xA;   LocalJumpError&#xA;   NameError&#xA;     NoMethodError&#xA;   RangeError&#xA;     FloatDomainError&#xA;   RegexpError&#xA;   RuntimeError&#xA;   SecurityError&#xA;   SystemCallError&#xA;   SystemStackError&#xA;   ThreadError&#xA;   TypeError&#xA;   ZeroDivisionError&#xA; SystemExit&#xA; fatal&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Defining Our Error Class&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s look at the example of our &lt;code&gt;Person&lt;/code&gt; class and its &lt;code&gt;#get_married&lt;/code&gt; method. In &lt;code&gt;lib/custom_errors.rb&lt;/code&gt;, we have the following code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person&#xA;  attr_accessor :name, :partner&#xA;&#xA;  def initialize(name)&#xA;    @name = name&#xA;  end&#xA;&#xA;  def get_married(person)&#xA;    self.partner = person&#xA;    person.partner = self&#xA;  end&#xA;end&#xA;&#xA;beyonce = Person.new(&#34;Beyonce&#34;)&#xA;beyonce.get_married(&#34;Jay-Z&#34;)&#xA;puts beyonce.name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As it currently stands, we would receive a NoMethodError if we try to pass &lt;code&gt;#get_married&lt;/code&gt; an argument of anything that &lt;em&gt;is not&lt;/em&gt; an instance of the &lt;code&gt;Person&lt;/code&gt; class (that is, a class without a &lt;code&gt;#partner=&lt;/code&gt; method defined).&lt;/p&gt; &#xA;&lt;p&gt;For example, at the bottom of our &lt;code&gt;lib/custom_errors.rb&lt;/code&gt; file, we&#39;re trying to tell Beyonce to &lt;code&gt;#get_married&lt;/code&gt; to &lt;code&gt;&#34;Jay-Z&#34;&lt;/code&gt;. The problem is that &lt;code&gt;&#34;Jay-Z&#34;&lt;/code&gt; is a string, &lt;em&gt;not&lt;/em&gt; an instance of the &lt;code&gt;Person&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;Run the code in the &lt;code&gt;lib/custom_errors.rb&lt;/code&gt; file with the &lt;code&gt;ruby lib/custom_errors.rb&lt;/code&gt; command. You should see the following output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;custom_errors.rb:10:in `get_married&#39;: undefined method `partner=&#39; for &#34;Jay-Z&#34;:String (NoMethodError)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s pretty informative as errors go. However, we&#39;re here to learn about raising our very own custom errors. So, for the sake of this example, let&#39;s say we are not satisfied with this error. Let&#39;s make our own!&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Defining the custom error class&lt;/h3&gt; &#xA;&lt;p&gt;Let&#39;s define a custom error class, &lt;code&gt;PartnerError&lt;/code&gt; that inherits from &lt;code&gt;StandardError&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PartnerError &amp;lt; StandardError&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Okay, we have the code for our custom error class right here, but where does it belong in our application? We have a couple of options. We can simply place the above code &lt;em&gt;inside&lt;/em&gt; of the &lt;code&gt;Person&lt;/code&gt; class. We could define it outside of our &lt;code&gt;Person&lt;/code&gt; class. Or, we can create a module and include that module inside the &lt;code&gt;Person&lt;/code&gt; class. For now, we&#39;re going to include our custom error class inside of our &lt;code&gt;Person&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person&#xA;  # rest of class...&#xA;&#xA;  def get_married(person)&#xA;    self.partner = person&#xA;    person.partner = self&#xA;  end&#xA;&#xA;  # Add the following two lines:&#xA;  class PartnerError &amp;lt; StandardError&#xA;  end&#xA;end&#xA;&#xA;beyonce = Person.new(&#34;Beyonce&#34;)&#xA;beyonce.get_married(&#34;Jay-Z&#34;)&#xA;puts beyonce.name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we&#39;re ready to use our custom error inside our &lt;code&gt;#get_married&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;h3&gt;Step 2: Raising our custom error&lt;/h3&gt; &#xA;&lt;p&gt;We need to tell our program to raise our brand new &lt;code&gt;PartnerError&lt;/code&gt; when the argument passed into the &lt;code&gt;#get_married&lt;/code&gt; method is &lt;em&gt;not&lt;/em&gt; an instance of the &lt;code&gt;Person&lt;/code&gt; class. We can do that with the &lt;code&gt;raise&lt;/code&gt; keyword. Place the following code in your &lt;code&gt;#get_married&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person&#xA;  attr_accessor :partner, :name&#xA;&#xA;  def initialize(name)&#xA;    @name = name&#xA;  end&#xA;&#xA;  def get_married(person)&#xA;    if person.is_a?(Person)&#xA;      self.partner = person&#xA;      person.partner = self&#xA;    else&#xA;      raise PartnerError&#xA;    end&#xA;  end&#xA;&#xA;  class PartnerError &amp;lt; StandardError&#xA;  end&#xA;end&#xA;&#xA;beyonce = Person.new(&#34;Beyonce&#34;)&#xA;beyonce.get_married(&#34;Jay-Z&#34;)&#xA;puts beyonce.name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, go ahead and run the file again. This time you should see the following in your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;custom_errors.rb:11:in `get_married&#39;: Person::PartnerError (Person::PartnerError)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We did it! We raised our very own custom error. However, our program is still broken. Notice that the &lt;code&gt;puts beyonce.name&lt;/code&gt; line at the bottom of our file &lt;em&gt;won&#39;t run&lt;/em&gt; because it follows the &lt;code&gt;#get_married&lt;/code&gt; method call, and we called that method in such a way as to raise an error. If only there was a way for us to &lt;em&gt;rescue&lt;/em&gt; our program when such an error is raised and allow it to keep running...&lt;/p&gt; &#xA;&lt;h2&gt;Custom Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;We can achieve the above goal via something called &lt;strong&gt;rescuing&lt;/strong&gt;. Before we look at how to rescue the errors we raise and allow our program to continue to run, let&#39;s think about the desired behavior of our rescue.&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Writing a Custom Error Message&lt;/h3&gt; &#xA;&lt;p&gt;Of course we want our program to continue running after we raise the error. It would also be nice to output a custom error message when the error is raised. Let&#39;s add a message to our &lt;code&gt;PartnerError&lt;/code&gt; class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PartnerError &amp;lt; StandardError&#xA;  def message&#xA;    &#34;you must give the get_married method an argument of an instance of the person class!&#34;&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we have a nice, informative, custom error message that will make it really clear to our users what went wrong if they encounter this error. Now we&#39;re ready to implement our &lt;code&gt;rescue&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Step 2: Implementing the &lt;code&gt;rescue&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The basic pattern of error rescuing is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;begin&#xA;  raise YourCustomError&#xA;rescue YourCustomError&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s implement this code in our &lt;code&gt;#get_married&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def get_married(person)&#xA;  if person.is_a?(Person)&#xA;    self.partner = person&#xA;    person.partner = self&#xA;  else&#xA;    begin&#xA;      raise PartnerError&#xA;    rescue PartnerError =&amp;gt; error&#xA;      puts error.message&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the object passed into the method as an argument &lt;em&gt;is not&lt;/em&gt; an instance of the &lt;code&gt;Person&lt;/code&gt; class, we will &lt;code&gt;begin&lt;/code&gt; our error handling. First, we &lt;code&gt;raise&lt;/code&gt; our &lt;code&gt;PartnerError&lt;/code&gt;, then we &lt;code&gt;rescue&lt;/code&gt; our &lt;code&gt;PartnerError&lt;/code&gt;. The &lt;code&gt;rescue&lt;/code&gt; method creates an instance of the &lt;code&gt;PartnerError&lt;/code&gt; class and &lt;code&gt;puts&lt;/code&gt; out the result of calling &lt;code&gt;message&lt;/code&gt; on that instance.&lt;/p&gt; &#xA;&lt;p&gt;At this point, the code in &lt;code&gt;custom_errors.rb&lt;/code&gt; should look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Person&#xA;  attr_accessor :partner, :name&#xA;&#xA;  def initialize(name)&#xA;    @name = name&#xA;  end&#xA;&#xA;  def get_married(person)&#xA;    if person.is_a?(Person)&#xA;      self.partner = person&#xA;      person.partner = self&#xA;    else&#xA;      begin&#xA;        raise PartnerError&#xA;      rescue PartnerError =&amp;gt; error&#xA;        puts error.message&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  class PartnerError &amp;lt; StandardError&#xA;    def message&#xA;      &#34;you must give the get_married method an argument of an instance of the person class!&#34;&#xA;    end&#xA;  end&#xA;end&#xA;&#xA;beyonce = Person.new(&#34;Beyonce&#34;)&#xA;beyonce.get_married(&#34;Jay-Z&#34;)&#xA;puts beyonce.name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, run the file one more time, and you&#39;ll see that not only is our custom error message printed out but the program continues to run and will execute the &lt;code&gt;puts beyonce.name&lt;/code&gt; line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;you must give the get_married method an argument of an instance of the person class!&#xA;Beyonce&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run &lt;code&gt;learn test&lt;/code&gt; with the code above, and the tests should all pass!&lt;/p&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Adding custom errors to our Ruby classes makes them much nicer for other developers to work with. We&#39;ve extended the API (the interface) of our classes to include more helpful messages to other developers who are using our code that indicate not only what the issue is, but how they can fix it by using our code in the way it&#39;s intended to be used.&lt;/p&gt; &#xA;&lt;p&gt;We also saw how to use the &lt;code&gt;begin/rescue&lt;/code&gt; syntax as another form of &lt;strong&gt;control flow&lt;/strong&gt; to handle exceptions gracefully.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.honeybadger.io/blog/ruby-custom-exceptions/&#34;&gt;Custom Exceptions in Ruby&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rubyguides.com/2019/06/ruby-rescue-exceptions/&#34;&gt;Rescuing Exceptions in Ruby&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>