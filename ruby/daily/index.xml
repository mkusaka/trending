<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-10T01:32:36Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>learn-co-curriculum/phase-3-methods</title>
    <updated>2022-08-10T01:32:36Z</updated>
    <id>tag:github.com,2022-08-10:/learn-co-curriculum/phase-3-methods</id>
    <link href="https://github.com/learn-co-curriculum/phase-3-methods" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Methods&lt;/h1&gt; &#xA;&lt;h2&gt;Learning Goals&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Understand the similarities between methods in Ruby and functions in JavaScript&lt;/li&gt; &#xA; &lt;li&gt;Identify key differences between methods and functions&lt;/li&gt; &#xA; &lt;li&gt;Define methods with parameters&lt;/li&gt; &#xA; &lt;li&gt;Call methods and use their return value&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;One of the first things you likely learned in JavaScript was how to write functions. In this lesson, you&#39;ll get practice writing methods in Ruby to see the difference between Ruby methods and JavaScript functions.&lt;/p&gt; &#xA;&lt;h2&gt;Ruby Method Syntax&lt;/h2&gt; &#xA;&lt;p&gt;To start, let&#39;s try re-writing this JavaScript function in Ruby:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function myFunction(param) {&#xA;  console.log(&#34;Running myFunction&#34;);&#xA;  return param + 1;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As a quick recap of the syntax here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;strong&gt;&lt;code&gt;function&lt;/code&gt; keyword&lt;/strong&gt; identifies this code as a function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;myFunction&lt;/code&gt; is a &lt;strong&gt;variable name&lt;/strong&gt; we can use to refer to the function from elsewhere in our code, written in camel case by convention.&lt;/li&gt; &#xA; &lt;li&gt;The parentheses &lt;code&gt;()&lt;/code&gt; after the function name give a space where we can define &lt;strong&gt;parameters&lt;/strong&gt; for our function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;param&lt;/code&gt; is the variable name given to our function&#39;s parameter; it will be assigned a value when the function is invoked and passed an argument.&lt;/li&gt; &#xA; &lt;li&gt;To define the body of the function, we use curly brackets (&lt;code&gt;{ }&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;console.log&lt;/code&gt; is a method that will output information to the terminal; remember, this is &lt;em&gt;different&lt;/em&gt; from a function&#39;s &lt;strong&gt;return value&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;return&lt;/code&gt; keyword is needed when we want our function to return a value when it is called; in this case, it will return a value of whatever the &lt;code&gt;param&lt;/code&gt; variable is plus one.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To actually run the code inside the function, we must invoke it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const myFunctionReturnValue = myFunction(1);&#xA;// =&amp;gt; &#34;Running myFunction&#34;&#xA;console.log(myFunctionReturnValue);&#xA;// =&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, we&#39;re calling the function &lt;code&gt;myFunction&lt;/code&gt; with an &lt;strong&gt;argument&lt;/strong&gt; of &lt;code&gt;1&lt;/code&gt;. We are then assigning the &lt;strong&gt;return value&lt;/strong&gt; of &lt;code&gt;myFunction&lt;/code&gt; to a new variable, &lt;code&gt;myFunctionReturnValue&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If we wanted to write a method in Ruby with similar functionality, here&#39;s how it would look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def my_method(param)&#xA;  puts &#34;Running my_method&#34;&#xA;  param + 1&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a few key differences in the syntax here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use the &lt;code&gt;def&lt;/code&gt; keyword to identify this code as a method.&lt;/li&gt; &#xA; &lt;li&gt;Write the name of the method in snake case (by convention).&lt;/li&gt; &#xA; &lt;li&gt;Parameters are still defined in parentheses, after the method name.&lt;/li&gt; &#xA; &lt;li&gt;Instead of curly parentheses, use the &lt;code&gt;end&lt;/code&gt; keyword to identify where the method ends.&lt;/li&gt; &#xA; &lt;li&gt;In Ruby, whatever the &lt;strong&gt;last line of a method is will be its return value&lt;/strong&gt;. You can use the &lt;code&gt;return&lt;/code&gt; keyword to explicitly identify the return value of a method, but Rubyists tend to rely on the implicit return instead.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Run IRB, and copy/paste the method definition above into your IRB session. Then, run the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;my_method_return_value = my_method(1)&#xA;# Running my_method&#xA;# =&amp;gt; 2&#xA;my_method_return_value&#xA;# =&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When the &lt;code&gt;#my_method&lt;/code&gt; method is called, you&#39;ll see the output from the &lt;code&gt;#puts&lt;/code&gt; method in the terminal, followed by the return value. The return value, &lt;code&gt;2&lt;/code&gt;, is then saved to the variable &lt;code&gt;my_method_return_value&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Why are they called methods in Ruby as opposed to functions? If you recall from Object Oriented JavaScript, the difference between a method and a function is that a &lt;strong&gt;method&lt;/strong&gt; is a special sub-category of functions that must be called on some object. In Ruby, every method we define — even when it&#39;s not defined explicitly &#34;on an object&#34; or as part of a class definition — is still actually defined on a built-in Ruby object: the global &lt;code&gt;main&lt;/code&gt; object, which you&#39;ll see referenced in error messages like &#34;NameError (undefined local variable or method &#39;my_var&#39; for main:Object)&#34;. &lt;code&gt;main&lt;/code&gt; is roughly equivalent to the global object in JavaScript (the window in the browser); you can see for yourself by entering IRB and typing &lt;code&gt;self&lt;/code&gt;. Read more about &lt;a href=&#34;https://codequizzes.wordpress.com/2014/04/23/rubys-main-object-top-level-context/&#34;&gt;Ruby&#39;s Main Object here&lt;/a&gt; if you&#39;re curious!&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Optional Parentheses&lt;/h3&gt; &#xA;&lt;p&gt;Just like in JavaScript, you can invoke a method by placing parentheses at the end and passing in values as arguments, as in the example above. In Ruby though, parentheses are optional:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;my_method 1&#xA;# Running my_method&#xA;# =&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This syntax is a point of confusion for developers new to Ruby, since it can make it a bit less clear when using code whether you&#39;re invoking a &lt;strong&gt;method&lt;/strong&gt; or using a &lt;strong&gt;variable&lt;/strong&gt;. Consider the following method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def say_hello()&#xA;  &#34;hello!&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Parentheses are optional when defining the method, so we could also write this method like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def say_hello&#xA;  &#34;hello!&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rubystyle.guide/#method-parens&#34;&gt;The convention in Ruby&lt;/a&gt; is to use parentheses as part of a method definition when it takes parameters, and to omit them when it has no parameters.&lt;/p&gt; &#xA;&lt;p&gt;You could &lt;strong&gt;run&lt;/strong&gt; this method by placing parentheses at the end, like you would in JavaScript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;say_hello()&#xA;# =&amp;gt; &#34;hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But you can also run this method without parentheses:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;say_hello&#xA;# =&amp;gt; &#34;hello&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In certain contexts, removing parentheses from the method calls can make your code more pleasant to look at. You might also see some Domain Specific Languages (DSLs) that prefer to omit parentheses. You&#39;ve probably already seen a little bit of RSpec&#39;s DSL in the test files, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;describe &#34;MyRubyThing&#34; do&#xA;  it &#34;runs&#34; do&#xA;    # test here&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;#describe&lt;/code&gt; and &lt;code&gt;#it&lt;/code&gt; are just methods, so the above could have been written:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;describe(&#34;MyRubyThing&#34;) do&#xA;  it(&#34;runs&#34;) do&#xA;    # test here&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But I think you&#39;ll agree that it looks nicer (and is easier to read) without the parentheses.&lt;/p&gt; &#xA;&lt;p&gt;As you&#39;re getting started, just keep the fact that &lt;strong&gt;parentheses are optional&lt;/strong&gt; in the back of your mind, and remember to ask yourself the question when looking at code: &#34;Is this a variable, or is this a method?&#34;&lt;/p&gt; &#xA;&lt;h2&gt;Method Arguments&lt;/h2&gt; &#xA;&lt;p&gt;JavaScript allows you to define functions that expect a certain number of arguments, but will still run your code even if you don&#39;t pass in the expected number when you invoke the function. This can lead to some unexpected behavior in your JavaScript applications.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function sayHi(name) {&#xA;  console.log(`Hi there, ${name}!`);&#xA;}&#xA;&#xA;sayHi();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What do you think will happen when this code runs? Will it throw an error? Print something to the console? If so, what? Try running it in the browser to find out.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately for JavaScript developers, bugs like these are hard to identify because they can only be found by testing our code and looking for unexpected behavior.&lt;/p&gt; &#xA;&lt;p&gt;In Ruby, thankfully, when we run a method without passing in the required arguments it will give us an error message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def say_hi(name)&#xA;  puts &#34;Hi there, #{name}!&#34;&#xA;end&#xA;&#xA;say_hi&#xA;# =&amp;gt; ArgumentError (wrong number of arguments (given 0, expected 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Error messages like this are a &lt;strong&gt;good thing&lt;/strong&gt; for us as developers, because it ensures that we are using methods as they are intending to be used, rather than trying to &#34;fail gracefully&#34; like JavaScript does.&lt;/p&gt; &#xA;&lt;h2&gt;Default Arguments&lt;/h2&gt; &#xA;&lt;p&gt;We can fix the behavior of our JavaScript function above by providing a default argument: a value that will be used if we don&#39;t explicitly provide one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function sayHi(name = &#34;friend&#34;) {&#xA;  console.log(`Hi there, ${name}!`);&#xA;}&#xA;&#xA;sayHi();&#xA;// =&amp;gt; &#34;Hi there, friend!&#34;&#xA;sayHi(&#34;Sunny&#34;);&#xA;// =&amp;gt; &#34;Hi there, Sunny!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Ruby also lets us provide default arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def say_hi(name = &#34;Rubyist&#34;)&#xA;  puts &#34;Hi there, #{name}!&#34;&#xA;end&#xA;&#xA;say_hi&#xA;# =&amp;gt; &#34;Hi there, Rubyist!&#34;&#xA;&#xA;say_hi &#34;Sunny&#34;&#xA;# =&amp;gt; &#34;Hi there, Sunny!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Return Values&lt;/h2&gt; &#xA;&lt;p&gt;You can categorize all functions that you write as generally useful for one (or both) of these things:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;What &lt;em&gt;return value&lt;/em&gt; they have&lt;/li&gt; &#xA; &lt;li&gt;What &lt;em&gt;side effects&lt;/em&gt; they have (what other parts of the application they change; or what they output to the terminal; or what they write to a file; etc)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Writing output to the terminal using &lt;code&gt;console.log&lt;/code&gt; or &lt;code&gt;#puts&lt;/code&gt; is a &lt;em&gt;side effect&lt;/em&gt; of a function: it&#39;s distinct from the function&#39;s &lt;em&gt;return value&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Consider these two JavaScript functions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function addAndLog(num1, num2) {&#xA;  console.log(num1 + num2);&#xA;}&#xA;&#xA;function addAndReturn(num1, num2) {&#xA;  return num1 + num2;&#xA;}&#xA;&#xA;const sum1 = addAndLog(2, 2);&#xA;const sum2 = addAndReturn(2, 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What do you expect the values of &lt;code&gt;sum1&lt;/code&gt; and &lt;code&gt;sum2&lt;/code&gt; to be? What output would you expect to see in the console if you ran this code?&lt;/p&gt; &#xA;&lt;p&gt;Since &lt;code&gt;addAndLog&lt;/code&gt; doesn&#39;t use the &lt;code&gt;return&lt;/code&gt; keyword, the value of &lt;code&gt;sum1&lt;/code&gt; is undefined. We&#39;re only using &lt;code&gt;addAndLog&lt;/code&gt; for its &lt;em&gt;side effect&lt;/em&gt; of logging output to the terminal. &lt;code&gt;sum2&lt;/code&gt;, on the other hand, will have a value of &lt;code&gt;4&lt;/code&gt;, since we are using &lt;code&gt;addAndReturn&lt;/code&gt; for its return value.&lt;/p&gt; &#xA;&lt;p&gt;Think of it this way: methods are like vending machines. When you use a vending machine you just put in two arguments, the number (C7) and your money. We already know how to use arguments, but then your vending machine might do two things. One, it will make a noise saying that everything worked, beep beep. Then it gives you the soda. The soda is the return type. But those beeps? Are you able to do anything with them? Nope! That&#39;s like &lt;code&gt;#puts&lt;/code&gt;: it just tells you stuff and then goes into the ether! Gone forever.&lt;/p&gt; &#xA;&lt;p&gt;Every method in Ruby returns a value by default. This returned value will be the value of the last statement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def add_and_log(num1, num2)&#xA;  puts num1 + num2&#xA;end&#xA;&#xA;def add_and_return(num1, num2)&#xA;  return num1 + num2&#xA;end&#xA;&#xA;sum1 = add_and_log(2, 2)&#xA;# =&amp;gt; nil&#xA;sum2 = add_and_return(2, 2)&#xA;# =&amp;gt; 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The return value of the &lt;code&gt;#add_and_log&lt;/code&gt; method is &lt;code&gt;nil&lt;/code&gt;, because &lt;code&gt;#puts&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Say you&#39;re the best painter in the world, Bob Ross. To make a method that just prints your name and returns &lt;code&gt;nil&lt;/code&gt;, you could write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def print_name&#xA;  puts &#34;Bob Ross&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To write a method that returns your name but doesn&#39;t print anything, you could write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def return_name&#xA;  &#34;Bob Ross&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To both print and return your name, you could write:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def print_and_return_name&#xA;  puts &#34;Bob Ross&#34;&#xA;  &#34;Bob Ross&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you accidentally switched the order of the lines inside the method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def broken_print_and_return_name&#xA;  &#34;Bob Ross&#34;&#xA;  puts &#34;Bob Ross&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The method would instead print &#34;Bob Ross&#34; and return &lt;code&gt;nil&lt;/code&gt;. This is because the last line that was evaluated was &lt;code&gt;puts ...&lt;/code&gt; and the return value of a &lt;code&gt;#puts&lt;/code&gt; is always &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;The Return Keyword&lt;/h3&gt; &#xA;&lt;p&gt;There is one other way to return a value from a method, and that is to use the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take a look:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def stylish_painter&#xA;  best_hairstyle = &#34;Bob Ross&#34;&#xA;  return &#34;Jean-Michel Basquiat&#34;&#xA;  best_hairstyle&#xA;end&#xA;&#xA;stylish_painter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What do you expect the return value of the above method to be? Go into IRB, copy and paste the above method and call it.&lt;/p&gt; &#xA;&lt;p&gt;You may have expected the return value to be Bob Ross. His name is the last line of the method. &lt;em&gt;However&lt;/em&gt;, the return value of the above method is actually Jean-Michel Basquiat! The &lt;code&gt;return&lt;/code&gt; keyword will disrupt the execution of your method, and prevent Ruby from running any lines of code after the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;p&gt;The explicit use of the &lt;code&gt;return&lt;/code&gt; keyword is generally avoided by many Rubyists, but there are instances where you might want to use &lt;code&gt;return&lt;/code&gt; instead of relying on implicit returns; for example, if we wanted to use a &lt;a href=&#34;https://devblast.com/b/what-are-guard-clauses&#34;&gt;guard clause&lt;/a&gt; and exit a function early if a certain condition isn&#39;t met:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rb&#34;&gt;def reverse_name(name)&#xA;  if name.class != String&#xA;    return nil&#xA;  end&#xA;&#xA;  name.reverse&#xA;end&#xA;&#xA;reverse_name(&#34;Bob Ross&#34;)&#xA;# =&amp;gt; &#34;ssoR boB&#34;&#xA;reverse_name(123)&#xA;# =&amp;gt; nil&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;p&gt;In the &lt;code&gt;js/index.js&lt;/code&gt; file, there are four functions defined in JavaScript. Your job is to recreate the functionality of those functions by writing methods in Ruby that will accomplish the same thing.&lt;/p&gt; &#xA;&lt;p&gt;Write your code in &lt;code&gt;methods.rb&lt;/code&gt;. Run &lt;code&gt;learn test&lt;/code&gt;, and use the tests along with the code in &lt;code&gt;js/index.js&lt;/code&gt; to guide your work.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a method &lt;code&gt;#greet_programmer&lt;/code&gt; that takes no arguments. It should output the string &#34;Hello, programmer!&#34; to the terminal with &lt;code&gt;#puts&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a method &lt;code&gt;#greet&lt;/code&gt; that takes one argument, a name. It should output the string &#34;Hello, name!&#34; (with &#34;name&#34; being whatever value was passed as an argument) to the terminal with &lt;code&gt;#puts&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a method &lt;code&gt;#greet_with_default&lt;/code&gt; that takes one argument, a name. It should output the string &#34;Hello, name!&#34; (with &#34;name&#34; being whatever value was passed as an argument) to the terminal with &lt;code&gt;#puts&lt;/code&gt;. If no arguments are passed in, it should output the string &#34;Hello, programmer!&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a method &lt;code&gt;#add&lt;/code&gt; that takes two numbers as arguments and &lt;strong&gt;returns&lt;/strong&gt; the sum of those two numbers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Define a method &lt;code&gt;#halve&lt;/code&gt; that takes one number as an argument and &lt;strong&gt;returns&lt;/strong&gt; the that number&#39;s value, divided by two. If the argument is &lt;strong&gt;not&lt;/strong&gt; an integer, it should return &lt;code&gt;nil&lt;/code&gt; and not throw an error.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Conclusion&lt;/h2&gt; &#xA;&lt;p&gt;Ruby&#39;s method syntax has a few things that make them distinct from JavaScript functions. In particular, make sure you pay attention to the &lt;strong&gt;implicit return&lt;/strong&gt; value of Ruby methods, and always call methods with the right number of arguments to avoid errors. You should also keep in mind that &lt;strong&gt;parentheses are optional when calling methods&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rubyguides.com/2019/06/ruby-method-definition/&#34;&gt;Writing Ruby Methods&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>