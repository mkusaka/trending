<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-10-29T01:39:36Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pglombardo/PasswordPusher</title>
    <updated>2022-10-29T01:39:36Z</updated>
    <id>tag:github.com,2022-10-29:/pglombardo/PasswordPusher</id>
    <link href="https://github.com/pglombardo/PasswordPusher" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üîê A dead-simple application to securely communicate passwords over the web. Passwords automatically expire after a certain number of views and/or time has passed.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://pwpush.s3.eu-west-1.amazonaws.com/pwpush-horizontal-logo.png&#34; alt=&#34;Password Pusher Front Page&#34;&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;Simple &amp;amp; Secure Password Sharing with Auto-Expiration of Shared Items&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://twitter.com/pwpush&#34;&gt;&lt;img src=&#34;https://badgen.net/twitter/follow/pwpush&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://badgen.net/github/stars/pglombardo/PasswordPusher&#34; alt=&#34;&#34;&gt; &lt;img src=&#34;https://badgen.net/uptime-robot/month/m789048867-17b5770ccd78208645662f1f&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://hub.docker.com/repositories&#34;&gt;&lt;img src=&#34;https://badgen.net/docker/pulls/pglombardo/pwpush-ephemeral&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/actions/workflows/ruby.yml&#34;&gt;&lt;img src=&#34;https://github.com/pglombardo/PasswordPusher/actions/workflows/ruby.yml/badge.svg?sanitize=true&#34; alt=&#34;Github CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://circleci.com/gh/pglombardo/PasswordPusher/tree/master&#34;&gt;&lt;img src=&#34;https://badgen.net/circleci/github/pglombardo/PasswordPusher&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pglombardo/pwpush-cli/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr%20author%3Aapp%2Fdependabot&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dependencies-up%20to%20date-brightgreen.svg?sanitize=true&#34; alt=&#34;Dependencies Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pglombardo/pwpush-cli/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--versions-e10079.svg?sanitize=true&#34; alt=&#34;Semantic Versions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/pglombardo/pwpush/raw/master/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/pglombardo/PasswordPusher&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Password Pusher is an opensource application to communicate passwords over the web. Links to passwords expire after a certain number of views and/or time has passed.&lt;/p&gt; &#xA;&lt;p&gt;Hosted at &lt;a href=&#34;https://pwpush.com&#34;&gt;pwpush.com&lt;/a&gt; but you can also easily run your own private instance with just a few steps.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Easy-to-install:&lt;/strong&gt; Host your own via Docker, a cloud service or just use &lt;a href=&#34;https://pwpush.com&#34;&gt;pwpush.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Opensource:&lt;/strong&gt; No blackbox code. Only trusted, tested and reviewed opensource code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Audit logging:&lt;/strong&gt; Track and control what you&#39;ve shared and see who has viewed it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Encrypted storage:&lt;/strong&gt; All sensitive data is stored encrypted and is deleted once expired.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Host your own:&lt;/strong&gt; Database backed or ephemeral, easily run your own instance isolated from the world.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;JSON API:&lt;/strong&gt; Raw JSON API available for 3rd party tools or command line via &lt;code&gt;curl&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Command line interface:&lt;/strong&gt; Automate your password distribution with CLI tools or custom scripts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Internationalized:&lt;/strong&gt; 14 language translations are bundled in. Easily selectable via UI or URL&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Unbranded delivery page:&lt;/strong&gt; No logos, superfluous text or unrelated links to confuse end users.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Customizable:&lt;/strong&gt; Change text and default options via environment variables.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Light &amp;amp; dark themes:&lt;/strong&gt; Via CSS @media integration, the site theme follows your local preferences&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rebrandable:&lt;/strong&gt; Customize the site name, tagline and logo to fit your environment.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;10 Years Old:&lt;/strong&gt; Password Pusher has securely delivered millions and millions of passwords in it&#39;s 10 year history.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Honest Software:&lt;/strong&gt; Opensource written and maintained by &lt;a href=&#34;https://github.com/pglombardo&#34;&gt;me&lt;/a&gt; with the help of some great contributors. No organizations, corporations or evil agendas.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Follow Password Pusher &lt;a href=&#34;https://twitter.com/pwpush&#34;&gt;on Twitter&lt;/a&gt;, &lt;a href=&#34;https://gettr.com/user/pwpush&#34;&gt;Gettr&lt;/a&gt; or &lt;a href=&#34;https://www.facebook.com/pwpush&#34;&gt;on Facebook&lt;/a&gt; for the latest news, updates and changes.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/front-page-large.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/front-page-thumb.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/audit-log-large.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/audit-log-thumb.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/secret-url-languages-large.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/secret-url-languages-thumb.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/password-generator-large.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/password-generator-thumb.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/dark-theme.gif&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/dark-theme-thumb.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/preliminary-step.gif&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/app/frontend/img/features/preliminary-step-thumb.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Quickstart&lt;/h1&gt; &#xA;&lt;p&gt;‚Üí Go to &lt;a href=&#34;https://pwpush.com&#34;&gt;pwpush.com&lt;/a&gt; and try it out.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;or&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚Üí Run your own instance with one command: &lt;code&gt;docker run -d -p &#34;5100:5100&#34; pglombardo/pwpush-ephemeral:release&lt;/code&gt; then go to &lt;a href=&#34;http://localhost:5100&#34;&gt;http://localhost:5100&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;or&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;‚Üí Use one of the &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/#3rd-party-tools&#34;&gt;3rd party tools&lt;/a&gt; that interface with Password Pusher.&lt;/p&gt; &#xA;&lt;h1&gt;üíæ Run Your Own Instance&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: Password Pusher can be largely configured by environment variables so after you pick your deployment method below, make sure to read &lt;a href=&#34;https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/Configuration.md&#34;&gt;the configuration page&lt;/a&gt;. Take particular attention in setting your own custom encryption key which isn&#39;t required but provides the best security for your instance.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;On Docker&lt;/h2&gt; &#xA;&lt;p&gt;Docker images of Password Pusher are available on &lt;a href=&#34;https://hub.docker.com/u/pglombardo&#34;&gt;Docker hub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;‚ûú ephemeral&lt;/strong&gt; &lt;em&gt;Temporary database that is wiped on container restart.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -d -p &#34;5100:5100&#34; pglombardo/pwpush-ephemeral:release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/tree/master/containers/docker#pwpush-ephemeral&#34;&gt;Learn more&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;‚ûú using an External Postgres Database&lt;/strong&gt; &lt;em&gt;Postgres database backed instance.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -d -p &#34;5100:5100&#34; pglombardo/pwpush-postgres:release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/tree/master/containers/docker#pwpush-postgres&#34;&gt;Learn more&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;‚ûú using an External MariaDB (MySQL) Database&lt;/strong&gt; &lt;em&gt;Mariadb database backed instance.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -d -p &#34;5100:5100&#34; pglombardo/pwpush-mysql:release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/tree/master/containers/docker#pwpush-mysql&#34;&gt;Learn more&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: The &lt;code&gt;latest&lt;/code&gt; Docker container tag builds nightly off of the latest code changes and can occasionally be unstable. Always use the &lt;a href=&#34;https://hub.docker.com/repository/docker/pglombardo/pwpush-ephemeral/tags?page=1&amp;amp;ordering=last_updated&#34;&gt;&#39;release&#39; or version&#39;d tags&lt;/a&gt; if you prefer more stability in releases.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;With Docker Compose&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;‚ûú One-liner Password Pusher with a Postgres Database&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -s -o docker-compose.yml https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/containers/docker/pwpush-postgres/docker-compose.yaml &amp;amp;&amp;amp; docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;‚ûú One-liner Password Pusher with a MariaDB (MySQL) Database&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -s -o docker-compose.yml https://raw.githubusercontent.com/pglombardo/PasswordPusher/master/containers/docker/pwpush-mysql/docker-compose.yaml &amp;amp;&amp;amp; docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;On Kubernetes&lt;/h2&gt; &#xA;&lt;p&gt;Instructions and explanation of a Kubernetes setup &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/tree/master/containers/kubernetes&#34;&gt;can be found here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;On Microsoft Azure&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;There used to be a 3rd party blog post with instructions but it&#39;s been deleted. If anyone has instructions they would like to contribute, it would be greatly appreciated.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/issues/277&#34;&gt;issue #277&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;On OpenShift&lt;/h2&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/tree/master/containers/docker#pwpush-openshift&#34;&gt;OpenShift documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;On Heroku&lt;/h2&gt; &#xA;&lt;p&gt;One click deploy to &lt;a href=&#34;https://www.heroku.com&#34;&gt;Heroku Cloud&lt;/a&gt; without having to set up servers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://heroku.com/deploy?template=https://github.com/pglombardo/PasswordPusher&#34;&gt;&lt;img src=&#34;https://www.herokucdn.com/deploy/button.svg?sanitize=true&#34; alt=&#34;Deploy&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;This option will deploy a production Password Pusher instance backed by a postgres database to Heroku. Heroku used to offer free dynos but that is &lt;a href=&#34;https://blog.heroku.com/next-chapter&#34;&gt;no longer the case&lt;/a&gt; from November 28, 2022. Hosting charges will be incurred.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;From Source&lt;/h2&gt; &#xA;&lt;p&gt;Make sure you have git and Ruby installed and then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com:pglombardo/PasswordPusher.git&#xA;cd PasswordPusher&#xA;gem install bundler&#xA;bundle install --without development production test --deployment&#xA;bundle exec rake assets:precompile&#xA;RAILS_ENV=private ./bin/rake db:setup&#xA;./bin/rails server --environment=private&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then view the site @ &lt;a href=&#34;http://localhost:5100/&#34;&gt;http://localhost:5100/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;3rd Party Tools&lt;/h1&gt; &#xA;&lt;h2&gt;Command Line Utilities&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The almost official &lt;a href=&#34;https://github.com/pglombardo/pwpush-cli&#34;&gt;pwpush-cli&lt;/a&gt; (in pre-beta): CLI for Password Pusher with authentication support&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/pgarm/pwposh&#34;&gt;pgarm/pwposh&lt;/a&gt;: a PowerShell module available in the &lt;a href=&#34;https://www.powershellgallery.com/packages/PwPoSh/&#34;&gt;PowerShell Gallery&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kprocyszyn/tools/raw/master/Get-PasswordLink/Get-PasswordLink.ps1&#34;&gt;kprocyszyn/Get-PasswordLink.ps1&lt;/a&gt;: a PowerShell based CLI&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/lnfnunes/pwpush-cli&#34;&gt;lnfnunes/pwpush-cli&lt;/a&gt;: a Node.js based CLI&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/abkierstein/pwpush&#34;&gt;abkierstein/pwpush&lt;/a&gt;: a Python based CLI&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Libraries &amp;amp; APIs&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/oyale/PwPush-PHP&#34;&gt;oyale/PwPush-PHP&lt;/a&gt;: a PHP library wrapper to easily push passwords to any Password Pusher instance&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Android Apps&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://play.google.com/store/apps/details?id=com.chesire.pushie&#34;&gt;Pushie&lt;/a&gt; by &lt;a href=&#34;https://github.com/chesire&#34;&gt;chesire&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Application Integrations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/wiki/PasswordPusher-&amp;amp;-Slack:-Custom-Slash-Command&#34;&gt;Slack: How to Add a Custom Slash Command&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://forums.unraid.net/topic/104128-support-passwordpusher-pwpush-corneliousjd-repo/&#34;&gt;Unraid Application&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.packal.org/workflow/passwordpusher&#34;&gt;Alfred Workflow&lt;/a&gt; for Mac users&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;See also the &lt;a href=&#34;https://pwpush.com/en/pages/tools&#34;&gt;Tools Page on pwpush.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h1&gt;The Password Pusher API&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pwpush.com/api&#34;&gt;JSON API Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/wiki/Password-API&#34;&gt;Walkthrough &amp;amp; Examples&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Internationalization&lt;/h1&gt; &#xA;&lt;p&gt;Password Pusher is currently available in &lt;strong&gt;14 languages&lt;/strong&gt; with more languages being added often as volunteers apply.&lt;/p&gt; &#xA;&lt;p&gt;From within the application, the language is selectable from a language menu. Out of the box and before any language menu selection is done, the default language for the application is English.&lt;/p&gt; &#xA;&lt;h2&gt;Changing the Default Language&lt;/h2&gt; &#xA;&lt;p&gt;The default language can be changed by setting an environment variable with the appropriate language code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PWP__DEFAULT_LOCALE=es&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more details, a list of supported language codes and further explanation, see the bottom of this &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/raw/master/config/settings.yml&#34;&gt;configuration file&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;üõü Help Out&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pwpush.com&#34;&gt;pwpush.com&lt;/a&gt; is hosted on Digital Ocean and is happily paid out of pocket by myself for more than 10 years.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;But you could help out greatly&lt;/strong&gt; by signing up to Digital Ocean with &lt;a href=&#34;https://m.do.co/c/f4ea6ef24c13&#34;&gt;this link&lt;/a&gt; (and get $200 credit). In return, Password Pusher gets a helpful hosting credit.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;tldr;&lt;/strong&gt; Sign up to Digital Ocean &lt;a href=&#34;https://m.do.co/c/f4ea6ef24c13&#34;&gt;with this link&lt;/a&gt;, get $200 credit for free and help Password Pusher out.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.digitalocean.com/?refcode=f4ea6ef24c13&amp;amp;utm_campaign=Referral_Invite&amp;amp;utm_medium=Referral_Program&amp;amp;utm_source=badge&#34;&gt;&lt;img src=&#34;https://web-platforms.sfo2.cdn.digitaloceanspaces.com/WWW/Badge%201.svg?sanitize=true&#34; alt=&#34;DigitalOcean Referral Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;üìº Credits&lt;/h1&gt; &#xA;&lt;h2&gt;Translators&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to our great translators!&lt;/p&gt; &#xA;&lt;p&gt;If you would like to volunteer and assist in translating, see &lt;a href=&#34;https://pwpush.com/en/pages/translate&#34;&gt;this page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Catalan&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/oyale&#34;&gt;Oyale&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Danish&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Finn Skaaning&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;French&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/tibo59&#34;&gt;Thibaut&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;German&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Thomas W√∂lk: &lt;a href=&#34;https://github.com/confluencepoint/&#34;&gt;Github&lt;/a&gt; | &lt;a href=&#34;https://twitter.com/confluencepoint&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Martin Otto&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Norwegian&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Robin J√∏rgensen&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Polish&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/drpt&#34;&gt;≈Åukasz&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Portuguese&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/jairhenrique/&#34;&gt;Jair Henrique&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/ifabriciorodrigues/&#34;&gt;Fabr√≠cio Rodrigues&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/IvanMFreitas&#34;&gt;Ivan Freitas&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Sara Faria&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Spanish&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/oyale&#34;&gt;Oyale&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Swedish&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;johan323&lt;/li&gt; &#xA;   &lt;li&gt;Fredrik Arvas&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also thanks to &lt;a href=&#34;https://translation.io&#34;&gt;translation.io&lt;/a&gt; for their great service in managing translations. It&#39;s also generously free for opensource projects.&lt;/p&gt; &#xA;&lt;h2&gt;Containers&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/fiskhest&#34;&gt;@fiskhest&lt;/a&gt; the &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/tree/master/containers/kubernetes&#34;&gt;Kubernetes installation instructions and manifests&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/sfarosu&#34;&gt;@sfarosu&lt;/a&gt; for &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/pull/82&#34;&gt;contributing&lt;/a&gt; the Docker, Kubernetes &amp;amp; OpenShift container support.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/iandunn&#34;&gt;@iandunn&lt;/a&gt; for better password form security.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/kaspergrubbe&#34;&gt;Kasper &#39;kap√∂w&#39; Grubbe&lt;/a&gt; for the &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/pull/3&#34;&gt;JSON POST fix&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.reddit.com/user/JarvisAndPi&#34;&gt;JarvisAndPi&lt;/a&gt; for the favicon design&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;...and many more. See the &lt;a href=&#34;https://github.com/pglombardo/PasswordPusher/graphs/contributors&#34;&gt;Contributors page&lt;/a&gt; for more details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jeremyevans/sequel</title>
    <updated>2022-10-29T01:39:36Z</updated>
    <id>tag:github.com,2022-10-29:/jeremyevans/sequel</id>
    <link href="https://github.com/jeremyevans/sequel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Sequel: The Database Toolkit for Ruby&lt;/p&gt;&lt;hr&gt;&lt;p&gt;== Sequel: The Database Toolkit for Ruby&lt;/p&gt; &#xA;&lt;p&gt;Sequel is a simple, flexible, and powerful SQL database access toolkit for Ruby.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sequel provides thread safety, connection pooling and a concise DSL for constructing SQL queries and table schemas.&lt;/li&gt; &#xA; &lt;li&gt;Sequel includes a comprehensive ORM layer for mapping records to Ruby objects and handling associated records.&lt;/li&gt; &#xA; &lt;li&gt;Sequel supports advanced database features such as prepared statements, bound variables, savepoints, two-phase commit, transaction isolation, primary/replica configurations, and database sharding.&lt;/li&gt; &#xA; &lt;li&gt;Sequel currently has adapters for ADO, Amalgalite, IBM_DB, JDBC, MySQL, Mysql2, ODBC, Oracle, PostgreSQL, SQLAnywhere, SQLite3, and TinyTDS.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;== Resources&lt;/p&gt; &#xA;&lt;p&gt;Website :: &lt;a href=&#34;https://sequel.jeremyevans.net&#34;&gt;https://sequel.jeremyevans.net&lt;/a&gt; RDoc Documentation :: &lt;a href=&#34;https://sequel.jeremyevans.net/rdoc&#34;&gt;https://sequel.jeremyevans.net/rdoc&lt;/a&gt; Source Code :: &lt;a href=&#34;https://github.com/jeremyevans/sequel&#34;&gt;https://github.com/jeremyevans/sequel&lt;/a&gt; Bug tracking (GitHub Issues) :: &lt;a href=&#34;https://github.com/jeremyevans/sequel/issues&#34;&gt;https://github.com/jeremyevans/sequel/issues&lt;/a&gt; Discussion Forum (GitHub Discussions) :: &lt;a href=&#34;https://github.com/jeremyevans/sequel/discussions&#34;&gt;https://github.com/jeremyevans/sequel/discussions&lt;/a&gt; Alternate Discussion Forum (sequel-talk Google Group) :: &lt;a href=&#34;http://groups.google.com/group/sequel-talk&#34;&gt;http://groups.google.com/group/sequel-talk&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have questions about how to use Sequel, please ask on GitHub Discussions or the sequel-talk Google Group. Only use the the bug tracker to report bugs in Sequel, not to ask for help on using Sequel.&lt;/p&gt; &#xA;&lt;p&gt;To check out the source code:&lt;/p&gt; &#xA;&lt;p&gt;git clone git://github.com/jeremyevans/sequel.git&lt;/p&gt; &#xA;&lt;p&gt;=== Contact&lt;/p&gt; &#xA;&lt;p&gt;If you have any comments or suggestions please post to the Google group.&lt;/p&gt; &#xA;&lt;p&gt;== Installation&lt;/p&gt; &#xA;&lt;p&gt;gem install sequel&lt;/p&gt; &#xA;&lt;p&gt;== A Short Example&lt;/p&gt; &#xA;&lt;p&gt;require &#39;sequel&#39;&lt;/p&gt; &#xA;&lt;p&gt;DB = Sequel.sqlite # memory database, requires sqlite3&lt;/p&gt; &#xA;&lt;p&gt;DB.create_table :items do primary_key :id String :name Float :price end&lt;/p&gt; &#xA;&lt;p&gt;items = DB[:items] # Create a dataset&lt;/p&gt; &#xA;&lt;h1&gt;Populate the table&lt;/h1&gt; &#xA;&lt;p&gt;items.insert(name: &#39;abc&#39;, price: rand * 100) items.insert(name: &#39;def&#39;, price: rand * 100) items.insert(name: &#39;ghi&#39;, price: rand * 100)&lt;/p&gt; &#xA;&lt;h1&gt;Print out the number of records&lt;/h1&gt; &#xA;&lt;p&gt;puts &#34;Item count: #{items.count}&#34;&lt;/p&gt; &#xA;&lt;h1&gt;Print out the average price&lt;/h1&gt; &#xA;&lt;p&gt;puts &#34;The average price is: #{items.avg(:price)}&#34;&lt;/p&gt; &#xA;&lt;p&gt;== The Sequel Console&lt;/p&gt; &#xA;&lt;p&gt;Sequel includes an IRB console for quick access to databases (usually referred to as &lt;tt&gt;bin/sequel&lt;/tt&gt;). You can use it like this:&lt;/p&gt; &#xA;&lt;p&gt;sequel sqlite://test.db # test.db in current directory&lt;/p&gt; &#xA;&lt;p&gt;You get an IRB session with the Sequel::Database object stored in DB.&lt;/p&gt; &#xA;&lt;p&gt;In addition to providing an IRB shell (the default behavior), bin/sequel also has support for migrating databases, dumping schema migrations, and copying databases. See the {bin/sequel guide}[rdoc-ref:doc/bin_sequel.rdoc] for more details.&lt;/p&gt; &#xA;&lt;p&gt;== An Introduction&lt;/p&gt; &#xA;&lt;p&gt;Sequel is designed to take the hassle away from connecting to databases and manipulating them. Sequel deals with all the boring stuff like maintaining connections, formatting SQL correctly and fetching records so you can concentrate on your application.&lt;/p&gt; &#xA;&lt;p&gt;Sequel uses the concept of datasets to retrieve data. A Dataset object encapsulates an SQL query and supports chainability, letting you fetch data using a convenient Ruby DSL that is both concise and flexible.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following one-liner returns the average GDP for countries in the middle east region:&lt;/p&gt; &#xA;&lt;p&gt;DB[:countries].where(region: &#39;Middle East&#39;).avg(:GDP)&lt;/p&gt; &#xA;&lt;p&gt;Which is equivalent to:&lt;/p&gt; &#xA;&lt;p&gt;SELECT avg(GDP) FROM countries WHERE region = &#39;Middle East&#39;&lt;/p&gt; &#xA;&lt;p&gt;Since datasets retrieve records only when needed, they can be stored and later reused. Records are fetched as hashes, and are accessed using an +Enumerable+ interface:&lt;/p&gt; &#xA;&lt;p&gt;middle_east = DB[:countries].where(region: &#39;Middle East&#39;) middle_east.order(:name).each{|r| puts r[:name]}&lt;/p&gt; &#xA;&lt;p&gt;Sequel also offers convenience methods for extracting data from Datasets, such as an extended +map+ method:&lt;/p&gt; &#xA;&lt;p&gt;middle_east.map(:name) # =&amp;gt; [&#39;Egypt&#39;, &#39;Turkey&#39;, &#39;Israel&#39;, ...] middle_east.map([:id, :name]) # =&amp;gt; [[1, &#39;Egypt&#39;], [3, &#39;Turkey&#39;], [2, &#39;Israel&#39;], ...]&lt;/p&gt; &#xA;&lt;p&gt;Or getting results as a hash via +as_hash+, with one column as key and another as value:&lt;/p&gt; &#xA;&lt;p&gt;middle_east.as_hash(:name, :area) # =&amp;gt; {&#39;Israel&#39; =&amp;gt; 20000, &#39;Turkey&#39; =&amp;gt; 120000, ...}&lt;/p&gt; &#xA;&lt;p&gt;== Getting Started&lt;/p&gt; &#xA;&lt;p&gt;=== Connecting to a database&lt;/p&gt; &#xA;&lt;p&gt;To connect to a database you simply provide &lt;tt&gt;Sequel.connect&lt;/tt&gt; with a URL:&lt;/p&gt; &#xA;&lt;p&gt;require &#39;sequel&#39; DB = Sequel.connect(&#39;sqlite://blog.db&#39;) # requires sqlite3&lt;/p&gt; &#xA;&lt;p&gt;The connection URL can also include such stuff as the user name, password, and port:&lt;/p&gt; &#xA;&lt;p&gt;DB = Sequel.connect(&#39;postgres://user:password@host:port/database_name&#39;) # requires pg&lt;/p&gt; &#xA;&lt;p&gt;You can also specify optional parameters, such as the connection pool size, or loggers for logging SQL queries:&lt;/p&gt; &#xA;&lt;p&gt;DB = Sequel.connect(&#34;postgres://user:password@host:port/database_name&#34;, max_connections: 10, logger: Logger.new(&#39;log/db.log&#39;))&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to use a hash instead of a connection URL, but make sure to include the :adapter option in this case:&lt;/p&gt; &#xA;&lt;p&gt;DB = Sequel.connect(adapter: :postgres, user: &#39;user&#39;, password: &#39;password&#39;, host: &#39;host&#39;, port: port, database: &#39;database_name&#39;, max_connections: 10, logger: Logger.new(&#39;log/db.log&#39;))&lt;/p&gt; &#xA;&lt;p&gt;You can specify a block to connect, which will disconnect from the database after it completes:&lt;/p&gt; &#xA;&lt;p&gt;Sequel.connect(&#39;postgres://user:password@host:port/database_name&#39;){|db| db[:posts].delete}&lt;/p&gt; &#xA;&lt;p&gt;=== The DB convention&lt;/p&gt; &#xA;&lt;p&gt;Throughout Sequel&#39;s documentation, you will see the +DB+ constant used to refer to the Sequel::Database instance you create. This reflects the recommendation that for an app with a single Sequel::Database instance, the Sequel convention is to store the instance in the +DB+ constant. This is just a convention, it&#39;s not required, but it is recommended.&lt;/p&gt; &#xA;&lt;p&gt;Note that some frameworks that use Sequel may create the Sequel::Database instance for you, and you might not know how to access it. In most cases, you can access the Sequel::Database instance through &lt;tt&gt;Sequel::Model.db&lt;/tt&gt;.&lt;/p&gt; &#xA;&lt;p&gt;=== Arbitrary SQL queries&lt;/p&gt; &#xA;&lt;p&gt;You can execute arbitrary SQL code using &lt;tt&gt;Database#run&lt;/tt&gt;:&lt;/p&gt; &#xA;&lt;p&gt;DB.run(&#34;create table t (a text, b text)&#34;) DB.run(&#34;insert into t values (&#39;a&#39;, &#39;b&#39;)&#34;)&lt;/p&gt; &#xA;&lt;p&gt;You can also create datasets based on raw SQL:&lt;/p&gt; &#xA;&lt;p&gt;dataset = DB[&#39;select id from items&#39;] dataset.count # will return the number of records in the result set dataset.map(:id) # will return an array containing all values of the id column in the result set&lt;/p&gt; &#xA;&lt;p&gt;You can also fetch records with raw SQL through the dataset:&lt;/p&gt; &#xA;&lt;p&gt;DB[&#39;select * from items&#39;].each do |row| p row end&lt;/p&gt; &#xA;&lt;p&gt;You can use placeholders in your SQL string as well:&lt;/p&gt; &#xA;&lt;p&gt;name = &#39;Jim&#39; DB[&#39;select * from items where name = ?&#39;, name].each do |row| p row end&lt;/p&gt; &#xA;&lt;p&gt;=== Getting Dataset Instances&lt;/p&gt; &#xA;&lt;p&gt;Datasets are the primary way records are retrieved and manipulated. They are generally created via the &lt;tt&gt;Database#from&lt;/tt&gt; or &lt;tt&gt;Database#[]&lt;/tt&gt; methods:&lt;/p&gt; &#xA;&lt;p&gt;posts = DB.from(:posts) posts = DB[:posts] # same&lt;/p&gt; &#xA;&lt;p&gt;Datasets will only fetch records when you tell them to. They can be manipulated to filter records, change ordering, join tables, etc. Datasets are always frozen, and they are safe to use by multiple threads concurrently.&lt;/p&gt; &#xA;&lt;p&gt;=== Retrieving Records&lt;/p&gt; &#xA;&lt;p&gt;You can retrieve all records by using the +all+ method:&lt;/p&gt; &#xA;&lt;p&gt;posts.all&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts&lt;/h1&gt; &#xA;&lt;p&gt;The +all+ method returns an array of hashes, where each hash corresponds to a record.&lt;/p&gt; &#xA;&lt;p&gt;You can also iterate through records one at a time using +each+:&lt;/p&gt; &#xA;&lt;p&gt;posts.each{|row| p row}&lt;/p&gt; &#xA;&lt;p&gt;Or perform more advanced stuff:&lt;/p&gt; &#xA;&lt;p&gt;names_and_dates = posts.map([:name, :date]) old_posts, recent_posts = posts.partition{|r| r[:date] &amp;lt; Date.today - 7}&lt;/p&gt; &#xA;&lt;p&gt;You can also retrieve the first record in a dataset:&lt;/p&gt; &#xA;&lt;p&gt;posts.order(:id).first&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts ORDER BY id LIMIT 1&lt;/h1&gt; &#xA;&lt;p&gt;Note that you can get the first record in a dataset even if it isn&#39;t ordered:&lt;/p&gt; &#xA;&lt;p&gt;posts.first&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts LIMIT 1&lt;/h1&gt; &#xA;&lt;p&gt;If the dataset is ordered, you can also ask for the last record:&lt;/p&gt; &#xA;&lt;p&gt;posts.order(:stamp).last&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts ORDER BY stamp DESC LIMIT 1&lt;/h1&gt; &#xA;&lt;p&gt;You can also provide a filter when asking for a single record:&lt;/p&gt; &#xA;&lt;p&gt;posts.first(id: 1)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts WHERE id = 1 LIMIT 1&lt;/h1&gt; &#xA;&lt;p&gt;Or retrieve a single value for a specific record:&lt;/p&gt; &#xA;&lt;p&gt;posts.where(id: 1).get(:name)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT name FROM posts WHERE id = 1 LIMIT 1&lt;/h1&gt; &#xA;&lt;p&gt;=== Filtering Records&lt;/p&gt; &#xA;&lt;p&gt;The most common way to filter records is to provide a hash of values to match to +where+:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.where(category: &#39;ruby&#39;, author: &#39;david&#39;)&lt;/p&gt; &#xA;&lt;h1&gt;WHERE ((category = &#39;ruby&#39;) AND (author = &#39;david&#39;))&lt;/h1&gt; &#xA;&lt;p&gt;You can also specify ranges:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.where(stamp: (Date.today - 14)..(Date.today - 7))&lt;/p&gt; &#xA;&lt;h1&gt;WHERE ((stamp &amp;gt;= &#39;2010-06-30&#39;) AND (stamp &amp;lt;= &#39;2010-07-07&#39;))&lt;/h1&gt; &#xA;&lt;p&gt;Or arrays of values:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.where(category: [&#39;ruby&#39;, &#39;postgres&#39;, &#39;linux&#39;])&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (category IN (&#39;ruby&#39;, &#39;postgres&#39;, &#39;linux&#39;))&lt;/h1&gt; &#xA;&lt;p&gt;By passing a block to where, you can use expressions (this is fairly &#34;magical&#34;):&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.where{stamp &amp;gt; Date.today &amp;lt;&amp;lt; 1}&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (stamp &amp;gt; &#39;2010-06-14&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;my_posts = posts.where{stamp =~ Date.today}&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (stamp = &#39;2010-07-14&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;If you want to wrap the objects yourself, you can use expressions without the &#34;magic&#34;:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.where(Sequel[:stamp] &amp;gt; Date.today &amp;lt;&amp;lt; 1)&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (stamp &amp;gt; &#39;2010-06-14&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;my_posts = posts.where(Sequel[:stamp] =~ Date.today)&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (stamp = &#39;2010-07-14&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;Some databases such as PostgreSQL and MySQL also support filtering via Regexps:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.where(category: /ruby/i)&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (category ~* &#39;ruby&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;You can also use an inverse filter via +exclude+:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.exclude(category: [&#39;ruby&#39;, &#39;postgres&#39;, &#39;linux&#39;])&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (category NOT IN (&#39;ruby&#39;, &#39;postgres&#39;, &#39;linux&#39;))&lt;/h1&gt; &#xA;&lt;p&gt;But note that this does a full inversion of the filter:&lt;/p&gt; &#xA;&lt;p&gt;my_posts = posts.exclude(category: [&#39;ruby&#39;, &#39;postgres&#39;, &#39;linux&#39;], id: 1)&lt;/p&gt; &#xA;&lt;h1&gt;WHERE ((category NOT IN (&#39;ruby&#39;, &#39;postgres&#39;, &#39;linux&#39;)) OR (id != 1))&lt;/h1&gt; &#xA;&lt;p&gt;If at any point you want to use a custom SQL fragment for part of a query, you can do so via +Sequel.lit+:&lt;/p&gt; &#xA;&lt;p&gt;posts.where(Sequel.lit(&#39;stamp IS NOT NULL&#39;))&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (stamp IS NOT NULL)&lt;/h1&gt; &#xA;&lt;p&gt;You can safely interpolate parameters into the custom SQL fragment by providing them as additional arguments:&lt;/p&gt; &#xA;&lt;p&gt;author_name = &#39;JKR&#39; posts.where(Sequel.lit(&#39;(stamp &amp;lt; ?) AND (author != ?)&#39;, Date.today - 3, author_name))&lt;/p&gt; &#xA;&lt;h1&gt;WHERE ((stamp &amp;lt; &#39;2010-07-11&#39;) AND (author != &#39;JKR&#39;))&lt;/h1&gt; &#xA;&lt;p&gt;Datasets can also be used as subqueries:&lt;/p&gt; &#xA;&lt;p&gt;DB[:items].where(Sequel[:price] &amp;gt; DB[:items].select{avg(price) + 100})&lt;/p&gt; &#xA;&lt;h1&gt;WHERE (price &amp;gt; (SELECT avg(price) + 100 FROM items))&lt;/h1&gt; &#xA;&lt;p&gt;After filtering, you can retrieve the matching records by using any of the retrieval methods:&lt;/p&gt; &#xA;&lt;p&gt;my_posts.each{|row| p row}&lt;/p&gt; &#xA;&lt;p&gt;See the {Dataset Filtering}[rdoc-ref:doc/dataset_filtering.rdoc] file for more details.&lt;/p&gt; &#xA;&lt;p&gt;=== Security&lt;/p&gt; &#xA;&lt;p&gt;Designing apps with security in mind is a best practice. Please read the {Security Guide}[rdoc-ref:doc/security.rdoc] for details on security issues that you should be aware of when using Sequel.&lt;/p&gt; &#xA;&lt;p&gt;=== Summarizing Records&lt;/p&gt; &#xA;&lt;p&gt;Counting records is easy using +count+:&lt;/p&gt; &#xA;&lt;p&gt;posts.where(Sequel.like(:category, &#39;%ruby%&#39;)).count&lt;/p&gt; &#xA;&lt;h1&gt;SELECT COUNT(*) FROM posts WHERE (category LIKE &#39;%ruby%&#39; ESCAPE &#39;&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;And you can also query maximum/minimum values via +max+ and +min+:&lt;/p&gt; &#xA;&lt;p&gt;max = DB[:history].max(:value)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT max(value) FROM history&lt;/h1&gt; &#xA;&lt;p&gt;min = DB[:history].min(:value)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT min(value) FROM history&lt;/h1&gt; &#xA;&lt;p&gt;Or calculate a sum or average via +sum+ and +avg+:&lt;/p&gt; &#xA;&lt;p&gt;sum = DB[:items].sum(:price)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT sum(price) FROM items&lt;/h1&gt; &#xA;&lt;p&gt;avg = DB[:items].avg(:price)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT avg(price) FROM items&lt;/h1&gt; &#xA;&lt;p&gt;=== Ordering Records&lt;/p&gt; &#xA;&lt;p&gt;Ordering datasets is simple using +order+:&lt;/p&gt; &#xA;&lt;p&gt;posts.order(:stamp)&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY stamp&lt;/h1&gt; &#xA;&lt;p&gt;posts.order(:stamp, :name)&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY stamp, name&lt;/h1&gt; &#xA;&lt;p&gt;+order+ always overrides the existing order:&lt;/p&gt; &#xA;&lt;p&gt;posts.order(:stamp).order(:name)&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY name&lt;/h1&gt; &#xA;&lt;p&gt;If you would like to add to the existing order, use +order_append+ or +order_prepend+:&lt;/p&gt; &#xA;&lt;p&gt;posts.order(:stamp).order_append(:name)&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY stamp, name&lt;/h1&gt; &#xA;&lt;p&gt;posts.order(:stamp).order_prepend(:name)&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY name, stamp&lt;/h1&gt; &#xA;&lt;p&gt;You can also specify descending order:&lt;/p&gt; &#xA;&lt;p&gt;posts.reverse_order(:stamp)&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY stamp DESC&lt;/h1&gt; &#xA;&lt;p&gt;posts.order(Sequel.desc(:stamp))&lt;/p&gt; &#xA;&lt;h1&gt;ORDER BY stamp DESC&lt;/h1&gt; &#xA;&lt;p&gt;=== Core Extensions&lt;/p&gt; &#xA;&lt;p&gt;Note the use of &lt;tt&gt;Sequel.desc(:stamp)&lt;/tt&gt; in the above example. Much of Sequel&#39;s DSL uses this style, calling methods on the Sequel module that return SQL expression objects. Sequel also ships with a {core_extensions extension}[rdoc-ref:doc/core_extensions.rdoc] that integrates Sequel&#39;s DSL better into the Ruby language, allowing you to write:&lt;/p&gt; &#xA;&lt;p&gt;:stamp.desc&lt;/p&gt; &#xA;&lt;p&gt;instead of:&lt;/p&gt; &#xA;&lt;p&gt;Sequel.desc(:stamp)&lt;/p&gt; &#xA;&lt;p&gt;=== Selecting Columns&lt;/p&gt; &#xA;&lt;p&gt;Selecting specific columns to be returned is also simple using +select+:&lt;/p&gt; &#xA;&lt;p&gt;posts.select(:stamp)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT stamp FROM posts&lt;/h1&gt; &#xA;&lt;p&gt;posts.select(:stamp, :name)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT stamp, name FROM posts&lt;/h1&gt; &#xA;&lt;p&gt;Like +order+, +select+ overrides an existing selection:&lt;/p&gt; &#xA;&lt;p&gt;posts.select(:stamp).select(:name)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT name FROM posts&lt;/h1&gt; &#xA;&lt;p&gt;As you might expect, there is an +order_append+ equivalent for +select+ called +select_append+:&lt;/p&gt; &#xA;&lt;p&gt;posts.select(:stamp).select_append(:name)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT stamp, name FROM posts&lt;/h1&gt; &#xA;&lt;p&gt;=== Deleting Records&lt;/p&gt; &#xA;&lt;p&gt;Deleting records from the table is done with +delete+:&lt;/p&gt; &#xA;&lt;p&gt;posts.where(Sequel[:stamp] &amp;lt; Date.today - 3).delete&lt;/p&gt; &#xA;&lt;h1&gt;DELETE FROM posts WHERE (stamp &amp;lt; &#39;2010-07-11&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;Be very careful when deleting, as +delete+ affects all rows in the dataset. Call +where+ first and +delete+ second:&lt;/p&gt; &#xA;&lt;h1&gt;DO THIS:&lt;/h1&gt; &#xA;&lt;p&gt;posts.where(Sequel[:stamp] &amp;lt; Date.today - 7).delete&lt;/p&gt; &#xA;&lt;h1&gt;NOT THIS:&lt;/h1&gt; &#xA;&lt;p&gt;posts.delete.where(Sequel[:stamp] &amp;lt; Date.today - 7)&lt;/p&gt; &#xA;&lt;p&gt;=== Inserting Records&lt;/p&gt; &#xA;&lt;p&gt;Inserting records into the table is done with +insert+:&lt;/p&gt; &#xA;&lt;p&gt;posts.insert(category: &#39;ruby&#39;, author: &#39;david&#39;)&lt;/p&gt; &#xA;&lt;h1&gt;INSERT INTO posts (category, author) VALUES (&#39;ruby&#39;, &#39;david&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;=== Updating Records&lt;/p&gt; &#xA;&lt;p&gt;Updating records in the table is done with +update+:&lt;/p&gt; &#xA;&lt;p&gt;posts.where(Sequel[:stamp] &amp;lt; Date.today - 7).update(state: &#39;archived&#39;)&lt;/p&gt; &#xA;&lt;h1&gt;UPDATE posts SET state = &#39;archived&#39; WHERE (stamp &amp;lt; &#39;2010-07-07&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;You can provide arbitrary expressions when choosing what values to set:&lt;/p&gt; &#xA;&lt;p&gt;posts.where(Sequel[:stamp] &amp;lt; Date.today - 7).update(backup_number: Sequel[:backup_number] + 1)&lt;/p&gt; &#xA;&lt;h1&gt;UPDATE posts SET backup_number = (backup_number + 1) WHERE (stamp &amp;lt; &#39;2010-07-07&#39;))))&lt;/h1&gt; &#xA;&lt;p&gt;As with +delete+, +update+ affects all rows in the dataset, so +where+ first, +update+ second:&lt;/p&gt; &#xA;&lt;h1&gt;DO THIS:&lt;/h1&gt; &#xA;&lt;p&gt;posts.where(Sequel[:stamp] &amp;lt; Date.today - 7).update(state: &#39;archived&#39;)&lt;/p&gt; &#xA;&lt;h1&gt;NOT THIS:&lt;/h1&gt; &#xA;&lt;p&gt;posts.update(state: &#39;archived&#39;).where(Sequel[:stamp] &amp;lt; Date.today - 7)&lt;/p&gt; &#xA;&lt;p&gt;=== Merging records&lt;/p&gt; &#xA;&lt;p&gt;Merging records using the SQL MERGE statement is done using &lt;tt&gt;merge*&lt;/tt&gt; methods. You use +merge_using+ to specify the merge source and join conditions. You can use +merge_insert+, +merge_delete+, and/or +merge_update+ to set the INSERT, DELETE, and UPDATE clauses for the merge. +merge_insert+ takes the same arguments as +insert+, and +merge_update+ takes the same arguments as +update+. +merge_insert+, +merge_delete+, and +merge_update+ can all be called with blocks, to set the conditions for the related INSERT, DELETE, or UPDATE.&lt;/p&gt; &#xA;&lt;p&gt;Finally, after calling all of the other &lt;tt&gt;merge_*&lt;/tt&gt; methods, you call +merge+ to run the MERGE statement on the database.&lt;/p&gt; &#xA;&lt;p&gt;ds = DB[:m1] merge_using(:m2, i1: :i2). merge_insert(i1: :i2, a: Sequel[:b]+11). merge_delete{a &amp;gt; 30}. merge_update(i1: Sequel[:i1]+:i2+10, a: Sequel[:a]+:b+20)&lt;/p&gt; &#xA;&lt;p&gt;ds.merge&lt;/p&gt; &#xA;&lt;h1&gt;MERGE INTO m1 USING m2 ON (i1 = i2)&lt;/h1&gt; &#xA;&lt;h1&gt;WHEN NOT MATCHED THEN INSERT (i1, a) VALUES (i2, (b + 11))&lt;/h1&gt; &#xA;&lt;h1&gt;WHEN MATCHED AND (a &amp;gt; 30) THEN DELETE&lt;/h1&gt; &#xA;&lt;h1&gt;WHEN MATCHED THEN UPDATE SET i1 = (i1 + i2 + 10), a = (a + b + 20)&lt;/h1&gt; &#xA;&lt;p&gt;=== Transactions&lt;/p&gt; &#xA;&lt;p&gt;You can wrap a block of code in a database transaction using the &lt;tt&gt;Database#transaction&lt;/tt&gt; method:&lt;/p&gt; &#xA;&lt;p&gt;DB.transaction do # BEGIN posts.insert(category: &#39;ruby&#39;, author: &#39;david&#39;) # INSERT posts.where(Sequel[:stamp] &amp;lt; Date.today - 7).update(state: &#39;archived&#39;) # UPDATE end&lt;/p&gt; &#xA;&lt;h1&gt;COMMIT&lt;/h1&gt; &#xA;&lt;p&gt;If the block does not raise an exception, the transaction will be committed. If the block does raise an exception, the transaction will be rolled back, and the exception will be reraised. If you want to rollback the transaction and not raise an exception outside the block, you can raise the &lt;tt&gt;Sequel::Rollback&lt;/tt&gt; exception inside the block:&lt;/p&gt; &#xA;&lt;p&gt;DB.transaction do # BEGIN posts.insert(category: &#39;ruby&#39;, author: &#39;david&#39;) # INSERT if posts.where(&#39;stamp &amp;lt; ?&#39;, Date.today - 7).update(state: &#39;archived&#39;) == 0 # UPDATE raise Sequel::Rollback end end&lt;/p&gt; &#xA;&lt;h1&gt;ROLLBACK&lt;/h1&gt; &#xA;&lt;p&gt;=== Joining Tables&lt;/p&gt; &#xA;&lt;p&gt;Sequel makes it easy to join tables:&lt;/p&gt; &#xA;&lt;p&gt;order_items = DB[:items].join(:order_items, item_id: :id).where(order_id: 1234)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM items&lt;/h1&gt; &#xA;&lt;h1&gt;INNER JOIN order_items ON (order_items.item_id = items.id)&lt;/h1&gt; &#xA;&lt;h1&gt;WHERE (order_id = 1234)&lt;/h1&gt; &#xA;&lt;p&gt;The important thing to note here is that item_id is automatically qualified with the table being joined, and id is automatically qualified with the last table joined.&lt;/p&gt; &#xA;&lt;p&gt;You can then do anything you like with the dataset:&lt;/p&gt; &#xA;&lt;p&gt;order_total = order_items.sum(:price)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT sum(price) FROM items&lt;/h1&gt; &#xA;&lt;h1&gt;INNER JOIN order_items ON (order_items.item_id = items.id)&lt;/h1&gt; &#xA;&lt;h1&gt;WHERE (order_id = 1234)&lt;/h1&gt; &#xA;&lt;p&gt;Note that the default selection in Sequel is &lt;tt&gt;*&lt;/tt&gt;, which includes all columns in all joined tables. Because Sequel returns results as a hash keyed by column name symbols, if any tables have columns with the same name, this will clobber the columns in the returned hash. So when joining you are usually going to want to change the selection using +select+, +select_all+, and/or +select_append+.&lt;/p&gt; &#xA;&lt;p&gt;== Column references in Sequel&lt;/p&gt; &#xA;&lt;p&gt;Sequel expects column names to be specified using symbols. In addition, returned hashes always use symbols as their keys. This allows you to freely mix literal values and column references in many cases. For example, the two following lines produce equivalent SQL:&lt;/p&gt; &#xA;&lt;p&gt;items.where(x: 1)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM items WHERE (x = 1)&lt;/h1&gt; &#xA;&lt;p&gt;items.where(1 =&amp;gt; :x)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM items WHERE (1 = x)&#34;&lt;/h1&gt; &#xA;&lt;p&gt;Ruby strings are generally treated as SQL strings:&lt;/p&gt; &#xA;&lt;p&gt;items.where(x: &#39;x&#39;)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM items WHERE (x = &#39;x&#39;)&lt;/h1&gt; &#xA;&lt;p&gt;=== Qualifying identifiers (column/table names)&lt;/p&gt; &#xA;&lt;p&gt;An identifier in SQL is a name that represents a column, table, or schema. The recommended way to qualify columns is to use &lt;tt&gt;Sequel[][]&lt;/tt&gt; or +Sequel.qualify+&lt;/p&gt; &#xA;&lt;p&gt;Sequel[:table][:column] Sequel.qualify(:table, :column)&lt;/p&gt; &#xA;&lt;h1&gt;table.column&lt;/h1&gt; &#xA;&lt;p&gt;You can also qualify tables with schemas:&lt;/p&gt; &#xA;&lt;p&gt;Sequel[:schema][:table]&lt;/p&gt; &#xA;&lt;h1&gt;schema.table&lt;/h1&gt; &#xA;&lt;p&gt;or use multi-level qualification:&lt;/p&gt; &#xA;&lt;p&gt;Sequel[:schema][:table][:column]&lt;/p&gt; &#xA;&lt;h1&gt;schema.table.column&lt;/h1&gt; &#xA;&lt;p&gt;=== Expression aliases&lt;/p&gt; &#xA;&lt;p&gt;You can alias identifiers using &lt;tt&gt;Sequel[].as&lt;/tt&gt; or +Sequel.as+:&lt;/p&gt; &#xA;&lt;p&gt;Sequel[:column].as(:alias) Sequel.as(:column, :alias)&lt;/p&gt; &#xA;&lt;h1&gt;column AS alias&lt;/h1&gt; &#xA;&lt;p&gt;You can use the &lt;tt&gt;Sequel.as&lt;/tt&gt; method to alias arbitrary expressions, not just identifiers:&lt;/p&gt; &#xA;&lt;p&gt;Sequel.as(DB[:posts].select{max(id)}, :p)&lt;/p&gt; &#xA;&lt;h1&gt;(SELECT max(id) FROM posts) AS p&lt;/h1&gt; &#xA;&lt;p&gt;And most Sequel expression objects support an +as+ method for aliasing:&lt;/p&gt; &#xA;&lt;p&gt;(Sequel[:column] + 2).as(:c_plus_2)&lt;/p&gt; &#xA;&lt;h1&gt;(column + 2) AS c_plus_2&lt;/h1&gt; &#xA;&lt;p&gt;== Sequel Models&lt;/p&gt; &#xA;&lt;p&gt;A model class wraps a dataset, and an instance of that class wraps a single record in the dataset.&lt;/p&gt; &#xA;&lt;p&gt;Model classes are defined as regular Ruby classes inheriting from &lt;tt&gt;Sequel::Model&lt;/tt&gt;:&lt;/p&gt; &#xA;&lt;p&gt;DB = Sequel.connect(&#39;sqlite://blog.db&#39;) class Post &amp;lt; Sequel::Model end&lt;/p&gt; &#xA;&lt;p&gt;When a model class is created, it parses the schema in the table from the database, and automatically sets up accessor methods for all of the columns in the table (Sequel::Model implements the active record pattern).&lt;/p&gt; &#xA;&lt;p&gt;Sequel model classes assume that the table name is an underscored plural of the class name:&lt;/p&gt; &#xA;&lt;p&gt;Post.table_name # =&amp;gt; :posts&lt;/p&gt; &#xA;&lt;p&gt;You can explicitly set the table name or even the dataset used:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model(:my_posts); end&lt;/p&gt; &#xA;&lt;h1&gt;or:&lt;/h1&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model(DB[:my_posts]); end&lt;/p&gt; &#xA;&lt;p&gt;If you pass a symbol to the &lt;tt&gt;Sequel::Model&lt;/tt&gt; method, it assumes you are referring to the table with the same name. You can also call it with a dataset, which will set the defaults for all retrievals for that model:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model(DB[:my_posts].where(category: &#39;ruby&#39;)); end class Post &amp;lt; Sequel::Model(DB[:my_posts].select(:id, :name).order(:date)); end&lt;/p&gt; &#xA;&lt;p&gt;=== Model instances&lt;/p&gt; &#xA;&lt;p&gt;Model instances are identified by a primary key. Sequel queries the database to determine the primary key for each model. The &lt;tt&gt;Model.[]&lt;/tt&gt; method can be used to fetch records by their primary key:&lt;/p&gt; &#xA;&lt;p&gt;post = Post[123]&lt;/p&gt; &#xA;&lt;p&gt;The +pk+ method is used to retrieve the record&#39;s primary key value:&lt;/p&gt; &#xA;&lt;p&gt;post.pk # =&amp;gt; 123&lt;/p&gt; &#xA;&lt;p&gt;If you want to override which column(s) to use as the primary key, you can use +set_primary_key+:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model set_primary_key [:category, :title] end&lt;/p&gt; &#xA;&lt;p&gt;post = Post[&#39;ruby&#39;, &#39;hello world&#39;] post.pk # =&amp;gt; [&#39;ruby&#39;, &#39;hello world&#39;]&lt;/p&gt; &#xA;&lt;p&gt;You can also define a model class that does not have a primary key via +no_primary_key+, but then you lose the ability to easily update and delete records:&lt;/p&gt; &#xA;&lt;p&gt;Post.no_primary_key&lt;/p&gt; &#xA;&lt;p&gt;A single model instance can also be fetched by specifying a condition:&lt;/p&gt; &#xA;&lt;p&gt;post = Post.first(title: &#39;hello world&#39;) post = Post.first{num_comments &amp;lt; 10}&lt;/p&gt; &#xA;&lt;p&gt;The dataset for a model class returns rows of model instances instead of plain hashes:&lt;/p&gt; &#xA;&lt;p&gt;DB[:posts].first.class # =&amp;gt; Hash Post.first.class # =&amp;gt; Post&lt;/p&gt; &#xA;&lt;p&gt;=== Acts like a dataset&lt;/p&gt; &#xA;&lt;p&gt;A model class forwards many methods to the underlying dataset. This means that you can use most of the +Dataset+ API to create customized queries that return model instances, e.g.:&lt;/p&gt; &#xA;&lt;p&gt;Post.where(category: &#39;ruby&#39;).each{|post| p post}&lt;/p&gt; &#xA;&lt;p&gt;You can also manipulate the records in the dataset:&lt;/p&gt; &#xA;&lt;p&gt;Post.where{num_comments &amp;lt; 7}.delete Post.where(Sequel.like(:title, /ruby/)).update(category: &#39;ruby&#39;)&lt;/p&gt; &#xA;&lt;p&gt;=== Accessing record values&lt;/p&gt; &#xA;&lt;p&gt;A model instance stores its values as a hash with column symbol keys, which you can access directly via the +values+ method:&lt;/p&gt; &#xA;&lt;p&gt;post.values # =&amp;gt; {:id =&amp;gt; 123, :category =&amp;gt; &#39;ruby&#39;, :title =&amp;gt; &#39;hello world&#39;}&lt;/p&gt; &#xA;&lt;p&gt;You can read the record values as object attributes, assuming the attribute names are valid columns in the model&#39;s dataset:&lt;/p&gt; &#xA;&lt;p&gt;post.id # =&amp;gt; 123 post.title # =&amp;gt; &#39;hello world&#39;&lt;/p&gt; &#xA;&lt;p&gt;If the record&#39;s attributes names are not valid columns in the model&#39;s dataset (maybe because you used +select_append+ to add a computed value column), you can use &lt;tt&gt;Model#[]&lt;/tt&gt; to access the values:&lt;/p&gt; &#xA;&lt;p&gt;post[:id] # =&amp;gt; 123 post[:title] # =&amp;gt; &#39;hello world&#39;&lt;/p&gt; &#xA;&lt;p&gt;You can also modify record values using attribute setters or the &lt;tt&gt;[]=&lt;/tt&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;post.title = &#39;hey there&#39; post[:title] = &#39;hey there&#39;&lt;/p&gt; &#xA;&lt;p&gt;That will just change the value for the object, it will not update the row in the database. To update the database row, call the +save+ method:&lt;/p&gt; &#xA;&lt;p&gt;post.save&lt;/p&gt; &#xA;&lt;p&gt;=== Mass assignment&lt;/p&gt; &#xA;&lt;p&gt;You can also set the values for multiple columns in a single method call, using one of the mass-assignment methods. See the {mass assignment guide}[rdoc-ref:doc/mass_assignment.rdoc] for details. For example +set+ updates the model&#39;s column values without saving:&lt;/p&gt; &#xA;&lt;p&gt;post.set(title: &#39;hey there&#39;, updated_by: &#39;foo&#39;)&lt;/p&gt; &#xA;&lt;p&gt;and +update+ updates the model&#39;s column values and then saves the changes to the database:&lt;/p&gt; &#xA;&lt;p&gt;post.update(title: &#39;hey there&#39;, updated_by: &#39;foo&#39;)&lt;/p&gt; &#xA;&lt;p&gt;=== Creating new records&lt;/p&gt; &#xA;&lt;p&gt;New model instances can be created by calling &lt;tt&gt;Model.new&lt;/tt&gt;, which returns a new model instance without updating the database:&lt;/p&gt; &#xA;&lt;p&gt;post = Post.new(title: &#39;hello world&#39;)&lt;/p&gt; &#xA;&lt;p&gt;You can save the record to the database later by calling +save+ on the model instance:&lt;/p&gt; &#xA;&lt;p&gt;post.save&lt;/p&gt; &#xA;&lt;p&gt;If you want to create a new record and save it to the database at the same time, you can use &lt;tt&gt;Model.create&lt;/tt&gt;:&lt;/p&gt; &#xA;&lt;p&gt;post = Post.create(title: &#39;hello world&#39;)&lt;/p&gt; &#xA;&lt;p&gt;You can also supply a block to &lt;tt&gt;Model.new&lt;/tt&gt; and &lt;tt&gt;Model.create&lt;/tt&gt;:&lt;/p&gt; &#xA;&lt;p&gt;post = Post.new do |p| p.title = &#39;hello world&#39; end&lt;/p&gt; &#xA;&lt;p&gt;post = Post.create{|p| p.title = &#39;hello world&#39;}&lt;/p&gt; &#xA;&lt;p&gt;=== Hooks&lt;/p&gt; &#xA;&lt;p&gt;You can execute custom code when creating, updating, or deleting records by defining hook methods. The +before_create+ and +after_create+ hook methods wrap record creation. The +before_update+ and +after_update+ hook methods wrap record updating. The +before_save+ and +after_save+ hook methods wrap record creation and updating. The +before_destroy+ and +after_destroy+ hook methods wrap destruction. The +before_validation+ and +after_validation+ hook methods wrap validation. Example:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model def after_create super author.increase_post_count end&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def after_destroy&#xA;  super&#xA;  author.decrease_post_count&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;end&lt;/p&gt; &#xA;&lt;p&gt;Note the use of +super+ if you define your own hook methods. Almost all &lt;tt&gt;Sequel::Model&lt;/tt&gt; class and instance methods (not just hook methods) can be overridden safely, but you have to make sure to call +super+ when doing so, otherwise you risk breaking things.&lt;/p&gt; &#xA;&lt;p&gt;For the example above, you should probably use a database trigger if you can. Hooks can be used for data integrity, but they will only enforce that integrity when you are modifying the database through model instances, and even then they are often subject to race conditions. It&#39;s best to use database triggers and database constraints to enforce data integrity.&lt;/p&gt; &#xA;&lt;p&gt;=== Deleting records&lt;/p&gt; &#xA;&lt;p&gt;You can delete individual records by calling +delete+ or +destroy+. The only difference between the two methods is that +destroy+ invokes +before_destroy+ and +after_destroy+ hook methods, while +delete+ does not:&lt;/p&gt; &#xA;&lt;p&gt;post.delete # =&amp;gt; bypasses hooks post.destroy # =&amp;gt; runs hooks&lt;/p&gt; &#xA;&lt;p&gt;Records can also be deleted en-masse by calling &lt;tt&gt;delete&lt;/tt&gt; and &lt;tt&gt;destroy&lt;/tt&gt; on the model&#39;s dataset. As stated above, you can specify filters for the deleted records:&lt;/p&gt; &#xA;&lt;p&gt;Post.where(category: 32).delete # =&amp;gt; bypasses hooks Post.where(category: 32).destroy # =&amp;gt; runs hooks&lt;/p&gt; &#xA;&lt;p&gt;Please note that if &lt;tt&gt;destroy&lt;/tt&gt; is called, each record is deleted separately, but &lt;tt&gt;delete&lt;/tt&gt; deletes all matching records with a single SQL query.&lt;/p&gt; &#xA;&lt;p&gt;=== Associations&lt;/p&gt; &#xA;&lt;p&gt;Associations are used in order to specify relationships between model classes that reflect relationships between tables in the database, which are usually specified using foreign keys. You specify model associations via class methods:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model many_to_one :author one_to_many :comments one_to_one :first_comment, class: :Comment, order: :id many_to_many :tags one_through_one :first_tag, class: :Tag, order: :name, right_key: :tag_id end&lt;/p&gt; &#xA;&lt;p&gt;+many_to_one+ and +one_to_one+ create a getter and setter for each model object:&lt;/p&gt; &#xA;&lt;p&gt;post = Post.create(name: &#39;hi!&#39;) post.author = Author.first(name: &#39;Sharon&#39;) post.author&lt;/p&gt; &#xA;&lt;p&gt;+one_to_many+ and +many_to_many+ create a getter method, a method for adding an object to the association, a method for removing an object from the association, and a method for removing all associated objects from the association:&lt;/p&gt; &#xA;&lt;p&gt;post = Post.create(name: &#39;hi!&#39;) post.comments&lt;/p&gt; &#xA;&lt;p&gt;comment = Comment.create(text: &#39;hi&#39;) post.add_comment(comment) post.remove_comment(comment) post.remove_all_comments&lt;/p&gt; &#xA;&lt;p&gt;tag = Tag.create(tag: &#39;interesting&#39;) post.add_tag(tag) post.remove_tag(tag) post.remove_all_tags&lt;/p&gt; &#xA;&lt;p&gt;Note that the remove_* and remove_all_* methods do not delete the object from the database, they merely disassociate the associated object from the receiver.&lt;/p&gt; &#xA;&lt;p&gt;All associations add a dataset method that can be used to further filter or reorder the returned objects, or modify all of them:&lt;/p&gt; &#xA;&lt;h1&gt;Delete all of this post&#39;s comments from the database&lt;/h1&gt; &#xA;&lt;p&gt;post.comments_dataset.destroy&lt;/p&gt; &#xA;&lt;h1&gt;Return all tags related to this post with no subscribers, ordered by the tag&#39;s name&lt;/h1&gt; &#xA;&lt;p&gt;post.tags_dataset.where(subscribers: 0).order(:name).all&lt;/p&gt; &#xA;&lt;p&gt;=== Eager Loading&lt;/p&gt; &#xA;&lt;p&gt;Associations can be eagerly loaded via +eager+ and the &lt;tt&gt;:eager&lt;/tt&gt; association option. Eager loading is used when loading a group of objects. It loads all associated objects for all of the current objects in one query, instead of using a separate query to get the associated objects for each current object. Eager loading requires that you retrieve all model objects at once via +all+ (instead of individually by +each+). Eager loading can be cascaded, loading association&#39;s associated objects.&lt;/p&gt; &#xA;&lt;p&gt;class Person &amp;lt; Sequel::Model one_to_many :posts, eager: [:tags] end&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model many_to_one :person one_to_many :replies many_to_many :tags end&lt;/p&gt; &#xA;&lt;p&gt;class Tag &amp;lt; Sequel::Model many_to_many :posts many_to_many :replies end&lt;/p&gt; &#xA;&lt;p&gt;class Reply &amp;lt; Sequel::Model many_to_one :person many_to_one :post many_to_many :tags end&lt;/p&gt; &#xA;&lt;h1&gt;Eager loading via .eager&lt;/h1&gt; &#xA;&lt;p&gt;Post.eager(:person).all&lt;/p&gt; &#xA;&lt;h1&gt;eager is a dataset method, so it works with filters/orders/limits/etc.&lt;/h1&gt; &#xA;&lt;p&gt;Post.where{topic &amp;gt; &#39;M&#39;}.order(:date).limit(5).eager(:person).all&lt;/p&gt; &#xA;&lt;p&gt;person = Person.first&lt;/p&gt; &#xA;&lt;h1&gt;Eager loading via :eager (will eagerly load the tags for this person&#39;s posts)&lt;/h1&gt; &#xA;&lt;p&gt;person.posts&lt;/p&gt; &#xA;&lt;h1&gt;These are equivalent&lt;/h1&gt; &#xA;&lt;p&gt;Post.eager(:person, :tags).all Post.eager(:person).eager(:tags).all&lt;/p&gt; &#xA;&lt;h1&gt;Cascading via .eager&lt;/h1&gt; &#xA;&lt;p&gt;Tag.eager(posts: :replies).all&lt;/p&gt; &#xA;&lt;h1&gt;Will also grab all associated posts&#39; tags (because of :eager)&lt;/h1&gt; &#xA;&lt;p&gt;Reply.eager(person: :posts).all&lt;/p&gt; &#xA;&lt;h1&gt;No depth limit (other than memory/stack), and will also grab posts&#39; tags&lt;/h1&gt; &#xA;&lt;h1&gt;Loads all people, their posts, their posts&#39; tags, replies to those posts,&lt;/h1&gt; &#xA;&lt;h1&gt;the person for each reply, the tag for each reply, and all posts and&lt;/h1&gt; &#xA;&lt;h1&gt;replies that have that tag. Uses a total of 8 queries.&lt;/h1&gt; &#xA;&lt;p&gt;Person.eager(posts: {replies: [:person, {tags: [:posts, :replies]}]}).all&lt;/p&gt; &#xA;&lt;p&gt;In addition to using +eager+, you can also use +eager_graph+, which will use a single query to get the object and all associated objects. This may be necessary if you want to filter or order the result set based on columns in associated tables. It works with cascading as well, the API is similar. Note that using +eager_graph+ to eagerly load multiple &lt;tt&gt;*_to_many&lt;/tt&gt; associations will cause the result set to be a cartesian product, so you should be very careful with your filters when using it in that case.&lt;/p&gt; &#xA;&lt;p&gt;You can dynamically customize the eagerly loaded dataset by using a proc. This proc is passed the dataset used for eager loading, and should return a modified copy of that dataset:&lt;/p&gt; &#xA;&lt;h1&gt;Eagerly load only replies containing &#39;foo&#39;&lt;/h1&gt; &#xA;&lt;p&gt;Post.eager(replies: proc{|ds| ds.where(Sequel.like(text, &#39;%foo%&#39;))}).all&lt;/p&gt; &#xA;&lt;p&gt;This also works when using +eager_graph+, in which case the proc is called with dataset to graph into the current dataset:&lt;/p&gt; &#xA;&lt;p&gt;Post.eager_graph(replies: proc{|ds| ds.where(Sequel.like(text, &#39;%foo%&#39;))}).all&lt;/p&gt; &#xA;&lt;p&gt;You can dynamically customize eager loads for both +eager+ and +eager_graph+ while also cascading, by making the value a single entry hash with the proc as a key, and the cascaded associations as the value:&lt;/p&gt; &#xA;&lt;h1&gt;Eagerly load only replies containing &#39;foo&#39;, and the person and tags for those replies&lt;/h1&gt; &#xA;&lt;p&gt;Post.eager(replies: {proc{|ds| ds.where(Sequel.like(text, &#39;%foo%&#39;))} =&amp;gt; [:person, :tags]}).all&lt;/p&gt; &#xA;&lt;p&gt;=== Joining with Associations&lt;/p&gt; &#xA;&lt;p&gt;You can use the +association_join+ method to add a join to the model&#39;s dataset based on the assocation:&lt;/p&gt; &#xA;&lt;p&gt;Post.association_join(:author)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts&lt;/h1&gt; &#xA;&lt;h1&gt;INNER JOIN authors AS author ON (author.id = posts.author_id)&lt;/h1&gt; &#xA;&lt;p&gt;This comes with variants for different join types:&lt;/p&gt; &#xA;&lt;p&gt;Post.association_left_join(:replies)&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts&lt;/h1&gt; &#xA;&lt;h1&gt;LEFT JOIN replies ON (replies.post_id = posts.id)&lt;/h1&gt; &#xA;&lt;p&gt;Similar to the eager loading methods, you can use multiple associations and nested associations:&lt;/p&gt; &#xA;&lt;p&gt;Post.association_join(:author, replies: :person).all&lt;/p&gt; &#xA;&lt;h1&gt;SELECT * FROM posts&lt;/h1&gt; &#xA;&lt;h1&gt;INNER JOIN authors AS author ON (author.id = posts.author_id)&lt;/h1&gt; &#xA;&lt;h1&gt;INNER JOIN replies ON (replies.post_id = posts.id)&lt;/h1&gt; &#xA;&lt;h1&gt;INNER JOIN people AS person ON (person.id = replies.person_id)&lt;/h1&gt; &#xA;&lt;p&gt;=== Extending the underlying dataset&lt;/p&gt; &#xA;&lt;p&gt;The recommended way to implement table-wide logic by defining methods on the dataset using +dataset_module+:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model dataset_module do def with_few_comments where{num_comments &amp;lt; 30} end&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  def clean_boring&#xA;    with_few_comments.delete&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;end&lt;/p&gt; &#xA;&lt;p&gt;This allows you to have access to your model API from filtered datasets as well:&lt;/p&gt; &#xA;&lt;p&gt;Post.where(category: &#39;ruby&#39;).clean_boring&lt;/p&gt; &#xA;&lt;h1&gt;DELETE FROM posts WHERE ((category = &#39;ruby&#39;) AND (num_comments &amp;lt; 30))&lt;/h1&gt; &#xA;&lt;p&gt;Inside +dataset_module+ blocks, there are numerous methods that support easy creation of dataset methods. Most of these methods are named after the dataset methods themselves, such as +select+, +order+, and +group+:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model dataset_module do where(:with_few_comments, Sequel[:num_comments] &amp;lt; 30) select :with_title_and_date, :id, :title, :post_date order :by_post_date, :post_date limit :top10, 10 end end&lt;/p&gt; &#xA;&lt;p&gt;Post.with_few_comments.with_title_and_date.by_post_date.top10&lt;/p&gt; &#xA;&lt;h1&gt;SELECT id, title, post_date&lt;/h1&gt; &#xA;&lt;h1&gt;FROM posts&lt;/h1&gt; &#xA;&lt;h1&gt;ORDER BY post_date&lt;/h1&gt; &#xA;&lt;h1&gt;LIMIT 10&lt;/h1&gt; &#xA;&lt;p&gt;One advantage of using these methods inside dataset_module blocks, instead of defining methods manually, is that the created methods will generally cache the resulting values and result in better performance.&lt;/p&gt; &#xA;&lt;p&gt;=== Model Validations&lt;/p&gt; &#xA;&lt;p&gt;You can define a +validate+ method for your model, which +save+ will check before attempting to save the model in the database. If an attribute of the model isn&#39;t valid, you should add an error message for that attribute to the model object&#39;s +errors+. If an object has any errors added by the validate method, +save+ will raise an error by default:&lt;/p&gt; &#xA;&lt;p&gt;class Post &amp;lt; Sequel::Model def validate super errors.add(:name, &#34;can&#39;t be empty&#34;) if name.empty? errors.add(:written_on, &#34;should be in the past&#34;) if written_on &amp;gt;= Time.now end end&lt;/p&gt; &#xA;&lt;p&gt;== Testing Sequel&lt;/p&gt; &#xA;&lt;p&gt;Please see the {testing guide}[rdoc-ref:doc/testing.rdoc] for recommendations on testing applications that use Sequel, as well as the how to run the tests for Sequel itself.&lt;/p&gt; &#xA;&lt;p&gt;== Sequel Release Policy&lt;/p&gt; &#xA;&lt;p&gt;New major versions of Sequel do not have a defined release policy, but historically have occurred once every few years.&lt;/p&gt; &#xA;&lt;p&gt;New minor versions of Sequel are released around once a month near the start of the month.&lt;/p&gt; &#xA;&lt;p&gt;New tiny versions of Sequel are only released to address security issues or regressions in the most current release.&lt;/p&gt; &#xA;&lt;p&gt;== Ruby Support Policy&lt;/p&gt; &#xA;&lt;p&gt;Sequel fully supports the currently supported versions of Ruby (MRI) and JRuby. It may support unsupported versions of Ruby or JRuby, but such support may be dropped in any minor version if keeping it becomes a support issue. The minimum Ruby version required to run the current version of Sequel is 1.9.2, and the minimum JRuby version is 9.0.0.0.&lt;/p&gt; &#xA;&lt;p&gt;== Maintainer&lt;/p&gt; &#xA;&lt;p&gt;Jeremy Evans &lt;a href=&#34;mailto:code@jeremyevans.net&#34;&gt;code@jeremyevans.net&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>