<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-11T01:38:19Z</updated>
  <subtitle>Daily Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tric/trick2022</title>
    <updated>2022-09-11T01:38:19Z</updated>
    <id>tag:github.com,2022-09-11:/tric/trick2022</id>
    <link href="https://github.com/tric/trick2022" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TRICK 2022 (Returns)&lt;/h1&gt; &#xA;&lt;p&gt;The 4th (Returns) Transcendental Ruby Imbroglio Contest for rubyKaigi&lt;/p&gt; &#xA;&lt;h2&gt;Winners&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Top 3&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Gold: &#34;Best fishbowl&#34; -- Tomoya Ishida (tompng)&lt;/li&gt; &#xA;   &lt;li&gt;Silver: &#34;Most interactive code&#34; -- Tomoya Ishida (tompng)&lt;/li&gt; &#xA;   &lt;li&gt;Bronze: &#34;Most anti-gravity&#34; -- Yusuke Endoh&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Judges&#39; awards&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;shinh award: &#34;Most orderly code&#34; -- Tomoya Ishida&lt;/li&gt; &#xA;   &lt;li&gt;leonid award: &#34;Most accessible&#34; -- Yutaka HARA&lt;/li&gt; &#xA;   &lt;li&gt;eto award: &#34;Most global&#34; -- Yusuke Endoh&lt;/li&gt; &#xA;   &lt;li&gt;matz award: &#34;Most reactive and diffusive&#34; -- Sergey Kruk&lt;/li&gt; &#xA;   &lt;li&gt;fragitious award: &#34;Most likely to be required&#34; -- Yutaka HARA&lt;/li&gt; &#xA;   &lt;li&gt;yhara award: &#34;Most playable&#34; â€“ Don Yang&lt;/li&gt; &#xA;   &lt;li&gt;mame award: &#34;Most calculating&#34; -- SAITOH Jinroq&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Goals of the TRICK&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To write the most Transcendental, Imbroglio Ruby program.&lt;/li&gt; &#xA; &lt;li&gt;To illustrate some of the subtleties (and design issues) of Ruby.&lt;/li&gt; &#xA; &lt;li&gt;To show the robustness and portability of Ruby interpreters.&lt;/li&gt; &#xA; &lt;li&gt;To stabilize the spec of Ruby by the presence of valuable but unmaintainable code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Rules&lt;/h2&gt; &#xA;&lt;p&gt;These rules are tentative.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Your entry must be a complete Ruby program.&lt;/li&gt; &#xA; &lt;li&gt;The size of your program must be &amp;lt;= 4096 bytes in length. The number of non-space characters must be &amp;lt;= 2048. The total size of your compressed submission must be less than ten megabyte in size.&lt;/li&gt; &#xA; &lt;li&gt;You can submit multiple entries, and your team may consist of any number of members.&lt;/li&gt; &#xA; &lt;li&gt;The entirety of your entry must be submitted under &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Your entry must bring the judges a surprise, excitement, and/or laughter.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Guidelines&lt;/h2&gt; &#xA;&lt;p&gt;These are not strict rules but hints or suggestions. You can ignore them but we&#39;d recommend you to follow them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Matz Ruby Implementation (MRI) 3.1 is recommended.&lt;/li&gt; &#xA; &lt;li&gt;You can use implementations other than MRI, such as JRuby and Rubinius.&lt;/li&gt; &#xA; &lt;li&gt;The judges would prefer more stoic, more portable, and/or more funny entries.&lt;/li&gt; &#xA; &lt;li&gt;You are encouraged to study the winners of &lt;a href=&#34;https://github.com/tric/&#34;&gt;previous TRICK contests&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;You can use a gem library. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Note that we will expect such entries to be much more interesting than an entry that uses no library; hence we will judge them strictly.&lt;/li&gt; &#xA;   &lt;li&gt;It is highly discouraged to abuse gem to get around the size limit.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;To judge without bias, we will try to keep each entry anonymous during judgment. Do not include anything that reveal your identity (such as a signature, copyright, URL, etc.) in your program.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to submit&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Your submission must consist of the following files: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;entry.rb&lt;/code&gt; (program source)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;remarks.markdown&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;authors.markdown&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Gemfile&lt;/code&gt;, &lt;code&gt;Gemfile.lock&lt;/code&gt; (if you use any gem library)&lt;/li&gt; &#xA;   &lt;li&gt;data files (if needed)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;remarks.markdown&lt;/code&gt; must include the following information: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ruby implementation, version, platform that you use (it is a good idea to copy and paste the output of &lt;code&gt;ruby -v&lt;/code&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;How to run&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;authors.markdown&lt;/code&gt; must include the following information (and the &lt;code&gt;remarks.markdown&lt;/code&gt; must NOT have them): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Your name (handle is ok)&lt;/li&gt; &#xA;   &lt;li&gt;ccTLD of your country/region&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Compress your entry as a zip file called &lt;code&gt;entry.zip&lt;/code&gt; and send it to &lt;code&gt;trick.submit at gmail.com&lt;/code&gt; as an attachment. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You must include the words &lt;code&gt;TRICK 2022 submission&lt;/code&gt; in the subject of your email.&lt;/li&gt; &#xA;   &lt;li&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/tric/trick2022/master/entry.zip&#34;&gt;an example of &lt;code&gt;entry.zip&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you have any question, please send a mail to &lt;code&gt;trick-judges at googlegroups.com&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Important Dates&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;9th Sep. 2021: Contest open&lt;/li&gt; &#xA; &lt;li&gt;31st Jul. 2022: Submission deadline &lt;em&gt;Now closed&lt;/em&gt;. We have been sent a receipt email to every applicant. If you do not receive a receipt email, please let me know (&lt;code&gt;trick.submit at gmail.com&lt;/code&gt; or &lt;a href=&#34;https://twitter.com/mametter&#34;&gt;@mametter&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;8th Sep. 2022: Result announcement (at RubyKaigi 2022)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Judges&lt;/h2&gt; &#xA;&lt;p&gt;Alphabetical order.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Yusuke Endoh (&lt;a href=&#34;https://twitter.com/mametter&#34;&gt;@mametter&lt;/a&gt;. Ruby committer. &lt;a href=&#34;http://www.ioccc.org/winners.html#Yusuke_Endoh&#34;&gt;The world&#39;s No.1 IOCCC player&lt;/a&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;Koichiro Eto (&lt;a href=&#34;https://twitter.com/eto&#34;&gt;@eto&lt;/a&gt;. Media Artist. &lt;a href=&#34;http://niconicogakkai.jp/&#34;&gt;Chairman at NicoNicoGakkai Beta&lt;/a&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;Shinichiro Hamaji (&lt;a href=&#34;https://twitter.com/shinh&#34;&gt;@shinh&lt;/a&gt;. &lt;a href=&#34;http://golf.shinh.org/&#34;&gt;The admin of anarchy golf&lt;/a&gt;. &lt;a href=&#34;http://www.ioccc.org/winners.html#Shinichiro_Hamaji&#34;&gt;IOCCC winner&lt;/a&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;Yutaka Hara (&lt;a href=&#34;https://twitter.com/yhara&#34;&gt;@yhara&lt;/a&gt;. &lt;a href=&#34;http://esolang-book.route477.net/&#34;&gt;The author of Japanese esolang book&lt;/a&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;Yukihiro Matsumoto (a.k.a. matz. &lt;a href=&#34;https://twitter.com/yukihiro_matz&#34;&gt;@yukihiro_matz&lt;/a&gt;. The creator of Ruby.)&lt;/li&gt; &#xA; &lt;li&gt;Sun Park (a.k.a. leonid. &lt;a href=&#34;http://golf.shinh.org/u.rb?rb&#34;&gt;The 1st super Ruby golfer&lt;/a&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;Darren Smith (a.k.a. flagitious. &lt;a href=&#34;http://www.golfscript.com/&#34;&gt;The author of some esolangs including GolfScript&lt;/a&gt;.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Legal&lt;/h2&gt; &#xA;&lt;p&gt;This work is licensed under the MIT License.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright (c) 2022, TRICK Winners and Judges.&#xA;&#xA;Permission is hereby granted, free of charge, to any person obtaining a copy&#xA;of this software and associated documentation files (the &#34;Software&#34;), to deal&#xA;in the Software without restriction, including without limitation the rights&#xA;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#xA;copies of the Software, and to permit persons to whom the Software is&#xA;furnished to do so, subject to the following conditions:&#xA;&#xA;The above copyright notice and this permission notice shall be included in&#xA;all copies or substantial portions of the Software.&#xA;&#xA;THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#xA;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#xA;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#xA;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#xA;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#xA;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#xA;THE SOFTWARE.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>rouge-ruby/rouge</title>
    <updated>2022-09-11T01:38:19Z</updated>
    <id>tag:github.com,2022-09-11:/rouge-ruby/rouge</id>
    <link href="https://github.com/rouge-ruby/rouge" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A pure Ruby code highlighter that is compatible with Pygments&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rouge&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rouge-ruby/rouge/actions/workflows/ruby.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt; &lt;a href=&#34;https://rubygems.org/gems/rouge&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/rouge.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://rouge-ruby.github.io/docs/&#34;&gt;&lt;img src=&#34;http://img.shields.io/badge/yard-docs-blue.svg?sanitize=true&#34; alt=&#34;YARD Docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://rouge.jneen.net/&#34; title=&#34;Rouge&#34;&gt;Rouge&lt;/a&gt; is a pure Ruby syntax highlighter. It can highlight &lt;a href=&#34;https://raw.githubusercontent.com/rouge-ruby/rouge/master/docs/Languages.md&#34; title=&#34;Languages&#34;&gt;over 200 different languages&lt;/a&gt;, and output HTML or ANSI 256-color text. Its HTML output is compatible with stylesheets designed for &lt;a href=&#34;http://pygments.org&#34; title=&#34;Pygments&#34;&gt;Pygments&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;In your Gemfile, add:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;rouge&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gem install rouge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Rouge&#39;s most common uses are as a Ruby library, as part of Jekyll and as a command line tool.&lt;/p&gt; &#xA;&lt;h3&gt;Library&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s a quick example of using Rouge as you would any other regular Ruby library:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;rouge&#39;&#xA;&#xA;# make some nice lexed html&#xA;source = File.read(&#39;/etc/bashrc&#39;)&#xA;formatter = Rouge::Formatters::HTML.new&#xA;lexer = Rouge::Lexers::Shell.new&#xA;formatter.format(lexer.lex(source))&#xA;&#xA;# Get some CSS&#xA;Rouge::Themes::Base16.mode(:light).render(scope: &#39;.highlight&#39;)&#xA;# Or use Theme#find with string input&#xA;Rouge::Theme.find(&#39;base16.light&#39;).render(scope: &#39;.highlight&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Jekyll&lt;/h3&gt; &#xA;&lt;p&gt;Rouge is Jekyll&#39;s default syntax highlighter. Out of the box, Rouge will be used to highlight text wrapped in the &lt;code&gt;{% highlight %}&lt;/code&gt; template tags. The &lt;code&gt;{% highlight %}&lt;/code&gt; tag provides minimal options: you can specify the language to use and whether to enable line numbers or not. More information is available in &lt;a href=&#34;https://jekyllrb.com/docs/liquid/tags/#code-snippet-highlighting&#34; title=&#34;Code snippet highlighting in the Jekyll documentation&#34;&gt;the Jekyll docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Command Line&lt;/h3&gt; &#xA;&lt;p&gt;Rouge ships with a &lt;code&gt;rougify&lt;/code&gt; command which allows you to easily highlight files in your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rougify foo.rb&#xA;rougify style monokai.sublime &amp;gt; syntax.css&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;Formatters&lt;/h3&gt; &#xA;&lt;p&gt;Rouge comes with a number of formatters built-in but as of Rouge 2.0, you are encouraged to write your own formatter if you need something custom.&lt;/p&gt; &#xA;&lt;p&gt;The built-in formatters are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTML.new&lt;/code&gt; will render your code with standard class names for tokens, with no div-wrapping or other bells or whistles.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLInline.new(theme)&lt;/code&gt; will render your code with no class names, but instead inline the styling options into the &lt;code&gt;style=&lt;/code&gt; attribute. This is good for emails and other systems where CSS support is minimal.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLLinewise.new(formatter, class: &#39;line-%i&#39;)&lt;/code&gt; will split your code into lines, each contained in its own div. The &lt;code&gt;class&lt;/code&gt; option will be used to add a class name to the div, given the line number.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLLineHighlighter.new(formatter, highlight_lines: [3, 5])&lt;/code&gt; will split your code into lines and wrap the lines specified by the &lt;code&gt;highlight_lines&lt;/code&gt; option in a span with a class name specified by the &lt;code&gt;highlight_line_class&lt;/code&gt; option (default: &lt;code&gt;hll&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLLineTable.new(formatter, opts={})&lt;/code&gt; will output an HTML table containing numbered lines, each contained in its own table-row. Options are:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;start_line: 1&lt;/code&gt; - the number of the first row&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;line_id: &#39;line-%i&#39;&lt;/code&gt; - a &lt;code&gt;sprintf&lt;/code&gt; template for &lt;code&gt;id&lt;/code&gt; attribute with current line number&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;line_class: &#39;lineno&#39;&lt;/code&gt; - a CSS class for each table-row&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;table_class: &#39;rouge-line-table&#39;&lt;/code&gt; - a CSS class for the table&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;gutter_class: &#39;rouge-gutter&#39;&lt;/code&gt; - a CSS class for the line-number cell&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;code_class: &#39;rouge-code&#39;&lt;/code&gt; - a CSS class for the code cell&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLPygments.new(formatter, css_class=&#39;codehilite&#39;)&lt;/code&gt; wraps the given formatter with div wrappers generally expected by stylesheets designed for Pygments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLTable.new(formatter, opts={})&lt;/code&gt; will output an HTML table containing numbered lines similar to &lt;code&gt;Rouge::Formatters::HTMLLineTable&lt;/code&gt;, except that the table from this formatter has just a single table-row. Therefore, while the table is more DOM-friendly for JavaScript scripting, long code lines will mess with the column alignment. Options are:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;start_line: 1&lt;/code&gt; - the number of the first line&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;line_format: &#39;%i&#39;&lt;/code&gt; - a &lt;code&gt;sprintf&lt;/code&gt; template for the line number itself&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;table_class: &#39;rouge-table&#39;&lt;/code&gt; - a CSS class for the table&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;gutter_class: &#39;rouge-gutter&#39;&lt;/code&gt; - a CSS class for the gutter&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;code_class: &#39;rouge-code&#39;&lt;/code&gt; - a CSS class for the code column&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::HTMLLegacy.new(opts={})&lt;/code&gt; is a backwards-compatibility class intended for users of Rouge 1.x, with options that were supported then. Options are:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;inline_theme: nil&lt;/code&gt; - use an HTMLInline formatter with the given theme&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;line_numbers: false&lt;/code&gt; - use an HTMLTable formatter&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;wrap: true&lt;/code&gt; - use an HTMLPygments wrapper&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;css_class: &#39;codehilite&#39;&lt;/code&gt; - a CSS class to use for the Pygments wrapper&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Rouge::Formatters::Terminal256.new(theme)&lt;/code&gt; is a formatter for generating highlighted text for use in the terminal. &lt;code&gt;theme&lt;/code&gt; must be an instance of &lt;code&gt;Rouge::Theme&lt;/code&gt;, or a &lt;code&gt;Hash&lt;/code&gt; structure with &lt;code&gt;:theme&lt;/code&gt; entry.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Writing your own HTML formatter&lt;/h4&gt; &#xA;&lt;p&gt;If the above formatters are not sufficient, and you wish to customize the layout of the HTML document, we suggest writing your own HTML formatter. This can be accomplished by subclassing &lt;code&gt;Rouge::Formatters::HTML&lt;/code&gt; and overriding specific methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyFormatter &amp;lt; Rouge::Formatters::HTML&#xA;&#xA;  # this is the main entry method. override this to customize the behavior of&#xA;  # the HTML blob as a whole. it should receive an Enumerable of (token, value)&#xA;  # pairs and yield out fragments of the resulting html string. see the docs&#xA;  # for the methods available on Token.&#xA;  def stream(tokens, &amp;amp;block)&#xA;    yield &#34;&amp;lt;div class=&#39;my-outer-div&#39;&amp;gt;&#34;&#xA;&#xA;    tokens.each do |token, value|&#xA;      # for every token in the output, we render a span&#xA;      yield span(token, value)&#xA;    end&#xA;&#xA;    yield &#34;&amp;lt;/div&amp;gt;&#34;&#xA;  end&#xA;&#xA;  # or, if you need linewise processing, try:&#xA;  def stream(tokens, &amp;amp;block)&#xA;    token_lines(tokens).each do |line_tokens|&#xA;      yield &#34;&amp;lt;div class=&#39;my-cool-line&#39;&amp;gt;&#34;&#xA;      line_tokens.each do |token, value|&#xA;        yield span(token, value)&#xA;      end&#xA;      yield &#34;&amp;lt;/div&amp;gt;&#34;&#xA;    end&#xA;  end&#xA;&#xA;  # Override this method to control how individual spans are rendered.&#xA;  # The value `safe_value` will already be HTML-escaped.&#xA;  def safe_span(token, safe_value)&#xA;    # in this case, &#34;text&#34; tokens don&#39;t get surrounded by a span&#xA;    if token == Token::Tokens::Text&#xA;      safe_value&#xA;    else&#xA;      &#34;&amp;lt;span class=\&#34;#{token.shortname}\&#34;&amp;gt;#{safe_value}&amp;lt;/span&amp;gt;&#34;&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lexer Options&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;debug: false&lt;/code&gt; will print a trace of the lex on stdout.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;parent: &#39;&#39;&lt;/code&gt; allows you to specify which language the template is inside.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;CSS Options&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;scope: &#39;.highlight&#39;&lt;/code&gt; sets the CSS selector to which styles are applied, e.g.:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Rouge::Themes::MonokaiSublime.render(scope: &#39;code&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Rouge&#39;s documentation is available at &lt;a href=&#34;https://rouge-ruby.github.io/docs&#34; title=&#34;Rouge&#39;s official documentation&#34;&gt;rouge-ruby.github.io/docs/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;h3&gt;Ruby&lt;/h3&gt; &#xA;&lt;p&gt;Rouge is compatible with all versions of Ruby from 2.0.0 onwards. It has no external dependencies.&lt;/p&gt; &#xA;&lt;h3&gt;Encodings&lt;/h3&gt; &#xA;&lt;p&gt;Rouge only supports UTF-8 strings. If you&#39;d like to highlight a string with a different encoding, please convert it to UTF-8 first.&lt;/p&gt; &#xA;&lt;h2&gt;Integrations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Middleman: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/middleman/middleman-syntax&#34;&gt;middleman-syntax&lt;/a&gt; (@bhollis)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Linuus/middleman-rouge&#34;&gt;middleman-rouge&lt;/a&gt; (@Linuus)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;RDoc: &lt;a href=&#34;https://github.com/zzak/rdoc-rouge&#34;&gt;rdoc-rouge&lt;/a&gt; (@zzak)&lt;/li&gt; &#xA; &lt;li&gt;Rails: &lt;a href=&#34;https://github.com/jacobsimeon/rouge-rails&#34;&gt;Rouge::Rails&lt;/a&gt; (@jacobsimeon)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re always excited to welcome new contributors to Rouge. By it&#39;s nature, a syntax highlighter relies for its success on submissions from users of the languages being highlighted. You can help Rouge by filing bug reports or developing new lexers.&lt;/p&gt; &#xA;&lt;h3&gt;Bug Reports&lt;/h3&gt; &#xA;&lt;p&gt;Rouge uses GitHub&#39;s Issues to report bugs. You can &lt;a href=&#34;https://github.com/rouge-ruby/rouge/issues/new/choose&#34; title=&#34;Choose an issue from the templates&#34;&gt;choose&lt;/a&gt; from one of our templates or create a custom issue. Issues that have not been active for a year are automatically closed by GitHub&#39;s &lt;a href=&#34;https://probot.github.io&#34; title=&#34;Read more about GitHub&#39;s Probot&#34;&gt;Probot&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Developing Lexers&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Please don&#39;t submit lexers that are copy-pasted from other files. These submission will be rejected and we don&#39;t want you to waste your time.&lt;/p&gt; &#xA;&lt;p&gt;We want to make it as easy as we can for anyone to contribute a lexer to Rouge. To help get you started, we have &lt;a href=&#34;https://rouge-ruby.github.io/docs/file.LexerDevelopment.html&#34; title=&#34;Rouge&#39;s lexer development guide&#34;&gt;a shiny new guide&lt;/a&gt; on lexer development in the documentation. The best place is to start there.&lt;/p&gt; &#xA;&lt;p&gt;If you get stuck and need help, submit a pull request with what you have and make it clear in your submission that the lexer isn&#39;t finished yet. We&#39;ll do our best to answer any questions you have and sometimes the best way to do that is with actual code.&lt;/p&gt; &#xA;&lt;h3&gt;Testing Rouge&lt;/h3&gt; &#xA;&lt;p&gt;Once you&#39;ve cloned the repository from GitHub, you can test the core of Rouge simply by running &lt;code&gt;rake&lt;/code&gt; (no &lt;code&gt;bundle exec&lt;/code&gt; required). You can also run a single test file by setting the &lt;code&gt;TEST&lt;/code&gt; environment variable to the path of the desired test. For example, to test just the &lt;em&gt;&lt;code&gt;ruby&lt;/code&gt; lexer&lt;/em&gt; (located at path &lt;code&gt;spec/lexers/ruby_spec.rb&lt;/code&gt;) simply run the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;TEST=spec/lexers/ruby_spec.rb rake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To test a lexer visually, run &lt;code&gt;rackup&lt;/code&gt; from the top-level working directory and you should have a web server running and ready to go. Visit &lt;a href=&#34;http://localhost:9292&#34;&gt;http://localhost:9292&lt;/a&gt; to see the full list of Rouge&#39;s lexers.&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;ve selected a particular lexer, you can add &lt;code&gt;?debug=1&lt;/code&gt; to your URL string to see a lot of helpful debugging info printed on stdout.&lt;/p&gt; &#xA;&lt;h2&gt;Versioning&lt;/h2&gt; &#xA;&lt;p&gt;Rouge uses &lt;a href=&#34;http://semver.org/&#34;&gt;Semantic Versioning 2.0.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;p&gt;Rouge is largely the result of the hard work of unpaid volunteers. It was originally developed by Jeanine Adkisson (@jneen) and is currently maintained by Jeanine Adkisson, Drew Blessing (@dblessing), Goro Fuji (@gfx) and Tan Le (@tancnle).&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Rouge is released under the MIT license. Please see the &lt;code&gt;LICENSE&lt;/code&gt; file for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>justinhoward/cutoff</title>
    <updated>2022-09-11T01:38:19Z</updated>
    <id>tag:github.com,2022-09-11:/justinhoward/cutoff</id>
    <link href="https://github.com/justinhoward/cutoff" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Deadlines for Ruby&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cutoff&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/rb/cutoff&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/cutoff.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/justinhoward/cutoff/actions?query=workflow%3ACI+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/justinhoward/cutoff/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.codacy.com/gh/justinhoward/cutoff/dashboard?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=justinhoward/cutoff&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://app.codacy.com/project/badge/Grade/2748da79ec294f909996a56f11caac4a&#34; alt=&#34;Code Quality&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/justinhoward/cutoff&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/justinhoward/cutoff/branch/master/graph/badge.svg?token=COVM3D2PTG&#34; alt=&#34;Code Coverage&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/justinhoward/cutoff&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/justinhoward/cutoff.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A deadlines library for Ruby inspired by Shopify and &lt;a href=&#34;https://kirshatrov.com/posts/scaling-mysql-stack-part-2-deadlines/&#34;&gt;Kir Shatrov&#39;s blog series&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.wrap(5) do&#xA;  sleep(4)&#xA;  Cutoff.checkpoint! # still have time left&#xA;  sleep(2)&#xA;  Cutoff.checkpoint! # raises an error&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It has built-in patches for Mysql2 and Net::HTTP to auto-insert checkpoints and timeouts.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;cutoff/patch/mysql2&#39;&#xA;&#xA;client = Mysql2::Client.new&#xA;Cutoff.wrap(5) do&#xA;  client.query(&#39;SELECT * FROM dual WHERE sleep(2)&#39;)&#xA;&#xA;  # Cutoff will automatically insert a /*+ MAX_EXECUTION_TIME(3000) */&#xA;  # hint so that MySQL will terminate the query after the time remaining&#xA;  #&#xA;  # Or if time already expired, this will raise an error and not be executed&#xA;  client.query(&#39;SELECT * FROM dual WHERE sleep(1)&#39;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why use deadlines?&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;ve already implemented timeouts for your networked dependencies, then you can be sure that no single HTTP request or database query can take longer than the time allotted to it.&lt;/p&gt; &#xA;&lt;p&gt;For example, let&#39;s say you set a query timeout of 3 seconds. That means no single query will take longer than 3 seconds. However, imagine a bad controller action or background job executes 100 slow queries. In that case, the queries add up to 300 seconds, much too long.&lt;/p&gt; &#xA;&lt;p&gt;Deadlines keep track of the total elapsed time in a request or job and interrupt it if it takes too long.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add it to your &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;gem &#39;cutoff&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or install it manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gem install cutoff&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API Documentation&lt;/h2&gt; &#xA;&lt;p&gt;API docs can be read &lt;a href=&#34;https://www.rubydoc.info/github/justinhoward/cutoff/master&#34;&gt;on rubydoc.info&lt;/a&gt;, inline in the source code, or you can generate them yourself with Ruby &lt;code&gt;yard&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bin/yardoc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then open &lt;code&gt;doc/index.html&lt;/code&gt; in your browser.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The simplest way to use Cutoff is to use its class methods, although it can be used in an object-oriented manner as well.&lt;/p&gt; &#xA;&lt;h3&gt;Wrapping a block&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.wrap(3.5) do # number of allowed seconds for this block&#xA;  # Do something time-consuming here&#xA;&#xA;  # At a good stopping point, call checkpoint!&#xA;  # If the allowed time is exceeded, this raises a Cutoff::CutoffExceededError&#xA;  # otherwise, it does nothing&#xA;  Cutoff.checkpoint!&#xA;&#xA;  # Now continue executing&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Creating your own instance&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cutoff = Cutoff.new(6.4)&#xA;sleep(10)&#xA;cutoff.checkpoint! # Raises Cutoff::CutoffExceededError&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting cutoff details&lt;/h3&gt; &#xA;&lt;p&gt;Cutoff has some instance methods to get information about the time remaining, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# If you&#39;re using Cutoff class methods, you can get the current instance&#xA;cutoff = Cutoff.current # careful, this will be nil if a cutoff isn&#39;t running&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once you have an instance, either by creating your own or from &lt;code&gt;.current&lt;/code&gt;, you have access to these methods.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cutoff = Cutoff.current&#xA;&#xA;# These return Floats&#xA;cutoff.allowed_seconds # Total seconds allowed (the seconds given when cutoff was started)&#xA;cutoff.seconds_remaining # Seconds left&#xA;cutoff.elapsed_seconds # Seconds since the cutoff was started&#xA;cutoff.ms_remaining # Milliseconds left&#xA;&#xA;cutoff.exceeded? # True if the cutoff is expired&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Patches&lt;/h2&gt; &#xA;&lt;p&gt;Cutoff is in early stages, but it aims to provide patches for common networked dependencies. Patches automatically insert useful checkpoints and timeouts. The patches so far are for &lt;code&gt;mysql2&lt;/code&gt; and &lt;code&gt;Net::HTTP&lt;/code&gt;. They are not loaded by default, so you need to require them manually.&lt;/p&gt; &#xA;&lt;p&gt;For example, to load the Mysql2 patch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# In your Gemfile&#xA;gem &#39;cutoff&#39;, require: %w[cutoff cutoff/patch/mysql2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Or manually&#xA;require &#39;cutoff&#39;&#xA;require &#39;cutoff/patch/mysql2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Mysql2&lt;/h3&gt; &#xA;&lt;p&gt;Once it is enabled, any &lt;code&gt;Mysql2::Client&lt;/code&gt; object will respect the current class-level cutoff if one is set.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;cutoff/patch/mysql2&#39;&#xA;&#xA;client = Mysql2::Client.new&#xA;Cutoff.wrap(3) do&#xA;  sleep(4)&#xA;&#xA;  # This query will not be executed because the time is already expired&#xA;  client.query(&#39;SELECT * FROM users&#39;)&#xA;end&#xA;&#xA;Cutoff.wrap(3) do&#xA;  sleep(1)&#xA;&#xA;  # There are 2 seconds left, so a MAX_EXECUTION_TIME query hint is added&#xA;  # to inform MySQL we only have 2 seconds to execute this query&#xA;  # The executed query will be &#34;SELECT /*+ MAX_EXECUTION_TIME(2000) */ * FROM users&#34;&#xA;  client.query(&#39;SELECT * FROM users&#39;)&#xA;&#xA;  # MySQL only supports MAX_EXECUTION_TIME for SELECTs so no query hint here&#xA;  client.query(&#34;INSERT INTO users(first_name) VALUES(&#39;Joe&#39;)&#34;)&#xA;&#xA;  sleep(3)&#xA;&#xA;  # We don&#39;t even execute this query because time is already expired&#xA;  # This limit applies to all queries, including INSERTS, etc&#xA;  client.query(&#39;SELECT * FROM users&#39;)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Net::HTTP&lt;/h3&gt; &#xA;&lt;p&gt;Once it is enabled, any &lt;code&gt;Net::HTTP&lt;/code&gt; requests will respect the current class-level cutoff if one is set.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;cutoff/patch/net_http&#39;&#xA;&#xA;Cutoff.wrap(3) do&#xA;  sleep(5)&#xA;&#xA;  # The cutoff is expired, so this hits a checkpoint and will not be executed&#xA;  Net::HTTP.get(URI.parse(&#39;http://example.com&#39;))&#xA;end&#xA;&#xA;Cutoff.wrap(3) do&#xA;  sleep(1.5)&#xA;&#xA;  # The cutoff has 1.5 seconds left, so this request will be executed&#xA;  # open_timeout, read_timeout, and write_timeout (Ruby &amp;gt;= 2.6) will each&#xA;  # be set to 1.5&#xA;  # This means the overall time can be &amp;gt; 1.5 since the combined phases can take&#xA;  # up to 4.5 seconds&#xA;  Net::HTTP.get(URI.parse(&#39;http://example.com&#39;))&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Selecting Checkpoints&lt;/h2&gt; &#xA;&lt;p&gt;In some cases, you may want to select some checkpoints to use, but not others. For example, you may want to run some code that contains MySQL queries, but not use the mysql2 patch. The &lt;code&gt;exclude&lt;/code&gt; and &lt;code&gt;only&lt;/code&gt; options support this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.wrap(10, exclude: :mysql2) do&#xA;  # The mysql2 patch won&#39;t be used here&#xA;end&#xA;&#xA;Cutoff.wrap(10, only: %i[foo bar]) do&#xA;  # These checkpoints will be used&#xA;  Cutoff.checkpoint!(:foo)&#xA;  Cutoff.checkpoint!(:bar)&#xA;&#xA;  # These checkpoints will be skipped&#xA;  Cutoff.checkpoint!(:asdf)&#xA;  Cutoff.checkpoint!&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Timing a Rails Controller&lt;/h2&gt; &#xA;&lt;p&gt;One use of a cutoff is to add a deadline to a Rails controller action. This is typically preferable to approaches like &lt;code&gt;Rack::Timeout&lt;/code&gt; that use the dangerous &lt;code&gt;Timeout&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;p&gt;Cutoff includes a built-in integration for this purpose. If Rails is installed, the &lt;code&gt;#cutoff&lt;/code&gt; class method is available in your controllers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  # You may want to set a long global cutoff, but it&#39;s not required&#xA;  cutoff 30&#xA;end&#xA;&#xA;class UsersController &amp;lt; ApplicationController&#xA;  cutoff 5.0&#xA;&#xA;  def index&#xA;    # Now in your action, you can call `checkpoint!`, or if you&#39;re using the&#xA;    # patches, checkpoints will be added automatically&#xA;    Cutoff.checkpoint!&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Just like with controller filters, you can use filters with the cutoff method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UsersController &amp;lt; ApplicationController&#xA;  # For example, use an :only filter&#xA;  cutoff 5.0, only: :index&#xA;&#xA;  # Multiple calls work just fine. Last match wins&#xA;  cutoff 2.5, only: :show&#xA;&#xA;  def index&#xA;    # ...&#xA;  end&#xA;&#xA;  def show&#xA;    # ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Consider adding a global error handler for the &lt;code&gt;Cutoff::CutoffExceededError&lt;/code&gt; in case you want to display a nice error page for timeouts.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  rescue_from Cutoff::CutoffExceededError, with: :handle_cutoff_exceeded&#xA;&#xA;  def handle_cutoff_exceeded&#xA;    # Render a nice error page&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Timing Sidekiq Workers&lt;/h2&gt; &#xA;&lt;p&gt;If Sidekiq is loaded, Cutoff includes middleware to support a &lt;code&gt;:cutoff&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class MyWorker&#xA;  include Sidekiq::Worker&#xA;&#xA;  sidekiq_options cutoff: 6.0&#xA;&#xA;  def perform&#xA;    # ...&#xA;    Cutoff.checkpoint!&#xA;    # ...&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Disabling Cutoff for Testing and Development&lt;/h2&gt; &#xA;&lt;p&gt;When testing or debugging an application that uses Cutoff, you may want to disable Cutoff entirely. These methods are not thread-safe and not intended for production.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# This disables all cutoff timers, for both global and local instances&#xA;Cutoff.disable!&#xA;Cutoff.disabled? # =&amp;gt; true&#xA;&#xA;# Re-enable cutoff&#xA;Cutoff.enable!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Multi-threading&lt;/h2&gt; &#xA;&lt;p&gt;In multi-threaded environments, cutoff class methods are independent in each thread. That means that if you start a cutoff in one thread then start a new thread, the second thread &lt;em&gt;will not&lt;/em&gt; inherit the cutoff from its parent thread.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.wrap(6) do&#xA;  Thread.new do&#xA;    # This code can run as long as it wants because the class-level&#xA;    # cutoff is independent&#xA;&#xA;    Cutoff.wrap(3) do&#xA;      # However, you can start a new cutoff inside the new thread and it&#xA;      # will not affect any other threads&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same rules apply to fibers. Each fiber has independent class-level cutoff instances. This means you can use Cutoff in a multi-threaded web server or job runner without worrying about thread conflicts.&lt;/p&gt; &#xA;&lt;p&gt;If you want to use a single cutoff for multi-threading, you&#39;ll need to pass an instance of a Cutoff.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cutoff = Cutoff.new(6)&#xA;cutoff.checkpoint! # parent thread can call checkpoint!&#xA;Thread.new do&#xA;  # And the child thread can use the same cutoff&#xA;  cutoff.checkpoint!&#xA;end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, because patches use the class-level Cutoff methods, this only works when calling cutoff methods manually.&lt;/p&gt; &#xA;&lt;h2&gt;Nested Cutoffs&lt;/h2&gt; &#xA;&lt;p&gt;When using the Cutoff class methods, it is possible to nest multiple Cutoff contexts with &lt;code&gt;.wrap&lt;/code&gt; or &lt;code&gt;.start&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.wrap(10) do&#xA;  # This outer block has a timeout of 10 seconds&#xA;  Cutoff.wrap(3) do&#xA;    # But this inner block is only allowed to take 3 seconds&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A child cutoff can never be set for longer than the remaining time of its parent cutoff. So if a child is created for longer than the remaining allowed time, it will be reduced to the remaining time of the outer cutoff.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.wrap(5) do&#xA;  sleep(4)&#xA;  # There is only 1 second remaining in the parent&#xA;  Cutoff.wrap(3) do&#xA;    # So this inner block will only have 1 second to execute&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;About the Timer&lt;/h2&gt; &#xA;&lt;p&gt;Cutoff tries to use the best timer available on whatever platform it&#39;s running on. If a monotonic clock is available, that will be used, or failing that, if concurrent-ruby is loaded, that will be used. If neither is available, &lt;code&gt;Time.now&lt;/code&gt; is used.&lt;/p&gt; &#xA;&lt;p&gt;This mean that Cutoff tries its best to prevent time from travelling backwards. However, the clock uniformity, resolution, and stability is determined by the system Cutoff is running on.&lt;/p&gt; &#xA;&lt;h2&gt;Manual start and stop&lt;/h2&gt; &#xA;&lt;p&gt;If you find that &lt;code&gt;Cutoff.wrap&lt;/code&gt; is too limiting for some integrations, Cutoff also provides the &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; methods. Extra care is required to use these to prevent a cutoff from being leaked. Every &lt;code&gt;start&lt;/code&gt; call must be accompanied by a &lt;code&gt;stop&lt;/code&gt; call, otherwise the cutoff will continue to run and could affect a context other than the intended one.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Cutoff.start(2.5)&#xA;begin&#xA;  # Execute code here&#xA;  Cutoff.checkpoint!&#xA;ensure&#xA;  # Always stop in an ensure statement to make sure an exception cannot leave&#xA;  # a cutoff running&#xA;  Cutoff.stop&#xA;end&#xA;&#xA;# Nested cutoffs are still supported&#xA;outer = Cutoff.start(10)&#xA;begin&#xA;  # Outer 10s cutoff is used here&#xA;  Cutoff.checkpoint!&#xA;&#xA;  inner = Cutoff.start(5)&#xA;  begin&#xA;    # Inner 5s cutoff is used here&#xA;    Cutoff.checkpoint!&#xA;  ensure&#xA;    # Stops the inner cutoff&#xA;    # We don&#39;t need to pass the instance here, but it does prevent some types of mistakes&#xA;    Cutoff.stop(inner)&#xA;  end&#xA;ensure&#xA;  # Stops the outer cutoff&#xA;  Cutoff.stop(outer)&#xA;end&#xA;&#xA;Cutoff.start(10)&#xA;Cutoff.start(5)&#xA;begin&#xA;  # Code here&#xA;ensure&#xA;  # This stops all cutoffs&#xA;  Cutoff.clear_all&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be careful, you can easily make a mistake when using this API, so prefer &lt;code&gt;.wrap&lt;/code&gt; when possible.&lt;/p&gt; &#xA;&lt;h2&gt;Design Philosophy&lt;/h2&gt; &#xA;&lt;p&gt;Cutoff is designed to only stop code execution at predictable points. It will never interrupt a running program unless:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;checkpoint!&lt;/code&gt; is called&lt;/li&gt; &#xA; &lt;li&gt;a network timeout is exceeded&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Patches are designed to ease the burden on developers to manually call &lt;code&gt;checkpoint!&lt;/code&gt; or configure network timeouts. The ruby &lt;code&gt;Timeout&lt;/code&gt; class is not used. See Julia Evans&#39; post on &lt;a href=&#34;https://jvns.ca/blog/2015/11/27/why-rubys-timeout-is-dangerous-and-thread-dot-raise-is-terrifying/&#34;&gt;Why Ruby&#39;s Timeout is dangerous&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Patches are only applied by explicit opt-in, and Cutoff can always be used as a standalone library.&lt;/p&gt;</summary>
  </entry>
</feed>