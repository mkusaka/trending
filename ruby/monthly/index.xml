<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Ruby Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-06-02T02:31:38Z</updated>
  <subtitle>Monthly Trending of Ruby in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>varvet/pundit</title>
    <updated>2022-06-02T02:31:38Z</updated>
    <id>tag:github.com,2022-06-02:/varvet/pundit</id>
    <link href="https://github.com/varvet/pundit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Minimal authorization through OO design and pure Ruby classes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pundit&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/varvet/pundit&#34;&gt;&lt;img src=&#34;https://secure.travis-ci.org/varvet/pundit.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codeclimate.com/github/varvet/pundit&#34;&gt;&lt;img src=&#34;https://codeclimate.com/github/varvet/pundit.svg?sanitize=true&#34; alt=&#34;Code Climate&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://inch-ci.org/github/varvet/pundit&#34;&gt;&lt;img src=&#34;http://inch-ci.org/github/varvet/pundit.svg?branch=master&#34; alt=&#34;Inline docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://badge.fury.io/rb/pundit&#34;&gt;&lt;img src=&#34;https://badge.fury.io/rb/pundit.svg?sanitize=true&#34; alt=&#34;Gem Version&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Pundit provides a set of helpers which guide you in leveraging regular Ruby classes and object oriented design patterns to build a simple, robust and scalable authorization system.&lt;/p&gt; &#xA;&lt;p&gt;Links:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.rubydoc.info/gems/pundit&#34;&gt;API documentation for the most recent version&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/raw/master/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/raw/master/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sponsored by:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.varvet.com&#34;&gt;&lt;img src=&#34;https://www.varvet.com/images/wordmark-red.svg?sanitize=true&#34; alt=&#34;Varvet&#34; height=&#34;50px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Please note&lt;/strong&gt; that the README on GitHub is accurate with the &lt;em&gt;latest code on GitHub&lt;/em&gt;. You are most likely using a released version of Pundit, so please refer to the &lt;a href=&#34;https://www.rubydoc.info/gems/pundit&#34;&gt;documentation for the latest released version of Pundit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bundle add pundit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Include &lt;code&gt;Pundit::Authorization&lt;/code&gt; in your application controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally, you can run the generator, which will set up an application policy with some useful defaults for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails g pundit:install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After generating your application policy, restart the Rails server so that Rails can pick up any classes in the new &lt;code&gt;app/policies/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Policies&lt;/h2&gt; &#xA;&lt;p&gt;Pundit is focused around the notion of policy classes. We suggest that you put these classes in &lt;code&gt;app/policies&lt;/code&gt;. This is a simple example that allows updating a post if the user is an admin, or if the post is unpublished:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy&#xA;  attr_reader :user, :post&#xA;&#xA;  def initialize(user, post)&#xA;    @user = user&#xA;    @post = post&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? || !post.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, this is just a plain Ruby class. Pundit makes the following assumptions about this class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The class has the same name as some kind of model class, only suffixed with the word &#34;Policy&#34;.&lt;/li&gt; &#xA; &lt;li&gt;The first argument is a user. In your controller, Pundit will call the &lt;code&gt;current_user&lt;/code&gt; method to retrieve what to send into this argument&lt;/li&gt; &#xA; &lt;li&gt;The second argument is some kind of model object, whose authorization you want to check. This does not need to be an ActiveRecord or even an ActiveModel object, it can be anything really.&lt;/li&gt; &#xA; &lt;li&gt;The class implements some kind of query method, in this case &lt;code&gt;update?&lt;/code&gt;. Usually, this will map to the name of a particular controller action.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That&#39;s it really.&lt;/p&gt; &#xA;&lt;p&gt;Usually you&#39;ll want to inherit from the application policy created by the generator, or set up your own base class to inherit from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the generated &lt;code&gt;ApplicationPolicy&lt;/code&gt;, the model object is called &lt;code&gt;record&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Supposing that you have an instance of class &lt;code&gt;Post&lt;/code&gt;, Pundit now lets you do this in your controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def update&#xA;  @post = Post.find(params[:id])&#xA;  authorize @post&#xA;  if @post.update(post_params)&#xA;    redirect_to @post&#xA;  else&#xA;    render :edit&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The authorize method automatically infers that &lt;code&gt;Post&lt;/code&gt; will have a matching &lt;code&gt;PostPolicy&lt;/code&gt; class, and instantiates this class, handing in the current user and the given record. It then infers from the action name, that it should call &lt;code&gt;update?&lt;/code&gt; on this instance of the policy. In this case, you can imagine that &lt;code&gt;authorize&lt;/code&gt; would have done something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;unless PostPolicy.new(current_user, @post).update?&#xA;  raise Pundit::NotAuthorizedError, &#34;not allowed to update? this #{@post.inspect}&#34;&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass a second argument to &lt;code&gt;authorize&lt;/code&gt; if the name of the permission you want to check doesn&#39;t match the action name. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def publish&#xA;  @post = Post.find(params[:id])&#xA;  authorize @post, :update?&#xA;  @post.publish!&#xA;  redirect_to @post&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can pass an argument to override the policy class if necessary. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def create&#xA;  @publication = find_publication # assume this method returns any model that behaves like a publication&#xA;  # @publication.class =&amp;gt; Post&#xA;  authorize @publication, policy_class: PublicationPolicy&#xA;  @publication.publish!&#xA;  redirect_to @publication&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you don&#39;t have an instance for the first argument to &lt;code&gt;authorize&lt;/code&gt;, then you can pass the class. For example:&lt;/p&gt; &#xA;&lt;p&gt;Policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def admin_list?&#xA;    user.admin?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def admin_list&#xA;  authorize Post # we don&#39;t have a particular post to authorize&#xA;  # Rest of controller action&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;authorize&lt;/code&gt; returns the instance passed to it, so you can chain it like this:&lt;/p&gt; &#xA;&lt;p&gt;Controller:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show&#xA;  @user = authorize User.find(params[:id])&#xA;end&#xA;&#xA;# return the record even for namespaced policies&#xA;def show&#xA;  @user = authorize [:admin, User.find(params[:id])]&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can easily get a hold of an instance of the policy through the &lt;code&gt;policy&lt;/code&gt; method in both the view and controller. This is especially useful for conditionally showing links or buttons in the view:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% if policy(@post).update? %&amp;gt;&#xA;  &amp;lt;%= link_to &#34;Edit post&#34;, edit_post_path(@post) %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Headless policies&lt;/h2&gt; &#xA;&lt;p&gt;Given there is a policy without a corresponding model / ruby class, you can retrieve it by passing a symbol.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/dashboard_policy.rb&#xA;class DashboardPolicy&#xA;  attr_reader :user&#xA;&#xA;  # _record in this example will just be :dashboard&#xA;  def initialize(user, _record)&#xA;    @user = user&#xA;  end&#xA;&#xA;  def show?&#xA;    user.admin?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the headless policy still needs to accept two arguments. The second argument will just be the symbol &lt;code&gt;:dashboard&lt;/code&gt; in this case which is what is passed as the record to &lt;code&gt;authorize&lt;/code&gt; below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# In controllers&#xA;def show&#xA;  authorize :dashboard, :show?&#xA;  ...&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;# In views&#xA;&amp;lt;% if policy(:dashboard).show? %&amp;gt;&#xA;  &amp;lt;%= link_to &#39;Dashboard&#39;, dashboard_path %&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scopes&lt;/h2&gt; &#xA;&lt;p&gt;Often, you will want to have some kind of view listing records which a particular user has access to. When using Pundit, you are expected to define a class called a policy scope. It can look something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope&#xA;    def initialize(user, scope)&#xA;      @user  = user&#xA;      @scope = scope&#xA;    end&#xA;&#xA;    def resolve&#xA;      if user.admin?&#xA;        scope.all&#xA;      else&#xA;        scope.where(published: true)&#xA;      end&#xA;    end&#xA;&#xA;    private&#xA;&#xA;    attr_reader :user, :scope&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Pundit makes the following assumptions about this class:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The class has the name &lt;code&gt;Scope&lt;/code&gt; and is nested under the policy class.&lt;/li&gt; &#xA; &lt;li&gt;The first argument is a user. In your controller, Pundit will call the &lt;code&gt;current_user&lt;/code&gt; method to retrieve what to send into this argument.&lt;/li&gt; &#xA; &lt;li&gt;The second argument is a scope of some kind on which to perform some kind of query. It will usually be an ActiveRecord class or a &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;, but it could be something else entirely.&lt;/li&gt; &#xA; &lt;li&gt;Instances of this class respond to the method &lt;code&gt;resolve&lt;/code&gt;, which should return some kind of result which can be iterated over. For ActiveRecord classes, this would usually be an &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You&#39;ll probably want to inherit from the application policy scope generated by the generator, or create your own base class to inherit from:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope &amp;lt; Scope&#xA;    def resolve&#xA;      if user.admin?&#xA;        scope.all&#xA;      else&#xA;        scope.where(published: true)&#xA;      end&#xA;    end&#xA;  end&#xA;&#xA;  def update?&#xA;    user.admin? or not record.published?&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now use this class from your controller via the &lt;code&gt;policy_scope&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  @posts = policy_scope(Post)&#xA;end&#xA;&#xA;def show&#xA;  @post = policy_scope(Post).find(params[:id])&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Like with the authorize method, you can also override the policy scope class:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  # publication_class =&amp;gt; Post&#xA;  @publications = policy_scope(publication_class, policy_scope_class: PublicationPolicy::Scope)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case it is a shortcut for doing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def index&#xA;  @publications = PublicationPolicy::Scope.new(current_user, Post).resolve&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can, and are encouraged to, use this method in views:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-erb&#34;&gt;&amp;lt;% policy_scope(@user.posts).each do |post| %&amp;gt;&#xA;  &amp;lt;p&amp;gt;&amp;lt;%= link_to post.title, post_path(post) %&amp;gt;&amp;lt;/p&amp;gt;&#xA;&amp;lt;% end %&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Ensuring policies and scopes are used&lt;/h2&gt; &#xA;&lt;p&gt;When you are developing an application with Pundit it can be easy to forget to authorize some action. People are forgetful after all. Since Pundit encourages you to add the &lt;code&gt;authorize&lt;/code&gt; call manually to each controller action, it&#39;s really easy to miss one.&lt;/p&gt; &#xA;&lt;p&gt;Thankfully, Pundit has a handy feature which reminds you in case you forget. Pundit tracks whether you have called &lt;code&gt;authorize&lt;/code&gt; anywhere in your controller action. Pundit also adds a method to your controllers called &lt;code&gt;verify_authorized&lt;/code&gt;. This method will raise an exception if &lt;code&gt;authorize&lt;/code&gt; has not yet been called. You should run this method in an &lt;code&gt;after_action&lt;/code&gt; hook to ensure that you haven&#39;t forgotten to authorize the action. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;  after_action :verify_authorized&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Likewise, Pundit also adds &lt;code&gt;verify_policy_scoped&lt;/code&gt; to your controller. This will raise an exception similar to &lt;code&gt;verify_authorized&lt;/code&gt;. However, it tracks if &lt;code&gt;policy_scope&lt;/code&gt; is used instead of &lt;code&gt;authorize&lt;/code&gt;. This is mostly useful for controller actions like &lt;code&gt;index&lt;/code&gt; which find collections with a scope and don&#39;t authorize individual instances.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;  after_action :verify_authorized, except: :index&#xA;  after_action :verify_policy_scoped, only: :index&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;This verification mechanism only exists to aid you while developing your application, so you don&#39;t forget to call &lt;code&gt;authorize&lt;/code&gt;. It is not some kind of failsafe mechanism or authorization mechanism. You should be able to remove these filters without affecting how your app works in any way.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Some people have found this feature confusing, while many others find it extremely helpful. If you fall into the category of people who find it confusing then you do not need to use it. Pundit will work just fine without using &lt;code&gt;verify_authorized&lt;/code&gt; and &lt;code&gt;verify_policy_scoped&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Conditional verification&lt;/h3&gt; &#xA;&lt;p&gt;If you&#39;re using &lt;code&gt;verify_authorized&lt;/code&gt; in your controllers but need to conditionally bypass verification, you can use &lt;code&gt;skip_authorization&lt;/code&gt;. For bypassing &lt;code&gt;verify_policy_scoped&lt;/code&gt;, use &lt;code&gt;skip_policy_scope&lt;/code&gt;. These are useful in circumstances where you don&#39;t want to disable verification for the entire action, but have some cases where you intend to not authorize.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show&#xA;  record = Record.find_by(attribute: &#34;value&#34;)&#xA;  if record.present?&#xA;    authorize record&#xA;  else&#xA;    skip_authorization&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Manually specifying policy classes&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you might want to explicitly declare which policy to use for a given class, instead of letting Pundit infer it. This can be done like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post&#xA;  def self.policy_class&#xA;    PostablePolicy&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can declare an instance method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Post&#xA;  def policy_class&#xA;    PostablePolicy&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Just plain old Ruby&lt;/h2&gt; &#xA;&lt;p&gt;As you can see, Pundit doesn&#39;t do anything you couldn&#39;t have easily done yourself. It&#39;s a very small library, it just provides a few neat helpers. Together these give you the power of building a well structured, fully working authorization system without using any special DSLs or funky syntax or anything.&lt;/p&gt; &#xA;&lt;p&gt;Remember that all of the policy and scope classes are just plain Ruby classes, which means you can use the same mechanisms you always use to DRY things up. Encapsulate a set of permissions into a module and include them in multiple policies. Use &lt;code&gt;alias_method&lt;/code&gt; to make some permissions behave the same as others. Inherit from a base set of permissions. Use metaprogramming if you really have to.&lt;/p&gt; &#xA;&lt;h2&gt;Generator&lt;/h2&gt; &#xA;&lt;p&gt;Use the supplied generator to generate policies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rails g pundit:policy post&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Closed systems&lt;/h2&gt; &#xA;&lt;p&gt;In many applications, only logged in users are really able to do anything. If you&#39;re building such a system, it can be kind of cumbersome to check that the user in a policy isn&#39;t &lt;code&gt;nil&lt;/code&gt; for every single permission. Aside from policies, you can add this check to the base class for scopes.&lt;/p&gt; &#xA;&lt;p&gt;We suggest that you define a filter that redirects unauthenticated users to the login page. As a secondary defence, if you&#39;ve defined an ApplicationPolicy, it might be a good idea to raise an exception if somehow an unauthenticated user got through. This way you can fail more gracefully.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationPolicy&#xA;  def initialize(user, record)&#xA;    raise Pundit::NotAuthorizedError, &#34;must be logged in&#34; unless user&#xA;    @user   = user&#xA;    @record = record&#xA;  end&#xA;&#xA;  class Scope&#xA;    attr_reader :user, :scope&#xA;&#xA;    def initialize(user, scope)&#xA;      raise Pundit::NotAuthorizedError, &#34;must be logged in&#34; unless user&#xA;      @user = user&#xA;      @scope = scope&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;NilClassPolicy&lt;/h2&gt; &#xA;&lt;p&gt;To support a &lt;a href=&#34;https://en.wikipedia.org/wiki/Null_Object_pattern&#34;&gt;null object pattern&lt;/a&gt; you may find that you want to implement a &lt;code&gt;NilClassPolicy&lt;/code&gt;. This might be useful where you want to extend your ApplicationPolicy to allow some tolerance of, for example, associations which might be &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NilClassPolicy &amp;lt; ApplicationPolicy&#xA;  class Scope &amp;lt; Scope&#xA;    def resolve&#xA;      raise Pundit::NotDefinedError, &#34;Cannot scope NilClass&#34;&#xA;    end&#xA;  end&#xA;&#xA;  def show?&#xA;    false # Nobody can see nothing&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Rescuing a denied Authorization in Rails&lt;/h2&gt; &#xA;&lt;p&gt;Pundit raises a &lt;code&gt;Pundit::NotAuthorizedError&lt;/code&gt; you can &lt;a href=&#34;http://guides.rubyonrails.org/action_controller_overview.html#rescue-from&#34;&gt;rescue_from&lt;/a&gt; in your &lt;code&gt;ApplicationController&lt;/code&gt;. You can customize the &lt;code&gt;user_not_authorized&lt;/code&gt; method in every controller.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA;  include Pundit::Authorization&#xA;&#xA;  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized&#xA;&#xA;  private&#xA;&#xA;  def user_not_authorized&#xA;    flash[:alert] = &#34;You are not authorized to perform this action.&#34;&#xA;    redirect_back(fallback_location: root_path)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, you can globally handle Pundit::NotAuthorizedError&#39;s by having rails handle them as a 403 error and serving a 403 error page. Add the following to application.rb:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;config.action_dispatch.rescue_responses[&#34;Pundit::NotAuthorizedError&#34;] = :forbidden&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Creating custom error messages&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;NotAuthorizedError&lt;/code&gt;s provide information on what query (e.g. &lt;code&gt;:create?&lt;/code&gt;), what record (e.g. an instance of &lt;code&gt;Post&lt;/code&gt;), and what policy (e.g. an instance of &lt;code&gt;PostPolicy&lt;/code&gt;) caused the error to be raised.&lt;/p&gt; &#xA;&lt;p&gt;One way to use these &lt;code&gt;query&lt;/code&gt;, &lt;code&gt;record&lt;/code&gt;, and &lt;code&gt;policy&lt;/code&gt; properties is to connect them with &lt;code&gt;I18n&lt;/code&gt; to generate error messages. Here&#39;s how you might go about doing that.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class ApplicationController &amp;lt; ActionController::Base&#xA; rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized&#xA;&#xA; private&#xA;&#xA; def user_not_authorized(exception)&#xA;   policy_name = exception.policy.class.to_s.underscore&#xA;&#xA;   flash[:error] = t &#34;#{policy_name}.#{exception.query}&#34;, scope: &#34;pundit&#34;, default: :default&#xA;   redirect_back(fallback_url: root_path)&#xA; end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:&#xA; pundit:&#xA;   default: &#39;You cannot perform this action.&#39;&#xA;   post_policy:&#xA;     update?: &#39;You cannot edit this post!&#39;&#xA;     create?: &#39;You cannot create posts!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course, this is just an example. Pundit is agnostic as to how you implement your error messaging.&lt;/p&gt; &#xA;&lt;h2&gt;Manually retrieving policies and scopes&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you want to retrieve a policy for a record outside the controller or view. For example when you delegate permissions from one policy to another.&lt;/p&gt; &#xA;&lt;p&gt;You can easily retrieve policies and scopes like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Pundit.policy!(user, post)&#xA;Pundit.policy(user, post)&#xA;&#xA;Pundit.policy_scope!(user, Post)&#xA;Pundit.policy_scope(user, Post)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The bang methods will raise an exception if the policy does not exist, whereas those without the bang will return nil.&lt;/p&gt; &#xA;&lt;h2&gt;Customize Pundit user&lt;/h2&gt; &#xA;&lt;p&gt;In some cases your controller might not have access to &lt;code&gt;current_user&lt;/code&gt;, or your &lt;code&gt;current_user&lt;/code&gt; is not the method that should be invoked by Pundit. Simply define a method in your controller called &lt;code&gt;pundit_user&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def pundit_user&#xA;  User.find_by_other_means&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Policy Namespacing&lt;/h2&gt; &#xA;&lt;p&gt;In some cases it might be helpful to have multiple policies that serve different contexts for a resource. A prime example of this is the case where User policies differ from Admin policies. To authorize with a namespaced policy, pass the namespace into the &lt;code&gt;authorize&lt;/code&gt; helper in an array:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;authorize(post)                   # =&amp;gt; will look for a PostPolicy&#xA;authorize([:admin, post])         # =&amp;gt; will look for an Admin::PostPolicy&#xA;authorize([:foo, :bar, post])     # =&amp;gt; will look for a Foo::Bar::PostPolicy&#xA;&#xA;policy_scope(Post)                # =&amp;gt; will look for a PostPolicy::Scope&#xA;policy_scope([:admin, Post])      # =&amp;gt; will look for an Admin::PostPolicy::Scope&#xA;policy_scope([:foo, :bar, Post])  # =&amp;gt; will look for a Foo::Bar::PostPolicy::Scope&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you are using namespaced policies for something like Admin views, it can be useful to override the &lt;code&gt;policy_scope&lt;/code&gt; and &lt;code&gt;authorize&lt;/code&gt; helpers in your &lt;code&gt;AdminController&lt;/code&gt; to automatically apply the namespacing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class AdminController &amp;lt; ApplicationController&#xA;  def policy_scope(scope)&#xA;    super([:admin, scope])&#xA;  end&#xA;&#xA;  def authorize(record, query = nil)&#xA;    super([:admin, record], query)&#xA;  end&#xA;end&#xA;&#xA;class Admin::PostController &amp;lt; AdminController&#xA;  def index&#xA;    policy_scope(Post)&#xA;  end&#xA;&#xA;  def show&#xA;    post = authorize Post.find(params[:id])&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Additional context&lt;/h2&gt; &#xA;&lt;p&gt;Pundit strongly encourages you to model your application in such a way that the only context you need for authorization is a user object and a domain model that you want to check authorization for. If you find yourself needing more context than that, consider whether you are authorizing the right domain model, maybe another domain model (or a wrapper around multiple domain models) can provide the context you need.&lt;/p&gt; &#xA;&lt;p&gt;Pundit does not allow you to pass additional arguments to policies for precisely this reason.&lt;/p&gt; &#xA;&lt;p&gt;However, in very rare cases, you might need to authorize based on more context than just the currently authenticated user. Suppose for example that authorization is dependent on IP address in addition to the authenticated user. In that case, one option is to create a special class which wraps up both user and IP and passes it to the policy.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class UserContext&#xA;  attr_reader :user, :ip&#xA;&#xA;  def initialize(user, ip)&#xA;    @user = user&#xA;    @ip   = ip&#xA;  end&#xA;end&#xA;&#xA;class ApplicationController&#xA;  include Pundit::Authorization&#xA;&#xA;  def pundit_user&#xA;    UserContext.new(current_user, request.ip)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Strong parameters&lt;/h2&gt; &#xA;&lt;p&gt;In Rails, mass-assignment protection is handled in the controller. With Pundit you can control which attributes a user has access to update via your policies. You can set up a &lt;code&gt;permitted_attributes&lt;/code&gt; method in your policy like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/post_policy.rb&#xA;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def permitted_attributes&#xA;    if user.admin? || user.owner_of?(post)&#xA;      [:title, :body, :tag_list]&#xA;    else&#xA;      [:tag_list]&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can now retrieve these attributes from the policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/posts_controller.rb&#xA;class PostsController &amp;lt; ApplicationController&#xA;  def update&#xA;    @post = Post.find(params[:id])&#xA;    if @post.update_attributes(post_params)&#xA;      redirect_to @post&#xA;    else&#xA;      render :edit&#xA;    end&#xA;  end&#xA;&#xA;  private&#xA;&#xA;  def post_params&#xA;    params.require(:post).permit(policy(@post).permitted_attributes)&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, this is a bit cumbersome, so Pundit provides a convenient helper method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/posts_controller.rb&#xA;class PostsController &amp;lt; ApplicationController&#xA;  def update&#xA;    @post = Post.find(params[:id])&#xA;    if @post.update_attributes(permitted_attributes(@post))&#xA;      redirect_to @post&#xA;    else&#xA;      render :edit&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to permit different attributes based on the current action, you can define a &lt;code&gt;permitted_attributes_for_#{action}&lt;/code&gt; method on your policy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/policies/post_policy.rb&#xA;class PostPolicy &amp;lt; ApplicationPolicy&#xA;  def permitted_attributes_for_create&#xA;    [:title, :body]&#xA;  end&#xA;&#xA;  def permitted_attributes_for_edit&#xA;    [:body]&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have defined an action-specific method on your policy for the current action, the &lt;code&gt;permitted_attributes&lt;/code&gt; helper will call it instead of calling &lt;code&gt;permitted_attributes&lt;/code&gt; on your controller.&lt;/p&gt; &#xA;&lt;p&gt;If you need to fetch parameters based on namespaces different from the suggested one, override the below method, in your controller, and return an instance of &lt;code&gt;ActionController::Parameters&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def pundit_params_for(record)&#xA;  params.require(PolicyFinder.new(record).param_key)&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# If you don&#39;t want to use require&#xA;def pundit_params_for(record)&#xA;  params.fetch(PolicyFinder.new(record).param_key, {})&#xA;end&#xA;&#xA;# If you are using something like the JSON API spec&#xA;def pundit_params_for(_record)&#xA;  params.fetch(:data, {}).fetch(:attributes, {})&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;RSpec&lt;/h2&gt; &#xA;&lt;h3&gt;Policy Specs&lt;/h3&gt; &#xA;&lt;p&gt;Pundit includes a mini-DSL for writing expressive tests for your policies in RSpec. Require &lt;code&gt;pundit/rspec&lt;/code&gt; in your &lt;code&gt;spec_helper.rb&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;pundit/rspec&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then put your policy specs in &lt;code&gt;spec/policies&lt;/code&gt;, and make them look somewhat like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;describe PostPolicy do&#xA;  subject { described_class }&#xA;&#xA;  permissions :update?, :edit? do&#xA;    it &#34;denies access if post is published&#34; do&#xA;      expect(subject).not_to permit(User.new(admin: false), Post.new(published: true))&#xA;    end&#xA;&#xA;    it &#34;grants access if post is published and user is an admin&#34; do&#xA;      expect(subject).to permit(User.new(admin: true), Post.new(published: true))&#xA;    end&#xA;&#xA;    it &#34;grants access if post is unpublished&#34; do&#xA;      expect(subject).to permit(User.new(admin: false), Post.new(published: false))&#xA;    end&#xA;  end&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An alternative approach to Pundit policy specs is scoping them to a user context as outlined in this &lt;a href=&#34;http://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/&#34;&gt;excellent post&lt;/a&gt; and implemented in the third party &lt;a href=&#34;https://github.com/chrisalley/pundit-matchers&#34;&gt;pundit-matchers&lt;/a&gt; gem.&lt;/p&gt; &#xA;&lt;h3&gt;Scope Specs&lt;/h3&gt; &#xA;&lt;p&gt;Pundit does not provide a DSL for testing scopes. Just test it like a regular Ruby class!&lt;/p&gt; &#xA;&lt;h1&gt;External Resources&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/RailsApps/rails-devise-pundit&#34;&gt;RailsApps Example Application: Pundit and Devise&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://blog.carbonfive.com/2013/10/21/migrating-to-pundit-from-cancan/&#34;&gt;Migrating to Pundit from CanCan&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://thunderboltlabs.com/blog/2013/03/27/testing-pundit-policies-with-rspec/&#34;&gt;Testing Pundit Policies with RSpec&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/issues/204#issuecomment-60166450&#34;&gt;Testing Pundit with Minitest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/varvet/pundit/pull/136&#34;&gt;Using Pundit outside of a Rails controller&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.sitepoint.com/straightforward-rails-authorization-with-pundit/&#34;&gt;Straightforward Rails Authorization with Pundit&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other implementations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anurag90x/flask-pundit&#34;&gt;Flask-Pundit&lt;/a&gt; (Python) is a &lt;a href=&#34;http://flask.pocoo.org/&#34;&gt;Flask&lt;/a&gt; extension &#34;heavily inspired by&#34; Pundit&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Licensed under the MIT license, see the separate LICENSE.txt file.&lt;/p&gt;</summary>
  </entry>
</feed>