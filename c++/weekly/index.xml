<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-28T01:55:06Z</updated>
  <subtitle>Weekly Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>NootInc/NootedRed</title>
    <updated>2023-05-28T01:55:06Z</updated>
    <id>tag:github.com,2023-05-28:/NootInc/NootedRed</id>
    <link href="https://github.com/NootInc/NootedRed" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lilu plugin for AMD Vega iGPUs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NootedRed &lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/NootInc/NootedRed/main.yml?branch=master&amp;amp;logo=github&amp;amp;style=for-the-badge&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;The AMD Vega iGPU support &lt;a href=&#34;https://github.com/acidanthera/Lilu&#34;&gt;Lilu&lt;/a&gt; (1.6.4+) plug-in.&lt;/p&gt; &#xA;&lt;p&gt;Supports the entire Raven ASIC family (Ryzen 5XXX series and older).&lt;/p&gt; &#xA;&lt;p&gt;The Source Code of this Original Work is licensed under the &lt;code&gt;Thou Shalt Not Profit License version 1.0&lt;/code&gt;. See &lt;a href=&#34;https://github.com/NootInc/NootedRed/raw/master/LICENSE&#34;&gt;&lt;code&gt;LICENSE&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Thanks &lt;a href=&#34;https://github.com/Acidanthera&#34;&gt;Acidanthera&lt;/a&gt; for the AppleBacklight code and UnfairGVA patches in &lt;a href=&#34;https://github.com/Acidanthera/WhateverGreen&#34;&gt;WhateverGreen&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Increase &lt;strong&gt;VRAM size&lt;/strong&gt;; otherwise, the device will fail to initialise. 512MiB VRAM is the minimum, 1GiB or more for proper functionality&lt;/li&gt; &#xA; &lt;li&gt;Disable &lt;strong&gt;Legacy Boot&lt;/strong&gt;, also known as CSM; otherwise, you will experience various difficulties, such as a kernel panic with &#34;Failed to get VBIOS from VRAM&#34; as the message.&lt;/li&gt; &#xA; &lt;li&gt;Remove &lt;strong&gt;&lt;code&gt;WhateverGreen&lt;/code&gt;&lt;/strong&gt;; this kext conflicts with it.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;code&gt;MacBookPro16,3&lt;/code&gt; or &lt;code&gt;MacPro7,1&lt;/code&gt; SMBIOS&lt;/li&gt; &#xA; &lt;li&gt;Update to latest macOS 11 (Big Sur) version&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Recommendations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;From this repository, add &lt;a href=&#34;https://raw.githubusercontent.com/NootInc/NootedRed/master/Assets/SSDT-PNLF.aml&#34;&gt;&lt;code&gt;SSDT-PNLF.aml&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/NootInc/NootedRed/master/Assets/SSDT-ALS0.aml&#34;&gt;&lt;code&gt;SSDT-ALS0.aml&lt;/code&gt;&lt;/a&gt; if you have no Ambient Light Sensor, along with &lt;a href=&#34;https://github.com/Acidanthera/VirtualSMC&#34;&gt;&lt;code&gt;SMCLightSensor.kext&lt;/code&gt;&lt;/a&gt; for backlight functionality. Usually only works on laptops. Add &lt;a href=&#34;https://github.com/Acidanthera/BrightnessKeys&#34;&gt;&lt;code&gt;BrightnessKeys.kext&lt;/code&gt;&lt;/a&gt; for brightness control from the keyboard&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Can I have an AMD dGPU installed on the system?&lt;/h3&gt; &#xA;&lt;p&gt;Your system must not have a GCN 5 or RDNA AMD dGPU, as this kext will conflict with them; we are mixing AMDRadeonX5000 for GCN 5, AMDRadeonX6000 for VCN, and AMDRadeonX6000Framebuffer for DCN. Disable them using &lt;code&gt;-wegnoegpu&lt;/code&gt; (yes, this works here too) or by adding the &lt;code&gt;disable-gpu&lt;/code&gt; device property.&lt;/p&gt; &#xA;&lt;h3&gt;How functional is the kext?&lt;/h3&gt; &#xA;&lt;p&gt;This project is under active research and development; There will be crashes here and there.&lt;/p&gt; &#xA;&lt;p&gt;See repository issues for more information.&lt;/p&gt; &#xA;&lt;h3&gt;On which macOS versions am I able to use this on?&lt;/h3&gt; &#xA;&lt;p&gt;Due to the complexity and secrecy of the Metal drivers, adding support for non-existent logic is basically impossible. In addition, the required logic for our iGPUs has been purged from the AMD kexts since Monterey. This cannot be resolved without breaking macOS&#39; integrity and potentially even stability, at the moment.&lt;/p&gt; &#xA;&lt;p&gt;Injecting the GPU kexts is not possible during the OpenCore injection stage; the pre-linked injection fails for kexts that don&#39;t contain their dependencies in the Boot Kext Collection, which is where OpenCore injects kexts to.&lt;/p&gt; &#xA;&lt;p&gt;In conclusion, this kext works only natively in macOS 11 (Big Sur). For Monterey, a downgrade of &lt;code&gt;AMDRadeonX6000Framebuffer.kext&lt;/code&gt; and &lt;code&gt;AMDRadeonX5000HWLibs.kext&lt;/code&gt; is required.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NVIDIA/cutlass</title>
    <updated>2023-05-28T01:55:06Z</updated>
    <id>tag:github.com,2023-05-28:/NVIDIA/cutlass</id>
    <link href="https://github.com/NVIDIA/cutlass" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CUDA Templates for Linear Algebra Subroutines&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/gemm-hierarchy-with-epilogue-no-labels.png&#34; alt=&#34;ALT&#34; title=&#34;Complete CUDA GEMM decomposition&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CUTLASS 3.1&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;CUTLASS 3.1 - April 2023&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS is a collection of CUDA C++ template abstractions for implementing high-performance matrix-matrix multiplication (GEMM) and related computations at all levels and scales within CUDA. It incorporates strategies for hierarchical decomposition and data movement similar to those used to implement cuBLAS and cuDNN. CUTLASS decomposes these &#34;moving parts&#34; into reusable, modular software components abstracted by C++ template classes. Primitives for different levels of a conceptual parallelization hierarchy can be specialized and tuned via custom tiling sizes, data types, and other algorithmic policy. The resulting flexibility simplifies their use as building blocks within custom kernels and applications.&lt;/p&gt; &#xA;&lt;p&gt;To support a wide variety of applications, CUTLASS provides extensive support for mixed-precision computations, providing specialized data-movement and multiply-accumulate abstractions for half-precision floating point (FP16), BFloat16 (BF16), Tensor Float 32 (TF32), single-precision floating point (FP32), &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/27_ampere_3xtf32_fast_accurate_tensorop_gemm&#34;&gt;FP32 emulation via tensor core instruction&lt;/a&gt;, double-precision floating point (FP64) types, integer data types (4b and 8b), and binary data types (1b). CUTLASS demonstrates warp-synchronous matrix multiply operations targeting the programmable, high-throughput &lt;em&gt;Tensor Cores&lt;/em&gt; implemented by NVIDIA&#39;s Volta, Turing, Ampere, and Hopper architectures.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quick Start Guide&lt;/a&gt; to get started quickly.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;functionality listing&lt;/a&gt; for the list of operations supported at each level of the execution model hierarchy.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS 3.0 introduced a new core library, CuTe, to describe and manipulate tensors of threads and data. CuTe is a collection of C++ CUDA template abstractions for defining and operating on hierarchically multidimensional layouts of threads and data. CuTe provides &lt;code&gt;Layout&lt;/code&gt; and &lt;code&gt;Tensor&lt;/code&gt; objects that compactly package the type, shape, memory space, and layout of data, while performing the complicated indexing for the user. This lets programmers focus on the logical descriptions of their algorithms while CuTe does the mechanical bookkeeping for them. With these tools, we can quickly design, implement, and modify all dense linear algebra operations.&lt;/p&gt; &#xA;&lt;p&gt;The core abstractions of CuTe are hierarchically multidimensional layouts which can be composed with data arrays to represent tensors. The representation of layouts is powerful enough to represent nearly everything we need to implement efficient dense linear algebra. Layouts can also be combined and manipulated via functional composition, on which we build a large set of common operations such as tiling and partitioning.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS 3.0 and beyond adopts CuTe throughout the GEMM hierarchy in its templates. This greatly simplifies the design and improves code composability and readability. More documentation specific to CuTe can be found in its &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/cute/00_quickstart.md&#34;&gt;dedicated documentation directory&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition to GEMMs, CUTLASS implements high-performance convolution via the implicit GEMM algorithm. Implicit GEMM is the formulation of a convolution operation as a GEMM thereby taking advantage of CUTLASS&#39;s modular GEMM pipeline. This allows CUTLASS to build convolutions by reusing highly-optimized GEMM components.&lt;/p&gt; &#xA;&lt;h1&gt;What&#39;s New in CUTLASS 3.1&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS 3.1 is an update to CUTLASS adding:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;New CUTLASS Python interface that aims to provide an ease-of-use interface for instantiating, emitting, compiling, and running CUTLASS kernels via Python. More details &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/python/README.md&#34;&gt;here&lt;/a&gt; and new &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/python&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;New &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/test/unit/gemm/device/sm90_gemm_f16_f16_f16_tensor_op_f32_cluster_warpspecialized_cooperative.cu#L783&#34;&gt;efficient epilogues&lt;/a&gt; using TMA for Hopper.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Support for &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/test/unit/gemm/device/sm90_gemm_f16_f16_f16_tensor_op_f32_cluster_warpspecialized_cooperative_bias_elementwise.cu&#34;&gt;fused epilogues&lt;/a&gt;, such Bias, ReLU and GELU, using the new efficient epilogues.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;New &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/test/unit/gemm/device/sm90_gemm_tf32_tf32_f32_tensor_op_f32_gmma_rs_cluster_warpspecialized.cu&#34;&gt;warp-specialized TensorFloat-32 (TF32) GEMM kernels&lt;/a&gt; targeting Hopper TMA.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;New &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/gemm/kernel/sm90_gemm_tma_warpspecialized_cooperative.hpp&#34;&gt;&lt;em&gt;warp-specialized persistent cooperative&lt;/em&gt;&lt;/a&gt; kernel design that improves performance on Hopper.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;An &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/51_hopper_gett&#34;&gt;example&lt;/a&gt; showcasing GEMM-Like Tensor-Tensor Contraction (GETT) capability on Hopper.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;New Epilogue builders. Similar to mainloop builders (see &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/49_hopper_gemm_with_collective_builder/49_collective_builder.cu&#34;&gt;example 49&lt;/a&gt;), epilogue builders aim to generate the best-possible epilogue while exposing incremental opt-ins for greater customization.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Profiler support for overriding kernel and epilogue builder auto schedules for 3.x API kernels, allowing specific policies to be run in the CUTLASS profiler.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Changes to the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/gemm_api_3x.md&#34;&gt;GEMM API 3.x&lt;/a&gt;, involving the host-facing arguments and the underlying &lt;code&gt;Params&lt;/code&gt; structs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/41_fused_multi_head_attention/fused_multi_head_attention_backward.cu&#34;&gt;FMHA Backward Pass&lt;/a&gt; from Meta xFormers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/47_ampere_gemm_universal_streamk/ampere_gemm_universal_streamk_broadcast.cu&#34;&gt;Streamk GEMM with Broadcast&lt;/a&gt; enables epilogue broadcast with StreamK GEMM.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/13_two_tensor_op_fusion&#34;&gt;Batched B2B GEMM&lt;/a&gt; now can run multiple Back-to-Back GEMM with the same problem size in parallel.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/test/unit/gemm/device/gemv.cu&#34;&gt;Batched Strided GEMV&lt;/a&gt; support both row major and column major input matrix.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples/39_gemm_permute&#34;&gt;Permute + GEMM fusion&lt;/a&gt; can fuse Permute with following GEMM now. Before, we only support fusing GEMM with Permute in the epilogue.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/include/cutlass/epilogue/threadblock/predicated_tile_iterator_row_broadcast.h&#34;&gt;Row Broadcast&lt;/a&gt; can be fused in the epilogue.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Announcement&lt;/em&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The GitHub branch is renamed from &lt;code&gt;master&lt;/code&gt; to &lt;code&gt;main&lt;/code&gt; in this release.&lt;/li&gt; &#xA;   &lt;li&gt;A slight modification has been made to the ordering of arguments passed in to epilogues in 3.x kernels. Existing CUTLASS 3.x kernel invocations will need to be modified to reflect this change. 2.x kernels remain unaffected. See &lt;a href=&#34;https://github.com/NVIDIA/cutlass/issues/890&#34;&gt;#890&lt;/a&gt; for additional information.&lt;/li&gt; &#xA;   &lt;li&gt;The CUTLASS Python interface supersedes PyCUTLASS. PyCUTLASS has been moved to &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/python/cutlass/backend&#34;&gt;/python/cutlass/backend&lt;/a&gt;. Backward compatibility between the Python interface and PyCUTLASS will not be maintained moving forward.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Minimum requirements:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Architecture: Volta&lt;/li&gt; &#xA; &lt;li&gt;Compiler: Must support at least C++17&lt;/li&gt; &#xA; &lt;li&gt;CUDA Toolkit version: 11.4&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Starting from CUTLASS 3.0, CUTLASS removed support for the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Maxwell and Pascal GPU architectures&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu 16.04&lt;/li&gt; &#xA; &lt;li&gt;CUDA 10.2&lt;/li&gt; &#xA; &lt;li&gt;C++ language versions less than 17.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for a detailed listing of releases and updates.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/cutlass-3.0-gemm-peak-performance.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS primitives are very efficient. When used to construct device-wide GEMM kernels, they exhibit peak performance comparable to cuBLAS for scalar GEMM computations. The above figure shows CUTLASS performance relative to cuBLAS for large matrix dimensions on an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/h100/&#34;&gt;NVIDIA H100&lt;/a&gt; (NVIDIA Hopper architecture), an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/l40/&#34;&gt;NVIDIA L40&lt;/a&gt; (NVIDIA Ada architecture), an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/a100/&#34;&gt;NVIDIA A100&lt;/a&gt; (NVIDIA Ampere architecture),&lt;br&gt; and an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/a40/&#34;&gt;NVIDIA A40&lt;/a&gt; (NVIDIA Ampere architecture). CUTLASS 3.0 was compiled with the &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 12.0 Toolkit&lt;/a&gt;. Tensor Core operations are implemented using CUDA&#39;s &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma&#34;&gt;mma&lt;/a&gt; and &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-instructions&#34;&gt;wgmma&lt;/a&gt; instructions.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/images/cutlass-2.9-implicit-gemm-performance.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When using CUTLASS building blocks to construct device-wide implicit gemm (Fprop, Dgrad, and Wgrad) kernels, CUTLASS performance is also comparable to cuDNN when running Resnet-50 layers on an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/a100/&#34;&gt;NVIDIA A100&lt;/a&gt; as shown in the above figure. Tensor Core operations are implemented using CUDA&#39;s &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma&#34;&gt;mma instruction&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS requires a C++17 host compiler and performs best when built with the &lt;a href=&#34;https://developer.nvidia.com/cuda-toolkit&#34;&gt;&lt;strong&gt;CUDA 12.1 Toolkit&lt;/strong&gt;&lt;/a&gt;. It is also compatible with CUDA 11.4, CUDA 11.5, CUDA 11.6, CUDA 11.7, CUDA 11.8, and CUDA 12.0.&lt;/p&gt; &#xA;&lt;h2&gt;Operating Systems&lt;/h2&gt; &#xA;&lt;p&gt;We have tested the following environments.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Operating System&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Compiler&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 18.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 7.5.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 20.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 10.3.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 22.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 11.2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note: We plan to add Windows (MSVC) &amp;amp; Clang compiler support soon. Note: GCC 8.5.0 has known regressions regarding fold expressions and overloaded operators. Using GCC 7.5.0 or (preferred) GCC &amp;gt;= 9 is recommended.&lt;/p&gt; &#xA;&lt;h2&gt;Hardware&lt;/h2&gt; &#xA;&lt;p&gt;CUTLASS runs successfully on the following NVIDIA GPUs, and it is expected to be efficient on Volta, Turing, Ampere, Ada, and Hopper architecture based NVIDIA GPUs.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;GPU&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;CUDA Compute Capability&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Minimum CUDA Toolkit Required by CUTLASS-3&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA V100 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;7.0&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA TitanV&lt;/td&gt; &#xA;   &lt;td&gt;7.0&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 2080 TI, 2080, 2070&lt;/td&gt; &#xA;   &lt;td&gt;7.5&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA T4&lt;/td&gt; &#xA;   &lt;td&gt;7.5&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA A100 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;8.0&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA A10&lt;/td&gt; &#xA;   &lt;td&gt;8.6&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 3090&lt;/td&gt; &#xA;   &lt;td&gt;8.6&lt;/td&gt; &#xA;   &lt;td&gt;11.4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 4090&lt;/td&gt; &#xA;   &lt;td&gt;8.9&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA L40&lt;/td&gt; &#xA;   &lt;td&gt;8.9&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA H100 Tensor Core GPU&lt;/td&gt; &#xA;   &lt;td&gt;9.0&lt;/td&gt; &#xA;   &lt;td&gt;11.8&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Target Architecture&lt;/h2&gt; &#xA;&lt;p&gt;In general, PTX code generated for one target architecture can be run on future architectures (i.e., it is forward compatible). However, CUDA 12.0 introduced the concept of &#34;architecture-accelerated features&#34; whose PTX does not have forward compatibility guarantees. Several Hopper PTX instructions fall under this category of architecture-accelerated features, and thus require a &lt;code&gt;sm_90a&lt;/code&gt; target architecture (note the &#34;a&#34; appended). For more details on this and other architecture-accelerated instructions, please refer to the &lt;a href=&#34;https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#feature-availability&#34;&gt;CUDA Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The target architecture information is passed on to CUTLASS via the cmake flag &lt;code&gt;CUTLASS_NVCC_ARCHS&lt;/code&gt;. In order to maximize performance on Hopper GH100, users are required to build CUTLASS with &lt;code&gt;90a&lt;/code&gt; as the target architecture. If a user accidentally builds a kernel which uses SM90a features (e.g. Hopper Tensor Core Instructions), using the SM90 target (note the lack of &#34;a&#34;), with either CTK 12 or 11.8, the kernel is expected to fail with a runtime error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake .. -DCUTLASS_NVCC_ARCHS=&#34;90a&#34; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;functionality documentation&lt;/a&gt; for details on which kernels require which target architectures.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is described in the following documents and the accompanying &lt;a href=&#34;https://nvidia.github.io/cutlass&#34;&gt;Doxygen documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quick Start Guide&lt;/a&gt; - build and run CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/functionality.md&#34;&gt;Functionality&lt;/a&gt; - summarizes functionality available in CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/efficient_gemm.md&#34;&gt;Efficient GEMM in CUDA&lt;/a&gt; - describes how GEMM kernels may be implemented efficiently in CUDA&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/cutlass_3x_design.md&#34;&gt;CUTLASS 3.x Design&lt;/a&gt; - describes the CUTLASS 3.x design, its benefits, and how CuTe enables us to write much more composable components&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/gemm_api_3x.md&#34;&gt;GEMM API 3.x&lt;/a&gt; - describes the CUTLASS 3.x GEMM model and C++ template concepts&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/gemm_api.md&#34;&gt;GEMM API 2.x&lt;/a&gt; - describes the CUTLASS 2.x GEMM model and C++ template concepts&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/implicit_gemm_convolution.md&#34;&gt;Implicit GEMM Convolution&lt;/a&gt; - describes 2-D and 3-D convolution in CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/code_organization.md&#34;&gt;Code Organization&lt;/a&gt; - describes the organization and contents of the CUTLASS project&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/terminology.md&#34;&gt;Terminology&lt;/a&gt; - describes terms used in the code&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/programming_guidelines.md&#34;&gt;Programming Guidelines&lt;/a&gt; - guidelines for writing efficient modern CUDA C++&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/fundamental_types.md&#34;&gt;Fundamental types&lt;/a&gt; - describes basic C++ classes used in CUTLASS to represent numeric quantities and arrays&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/layout.md&#34;&gt;Layouts&lt;/a&gt; - describes layouts of matrices and tensors in memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/tile_iterator_concept.md&#34;&gt;Tile Iterators&lt;/a&gt; - describes C++ concepts for iterating over tiles of matrices in memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/profiler.md&#34;&gt;CUTLASS Profiler&lt;/a&gt; - command-line driven profiling application&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/utilities.md&#34;&gt;CUTLASS Utilities&lt;/a&gt; - additional templates used to facilate rapid development&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Resources&lt;/h1&gt; &#xA;&lt;p&gt;We have also described the structure of an efficient GEMM in our talk at the &lt;a href=&#34;http://on-demand.gputechconf.com/gtc/2018/presentation/s8854-cutlass-software-primitives-for-dense-linear-algebra-at-all-levels-and-scales-within-cuda.pdf&#34;&gt;GPU Technology Conference 2018&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcsiliconvalley2018-s8854/&#34;&gt;CUTLASS: Software Primitives for Dense Linear Algebra at All Levels and Scales within CUDA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcsj20-s21745/&#34;&gt;Developing CUDA Kernels to Push Tensor Cores to the Absolute Limit on NVIDIA A100&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcspring21-s31883/&#34;&gt;Accelerating Convolution with Tensor Cores in CUTLASS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcspring22-s41996/&#34;&gt;Accelerating Backward Data Gradient by Increasing Tensor Core Utilization in CUTLASS&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/on-demand/session/gtcfall22-a41131/&#34;&gt;CUTLASS: Python API, Enhancements, and NVIDIA Hopper&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Building CUTLASS&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is a header-only template library and does not need to be built to be used by other projects. Client applications should target CUTLASS&#39;s &lt;code&gt;include/&lt;/code&gt; directory in their include paths.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS unit tests, examples, and utilities can be build with CMake starting version 3.12. Make sure the &lt;code&gt;CUDACXX&lt;/code&gt; environment variable points to NVCC in the CUDA Toolkit installed on your system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export CUDACXX=${CUDA_INSTALL_PATH}/bin/nvcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a build directory within the CUTLASS project, then run CMake. By default CUTLASS will build kernels for CUDA architecture versions 5.0, 6.0, 6.1, 7.0, 7.5, 8.0, 8.6, 8.9, and 9.0. To reduce compile time you can specify the architectures to build CUTLASS for by changing the CMake configuration setting &lt;code&gt;CUTLASS_NVCC_ARCHS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir build &amp;amp;&amp;amp; cd build&#xA;&#xA;$ cmake .. -DCUTLASS_NVCC_ARCHS=80               # compiles for NVIDIA&#39;s Ampere Architecture&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From the &lt;code&gt;build/&lt;/code&gt; directory, compile and run the CUTLASS unit tests by building the target &lt;code&gt;test_unit&lt;/code&gt; with make.&lt;/p&gt; &#xA;&lt;p&gt;The unit tests are organized as several binaries mirroring the top-level namespaces of CUTLASS, and they may be executed in parallel via make&#39;s &lt;code&gt;-j&lt;/code&gt; command line argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make test_unit -j&#xA;...&#xA;...&#xA;...&#xA;[----------] Global test environment tear-down&#xA;[==========] 946 tests from 57 test cases ran. (10812 ms total)&#xA;[  PASSED  ] 946 tests.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All tests should pass on supported platforms, though the exact number of tests may vary over time.&lt;/p&gt; &#xA;&lt;h1&gt;Project Structure&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is arranged as a header-only library along with Utilities, Tools, Examples, and unit tests. &lt;a href=&#34;https://nvidia.github.io/cutlass&#34;&gt;Doxygen documentation&lt;/a&gt; provides a complete list of files, classes, and template concepts defined in the CUTLASS project.&lt;/p&gt; &#xA;&lt;p&gt;A detailed explanation of the source code organization may be found in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/code_organization.md&#34;&gt;CUTLASS documentation&lt;/a&gt;, but several main components are summarized below.&lt;/p&gt; &#xA;&lt;h2&gt;CUTLASS Template Library&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;include/                     # client applications should target this directory in their build&#39;s include paths&#xA;&#xA;  cutlass/                   # CUDA Templates for Linear Algebra Subroutines and Solvers - headers only&#xA;&#xA;    arch/                    # direct exposure of architecture features (including instruction-level GEMMs)&#xA;&#xA;    conv/                    # code specialized for convolution&#xA;&#xA;    epilogue/                # code specialized for the epilogue of gemm/convolution&#xA;&#xA;    gemm/                    # code specialized for general matrix product computations&#xA;&#xA;    layout/                  # layout definitions for matrices, tensors, and other mathematical objects in memory&#xA;&#xA;    platform/                # CUDA-capable Standard Library components&#xA;&#xA;    reduction/               # bandwidth-limited reduction kernels that do not fit the &#34;gemm&#34; model&#xA;&#xA;    thread/                  # simt code that can be performed within a CUDA thread&#xA;    &#xA;    transform/               # code specialized for layout, type, and domain transformations&#xA;&#xA;    *                        # core vocabulary types, containers, and basic numeric operations&#xA;&#xA;  cute/                      # CuTe Layout, layout algebra, MMA/Copy atoms, tiled MMA/Copy&#xA;&#xA;    algorithm/               # Definitions of core operations such as copy, gemm, and operations on cute::tuples&#xA;&#xA;    arch/                    # Bare bones PTX wrapper structs for copy and math instructions&#xA;&#xA;    atom/                    # Meta-information either link to or built from arch/ operators&#xA;&#xA;      mma_atom.hpp           # cute::Mma_Atom and cute::TiledMma&#xA;&#xA;      copy_atom.hpp          # cute::Copy_Atom and cute::TiledCopy&#xA;&#xA;      *sm*.hpp               # Arch specific meta-information for copy and math operations&#xA;&#xA;    *                        # Core library types such as Shape, Stride, Layout, Tensor, and associated operations&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CUTLASS SDK Examples&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/examples&#34;&gt;CUTLASS SDK examples&lt;/a&gt; apply CUTLASS templates to implement basic computations.&lt;/p&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;tools/&#xA;  library/                   # CUTLASS Instance Library - contains instantiations of all supported CUTLASS templates&#xA;    include/&#xA;      cutlass/&#xA;        library/&#xA;&#xA;  profiler/                  # CUTLASS Profiler         - command-line utility for executing operations in the&#xA;                             #                            CUTLASS Library&#xA;  &#xA;  util/                      # CUTLASS Utilities        - contains numerous helper classes for&#xA;    include/                 #                            manging tensors in device memory, reference&#xA;      cutlass/               #                            implementations for GEMM, random initialization&#xA;        util/                #                            of tensors, and I/O.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;test/unit/&lt;/code&gt; directory consist of unit tests implemented with Google Test that demonstrate basic usage of Core API components and complete tests of the CUTLASS GEMM computations.&lt;/p&gt; &#xA;&lt;p&gt;Instructions for building and running the Unit tests are described in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md&#34;&gt;Quickstart guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Performance Profiling&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;code&gt;tools/profiler/&lt;/code&gt; directory contains a command-line utility for launching each of the GEMM kernels. It can be built as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building all GEMM and Convolution kernels (&lt;em&gt;long&lt;/em&gt; build times)&lt;/h2&gt; &#xA;&lt;p&gt;By default, only one tile size is instantiated for each data type, math instruction, and layout. To instantiate all, set the following environment variable when running CMake from an empty &lt;code&gt;build/&lt;/code&gt; directory. Beware, this results in &lt;em&gt;tens of thousands&lt;/em&gt; of kernels and long build times. This would also result in a large binary size and on some platforms linker to fail on building the library. Therefore, it&#39;s highly recommended to generate only a subset of kernels as demonstrated in the sub-section below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=90a -DCUTLASS_LIBRARY_KERNELS=all&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building a subset of GEMM and Convolution kernels (&lt;em&gt;reduced&lt;/em&gt; build times)&lt;/h2&gt; &#xA;&lt;p&gt;To compile strictly one kernel or a small set of kernels, a comma-delimited list of kernel names with wildcard characters may be used to reduce the set of kernels. The following examples show building exactly one or a subset of kernels for NVIDIA Ampere and Turing architecture:&lt;/p&gt; &#xA;&lt;h3&gt;Building a subset Tensor Core GEMM kernels&lt;/h3&gt; &#xA;&lt;p&gt;To compile a subset of Tensor Core GEMM kernels with FP32 accumulation and FP16 input targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_tensorop_s*gemm_f16_*_nt_align8&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling a subset of Tensor Core GEMM kernels is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./tools/profiler/cutlass_profiler --kernels=cutlass_tensorop_s*gemm_f16_*_nt_align8 --m=3456 --n=4096 --k=4096&#xA;&#xA;...&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: gemm&#xA;       Operation: cutlass_tensorop_s1688gemm_f16_256x128_32x2_nt_align8&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;          cuBLAS: Passed&#xA;&#xA;       Arguments: --gemm_kind=universal --m=3456 --n=4096 --k=4096 --A=f16:column --B=f16:row --C=f32:column --alpha=1  \&#xA;                  --beta=0 --split_k_slices=1 --batch_count=1 --op_class=tensorop --accum=f32 --cta_m=256 --cta_n=128  \&#xA;                  --cta_k=32 --stages=2 --warps_m=4 --warps_n=2 --warps_k=1 --inst_m=16 --inst_n=8 --inst_k=8 --min_cc=75  \&#xA;                  --max_cc=1024&#xA;&#xA;           Bytes: 118489088  bytes&#xA;           FLOPs: 115992428544  flops&#xA;&#xA;         Runtime: 1.55948  ms&#xA;          Memory: 70.7616 GiB/s&#xA;&#xA;            Math: 74378.8 GFLOP/s&#xA;&#xA;&#xA;&#xA;=============================&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building one CUDA Core GEMM kernel&lt;/h3&gt; &#xA;&lt;p&gt;To compile one SGEMM kernel targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_simt_sgemm_128x128_8x2_nn_align1&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling single SGEMM CUDA kernel is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=sgemm --m=3456 --n=4096 --k=4096&#xA;&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: gemm&#xA;       Operation: cutlass_simt_sgemm_128x128_8x2_nn_align1&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;          cuBLAS: Passed&#xA;&#xA;       Arguments: --m=3456 --n=4096 --k=4096 --A=f32:column --B=f32:column --C=f32:column --alpha=1 --beta=0 --split_k_slices=1  \&#xA;                  --batch_count=1 --op_class=simt --accum=f32 --cta_m=128 --cta_n=128 --cta_k=8 --stages=2 --warps_m=4  \&#xA;                  --warps_n=2 --warps_k=1 --inst_m=1 --inst_n=1 --inst_k=1 --min_cc=50 --max_cc=1024&#xA;&#xA;           Bytes: 180355072  bytes&#xA;           FLOPs: 115992428544  flops&#xA;&#xA;         Runtime: 6.73655  ms&#xA;          Memory: 24.934 GiB/s&#xA;&#xA;            Math: 17218.4 GFLOP/s&#xA;&#xA;=============================&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building a subset of Tensor Core Convolution kernels&lt;/h3&gt; &#xA;&lt;p&gt;To compile a subset of Tensor core convolution kernels implementing forward propagation (fprop) with FP32 accumulation and FP16 input targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_tensorop_s*fprop_optimized_f16&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling a subset of Tensor Core convolution kernels is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=cutlass_tensorop_s*fprop_optimized_f16 --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3&#xA;&#xA;...&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: conv2d&#xA;       Operation: cutlass_tensorop_s16816fprop_optimized_f16_128x128_32x5_nhwc&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;&#xA;       Arguments: --conv_kind=fprop --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3 --p=224 --q=224 --pad_h=1 --pad_w=1  \&#xA;                  --stride_h=1 --stride_w=1 --dilation_h=1 --dilation_w=1 --Activation=f16:nhwc --Filter=f16:nhwc --Output=f32:nhwc  \&#xA;                  --conv_mode=cross --iterator_algorithm=optimized --alpha=1 --beta=0 --split_k_mode=serial --split_k_slices=1  \&#xA;                  --eq_gemm_provider=none --op_class=tensorop --accum=f32 --cta_m=128 --cta_n=128 --cta_k=32 --stages=5  \&#xA;                  --warps_m=2 --warps_n=2 --warps_k=1 --inst_m=16 --inst_n=8 --inst_k=16 --min_cc=80 --max_cc=1024&#xA;&#xA;           Bytes: 1130659840  bytes&#xA;           FLOPs: 118482796544  flops&#xA;&#xA;         Runtime: 0.711496  ms&#xA;          Memory: 1479.99 GiB/s&#xA;&#xA;            Math: 166526 GFLOP/s&#xA;&#xA;=============================&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building one Convolution CUDA kernel&lt;/h3&gt; &#xA;&lt;p&gt;To compile and run one CUDA Core convolution kernel implementing forward propagation (fprop) with F32 accumulation and FP32 input targeting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_simt_sfprop_optimized_128x128_8x2_nhwc&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling one CUDA Core convolution kernel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=cutlass_simt_sfprop_optimized_128x128_8x2_nhwc --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3&#xA;&#xA;&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: conv2d&#xA;       Operation: cutlass_simt_sfprop_optimized_128x128_8x2_nhwc&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;&#xA;       Arguments: --conv_kind=fprop --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3 --p=224 --q=224 --pad_h=1 --pad_w=1  \&#xA;                  --stride_h=1 --stride_w=1 --dilation_h=1 --dilation_w=1 --Activation=f32:nhwc --Filter=f32:nhwc --Output=f32:nhwc  \&#xA;                  --conv_mode=cross --iterator_algorithm=optimized --alpha=1 --beta=0 --split_k_mode=serial --split_k_slices=1  \&#xA;                  --eq_gemm_provider=none --op_class=simt --accum=f32 --cta_m=128 --cta_n=128 --cta_k=8 --stages=2 --warps_m=4  \&#xA;                  --warps_n=2 --warps_k=1 --inst_m=1 --inst_n=1 --inst_k=1 --min_cc=50 --max_cc=1024&#xA;&#xA;           Bytes: 2055798784  bytes&#xA;           FLOPs: 118482796544  flops&#xA;&#xA;         Runtime: 7.34266  ms&#xA;          Memory: 260.752 GiB/s&#xA;&#xA;            Math: 16136.2 GFLOP/s&#xA;&#xA;&#xA;=============================&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More Details on Compiling CUTLASS Kernels and CUTLASS Profiler&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please follow the links for more CMake examples on selectively compiling CUTLASS kernels: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md#gemm-cmake-examples&#34;&gt;GEMM CMake Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/quickstart.md#convolution-cmake-examples&#34;&gt;Implicit GEMM conovlution CMake Examples&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/media/docs/profiler.md&#34;&gt;Further details about the CUTLASS Profiler are described here.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is released by NVIDIA Corporation as Open Source software under the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/LICENSE.txt&#34;&gt;3-clause &#34;New&#34; BSD license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;The official list of CUTLASS developers and contributors is available here: &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/main/CONTRIBUTORS.md&#34;&gt;CONTRIBUTORS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Copyright&lt;/h1&gt; &#xA;&lt;p&gt;Copyright (c) 2017 - 2023 NVIDIA CORPORATION &amp;amp; AFFILIATES. All rights reserved. SPDX-License-Identifier: BSD-3-Clause&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  Redistribution and use in source and binary forms, with or without&#xA;  modification, are permitted provided that the following conditions are met:&#xA;&#xA;  1. Redistributions of source code must retain the above copyright notice, this&#xA;  list of conditions and the following disclaimer.&#xA;&#xA;  2. Redistributions in binary form must reproduce the above copyright notice,&#xA;  this list of conditions and the following disclaimer in the documentation&#xA;  and/or other materials provided with the distribution.&#xA;&#xA;  3. Neither the name of the copyright holder nor the names of its&#xA;  contributors may be used to endorse or promote products derived from&#xA;  this software without specific prior written permission.&#xA;&#xA;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;&#xA;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&#xA;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&#xA;  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE&#xA;  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&#xA;  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&#xA;  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER&#xA;  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&#xA;  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&#xA;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>Tencent/rapidjson</title>
    <updated>2023-05-28T01:55:06Z</updated>
    <id>tag:github.com,2023-05-28:/Tencent/rapidjson</id>
    <link href="https://github.com/Tencent/rapidjson" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast JSON parser/generator for C++ with both SAX/DOM style API&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/logo/rapidjson.png&#34; alt=&#34;RapidJSON logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/release-v1.1.0-blue.svg?sanitize=true&#34; alt=&#34;Release version&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;A fast JSON parser/generator for C++ with both SAX/DOM style API&lt;/h2&gt; &#xA;&lt;p&gt;Tencent is pleased to support the open source community by making RapidJSON available.&lt;/p&gt; &#xA;&lt;p&gt;Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/&#34;&gt;RapidJSON GitHub&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;RapidJSON Documentation &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://rapidjson.org/&#34;&gt;English&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://rapidjson.org/zh-cn/&#34;&gt;简体中文&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.gitbook.com/book/miloyip/rapidjson/&#34;&gt;GitBook&lt;/a&gt; with downloadable PDF/EPUB/MOBI, without API reference.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build status&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://travis-ci.org/Tencent/rapidjson&#34; title=&#34;Travis build status&#34;&gt;Linux&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://ci.appveyor.com/project/miloyip/rapidjson-0fdqj/branch/master&#34; title=&#34;AppVeyor build status&#34;&gt;Windows&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://coveralls.io/r/Tencent/rapidjson?branch=master&#34; title=&#34;Coveralls coverage&#34;&gt;Coveralls&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://travis-ci.org/Tencent/rapidjson.svg?branch=master&#34; alt=&#34;lin-badge&#34; title=&#34;Travis build status&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/l6qulgqahcayidrf/branch/master?svg=true&#34; alt=&#34;win-badge&#34; title=&#34;AppVeyor build status&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/Tencent/rapidjson/badge.svg?branch=master&#34; alt=&#34;cov-badge&#34; title=&#34;Coveralls coverage&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;RapidJSON is a JSON parser and generator for C++. It was inspired by &lt;a href=&#34;http://rapidxml.sourceforge.net/&#34;&gt;RapidXml&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;RapidJSON is &lt;strong&gt;small&lt;/strong&gt; but &lt;strong&gt;complete&lt;/strong&gt;. It supports both SAX and DOM style API. The SAX parser is only a half thousand lines of code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RapidJSON is &lt;strong&gt;fast&lt;/strong&gt;. Its performance can be comparable to &lt;code&gt;strlen()&lt;/code&gt;. It also optionally supports SSE2/SSE4.2 for acceleration.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RapidJSON is &lt;strong&gt;self-contained&lt;/strong&gt; and &lt;strong&gt;header-only&lt;/strong&gt;. It does not depend on external libraries such as BOOST. It even does not depend on STL.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RapidJSON is &lt;strong&gt;memory-friendly&lt;/strong&gt;. Each JSON value occupies exactly 16 bytes for most 32/64-bit machines (excluding text string). By default it uses a fast memory allocator, and the parser allocates memory compactly during parsing.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RapidJSON is &lt;strong&gt;Unicode-friendly&lt;/strong&gt;. It supports UTF-8, UTF-16, UTF-32 (LE &amp;amp; BE), and their detection, validation and transcoding internally. For example, you can read a UTF-8 file and let RapidJSON transcode the JSON strings into UTF-16 in the DOM. It also supports surrogates and &#34;\u0000&#34; (null character).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More features can be read &lt;a href=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/features.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;JSON(JavaScript Object Notation) is a light-weight data exchange format. RapidJSON should be in full compliance with RFC7159/ECMA-404, with optional support of relaxed syntax. More information about JSON can be obtained at&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://json.org/&#34;&gt;Introducing JSON&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34;&gt;RFC7159: The JavaScript Object Notation (JSON) Data Interchange Format&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.ecma-international.org/publications/standards/Ecma-404.htm&#34;&gt;Standard ECMA-404: The JSON Data Interchange Format&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Highlights in v1.1 (2016-8-25)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Added &lt;a href=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/pointer.md&#34;&gt;JSON Pointer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Added &lt;a href=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/schema.md&#34;&gt;JSON Schema&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Added &lt;a href=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/dom.md&#34;&gt;relaxed JSON syntax&lt;/a&gt; (comment, trailing comma, NaN/Infinity)&lt;/li&gt; &#xA; &lt;li&gt;Iterating array/object with &lt;a href=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/tutorial.md&#34;&gt;C++11 Range-based for loop&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Reduce memory overhead of each &lt;code&gt;Value&lt;/code&gt; from 24 bytes to 16 bytes in x86-64 architecture.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For other changes please refer to &lt;a href=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/CHANGELOG.md&#34;&gt;change log&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;RapidJSON is cross-platform. Some platform/compiler combinations which have been tested are shown as follows.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Visual C++ 2008/2010/2013 on Windows (32/64-bit)&lt;/li&gt; &#xA; &lt;li&gt;GNU C++ 3.8.x on Cygwin&lt;/li&gt; &#xA; &lt;li&gt;Clang 3.4 on Mac OS X (32/64-bit) and iOS&lt;/li&gt; &#xA; &lt;li&gt;Clang 3.4 on Android NDK&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Users can build and run the unit tests on their platform/compiler.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;RapidJSON is a header-only C++ library. Just copy the &lt;code&gt;include/rapidjson&lt;/code&gt; folder to system or project&#39;s include path.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, if you are using the &lt;a href=&#34;https://github.com/Microsoft/vcpkg/&#34;&gt;vcpkg&lt;/a&gt; dependency manager you can download and install rapidjson with CMake integration in a single command:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;vcpkg install rapidjson&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;RapidJSON uses following software as its dependencies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; as a general build tool&lt;/li&gt; &#xA; &lt;li&gt;(optional) &lt;a href=&#34;http://www.doxygen.org&#34;&gt;Doxygen&lt;/a&gt; to build documentation&lt;/li&gt; &#xA; &lt;li&gt;(optional) &lt;a href=&#34;https://github.com/google/googletest&#34;&gt;googletest&lt;/a&gt; for unit and performance testing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To generate user documentation and run tests please proceed with the steps below:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Execute &lt;code&gt;git submodule update --init&lt;/code&gt; to get the files of thirdparty submodules (google test).&lt;/li&gt; &#xA; &lt;li&gt;Create directory called &lt;code&gt;build&lt;/code&gt; in rapidjson source directory.&lt;/li&gt; &#xA; &lt;li&gt;Change to &lt;code&gt;build&lt;/code&gt; directory and run &lt;code&gt;cmake ..&lt;/code&gt; command to configure your build. Windows users can do the same with cmake-gui application.&lt;/li&gt; &#xA; &lt;li&gt;On Windows, build the solution found in the build directory. On Linux, run &lt;code&gt;make&lt;/code&gt; from the build directory.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On successful build you will find compiled test and example binaries in &lt;code&gt;bin&lt;/code&gt; directory. The generated documentation will be available in &lt;code&gt;doc/html&lt;/code&gt; directory of the build tree. To run tests after finished build please run &lt;code&gt;make test&lt;/code&gt; or &lt;code&gt;ctest&lt;/code&gt; from your build tree. You can get detailed output using &lt;code&gt;ctest -V&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to install library system-wide by running &lt;code&gt;make install&lt;/code&gt; command from the build tree with administrative privileges. This will install all files according to system preferences. Once RapidJSON is installed, it is possible to use it from other CMake projects by adding &lt;code&gt;find_package(RapidJSON)&lt;/code&gt; line to your CMakeLists.txt.&lt;/p&gt; &#xA;&lt;h2&gt;Usage at a glance&lt;/h2&gt; &#xA;&lt;p&gt;This simple example parses a JSON string into a document (DOM), make a simple modification of the DOM, and finally stringify the DOM to a JSON string.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// rapidjson/example/simpledom/simpledom.cpp`&#xA;#include &#34;rapidjson/document.h&#34;&#xA;#include &#34;rapidjson/writer.h&#34;&#xA;#include &#34;rapidjson/stringbuffer.h&#34;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;&#xA;using namespace rapidjson;&#xA;&#xA;int main() {&#xA;    // 1. Parse a JSON string into DOM.&#xA;    const char* json = &#34;{\&#34;project\&#34;:\&#34;rapidjson\&#34;,\&#34;stars\&#34;:10}&#34;;&#xA;    Document d;&#xA;    d.Parse(json);&#xA;&#xA;    // 2. Modify it by DOM.&#xA;    Value&amp;amp; s = d[&#34;stars&#34;];&#xA;    s.SetInt(s.GetInt() + 1);&#xA;&#xA;    // 3. Stringify the DOM&#xA;    StringBuffer buffer;&#xA;    Writer&amp;lt;StringBuffer&amp;gt; writer(buffer);&#xA;    d.Accept(writer);&#xA;&#xA;    // Output {&#34;project&#34;:&#34;rapidjson&#34;,&#34;stars&#34;:11}&#xA;    std::cout &amp;lt;&amp;lt; buffer.GetString() &amp;lt;&amp;lt; std::endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this example did not handle potential errors.&lt;/p&gt; &#xA;&lt;p&gt;The following diagram shows the process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Tencent/rapidjson/master/doc/diagram/simpledom.png&#34; alt=&#34;simpledom&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;More &lt;a href=&#34;https://github.com/Tencent/rapidjson/tree/master/example&#34;&gt;examples&lt;/a&gt; are available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;DOM API&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/tutorial/tutorial.cpp&#34;&gt;tutorial&lt;/a&gt;: Basic usage of DOM API.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;SAX API&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/simplereader/simplereader.cpp&#34;&gt;simplereader&lt;/a&gt;: Dumps all SAX events while parsing a JSON by &lt;code&gt;Reader&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/condense/condense.cpp&#34;&gt;condense&lt;/a&gt;: A command line tool to rewrite a JSON, with all whitespaces removed.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/pretty/pretty.cpp&#34;&gt;pretty&lt;/a&gt;: A command line tool to rewrite a JSON with indents and newlines by &lt;code&gt;PrettyWriter&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/capitalize/capitalize.cpp&#34;&gt;capitalize&lt;/a&gt;: A command line tool to capitalize strings in JSON.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/messagereader/messagereader.cpp&#34;&gt;messagereader&lt;/a&gt;: Parse a JSON message with SAX API.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/serialize/serialize.cpp&#34;&gt;serialize&lt;/a&gt;: Serialize a C++ object into JSON with SAX API.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/jsonx/jsonx.cpp&#34;&gt;jsonx&lt;/a&gt;: Implements a &lt;code&gt;JsonxWriter&lt;/code&gt; which stringify SAX events into &lt;a href=&#34;https://www-01.ibm.com/support/knowledgecenter/SS9H2Y_7.1.0/com.ibm.dp.doc/json_jsonx.html&#34;&gt;JSONx&lt;/a&gt; (a kind of XML) format. The example is a command line tool which converts input JSON into JSONx format.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Schema&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/schemavalidator/schemavalidator.cpp&#34;&gt;schemavalidator&lt;/a&gt; : A command line tool to validate a JSON with a JSON schema.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Advanced&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/prettyauto/prettyauto.cpp&#34;&gt;prettyauto&lt;/a&gt;: A modified version of &lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/pretty/pretty.cpp&#34;&gt;pretty&lt;/a&gt; to automatically handle JSON with any UTF encodings.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/parsebyparts/parsebyparts.cpp&#34;&gt;parsebyparts&lt;/a&gt;: Implements an &lt;code&gt;AsyncDocumentParser&lt;/code&gt; which can parse JSON in parts, using C++11 thread.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/filterkey/filterkey.cpp&#34;&gt;filterkey&lt;/a&gt;: A command line tool to remove all values with user-specified key.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/raw/master/example/filterkeydom/filterkeydom.cpp&#34;&gt;filterkeydom&lt;/a&gt;: Same tool as above, but it demonstrates how to use a generator to populate a &lt;code&gt;Document&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;RapidJSON welcomes contributions. When contributing, please follow the code below.&lt;/p&gt; &#xA;&lt;h3&gt;Issues&lt;/h3&gt; &#xA;&lt;p&gt;Feel free to submit issues and enhancement requests.&lt;/p&gt; &#xA;&lt;p&gt;Please help us by providing &lt;strong&gt;minimal reproducible examples&lt;/strong&gt;, because source code is easier to let other people understand what happens. For crash problems on certain platforms, please bring stack dump content with the detail of the OS, compiler, etc.&lt;/p&gt; &#xA;&lt;p&gt;Please try breakpoint debugging first, tell us what you found, see if we can start exploring based on more information been prepared.&lt;/p&gt; &#xA;&lt;h3&gt;Workflow&lt;/h3&gt; &#xA;&lt;p&gt;In general, we follow the &#34;fork-and-pull&#34; Git workflow.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fork&lt;/strong&gt; the repo on GitHub&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Clone&lt;/strong&gt; the project to your own machine&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Checkout&lt;/strong&gt; a new branch on your fork, start developing on the branch&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Test&lt;/strong&gt; the change before commit, Make sure the changes pass all the tests, including &lt;code&gt;unittest&lt;/code&gt; and &lt;code&gt;preftest&lt;/code&gt;, please add test case for each new feature or bug-fix if needed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Commit&lt;/strong&gt; changes to your own branch&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Push&lt;/strong&gt; your work back up to your fork&lt;/li&gt; &#xA; &lt;li&gt;Submit a &lt;strong&gt;Pull request&lt;/strong&gt; so that we can review your changes&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;NOTE: Be sure to merge the latest from &#34;upstream&#34; before making a pull request!&lt;/p&gt; &#xA;&lt;h3&gt;Copyright and Licensing&lt;/h3&gt; &#xA;&lt;p&gt;You can copy and paste the license summary from below.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Tencent is pleased to support the open source community by making RapidJSON available.&#xA;&#xA;Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip.&#xA;&#xA;Licensed under the MIT License (the &#34;License&#34;); you may not use this file except&#xA;in compliance with the License. You may obtain a copy of the License at&#xA;&#xA;http://opensource.org/licenses/MIT&#xA;&#xA;Unless required by applicable law or agreed to in writing, software distributed &#xA;under the License is distributed on an &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR &#xA;CONDITIONS OF ANY KIND, either express or implied. See the License for the &#xA;specific language governing permissions and limitations under the License.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>