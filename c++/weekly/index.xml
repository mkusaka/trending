<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-21T01:49:01Z</updated>
  <subtitle>Weekly Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SysSec-KAIST/LTESniffer</title>
    <updated>2023-05-21T01:49:01Z</updated>
    <id>tag:github.com,2023-05-21:/SysSec-KAIST/LTESniffer</id>
    <link href="https://github.com/SysSec-KAIST/LTESniffer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An Open-source LTE Downlink/Uplink Eavesdropper&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LTESniffer - An Open-source LTE Downlink/Uplink Eavesdropper&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;LTESniffer&lt;/strong&gt; is An Open-source LTE Downlink/Uplink Eavesdropper&lt;/p&gt; &#xA;&lt;p&gt;It first decodes the Physical Downlink Control Channel (PDCCH) to obtain the Downlink Control Informations (DCIs) and Radio Network Temporary Identifiers (RNTIs) of all active users. Using decoded DCIs and RNTIs, LTESniffer further decodes the Physical Downlink Shared Channel (PDSCH) and Physical Uplink Shared Channel (PUSCH) to retrieve uplink and downlink data traffic.&lt;/p&gt; &#xA;&lt;p&gt;LTESniffer supports an API with three functions for security applications and research. Many LTE security research assumes a passive sniffer that can capture privacy-related packets on the air. However, non of the current open-source sniffers satisfy their requirements as they cannot decode protocol packets in PDSCH and PUSCH. We developed a proof-of-concept security API that supports three tasks that were proposed by previous works: 1) Identity mapping, 2) IMSI collecting, and 3) Capability profiling.&lt;/p&gt; &#xA;&lt;p&gt;Please refer to our &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2023/wisec2023_tuan.pdf&#34;&gt;paper&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;LTESniffer in layman&#39;s terms&lt;/h2&gt; &#xA;&lt;p&gt;LTESniffer is a tool that can capture the LTE wireless messages that are sent between a cell tower and smartphones connected to it. LTESniffer supports capturing the messages in both directions, from the tower to the smartphones, and from the smartphones back to the cell tower.&lt;/p&gt; &#xA;&lt;p&gt;LTESniffer can &lt;strong&gt;NOT DECRYPT&lt;/strong&gt; encrypted messages between the cell tower and smartphones. It can be used for analyzing unencrypted parts of the communication between the cell tower and smartphones. For example, for encrypted messages, it can allow the user to analyze unencrypted parts, such as headers in MAC and physical layers. However, those messages sent in plaintext can be completely analyzable. For example, the broadcast messages sent by the cell tower, or the messages at the beginning of the connection are completely visible.&lt;/p&gt; &#xA;&lt;h2&gt;Ethical Consideration&lt;/h2&gt; &#xA;&lt;p&gt;The main purpose of LTESniffer is to support security and analysis research on the cellular network. Due to the collection of uplink-downlink user data, any use of LTESniffer must follow the local regulations on sniffing the LTE traffic. We are not responsible for any illegal purposes such as intentionally collecting user privacy-related information.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;LTESniffer is implemented on top of &lt;a href=&#34;https://github.com/falkenber9/falcon&#34;&gt;FALCON&lt;/a&gt; with the help of &lt;a href=&#34;https://github.com/srsran/srsRAN_4G&#34;&gt;srsRAN&lt;/a&gt; library. LTESniffer supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Real-time decoding LTE uplink-downlink control-data channels: PDCCH, PDSCH, PUSCH&lt;/li&gt; &#xA; &lt;li&gt;LTE Advanced and LTE Advanced Pro, up to 256QAM in both uplink and downlink&lt;/li&gt; &#xA; &lt;li&gt;DCI formats: 0, 1A, 1, 1B, 1C, 2, 2A, 2B&lt;/li&gt; &#xA; &lt;li&gt;Transmission modes: 1, 2, 3, 4&lt;/li&gt; &#xA; &lt;li&gt;FDD only&lt;/li&gt; &#xA; &lt;li&gt;Maximum 20 MHz base station.&lt;/li&gt; &#xA; &lt;li&gt;Automatically detect maximum UL/DL modulation schemes of smartphones (64QAM/256QAM on DL and 16QAM/64QAM/256QAM on UL)&lt;/li&gt; &#xA; &lt;li&gt;Automatically detect physical layer configuration per UE.&lt;/li&gt; &#xA; &lt;li&gt;LTE Security API: RNTI-TMSI mapping, IMSI collecting, UECapability Profiling.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Hardware and Software Requirement&lt;/h2&gt; &#xA;&lt;h3&gt;OS Requirement&lt;/h3&gt; &#xA;&lt;p&gt;Currently, LTESniffer works stably on Ubuntu 18.04/20.04.&lt;/p&gt; &#xA;&lt;h3&gt;Hardware Requirement&lt;/h3&gt; &#xA;&lt;p&gt;Achieving real-time decoding of LTE traffic requires a high-performance CPU with multiple physical cores. Especially when the base station has many active users during the peak hour. LTESniffer was able to achieve real-time decoding when running on an Intel i7-9700K PC to decode traffic on a base station with 150 active users.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;The following hardware is recommended&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel i7 CPU with at least 8 physical cores&lt;/li&gt; &#xA; &lt;li&gt;At least 16Gb RAM&lt;/li&gt; &#xA; &lt;li&gt;256 Gb SSD storage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;SDR&lt;/h3&gt; &#xA;&lt;p&gt;Currently, LTESniffer requires USRP X310 with 2 daughterboards, especially when sniffing the uplink traffic. This is because sniffing the uplink traffic requires precise time synchronization between uplink and downlink subframes, which can be achieved by using two daughterboards with the same clock source from a single motherboard of USRP X310. Also, the &#34;srsran_rf_set_rx_freq&#34; function used by LTESniffer seems to only support the USRP X310 with 2 daughterboards for simultaneous reception of signals at two different frequencies. The function might not work with USRP X310 equipped with a single TwinRX daughterboard. The USRP X310 should be equipped with GPSDO to maintain stable synchronization. Additionally, two RX antennas are required to enable LTESniffer to decode downlink messages in transmission modes 3 and 4.&lt;/p&gt; &#xA;&lt;p&gt;To sniff only downlink traffic from the base station, one can operate LTESniffer with USRP B210 which is connected to PC via a USB 3.0 port. Similarly, USRB B210 should be equipped with GPSDO and two RX antennas to decode downlink messages in transmission modes 3 and 4.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important note: To avoid unexpected errors, please follow the following steps on Ubuntu 18.04/20.04.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dependencies&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Important dependency&lt;/strong&gt;: &lt;a href=&#34;https://github.com/EttusResearch/uhd&#34;&gt;UHD&lt;/a&gt; library version &amp;gt;= 4.0 must be installed in advance (recommend building from source). The following steps can be used on Ubuntu 18.04. Refer to UHD Manual for full installation guidance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;UHD dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update&#xA;sudo apt-get install autoconf automake build-essential ccache cmake cpufrequtils doxygen ethtool \&#xA;g++ git inetutils-tools libboost-all-dev libncurses5 libncurses5-dev libusb-1.0-0 libusb-1.0-0-dev \&#xA;libusb-dev python3-dev python3-mako python3-numpy python3-requests python3-scipy python3-setuptools \&#xA;python3-ruamel.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Clone and build UHD from source (make sure that the current branch is higher than 4.0)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/EttusResearch/uhd.git&#xA;cd &amp;lt;uhd-repo-path&amp;gt;/host&#xA;mkdir build&#xA;cd build&#xA;cmake ../&#xA;make -j 4&#xA;make test&#xA;sudo make install&#xA;sudo ldconfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Download firmwares for USRPs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo uhd_images_downloader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use a &lt;a href=&#34;https://www.ettus.com/all-products/10gige-kit/&#34;&gt;10Gb card&lt;/a&gt; to connect USRP X310 to PC, refer to UHD Manual &lt;a href=&#34;https://files.ettus.com/manual/page_usrp_x3x0.html&#34;&gt;[1]&lt;/a&gt;, &lt;a href=&#34;https://files.ettus.com/manual/page_usrp_x3x0_config.html&#34;&gt;[2]&lt;/a&gt; to configure USRP X310 and 10Gb card interface. For USRP B210, it should be connected to PC via a USB 3.0 port.&lt;/p&gt; &#xA;&lt;p&gt;Test the connection and firmware (for USRP X310 only):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sysctl -w net.core.rmem_max=33554432&#xA;sudo sysctl -w net.core.wmem_max=33554432&#xA;sudo ifconfig &amp;lt;10Gb card interface&amp;gt; mtu 9000&#xA;sudo uhd_usrp_probe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;srsRAN dependencies:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install build-essential git cmake libfftw3-dev libmbedtls-dev libboost-program-options-dev libconfig++-dev libsctp-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LTESniffer dependencies:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install libglib2.0-dev libudev-dev libcurl4-gnutls-dev libboost-all-dev qtdeclarative5-dev libqt5charts5-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Build LTESniffer from source:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/SysSec-KAIST/LTESniffer.git&#xA;cd LTESniffer&#xA;mkdir build&#xA;cd build&#xA;cmake ../&#xA;make -j 4 (use 4 threads)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;LTESniffer has 3 main functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sniffing LTE downlink traffic from the base station&lt;/li&gt; &#xA; &lt;li&gt;Sniffing LTE uplink traffic from smartphones&lt;/li&gt; &#xA; &lt;li&gt;Security API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After building from source, &lt;code&gt;LTESniffer&lt;/code&gt; is located in &lt;code&gt;&amp;lt;build-dir&amp;gt;/src/LTESniffer&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that before using LTESniffer on the commercial, one should have to check the local regulations on sniffing LTE traffic, as we explained in the &lt;strong&gt;Ethical Consideration&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To figure out the base station and Uplink-Downlink band the test smartphone is connected to, install &lt;a href=&#34;https://play.google.com/store/apps/details?id=make.more.r2d2.cellular_z&amp;amp;hl=en&amp;amp;gl=US&amp;amp;pli=1&#34;&gt;Cellular-Z&lt;/a&gt; app on the test smartphone (the app only supports Android). It will show the cell ID and Uplink-Downlink band/frequency to which the test smartphone is connected. Make sure that LTESniffer also connects to the same cell and frequency.&lt;/p&gt; &#xA;&lt;h3&gt;General downlink sniffing&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/png/dl_mode_png.png&#34; alt=&#34;LTESniffer Downlink Mode&#34;&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -C -m 0&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -C -m 0&#xA;-A: number of antennas&#xA;-W: number of threads&#xA;-f: downlink frequency&#xA;-C: turn on cell search&#xA;-m: sniffer mode, 0 for downlink sniffing and 1 for uplink sniffing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: to run &lt;code&gt;LTESniffer&lt;/code&gt; with USRP B210 in the downlink mode, add option &lt;code&gt;-a &#34;num_recv_frames=512&#34; &lt;/code&gt; to the command line. This option extends the receiving buffer for USRP B210 to achieve better synchronization.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -C -m 0 -a &#34;num_recv_frames=512&#34;&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -C -m 0 -a &#34;num_recv_frames=512&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;General uplink sniffing&lt;/h3&gt; &#xA;&lt;p&gt;Note: In the uplink sniffing mode, the test smartphones should be located nearby the sniffer, because the uplink signal power from UE is significantly weaker compared to the downlink signal from the base station.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/png/ul_mode_png.png&#34; alt=&#34;LTESniffer Uplink Mode&#34;&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -u &amp;lt;UL Freq&amp;gt; -C -m 1&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -u 1745e6 -C -m 1&#xA;-u: uplink frequency&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Security API&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/png/api_png.png&#34; alt=&#34;LTESniffer API Mode&#34;&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -u &amp;lt;UL Freq&amp;gt; -C -m 1 -z 3&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -u 1745e6 -C -m 1 -z 3&#xA;-z: 3 for turnning on 3 functions of sniffer, which are identity mapping, IMSI collecting, and UECapability profiling.&#xA;    2 for UECapability profiling&#xA;    1 for IMSI collecting&#xA;    0 for identity mapping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specify a base station&lt;/h3&gt; &#xA;&lt;p&gt;LTESniffer can sniff on a specific base station by using options &lt;code&gt;-I &amp;lt;Phycial Cell ID (PCI)&amp;gt; -p &amp;lt;number of Physical Resource Block (PRB)&amp;gt;&lt;/code&gt;. In this case, LTESniffer does not do the cell search but connects directly to the specified cell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -I &amp;lt;PCI&amp;gt; -p &amp;lt;PRB&amp;gt; -m 0&#xA;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -u &amp;lt;UL Freq&amp;gt; -I &amp;lt;PCI&amp;gt; -p &amp;lt;PRB&amp;gt; -m 1&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -u 1745e6 -I 379 -p 100 -m 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The debug mode can be enabled by using option &lt;code&gt;-d&lt;/code&gt;. In this case, the debug messages will be printed on the terminal.&lt;/p&gt; &#xA;&lt;h3&gt;Output of LTESniffer&lt;/h3&gt; &#xA;&lt;p&gt;LTESniffer provides pcap files in the output. The pcap file can be opened by WireShark for further analysis and packet trace. The name of downlink pcap file: &lt;code&gt;sniffer_dl_mode.pcap&lt;/code&gt;, uplink pcap file: &lt;code&gt;sniffer_ul_mode.pcap&lt;/code&gt;, and API pcap file: &lt;code&gt;api_collector.pcap&lt;/code&gt;. The pcap files are located in the same directory &lt;code&gt;LTESniffer&lt;/code&gt; has been executed. To enable the WireShark to analyze the decoded packets correctly, please refer to the WireShark configuration guide &lt;a href=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/pcap_file_example/README.md&#34;&gt;here&lt;/a&gt;. There are also some examples of pcap files in the link.&lt;br&gt; &lt;strong&gt;Note:&lt;/strong&gt; The uplink pcap file contains both uplink and downlink messages. On the WireShark, use this filter to monitor only uplink messages: &lt;code&gt;mac-lte.direction == 0&lt;/code&gt;; or this filter to monitor only downlink messages: &lt;code&gt;mac-lte.direction == 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Application Note&lt;/h2&gt; &#xA;&lt;h3&gt;Uplink sniffing mode&lt;/h3&gt; &#xA;&lt;p&gt;When sniffing LTE uplink, LTESniffer requires USRP X310 because it needs to listen to two different frequencies at the same time, 1 for uplink and 1 for downlink. The main target of the uplink sniffing function is to decode uplink traffic from nearby smartphones. However, as LTESniffer needs to decode the downlink traffic to obtain uplink-downlink DCI messages, it also supports decoding downlink traffic at the same time. Nevertheless, the downlink sniffing function is limited to decoding messages which use transmission modes 1 and 2, since LTESniffer only has 1 antenna for downlink.&lt;/p&gt; &#xA;&lt;h3&gt;Distance for uplink sniffing&lt;/h3&gt; &#xA;&lt;p&gt;The effective range for sniffing uplink is limited in LTESniffer due to the capability of the RF front-end of the hardware (i.e. SDR). The uplink signal power from UE is significantly weaker compared to the downlink signal because UE is a handheld device that optimizes battery usage, while the eNB uses sufficient power to cover a large area. To successfully capture the uplink traffic, LTESniffer can increase the strength of the signal power by i) being physically close to the UE, or ii) improving the signal reception capability with specialized hardware, such as a directional antenna, dedicated RF front-end, and signal amplifier.&lt;/p&gt; &#xA;&lt;h3&gt;The information displayed on the terminal&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Downlink Sniffing Mode&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Processed 1000/1000 subframes&lt;/code&gt;: Number of subframes was processed by LTESniffer last 1 second. There are 1000 LTE subframes per second by design. &lt;br&gt; &lt;code&gt;RNTI&lt;/code&gt;: Radio Network Temporary Identifier of UEs. &lt;br&gt; &lt;code&gt;Table&lt;/code&gt;: The maximum modulation scheme that is used by smartphones in downlink. LTESniffer supports up to 256QAM in the downlink. Refer to our &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2023/wisec2023_tuan.pdf&#34;&gt;paper&lt;/a&gt; for more details. &lt;br&gt; &lt;code&gt;Active&lt;/code&gt;: Number of detected messages of RNTIs. &lt;br&gt; &lt;code&gt;Success&lt;/code&gt;: Number of successfully decoded messages over number of detected messages (&lt;code&gt;Active&lt;/code&gt;). &lt;br&gt; &lt;code&gt;New TX, ReTX, HARQ, Normal&lt;/code&gt;: Statistic of new messages and retransmitted messages. This function is in development. &lt;br&gt; &lt;code&gt;W_MIMO, W_pinfor, Other&lt;/code&gt;: Number of messages with wrong radio configuration, only for debugging.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Uplink Sniffing Mode&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Max Mod&lt;/code&gt;: The maximum modulation scheme that is used by smartphones in uplink. It can be 16/64/256QAM depending on the support of smartphones and the configuration of the network. Refer to our &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2023/wisec2023_tuan.pdf&#34;&gt;paper&lt;/a&gt; for more details. &lt;br&gt; &lt;code&gt;SNR&lt;/code&gt;: Signal-to-noise ratio (dB). Low SNR means the uplink signal quality from the smartphone is bad. One possible reason is the smartphone is far from the sniffer. &lt;br&gt; &lt;code&gt;DL-UL_delay&lt;/code&gt;: The average of time delay between downlink signal from the base station and uplink signal from the smartphone. &lt;br&gt; &lt;code&gt;Other Info&lt;/code&gt;: Information only for debugging.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;API Mode&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Detected Identity&lt;/code&gt;: The name of detected identity. &lt;br&gt; &lt;code&gt;Value&lt;/code&gt;: The value of detected identity. &lt;br&gt; &lt;code&gt;From Message&lt;/code&gt;: The name of the message that contains the detected identity.&lt;/p&gt; &#xA;&lt;!-- ## FAQ&#xA;**Q:** Is it possible to capture and see the phone call content using LTESniffer? \&#xA;**A:** No. LTE traffic including phone call traffic is encrypted, so you cannot use LTESniffer to know the content of phone calls of someone. Moreover, it is important to note that sniffing phone calls in the commercial network is illegal in most countries. --&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;We sincerely appreciate the &lt;a href=&#34;https://github.com/falkenber9/falcon&#34;&gt;FALCON&lt;/a&gt; and &lt;a href=&#34;https://github.com/srsran/srsRAN_4G&#34;&gt;SRS team&lt;/a&gt; for making their great softwares available.&lt;/p&gt; &#xA;&lt;h2&gt;BibTex&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to our &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2023/wisec2023_tuan.pdf&#34;&gt;paper&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@inproceedings{hoang:ltesniffer,&#xA;  title = {{LTESniffer: An Open-source LTE Downlink/Uplink Eavesdropper}},&#xA;  author = {Hoang, Dinh Tuan and Park, CheolJun and Son, Mincheol and Oh, Taekkyung and Bae, Sangwook and Ahn, Junho and Oh, BeomSeok and Kim, Yongdae},&#xA;  booktitle = {16th ACM Conference on Security and Privacy in Wireless and Mobile Networks (WiSec &#39;23)},&#xA;  year = {2023}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; What kind of SDRs I can use to run LTESniffer? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; To sniff only downlink traffic from the base station, LTESniffer works well with USRP B210 with 2 RX antennas. To sniff the uplink traffic, LTESniffer requires USRP X310 with 2 daughterboards. There are two reasons for this. First, sniffing the uplink traffic requires precise time synchronization between uplink and downlink subframes, which can be simply achieved by using two daughterboards with the same clock source from a single motherboard of USRP X310. Second, the &#34;srsran_rf_set_rx_freq&#34; function used by LTESniffer seems to only support the USRP X310 with 2 daughterboards for simultaneous reception of signals at two different frequencies.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Is it mandatory to use GPSDO with the USRP in order to run LTESniffer? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; GPSDO is useful for more stable synchronization. However, without GPSDO, LTESniffer still can synchronize with the LTE signal to decode the packets.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; For downlink traffic, can I use a cheaper SDR? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; Technically, any SDRs supported by srsRAN library such as Blade RF can be used to run LTESniffer in the downlink sniffing mode. However, we only tested the downlink sniffing function of LTESniffer with USRP B210 and X310.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Is it illegal to use LTESniffer to sniff the LTE traffic? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; You should have to check the local regulations on sniffing (unencrypted) LTE traffic. Another way to test LTESniffer is setting up a personal LTE network by using &lt;a href=&#34;https://github.com/srsran/srsRAN_4G&#34;&gt;srsRAN&lt;/a&gt; - an open-source LTE implementation in a Faraday cage.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Can LTESniffer be used to view the content of messages between two users? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; One can see only the &#34;unencrypted&#34; part of the messages. Note that the air traffic between the base station and users is mostly encrypted.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Is there any device identity exposed in plaintext in the LTE network? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; Yes, literature shows that there are multiple identities exposed, such as TMSI, GUTI, IMSI, and RNTI. Please refer to the academic literature for more details. e.g. &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2022/sec22summer_bae.pdf&#34;&gt;Watching the Watchers: Practical Video Identification Attack in LTE Networks&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>strato-emu/strato</title>
    <updated>2023-05-21T01:49:01Z</updated>
    <id>tag:github.com,2023-05-21:/strato-emu/strato</id>
    <link href="https://github.com/strato-emu/strato" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Run Nintendo Switch homebrew &amp; games on your Android device!&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/strato-emu/strato&#34; target=&#34;_blank&#34;&gt; &lt;img height=&#34;60%&#34; width=&#34;60%&#34; src=&#34;https://raw.github.com/strato-emu/branding/master/banner/strato-banner-rounded.png&#34;&gt;&lt;br&gt; &lt;/a&gt; &lt;a href=&#34;https://discord.gg/YhpdhVBmXX&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://img.shields.io/discord/1104386300750082081.svg?label=&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=5865F2&amp;amp;labelColor=404EED&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/strato-emu/strato/actions/workflows/ci.yml&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://github.com/strato-emu/strato/actions/workflows/ci.yml/badge.svg?sanitize=true&#34;&gt;&lt;br&gt; &lt;/a&gt; &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt;&lt;a href=&#34;https://raw.githubusercontent.com/strato-emu/strato/master/CONTRIBUTING.md&#34;&gt;Contributing Guide&lt;/a&gt; • &lt;a href=&#34;https://raw.githubusercontent.com/strato-emu/strato/master/BUILDING.md&#34;&gt;Building Guide&lt;/a&gt;&lt;/b&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt;Strato&lt;/b&gt; is an experimental emulator that runs on &lt;b&gt;ARMv8 Android™&lt;/b&gt; devices and emulates the functionality of a &lt;b&gt;Nintendo Switch™&lt;/b&gt; system, licensed under &lt;a href=&#34;https://github.com/strato-emu/strato/raw/master/LICENSE.md&#34;&gt;&lt;b&gt;Mozilla Public License 2.0&lt;/b&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Contact&lt;/h3&gt; &#xA;&lt;p&gt;You can contact the core developers of Strato at our &lt;strong&gt;&lt;a href=&#34;https://discord.gg/YhpdhVBmXX&#34;&gt;Discord&lt;/a&gt;&lt;/strong&gt;. If you have any questions, feel free to ask. It&#39;s also a good place to just keep up with the emulator, as most talk regarding development goes on over there.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Special Thanks&lt;/h3&gt; &#xA;&lt;p&gt;A few noteworthy teams/projects who&#39;ve helped us along the way are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://skyline-emu.one/&#34;&gt;Skyline&lt;/a&gt;:&lt;/strong&gt; Strato builds on top of Skyline and is meant as a continuation of that project.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ryujinx.org/&#34;&gt;Ryujinx&lt;/a&gt;:&lt;/strong&gt; We&#39;ve used Ryujinx for reference throughout the project, the accuracy of their HLE implementations of Switch subsystems make it an amazing reference. The team behind the project has been extremely helpful with any queries we&#39;ve had and have constantly helped us with any issues we&#39;ve come across. &lt;strong&gt;It should be noted that Strato is not based on Ryujinx&lt;/strong&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://yuzu-emu.org/&#34;&gt;yuzu&lt;/a&gt;:&lt;/strong&gt; Strato&#39;s shader compiler is a &lt;strong&gt;fork&lt;/strong&gt; of &lt;em&gt;yuzu&lt;/em&gt;&#39;s shader compiler with Strato-specific changes, using it allowed us to focus on the parts of GPU emulation that we could specifically optimize for mobile while having a high-quality shader compiler implementation as a base.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/switchbrew/&#34;&gt;Switchbrew&lt;/a&gt;:&lt;/strong&gt; We&#39;ve extensively used Switchbrew whether that be their &lt;strong&gt;&lt;a href=&#34;https://switchbrew.org/&#34;&gt;wiki&lt;/a&gt;&lt;/strong&gt; with its colossal amount of information on the Switch that has saved us countless hours of time or &lt;strong&gt;&lt;a href=&#34;https://github.com/switchbrew/libnx&#34;&gt;libnx&lt;/a&gt;&lt;/strong&gt; which was crucial to initial development of the emulator to ensure that our HLE kernel and sysmodule implementations were accurate.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Disclaimer&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Nintendo Switch&lt;/strong&gt; is a trademark of &lt;strong&gt;Nintendo Co., Ltd&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Android&lt;/strong&gt; is a trademark of &lt;strong&gt;Google LLC&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>openxla/iree</title>
    <updated>2023-05-21T01:49:01Z</updated>
    <id>tag:github.com,2023-05-21:/openxla/iree</id>
    <link href="https://github.com/openxla/iree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A retargetable MLIR-based machine learning compiler and runtime toolkit.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;IREE: Intermediate Representation Execution Environment&lt;/h1&gt; &#xA;&lt;p&gt;IREE (&lt;strong&gt;I&lt;/strong&gt;ntermediate &lt;strong&gt;R&lt;/strong&gt;epresentation &lt;strong&gt;E&lt;/strong&gt;xecution &lt;strong&gt;E&lt;/strong&gt;nvironment, pronounced as &#34;eerie&#34;) is an &lt;a href=&#34;https://mlir.llvm.org/&#34;&gt;MLIR&lt;/a&gt;-based end-to-end compiler and runtime that lowers Machine Learning (ML) models to a unified IR that scales up to meet the needs of the datacenter and down to satisfy the constraints and special considerations of mobile and edge deployments.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://openxla.github.io/iree/&#34;&gt;our website&lt;/a&gt; for project details, user guides, and instructions on building from source.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/openxla/iree/actions/workflows/ci.yml?query=branch%3Amain+event%3Apush&#34;&gt;&lt;img src=&#34;https://github.com/openxla/iree/actions/workflows/ci.yml/badge.svg?query=branch%3Amain+event%3Apush&#34; alt=&#34;CI Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Project Status&lt;/h4&gt; &#xA;&lt;p&gt;IREE is still in its early phase. We have settled down on the overarching infrastructure and are actively improving various software components as well as project logistics. It is still quite far from ready for everyday use and is made available without any support at the moment. With that said, we welcome any kind of feedback on any &lt;a href=&#34;https://raw.githubusercontent.com/openxla/iree/main/#communication-channels&#34;&gt;communication channels&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Communication Channels&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/openxla/iree/issues&#34;&gt;GitHub issues&lt;/a&gt;: Feature requests, bugs, and other work tracking&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/26P4xW4&#34;&gt;IREE Discord server&lt;/a&gt;: Daily development discussions with the core team and collaborators&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/iree-discuss&#34;&gt;iree-discuss email list&lt;/a&gt;: Announcements, general and low-priority discussion&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Related Project Channels&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://llvm.discourse.group/c/llvm-project/mlir/31&#34;&gt;MLIR topic within LLVM Discourse&lt;/a&gt;: IREE is enabled by and heavily relies on &lt;a href=&#34;https://mlir.llvm.org&#34;&gt;MLIR&lt;/a&gt;. IREE sometimes is referred to in certain MLIR discussions. Useful if you are also interested in MLIR evolution.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Architecture Overview&lt;/h2&gt; &#xA;&lt;!-- TODO(scotttodd): switch to &lt;picture&gt; once better supported? https://github.blog/changelog/2022-05-19-specify-theme-context-for-images-in-markdown-beta/ --&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/openxla/iree/main/docs/website/docs/assets/images/iree_architecture_dark.svg#gh-dark-mode-only&#34; alt=&#34;IREE Architecture&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/openxla/iree/main/docs/website/docs/assets/images/iree_architecture.svg#gh-light-mode-only&#34; alt=&#34;IREE Architecture&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://openxla.github.io/iree/&#34;&gt;our website&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Presentations and Talks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2021-06-09: IREE Runtime Design Tech Talk (&lt;a href=&#34;https://drive.google.com/file/d/1p0DcysaIg8rC7ErKYEgutQkOJGPFCU3s/view&#34;&gt;recording&lt;/a&gt; and &lt;a href=&#34;https://drive.google.com/file/d/1ikgOdZxnMz1ExqwrAiuTY9exbe3yMWbB/view?usp=sharing&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;2020-08-20: IREE CodeGen: MLIR Open Design Meeting Presentation (&lt;a href=&#34;https://drive.google.com/file/d/1325zKXnNIXGw3cdWrDWJ1-bp952wvC6W/view?usp=sharing&#34;&gt;recording&lt;/a&gt; and &lt;a href=&#34;https://docs.google.com/presentation/d/1NetHjKAOYg49KixY5tELqFp6Zr2v8_ujGzWZ_3xvqC8/edit&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;2020-03-18: Interactive HAL IR Walkthrough (&lt;a href=&#34;https://drive.google.com/file/d/1_sWDgAPDfrGQZdxAapSA90AD1jVfhp-f/view?usp=sharing&#34;&gt;recording&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;2020-01-31: End-to-end MLIR Workflow in IREE: MLIR Open Design Meeting Presentation (&lt;a href=&#34;https://drive.google.com/open?id=1os9FaPodPI59uj7JJI3aXnTzkuttuVkR&#34;&gt;recording&lt;/a&gt; and &lt;a href=&#34;https://drive.google.com/open?id=1RCQ4ZPQFK9cVgu3IH1e5xbrBcqy7d_cEZ578j84OvYI&#34;&gt;slides&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;IREE is licensed under the terms of the Apache 2.0 License with LLVM Exceptions. See &lt;a href=&#34;https://raw.githubusercontent.com/openxla/iree/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for more information.&lt;/p&gt;</summary>
  </entry>
</feed>