<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-05T01:36:06Z</updated>
  <subtitle>Weekly Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>microsoft/calculator</title>
    <updated>2024-05-05T01:36:06Z</updated>
    <id>tag:github.com,2024-05-05:/microsoft/calculator</id>
    <link href="https://github.com/microsoft/calculator" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Windows Calculator: A simple yet powerful calculator that ships with Windows&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Calculator&lt;/h1&gt; &#xA;&lt;p&gt;The Windows Calculator app is a modern Windows app written in C++ and C# that ships pre-installed with Windows. The app provides standard, scientific, and programmer calculator functionality, as well as a set of converters between various units of measurement and currencies.&lt;/p&gt; &#xA;&lt;p&gt;Calculator ships regularly with new features and bug fixes. You can get the latest version of Calculator in the &lt;a href=&#34;https://www.microsoft.com/store/apps/9WZDNCRFHVN5&#34;&gt;Microsoft Store&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://dev.azure.com/ms/calculator/_build/latest?definitionId=57&amp;amp;branchName=main&#34;&gt;&lt;img src=&#34;https://dev.azure.com/ms/calculator/_apis/build/status/Calculator-CI?branchName=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/docs/Images/CalculatorScreenshot.png&#34; alt=&#34;Calculator Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Standard Calculator functionality which offers basic operations and evaluates commands immediately as they are entered.&lt;/li&gt; &#xA; &lt;li&gt;Scientific Calculator functionality which offers expanded operations and evaluates commands using order of operations.&lt;/li&gt; &#xA; &lt;li&gt;Programmer Calculator functionality which offers common mathematical operations for developers including conversion between common bases.&lt;/li&gt; &#xA; &lt;li&gt;Date Calculation functionality which offers the difference between two dates, as well as the ability to add/subtract years, months and/or days to/from a given input date.&lt;/li&gt; &#xA; &lt;li&gt;Calculation history and memory capabilities.&lt;/li&gt; &#xA; &lt;li&gt;Conversion between many units of measurement.&lt;/li&gt; &#xA; &lt;li&gt;Currency conversion based on data retrieved from &lt;a href=&#34;https://www.bing.com&#34;&gt;Bing&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic&#34;&gt;Infinite precision&lt;/a&gt; for basic arithmetic operations (addition, subtraction, multiplication, division) so that calculations never lose precision.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Prerequisites:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Your computer must be running Windows 11, build 22000 or newer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the latest version of &lt;a href=&#34;https://developer.microsoft.com/en-us/windows/downloads&#34;&gt;Visual Studio&lt;/a&gt; (the free community edition is sufficient).&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Install the &#34;Universal Windows Platform Development&#34; workload.&lt;/li&gt; &#xA;   &lt;li&gt;Install the optional &#34;C++ Universal Windows Platform tools&#34; component.&lt;/li&gt; &#xA;   &lt;li&gt;Install the latest Windows 11 SDK.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/docs/Images/VSInstallationScreenshot.png&#34; alt=&#34;Visual Studio Installation Screenshot&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler&#34;&gt;XAML Styler&lt;/a&gt; Visual Studio extension.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Get the code:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/calculator.git&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/src/Calculator.sln&#34;&gt;src\Calculator.sln&lt;/a&gt; in Visual Studio to build and run the Calculator app.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For a general description of the Calculator project architecture see &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/docs/ApplicationArchitecture.md&#34;&gt;ApplicationArchitecture.md&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To run the UI Tests, you need to make sure that &lt;a href=&#34;https://github.com/microsoft/WinAppDriver/releases/latest&#34;&gt;Windows Application Driver (WinAppDriver)&lt;/a&gt; is installed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Want to contribute? The team encourages community feedback and contributions. Please follow our &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/CONTRIBUTING.md&#34;&gt;contributing guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If Calculator is not working properly, please file a report in the &lt;a href=&#34;https://insider.windows.com/en-us/fb/?contextid=130&#34;&gt;Feedback Hub&lt;/a&gt;. We also welcome &lt;a href=&#34;https://github.com/Microsoft/calculator/issues&#34;&gt;issues submitted on GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;For information regarding Windows Calculator plans and release schedule, please see the &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/docs/Roadmap.md&#34;&gt;Windows Calculator Roadmap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Graphing Mode&lt;/h3&gt; &#xA;&lt;p&gt;Adding graphing calculator functionality &lt;a href=&#34;https://github.com/Microsoft/calculator/issues/338&#34;&gt;is on the project roadmap&lt;/a&gt; and we hope that this project can create a great end-user experience around graphing. To that end, the UI from the official in-box Windows Calculator is currently part of this repository, although the proprietary Microsoft-built graphing engine, which also drives graphing in Microsoft Mathematics and OneNote, is not. Community members can still be involved in the creation of the UI, however developer builds will not have graphing functionality due to the use of a &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/src/GraphingImpl/Mocks&#34;&gt;mock implementation of the engine&lt;/a&gt; built on top of a &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/src/GraphingInterfaces&#34;&gt;common graphing API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Diagnostic Data&lt;/h2&gt; &#xA;&lt;p&gt;This project collects usage data and sends it to Microsoft to help improve our products and services. Read our &lt;a href=&#34;https://go.microsoft.com/fwlink/?LinkId=521839&#34;&gt;privacy statement&lt;/a&gt; to learn more. Diagnostic data is disabled in development builds by default, and can be enabled with the &lt;code&gt;SEND_DIAGNOSTICS&lt;/code&gt; build flag.&lt;/p&gt; &#xA;&lt;h2&gt;Currency Converter&lt;/h2&gt; &#xA;&lt;p&gt;Windows Calculator includes a currency converter feature that uses mock data in developer builds. The data that Microsoft uses for the currency converter feature (e.g., in the retail version of the application) is not licensed for your use. The mock data will be clearly identifiable as it references planets instead of countries, and remains static regardless of selected inputs.&lt;/p&gt; &#xA;&lt;h2&gt;Reporting Security Issues&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/SECURITY.md&#34;&gt;SECURITY.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (c) Microsoft Corporation. All rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;Licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/calculator/main/LICENSE&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mltframework/shotcut</title>
    <updated>2024-05-05T01:36:06Z</updated>
    <id>tag:github.com,2024-05-05:/mltframework/shotcut</id>
    <link href="https://github.com/mltframework/shotcut" rel="alternate"></link>
    <summary type="html">&lt;p&gt;cross-platform (Qt), open-source (GPLv3) video editor&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/mltframework/shotcut/actions?query=workflow%3Abuild-shotcut-linux+is%3Acompleted+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/mltframework/shotcut/workflows/build-shotcut-linux/badge.svg?sanitize=true&#34; alt=&#34;build-shotcut-linux&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mltframework/shotcut/actions?query=workflow%3Abuild-shotcut-macos+is%3Acompleted+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/mltframework/shotcut/workflows/build-shotcut-macos/badge.svg?sanitize=true&#34; alt=&#34;build-shotcut-macos&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mltframework/shotcut/actions?query=workflow%3Abuild-shotcut-windows+is%3Acompleted+branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/mltframework/shotcut/workflows/build-shotcut-windows/badge.svg?sanitize=true&#34; alt=&#34;build-shotcut-windows&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Shotcut - a free, open source, cross-platform &lt;strong&gt;video editor&lt;/strong&gt;&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://www.shotcut.org/assets/img/screenshots/Shotcut-18.11.18.png&#34; alt=&#34;screenshot&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Features: &lt;a href=&#34;https://www.shotcut.org/features/&#34;&gt;https://www.shotcut.org/features/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Roadmap: &lt;a href=&#34;https://www.shotcut.org/roadmap/&#34;&gt;https://www.shotcut.org/roadmap/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;Binaries are regularly built and are available at &lt;a href=&#34;https://www.shotcut.org/download/&#34;&gt;https://www.shotcut.org/download/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dan Dennedy &amp;lt;&lt;a href=&#34;http://www.dennedy.org&#34;&gt;http://www.dennedy.org&lt;/a&gt;&amp;gt; : main author&lt;/li&gt; &#xA; &lt;li&gt;Brian Matherly &amp;lt;&lt;a href=&#34;mailto:code@brianmatherly.com&#34;&gt;code@brianmatherly.com&lt;/a&gt;&amp;gt; : contributor&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;Shotcut&#39;s direct (linked or hard runtime) dependencies are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.mltframework.org/&#34;&gt;MLT&lt;/a&gt;: multimedia authoring framework&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.qt.io/&#34;&gt;Qt 6 (6.4 mininum)&lt;/a&gt;: application and UI framework&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://fftw.org/&#34;&gt;FFTW&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt;: multimedia format and codec libraries&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.dyne.org/software/frei0r/&#34;&gt;Frei0r&lt;/a&gt;: video plugins&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.libsdl.org/&#34;&gt;SDL&lt;/a&gt;: cross-platform audio playback&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://shotcut.org/credits/&#34;&gt;https://shotcut.org/credits/&lt;/a&gt; for a more complete list including indirect and bundled dependencies.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;GPLv3. See &lt;a href=&#34;https://raw.githubusercontent.com/mltframework/shotcut/master/COPYING&#34;&gt;COPYING&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How to build&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: building Shotcut should only be reserved to beta testers or contributors who know what they are doing.&lt;/p&gt; &#xA;&lt;h3&gt;Qt Creator&lt;/h3&gt; &#xA;&lt;p&gt;The fastest way to build and try Shotcut development version is through &lt;a href=&#34;https://www.qt.io/download#qt-creator&#34;&gt;Qt Creator&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;From command line&lt;/h3&gt; &#xA;&lt;p&gt;First, check dependencies are satisfied and various paths are correctly set to find different libraries and include files (Qt, MLT, frei0r and so forth).&lt;/p&gt; &#xA;&lt;h4&gt;Configure&lt;/h4&gt; &#xA;&lt;p&gt;In a new directory in which to make the build (separate from the source):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -DCMAKE_INSTALL_PREFIX=/usr/local/ /path/to/shotcut&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We recommend using the Ninja generator by adding &lt;code&gt;-GNinja&lt;/code&gt; to the above command line.&lt;/p&gt; &#xA;&lt;h4&gt;Build&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install&lt;/h4&gt; &#xA;&lt;p&gt;If you do not install, Shotcut may fail when you run it because it cannot locate its QML files that it reads at run-time.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --install .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Translation&lt;/h2&gt; &#xA;&lt;p&gt;If you want to translate Shotcut to another language, please use &lt;a href=&#34;https://www.transifex.com/ddennedy/shotcut/&#34;&gt;Transifex&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>zk-Call/zkp-hmac-communication-cpp</title>
    <updated>2024-05-05T01:36:06Z</updated>
    <id>tag:github.com,2024-05-05:/zk-Call/zkp-hmac-communication-cpp</id>
    <link href="https://github.com/zk-Call/zkp-hmac-communication-cpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&#34;Zero-Knowledge&#34; Proof Implementation with HMAC Communication in C++&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;assets/zk-Call Preview [C++].png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;zk-Call &amp;amp; Labs&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;strong&gt;&#34;Zero-Knowledge&#34; Proof Implementation with HMAC Communication in C++&lt;/strong&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;http://badges.github.io/stability-badges/dist/experimental.svg?sanitize=true&#34; alt=&#34;Experimental&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;sub&gt; Built by &lt;a href=&#34;https://github.com/zk-Call&#34;&gt; zk-Call&lt;/a&gt; :) &lt;/sub&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#purpose&#34;&gt;Purpose&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#how-it-works&#34;&gt;How it Works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#api&#34;&gt;API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#example-usage&#34;&gt;Example Usage&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;This repository hosts a refined implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Schnorr_signature&#34;&gt;&lt;strong&gt;Schnorr&#39;s Protocol&lt;/strong&gt;&lt;/a&gt;, innovatively incorporating a state seed for enhanced security measures. While the underlying proofs may appear intricate, I aim to elucidate their functionality to the best of my ability. However, for a deeper understanding, I encourage referencing the seminal research papers underpinning this implementation, as they offer comprehensive insights.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Schnorr&#39;s%20Protocol.png&#34; alt=&#34;Detailed Schematic Overview of Schnorr&#39;s Protocol (Example)&#34;&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;For further exploration:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1107.1626.pdf&#34;&gt;&lt;strong&gt;Elliptic Curve Based &#34;Zero-Knowledge&#34; Proofs and Their Applicability on Resource Constrained Devices by Ioannis Chatzigiannakis, Apostolos Pyrgelis, Paul G. Spirakis, and Yannis C. Stamatiou&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Elliptic%20Curve.png&#34; alt=&#34;Detailed Schematic Overview of Elliptic Curves (Example)&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additionally, this repository delves into the concepts of &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; and &lt;strong&gt;Hash-based Message Authentication Codes (HMACs)&lt;/strong&gt;. &lt;strong&gt;ZKPs&lt;/strong&gt; are cryptographic protocols that allow one party &lt;strong&gt;(the prover)&lt;/strong&gt; to prove to another party &lt;strong&gt;(the verifier)&lt;/strong&gt; that a given statement is true, without revealing any additional information beyond the validity of the statement itself. This property is particularly valuable for preserving privacy while establishing trust. &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, &lt;strong&gt;HMACs&lt;/strong&gt; are a type of cryptographic hash function used for message authentication. They involve a cryptographic hash function &lt;strong&gt;(such as SHA-256)&lt;/strong&gt; and a secret cryptographic key. &lt;strong&gt;HMACs&lt;/strong&gt; provide a way to verify both the data integrity and the authenticity of a message, ensuring that it has not been altered or tampered with during transmission and that it indeed originates from the purported sender. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Purpose&lt;/h1&gt; &#xA;&lt;p&gt;In today&#39;s rapidly evolving IT and application development landscape, &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; emerge as a pivotal paradigm for authentication security. Their capacity to affirm the validity of a claim, such as proving possession of a secret password — without revealing any sensitive information about the claim itself, such as passwords or hashes, revolutionizes the assurance of secure &lt;strong&gt;AAA operations&lt;/strong&gt; (&lt;strong&gt;authentication&lt;/strong&gt;, &lt;strong&gt;authorization&lt;/strong&gt;, and &lt;strong&gt;accounting&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Purpose-1.png&#34; alt=&#34;The Purpose of our Repositories and The Overall Technology&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;zk-Call &amp;amp; Labs&lt;/strong&gt; represents an implementation of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof&#34;&gt;&lt;strong&gt;Non-Interactive &#34;Zero-Knowledge&#34; Proof&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;(NIZKP)&lt;/strong&gt; protocol tailored specifically for validating text-based secrets. This framework proves invaluable for safeguarding passwords and other authentication mechanisms, ensuring robust security measures without compromising privacy. Additionally, the integration of &lt;strong&gt;HMAC (Hash-Based Message Authentication Code)&lt;/strong&gt; further fortifies the authentication process, enhancing data integrity and thwarting potential security breaches. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;How It Works&lt;/h1&gt; &#xA;&lt;p&gt;The authentication protocol employed in this system operates based on two fundamental concepts: &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; and &lt;strong&gt;Hash-Based Message Authentication Code (HMAC)&lt;/strong&gt;. Let&#39;s delve into each of these components and understand how they synergize to ensure secure authentication in messaging applications. &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs):&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;ZKPs&lt;/strong&gt; form the bedrock of privacy-preserving authentication mechanisms. These proofs allow one party &lt;strong&gt;(the prover)&lt;/strong&gt; to demonstrate the validity of a claim to another party &lt;strong&gt;(the verifier)&lt;/strong&gt; without revealing any additional information beyond the claim&#39;s validity. In essence, &lt;strong&gt;ZKPs&lt;/strong&gt; enable authentication without the need for the prover to disclose sensitive data, such as passwords or cryptographic keys.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-1.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (1)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-2.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (2)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-3.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (3)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-4.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (4)&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Application in Authentication:&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In the context of messaging applications, &lt;strong&gt;ZKPs&lt;/strong&gt; play a pivotal role in verifying a user&#39;s identity without the need to transmit explicit credentials over the network. Instead, users can generate cryptographic proofs attesting to their identity or possession of certain credentials without exposing those credentials themselves. This ensures that sensitive information remains confidential during the authentication process, bolstering security and privacy. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hash-Based Message Authentication Code (HMAC)&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Hash-Based Message Authentication Code (HMAC):&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;HMAC&lt;/strong&gt; provides a robust mechanism for verifying the integrity and authenticity of messages exchanged between parties. It involves the use of a cryptographic hash function in conjunction with a secret key to generate a unique code &lt;strong&gt;(the HMAC)&lt;/strong&gt; for each message. This code serves as a digital signature, allowing the recipient to verify that the message has not been tampered with or altered during transmission.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/HMAC.png&#34; alt=&#34;Detailed Schematic Overview of HMAC Encryption&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Application in Authentication:&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In messaging applications, &lt;strong&gt;HMAC&lt;/strong&gt; can be employed to authenticate message senders and ensure the integrity of communication channels. By appending an &lt;strong&gt;HMAC&lt;/strong&gt; to each message using a shared secret key, both the sender and recipient can validate the message&#39;s authenticity upon receipt. Any unauthorized modifications to the message would result in a mismatch between the &lt;strong&gt;computed HMAC&lt;/strong&gt; and the &lt;strong&gt;received HMAC&lt;/strong&gt;, thereby alerting the recipient to potential tampering. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Synergistic Operation&lt;/h2&gt; &#xA;&lt;p&gt;When combined, &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs&lt;/strong&gt; and &lt;strong&gt;HMAC&lt;/strong&gt; create a formidable framework for secure authentication in messaging applications. &lt;strong&gt;ZKPs&lt;/strong&gt; facilitate identity verification without divulging sensitive information, while &lt;strong&gt;HMAC&lt;/strong&gt; ensures the integrity and authenticity of messages exchanged between parties. Together, these mechanisms uphold the confidentiality, integrity, and authenticity of communication channels, safeguarding users&#39; privacy and security in the digital realm.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Synergistic%20Operation.png&#34; alt=&#34;The Advantages of Synergy between &amp;quot;Zero-Knowledge&amp;quot; Proof and HMAC&#34;&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;API&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;&#34;HMAC_Client&#34;&lt;/code&gt;&lt;/strong&gt; С++ API is meant to be simple and intuitive:&lt;/p&gt; &#xA;&lt;h2&gt;Core Components&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;Core Components&lt;/code&gt;&lt;/strong&gt; streamline secure &lt;strong&gt;Message Encryption&lt;/strong&gt; and &lt;strong&gt;Decryption&lt;/strong&gt;, supporting both &lt;strong&gt;Chunk&lt;/strong&gt; and &lt;strong&gt;Character-Level&lt;/strong&gt; processing for enhanced data protection.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Core%20Components%20(C++).png&#34; alt=&#34;Detailed Schematic Overview of Core Components&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;HMAC_Client.encrypt_message_by_chunks&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;encrypt a message&lt;/strong&gt; by processing it in &lt;strong&gt;chunks&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;std::string encrypt_message_by_chunks(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be encrypted, processed in chunks&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HMAC_Client.encrypt_message&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;encrypt a message&lt;/strong&gt; by a &lt;strong&gt;chars&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;std::string encrypt_message(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be encrypted, processed in characters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HMAC_Client.decrypt_message_by_chunks&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;decrypt a message&lt;/strong&gt; by processing it in &lt;strong&gt;chunks&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; std::string decrypt_message_by_chunks(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be decrypted, processed in chunks&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HMAC_Client.decrypt_message&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;decrypt a message&lt;/strong&gt; by processing it in &lt;strong&gt;chars&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; std::string encrypt_message(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be decrypted, processed in characters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Example Usage&lt;/h1&gt; &#xA;&lt;p&gt;TODO: Include &lt;strong&gt;&lt;code&gt;Example Usage&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example 1&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt; // Include the input/output stream standard header&#xA;#include &amp;lt;thread&amp;gt; // Include the thread standard header&#xA;#include &amp;lt;queue&amp;gt; // Include the queue standard header&#xA;#include &amp;lt;string&amp;gt; // Include the string standard header&#xA;#include &#34;src/HMAC/core/base.h&#34; // Include the header file for HMAC_Client functionality&#xA;#include &#34;src/SeedGeneration/core/base.h&#34; // Include the header file for SeedGenerator functionality&#xA;&#xA;constexpr bool DEBUG = true; // Define a constexpr boolean variable DEBUG with value true&#xA;&#xA;void print_msg(const std::string &amp;amp;who, const std::string &amp;amp;message) { // Define a function to print messages&#xA;    if (DEBUG) { // Check if debugging is enabled&#xA;        std::cout &amp;lt;&amp;lt; &#34;[&#34; &amp;lt;&amp;lt; who &amp;lt;&amp;lt; &#34;] &#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; std::endl; // Print the message with source identifier&#xA;    }&#xA;}&#xA;&#xA;bool check_if_queue_empty(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to check if a queue is empty&#xA;    while (true) { // Infinite loop&#xA;        if (!socket.empty()) { // Check if the queue is not empty&#xA;            return true; // Return true if the queue is not empty&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;std::string get_content_from_socket(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to get content from a socket (queue)&#xA;    if (check_if_queue_empty(socket)) { // Check if the queue is not empty&#xA;        std::string val = socket.front(); // Get the front element of the queue&#xA;        socket.pop(); // Remove the front element from the queue&#xA;        return val; // Return the retrieved value&#xA;    }&#xA;}&#xA;&#xA;void client(std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket) { // Define the client function&#xA;    // Generating the main seed&#xA;    SeedGenerator seed_generator(&#34;job&#34;); // Create an instance of SeedGenerator&#xA;    std::vector&amp;lt;unsigned char&amp;gt; main_seed = seed_generator.generate(); // Generate the main seed&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    print_msg(&#34;client&#34;, &#34;first&#34;);&#xA;    HMAC_Client obj(&#34;sha256&#34;, main_seed, 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending the main seed to the server&#xA;    server_socket.emplace(main_seed.begin(), main_seed.end()); // Convert the main seed vector to a string and send it to the server&#xA;    print_msg(&#34;client&#34;, &#34;after obj&#34;);&#xA;&#xA;    // Checking if the server has successfully received the seed&#xA;    if (get_content_from_socket(client_socket) == obj.encrypt_message(&#34;&#34;)) { // Check if the server received the seed&#xA;        print_msg(&#34;client&#34;, &#34;after if&#34;);&#xA;&#xA;        // If successful, send a message to the server&#xA;        std::string message = &#34;hello&#34;; // Define the message to be sent&#xA;        server_socket.push(obj.encrypt_message_by_chunks(message)); // Encrypt and send the message to the server&#xA;        print_msg(&#34;client&#34;, &#34;client sent message &#34; + message);&#xA;&#xA;        // Checking if the server has successfully decrypted the message&#xA;        if (get_content_from_socket(client_socket) == obj.encrypt_message(message)) { // Check if the server decrypted the message&#xA;            print_msg(&#34;client&#34;, &#34;server has decrypted message&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;void server(std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket) { // Define the server function&#xA;    // Receiving the main seed from the client&#xA;    std::string main_seed = get_content_from_socket(server_socket); // Receive the main seed from the client&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    HMAC_Client obj(&#34;sha256&#34;, std::vector&amp;lt;unsigned char&amp;gt;(main_seed.begin(), main_seed.end()), 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending an empty message to the client as acknowledgment&#xA;    client_socket.push(obj.encrypt_message(&#34;&#34;)); // Encrypt and send an empty message to the client as acknowledgment&#xA;&#xA;    // Receiving the encrypted message from the client&#xA;    std::string msg = get_content_from_socket(server_socket); // Receive the encrypted message from the client&#xA;    print_msg(&#34;server&#34;, &#34;message encrypted: &#34; + msg);&#xA;&#xA;    // Decrypting the message&#xA;    print_msg(&#34;server&#34;, &#34;before decrypt &#34;);&#xA;    std::string msg_raw = obj.decrypt_message_by_chunks(msg); // Decrypt the received message&#xA;    print_msg(&#34;server&#34;, &#34;message raw: &#34; + msg_raw);&#xA;&#xA;    // Sending the encrypted message back to the client&#xA;    client_socket.push(obj.encrypt_message(msg_raw)); // Encrypt and send the decrypted message back to the client&#xA;}&#xA;&#xA;int main() { // Main function&#xA;    std::queue&amp;lt;std::string&amp;gt; client_socket, server_socket; // Create queues for client and server sockets&#xA;    std::thread client_thread(client, std::ref(client_socket), std::ref(server_socket)); // Create a thread for the client function&#xA;    std::thread server_thread(server, std::ref(server_socket), std::ref(client_socket)); // Create a thread for the server function&#xA;&#xA;    // Joining the threads to wait for their completion&#xA;    client_thread.join(); // Wait for the client thread to finish&#xA;    server_thread.join(); // Wait for the server thread to finish&#xA;&#xA;    return 0; // Return 0 to indicate successful execution&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example 2&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;src/ZeroKnowledge/core/base.h&#34; // Include the header file for ZeroKnowledge class&#xA;&#xA;int main() { // Main function&#xA;    // Creating a ZeroKnowledge object for the client with specified curve and hash algorithm&#xA;    ZeroKnowledge clientObject = ZeroKnowledge::createNew(&#34;secp256k1&#34;, &#34;sha3_256&#34;);&#xA;&#xA;    // Creating a ZeroKnowledge object for the server with specified curve and hash algorithm&#xA;    ZeroKnowledge serverObject = ZeroKnowledge::createNew(&#34;secp384r1&#34;, &#34;sha3_512&#34;);&#xA;&#xA;    // Setting the server password&#xA;    std::string serverPassword = &#34;SecretServerPassword&#34;;&#xA;&#xA;    // Creating a signature for the server password&#xA;    ZeroKnowledgeSignature serverSignature = serverObject.createSignature(serverPassword);&#xA;&#xA;    // Creating a signature for the client identity&#xA;    std::string identity = &#34;John&#34;;&#xA;    ZeroKnowledgeSignature clientSignature = clientObject.createSignature(identity);&#xA;    std::cout&amp;lt;&amp;lt;&#34;before\n&#34;;&#xA;&#xA;    // Generating a token signed by the server for the client&#xA;    std::cout&amp;lt;&amp;lt;clientObject.token()&amp;lt;&amp;lt;&#34;\n&#34;;&#xA;&#xA;    ZeroKnowledgeData token = serverObject.sign(serverPassword, clientObject.token());&#xA;    std::cout&amp;lt;&amp;lt;&#34;after\n&#34;;&#xA;&#xA;    // Generating proof using client identity and token&#xA;    ZeroKnowledgeData proof = clientObject.sign(identity, token.data);&#xA;&#xA;    // Verifying the received proof&#xA;    bool serverVerification = serverObject.verify(token, serverSignature);&#xA;    if (!serverVerification) { // Check if server verification failed&#xA;        std::cout &amp;lt;&amp;lt; &#34;Server verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;    } else { // If server verification succeeded&#xA;        // Otherwise, verify the proof using client signature&#xA;        bool clientVerification = clientObject.verify(token, clientSignature, proof.proof);&#xA;        if (!clientVerification) { // Check if client verification failed&#xA;            std::cout &amp;lt;&amp;lt; &#34;Client verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;        } else { // If client verification succeeded&#xA;            std::cout &amp;lt;&amp;lt; &#34;Authentication successful&#34; &amp;lt;&amp;lt; std::endl; // Print success message&#xA;        }&#xA;    }&#xA;&#xA;    return 0; // Return 0 to indicate successful execution&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example 3&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;src/ZeroKnowledge/core/base.h&#34; // Include the header file for ZeroKnowledge class&#xA;#include &#34;src/HMAC/core/base.h&#34; // Include the header file for HMAC_Client functionality&#xA;#include &#34;src/SeedGeneration/core/base.h&#34; // Include the header file for SeedGenerator functionality&#xA;#include &amp;lt;iostream&amp;gt; // Include the input/output stream standard header&#xA;#include &amp;lt;thread&amp;gt; // Include the thread standard header&#xA;#include &amp;lt;queue&amp;gt; // Include the queue standard header&#xA;#include &amp;lt;string&amp;gt; // Include the string standard header&#xA;&#xA;constexpr bool DEBUG = true; // Define a constexpr boolean variable DEBUG with value true&#xA;&#xA;void print_msg(const std::string &amp;amp;who, const std::string &amp;amp;message) { // Define a function to print messages&#xA;    if (DEBUG) { // Check if debugging is enabled&#xA;        std::cout &amp;lt;&amp;lt; &#34;[&#34; &amp;lt;&amp;lt; who &amp;lt;&amp;lt; &#34;] &#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; std::endl; // Print the message with source identifier&#xA;    }&#xA;}&#xA;&#xA;bool check_if_queue_empty(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to check if a queue is empty&#xA;    while (true) { // Infinite loop&#xA;        if (!socket.empty()) { // Check if the queue is not empty&#xA;            return true; // Return true if the queue is not empty&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;std::string get_content_from_socket(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to get content from a socket (queue)&#xA;    if (check_if_queue_empty(socket)) { // Check if the queue is not empty&#xA;        std::string val = socket.front(); // Get the front element of the queue&#xA;        socket.pop(); // Remove the front element from the queue&#xA;        return val; // Return the retrieved value&#xA;    }&#xA;}&#xA;&#xA;void client(std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket) { // Define the client function&#xA;    // Generating the main seed&#xA;    SeedGenerator seed_generator(&#34;job&#34;); // Create an instance of SeedGenerator&#xA;    std::vector&amp;lt;unsigned char&amp;gt; main_seed = seed_generator.generate(); // Generate the main seed&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    print_msg(&#34;client&#34;, &#34;first&#34;);&#xA;    HMAC_Client obj(&#34;sha256&#34;, main_seed, 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending the main seed to the server&#xA;    server_socket.emplace(main_seed.begin(), main_seed.end()); // Convert the main seed vector to a string and send it to the server&#xA;    print_msg(&#34;client&#34;, &#34;after obj&#34;);&#xA;&#xA;    // Checking if the server has successfully received the seed&#xA;    if (get_content_from_socket(client_socket) == obj.encrypt_message(&#34;&#34;)) { // Check if the server received the seed&#xA;        print_msg(&#34;client&#34;, &#34;after if&#34;);&#xA;&#xA;        // If successful, send a message to the server&#xA;        std::string message = &#34;hello&#34;; // Define the message to be sent&#xA;        server_socket.push(obj.encrypt_message_by_chunks(message)); // Encrypt and send the message to the server&#xA;        print_msg(&#34;client&#34;, &#34;client sent message &#34; + message);&#xA;&#xA;        // Checking if the server has successfully decrypted the message&#xA;        if (get_content_from_socket(client_socket) == obj.encrypt_message(message)) { // Check if the server decrypted the message&#xA;            print_msg(&#34;client&#34;, &#34;server has decrypted message&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;void server(std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket) { // Define the server function&#xA;    // Receiving the main seed from the client&#xA;    std::string main_seed = get_content_from_socket(server_socket); // Receive the main seed from the client&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    HMAC_Client obj(&#34;sha256&#34;, std::vector&amp;lt;unsigned char&amp;gt;(main_seed.begin(), main_seed.end()), 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending an empty message to the client as acknowledgment&#xA;    client_socket.push(obj.encrypt_message(&#34;&#34;)); // Encrypt and send an empty message to the client as acknowledgment&#xA;&#xA;    // Receiving the encrypted message from the client&#xA;    std::string msg = get_content_from_socket(server_socket); // Receive the encrypted message from the client&#xA;    print_msg(&#34;server&#34;, &#34;message encrypted: &#34; + msg);&#xA;&#xA;    // Decrypting the message&#xA;    print_msg(&#34;server&#34;, &#34;before decrypt &#34;);&#xA;    std::string msg_raw = obj.decrypt_message_by_chunks(msg); // Decrypt the received message&#xA;    print_msg(&#34;server&#34;, &#34;message raw: &#34; + msg_raw);&#xA;&#xA;    // Sending the encrypted message back to the client&#xA;    client_socket.push(obj.encrypt_message(msg_raw)); // Encrypt and send the decrypted message back to the client&#xA;}&#xA;&#xA;void init_talking() { // Define a function to initialize client-server communication&#xA;    std::queue&amp;lt;std::string&amp;gt; client_socket, server_socket; // Create queues for client and server sockets&#xA;    std::thread client_thread(client, std::ref(client_socket), std::ref(server_socket)); // Create a thread for the client function&#xA;    std::thread server_thread(server, std::ref(server_socket), std::ref(client_socket)); // Create a thread for the server function&#xA;&#xA;    // Joining the threads to wait for their completion&#xA;    client_thread.join(); // Wait for the client thread to finish&#xA;    server_thread.join(); // Wait for the server thread to finish&#xA;}&#xA;&#xA;int main() { // Main function&#xA;&#xA;    // Creating a ZeroKnowledge object for the client with specified curve and hash algorithm&#xA;    ZeroKnowledge clientObject = ZeroKnowledge::createNew(&#34;secp256k1&#34;, &#34;sha3_256&#34;);&#xA;&#xA;    // Creating a ZeroKnowledge object for the server with specified curve and hash algorithm&#xA;    ZeroKnowledge serverObject = ZeroKnowledge::createNew(&#34;secp384r1&#34;, &#34;sha3_512&#34;);&#xA;&#xA;    // Setting the server password&#xA;    std::string serverPassword = &#34;SecretServerPassword&#34;;&#xA;&#xA;    // Creating a signature for the server password&#xA;    ZeroKnowledgeSignature serverSignature = serverObject.createSignature(serverPassword);&#xA;&#xA;    // Creating a signature for the client identity&#xA;    std::string identity = &#34;John&#34;;&#xA;    ZeroKnowledgeSignature clientSignature = clientObject.createSignature(identity);&#xA;    std::cout &amp;lt;&amp;lt; &#34;before\n&#34;;&#xA;&#xA;    // Generating a token signed by the server for the client&#xA;    std::cout &amp;lt;&amp;lt; clientObject.token() &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;&#xA;    ZeroKnowledgeData token = serverObject.sign(serverPassword, clientObject.token());&#xA;    std::cout &amp;lt;&amp;lt; &#34;after\n&#34;;&#xA;&#xA;    // Generating proof using client identity and token&#xA;    ZeroKnowledgeData proof = clientObject.sign(identity, token.data);&#xA;&#xA;    // Verifying the received proof&#xA;    bool serverVerification = serverObject.verify(token, serverSignature);&#xA;    if (!serverVerification) { // Check if server verification failed&#xA;        std::cout &amp;lt;&amp;lt; &#34;Server verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;    } else { // If server verification succeeded&#xA;        // Otherwise, verify the proof using client signature&#xA;        bool clientVerification = clientObject.verify(token, clientSignature, proof.proof);&#xA;        if (!clientVerification) { // Check if client verification failed&#xA;            std::cout &amp;lt;&amp;lt; &#34;Client verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;        } else { // If client verification succeeded&#xA;            std::cout &amp;lt;&amp;lt; &#34;Authentication successful&#34; &amp;lt;&amp;lt; std::endl; // Print success message&#xA;            init_talking(); // Initialize client-server communication&#xA;&#xA;        }&#xA;    }&#xA;&#xA;    return 0; // Return 0 to indicate successful execution&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>