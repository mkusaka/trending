<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-14T02:01:05Z</updated>
  <subtitle>Weekly Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dragonflydb/dragonfly</title>
    <updated>2022-08-14T02:01:05Z</updated>
    <id>tag:github.com,2022-08-14:/dragonflydb/dragonfly</id>
    <link href="https://github.com/dragonflydb/dragonfly" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modern replacement for Redis and Memcached&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://dragonflydb.io&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/.github/images/logo-full.svg?sanitize=true&#34; width=&#34;284&#34; border=&#34;0&#34; alt=&#34;Dragonfly&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/dragonflydb/dragonfly/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;ci-tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/romanger&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/romanger?style=social&#34; alt=&#34;Twitter URL&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dragonflydb/dragonfly/tree/main/docs/quick-start&#34;&gt;Quick Start&lt;/a&gt; | &lt;a href=&#34;https://discord.gg/HsPjXGVH85&#34;&gt;Discord Chat&lt;/a&gt; | &lt;a href=&#34;https://github.com/dragonflydb/dragonfly/discussions&#34;&gt;GitHub Discussions&lt;/a&gt; | &lt;a href=&#34;https://github.com/dragonflydb/dragonfly/issues&#34;&gt;GitHub Issues&lt;/a&gt; | &lt;a href=&#34;https://github.com/dragonflydb/dragonfly/raw/main/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Probably, the fastest in-memory store in the universe!&lt;/h3&gt; &#xA;&lt;p&gt;Dragonfly is a modern in-memory datastore, fully compatible with Redis and Memcached APIs. Dragonfly implements novel algorithms and data structures on top of a multi-threaded, shared-nothing architecture. As a result, Dragonfly reaches x25 performance compared to Redis and supports millions of QPS on a single instance.&lt;/p&gt; &#xA;&lt;p&gt;Dragonfly&#39;s core properties make it a cost-effective, high-performing, and easy-to-use Redis replacement.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;img src=&#34;http://assets.dragonflydb.io/repo-assets/aws-throughput.svg?sanitize=true&#34; width=&#34;80%&#34; border=&#34;0&#34;&gt; &#xA;&lt;p&gt;Dragonfly is crossing 3.8M QPS on c6gn.16xlarge reaching x25 increase in throughput compared to Redis.&lt;/p&gt; &#xA;&lt;p&gt;99th latency percentile of Dragonfly at its peak throughput:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;op&lt;/th&gt; &#xA;   &lt;th&gt;r6g&lt;/th&gt; &#xA;   &lt;th&gt;c6gn&lt;/th&gt; &#xA;   &lt;th&gt;c7g&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;set&lt;/td&gt; &#xA;   &lt;td&gt;0.8ms&lt;/td&gt; &#xA;   &lt;td&gt;1ms&lt;/td&gt; &#xA;   &lt;td&gt;1ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;get&lt;/td&gt; &#xA;   &lt;td&gt;0.9ms&lt;/td&gt; &#xA;   &lt;td&gt;0.9ms&lt;/td&gt; &#xA;   &lt;td&gt;0.8ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;setex&lt;/td&gt; &#xA;   &lt;td&gt;0.9ms&lt;/td&gt; &#xA;   &lt;td&gt;1.1ms&lt;/td&gt; &#xA;   &lt;td&gt;1.3ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;em&gt;All benchmarks were performed using &lt;code&gt;memtier_benchmark&lt;/code&gt; (see below) with number of threads tuned per server type and the instance type. &lt;code&gt;memtier&lt;/code&gt; was running on a separate c6gn.16xlarge machine. For setex benchmark we used expiry-range of 500, so it would survive the end of the test.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  memtier_benchmark --ratio ... -t &amp;lt;threads&amp;gt; -c 30 -n 200000 --distinct-client-seed -d 256 \&#xA;     --expiry-range=...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When running in pipeline mode &lt;code&gt;--pipeline=30&lt;/code&gt;, Dragonfly reaches &lt;strong&gt;10M qps&lt;/strong&gt; for SET and &lt;strong&gt;15M qps&lt;/strong&gt; for GET operations.&lt;/p&gt; &#xA;&lt;h3&gt;Memcached / Dragonfly&lt;/h3&gt; &#xA;&lt;p&gt;We compared memcached with Dragonfly on &lt;code&gt;c6gn.16xlarge&lt;/code&gt; instance on AWS. As you can see below Dragonfly dominates memcached for both write and read workloads in terms of throughput with a comparable latency. For write workloads, Dragonfly has also better latency, due to contention on the &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/docs/memcached_benchmark.md&#34;&gt;write path in memcached&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SET benchmark&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Server&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;QPS(thousands qps)&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;latency 99%&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;99.9%&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Dragonfly&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üü© 3844&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üü© 0.9ms&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üü© 2.4ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Memcached&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;806&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.6ms&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;3.2ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;GET benchmark&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Server&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;QPS(thousands qps)&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;latency 99%&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;99.9%&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Dragonfly&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üü© 3717&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1ms&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2.4ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Memcached&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2100&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üü© 0.34ms&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;üü© 0.6ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Memcached exhibited lower latency for the read benchmark, but also lower throughput.&lt;/p&gt; &#xA;&lt;h3&gt;Memory efficiency&lt;/h3&gt; &#xA;&lt;p&gt;In the following test, we filled Dragonfly and Redis with ~5GB of data using &lt;code&gt;debug populate 5000000 key 1024&lt;/code&gt; command. Then we started sending the update traffic with &lt;code&gt;memtier&lt;/code&gt; and kicked off the snapshotting with the &#34;bgsave&#34; command. The following figure demonstrates clearly how both servers behave in terms of memory efficiency.&lt;/p&gt; &#xA;&lt;img src=&#34;http://assets.dragonflydb.io/repo-assets/bgsave-memusage.svg?sanitize=true&#34; width=&#34;70%&#34; border=&#34;0&#34;&gt; &#xA;&lt;p&gt;Dragonfly was 30% more memory efficient than Redis at the idle state. It also did not show any visible memory increase during the snapshot phase. Meanwhile, Redis reached almost x3 memory increase at peak compared to Dragonfly. Dragonfly also finished the snapshot much faster, just a few seconds after it started. For more info about memory efficiency in Dragonfly see &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/docs/dashtable.md&#34;&gt;dashtable doc&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Running the server&lt;/h2&gt; &#xA;&lt;p&gt;Dragonfly runs on linux. It uses relatively new linux specific &lt;a href=&#34;https://github.com/axboe/liburing&#34;&gt;io-uring API&lt;/a&gt; for I/O, hence it requires Linux version 5.10 or later. Debian/Bullseye, Ubuntu 20.04.4 or later fit these requirements.&lt;/p&gt; &#xA;&lt;h3&gt;With docker:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --network=host --ulimit memlock=-1 docker.dragonflydb.io/dragonflydb/dragonfly&#xA;&#xA;redis-cli PING  # redis-cli can be installed with &#34;apt install -y redis-tools&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;You need &lt;code&gt;--ulimit memlock=-1&lt;/code&gt; because some Linux distros configure the default memlock limit for containers as 64m and Dragonfly requires more.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Releases&lt;/h3&gt; &#xA;&lt;p&gt;We maintain &lt;a href=&#34;https://github.com/dragonflydb/dragonfly/releases&#34;&gt;binary releases&lt;/a&gt; for x86 and arm64 architectures. You will need to install &lt;code&gt;libunwind8&lt;/code&gt; lib to run the binaries.&lt;/p&gt; &#xA;&lt;h3&gt;Building from source&lt;/h3&gt; &#xA;&lt;p&gt;You need to install dependencies in order to build on Ubuntu 20.04 or later:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone --recursive https://github.com/dragonflydb/dragonfly &amp;amp;&amp;amp; cd dragonfly&#xA;&#xA;# to install dependencies&#xA;sudo apt install ninja-build libunwind-dev libboost-fiber-dev libssl-dev \&#xA;     autoconf-archive libtool cmake g++&#xA;&#xA;# Configure the build&#xA;./helio/blaze.sh -release&#xA;&#xA;# Build&#xA;cd build-opt &amp;amp;&amp;amp; ninja dragonfly&#xA;&#xA;# Run&#xA;./dragonfly --alsologtostderr&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Dragonfly supports common redis arguments where applicable. For example, you can run: &lt;code&gt;dragonfly --requirepass=foo --bind localhost&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Dragonfly currently supports the following Redis-specific arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;port&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;requirepass&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;maxmemory&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dir&lt;/code&gt; - by default, dragonfly docker uses &lt;code&gt;/data&lt;/code&gt; folder for snapshotting. You can use &lt;code&gt;-v&lt;/code&gt; docker option to map it to your host folder.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dbfilename&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition, it has Dragonfly specific arguments options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;memcache_port&lt;/code&gt; - to enable memcached compatible API on this port. Disabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;keys_output_limit&lt;/code&gt; - maximum number of returned keys in &lt;code&gt;keys&lt;/code&gt; command. Default is 8192. &lt;code&gt;keys&lt;/code&gt; is a dangerous command. We truncate its result to avoid blowup in memory when fetching too many keys.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dbnum&lt;/code&gt; - maximum number of supported databases for &lt;code&gt;select&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cache_mode&lt;/code&gt; - see &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/#novel-cache-design&#34;&gt;Cache&lt;/a&gt; section below.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hz&lt;/code&gt; - key expiry evaluation frequency. Default is 1000. Lower frequency uses less cpu when idle at the expense of precision in key eviction.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;for more options like logs management or tls support, run &lt;code&gt;dragonfly --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap and status&lt;/h2&gt; &#xA;&lt;p&gt;Currently Dragonfly supports ~130 Redis commands and all memcache commands besides &lt;code&gt;cas&lt;/code&gt;. We are almost on par with Redis 2.8 API. Our first milestone will be to stabilize basic functionality and reach API parity with Redis 2.8 and Memcached APIs. If you see that a command you need, is not implemented yet, please open an issue.&lt;/p&gt; &#xA;&lt;p&gt;The next milestone will be implementing H/A with &lt;code&gt;redis -&amp;gt; dragonfly&lt;/code&gt; and &lt;code&gt;dragonfly&amp;lt;-&amp;gt;dragonfly&lt;/code&gt; replication.&lt;/p&gt; &#xA;&lt;p&gt;For dragonfly-native replication, we are planning to design a distributed log format that will support order of magnitude higher speeds when replicating.&lt;/p&gt; &#xA;&lt;p&gt;After replication and failover feature we will continue with other Redis commands from APIs 3,4 and 5.&lt;/p&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/docs/api_status.md&#34;&gt;API readiness doc&lt;/a&gt; for the current status of Dragonfly.&lt;/p&gt; &#xA;&lt;h3&gt;Milestone - H/A&lt;/h3&gt; &#xA;&lt;p&gt;Implement leader/follower replication (PSYNC/REPLICAOF/...).&lt;/p&gt; &#xA;&lt;h3&gt;Milestone - &#34;Maturity&#34;&lt;/h3&gt; &#xA;&lt;p&gt;APIs 3,4,5 without cluster support, without modules and without memory introspection commands. Also without geo commands and without support for keyspace notifications, without streams. Probably design config support. Overall - few dozens commands... Probably implement cluster-API decorators to allow cluster-configured clients to connect to a single instance.&lt;/p&gt; &#xA;&lt;h3&gt;Next milestones will be determined along the way.&lt;/h3&gt; &#xA;&lt;h2&gt;Design decisions&lt;/h2&gt; &#xA;&lt;h3&gt;Novel cache design&lt;/h3&gt; &#xA;&lt;p&gt;Dragonfly has a single unified adaptive caching algorithm that is very simple and memory efficient. You can enable caching mode by passing &lt;code&gt;--cache_mode=true&lt;/code&gt; flag. Once this mode is on, Dragonfly will evict items least likely to be stumbled upon in the future but only when it is near maxmemory limit.&lt;/p&gt; &#xA;&lt;h3&gt;Expiration deadlines with relative accuracy&lt;/h3&gt; &#xA;&lt;p&gt;Expiration ranges are limited to ~4 years. Moreover, expiration deadlines with millisecond precision (PEXPIRE/PSETEX etc) will be rounded to closest second &lt;strong&gt;for deadlines greater than 134217727ms (approximately 37 hours)&lt;/strong&gt;. Such rounding has less than 0.001% error which I hope is acceptable for large ranges. If it breaks your use-cases - talk to me or open an issue and explain your case.&lt;/p&gt; &#xA;&lt;p&gt;For more detailed differences between this and Redis implementations &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/docs/differences.md&#34;&gt;see here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Native Http console and Prometheus compatible metrics&lt;/h3&gt; &#xA;&lt;p&gt;By default Dragonfly allows http access via its main TCP port (6379). That&#39;s right, you can connect to Dragonfly via Redis protocol and via HTTP protocol - the server recognizes the protocol automatically during the connection initiation. Go ahead and try it with your browser. Right now it does not have much info but in the future we are planning to add there useful debugging and management info. If you go to &lt;code&gt;:6379/metrics&lt;/code&gt; url you will see some prometheus compatible metrics.&lt;/p&gt; &#xA;&lt;p&gt;The Prometheus exported metrics are compatible with the Grafana dashboard &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/examples/grafana/dashboard.json&#34;&gt;see here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Important! Http console is meant to be accessed within a safe network. If you expose Dragonfly&#39;s TCP port externally, it is advised to disable the console with &lt;code&gt;--http_admin_console=false&lt;/code&gt; or &lt;code&gt;--nohttp_admin_console&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Dragonfly started as an experiment to see how an in-memory datastore could look like if it was designed in 2022. Based on lessons learned from our experience as users of memory stores and as engineers who worked for cloud companies, we knew that we need to preserve two key properties for Dragonfly: a) to provide atomicity guarantees for all its operations, and b) to guarantee low, sub-millisecond latency over very high throughput.&lt;/p&gt; &#xA;&lt;p&gt;Our first challenge was how to fully utilize CPU, memory, and i/o resources using servers that are available today in public clouds. To solve this, we used &lt;a href=&#34;https://en.wikipedia.org/wiki/Shared-nothing_architecture&#34;&gt;shared-nothing architecture&lt;/a&gt;, which allows us to partition the keyspace of the memory store between threads, so that each thread would manage its own slice of dictionary data. We call these slices - shards. The library that powers thread and I/O management for shared-nothing architecture is open-sourced &lt;a href=&#34;https://github.com/romange/helio&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To provide atomicity guarantees for multi-key operations, we used the advancements from recent academic research. We chose the paper &lt;a href=&#34;https://www.cs.umd.edu/~abadi/papers/vldbj-vll.pdf&#34;&gt;&#34;VLL: a lock manager redesign for main memory database systems‚Äù&lt;/a&gt; to develop the transactional framework for Dragonfly. The choice of shared-nothing architecture and VLL allowed us to compose atomic multi-key operations without using mutexes or spinlocks. This was a major milestone for our PoC and its performance stood out from other commercial and open-source solutions.&lt;/p&gt; &#xA;&lt;p&gt;Our second challenge was to engineer more efficient data structures for the new store. To achieve this goal, we based our core hashtable structure on paper &lt;a href=&#34;https://arxiv.org/pdf/2003.07302.pdf&#34;&gt;&#34;Dash: Scalable Hashing on Persistent Memory&#34;&lt;/a&gt;. The paper itself is centered around persistent memory domain and is not directly related to main-memory stores. Nevertheless, its very much applicable for our problem. It suggested a hashtable design that allowed us to maintain two special properties that are present in the Redis dictionary: a) its incremental hashing ability during datastore growth b) its ability to traverse the dictionary under changes using a stateless scan operation. Besides these 2 properties, Dash is much more efficient in CPU and memory. By leveraging Dash&#39;s design, we were able to innovate further with the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Efficient record expiry for TTL records.&lt;/li&gt; &#xA; &lt;li&gt;A novel cache eviction algorithm that achieves higher hit rates than other caching strategies like LRU and LFU with &lt;strong&gt;zero memory overhead&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A novel &lt;strong&gt;fork-less&lt;/strong&gt; snapshotting algorithm.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After we built the foundation for Dragonfly and &lt;a href=&#34;https://raw.githubusercontent.com/dragonflydb/dragonfly/main/#benchmarks&#34;&gt;we were happy with its performance&lt;/a&gt;, we went on to implement the Redis and Memcached functionality. By now, we have implemented ~130 Redis commands (equivalent to v2.8) and 13 Memcached commands.&lt;/p&gt; &#xA;&lt;p&gt;And finally, &lt;br&gt; &lt;em&gt;Our mission is to build a well-designed, ultra-fast, cost-efficient in-memory datastore for cloud workloads that takes advantage of the latest hardware advancements. We intend to address the pain points of current solutions while preserving their product APIs and propositions. &lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ethereum/solidity</title>
    <updated>2022-08-14T02:01:05Z</updated>
    <id>tag:github.com,2022-08-14:/ethereum/solidity</id>
    <link href="https://github.com/ethereum/solidity" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Solidity, the Smart Contract Programming Language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Solidity Contract-Oriented Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://matrix.to/#/#ethereum_solidity:gitter.im&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Matrix%20-chat-brightgreen?style=plastic&amp;amp;logo=matrix&#34; alt=&#34;Matrix Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/ethereum/solidity&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Gitter%20-chat-brightgreen?style=plastic&amp;amp;logo=gitter&#34; alt=&#34;Gitter Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://forum.soliditylang.org/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Solidity_Forum%20-discuss-brightgreen?style=plastic&amp;amp;logo=discourse&#34; alt=&#34;Solidity&amp;nbsp;Forum&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/solidity_lang&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/solidity_lang?style=plastic&amp;amp;logo=twitter&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://fosstodon.org/@solidity&#34;&gt;&lt;img src=&#34;https://img.shields.io/mastodon/follow/000335908?domain=https%3A%2F%2Ffosstodon.org%2F&amp;amp;logo=mastodon&amp;amp;style=plastic&#34; alt=&#34;Mastodon Follow&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can talk to us on Gitter and Matrix, tweet at us on Twitter or create a new topic in the Solidity forum. Questions, feedback, and suggestions are welcome!&lt;/p&gt; &#xA;&lt;p&gt;Solidity is a statically typed, contract-oriented, high-level language for implementing smart contracts on the Ethereum platform.&lt;/p&gt; &#xA;&lt;p&gt;For a good overview and starting point, please check out the official &lt;a href=&#34;https://soliditylang.org&#34;&gt;Solidity Language Portal&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#background&#34;&gt;Background&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#build-and-install&#34;&gt;Build and Install&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#documentation&#34;&gt;Documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#development&#34;&gt;Development&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#maintainers&#34;&gt;Maintainers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/#security&#34;&gt;Security&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Solidity is a statically-typed curly-braces programming language designed for developing smart contracts that run on the Ethereum Virtual Machine. Smart contracts are programs that are executed inside a peer-to-peer network where nobody has special authority over the execution, and thus they allow to implement tokens of value, ownership, voting, and other kinds of logic.&lt;/p&gt; &#xA;&lt;p&gt;When deploying contracts, you should use the latest released version of Solidity. This is because breaking changes, as well as new features and bug fixes are introduced regularly. We currently use a 0.x version number &lt;a href=&#34;https://semver.org/#spec-item-4&#34;&gt;to indicate this fast pace of change&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Build and Install&lt;/h2&gt; &#xA;&lt;p&gt;Instructions about how to build and install the Solidity compiler can be found in the &lt;a href=&#34;https://docs.soliditylang.org/en/latest/installing-solidity.html#building-from-source&#34;&gt;Solidity documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;A &#34;Hello World&#34; program in Solidity is of even less use than in other languages, but still:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;// SPDX-License-Identifier: MIT&#xA;pragma solidity &amp;gt;=0.6.0 &amp;lt;0.9.0;&#xA;&#xA;contract HelloWorld {&#xA;    function helloWorld() external pure returns (string memory) {&#xA;        return &#34;Hello, World!&#34;;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get started with Solidity, you can use &lt;a href=&#34;https://remix.ethereum.org/&#34;&gt;Remix&lt;/a&gt;, which is a browser-based IDE. Here are some example contracts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.soliditylang.org/en/latest/solidity-by-example.html#voting&#34;&gt;Voting&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.soliditylang.org/en/latest/solidity-by-example.html#blind-auction&#34;&gt;Blind Auction&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.soliditylang.org/en/latest/solidity-by-example.html#safe-remote-purchase&#34;&gt;Safe remote purchase&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.soliditylang.org/en/latest/solidity-by-example.html#micropayment-channel&#34;&gt;Micropayment Channel&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The Solidity documentation is hosted at &lt;a href=&#34;https://docs.soliditylang.org&#34;&gt;Read the docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Solidity is still under development. Contributions are always welcome! Please follow the &lt;a href=&#34;https://docs.soliditylang.org/en/latest/contributing.html&#34;&gt;Developers Guide&lt;/a&gt; if you want to help.&lt;/p&gt; &#xA;&lt;p&gt;You can find our current feature and bug priorities for forthcoming releases in the &lt;a href=&#34;https://github.com/ethereum/solidity/projects&#34;&gt;projects section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Maintainers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/axic&#34;&gt;@axic&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/chriseth&#34;&gt;@chriseth&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Solidity is licensed under &lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/LICENSE.txt&#34;&gt;GNU General Public License v3.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Some third-party code has its &lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/cmake/templates/license.h.in&#34;&gt;own licensing terms&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Security&lt;/h2&gt; &#xA;&lt;p&gt;The security policy may be &lt;a href=&#34;https://raw.githubusercontent.com/ethereum/solidity/develop/SECURITY.md&#34;&gt;found here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>duckdb/duckdb</title>
    <updated>2022-08-14T02:01:05Z</updated>
    <id>tag:github.com,2022-08-14:/duckdb/duckdb</id>
    <link href="https://github.com/duckdb/duckdb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;DuckDB is an in-process SQL OLAP Database Management System&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://duckdb.org/images/DuckDB_Logo_dl.png&#34; height=&#34;50&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&amp;nbsp;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/duckdb/duckdb/actions&#34;&gt; &lt;img src=&#34;https://github.com/duckdb/duckdb/actions/workflows/Main.yml/badge.svg?branch=master&#34; alt=&#34;Github Actions Badge&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://www.codefactor.io/repository/github/cwida/duckdb&#34;&gt; &lt;img src=&#34;https://www.codefactor.io/repository/github/cwida/duckdb/badge&#34; alt=&#34;CodeFactor&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://app.codecov.io/gh/duckdb/duckdb&#34;&gt; &lt;img src=&#34;https://codecov.io/gh/duckdb/duckdb/branch/master/graph/badge.svg?token=FaxjcfFghN&#34; alt=&#34;codecov&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://discord.gg/tcvwpjfnZx&#34;&gt; &lt;img src=&#34;https://shields.io/discord/909674491309850675&#34; alt=&#34;discord&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h2&gt;DuckDB&lt;/h2&gt; &#xA;&lt;p&gt;DuckDB is a high-performance analytical database system. It is designed to be fast, reliable and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more. For more information on the goals of DuckDB, please refer to &lt;a href=&#34;https://duckdb.org/why_duckdb&#34;&gt;the Why DuckDB page on our website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;If you want to install and use DuckDB, please see &lt;a href=&#34;https://www.duckdb.org&#34;&gt;our website&lt;/a&gt; for installation and usage instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Data Import&lt;/h2&gt; &#xA;&lt;p&gt;For CSV files and Parquet files, data import is as simple as referencing the file in the FROM clause:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT * FROM &#39;myfile.csv&#39;;&#xA;SELECT * FROM &#39;myfile.parquet&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refer to our &lt;a href=&#34;https://duckdb.org/docs/data/overview&#34;&gt;Data Import&lt;/a&gt; section for more information.&lt;/p&gt; &#xA;&lt;h2&gt;SQL Reference&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://duckdb.org/docs/sql/introduction&#34;&gt;website&lt;/a&gt; contains a reference of functions and SQL constructs available in DuckDB.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;For development, DuckDB requires &lt;a href=&#34;https://cmake.org&#34;&gt;CMake&lt;/a&gt;, Python3 and a &lt;code&gt;C++11&lt;/code&gt; compliant compiler. Run &lt;code&gt;make&lt;/code&gt; in the root directory to compile the sources. For development, use &lt;code&gt;make debug&lt;/code&gt; to build a non-optimized debug version. You should run &lt;code&gt;make unit&lt;/code&gt; and &lt;code&gt;make allunit&lt;/code&gt; to verify that your version works properly after making changes. To test performance, you can run &lt;code&gt;BUILD_BENCHMARK=1 BUILD_TPCH=1 make&lt;/code&gt; and then perform several standard benchmarks from the root directory by executing &lt;code&gt;./build/release/benchmark/benchmark_runner&lt;/code&gt;. The detail of benchmarks is in our &lt;a href=&#34;https://raw.githubusercontent.com/duckdb/duckdb/master/benchmark/README.md&#34;&gt;Benchmark Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please also refer to our &lt;a href=&#34;https://raw.githubusercontent.com/duckdb/duckdb/master/CONTRIBUTING.md&#34;&gt;Contribution Guide&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>