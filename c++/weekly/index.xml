<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-04T01:47:41Z</updated>
  <subtitle>Weekly Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yhirose/cpp-httplib</title>
    <updated>2024-02-04T01:47:41Z</updated>
    <id>tag:github.com,2024-02-04:/yhirose/cpp-httplib</id>
    <link href="https://github.com/yhirose/cpp-httplib" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A C++ header-only HTTP/HTTPS server and client library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;cpp-httplib&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/yhirose/cpp-httplib/actions&#34;&gt;&lt;img src=&#34;https://github.com/yhirose/cpp-httplib/workflows/test/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A C++11 single-file header-only cross platform HTTP/HTTPS library.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s extremely easy to setup. Just include the &lt;strong&gt;httplib.h&lt;/strong&gt; file in your code!&lt;/p&gt; &#xA;&lt;p&gt;NOTE: This library uses &#39;blocking&#39; socket I/O. If you are looking for a library with &#39;non-blocking&#39; socket I/O, this is not the one that you want.&lt;/p&gt; &#xA;&lt;h2&gt;Simple examples&lt;/h2&gt; &#xA;&lt;h4&gt;Server (Multi-threaded)&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define CPPHTTPLIB_OPENSSL_SUPPORT&#xA;#include &#34;path/to/httplib.h&#34;&#xA;&#xA;// HTTP&#xA;httplib::Server svr;&#xA;&#xA;// HTTPS&#xA;httplib::SSLServer svr;&#xA;&#xA;svr.Get(&#34;/hi&#34;, [](const httplib::Request &amp;amp;, httplib::Response &amp;amp;res) {&#xA;  res.set_content(&#34;Hello World!&#34;, &#34;text/plain&#34;);&#xA;});&#xA;&#xA;svr.listen(&#34;0.0.0.0&#34;, 8080);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Client&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define CPPHTTPLIB_OPENSSL_SUPPORT&#xA;#include &#34;path/to/httplib.h&#34;&#xA;&#xA;// HTTP&#xA;httplib::Client cli(&#34;http://cpp-httplib-server.yhirose.repl.co&#34;);&#xA;&#xA;// HTTPS&#xA;httplib::Client cli(&#34;https://cpp-httplib-server.yhirose.repl.co&#34;);&#xA;&#xA;auto res = cli.Get(&#34;/hi&#34;);&#xA;res-&amp;gt;status;&#xA;res-&amp;gt;body;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SSL Support&lt;/h2&gt; &#xA;&lt;p&gt;SSL support is available with &lt;code&gt;CPPHTTPLIB_OPENSSL_SUPPORT&lt;/code&gt;. &lt;code&gt;libssl&lt;/code&gt; and &lt;code&gt;libcrypto&lt;/code&gt; should be linked.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: cpp-httplib currently supports only version 3.0 or later. Please see &lt;a href=&#34;https://www.openssl.org/policies/releasestrat.html&#34;&gt;this page&lt;/a&gt; to get more information.&lt;/p&gt; &#xA;&lt;p&gt;NOTE for macOS: cpp-httplib now can use system certs with &lt;code&gt;CPPHTTPLIB_USE_CERTS_FROM_MACOSX_KEYCHAIN&lt;/code&gt;. &lt;code&gt;CoreFoundation&lt;/code&gt; and &lt;code&gt;Security&lt;/code&gt; should be linked with &lt;code&gt;-framework&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define CPPHTTPLIB_OPENSSL_SUPPORT&#xA;#include &#34;path/to/httplib.h&#34;&#xA;&#xA;// Server&#xA;httplib::SSLServer svr(&#34;./cert.pem&#34;, &#34;./key.pem&#34;);&#xA;&#xA;// Client&#xA;httplib::Client cli(&#34;https://localhost:1234&#34;); // scheme + host&#xA;httplib::SSLClient cli(&#34;localhost:1234&#34;); // host&#xA;httplib::SSLClient cli(&#34;localhost&#34;, 1234); // host, port&#xA;&#xA;// Use your CA bundle&#xA;cli.set_ca_cert_path(&#34;./ca-bundle.crt&#34;);&#xA;&#xA;// Disable cert verification&#xA;cli.enable_server_certificate_verification(false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: When using SSL, it seems impossible to avoid SIGPIPE in all cases, since on some operating systems, SIGPIPE can only be suppressed on a per-message basis, but there is no way to make the OpenSSL library do so for its internal communications. If your program needs to avoid being terminated on SIGPIPE, the only fully general way might be to set up a signal handler for SIGPIPE to handle or ignore it yourself.&lt;/p&gt; &#xA;&lt;h2&gt;Server&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;httplib.h&amp;gt;&#xA;&#xA;int main(void)&#xA;{&#xA;  using namespace httplib;&#xA;&#xA;  Server svr;&#xA;&#xA;  svr.Get(&#34;/hi&#34;, [](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;    res.set_content(&#34;Hello World!&#34;, &#34;text/plain&#34;);&#xA;  });&#xA;&#xA;  // Match the request path against a regular expression&#xA;  // and extract its captures&#xA;  svr.Get(R&#34;(/numbers/(\d+))&#34;, [&amp;amp;](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;    auto numbers = req.matches[1];&#xA;    res.set_content(numbers, &#34;text/plain&#34;);&#xA;  });&#xA;&#xA;  // Capture the second segment of the request path as &#34;id&#34; path param&#xA;  svr.Get(&#34;/users/:id&#34;, [&amp;amp;](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;    auto user_id = req.path_params.at(&#34;id&#34;);&#xA;    res.set_content(user_id, &#34;text/plain&#34;);&#xA;  });&#xA;&#xA;  // Extract values from HTTP headers and URL query params&#xA;  svr.Get(&#34;/body-header-param&#34;, [](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;    if (req.has_header(&#34;Content-Length&#34;)) {&#xA;      auto val = req.get_header_value(&#34;Content-Length&#34;);&#xA;    }&#xA;    if (req.has_param(&#34;key&#34;)) {&#xA;      auto val = req.get_param_value(&#34;key&#34;);&#xA;    }&#xA;    res.set_content(req.body, &#34;text/plain&#34;);&#xA;  });&#xA;&#xA;  svr.Get(&#34;/stop&#34;, [&amp;amp;](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;    svr.stop();&#xA;  });&#xA;&#xA;  svr.listen(&#34;localhost&#34;, 1234);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Post&lt;/code&gt;, &lt;code&gt;Put&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; and &lt;code&gt;Options&lt;/code&gt; methods are also supported.&lt;/p&gt; &#xA;&lt;h3&gt;Bind a socket to multiple interfaces and any available port&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int port = svr.bind_to_any_port(&#34;0.0.0.0&#34;);&#xA;svr.listen_after_bind();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Static File Server&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Mount / to ./www directory&#xA;auto ret = svr.set_mount_point(&#34;/&#34;, &#34;./www&#34;);&#xA;if (!ret) {&#xA;  // The specified base directory doesn&#39;t exist...&#xA;}&#xA;&#xA;// Mount /public to ./www directory&#xA;ret = svr.set_mount_point(&#34;/public&#34;, &#34;./www&#34;);&#xA;&#xA;// Mount /public to ./www1 and ./www2 directories&#xA;ret = svr.set_mount_point(&#34;/public&#34;, &#34;./www1&#34;); // 1st order to search&#xA;ret = svr.set_mount_point(&#34;/public&#34;, &#34;./www2&#34;); // 2nd order to search&#xA;&#xA;// Remove mount /&#xA;ret = svr.remove_mount_point(&#34;/&#34;);&#xA;&#xA;// Remove mount /public&#xA;ret = svr.remove_mount_point(&#34;/public&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// User defined file extension and MIME type mappings&#xA;svr.set_file_extension_and_mimetype_mapping(&#34;cc&#34;, &#34;text/x-c&#34;);&#xA;svr.set_file_extension_and_mimetype_mapping(&#34;cpp&#34;, &#34;text/x-c&#34;);&#xA;svr.set_file_extension_and_mimetype_mapping(&#34;hh&#34;, &#34;text/x-h&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The followings are built-in mappings:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Extension&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;MIME Type&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Extension&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;MIME Type&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;css&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;text/css&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mpga&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;audio/mpeg&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;csv&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;text/csv&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;weba&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;audio/webm&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;txt&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;text/plain&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;wav&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;audio/wave&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;vtt&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;text/vtt&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;otf&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;font/otf&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;html, htm&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;text/html&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;ttf&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;font/ttf&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;apng&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/apng&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;woff&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;font/woff&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;avif&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/avif&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;woff2&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;font/woff2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;bmp&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/bmp&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;7z&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/x-7z-compressed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;gif&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/gif&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;atom&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/atom+xml&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;png&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/png&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;pdf&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/pdf&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;svg&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/svg+xml&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mjs, js&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/javascript&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;webp&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/webp&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;json&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/json&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;ico&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/x-icon&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;rss&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/rss+xml&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;tif&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/tiff&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;tar&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/x-tar&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;tiff&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/tiff&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;xhtml, xht&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/xhtml+xml&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;jpeg, jpg&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;image/jpeg&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;xslt&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/xslt+xml&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mp4&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;video/mp4&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;xml&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/xml&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mpeg&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;video/mpeg&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;gz&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/gzip&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;webm&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;video/webm&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;zip&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/zip&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;mp3&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;audio/mp3&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;wasm&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;application/wasm&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;NOTE: These static file server methods are not thread-safe.&lt;/p&gt; &#xA;&lt;h3&gt;File request handler&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// The handler is called right before the response is sent to a client&#xA;svr.set_file_request_handler([](const Request &amp;amp;req, Response &amp;amp;res) {&#xA;  ...&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Logging&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.set_logger([](const auto&amp;amp; req, const auto&amp;amp; res) {&#xA;  your_logger(req, res);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Error handler&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.set_error_handler([](const auto&amp;amp; req, auto&amp;amp; res) {&#xA;  auto fmt = &#34;&amp;lt;p&amp;gt;Error Status: &amp;lt;span style=&#39;color:red;&#39;&amp;gt;%d&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;&#34;;&#xA;  char buf[BUFSIZ];&#xA;  snprintf(buf, sizeof(buf), fmt, res.status);&#xA;  res.set_content(buf, &#34;text/html&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exception handler&lt;/h3&gt; &#xA;&lt;p&gt;The exception handler gets called if a user routing handler throws an error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.set_exception_handler([](const auto&amp;amp; req, auto&amp;amp; res, std::exception_ptr ep) {&#xA;  auto fmt = &#34;&amp;lt;h1&amp;gt;Error 500&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;%s&amp;lt;/p&amp;gt;&#34;;&#xA;  char buf[BUFSIZ];&#xA;  try {&#xA;    std::rethrow_exception(ep);&#xA;  } catch (std::exception &amp;amp;e) {&#xA;    snprintf(buf, sizeof(buf), fmt, e.what());&#xA;  } catch (...) { // See the following NOTE&#xA;    snprintf(buf, sizeof(buf), fmt, &#34;Unknown Exception&#34;);&#xA;  }&#xA;  res.set_content(buf, &#34;text/html&#34;);&#xA;  res.status = StatusCode::InternalServerError_500;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: if you don&#39;t provide the &lt;code&gt;catch (...)&lt;/code&gt; block for a rethrown exception pointer, an uncaught exception will end up causing the server crash. Be careful!&lt;/p&gt; &#xA;&lt;h3&gt;Pre routing handler&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.set_pre_routing_handler([](const auto&amp;amp; req, auto&amp;amp; res) {&#xA;  if (req.path == &#34;/hello&#34;) {&#xA;    res.set_content(&#34;world&#34;, &#34;text/html&#34;);&#xA;    return Server::HandlerResponse::Handled;&#xA;  }&#xA;  return Server::HandlerResponse::Unhandled;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Post routing handler&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.set_post_routing_handler([](const auto&amp;amp; req, auto&amp;amp; res) {&#xA;  res.set_header(&#34;ADDITIONAL_HEADER&#34;, &#34;value&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&#39;multipart/form-data&#39; POST data&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.Post(&#34;/multipart&#34;, [&amp;amp;](const auto&amp;amp; req, auto&amp;amp; res) {&#xA;  auto size = req.files.size();&#xA;  auto ret = req.has_file(&#34;name1&#34;);&#xA;  const auto&amp;amp; file = req.get_file_value(&#34;name1&#34;);&#xA;  // file.filename;&#xA;  // file.content_type;&#xA;  // file.content;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Receive content with a content receiver&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.Post(&#34;/content_receiver&#34;,&#xA;  [&amp;amp;](const Request &amp;amp;req, Response &amp;amp;res, const ContentReader &amp;amp;content_reader) {&#xA;    if (req.is_multipart_form_data()) {&#xA;      // NOTE: `content_reader` is blocking until every form data field is read&#xA;      MultipartFormDataItems files;&#xA;      content_reader(&#xA;        [&amp;amp;](const MultipartFormData &amp;amp;file) {&#xA;          files.push_back(file);&#xA;          return true;&#xA;        },&#xA;        [&amp;amp;](const char *data, size_t data_length) {&#xA;          files.back().content.append(data, data_length);&#xA;          return true;&#xA;        });&#xA;    } else {&#xA;      std::string body;&#xA;      content_reader([&amp;amp;](const char *data, size_t data_length) {&#xA;        body.append(data, data_length);&#xA;        return true;&#xA;      });&#xA;    }&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send content with the content provider&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const size_t DATA_CHUNK_SIZE = 4;&#xA;&#xA;svr.Get(&#34;/stream&#34;, [&amp;amp;](const Request &amp;amp;req, Response &amp;amp;res) {&#xA;  auto data = new std::string(&#34;abcdefg&#34;);&#xA;&#xA;  res.set_content_provider(&#xA;    data-&amp;gt;size(), // Content length&#xA;    &#34;text/plain&#34;, // Content type&#xA;    [&amp;amp;, data](size_t offset, size_t length, DataSink &amp;amp;sink) {&#xA;      const auto &amp;amp;d = *data;&#xA;      sink.write(&amp;amp;d[offset], std::min(length, DATA_CHUNK_SIZE));&#xA;      return true; // return &#39;false&#39; if you want to cancel the process.&#xA;    },&#xA;    [data](bool success) { delete data; });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Without content length:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.Get(&#34;/stream&#34;, [&amp;amp;](const Request &amp;amp;req, Response &amp;amp;res) {&#xA;  res.set_content_provider(&#xA;    &#34;text/plain&#34;, // Content type&#xA;    [&amp;amp;](size_t offset, DataSink &amp;amp;sink) {&#xA;      if (/* there is still data */) {&#xA;        std::vector&amp;lt;char&amp;gt; data;&#xA;        // prepare data...&#xA;        sink.write(data.data(), data.size());&#xA;      } else {&#xA;        sink.done(); // No more data&#xA;      }&#xA;      return true; // return &#39;false&#39; if you want to cancel the process.&#xA;    });&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chunked transfer encoding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.Get(&#34;/chunked&#34;, [&amp;amp;](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;  res.set_chunked_content_provider(&#xA;    &#34;text/plain&#34;,&#xA;    [](size_t offset, DataSink &amp;amp;sink) {&#xA;      sink.write(&#34;123&#34;, 3);&#xA;      sink.write(&#34;345&#34;, 3);&#xA;      sink.write(&#34;789&#34;, 3);&#xA;      sink.done(); // No more data&#xA;      return true; // return &#39;false&#39; if you want to cancel the process.&#xA;    }&#xA;  );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With trailer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.Get(&#34;/chunked&#34;, [&amp;amp;](const Request&amp;amp; req, Response&amp;amp; res) {&#xA;  res.set_header(&#34;Trailer&#34;, &#34;Dummy1, Dummy2&#34;);&#xA;  res.set_chunked_content_provider(&#xA;    &#34;text/plain&#34;,&#xA;    [](size_t offset, DataSink &amp;amp;sink) {&#xA;      sink.write(&#34;123&#34;, 3);&#xA;      sink.write(&#34;345&#34;, 3);&#xA;      sink.write(&#34;789&#34;, 3);&#xA;      sink.done_with_trailer({&#xA;        {&#34;Dummy1&#34;, &#34;DummyVal1&#34;},&#xA;        {&#34;Dummy2&#34;, &#34;DummyVal2&#34;}&#xA;      });&#xA;      return true;&#xA;    }&#xA;  );&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&#39;Expect: 100-continue&#39; handler&lt;/h3&gt; &#xA;&lt;p&gt;By default, the server sends a &lt;code&gt;100 Continue&lt;/code&gt; response for an &lt;code&gt;Expect: 100-continue&lt;/code&gt; header.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Send a &#39;417 Expectation Failed&#39; response.&#xA;svr.set_expect_100_continue_handler([](const Request &amp;amp;req, Response &amp;amp;res) {&#xA;  return StatusCode::ExpectationFailed_417;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Send a final status without reading the message body.&#xA;svr.set_expect_100_continue_handler([](const Request &amp;amp;req, Response &amp;amp;res) {&#xA;  return res.status = StatusCode::Unauthorized_401;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Keep-Alive connection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.set_keep_alive_max_count(2); // Default is 5&#xA;svr.set_keep_alive_timeout(10);  // Default is 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeout&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;svr.set_read_timeout(5, 0); // 5 seconds&#xA;svr.set_write_timeout(5, 0); // 5 seconds&#xA;svr.set_idle_interval(0, 100000); // 100 milliseconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Set maximum payload length for reading a request body&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;svr.set_payload_max_length(1024 * 1024 * 512); // 512MB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: When the request body content type is &#39;www-form-urlencoded&#39;, the actual payload length shouldn&#39;t exceed &lt;code&gt;CPPHTTPLIB_FORM_URL_ENCODED_PAYLOAD_MAX_LENGTH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Server-Sent Events&lt;/h3&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/yhirose/cpp-httplib/raw/master/example/ssesvr.cc&#34;&gt;Server example&lt;/a&gt; and &lt;a href=&#34;https://github.com/yhirose/cpp-httplib/raw/master/example/ssecli.cc&#34;&gt;Client example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Default thread pool support&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ThreadPool&lt;/code&gt; is used as a &lt;strong&gt;default&lt;/strong&gt; task queue, and the default thread count is 8, or &lt;code&gt;std:&lt;span&gt;🧵&lt;/span&gt;:hardware_concurrency()&lt;/code&gt;. You can change it with &lt;code&gt;CPPHTTPLIB_THREAD_POOL_COUNT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to set the thread count at runtime, there is no convenient way... But here is how.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.new_task_queue = [] { return new ThreadPool(12); };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also provide an optional parameter to limit the maximum number of pending requests, i.e. requests &lt;code&gt;accept()&lt;/code&gt;ed by the listener but still waiting to be serviced by worker threads.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;svr.new_task_queue = [] { return new ThreadPool(/*num_threads=*/12, /*max_queued_requests=*/18); };&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Default limit is 0 (unlimited). Once the limit is reached, the listener will shutdown the client connection.&lt;/p&gt; &#xA;&lt;h3&gt;Override the default thread pool with yours&lt;/h3&gt; &#xA;&lt;p&gt;You can supply your own thread pool implementation according to your need.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class YourThreadPoolTaskQueue : public TaskQueue {&#xA;public:&#xA;  YourThreadPoolTaskQueue(size_t n) {&#xA;    pool_.start_with_thread_count(n);&#xA;  }&#xA;&#xA;  virtual bool enqueue(std::function&amp;lt;void()&amp;gt; fn) override {&#xA;    /* Return true if the task was actually enqueued, or false&#xA;     * if the caller must drop the corresponding connection. */&#xA;    return pool_.enqueue(fn);&#xA;  }&#xA;&#xA;  virtual void shutdown() override {&#xA;    pool_.shutdown_gracefully();&#xA;  }&#xA;&#xA;private:&#xA;  YourThreadPool pool_;&#xA;};&#xA;&#xA;svr.new_task_queue = [] {&#xA;  return new YourThreadPoolTaskQueue(12);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Client&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;httplib.h&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;&#xA;int main(void)&#xA;{&#xA;  httplib::Client cli(&#34;localhost&#34;, 1234);&#xA;&#xA;  if (auto res = cli.Get(&#34;/hi&#34;)) {&#xA;    if (res-&amp;gt;status == StatusCode::OK_200) {&#xA;      std::cout &amp;lt;&amp;lt; res-&amp;gt;body &amp;lt;&amp;lt; std::endl;&#xA;    }&#xA;  } else {&#xA;    auto err = res.error();&#xA;    std::cout &amp;lt;&amp;lt; &#34;HTTP error: &#34; &amp;lt;&amp;lt; httplib::to_string(err) &amp;lt;&amp;lt; std::endl;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: Constructor with scheme-host-port string is now supported!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;httplib::Client cli(&#34;localhost&#34;);&#xA;httplib::Client cli(&#34;localhost:8080&#34;);&#xA;httplib::Client cli(&#34;http://localhost&#34;);&#xA;httplib::Client cli(&#34;http://localhost:8080&#34;);&#xA;httplib::Client cli(&#34;https://localhost&#34;);&#xA;httplib::SSLClient cli(&#34;localhost&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Error code&lt;/h3&gt; &#xA;&lt;p&gt;Here is the list of errors from &lt;code&gt;Result::error()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum Error {&#xA;  Success = 0,&#xA;  Unknown,&#xA;  Connection,&#xA;  BindIPAddress,&#xA;  Read,&#xA;  Write,&#xA;  ExceedRedirectCount,&#xA;  Canceled,&#xA;  SSLConnection,&#xA;  SSLLoadingCerts,&#xA;  SSLServerVerification,&#xA;  UnsupportedMultipartBoundaryChars,&#xA;  Compression,&#xA;  ConnectionTimeout,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GET with HTTP headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;httplib::Headers headers = {&#xA;  { &#34;Accept-Encoding&#34;, &#34;gzip, deflate&#34; }&#xA;};&#xA;auto res = cli.Get(&#34;/hi&#34;, headers);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto res = cli.Get(&#34;/hi&#34;, {{&#34;Accept-Encoding&#34;, &#34;gzip, deflate&#34;}});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cli.set_default_headers({&#xA;  { &#34;Accept-Encoding&#34;, &#34;gzip, deflate&#34; }&#xA;});&#xA;auto res = cli.Get(&#34;/hi&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;POST&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;res = cli.Post(&#34;/post&#34;, &#34;text&#34;, &#34;text/plain&#34;);&#xA;res = cli.Post(&#34;/person&#34;, &#34;name=john1&amp;amp;note=coder&#34;, &#34;application/x-www-form-urlencoded&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;POST with parameters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;httplib::Params params;&#xA;params.emplace(&#34;name&#34;, &#34;john&#34;);&#xA;params.emplace(&#34;note&#34;, &#34;coder&#34;);&#xA;&#xA;auto res = cli.Post(&#34;/post&#34;, params);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;httplib::Params params{&#xA;  { &#34;name&#34;, &#34;john&#34; },&#xA;  { &#34;note&#34;, &#34;coder&#34; }&#xA;};&#xA;&#xA;auto res = cli.Post(&#34;/post&#34;, params);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;POST with Multipart Form Data&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;httplib::MultipartFormDataItems items = {&#xA;  { &#34;text1&#34;, &#34;text default&#34;, &#34;&#34;, &#34;&#34; },&#xA;  { &#34;text2&#34;, &#34;aωb&#34;, &#34;&#34;, &#34;&#34; },&#xA;  { &#34;file1&#34;, &#34;h\ne\n\nl\nl\no\n&#34;, &#34;hello.txt&#34;, &#34;text/plain&#34; },&#xA;  { &#34;file2&#34;, &#34;{\n  \&#34;world\&#34;, true\n}\n&#34;, &#34;world.json&#34;, &#34;application/json&#34; },&#xA;  { &#34;file3&#34;, &#34;&#34;, &#34;&#34;, &#34;application/octet-stream&#34; },&#xA;};&#xA;&#xA;auto res = cli.Post(&#34;/multipart&#34;, items);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;PUT&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;res = cli.Put(&#34;/resource/foo&#34;, &#34;text&#34;, &#34;text/plain&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;DELETE&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;res = cli.Delete(&#34;/resource/foo&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OPTIONS&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;res = cli.Options(&#34;*&#34;);&#xA;res = cli.Options(&#34;/resource/foo&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Timeout&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cli.set_connection_timeout(0, 300000); // 300 milliseconds&#xA;cli.set_read_timeout(5, 0); // 5 seconds&#xA;cli.set_write_timeout(5, 0); // 5 seconds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Receive content with a content receiver&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string body;&#xA;&#xA;auto res = cli.Get(&#34;/large-data&#34;,&#xA;  [&amp;amp;](const char *data, size_t data_length) {&#xA;    body.append(data, data_length);&#xA;    return true;&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string body;&#xA;&#xA;auto res = cli.Get(&#xA;  &#34;/stream&#34;, Headers(),&#xA;  [&amp;amp;](const Response &amp;amp;response) {&#xA;    EXPECT_EQ(StatusCode::OK_200, response.status);&#xA;    return true; // return &#39;false&#39; if you want to cancel the request.&#xA;  },&#xA;  [&amp;amp;](const char *data, size_t data_length) {&#xA;    body.append(data, data_length);&#xA;    return true; // return &#39;false&#39; if you want to cancel the request.&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send content with a content provider&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string body = ...;&#xA;&#xA;auto res = cli.Post(&#xA;  &#34;/stream&#34;, body.size(),&#xA;  [](size_t offset, size_t length, DataSink &amp;amp;sink) {&#xA;    sink.write(body.data() + offset, length);&#xA;    return true; // return &#39;false&#39; if you want to cancel the request.&#xA;  },&#xA;  &#34;text/plain&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chunked transfer encoding&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto res = cli.Post(&#xA;  &#34;/stream&#34;,&#xA;  [](size_t offset, DataSink &amp;amp;sink) {&#xA;    sink.os &amp;lt;&amp;lt; &#34;chunked data 1&#34;;&#xA;    sink.os &amp;lt;&amp;lt; &#34;chunked data 2&#34;;&#xA;    sink.os &amp;lt;&amp;lt; &#34;chunked data 3&#34;;&#xA;    sink.done();&#xA;    return true; // return &#39;false&#39; if you want to cancel the request.&#xA;  },&#xA;  &#34;text/plain&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;With Progress Callback&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;httplib::Client cli(url, port);&#xA;&#xA;// prints: 0 / 000 bytes =&amp;gt; 50% complete&#xA;auto res = cli.Get(&#34;/&#34;, [](uint64_t len, uint64_t total) {&#xA;  printf(&#34;%lld / %lld bytes =&amp;gt; %d%% complete\n&#34;,&#xA;    len, total,&#xA;    (int)(len*100/total));&#xA;  return true; // return &#39;false&#39; if you want to cancel the request.&#xA;}&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/236374/33138910-495c4ecc-cf86-11e7-8693-2fc6d09615c4.gif&#34; alt=&#34;progress&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Authentication&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Basic Authentication&#xA;cli.set_basic_auth(&#34;user&#34;, &#34;pass&#34;);&#xA;&#xA;// Digest Authentication&#xA;cli.set_digest_auth(&#34;user&#34;, &#34;pass&#34;);&#xA;&#xA;// Bearer Token Authentication&#xA;cli.set_bearer_token_auth(&#34;token&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: OpenSSL is required for Digest Authentication.&lt;/p&gt; &#xA;&lt;h3&gt;Proxy server support&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cli.set_proxy(&#34;host&#34;, port);&#xA;&#xA;// Basic Authentication&#xA;cli.set_proxy_basic_auth(&#34;user&#34;, &#34;pass&#34;);&#xA;&#xA;// Digest Authentication&#xA;cli.set_proxy_digest_auth(&#34;user&#34;, &#34;pass&#34;);&#xA;&#xA;// Bearer Token Authentication&#xA;cli.set_proxy_bearer_token_auth(&#34;pass&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: OpenSSL is required for Digest Authentication.&lt;/p&gt; &#xA;&lt;h3&gt;Range&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;httplib::Client cli(&#34;httpbin.org&#34;);&#xA;&#xA;auto res = cli.Get(&#34;/range/32&#34;, {&#xA;  httplib::make_range_header({{1, 10}}) // &#39;Range: bytes=1-10&#39;&#xA;});&#xA;// res-&amp;gt;status should be 206.&#xA;// res-&amp;gt;body should be &#34;bcdefghijk&#34;.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;httplib::make_range_header({{1, 10}, {20, -1}})      // &#39;Range: bytes=1-10, 20-&#39;&#xA;httplib::make_range_header({{100, 199}, {500, 599}}) // &#39;Range: bytes=100-199, 500-599&#39;&#xA;httplib::make_range_header({{0, 0}, {-1, 1}})        // &#39;Range: bytes=0-0, -1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Keep-Alive connection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;httplib::Client cli(&#34;localhost&#34;, 1234);&#xA;&#xA;cli.Get(&#34;/hello&#34;);         // with &#34;Connection: close&#34;&#xA;&#xA;cli.set_keep_alive(true);&#xA;cli.Get(&#34;/world&#34;);&#xA;&#xA;cli.set_keep_alive(false);&#xA;cli.Get(&#34;/last-request&#34;);  // with &#34;Connection: close&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redirect&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;httplib::Client cli(&#34;yahoo.com&#34;);&#xA;&#xA;auto res = cli.Get(&#34;/&#34;);&#xA;res-&amp;gt;status; // 301&#xA;&#xA;cli.set_follow_location(true);&#xA;res = cli.Get(&#34;/&#34;);&#xA;res-&amp;gt;status; // 200&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Use a specific network interface&lt;/h3&gt; &#xA;&lt;p&gt;NOTE: This feature is not available on Windows, yet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cli.set_interface(&#34;eth0&#34;); // Interface name, IP address or host name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compression&lt;/h2&gt; &#xA;&lt;p&gt;The server can apply compression to the following MIME type contents:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;all text types except text/event-stream&lt;/li&gt; &#xA; &lt;li&gt;image/svg+xml&lt;/li&gt; &#xA; &lt;li&gt;application/javascript&lt;/li&gt; &#xA; &lt;li&gt;application/json&lt;/li&gt; &#xA; &lt;li&gt;application/xml&lt;/li&gt; &#xA; &lt;li&gt;application/xhtml+xml&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Zlib Support&lt;/h3&gt; &#xA;&lt;p&gt;&#39;gzip&#39; compression is available with &lt;code&gt;CPPHTTPLIB_ZLIB_SUPPORT&lt;/code&gt;. &lt;code&gt;libz&lt;/code&gt; should be linked.&lt;/p&gt; &#xA;&lt;h3&gt;Brotli Support&lt;/h3&gt; &#xA;&lt;p&gt;Brotli compression is available with &lt;code&gt;CPPHTTPLIB_BROTLI_SUPPORT&lt;/code&gt;. Necessary libraries should be linked. Please see &lt;a href=&#34;https://github.com/google/brotli&#34;&gt;https://github.com/google/brotli&lt;/a&gt; for more detail.&lt;/p&gt; &#xA;&lt;h3&gt;Compress request body on client&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cli.set_compress(true);&#xA;res = cli.Post(&#34;/resource/foo&#34;, &#34;...&#34;, &#34;text/plain&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compress response body on client&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cli.set_decompress(false);&#xA;res = cli.Get(&#34;/resource/foo&#34;, {{&#34;Accept-Encoding&#34;, &#34;gzip, deflate, br&#34;}});&#xA;res-&amp;gt;body; // Compressed data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Use &lt;code&gt;poll&lt;/code&gt; instead of &lt;code&gt;select&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;select&lt;/code&gt; system call is used as default since it&#39;s more widely supported. If you want to let cpp-httplib use &lt;code&gt;poll&lt;/code&gt; instead, you can do so with &lt;code&gt;CPPHTTPLIB_USE_POLL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Split httplib.h into .h and .cc&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./split.py -h&#xA;usage: split.py [-h] [-e EXTENSION] [-o OUT]&#xA;&#xA;This script splits httplib.h into .h and .cc parts.&#xA;&#xA;optional arguments:&#xA;  -h, --help            show this help message and exit&#xA;  -e EXTENSION, --extension EXTENSION&#xA;                        extension of the implementation file (default: cc)&#xA;  -o OUT, --out OUT     where to write the files (default: out)&#xA;&#xA;$ ./split.py&#xA;Wrote out/httplib.h and out/httplib.cc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;NOTE&lt;/h2&gt; &#xA;&lt;h3&gt;g++&lt;/h3&gt; &#xA;&lt;p&gt;g++ 4.8 and below cannot build this library since &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; in the versions are &lt;a href=&#34;https://stackoverflow.com/questions/12530406/is-gcc-4-8-or-earlier-buggy-about-regular-expressions&#34;&gt;broken&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;Include &lt;code&gt;httplib.h&lt;/code&gt; before &lt;code&gt;Windows.h&lt;/code&gt; or include &lt;code&gt;Windows.h&lt;/code&gt; by defining &lt;code&gt;WIN32_LEAN_AND_MEAN&lt;/code&gt; beforehand.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;httplib.h&amp;gt;&#xA;#include &amp;lt;Windows.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define WIN32_LEAN_AND_MEAN&#xA;#include &amp;lt;Windows.h&amp;gt;&#xA;#include &amp;lt;httplib.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: cpp-httplib officially supports only the latest Visual Studio. It might work with former versions of Visual Studio, but I can no longer verify it. Pull requests are always welcome for the older versions of Visual Studio unless they break the C++11 conformance.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: Windows 8 or lower, Visual Studio 2013 or lower, and Cygwin and MSYS2 including MinGW are neither supported nor tested.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT license (© 2024 Yuji Hirose)&lt;/p&gt; &#xA;&lt;h2&gt;Special Thanks To&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/yhirose/cpp-httplib/graphs/contributors&#34;&gt;These folks&lt;/a&gt; made great contributions to polish this library to totally another level from a simple toy!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>localcc/PalworldModdingKit</title>
    <updated>2024-02-04T01:47:41Z</updated>
    <id>tag:github.com,2024-02-04:/localcc/PalworldModdingKit</id>
    <link href="https://github.com/localcc/PalworldModdingKit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modding kit for Palworld&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Palworld game sdk&lt;/h1&gt; &#xA;&lt;p&gt;This sdk allows for creation of blueprint mods referencing game functions, which makes it possible to add custom pals, change player behavior, modify constants, etc.&lt;/p&gt; &#xA;&lt;p&gt;Simple example usage could look like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/localcc/PalworldModdingKit/main/assets/SetInventoryWeight.png&#34; alt=&#34;Set inventory weight&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Installing the SDK&lt;/h1&gt; &#xA;&lt;h3&gt;You can find the guide for installing the sdk &lt;a href=&#34;https://pwmodding.wiki&#34;&gt;here&lt;/a&gt;&lt;/h3&gt;</summary>
  </entry>
  <entry>
    <title>ton-blockchain/ton</title>
    <updated>2024-02-04T01:47:41Z</updated>
    <id>tag:github.com,2024-02-04:/ton-blockchain/ton</id>
    <link href="https://github.com/ton-blockchain/ton" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Main TON monorepo&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://ton.org&#34;&gt; &#xA;  &lt;picture&gt; &#xA;   &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://ton.org/download/ton_logo_dark_background.svg&#34;&gt; &#xA;   &lt;img alt=&#34;TON logo&#34; src=&#34;https://ton.org/download/ton_logo_light_background.svg?sanitize=true&#34;&gt; &#xA;  &lt;/picture&gt; &lt;/a&gt; &#xA; &lt;h3&gt;Reference implementation of TON Node and tools&lt;/h3&gt; &#xA; &lt;hr&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://answers.ton.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-TON%20Overflow-FE7A16?style=flat&amp;amp;logo=stack-overflow&amp;amp;logoColor=white&#34; alt=&#34;TON Overflow Group&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://stackoverflow.com/questions/tagged/ton&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-Stack%20Overflow-FE7A16?style=flat&amp;amp;logo=stack-overflow&amp;amp;logoColor=white&#34; alt=&#34;Stack Overflow Group&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/tondev_eng&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-TONDev-2CA5E0?logo=telegram&amp;amp;logoColor=white&amp;amp;style=flat&#34; alt=&#34;Telegram Community Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/toncoin&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/TON%20Community-2CA5E0?logo=telegram&amp;amp;logoColor=white&amp;amp;style=flat&#34; alt=&#34;Telegram Community Group&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/tonblockchain&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/TON%20Foundation-2CA5E0?logo=telegram&amp;amp;logoColor=white&amp;amp;style=flat&#34; alt=&#34;Telegram Foundation Group&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/ton_blockchain&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/ton_blockchain&#34; alt=&#34;Twitter Group&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Main TON monorepo, which includes the code of the node/validator, lite-client, tonlib, FunC compiler, etc.&lt;/p&gt; &#xA;&lt;h2&gt;The Open Network&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;The Open Network (TON)&lt;/strong&gt; is a fast, secure, scalable blockchain focused on handling &lt;em&gt;millions of transactions per second&lt;/em&gt; (TPS) with the goal of reaching hundreds of millions of blockchain users.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To learn more about different aspects of TON blockchain and its underlying ecosystem check &lt;a href=&#34;https://ton.org/docs&#34;&gt;documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;To run node, validator or lite-server check &lt;a href=&#34;https://ton.org/docs/participate/nodes/run-node&#34;&gt;Participate section&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;To develop decentralised apps check &lt;a href=&#34;https://ton.org/docs/develop/smart-contracts/&#34;&gt;Tutorials&lt;/a&gt;, &lt;a href=&#34;https://ton.org/docs/develop/func/overview&#34;&gt;FunC docs&lt;/a&gt; and &lt;a href=&#34;https://ton.org/docs/develop/dapps/&#34;&gt;DApp tutorials&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;To work on TON check &lt;a href=&#34;https://ton.app/wallets&#34;&gt;wallets&lt;/a&gt;, &lt;a href=&#34;https://ton.app/explorers&#34;&gt;explorers&lt;/a&gt;, &lt;a href=&#34;https://ton.app/dex&#34;&gt;DEXes&lt;/a&gt; and &lt;a href=&#34;https://ton.app/utilities&#34;&gt;utilities&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;To interact with TON check &lt;a href=&#34;https://ton.org/docs/develop/dapps/apis/&#34;&gt;APIs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Updates flow&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;master branch&lt;/strong&gt; - mainnet is running on this stable branch.&lt;/p&gt; &lt;p&gt;Only emergency updates, urgent updates, or updates that do not affect the main codebase (GitHub workflows / docker images / documentation) are committed directly to this branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;testnet branch&lt;/strong&gt; - testnet is running on this branch. The branch contains a set of new updates. After testing, the testnet branch is merged into the master branch and then a new set of updates is added to testnet branch.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;backlog&lt;/strong&gt; - other branches that are candidates to getting into the testnet branch in the next iteration.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Usually, the response to your pull request will indicate which section it falls into.&lt;/p&gt; &#xA;&lt;h2&gt;&#34;Soft&#34; Pull Request rules&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thou shall not merge your own PRs, at least one person should review the PR and merge it (4-eyes rule)&lt;/li&gt; &#xA; &lt;li&gt;Thou shall make sure that workflows are cleanly completed for your PR before considering merge&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build TON blockchain&lt;/h2&gt; &#xA;&lt;h3&gt;Ubuntu 20.4, 22.04 (x86-64, aarch64)&lt;/h3&gt; &#xA;&lt;p&gt;Install additional system libraries&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  sudo apt-get update&#xA;  sudo apt-get install -y build-essential git cmake ninja-build zlib1g-dev libsecp256k1-dev libmicrohttpd-dev libsodium-dev&#xA;          &#xA;  wget https://apt.llvm.org/llvm.sh&#xA;  chmod +x llvm.sh&#xA;  sudo ./llvm.sh 16 all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile TON binaries&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  cp assembly/native/build-ubuntu-shared.sh .&#xA;  chmod +x build-ubuntu-shared.sh&#xA;  ./build-ubuntu-shared.sh  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MacOS 11, 12 (x86-64, aarch64)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  cp assembly/native/build-macos-shared.sh .&#xA;  chmod +x build-macos-shared.sh&#xA;  ./build-macos-shared.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows 10, 11, Server (x86-64)&lt;/h3&gt; &#xA;&lt;p&gt;You need to install &lt;code&gt;MS Visual Studio 2022&lt;/code&gt; first. Go to &lt;a href=&#34;https://www.visualstudio.com/downloads/&#34;&gt;https://www.visualstudio.com/downloads/&lt;/a&gt; and download &lt;code&gt;MS Visual Studio 2022 Community&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Launch installer and select &lt;code&gt;Desktop development with C++&lt;/code&gt;. After installation, also make sure that &lt;code&gt;cmake&lt;/code&gt; is globally available by adding &lt;code&gt;C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin&lt;/code&gt; to the system &lt;code&gt;PATH&lt;/code&gt; (adjust the path per your needs).&lt;/p&gt; &#xA;&lt;p&gt;Open an elevated (Run as Administrator) &lt;code&gt;x86-64 Native Tools Command Prompt for VS 2022&lt;/code&gt;, go to the root folder and execute:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  copy assembly\native\build-windows.bat .&#xA;  build-windows.bat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building TON to WebAssembly&lt;/h3&gt; &#xA;&lt;p&gt;Install additional system libraries on Ubuntu&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  sudo apt-get update&#xA;  sudo apt-get install -y build-essential git cmake ninja-build zlib1g-dev libsecp256k1-dev libmicrohttpd-dev libsodium-dev&#xA;          &#xA;  wget https://apt.llvm.org/llvm.sh&#xA;  chmod +x llvm.sh&#xA;  sudo ./llvm.sh 16 all&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile TON binaries with emscripten&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  cd assembly/wasm&#xA;  chmod +x fift-func-wasm-build-ubuntu.sh&#xA;  ./fift-func-wasm-build-ubuntu.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building TON tonlib library for Android (arm64-v8a, armeabi-v7a, x86, x86-64)&lt;/h3&gt; &#xA;&lt;p&gt;Install additional system libraries on Ubuntu&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  sudo apt-get update&#xA;  sudo apt-get install -y build-essential git cmake ninja-build automake libtool texinfo autoconf libgflags-dev \&#xA;  zlib1g-dev libssl-dev libreadline-dev libmicrohttpd-dev pkg-config libgsl-dev python3 python3-dev \&#xA;  libtool autoconf libsodium-dev libsecp256k1-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compile TON tonlib library&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  cp assembly/android/build-android-tonlib.sh .&#xA;  chmod +x build-android-tonlib.sh&#xA;  ./build-android-tonlib.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build TON portable binaries with Nix package manager&lt;/h3&gt; &#xA;&lt;p&gt;You need to install Nix first.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   sh &amp;lt;(curl -L https://nixos.org/nix/install) --daemon&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then compile TON with Nix by executing below command from the root folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  cp -r assembly/nix/* .&#xA;  export NIX_PATH=nixpkgs=https://github.com/nixOS/nixpkgs/archive/23.05.tar.gz&#xA;  nix-build linux-x86-64-static.nix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More examples for other platforms can be found under &lt;code&gt;assembly/nix&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Running tests&lt;/h2&gt; &#xA;&lt;p&gt;Tests are executed by running &lt;code&gt;ctest&lt;/code&gt; in the build directory. See &lt;code&gt;doc/Tests.md&lt;/code&gt; for more information.&lt;/p&gt;</summary>
  </entry>
</feed>