<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-15T01:27:41Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pard0p/Cordyceps</title>
    <updated>2023-10-15T01:27:41Z</updated>
    <id>tag:github.com,2023-10-15:/pard0p/Cordyceps</id>
    <link href="https://github.com/pard0p/Cordyceps" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C++ self-Injecting dropper based on various EDR evasion techniques.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ü¶† Cordyceps&lt;/h1&gt; &#xA;&lt;p&gt;This project consists of a simple C++ self-Injecting dropper focused on EDR evasion. To implement it, I have combined the use of &lt;strong&gt;&lt;code&gt;Windows Thread Pooling&lt;/code&gt;&lt;/strong&gt; to hide the call stack and the use of &lt;strong&gt;&lt;code&gt;indirect syscalls&lt;/code&gt;&lt;/strong&gt; to avoid hooking in the NTDLL. &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/pard0p/Cordyceps/assets/79936108/060db2ad-2c02-4501-bc86-5be0cff78711&#34; alt=&#34;2023-10-08-23-22-35-Trim&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/pard0p/Cordyceps/assets/79936108/5d2cb59c-0ea8-4f8b-ad68-298098e9b6c2&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/pard0p/Cordyceps/assets/79936108/1242c777-5c08-404d-8a7c-33da3e3cb478&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/pard0p/Cordyceps/assets/79936108/c74137be-8e4e-434b-b6c4-faf90baf7be2&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;As can be seen in the images, from the Cordyceps code, it performs a jump to ntdll to utilize one of the syscall instructions. This should be considered a malicious action; however, upon executing the return in ntdll, we return to the code of tpWorker, which is located within ntdll. Thus, from the perspective of the antivirus (AV), ntdll would appear to be making a call to another part of ntdll, which is not considered malicious.&lt;/p&gt; &#xA;&lt;h2&gt;Future Upgrades:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement a mechanism to automatically search for the syscall number.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; In-memory payload decryption.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;To compile:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nasm -f win64 ./syscalls.asm -o ./syscalls.obj&#xA;g++ -o cordyceps.exe main.cpp syscalls.obj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;‚ö†Ô∏èAttention:&lt;/h2&gt; &#xA;&lt;p&gt;This POC has been developed for Windows 10. To use it in a real environment the syscalls should be adapted for the corresponding Windows version.&lt;/p&gt; &#xA;&lt;h2&gt;Resources:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://0xdarkvortex.dev/hiding-in-plainsight/&#34;&gt;https://0xdarkvortex.dev/hiding-in-plainsight/&lt;/a&gt; &lt;a href=&#34;https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls&#34;&gt;https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls&lt;/a&gt; &lt;a href=&#34;https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html&#34;&gt;https://captmeelo.com/redteam/maldev/2022/05/10/ntcreateuserprocess.html&lt;/a&gt; &lt;a href=&#34;https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/&#34;&gt;https://klezvirus.github.io/RedTeaming/AV_Evasion/StackSpoofing/&lt;/a&gt; &lt;a href=&#34;https://medium.com/@sruthk/cracking-assembly-fastcall-calling-convention-in-x64-c6d77b51ea86&#34;&gt;https://medium.com/@sruthk/cracking-assembly-fastcall-calling-convention-in-x64-c6d77b51ea86&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>