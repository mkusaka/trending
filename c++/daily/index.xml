<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-13T01:32:54Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SerenityOS/jakt</title>
    <updated>2022-09-13T01:32:54Z</updated>
    <id>tag:github.com,2022-09-13:/SerenityOS/jakt</id>
    <link href="https://github.com/SerenityOS/jakt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Jakt Programming Language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Jakt programming language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Jakt&lt;/strong&gt; is a memory-safe systems programming language.&lt;/p&gt; &#xA;&lt;p&gt;It currently transpiles to C++.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The language is under heavy development.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; If you&#39;re cloning to a Windows PC (not WSL), make sure that your Git client keeps the line endings as &lt;code&gt;\n&lt;/code&gt;. You can set this as a global config via &lt;code&gt;git config --global core.autocrlf false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The transpilation to C++ requires &lt;code&gt;clang&lt;/code&gt;. Make sure you have that installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;jakt file.jakt&#xA;./build/file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/SerenityOS/jakt/main/documentation/cmake-bootstrap.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Memory safety&lt;/li&gt; &#xA; &lt;li&gt;Code readability&lt;/li&gt; &#xA; &lt;li&gt;Developer productivity&lt;/li&gt; &#xA; &lt;li&gt;Executable performance&lt;/li&gt; &#xA; &lt;li&gt;Fun!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Memory safety&lt;/h2&gt; &#xA;&lt;p&gt;The following strategies are employed to achieve memory safety:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatic reference counting&lt;/li&gt; &#xA; &lt;li&gt;Strong typing&lt;/li&gt; &#xA; &lt;li&gt;Bounds checking&lt;/li&gt; &#xA; &lt;li&gt;No raw pointers in safe mode&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In &lt;strong&gt;Jakt&lt;/strong&gt;, there are three pointer types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;T&lt;/strong&gt; (Strong pointer to reference-counted class &lt;code&gt;T&lt;/code&gt;.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;weak T?&lt;/strong&gt; (Weak pointer to reference-counted class &lt;code&gt;T&lt;/code&gt;. Becomes empty on pointee destruction.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;strong&gt;raw T&lt;/strong&gt; (Raw pointer to arbitrary type &lt;code&gt;T&lt;/code&gt;. Only usable in &lt;code&gt;unsafe&lt;/code&gt; blocks.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Null pointers are not possible in safe mode, but pointers can be wrapped in &lt;code&gt;Optional&lt;/code&gt;, i.e &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;T?&lt;/code&gt; for short.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;strong&gt;weak&lt;/strong&gt; pointers must always be wrapped in &lt;code&gt;Optional&lt;/code&gt;. There is no &lt;strong&gt;weak T&lt;/strong&gt;, only &lt;strong&gt;weak T?&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Math safety&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Integer overflow (both signed and unsigned) is a runtime error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Numeric values are not automatically coerced to &lt;code&gt;int&lt;/code&gt;. All casts must be explicit.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For cases where silent integer overflow is desired, there are explicit functions that provide this functionality.&lt;/p&gt; &#xA;&lt;h2&gt;Code readability&lt;/h2&gt; &#xA;&lt;p&gt;Far more time is spent reading code than writing it. For that reason, &lt;strong&gt;Jakt&lt;/strong&gt; puts a high emphasis on readability.&lt;/p&gt; &#xA;&lt;p&gt;Some of the features that encourage more readable programs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Immutable by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Argument labels in call expressions (&lt;code&gt;object.function(width: 10, height: 5)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Inferred &lt;code&gt;enum&lt;/code&gt; scope. (You can say &lt;code&gt;Foo&lt;/code&gt; instead of &lt;code&gt;MyEnum::Foo&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Pattern matching with &lt;code&gt;match&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Optional chaining (&lt;code&gt;foo?.bar?.baz&lt;/code&gt; (fallible) and &lt;code&gt;foo!.bar!.baz&lt;/code&gt; (infallible))&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; None coalescing for optionals (&lt;code&gt;foo ?? bar&lt;/code&gt; yields &lt;code&gt;foo&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; has a value, otherwise &lt;code&gt;bar&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;defer&lt;/code&gt; statements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Pointers are always dereferenced with &lt;code&gt;.&lt;/code&gt; (never &lt;code&gt;-&amp;gt;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Trailing closure parameters can be passed outside the call parentheses.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Error propagation with &lt;code&gt;ErrorOr&amp;lt;T&amp;gt;&lt;/code&gt; return type and dedicated &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;must&lt;/code&gt; keywords.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Function calls&lt;/h2&gt; &#xA;&lt;p&gt;When calling a function, you must specify the name of each argument as you&#39;re passing it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;rect.set_size(width: 640, height: 480)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are two exceptions to this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; If the parameter in the function declaration is declared as &lt;code&gt;anon&lt;/code&gt;, omitting the argument label is allowed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; When passing a variable with the same name as the parameter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Structures and classes&lt;/h2&gt; &#xA;&lt;p&gt;There are two main ways to declare a structure in &lt;strong&gt;Jakt&lt;/strong&gt;: &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Basic syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;struct Point {&#xA;    x: i64&#xA;    y: i64&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Structs in &lt;strong&gt;Jakt&lt;/strong&gt; have &lt;em&gt;value semantics&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Variables that contain a struct always have a unique instance of the struct.&lt;/li&gt; &#xA; &lt;li&gt;Copying a &lt;code&gt;struct&lt;/code&gt; instance always makes a deep copy.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;let a = Point(x: 10, y: 5)&#xA;let b = a&#xA;// &#34;b&#34; is a deep copy of &#34;a&#34;, they do not refer to the same Point&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Jakt&lt;/strong&gt; generates a default constructor for structs. It takes all fields by name. For the &lt;code&gt;Point&lt;/code&gt; struct above, it looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;Point(x: i64, y: i64)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Struct members are &lt;em&gt;public&lt;/em&gt; by default.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;class&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; basic class support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; private-by-default members&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; inheritance&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; class-based polymorphism (assign child instance to things requiring the parent type)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;code&gt;Super&lt;/code&gt; type&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; &lt;code&gt;Self&lt;/code&gt; type&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Same basic syntax as &lt;code&gt;struct&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;class Size {&#xA;    width: i64&#xA;    height: i64&#xA;&#xA;    public function area(this) =&amp;gt; .width * .height&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Classes in &lt;strong&gt;Jakt&lt;/strong&gt; have &lt;em&gt;reference semantics&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copying a &lt;code&gt;class&lt;/code&gt; instance (aka an &#34;object&#34;) copies a reference to the object.&lt;/li&gt; &#xA; &lt;li&gt;All objects are reference-counted by default. This ensures that objects don&#39;t get accessed after being deleted.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Class members are &lt;em&gt;private&lt;/em&gt; by default.&lt;/p&gt; &#xA;&lt;h3&gt;Member functions&lt;/h3&gt; &#xA;&lt;p&gt;Both structs and classes can have member functions.&lt;/p&gt; &#xA;&lt;p&gt;There are three kinds of member functions:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Static member functions&lt;/strong&gt; don&#39;t require an object to call. They have no &lt;code&gt;this&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;class Foo {&#xA;    function func() =&amp;gt; println(&#34;Hello!&#34;)&#xA;}&#xA;&#xA;// Foo::func() can be called without an object.&#xA;Foo::func()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Non-mutating member functions&lt;/strong&gt; require an object to be called, but cannot mutate the object. The first parameter is &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;class Foo {&#xA;    function func(this) =&amp;gt; println(&#34;Hello!&#34;)&#xA;}&#xA;&#xA;// Foo::func() can only be called on an instance of Foo.&#xA;let x = Foo()&#xA;x.func()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Mutating member functions&lt;/strong&gt; require an object to be called, and may modify the object. The first parameter is &lt;code&gt;mut this&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;class Foo {&#xA;    x: i64&#xA;&#xA;    function set(mut this, anon x: i64) {&#xA;        this.x = x&#xA;    }&#xA;}&#xA;&#xA;// Foo::set() can only be called on a mut Foo:&#xA;mut foo = Foo(x: 3)&#xA;foo.set(9)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shorthand for accessing member variables&lt;/h3&gt; &#xA;&lt;p&gt;To reduce repetitive &lt;code&gt;this.&lt;/code&gt; spam in methods, the shorthand &lt;code&gt;.foo&lt;/code&gt; expands to &lt;code&gt;this.foo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Arrays&lt;/h2&gt; &#xA;&lt;p&gt;Dynamic arrays are provided via a built-in &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type. They can grow and shrink at runtime.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Array&lt;/code&gt; is memory safe:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Out-of-bounds will panic the program with a runtime error.&lt;/li&gt; &#xA; &lt;li&gt;Slices of an &lt;code&gt;Array&lt;/code&gt; keep the underlying data alive via automatic reference counting.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Declaring arrays&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;// Function that takes an Array&amp;lt;i64&amp;gt; and returns an Array&amp;lt;String&amp;gt;&#xA;function foo(numbers: [i64]) -&amp;gt; [String] {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shorthand for creating arrays&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;// Array&amp;lt;i64&amp;gt; with 256 elements, all initialized to 0.&#xA;let values = [0; 256]&#xA;&#xA;// Array&amp;lt;String&amp;gt; with 3 elements: &#34;foo&#34;, &#34;bar&#34; and &#34;baz&#34;.&#xA;let values = [&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dictionaries&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Creating dictionaries&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Indexing dictionaries&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Assigning into indexes (aka lvalue)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;function main() {&#xA;    let dict = [&#34;a&#34;: 1, &#34;b&#34;: 2]&#xA;&#xA;    println(&#34;{}&#34;, dict[&#34;a&#34;])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Declaring dictionaries&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;// Function that takes a Dictionary&amp;lt;i64, String&amp;gt; and returns an Dictionary&amp;lt;String, bool&amp;gt;&#xA;function foo(numbers: [i64:String]) -&amp;gt; [String:bool] {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Shorthand for creating dictionaries&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;// Dictionary&amp;lt;String, i64&amp;gt; with 3 entries.&#xA;let values = [&#34;foo&#34;: 500, &#34;bar&#34;: 600, &#34;baz&#34;: 700]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Sets&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Creating sets&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Reference semantics&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;function main() {&#xA;    let set = {1, 2, 3}&#xA;&#xA;    println(&#34;{}&#34;, set.contains(1))&#xA;    println(&#34;{}&#34;, set.contains(5))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tuples&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Creating tuples&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Index tuples&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Tuple types&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;function main() {&#xA;    let x = (&#34;a&#34;, 2, true)&#xA;&#xA;    println(&#34;{}&#34;, x.1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Enums and Pattern Matching&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Enums as sum-types&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Generic enums&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Enums as names for values of an underlying type&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;match&lt;/code&gt; expressions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Enum scope inference in &lt;code&gt;match&lt;/code&gt; arms&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Yielding values from match blocks&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Nested &lt;code&gt;match&lt;/code&gt; patterns&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Traits as &lt;code&gt;match&lt;/code&gt; patterns&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Support for interop with the &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;??&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; operators&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;enum MyOptional&amp;lt;T&amp;gt; {&#xA;    Some(T)&#xA;    None&#xA;}&#xA;&#xA;function value_or_default&amp;lt;T&amp;gt;(anon x: MyOptional&amp;lt;T&amp;gt;, default: T) -&amp;gt; T {&#xA;    return match x {&#xA;        Some(value) =&amp;gt; {&#xA;            let stuff = maybe_do_stuff_with(value)&#xA;            let more_stuff = stuff.do_some_more_processing()&#xA;            yield more_stuff&#xA;        }&#xA;        None =&amp;gt; default&#xA;    }&#xA;}&#xA;&#xA;enum Foo {&#xA;    StructLikeThingy (&#xA;        field_a: i32&#xA;        field_b: i32&#xA;    )&#xA;}&#xA;&#xA;function look_at_foo(anon x: Foo) -&amp;gt; i32 {&#xA;    match x {&#xA;        StructLikeThingy(field_a: a, field_b) =&amp;gt; {&#xA;            return a + field_b&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;enum AlertDescription: i8 {&#xA;    CloseNotify = 0&#xA;    UnexpectedMessage = 10&#xA;    BadRecordMAC = 20&#xA;    // etc&#xA;}&#xA;&#xA;// Use in match:&#xA;function do_nothing_in_particular() =&amp;gt; match AlertDescription::CloseNotify {&#xA;    CloseNotify =&amp;gt; { ... }&#xA;    UnexpectedMessage =&amp;gt; { ... }&#xA;    BadRecordMAC =&amp;gt; { ... }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Generics&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Generic types&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Generic type inference&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Traits&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Jakt&lt;/strong&gt; supports both generic structures and generic functions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;function id&amp;lt;T&amp;gt;(anon x: T) -&amp;gt; T {&#xA;    return x&#xA;}&#xA;&#xA;function main() {&#xA;    let y = id(3)&#xA;&#xA;    println(&#34;{}&#34;, y + 1000)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;struct Foo&amp;lt;T&amp;gt; {&#xA;    x: T&#xA;}&#xA;&#xA;function main() {&#xA;    let f = Foo(x: 100)&#xA;&#xA;    println(&#34;{}&#34;, f.x)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Namespaces&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Namespace support for functions and struct/class/enum&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Deep namespace support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;namespace Greeters {&#xA;    function greet() {&#xA;        println(&#34;Well, hello friends&#34;)&#xA;    }&#xA;}&#xA;&#xA;function main() {&#xA;    Greeters::greet()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Type casts&lt;/h2&gt; &#xA;&lt;p&gt;There are two built-in casting operators in &lt;strong&gt;Jakt&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;as? T&lt;/code&gt;: Returns an &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;, empty if the source value isn&#39;t convertible to &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;as! T&lt;/code&gt;: Returns a &lt;code&gt;T&lt;/code&gt;, aborts the program if the source value isn&#39;t convertible to &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; cast can do these things (note that the implementation may not agree yet):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Casts to the same type are infallible and pointless, so might be forbidden in the future.&lt;/li&gt; &#xA; &lt;li&gt;If both types are primitive, a safe conversion is done. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Integer casts will fail if the value is out of range. This means that promotion casts like i32 -&amp;gt; i64 are infallible.&lt;/li&gt; &#xA;   &lt;li&gt;Float -&amp;gt; Integer casts truncate the decimal point (?)&lt;/li&gt; &#xA;   &lt;li&gt;Integer -&amp;gt; Float casts resolve to the closest value to the integer representable by the floating-point type (?). If the integer value is too large, they resolve to infinity (?)&lt;/li&gt; &#xA;   &lt;li&gt;Any primitive -&amp;gt; bool will create &lt;code&gt;true&lt;/code&gt; for any value except 0, which is &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;bool -&amp;gt; any primitive will do &lt;code&gt;false -&amp;gt; 0&lt;/code&gt; and &lt;code&gt;true -&amp;gt; 1&lt;/code&gt;, even for floats.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If the types are two different pointer types (see above), the cast is essentially a no-op. A cast to &lt;code&gt;T&lt;/code&gt; will increment the reference count as expected; that&#39;s the preferred way of creating a strong reference from a weak reference. A cast from and to &lt;code&gt;raw T&lt;/code&gt; is unsafe.&lt;/li&gt; &#xA; &lt;li&gt;If the types are part of the same type hierarchy (i.e. one is a child type of another): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;A child can be cast to its parent infallibly.&lt;/li&gt; &#xA;   &lt;li&gt;A parent can be cast to a child, but this will check the type at runtime and fail if the object was not of the child type or one of its subtypes.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;If the types are incompatible, a user-defined cast is attempted to be used. The details here are not decided yet.&lt;/li&gt; &#xA; &lt;li&gt;If nothing works, the cast will not even compile.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additional casts are available in the standard library. Two important ones are &lt;code&gt;as_saturated&lt;/code&gt; and &lt;code&gt;as_truncated&lt;/code&gt;, which cast integral values while saturating to the boundaries or truncating bits, respectively.&lt;/p&gt; &#xA;&lt;h2&gt;Traits&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;(Not yet implemented)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To make generics a bit more powerful and expressive, you can add additional information to them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;trait Hashable {&#xA;    function hash(self) -&amp;gt; i128&#xA;}&#xA;&#xA;class Foo implements Hashable {&#xA;    function hash(self) =&amp;gt; 42&#xA;}&#xA;&#xA;type i64 implements Hashable {&#xA;    function hash(self) =&amp;gt; 100&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The intention is that generics use traits to limit what is passed into a generic parameter, and also to grant that variable more capabilities in the body. It&#39;s not really intended to do vtable types of things (for that, just use a subclass)&lt;/p&gt; &#xA;&lt;h2&gt;Safety analysis&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;(Not yet implemented)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;To keep things safe, there are a few kinds of analysis we&#39;d like to do (non-exhaustive):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Preventing overlapping of method calls that would collide with each other. For example, creating an iterator over a container, and while that&#39;s live, resizing the container&lt;/li&gt; &#xA; &lt;li&gt;Using and manipulating raw pointers&lt;/li&gt; &#xA; &lt;li&gt;Calling out to C code that may have side effects&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Error handling&lt;/h2&gt; &#xA;&lt;p&gt;Functions that can fail with an error instead of returning normally are marked with the &lt;code&gt;throws&lt;/code&gt; keyword:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;function task_that_might_fail() throws -&amp;gt; usize {&#xA;    if problem {&#xA;        throw Error::from_errno(EPROBLEM)&#xA;    }&#xA;    ...&#xA;    return result&#xA;}&#xA;&#xA;function task_that_cannot_fail() -&amp;gt; usize {&#xA;    ...&#xA;    return result&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Unlike languages like C++ and Java, errors don&#39;t unwind the call stack automatically. Instead, they bubble up to the nearest caller.&lt;/p&gt; &#xA;&lt;p&gt;If nothing else is specified, calling a function that &lt;code&gt;throws&lt;/code&gt; from within a function that &lt;code&gt;throws&lt;/code&gt; will implicitly bubble errors.&lt;/p&gt; &#xA;&lt;h3&gt;Syntax for catching errors&lt;/h3&gt; &#xA;&lt;p&gt;If you want to catch errors locally instead of letting them bubble up to the caller, use a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; construct like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;try {&#xA;    task_that_might_fail()&#xA;} catch error {&#xA;    println(&#34;Caught error: {}&#34;, error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;s also a shorter form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;try task_that_might_fail() catch error {&#xA;    println(&#34;Caught error: {}&#34;, error)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rethrowing errors&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;(Not yet implemented)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Inline C++&lt;/h2&gt; &#xA;&lt;p&gt;For better interoperability with existing C++ code, as well as situations where the capabilities of &lt;strong&gt;Jakt&lt;/strong&gt; within &lt;code&gt;unsafe&lt;/code&gt; blocks are not powerful enough, the possibility of embedding inline C++ code into the program exists in the form of &lt;code&gt;cpp&lt;/code&gt; blocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;mut x = 0&#xA;unsafe {&#xA;    cpp {&#xA;        &#34;x = (i64)&amp;amp;x;&#34;&#xA;    }&#xA;}&#xA;println(&#34;{}&#34;, x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;Values and objects can be passed by reference in some situations where it&#39;s provably safe to do so.&lt;/p&gt; &#xA;&lt;p&gt;A reference is either immutable (default) or mutable.&lt;/p&gt; &#xA;&lt;h3&gt;Reference type syntax&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;T&lt;/code&gt; is an immutable reference to a value of type &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;mut T&lt;/code&gt; is a mutable reference to a value of type &lt;code&gt;T&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Reference expression syntax&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;foo&lt;/code&gt; creates an immutable reference to the variable &lt;code&gt;foo&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;amp;mut foo&lt;/code&gt; creates a mutable reference to the variable &lt;code&gt;foo&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Dereferencing a reference&lt;/h3&gt; &#xA;&lt;p&gt;To &#34;get the value out&#34; of a reference, it must be dereferenced using the &lt;code&gt;*&lt;/code&gt; operator, however the compiler will automatically dereference references if the dereferencing is the single unambiguous correct use of the reference (in practice, manual dereferencing is only required where the reference is being stored or passed to functions).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;function sum(a: &amp;amp;i64, b: &amp;amp;i64) -&amp;gt; i64 {&#xA;    return a + b&#xA;    // Or with manual dereferencing:&#xA;    return *a + *b&#xA;}&#xA;&#xA;function test() {&#xA;    let a = 1&#xA;    let b = 2&#xA;    let c = sum(&amp;amp;a, &amp;amp;b)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For mutable references to structs, you&#39;ll need to wrap the dereference in parentheses in order to do a field access:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jakt&#34;&gt;struct Foo {&#xA;    x: i64&#xA;}&#xA;function zero_out(foo: &amp;amp;mut Foo) {&#xA;    foo.x = 0&#xA;    // Or with manual dereferencing:&#xA;    (*foo).x = 0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;References (first version) feature list:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Reference types&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Reference function parameters&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; No reference locals&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; No references in structs&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; No references in return types&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; No mutable references to immutable values&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Allow &lt;code&gt;&amp;amp;foo&lt;/code&gt; and &lt;code&gt;&amp;amp;mut foo&lt;/code&gt; without argument label for parameters named &lt;code&gt;foo&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Auto-dereference references where applicable&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;References TODO:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; (&lt;code&gt;unsafe&lt;/code&gt;) references and raw pointers bidirectionally convertible&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; No capture-by-reference in persistent closures&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Closures (first version) feature list:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Function as parameter to function&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Functions as variables&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; No returning functions from functions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Lambdas can throw&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Explicit captures&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Closures TODO:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[] Return function from function&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Compiletime Execution&lt;/h2&gt; &#xA;&lt;p&gt;Compiletime Function Execution (or CTFE) in Jakt allows the execution of any jakt function at compiletime, provided that the result value may be synthesized using its fields - currently this only disallows a few prelude objects that cannot be constructed by their fields (like Iterator objects and StringBuilders).&lt;/p&gt; &#xA;&lt;p&gt;Any regular Jakt function can be turned into a compiletime function by replacing the &lt;code&gt;function&lt;/code&gt; keyword in its declaration with the &lt;code&gt;comptime&lt;/code&gt; keyword, which will force all calls to that specific function to be evaluated at compile time.&lt;/p&gt; &#xA;&lt;h3&gt;Invocation Restrictions&lt;/h3&gt; &#xA;&lt;p&gt;Comptime functions may only be invoked by constant expressions; this restriction includes the &lt;code&gt;this&lt;/code&gt; object of methods.&lt;/p&gt; &#xA;&lt;h3&gt;Throwing in a comptime context&lt;/h3&gt; &#xA;&lt;p&gt;Throwing behaves the same way as normal error control flow does, if the error leaves the comptime context (by reaching the original callsite), it will be promoted to a compiliation error.&lt;/p&gt; &#xA;&lt;h3&gt;Side effects&lt;/h3&gt; &#xA;&lt;p&gt;Currently all prelude functions with side effects behave the same as they would in runtime. This allows e.g. pulling in files into the binary; some functions may be changed later to perform more useful actions.&lt;/p&gt; &#xA;&lt;h3&gt;comptime TODO&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement execution of all Jakt expressions&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>epezent/implot</title>
    <updated>2022-09-13T01:32:54Z</updated>
    <id>tag:github.com,2022-09-13:/epezent/implot</id>
    <link href="https://github.com/epezent/implot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Immediate Mode Plotting&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ImPlot&lt;/h1&gt; &#xA;&lt;p&gt;ImPlot is an immediate mode, GPU accelerated plotting library for &lt;a href=&#34;https://github.com/ocornut/imgui&#34;&gt;Dear ImGui&lt;/a&gt;. It aims to provide a first-class API that ImGui fans will love. ImPlot is well suited for visualizing program data in real-time or creating interactive plots, and requires minimal code to integrate. Just like ImGui, it does not burden the end user with GUI state management, avoids STL containers and C++ headers, and has no external dependencies except for ImGui itself.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/controls.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/dnd.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/pie.gif&#34; width=&#34;270&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/query.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/bars.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/rt.gif&#34; width=&#34;270&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/stem.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/markers.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/shaded.gif&#34; width=&#34;270&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/candle.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/heat.gif&#34; width=&#34;270&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/tables.gif&#34; width=&#34;270&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GPU accelerated rendering&lt;/li&gt; &#xA; &lt;li&gt;multiple plot types: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;line plots&lt;/li&gt; &#xA;   &lt;li&gt;shaded plots&lt;/li&gt; &#xA;   &lt;li&gt;scatter plots&lt;/li&gt; &#xA;   &lt;li&gt;vertical/horizontal/stacked bars graphs&lt;/li&gt; &#xA;   &lt;li&gt;vertical/horizontal error bars&lt;/li&gt; &#xA;   &lt;li&gt;stem plots&lt;/li&gt; &#xA;   &lt;li&gt;stair plots&lt;/li&gt; &#xA;   &lt;li&gt;pie charts&lt;/li&gt; &#xA;   &lt;li&gt;heatmap charts&lt;/li&gt; &#xA;   &lt;li&gt;1D/2D histograms&lt;/li&gt; &#xA;   &lt;li&gt;images&lt;/li&gt; &#xA;   &lt;li&gt;and more likely to come&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;mix/match multiple plot items on a single plot&lt;/li&gt; &#xA; &lt;li&gt;configurable axes ranges and scaling (linear/log)&lt;/li&gt; &#xA; &lt;li&gt;subplots&lt;/li&gt; &#xA; &lt;li&gt;time formatted x-axes (US formatted or ISO 8601)&lt;/li&gt; &#xA; &lt;li&gt;reversible and lockable axes&lt;/li&gt; &#xA; &lt;li&gt;multiple x-axes and y-axes&lt;/li&gt; &#xA; &lt;li&gt;controls for zooming, panning, box selection, and auto-fitting data&lt;/li&gt; &#xA; &lt;li&gt;controls for creating persistent query ranges (see demo)&lt;/li&gt; &#xA; &lt;li&gt;several plot styling options: 10 marker types, adjustable marker sizes, line weights, outline colors, fill colors, etc.&lt;/li&gt; &#xA; &lt;li&gt;16 built-in colormaps and support for and user-added colormaps&lt;/li&gt; &#xA; &lt;li&gt;optional plot titles, axis labels, and grid labels&lt;/li&gt; &#xA; &lt;li&gt;optional and configurable legends with toggle buttons to quickly show/hide plot items&lt;/li&gt; &#xA; &lt;li&gt;default styling based on current ImGui theme, or completely custom plot styles&lt;/li&gt; &#xA; &lt;li&gt;customizable data getters and data striding (just like ImGui:PlotLine)&lt;/li&gt; &#xA; &lt;li&gt;accepts data as float, double, and 8, 16, 32, and 64-bit signed/unsigned integral types&lt;/li&gt; &#xA; &lt;li&gt;and more! (see Announcements &lt;a href=&#34;https://github.com/epezent/implot/discussions/370&#34;&gt;2022&lt;/a&gt;/&lt;a href=&#34;https://github.com/epezent/implot/issues/168&#34;&gt;2021&lt;/a&gt;/&lt;a href=&#34;https://github.com/epezent/implot/issues/48&#34;&gt;2020&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The API is used just like any other ImGui &lt;code&gt;BeginX&lt;/code&gt;/&lt;code&gt;EndX&lt;/code&gt; pair. First, start a new plot with &lt;code&gt;ImPlot::BeginPlot()&lt;/code&gt;. Next, plot as many items as you want with the provided &lt;code&gt;PlotX&lt;/code&gt; functions (e.g. &lt;code&gt;PlotLine()&lt;/code&gt;, &lt;code&gt;PlotBars()&lt;/code&gt;, &lt;code&gt;PlotScatter()&lt;/code&gt;, etc). Finally, wrap things up with a call to &lt;code&gt;ImPlot::EndPlot()&lt;/code&gt;. That&#39;s it!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int   bar_data[11] = ...;&#xA;float x_data[1000] = ...;&#xA;float y_data[1000] = ...;&#xA;&#xA;ImGui::Begin(&#34;My Window&#34;);&#xA;if (ImPlot::BeginPlot(&#34;My Plot&#34;)) {&#xA;    ImPlot::PlotBars(&#34;My Bar Plot&#34;, bar_data, 11);&#xA;    ImPlot::PlotLine(&#34;My Line Plot&#34;, x_data, y_data, 1000);&#xA;    ...&#xA;    ImPlot::EndPlot();&#xA;}&#xA;ImGui::End();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/epezent/implot/screenshots3/example.PNG&#34; alt=&#34;Usage&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Of course, there&#39;s much more you can do with ImPlot...&lt;/p&gt; &#xA;&lt;h2&gt;Demos&lt;/h2&gt; &#xA;&lt;p&gt;A comprehensive example of ImPlot&#39;s features can be found in &lt;code&gt;implot_demo.cpp&lt;/code&gt;. Add this file to your sources and call &lt;code&gt;ImPlot::ShowDemoWindow()&lt;/code&gt; somewhere in your update loop. You are encouraged to use this file as a reference when needing to implement various plot types. The demo is always updated to show new plot types and features as they are added, so check back with each release!&lt;/p&gt; &#xA;&lt;p&gt;An online version of the demo is hosted &lt;a href=&#34;https://traineq.org/implot_demo/src/implot_demo.html&#34;&gt;here&lt;/a&gt;. You can view the plots and the source code that generated them. Note that this demo may not always be up to date and is not as performant as a desktop implementation, but it should give you a general taste of what&#39;s possible with ImPlot. Special thanks to &lt;a href=&#34;https://github.com/pthom&#34;&gt;pthom&lt;/a&gt; for creating and hosting this!&lt;/p&gt; &#xA;&lt;p&gt;More sophisticated demos requiring lengthier code and/or third-party libraries can be found in a separate repository: &lt;a href=&#34;https://github.com/epezent/implot_demos&#34;&gt;implot_demos&lt;/a&gt;. Here, you will find advanced signal processing and ImPlot usage in action. Please read the &lt;code&gt;Contributing&lt;/code&gt; section of that repository if you have an idea for a new demo!&lt;/p&gt; &#xA;&lt;h2&gt;Integration&lt;/h2&gt; &#xA;&lt;ol start=&#34;0&#34;&gt; &#xA; &lt;li&gt;Set up an &lt;a href=&#34;https://github.com/ocornut/imgui&#34;&gt;ImGui&lt;/a&gt; environment if you don&#39;t already have one.&lt;/li&gt; &#xA; &lt;li&gt;Add &lt;code&gt;implot.h&lt;/code&gt;, &lt;code&gt;implot_internal.h&lt;/code&gt;, &lt;code&gt;implot.cpp&lt;/code&gt;, &lt;code&gt;implot_items.cpp&lt;/code&gt; and optionally &lt;code&gt;implot_demo.cpp&lt;/code&gt; to your sources. Alternatively, you can get ImPlot using &lt;a href=&#34;https://github.com/microsoft/vcpkg/tree/master/ports/implot&#34;&gt;vcpkg&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Create and destroy an &lt;code&gt;ImPlotContext&lt;/code&gt; wherever you do so for your &lt;code&gt;ImGuiContext&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ImGui::CreateContext();&#xA;ImPlot::CreateContext();&#xA;...&#xA;ImPlot::DestroyContext();&#xA;ImGui::DestroyContext();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should be good to go!&lt;/p&gt; &#xA;&lt;p&gt;If you want to test ImPlot quickly, consider trying &lt;a href=&#34;https://github.com/mahilab/mahi-gui&#34;&gt;mahi-gui&lt;/a&gt;, which bundles ImGui, ImPlot, and several other packages for you.&lt;/p&gt; &#xA;&lt;h2&gt;Extremely Important Note&lt;/h2&gt; &#xA;&lt;p&gt;Dear ImGui uses &lt;strong&gt;16-bit indexing by default&lt;/strong&gt;, so high-density ImPlot widgets like &lt;code&gt;ImPlot::PlotHeatmap()&lt;/code&gt; may produce too many vertices into &lt;code&gt;ImDrawList&lt;/code&gt;, which causes an assertion failure and will result in data truncation and/or visual glitches. Therefore, it is &lt;strong&gt;HIGHLY&lt;/strong&gt; recommended that you EITHER:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Option 1:&lt;/strong&gt; Enable 32-bit indices by uncommenting &lt;code&gt;#define ImDrawIdx unsigned int&lt;/code&gt; in your ImGui &lt;a href=&#34;https://github.com/ocornut/imgui/raw/master/imconfig.h#L89&#34;&gt;&lt;code&gt;imconfig.h&lt;/code&gt;&lt;/a&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Option 2:&lt;/strong&gt; Handle the &lt;code&gt;ImGuiBackendFlags_RendererHasVtxOffset&lt;/code&gt; flag in your renderer if you must use 16-bit indices. Many of the default ImGui rendering backends already support &lt;code&gt;ImGuiBackendFlags_RendererHasVtxOffset&lt;/code&gt;. Refer to &lt;a href=&#34;https://github.com/ocornut/imgui/issues/2591&#34;&gt;this issue&lt;/a&gt; for more information.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Why?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: ImGui is an incredibly powerful tool for rapid prototyping and development, but provides only limited mechanisms for data visualization. Two dimensional plots are ubiquitous and useful to almost any application. Being able to visualize your data in real-time will give you insight and better understanding of your application.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Is ImPlot the right plotting library for me?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: If you&#39;re looking to generate publication quality plots and/or export plots to a file, ImPlot is NOT the library for you! ImPlot is geared toward plotting application data at realtime speeds with high levels of interactivity. ImPlot does its best to create pretty plots (indeed, there are quite a few styling options available), but it will always favor function over form.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Where is the documentation?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: The API is thoroughly commented in &lt;code&gt;implot.h&lt;/code&gt;, and the demo in &lt;code&gt;implot_demo.cpp&lt;/code&gt; should be more than enough to get you started. Also take a look at the &lt;a href=&#34;https://github.com/epezent/implot_demos&#34;&gt;implot_demos&lt;/a&gt; repository.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Is ImPlot suitable for plotting large datasets?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Yes, within reason. You can plot tens to hundreds of thousands of points without issue, but don&#39;t expect millions to be a buttery smooth experience. That said, you can always downsample extremely large datasets by telling ImPlot to stride your data at larger intervals if needed. Also try the experimental &lt;code&gt;backends&lt;/code&gt; branch which aims to provide GPU acceleration support.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: What data types can I plot?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: ImPlot plotting functions accept most scalar types: &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. Arrays of custom structs or classes (e.g. &lt;code&gt;Vector2f&lt;/code&gt; or similar) are easily passed to ImPlot functions using the built-in striding features (see &lt;code&gt;implot.h&lt;/code&gt; for documentation), and many plotters provide a &#34;getter&#34; overload which accepts data generating callbacks. Additional support for &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt; and &lt;code&gt;long double&lt;/code&gt; can be added by defining &lt;code&gt;IMPLOT_INSTANTIATE_ALL_NUMERIC_TYPES&lt;/code&gt; at compile-time (see &lt;code&gt;implot_items.cpp&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Can plot styles be modified?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Yes. Data colormaps and various styling colors and variables can be pushed/popped or modified permanently on startup. Three default styles are available, as well as an automatic style that attempts to match you ImGui style.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Does ImPlot support logarithmic scaling or time formatting?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Yep! Both logscale and timescale are supported.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Does ImPlot support multiple y-axes? x-axes?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Yes. Up to three x-axes and three y-axes can be enabled.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Does ImPlot support [insert plot type]?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Maybe. Check the demo, gallery, or Announcements (&lt;a href=&#34;https://github.com/epezent/implot/issues/48&#34;&gt;2020&lt;/a&gt;/&lt;a href=&#34;https://github.com/epezent/implot/issues/168&#34;&gt;2021&lt;/a&gt;)to see if your desired plot type is shown. If not, consider submitting an issue or better yet, a PR!&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Does ImPlot support 3D plots?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: No, and likely never will since ImGui only deals in 2D rendering.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: My plot lines look like crap!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: By default, no anti-aliasing is done on line plots for performance gains. If you use at least 4x MSAA, then you likely won&#39;t even notice. However, you can enable software AA per-plot with the &lt;code&gt;ImPlotFlags_AntiAliased&lt;/code&gt; flag, or globally with &lt;code&gt;ImPlot::GetStyle().AntiAliasedLines = true;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Does ImPlot provide analytic tools?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Not exactly, but it does give you the ability to query plot sub-ranges, with which you can process your data however you like.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Can plots be exported/saved to image?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Not currently. Use your OS&#39;s screen capturing mechanisms if you need to capture a plot. ImPlot is not suitable for rendering publication quality plots; it is only intended to be used as a visualization tool. Post-process your data with MATLAB or matplotlib for these purposes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Can I compile ImPlot as a dynamic library?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Like ImGui, it is recommended that you compile and link ImPlot as a &lt;em&gt;static&lt;/em&gt; library or directly as a part of your sources. However, if you must and are compiling ImPlot and ImGui as separate DLLs, make sure you set the current &lt;em&gt;ImGui&lt;/em&gt; context with &lt;code&gt;ImPlot::SetImGuiContext(ImGuiContext* ctx)&lt;/code&gt;. This ensures that global ImGui variables are correctly shared across the DLL boundary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Can ImPlot be used with other languages/bindings?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;A: Yes, you can use the generated C binding, &lt;a href=&#34;https://github.com/cimgui/cimplot&#34;&gt;cimplot&lt;/a&gt; with most high level languages. &lt;a href=&#34;https://github.com/hoffstadt/DearPyGui&#34;&gt;DearPyGui&lt;/a&gt; provides a Python wrapper, among other things. &lt;a href=&#34;https://github.com/SpaiR/imgui-java&#34;&gt;imgui-java&lt;/a&gt; provides bindings for Java. A Rust binding, &lt;a href=&#34;https://github.com/4bb4/implot-rs&#34;&gt;implot-rs&lt;/a&gt;, is currently in the works. An example using Emscripten can be found &lt;a href=&#34;https://github.com/pthom/implot_demo&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/silifuzz</title>
    <updated>2022-09-13T01:32:54Z</updated>
    <id>tag:github.com,2022-09-13:/google/silifuzz</id>
    <link href="https://github.com/google/silifuzz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SiliFuzz - Fuzzing CPUs by proxy&lt;/h1&gt; &#xA;&lt;h2&gt;What is SiliFuzz&lt;/h2&gt; &#xA;&lt;p&gt;SiliFuzz is a system that finds CPU defects by fuzzing software proxies, like CPU simulators or disassemblers, and then executing the accumulated test inputs (known as the &lt;em&gt;corpus&lt;/em&gt;) on actual CPUs on a large scale. SiliFuzz is a work in progress, please refer to the &lt;a href=&#34;https://github.com/google/silifuzz/raw/master/paper/silifuzz.pdf&#34;&gt;paper&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Terminology&lt;/h2&gt; &#xA;&lt;h5&gt;Software fuzzing and coverage&lt;/h5&gt; &#xA;&lt;p&gt;Fuzzing is a technique of testing a target (an application, or an API) with a large number of test inputs generated on the fly. The goal is to make these inputs as interesting and as diverse as possible in order to trigger corner cases. In other words, fuzzing aims to maximize the combined code coverage. &lt;em&gt;Code coverage&lt;/em&gt; may have different meanings, e.g. which basic blocks are executed or which paths are taken in the program.&lt;/p&gt; &#xA;&lt;h5&gt;Proxy&lt;/h5&gt; &#xA;&lt;p&gt;For the purposes of SiliFuzz, a &lt;em&gt;proxy&lt;/em&gt; is any software or hardware system that behaves similar to some aspects of the target CPU. For example, a CPU emulator or a disassembler. A proxy is needed when we cannot directly collect coverage information from the target.&lt;/p&gt; &#xA;&lt;p&gt;By applying fuzzing techniques to a proxy, we can generate a series of test inputs (corpus) that produce interesting behavior in the proxy. Our underlying assumption is that this translates into similarly interesting behavior in the target.&lt;/p&gt; &#xA;&lt;h5&gt;Corpus / Corpus shard&lt;/h5&gt; &#xA;&lt;p&gt;A collection of inputs used for testing the target is known as &lt;em&gt;corpus&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A reasonably large corpus contains millions of inputs and is usually split into multiple non-overlapping chunks called &lt;em&gt;shards&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Snapshot&lt;/h5&gt; &#xA;&lt;p&gt;A SiliFuzz snapshot describes a short sequence of CPU instructions plus an initial state of CPU registers and memory to deterministically execute that sequence. A typical snapshot contains less than 100 bytes of code and runs in microseconds, but it can be arbitrarily large. Snapshots are stored as &lt;code&gt;silifuzz.proto.Snapshot&lt;/code&gt; protocol buffers.&lt;/p&gt; &#xA;&lt;p&gt;Snapshots are typically created from the inputs generated by a fuzzing engine. For CPU testing purposes these inputs are filtered to eliminate all non-deterministic snapshots.&lt;/p&gt; &#xA;&lt;h6&gt;Expected end state&lt;/h6&gt; &#xA;&lt;p&gt;An end state describes the contents of registers and memory expected to exist at the end of a Snapshot execution. If the snapshot executes differently on different CPU microarchitectures it will have multiple expected end states.&lt;/p&gt; &#xA;&lt;h5&gt;Snap&lt;/h5&gt; &#xA;&lt;p&gt;A Snap is an in-memory representation of a &lt;strong&gt;Snapshot&lt;/strong&gt; that can be easily loaded and executed by the &lt;strong&gt;Runner&lt;/strong&gt;. Snaps can be compiled in an executable program (also called &lt;em&gt;baked-in runner&lt;/em&gt;) or loaded from disk by a &lt;em&gt;reading runner&lt;/em&gt;. In the latter case the Snap on-disk format is essentially the same as the in-memory one except that native pointers are replaced with offsets. See this &lt;a href=&#34;https://github.com/google/silifuzz/raw/main/snap/gen/relocatable_snap_generator.h&#34;&gt;header&lt;/a&gt; for details. This format is often referred to as &lt;em&gt;relocatable&lt;/em&gt;. Each Snap contains exactly one expected end state i.e. Snaps are microarchitecture-specific.&lt;/p&gt; &#xA;&lt;h5&gt;Runner&lt;/h5&gt; &#xA;&lt;p&gt;Runner is a binary for testing a single CPU core. A runner consumes a corpus shard, repeatedly executes random Snaps in it and checks that the expected end state is reached. Runner is a single-threaded process.&lt;/p&gt; &#xA;&lt;h5&gt;Orchestrator&lt;/h5&gt; &#xA;&lt;p&gt;The orchestrator is a process that drives multiple runners. In a typical setting the orchestrator will continuously execute one runner per logical CPU core, and accumulate and report any failures produced by the individual runner processes.&lt;/p&gt; &#xA;&lt;h2&gt;Supported platforms and microarchitectures&lt;/h2&gt; &#xA;&lt;p&gt;We have extensively tested SiliFuzz on the following &lt;code&gt;x86_64&lt;/code&gt; microarchitectures running recent Linux kernels:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;intel-skylake / intel-cascadelake&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;intel-haswell / intel-broadwell&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;intel-ivybridge&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;amd-rome&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;amd-milan&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other &lt;code&gt;x86_64&lt;/code&gt; microarchitectures should work, too, as long as there is the compiler and OS support for them.&lt;/p&gt; &#xA;&lt;p&gt;We are actively working on &lt;code&gt;AArch64&lt;/code&gt; support.&lt;/p&gt; &#xA;&lt;h2&gt;Trophies&lt;/h2&gt; &#xA;&lt;p&gt;A non-exhaustive list of bugs and defects SiliFuzz has found.&lt;/p&gt; &#xA;&lt;h3&gt;Bugs&lt;/h3&gt; &#xA;&lt;p&gt;A logic bug is an invalid CPU behavior inherent to a particular CPU microarchitecture or stepping. SiliFuzz has identified the following bugs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.amd.com/en/corporate/product-security/bulletin/amd-sb-1028&#34;&gt;CVE-2021-26339&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.amd.com/system/files/TechDocs/56683-PUB-1.07.pdf&#34;&gt;Erratum #1386&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Defects&lt;/h3&gt; &#xA;&lt;p&gt;An (electrical) defect is an invalid CPU behavior that happens only on one or several chips. SiliFuzz has found the following defects we described in the paper&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;F2XM1 Defect. &lt;a href=&#34;https://github.com/google/silifuzz/raw/master/paper/silifuzz.pdf&#34;&gt;Paper&lt;/a&gt; / Appendix A&lt;/li&gt; &#xA; &lt;li&gt;Overshoot of an Illegal Instruction. &lt;a href=&#34;https://github.com/google/silifuzz/raw/master/paper/silifuzz.pdf&#34;&gt;Paper&lt;/a&gt; / Appendix B&lt;/li&gt; &#xA; &lt;li&gt;FCOS Miscomputes. &lt;a href=&#34;https://github.com/google/silifuzz/raw/master/paper/silifuzz.pdf&#34;&gt;Paper&lt;/a&gt; / Appendix C&lt;/li&gt; &#xA; &lt;li&gt;Missing x87 Data Pointer Update. &lt;a href=&#34;https://github.com/google/silifuzz/raw/master/paper/silifuzz.pdf&#34;&gt;Paper&lt;/a&gt; / Appendix D&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/centipede&#34;&gt;Centipede&lt;/a&gt; is a fuzzing engine developed at Google for fuzzing large and slow targets like CPU emulators.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Prework&lt;/h2&gt; &#xA;&lt;h3&gt;Prework (for Bazel)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/google/silifuzz.git &amp;amp;&amp;amp; cd silifuzz&#xA;SILIFUZZ_SRC_DIR=`pwd`&#xA;./install_build_dependencies.sh  # Currently, works for the latest Debian and Ubuntu only&#xA;bazel build @silifuzz//tools:{snap_corpus_tool,fuzz_filter_tool,snap_tool,silifuzz_platform_id} @silifuzz//runner:reading_runner_main_nolibc @silifuzz//orchestrator:silifuzz_orchestrator_main&#xA;SILIFUZZ_BIN_DIR=`pwd`/bazel-bin/&#xA;cd &#34;${SILIFUZZ_BIN_DIR}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: You can use a Docker container to avoid polluting the host system: &lt;code&gt;docker run -it --tty --security-opt seccomp=unconfined --mount type=bind,source=${SILIFUZZ_SRC_DIR},target=/app debian /bin/bash -c &#34;cd /app &amp;amp;&amp;amp; ./install_build_dependencies.sh &amp;amp;&amp;amp; bazel build ... &amp;amp;&amp;amp; bazel test ...&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Prework (fuzzing Unicorn target)&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd &#34;${SILIFUZZ_SRC_DIR}&#34;&#xA;bazel build -c opt @silifuzz//proxies:unicorn_x86_64_sancov&#xA;bazel build -c opt @centipede//:centipede&#xA;mkdir -p /tmp/wd&#xA;&#xA;# Fuzz unicorn proxies under centipede with parallelism of 30.&#xA;&#34;${SILIFUZZ_BIN_DIR}/external/centipede/centipede&#34; \&#xA;  --binary &#34;${SILIFUZZ_BIN_DIR}/proxies/unicorn_x86_64_sancov&#34; \&#xA;  --workdir /tmp/wd&#xA;  -j 30&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Prework (collect corpus from fuzzing result)&lt;/h3&gt; &#xA;&lt;p&gt;TODO: Coming soon&lt;/p&gt; &#xA;&lt;h2&gt;Tools&lt;/h2&gt; &#xA;&lt;h3&gt;silifuzz_platform_id&lt;/h3&gt; &#xA;&lt;p&gt;This helper tool is to check that the machine you&#39;re running on is supported.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ${SILIFUZZ_BIN_DIR}/tools/silifuzz_platform_id&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;intel-skylake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;fuzz_filter_tool&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/google/silifuzz/raw/main/tools/fuzz_filter_tool.cc&#34;&gt;fuzz_filter_tool&lt;/a&gt; converts raw instructions into Snap-compatible Snapshots. It returns 0 when the conversion is possible and 1 otherwise. This interface is compatible with Centipede &lt;a href=&#34;https://github.com/google/centipede/raw/main/environment.cc&#34;&gt;input_filter&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;fuzz_filter_tool raw_input_sequence [optional output proto]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;raw_input_sequence&lt;/code&gt; file contains &lt;code&gt;x86_64&lt;/code&gt; instructions which will be converted into the Snapshot format using &lt;a href=&#34;https://github.com/google/silifuzz/raw/main/common/raw_insns_util.cc&#34;&gt;InstructionsToSnapshotRandomizedCodepage&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;When the second argument is provided, the tool will also output the resulting Snapshot proto.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: the result proto is best-effort i.e. for Snapshots that are not Snap-compatible the output will contain some intermediate Snapshot value.&lt;/p&gt; &#xA;&lt;p&gt;Sample usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# NOP&#xA;echo -en &#39;\x90&#39; | ./tools/fuzz_filter_tool /dev/stdin /tmp/nop.pb&#xA;# INC EAX&#xA;echo -en &#39;\xFF\xC0&#39; | ./tools/fuzz_filter_tool /dev/stdin /tmp/inc_eax.pb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;snap_tool&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;snap_tool&lt;/code&gt; examines and manipulates binary Snapshot protos (e.g. ones produced by &lt;code&gt;fuzz_filter_tool&lt;/code&gt; at the previous step).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./tools/snap_tool print /tmp/inc_eax.pb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Metadata:&#xA;  Id: inc_eax&#xA;  Architecture: x86_64 Linux&#xA;  Compleness: complete&#xA;Registers:&#xA;  gregs (non-0 only)&#xA;    rax = 0x20000000&#xA;    ....&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Frequently asked questions&lt;/h2&gt; &#xA;&lt;p&gt;The rest of the document is organized in a How-to manner with each question describing a typical use case. The progression of the questions represents the increasing complexity of the task one is trying to accomplish. Each step typically requires either understanding or the artifacts (sometimes both) obtained at the previous step.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: The document assumes an &lt;code&gt;x86_64&lt;/code&gt; host/target CPU. The exact output may vary depending on the CPU vendor/stepping/etc and the environment (e.g. Docker/KVM).&lt;/p&gt; &#xA;&lt;p&gt;WARNING: many of the instructions below execute &lt;strong&gt;arbitrary&lt;/strong&gt; binary code with the privileges of the running user. The tool does its best to sandbox the code with seccomp(2). Use at your own risk.&lt;/p&gt; &#xA;&lt;h3&gt;How to create a simple snapshot&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# INC EAX&#xA;$ echo -en &#39;\xFF\xC0&#39; &amp;gt; /tmp/inc_eax&#xA;$ ./tools/fuzz_filter_tool /tmp/inc_eax /tmp/inc_eax.pb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CPUID&#xA;$ echo -en &#39;\x0F\xA2&#39; | ./tools/fuzz_filter_tool /dev/stdin /tmp/cpuid.pb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;error log omitted&amp;gt;&#xA;failed: Non-deterministic insn CPUID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: To avoid non-deterministic results, various parts of SiliFuzz exclude certain classes of instructions, e.g. CPUID above.&lt;/p&gt; &#xA;&lt;h3&gt;How to inspect a snapshot&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./tools/snap_tool print /tmp/inc_eax.pb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Metadata:&#xA;  Id: inc_eax&#xA;  Architecture: x86_64 Linux&#xA;  Compleness: complete&#xA;Registers:&#xA;  gregs (non-0 only):&#xA;    rax = 0x20000000&#xA;    rip = 0xeb85c12b000&#xA;    &amp;lt;omitted&amp;gt;&#xA;End states (1):&#xA;  Endpoint:&#xA;    Instruction address: 0xeb85c12b002&#xA;  Platforms:&#xA;    intel-skylake&#xA;  Registers (diff vs snapshot&#39;s initial values):&#xA;    gregs (modified only):&#xA;      rax = 0x20000001&#xA;      rip = 0xeb85c12b002&#xA;      &amp;lt;omitted&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice how the end state value of the &lt;code&gt;RAX&lt;/code&gt; register is &lt;code&gt;0x20000001&lt;/code&gt; (&lt;code&gt;0x20000000+1&lt;/code&gt; which is exactly what &lt;code&gt;INC EAX&lt;/code&gt; does). Also notice that the &lt;code&gt;RIP&lt;/code&gt; value is the original &lt;code&gt;+2&lt;/code&gt; which is the size of the &lt;code&gt;INC EAX&lt;/code&gt; instruction.&lt;/p&gt; &#xA;&lt;h3&gt;How to run a snapshot from a proto&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./tools/snap_tool play /tmp/inc_eax.pb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Snapshot played successfully.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to create and use a (relocatable) corpus&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./tools/snap_tool generate_corpus /tmp/inc_eax.pb &amp;gt; /tmp/inc_eax.corpus&#xA;# Will play the same &#34;INC EAX&#34; snapshot 1M times&#xA;$ ./runner/reading_runner_main_nolibc /tmp/inc_eax.corpus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can inspect the process with gdb:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gdb ./runner/reading_runner_main_nolibc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;(gdb) b RestoreUContextNoSyscalls&#xA;(gdb) run /tmp/inc_eax.corpus&#xA;Starting program: .../reading_runner_main_nolibc /tmp/inc_eax.corpus&#xA;&#xA;Breakpoint 1, 0x0000456700010598 in RestoreUContextNoSyscalls ()&#xA;(gdb) x/i 0xeb85c12b000 # same as the rip value produced by snap_tool print above&#xA;   0xeb85c12b000:       inc    %eax&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to inspect a corpus file&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./tools/snap_corpus_tool list_snaps /tmp/inc_eax.corpus&#xA;...&#xA;I0000 00:00:1661887744.019079 4074672 snap_corpus_tool.cc:155] inc_eax&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: This is a very basic tool at the moment offering just a few commands.&lt;/p&gt; &#xA;&lt;h3&gt;How to create and run a standalone runner binary&lt;/h3&gt; &#xA;&lt;p&gt;TODO: coming soon&lt;/p&gt; &#xA;&lt;h3&gt;How to invoke the runner to scan a single core of a CPU&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Will play the same &#34;INC EAX&#34; snapshot on CPU#1 10k times.&#xA;$ ./runner/reading_runner_main_nolibc \&#xA;    --cpu=1 --num_iterations=10000 /tmp/inc_eax.corpus&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to scan all cores of a CPU&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ xz -c /tmp/inc_eax.corpus &amp;gt; /tmp/inc_eax.corpus.xz&#xA;# Will repeatedly run the corpus on all available CPU cores for 30s.&#xA;$ ./orchestrator/silifuzz_orchestrator_main --duration=30s \&#xA;     --runner=./runner/reading_runner_main_nolibc \&#xA;     /tmp/inc_eax.corpus.xz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to create a corpus from a real target&lt;/h3&gt; &#xA;&lt;p&gt;TODO: coming soon&lt;/p&gt;</summary>
  </entry>
</feed>