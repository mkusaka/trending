<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-28T01:29:36Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>prusa3d/Prusa-Firmware-ESP32-Cam</title>
    <updated>2024-04-28T01:29:36Z</updated>
    <id>tag:github.com,2024-04-28:/prusa3d/Prusa-Firmware-ESP32-Cam</id>
    <link href="https://github.com/prusa3d/Prusa-Firmware-ESP32-Cam" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Firmware for ESP32 Cam modules to be used in Prusa Connect&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PrusaConnect ESP32-CAM&lt;/h1&gt; &#xA;&lt;p&gt;This repository includes source code and firmware releases for the ESP32-cam module programmed in the Arduino IDE&lt;/p&gt; &#xA;&lt;p&gt;This project uses other libraries. It is necessary to install them in the Arduino IDE.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;App &lt;a href=&#34;https://www.arduino.cc/en/software&#34;&gt;Arduino IDE 2.3.2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;MCU support &lt;a href=&#34;https://github.com/espressif/arduino-esp32&#34;&gt;ESP32 2.0.15&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/dvarrel/ESPAsyncWebSrv&#34;&gt;ESPAsyncWebSrv 1.2.7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/dvarrel/AsyncTCP&#34;&gt;AsyncTCP 1.1.4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/bblanchon/ArduinoJson&#34;&gt;ArduinoJson 7.0.4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/ricaun/ArduinoUniqueID&#34;&gt;UniqueID 1.3.0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What we need for functionality&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ESP32-CAM AI-thinker board with OV2640 camera module &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#esp32&#34;&gt; here &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Module board version &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#different_mcu&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install the necessary libraries in the Arduino IDE &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#arduino_lib&#34;&gt; here &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Arduino IDE configuration &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#arduino_cfg&#34;&gt; here &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;How to flash binary files to ESP32-cam board from Linux/MAC/Windows &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#flash_fw&#34;&gt; here &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Service AP &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#service_ap&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;How to reset the configuration to factory settings &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#factory_cfg&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Status LED &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#status_led&#34;&gt; here &lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Schematic main board is &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#schematic&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Issue with FLASH LED on the main board &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#led_issue&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;External WiFi antenna &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#ext_wifi&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Power supply &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#power_supply&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Debug logs &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#logs&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Serial console configuration &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#serial_cfg&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Potential issue &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#issue&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;esp32&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ESP32-CAM AI-thinker board&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s a few dollars board with &lt;strong&gt;ESP32&lt;/strong&gt; MCU and Camera. It&#39;s necessary to buy a board with &lt;strong&gt;camera module OV2640&lt;/strong&gt;. The board is sold without a programmer by default. It is possible to program it using the FTDI USB to UART converter, or purchase an official programmer for the board. We recommend purchasing an official programmer. It can save a lot of trouble with connecting and programming the board. There are currently &lt;a href=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/#different_mcu&#34;&gt;2 different board versions&lt;/a&gt;, but only one is compatible with the official programmer.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/esp32-cam.jpg&#34; width=&#34;30%&#34; height=&#34;30%&#34;&gt; &#xA;&lt;p&gt;In the following picture, we can see the &lt;strong&gt;ESP32-CAM&lt;/strong&gt; board and the programator for the board.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/esp32_and_prog.jpg&#34; width=&#34;30%&#34; height=&#34;30%&#34;&gt; &#xA;&lt;p&gt;It&#39;s necessary to use a camera version &lt;strong&gt;OV2640&lt;/strong&gt;. If using a different camera, modification of the camera&#39;s pinout can be needed, or some camera settings may not work correctly. We recommend to use a camera module with a viewing angle of 120° or 160°.&lt;/p&gt; &#xA;&lt;p&gt;These are currently known or tested camera modules:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Camera chip&lt;/th&gt; &#xA;   &lt;th&gt;FOV&lt;/th&gt; &#xA;   &lt;th&gt;Resolution&lt;/th&gt; &#xA;   &lt;th&gt;Tested&lt;/th&gt; &#xA;   &lt;th&gt;Works&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;30°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;44°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;66°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Recommended. Standard camera module&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;120°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Recommended&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;160°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Recommended&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;200°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640&lt;/td&gt; &#xA;   &lt;td&gt;222°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV2640IR&lt;/td&gt; &#xA;   &lt;td&gt;160°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV8225N&lt;/td&gt; &#xA;   &lt;td&gt;66°&lt;/td&gt; &#xA;   &lt;td&gt;2MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV3360&lt;/td&gt; &#xA;   &lt;td&gt;66°&lt;/td&gt; &#xA;   &lt;td&gt;3MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;OV5640-AF&lt;/td&gt; &#xA;   &lt;td&gt;72°&lt;/td&gt; &#xA;   &lt;td&gt;5MP&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Overheating, slow photo loading&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;a name=&#34;different_mcu&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Different MCU version&lt;/h2&gt; &#xA;&lt;p&gt;There are currently 2 versions of the board, but only one version is possible programming via CH340. The blue rectangle shows the differences between the HW versions.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/cam_versions.jpg&#34; width=&#34;50%&#34; height=&#34;50%&#34;&gt; &#xA;&lt;p&gt;The red arrow points to a pin that differs between these boards. In version 1, this pin is used for MCU RESET (GND/R). In version 2, this pin serves as ground (GND). Version 1 can be programmed via CH340, whereas version 2 cannot be programmed via CH340. For version 2, we tested programming via FT232RL or CP2102, and the programming process worked successfully.&lt;/p&gt; &#xA;&lt;p&gt;The recommended version includes the MCU ESP32 (ESP32-S) with 520 KB of SRAM and external 4M PSRAM&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;arduino_lib&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Necessary libraries in the Arduino IDE&lt;/h2&gt; &#xA;&lt;p&gt;Software compilation was done in Arduino IDE 2.3.2. To ensure proper functionality, it is necessary to install support for ESP32 boards into Arduino IDE, as well as several other libraries&lt;/p&gt; &#xA;&lt;p&gt;At the first step we need to install support for &lt;strong&gt;ESP32 board&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;File&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Preferences&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Additional boards managers URLs&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then go to &lt;strong&gt;Tools&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Board&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Boards Manager...&lt;/strong&gt; and install module &lt;strong&gt;ESP32&lt;/strong&gt; by &lt;strong&gt;Espressif Systems&lt;/strong&gt;, version &lt;strong&gt;2.0.15&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The next step is to install the necessary libraries. Go to &lt;strong&gt;Sketch&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Include Library&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Manage Libraries...&lt;/strong&gt; or you can use &lt;strong&gt;Ctrl+Shift+I&lt;/strong&gt;. Then you can search for the necessary libraries and install them.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/dvarrel/ESPAsyncWebSrv&#34;&gt;ESPAsyncWebSrv by dvarrel 1.2.7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/dvarrel/AsyncTCP&#34;&gt;AsyncTCP by dvarrel 1.1.4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/bblanchon/ArduinoJson&#34;&gt;ArduinoJson by bblanchon 7.0.4&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Library &lt;a href=&#34;https://github.com/ricaun/ArduinoUniqueID&#34;&gt;UniqueID by Luiz Henrique Cassettari1.3.0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;arduino_cfg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Arduino IDE configuration&lt;/h2&gt; &#xA;&lt;p&gt;Board configuration in the Arduino IDE 2.3.2&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tools -&amp;gt; Board -&amp;gt; ESP32 Arduino -&amp;gt; AI Thinker ESP32&lt;/li&gt; &#xA; &lt;li&gt;Tools -&amp;gt; Flash frequency -&amp;gt; 80MHz&lt;/li&gt; &#xA; &lt;li&gt;Tools -&amp;gt; Core Debug Level -&amp;gt; None&lt;/li&gt; &#xA; &lt;li&gt;Tools -&amp;gt; Erase all Flash Before Sketch Upload -&amp;gt; Disable &lt;strong&gt;(first flash, new board = enable. otherwise = disable)&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Tools -&amp;gt; Flash Mode -&amp;gt; DIO&lt;/li&gt; &#xA; &lt;li&gt;Tools -&amp;gt; Partition scheme -&amp;gt; Minimal SPIFFS (1.9MB APP with OTA/190KB SPIFFS)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When flashing the firmware to a new, empty ESP32-CAM device for the first time, it is necessary to use the &#39;Erase&#39; function.&lt;/p&gt; &#xA;&lt;p&gt;This can be found under &lt;strong&gt;Tools&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Erase all Flash Before Sketch Upload&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Enable&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;After the initial firmware upload to the MCU, it&#39;s necessary to disable this option. If you do not disable this option, your camera configuration will continue to be erased from the flash memory after uploading new firmware from the Arduino IDE.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;flash_fw&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to flash binary files to ESP32-cam board from Linux/MAC/Windows&lt;/h2&gt; &#xA;&lt;h4&gt;Linux/MAC&lt;/h4&gt; &#xA;&lt;p&gt;You must use the console to upload the firmware on the MAC or Linux platform. First, ensure you have installed esptool for Python. You can find it on the manufacturer&#39;s website, ESPRESSIF, &lt;a href=&#34;https://docs.espressif.com/projects/esp-at/en/latest/esp32/Get_Started/Downloading_guide.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And command for FLASH FW is here, where &lt;strong&gt;/dev/ttya0&lt;/strong&gt; is your serial interface for communication with the ESP32-cam board. This is the command for the first flash FW to MCU.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 -m esptool -p /dev/ttya0 -b 460800 --before default_reset --after hard_reset --chip&#xA;esp32 write_flash --erase-all --flash_mode dio --flash_size 4MB --flash_freq 80m 0x1000&#xA;ESP32_PrusaConnectCam_web.ino.bootloader.bin 0x8000&#xA;ESP32_PrusaConnectCam_web.ino.partitions.bin 0x10000 ESP32_PrusaConnectCam_web.ino.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command contains the parameter &lt;strong&gt;--eras-all&lt;/strong&gt;, which erases the entire flash in the MCU. So, for just updating the firmware, it is necessary to remove the parameter &lt;strong&gt;--eras-all&lt;/strong&gt;; otherwise, the MCU configuration will also be deleted. The basic command list can be found &lt;a href=&#34;https://docs.espressif.com/projects/esptool/en/latest/esp32s3/esptool/basic-commands.html&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Here is the command for updating the firmware in the MCU without erasing the MCU configuration&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 -m esptool -p /dev/ttya0 -b 460800 --before default_reset --after hard_reset --chip&#xA;esp32 write_flash --flash_mode dio --flash_size 4MB --flash_freq 80m 0x1000&#xA;ESP32_PrusaConnectCam_web.ino.bootloader.bin 0x8000&#xA;ESP32_PrusaConnectCam_web.ino.partitions.bin 0x10000 ESP32_PrusaConnectCam_web.ino.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;p&gt;Here is the tool and configuration for &lt;a href=&#34;https://www.espressif.com/en/support/download/other-tools&#34;&gt;windows platform&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;doc/how to flash chip select.jpg&#34; width=&#34;15%&#34; height=&#34;15%&#34;&gt; &#xA;&lt;p&gt;It&#39;s necessary to erase the FLASH using the &lt;strong&gt;ERASE&lt;/strong&gt; button before the first firmware flash.&lt;/p&gt; &#xA;&lt;img src=&#34;doc/how to flash.jpg&#34; width=&#34;25%&#34; height=&#34;25%&#34;&gt; &#xA;&lt;h4&gt;Partitions table&lt;/h4&gt; &#xA;&lt;p&gt;Here is the partitions table:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Name&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;SubType&lt;/th&gt; &#xA;   &lt;th&gt;Offset&lt;/th&gt; &#xA;   &lt;th&gt;Size&lt;/th&gt; &#xA;   &lt;th&gt;Flags&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;nvs&lt;/td&gt; &#xA;   &lt;td&gt;data&lt;/td&gt; &#xA;   &lt;td&gt;nvs&lt;/td&gt; &#xA;   &lt;td&gt;0x9000&lt;/td&gt; &#xA;   &lt;td&gt;0x5000&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;otadata&lt;/td&gt; &#xA;   &lt;td&gt;data&lt;/td&gt; &#xA;   &lt;td&gt;ota&lt;/td&gt; &#xA;   &lt;td&gt;0xe000&lt;/td&gt; &#xA;   &lt;td&gt;0x2000&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;app0&lt;/td&gt; &#xA;   &lt;td&gt;app&lt;/td&gt; &#xA;   &lt;td&gt;ota_0&lt;/td&gt; &#xA;   &lt;td&gt;0x10000&lt;/td&gt; &#xA;   &lt;td&gt;0x1E0000&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;app1&lt;/td&gt; &#xA;   &lt;td&gt;app&lt;/td&gt; &#xA;   &lt;td&gt;ota_1&lt;/td&gt; &#xA;   &lt;td&gt;0x1F0000&lt;/td&gt; &#xA;   &lt;td&gt;0x1E0000&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;spiffs&lt;/td&gt; &#xA;   &lt;td&gt;data&lt;/td&gt; &#xA;   &lt;td&gt;spiffs&lt;/td&gt; &#xA;   &lt;td&gt;0x3D0000&lt;/td&gt; &#xA;   &lt;td&gt;0x20000&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;coredump&lt;/td&gt; &#xA;   &lt;td&gt;data&lt;/td&gt; &#xA;   &lt;td&gt;coredump&lt;/td&gt; &#xA;   &lt;td&gt;0x3F0000&lt;/td&gt; &#xA;   &lt;td&gt;0x10000&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;However, for uploading the firmware, it&#39;s important to use this configuration of addresses and files:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;address &lt;strong&gt;0x1000&lt;/strong&gt; - &lt;strong&gt;ESP32_PrusaConnectCam.ino.bootloader.bin&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;address &lt;strong&gt;0x8000&lt;/strong&gt; - &lt;strong&gt;ESP32_PrusaConnectCam.ino.partitions.bin&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;address &lt;strong&gt;0x10000&lt;/strong&gt; - &lt;strong&gt;ESP32_PrusaConnectCam.ino.bin&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;service_ap&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Service AP&lt;/h2&gt; &#xA;&lt;p&gt;After powering on and booting up the camera, it enters &lt;strong&gt;AP mode&lt;/strong&gt;, which serves as a configuration mode for the camera. Essentially, it starts its own Wi-Fi network. The network name (SSID) is &lt;strong&gt;ESP32_camera_UID&lt;/strong&gt;, where &lt;strong&gt;UID&lt;/strong&gt; is the first three numbers from the &lt;strong&gt;MCU ID&lt;/strong&gt;, serving as a unique identifier for the camera. The password for connecting to the AP is &lt;strong&gt;12345678&lt;/strong&gt;. The camera&#39;s IP address is &lt;strong&gt;192.168.0.1&lt;/strong&gt;. To configure the camera via &lt;strong&gt;AP mode&lt;/strong&gt;, you need to connect to this IP address using a web browser: &lt;strong&gt;&lt;a href=&#34;http://192.168.0.1&#34;&gt;http://192.168.0.1&lt;/a&gt;&lt;/strong&gt;. Alternatively, you can also use the &lt;strong&gt;&lt;a href=&#34;http://prusa-esp32cam.local&#34;&gt;http://prusa-esp32cam.local&lt;/a&gt;&lt;/strong&gt; hostname (&lt;strong&gt;mDNS&lt;/strong&gt;) instead of the IP Address.&lt;/p&gt; &#xA;&lt;p&gt;After establishing a successful connection, your computer might display a &#34;&lt;strong&gt;No Internet&lt;/strong&gt;&#34; warning for the given network. &lt;strong&gt;This is normal&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have set up a Wi-Fi network name (SSID) and password in the camera for it to connect to, then upon powering on, the camera will automatically connect to the configured Wi-Fi network and simultaneously activate AP mode for &lt;strong&gt;5 minutes&lt;/strong&gt;. AP mode is always enabled after powering on and booting up the camera for &lt;strong&gt;5 minutes&lt;/strong&gt;. The service Wi-Fi AP is &lt;strong&gt;automatically deactivates&lt;/strong&gt; itself after &lt;strong&gt;5 minutes&lt;/strong&gt; following each camera startup if no device is connected to the camera.&lt;/p&gt; &#xA;&lt;p&gt;Service AP is for for the first camera configuration. If the camera is connected to a WiFi network, it is possible to configure it from the local network.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;factory_cfg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to reset configuration to factory settings&lt;/h2&gt; &#xA;&lt;p&gt;To reset the settings to factory defaults, follow these instructions:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/factory_cfg.jpg&#34; width=&#34;30%&#34; height=&#34;30%&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Connect PIN &lt;strong&gt;IO12&lt;/strong&gt; to &lt;strong&gt;ground&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Plug in&lt;/strong&gt; the power supply.&lt;/li&gt; &#xA; &lt;li&gt;Wait for &lt;strong&gt;10 seconds&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;After 10 seconds, the &lt;strong&gt;FLASH LED will start flashing&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Disconnect&lt;/strong&gt; PIN &lt;strong&gt;IO12&lt;/strong&gt; from &lt;strong&gt;ground&lt;/strong&gt; (but don&#39;t disconnect the power supply).&lt;/li&gt; &#xA; &lt;li&gt;After disconnecting &lt;strong&gt;IO12&lt;/strong&gt; from &lt;strong&gt;ground&lt;/strong&gt;, the &lt;strong&gt;FLASH LED&lt;/strong&gt; will &lt;strong&gt;stop flashing&lt;/strong&gt;, and the MCU will &lt;strong&gt;automatically reboot&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Now the MCU is in the factory settings.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;status_led&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Status LED&lt;/h2&gt; &#xA;&lt;p&gt;On the board, there is a status LED that provides a visual indicator of the module&#39;s current status through blinking at defined intervals.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/status_led.jpg&#34; width=&#34;25%&#34; height=&#34;25%&#34;&gt; &#xA;&lt;p&gt;Upon module activation, the LED illuminates. After processor initialization, the LED exhibits different blinking intervals based on the current mode of the module&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Service AP Mode only:&lt;/strong&gt; The LED blinks every &lt;strong&gt;400 ms&lt;/strong&gt;, indicating the module&#39;s availability in service AP mode.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Connecting to WiFi AP:&lt;/strong&gt; While connecting to a WiFi Access Point, the LED blinks at intervals of &lt;strong&gt;800 ms&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Connected to WiFi Network:&lt;/strong&gt; Upon successful connection to a WiFi network, the LED blinks at intervals of &lt;strong&gt;4000 ms&lt;/strong&gt;, signaling a stable connection.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Problematic State:&lt;/strong&gt; If an issue or error occurs, the LED accelerates its blinking to every &lt;strong&gt;100 ms&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The approximate boot time of the device is 15-20 seconds.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;schematic&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Schematic for ESP32-cam board&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/ESP32-CAM-AI-Thinker-schematic-diagram.png&#34; width=&#34;70%&#34; height=&#34;70%&#34;&gt; &#xA;&lt;p&gt;Board description&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/esp32-cam_parts.jpg&#34; width=&#34;50%&#34; height=&#34;50%&#34;&gt; &#xA;&lt;p&gt;Pinout&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/pinout.png&#34; width=&#34;50%&#34; height=&#34;50%&#34;&gt; &#xA;&lt;p&gt;&lt;a name=&#34;led_issue&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;FLASH LED issue&lt;/h2&gt; &#xA;&lt;p&gt;The board has a problem with the FLASH LED, as it lacks any current limitation for the LED. Consequently, frequent use of the FLASH LED can lead to malfunction, due to excessive current flow.&lt;/p&gt; &#xA;&lt;p&gt;One simple solution is to connect an external LED via a relay, transistor, or MOSFET to the board, as shown in the next picture. Using a relay is not ideal, but it provides a simple solution.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/relay_flash_bb.png&#34; width=&#34;40%&#34; height=&#34;40%&#34;&gt; &#xA;&lt;p&gt;Another solution is to use an LED COB or a USB LED lamp. I utilized a board from a simple USB LED lamp. The transistor has a current limitation of 500mA, and my USB lamp has a current consumption of approximately 180mA. The original LED has a current consumption of 60-80mA. After calculation, the total current consumption is approximately 260mA, which falls within the current limitation of the transistor. Therefore, it is possible to solder the negative wire from the COB LED or the USB LED lamp to the transistor. The positive wire needs to be soldered to +5V.&lt;/p&gt; &#xA;&lt;p&gt;This is my USB LED lamp&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/usb_lamp.jpg&#34; width=&#34;40%&#34; height=&#34;40%&#34;&gt; &#xA;&lt;p&gt;The next step is to solder the negative wire from the LED lamp to the transistor collector, and the positive wire from the LED lamp to the +5V on the board.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/esp32-cam_with_led_lamp.jpg&#34; width=&#34;40%&#34; height=&#34;40%&#34;&gt; &#xA;&lt;p&gt;The third option is to solder a resistor between the collector of the transistor and the PCB. I used a 10-ohm resistor in a 0603 package. This option is more complicated for users with limited soldering experience.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/esp32-cam_flash_led_resistor.jpg&#34; width=&#34;40%&#34; height=&#34;40%&#34;&gt; &#xA;&lt;p&gt;&lt;a name=&#34;ext_wifi&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;External/internal WiFi antenna&lt;/h2&gt; &#xA;&lt;p&gt;The standard ESP32-CAM board utilizes an internal antenna on the PCB. However, this antenna can sometimes cause issues with the quality of the WiFi signal, leading to slow photo uploads to PrusaConnect or connectivity problems. Fortunately, there is an option to connect an external antenna. This requires changing the resistor position, as shown in the picture below. Then, you can use a 2.4GHz Wi-Fi cable with a U.FL to RP-SMA connector and a standard 2.4GHz WiFi antenna&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/prusa3d/Prusa-Firmware-ESP32-Cam/master/doc/esp32-cam_ext_ant.png&#34; width=&#34;40%&#34; height=&#34;40%&#34;&gt; &#xA;&lt;p&gt;&lt;a name=&#34;power_supply&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Power Supply&lt;/h2&gt; &#xA;&lt;p&gt;The device requires a 5V power supply, with a maximum current consumption of 2A. Power is supplied via a micro USB connector when using the original programmer.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;logs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Debug logs&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to save debug logs to a microSD card, but the card must be formatted to FAT32. Currently, the maximum tested capacity for a microSD card is 16GB. If a microSD card is inserted into the camera, it is necessary to reboot the camera. When a microSD card is inserted into the camera before boot, logging to the microSD card is automatically enabled. If no microSD card is inserted, the saving of debug logs to the microSD card is automatically disabled. Enabling the saving of debug logs to a microSD card is only possible during camera boot, so it is necessary to restart the camera after inserting the microSD card. Debug logs are saved as plain text in the file Syslog.log&lt;/p&gt; &#xA;&lt;p&gt;&lt;a name=&#34;serial_cfg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Serial console configuration&lt;/h2&gt; &#xA;&lt;p&gt;Currently, it is possible to set the basic camera configuration using the serial console. Baud speed for communication with MCU is &lt;strong&gt;115200 8N1&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Commands for configuration have simple syntax&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;command&lt;/th&gt; &#xA;   &lt;th&gt;separator&lt;/th&gt; &#xA;   &lt;th&gt;variable&lt;/th&gt; &#xA;   &lt;th&gt;termination&lt;/th&gt; &#xA;   &lt;th&gt;line terminator&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;setwifissid&lt;/td&gt; &#xA;   &lt;td&gt;:&lt;/td&gt; &#xA;   &lt;td&gt;SSID&lt;/td&gt; &#xA;   &lt;td&gt;;&lt;/td&gt; &#xA;   &lt;td&gt;\n or \r or \n\r or \r\n&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Currently, available commands are listed in the table below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Command&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;setwifissid&lt;/td&gt; &#xA;   &lt;td&gt;Setting WiFi SSID, where variable SSID is network name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;setwifipass&lt;/td&gt; &#xA;   &lt;td&gt;Setting WiFi password, where variable PASSWORD is WiFi password&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;wificonnect&lt;/td&gt; &#xA;   &lt;td&gt;Connecting to WiFi network&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;mcureboot&lt;/td&gt; &#xA;   &lt;td&gt;Rebooting the MCU&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;commandslist&lt;/td&gt; &#xA;   &lt;td&gt;Listing currently supported commands via serial console&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;getwifimode&lt;/td&gt; &#xA;   &lt;td&gt;Print current WiFi mode. STA/AP/AP+STA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;getwifistastatus&lt;/td&gt; &#xA;   &lt;td&gt;Print WiFi STA status. Connected/Disconnected/Connecting....&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;getwifistaip&lt;/td&gt; &#xA;   &lt;td&gt;Print IP address for WiFi STA&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;getserviceapssid&lt;/td&gt; &#xA;   &lt;td&gt;Print service AP SSID name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;setauthtoken:&lt;/td&gt; &#xA;   &lt;td&gt;Set authentication token for Prusa Connect&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The standard command sequence for camera basic settings is&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;setwifissid:SSID;&lt;/li&gt; &#xA; &lt;li&gt;setwifipass:PASSWORD;&lt;/li&gt; &#xA; &lt;li&gt;wificonnect;&lt;/li&gt; &#xA; &lt;li&gt;setauthtoken:TOKEN;&lt;/li&gt; &#xA; &lt;li&gt;mcureboot;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a name=&#34;issue&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Potential issue&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A potential issue may arise with connecting to the service AP. If the connection fails and an authentication error occurs, it is necessary to clear the FLASH memory of the processor, and FLASH FW again. This can be done either through the Arduino IDE or using official software.&lt;/li&gt; &#xA; &lt;li&gt;While sending the photo to the backend, the WEB server is temporarily disabled for this short interval. After the photo is sent to the backend, the WEB server is re-enabled. This may cause short unavailability in the WEB server on the camera, lasting several seconds, depending on the internet connection and the quality of the WiFi connection&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>facebookexternal/nimble</title>
    <updated>2024-04-28T01:29:36Z</updated>
    <id>tag:github.com,2024-04-28:/facebookexternal/nimble</id>
    <link href="https://github.com/facebookexternal/nimble" rel="alternate"></link>
    <summary type="html">&lt;p&gt;New file format for storage of large columnar datasets.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Nimble File Format&lt;/h1&gt; &#xA;&lt;p&gt;Nimble (formerly known as &lt;em&gt;“Alpha”&lt;/em&gt;) is a new columnar file format for large datasets created by Meta. Nimble is meant to be a replacement for file formats such as Apache Parquet and ORC.&amp;nbsp;&lt;/p&gt; &#xA;&lt;p&gt;Watch &lt;a href=&#34;https://www.youtube.com/watch?v=bISBNVtXZ6M&#34;&gt;this talk&lt;/a&gt; to learn more about Nimble’s internals.&lt;/p&gt; &#xA;&lt;p&gt;Nimble has the following design principles:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Wide:&lt;/strong&gt; Nimble is better suited for workloads that are wide in nature, such as tables with thousands of columns (or streams) which are commonly found in feature engineering workloads and training tables for machine learning.&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Extensible:&lt;/strong&gt; Since the state-of-the-art in data encoding evolves faster than the file layout itself, Nimble decouples stream encoding from the underlying physical layout. Nimble allows encodings to be extended by library users and recursively applied (cascading).&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Parallel:&lt;/strong&gt; Nimble is meant to fully leverage highly parallel hardware by providing encodings which are SIMD and GPU friendly. Although this is not implemented yet, we intend to expose metadata to allow developers to better plan decoding trees and schedule kernels without requiring the data streams themselves.&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Unified:&lt;/strong&gt; More than a specification, Nimble is a product. We strongly discourage developers to (re-)implement Nimble’s spec to prevent environmental fragmentation issues observed with similar projects in the past. We encourage developers to leverage the single unified Nimble library, and create high-quality bindings to other languages as needed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nimble has the following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Lighter metadata organization to efficiently support thousands to tens of thousands of columns and streams.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use Flatbuffers instead of thrift/protobuf to more efficiently access large metadata sections.&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use block encoding instead of stream encoding to provide predictable memory usage while decoding/reading.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports many encodings out-of-the-box, and additional encodings can be added as needed.&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports cascading (recursive/composite) encoding of streams.&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Supports pluggable encoding selection policies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Provide extensibility APIs where encodings and other aspects of the file can be extended.&amp;nbsp;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clear separation between logical and physical encoded types.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;And more.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nimble is a work in progress, and many of these features above are still under design and/or active development. As such, Nimble does not provide stability or versioning guarantees (yet). They will be eventually provided with a future stable release. Use it at your own risk.&amp;nbsp;&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Nimble’s CMake build system is self-sufficient and able to either locate its main dependencies or compile them locally. In order to compile it, one can simply:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone git@github.com:facebookexternal/nimble.git&#xA;$ cd nimble&#xA;$ make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To override the default behavior and force the build system to, for example, build a dependency locally (bundle it), one can:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ folly_SOURCE=BUNDLED make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Nimble builds have been tested using clang 15 and 16. It should automatically compile the following dependencies: gtest, glog, folly, abseil, and velox. You may need to first install the following system dependencies for these to compile (example from Ubuntu 22.04):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo apt install -y \&#xA;    flatbuffers-compiler \&#xA;    libflatbuffers-dev \&#xA;    libgflags-dev \&#xA;    libunwind-dev \&#xA;    libgoogle-glog-dev \&#xA;    libdouble-conversion-dev \&#xA;    libevent-dev \&#xA;    liblzo2-dev \&#xA;    libelf-dev \&#xA;    libdwarf-dev \&#xA;    libsnappy-dev \&#xA;    bison \&#xA;    flex \&#xA;    libfl-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although Nimble’s codebase is today closely coupled with velox, we intend to decouple them in the future.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Nimble is licensed under the Apache 2.0 License. A copy of the license &lt;a href=&#34;https://raw.githubusercontent.com/facebookexternal/nimble/main/LICENSE&#34;&gt;can be found here.&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>turingmotors/swan</title>
    <updated>2024-04-28T01:29:36Z</updated>
    <id>tag:github.com,2024-04-28:/turingmotors/swan</id>
    <link href="https://github.com/turingmotors/swan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This project aims to enable language model inference on FPGAs, supporting AI applications in edge devices and environments with limited resources.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Swan&lt;/h1&gt; &#xA; &lt;p&gt;&lt;strong&gt;A Lightweight Language Model Execution Environment Using FPGA&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;English | &lt;a href=&#34;https://raw.githubusercontent.com/turingmotors/swan/main/docs/README_JP.md&#34;&gt;日本語&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/turingmotors/swan/main/docs/README_CN.md&#34;&gt;中文&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;Swan is an OSS project implemented in C++.&lt;br&gt; Its goal is to efficiently run language models on general-purpose FPGAs using High-Level Synthesis (HLS).&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/turingmotors/swan/main/images/swan_image.png&#34; width=&#34;50%&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;This project aims to enable language model inference on FPGAs, supporting AI applications in edge devices and environments with limited resources.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Versatility: Supports common FPGA boards such as the KV260.&lt;/li&gt; &#xA; &lt;li&gt;Scalability: The source code is written in C++, making customization and extension easy.&lt;/li&gt; &#xA; &lt;li&gt;Lightweight: Considers the size constraints of language models and adopts an efficient architecture.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;To build and run Swan, the following tools and libraries are required:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CMake&lt;/li&gt; &#xA; &lt;li&gt;g++&lt;/li&gt; &#xA; &lt;li&gt;HLS tools (e.g., Vivado HLS)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Clone &amp;amp; Download Weight Files&lt;/h2&gt; &#xA;&lt;p&gt;To clone the Swan repository, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone git@github.com:turingmotors/swan.git&#xA;$ cd swan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Download 15M parameter model from &lt;a href=&#34;https://huggingface.co/karpathy/tinyllamas/tree/main&#34;&gt;huggingface.co/karpathy/tinyllamas&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin -O model/stories15M.bin&#xA;wget https://raw.githubusercontent.com/leloykun/llama2.cpp/master/tokenizer.bin -O model/tokenizer.bin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;h3&gt;FPGA Environment&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://zenn.dev/turing_motors/articles/82505880d27d65&#34;&gt;technical blog&lt;/a&gt; for details on building Swan in an FPGA environment.&lt;/p&gt; &#xA;&lt;h3&gt;CPU Environment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir -p build &amp;amp;&amp;amp; cd build&#xA;$ cmake ..&#xA;$ make &amp;amp;&amp;amp; cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the build is complete, you can run Swan with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./build/swan&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Command Line Options&lt;/h2&gt; &#xA;&lt;p&gt;Swan supports the following options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: ./build/swan [options]&#xA;Options:&#xA;  --weight_path   : Weight file path&#xA;  --vocab_path    : Tokenizer file path&#xA;  --max_seq       : Maximum sequence length&#xA;  --temp          : Temperature for sampling&#xA;  --color         : Enable color output&#xA;  --log           : Enable log output&#xA;  --help, -h      : Show this help message&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reference Projects&lt;/h2&gt; &#xA;&lt;p&gt;This project is inspired by &lt;a href=&#34;https://github.com/karpathy/llama2.c&#34;&gt;llama2.c&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is released under the &lt;a href=&#34;https://raw.githubusercontent.com/turingmotors/swan/main/LICENSE&#34;&gt;Apache License 2.0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributions&lt;/h2&gt; &#xA;&lt;p&gt;Contributions to Swan are highly welcome. Please submit feedback and improvement suggestions through Issues and Pull Requests.&lt;br&gt; &lt;a href=&#34;https://www.turing-motors.com/en&#34;&gt;Turing Inc.&lt;/a&gt; is supporting the development of Swan.&lt;/p&gt;</summary>
  </entry>
</feed>