<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-08T01:27:23Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>archercreat/titan</title>
    <updated>2023-11-08T01:27:23Z</updated>
    <id>tag:github.com,2023-11-08:/archercreat/titan</id>
    <link href="https://github.com/archercreat/titan" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Titan is a VMProtect devirtualizer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;titan - VMProtect devirtualizer&lt;/h1&gt; &#xA;&lt;p&gt;I&#39;m releasing my VMProtect devirtualizer for others to research, learn, and improve. This project started in 2018 as a hobby project and was rewritten at least 4 times. During my research, I&#39;ve met with awesome people, made friends, and learned a lot. The tool is for educational purposes only, it works for vmprotect &amp;lt; 3.8 but produces less than ideal output.&lt;/p&gt; &#xA;&lt;h2&gt;How does it work?&lt;/h2&gt; &#xA;&lt;p&gt;The tool uses &lt;a href=&#34;https://github.com/JonathanSalwan/Triton&#34;&gt;Triton&lt;/a&gt; for emulation, symbolic execution, and lifting. The easiest way to match VM handlers is to match them on the Triton AST level. The tool symbolizes vip and vsp registers and propagates memory loads and stores. Almost every handler ends with the store (to the stack, vm register or memory). We take Triton AST of the value that is being stored and match against known patterns:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Match [vsp] + [vsp].&#xA;//&#xA;static bool match_add(const triton::ast::SharedAbstractNode&amp;amp; ast)&#xA;{&#xA;    if (ast-&amp;gt;getType() == triton::ast::EXTRACT_NODE)&#xA;    {&#xA;        return match_add(ast-&amp;gt;getChildren()[2]-&amp;gt;getChildren()[1]);&#xA;    }&#xA;    return ast-&amp;gt;getType() == triton::ast::BVADD_NODE&#xA;        &amp;amp;&amp;amp; is_variable(ast-&amp;gt;getChildren()[1], variable::vsp_fetch);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;No matter how obfuscated handlers are, it is possible to match them with a single x86 instruction! Once the handler is identified, it is lifted into a basic block. Once the basic block is terminated, the partial control-flow graph is computed and the RIP register is sliced, giving the address of the next basic block. The process repeats until no new basic blocks are found. Every basic block is lifted into separate LLVM function. The process of building control-flow graph comes down chaining calls to basic block functions in the right order. The tool has few custom LLVM passes like &lt;code&gt;no-alias&lt;/code&gt; and &lt;code&gt;memory coalescing&lt;/code&gt; passes. The only pass that is left to implement is &lt;code&gt;flag synthesis&lt;/code&gt; pass which will give the cleanest LLVM bitcode.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The tool requires 3 arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Path to vmprotect intrinsics file&lt;/li&gt; &#xA; &lt;li&gt;Path to virtualized binary&lt;/li&gt; &#xA; &lt;li&gt;Virtual address of vm entry point&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;./build/titan&#xA;titan: for the -i option: must be specified at least once!&#xA;titan: for the -b option: must be specified at least once!&#xA;titan: for the -e option: must be specified at least once!&#xA;./build/titan -i intrinsics/vmprotect64.ll -b samples/loop_hash.0x140103FF4.exe -e 0x140103FF4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Matteo Favaro&lt;/em&gt; and &lt;em&gt;Vlad Malagar&lt;/em&gt; for answering my sometimes dumb questions, helping to find bugs in llvm bitcode, giving motivation and new ideas.&lt;/p&gt;</summary>
  </entry>
</feed>