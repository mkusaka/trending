<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-03T01:29:27Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>jeremy-rifkin/cpptrace</title>
    <updated>2025-05-03T01:29:27Z</updated>
    <id>tag:github.com,2025-05-03:/jeremy-rifkin/cpptrace</id>
    <link href="https://github.com/jeremy-rifkin/cpptrace" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simple, portable, and self-contained stacktrace library for C++11 and newer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Cpptrace &#xA; &lt;!-- omit in toc --&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jeremy-rifkin/cpptrace/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/jeremy-rifkin/cpptrace/actions/workflows/ci.yml/badge.svg?branch=main&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://sonarcloud.io/summary/new_code?id=jeremy-rifkin_cpptrace&#34;&gt;&lt;img src=&#34;https://sonarcloud.io/api/project_badges/measure?project=jeremy-rifkin_cpptrace&amp;amp;metric=alert_status&#34; alt=&#34;Quality Gate Status&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://discord.gg/frjaAZvqUZ&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Chat%20on%20the%20(very%20small)-Community%20Discord-blue?labelColor=2C3239&amp;amp;color=7289DA&amp;amp;style=flat&amp;amp;logo=discord&amp;amp;logoColor=959DA5&#34; alt=&#34;Community Discord Link&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://godbolt.org/z/c6TqTzqcf&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-Compiler%20Explorer-brightgreen?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAYAAAAmlE46AAAACXBIWXMAAACwAAAAsAEUaqtpAAABSElEQVQokYVTsU7DMBB9QMTCEJbOMLB5oF0tRfUPIPIJZctYJkZYu3WMxNL+ARUfQKpImcPgDYnsXWBgYQl61TkYyxI3Wef37j3fnQ/6vkcsikY9AbiWq0mpbevDBmLRqDEAA4CEHMADgFRwrwDmch6X2i73RCFVHvC/WCeCMAFpC2AFoPPu5x4md4rnAN4luS61nYWSgauNU8ydkr0bLTMYAoIYtWqxM4LtEumeERDtfUjlMDrp7L67iddyyJtOvUIu2rquVn4iiVSOKXYhiMSJWLwUJZLuQ2CWmVldV4MT11UmXgB8fr0dX3WP6VHMiVrscim6Da2mJxffzwSU2v6xWzSKmzQ4cUTOaCBTvWgU14xkzjhckKm/q3wnrRAcAhksxMZNAdxEf0fRKI6E8zqT1C0X28ccRpqAUltW5pu4sxv5Mb8B4AciE3bHMxz/+gAAAABJRU5ErkJggg==&amp;amp;labelColor=2C3239&amp;amp;style=flat&amp;amp;label=Try+it+on&amp;amp;color=30C452&#34; alt=&#34;Try on Compiler Explorer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace is a simple and portable C++ stacktrace library supporting C++11 and greater on Linux, macOS, and Windows including MinGW and Cygwin environments. The goal: Make stack traces simple for once.&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace also has a C API, docs &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/docs/c-api.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents &#xA; &lt;!-- omit in toc --&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#30-second-overview&#34;&gt;30-Second Overview&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#cmake-fetchcontent-usage&#34;&gt;CMake FetchContent Usage&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#prerequisites&#34;&gt;Prerequisites&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#basic-usage&#34;&gt;Basic Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#namespace-cpptrace&#34;&gt;&lt;code&gt;namespace cpptrace&lt;/code&gt;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#stack-traces&#34;&gt;Stack Traces&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#object-traces&#34;&gt;Object Traces&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#raw-traces&#34;&gt;Raw Traces&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#utilities&#34;&gt;Utilities&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#formatting&#34;&gt;Formatting&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#transforms&#34;&gt;Transforms&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#configuration&#34;&gt;Configuration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traces-from-all-exceptions&#34;&gt;Traces From All Exceptions&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#removing-the-cpptrace_-prefix&#34;&gt;Removing the &lt;code&gt;CPPTRACE_&lt;/code&gt; prefix&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#how-it-works&#34;&gt;How it works&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traced-exception-objects&#34;&gt;Traced Exception Objects&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#wrapping-stdexceptions&#34;&gt;Wrapping std::exceptions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#exception-handling-with-cpptrace-exception-objects&#34;&gt;Exception handling with cpptrace exception objects&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#terminate-handling&#34;&gt;Terminate Handling&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#signal-safe-tracing&#34;&gt;Signal-Safe Tracing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#utility-types&#34;&gt;Utility Types&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#headers&#34;&gt;Headers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#libdwarf-tuning&#34;&gt;Libdwarf Tuning&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#jit-support&#34;&gt;JIT Support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#supported-debug-formats&#34;&gt;Supported Debug Formats&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#how-to-include-the-library&#34;&gt;How to Include The Library&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#cmake-fetchcontent&#34;&gt;CMake FetchContent&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#system-wide-installation&#34;&gt;System-Wide Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#local-user-installation&#34;&gt;Local User Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#use-without-cmake&#34;&gt;Use Without CMake&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#installation-without-package-managers-or-fetchcontent&#34;&gt;Installation Without Package Managers or FetchContent&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#package-managers&#34;&gt;Package Managers&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#conan&#34;&gt;Conan&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#vcpkg&#34;&gt;Vcpkg&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#platform-logistics&#34;&gt;Platform Logistics&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#windows&#34;&gt;Windows&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#macos&#34;&gt;macOS&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#library-back-ends&#34;&gt;Library Back-Ends&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#summary-of-library-configurations&#34;&gt;Summary of Library Configurations&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#testing-methodology&#34;&gt;Testing Methodology&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#notes-about-the-library&#34;&gt;Notes About the Library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#faq&#34;&gt;FAQ&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#what-about-c23-stacktrace&#34;&gt;What about C++23 &lt;code&gt;&amp;lt;stacktrace&amp;gt;&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#what-does-cpptrace-have-over-other-c-stacktrace-libraries&#34;&gt;What does cpptrace have over other C++ stacktrace libraries?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#im-getting-undefined-standard-library-symbols-like-std__1basic_string-on-macos&#34;&gt;I&#39;m getting undefined standard library symbols like &lt;code&gt;std::__1::basic_string&lt;/code&gt; on MacOS&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;30-Second Overview&lt;/h1&gt; &#xA;&lt;p&gt;Generating stack traces is as easy as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cpptrace/cpptrace.hpp&amp;gt;&#xA;&#xA;void trace() {&#xA;    cpptrace::generate_trace().print();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/res/demo.png&#34; alt=&#34;Demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace can also retrieve function inlining information on optimized release builds:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/res/inlining.png&#34; alt=&#34;Inlining&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace provides access to resolved stack traces as well as lightweight raw traces (just addresses) that can be resolved later:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const auto raw_trace = cpptrace::generate_raw_trace();&#xA;// then later&#xA;raw_trace.resolve().print();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Cpptrace provides a way to produce stack traces on arbitrary exceptions. More information on this system &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traces-from-all-exceptions&#34;&gt;below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cpptrace/from_current.hpp&amp;gt;&#xA;void foo() {&#xA;    throw std::runtime_error(&#34;foo failed&#34;);&#xA;}&#xA;int main() {&#xA;    CPPTRACE_TRY {&#xA;        foo();&#xA;    } CPPTRACE_CATCH(const std::exception&amp;amp; e) {&#xA;        std::cerr&amp;lt;&amp;lt;&#34;Exception: &#34;&amp;lt;&amp;lt;e.what()&amp;lt;&amp;lt;std::endl;&#xA;        cpptrace::from_current_exception().print();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/res/from_current.png&#34; alt=&#34;from_current&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are a few extraneous frames at the top of the stack corresponding to internals of exception handling in the standard library. These are a small price to pay for stack traces on all exceptions.&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace also provides a handful of traced exception objects that store stack traces when thrown. This is useful when the exceptions might not be caught by &lt;code&gt;CPPTRACE_CATCH&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cpptrace/cpptrace.hpp&amp;gt;&#xA;&#xA;void trace() {&#xA;    throw cpptrace::logic_error(&#34;This wasn&#39;t supposed to happen!&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/res/exception.png&#34; alt=&#34;Exception&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additional notable features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Utilities for demangling&lt;/li&gt; &#xA; &lt;li&gt;Utilities for catching &lt;code&gt;std::exception&lt;/code&gt;s and wrapping them in traced exceptions&lt;/li&gt; &#xA; &lt;li&gt;Signal-safe stack tracing&lt;/li&gt; &#xA; &lt;li&gt;Source code snippets in traces&lt;/li&gt; &#xA; &lt;li&gt;Extensive configuration options for &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#formatting&#34;&gt;trace formatting&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/res/snippets.png&#34; alt=&#34;Snippets&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;CMake FetchContent Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;include(FetchContent)&#xA;FetchContent_Declare(&#xA;  cpptrace&#xA;  GIT_REPOSITORY https://github.com/jeremy-rifkin/cpptrace.git&#xA;  GIT_TAG        v0.8.3 # &amp;lt;HASH or TAG&amp;gt;&#xA;)&#xA;FetchContent_MakeAvailable(cpptrace)&#xA;target_link_libraries(your_target cpptrace::cpptrace)&#xA;&#xA;# Needed for shared library builds on windows:  copy cpptrace.dll to the same directory as the&#xA;# executable for your_target&#xA;if(WIN32)&#xA;  add_custom_command(&#xA;    TARGET your_target POST_BUILD&#xA;    COMMAND ${CMAKE_COMMAND} -E copy_if_different&#xA;    $&amp;lt;TARGET_FILE:cpptrace::cpptrace&amp;gt;&#xA;    $&amp;lt;TARGET_FILE_DIR:your_target&amp;gt;&#xA;  )&#xA;endif()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be sure to configure with &lt;code&gt;-DCMAKE_BUILD_TYPE=Debug&lt;/code&gt; or &lt;code&gt;-DCMAKE_BUILD_TYPE=RelWithDebInfo&lt;/code&gt; for symbols and line information.&lt;/p&gt; &#xA;&lt;p&gt;On macOS it is recommended to generate a &lt;code&gt;.dSYM&lt;/code&gt; file, see &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#platform-logistics&#34;&gt;Platform Logistics&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;p&gt;For other ways to use the library, such as through package managers, a system-wide installation, or on a platform without internet access see &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#how-to-include-the-library&#34;&gt;How to Include The Library&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;h1&gt;Prerequisites&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Debug info (&lt;code&gt;-g&lt;/code&gt;/&lt;code&gt;/Z7&lt;/code&gt;/&lt;code&gt;/Zi&lt;/code&gt;/&lt;code&gt;/DEBUG&lt;/code&gt;/&lt;code&gt;-DBUILD_TYPE=Debug&lt;/code&gt;/&lt;code&gt;-DBUILD_TYPE=RelWithDebInfo&lt;/code&gt;) is required for complete trace information.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Basic Usage&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::generate_trace()&lt;/code&gt; can be used to generate a &lt;code&gt;stacktrace&lt;/code&gt; object at the current call site. Resolved frames can be accessed from this object with &lt;code&gt;.frames&lt;/code&gt; and the trace can be printed with &lt;code&gt;.print()&lt;/code&gt;. Cpptrace also provides a method to get light-weight raw traces with &lt;code&gt;cpptrace::generate_raw_trace()&lt;/code&gt;, which are just vectors of program counters, which can be resolved at a later time.&lt;/p&gt; &#xA;&lt;h1&gt;&lt;code&gt;namespace cpptrace&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;All functions are thread-safe unless otherwise noted.&lt;/p&gt; &#xA;&lt;h2&gt;Stack Traces&lt;/h2&gt; &#xA;&lt;p&gt;The core resolved stack trace object. Generate a trace with &lt;code&gt;cpptrace::generate_trace()&lt;/code&gt; or &lt;code&gt;cpptrace::stacktrace::current()&lt;/code&gt;. On top of a set of helper functions &lt;code&gt;struct stacktrace&lt;/code&gt; allows direct access to frames as well as iterators.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::stacktrace::print&lt;/code&gt; can be used to print a stacktrace. &lt;code&gt;cpptrace::stacktrace::print_with_snippets&lt;/code&gt; can be used to print a stack trace with source code snippets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    // Some type sufficient for an instruction pointer, currently always an alias to std::uintptr_t&#xA;    using frame_ptr = std::uintptr_t;&#xA;&#xA;    struct stacktrace_frame {&#xA;        frame_ptr raw_address; // address in memory&#xA;        frame_ptr object_address; // address in the object file&#xA;        // nullable&amp;lt;T&amp;gt; represents a nullable integer. More docs later.&#xA;        nullable&amp;lt;std::uint32_t&amp;gt; line;&#xA;        nullable&amp;lt;std::uint32_t&amp;gt; column;&#xA;        std::string filename;&#xA;        std::string symbol;&#xA;        bool is_inline;&#xA;        bool operator==(const stacktrace_frame&amp;amp; other) const;&#xA;        bool operator!=(const stacktrace_frame&amp;amp; other) const;&#xA;        object_frame get_object_info() const; // object_address is stored but if the object_path is needed this can be used&#xA;        std::string to_string() const;&#xA;        /* operator&amp;lt;&amp;lt;(ostream, ..) and std::format support exist for this object */&#xA;    };&#xA;&#xA;    struct stacktrace {&#xA;        std::vector&amp;lt;stacktrace_frame&amp;gt; frames;&#xA;        // here as a drop-in for std::stacktrace&#xA;        static stacktrace current(std::size_t skip = 0);&#xA;        static stacktrace current(std::size_t skip, std::size_t max_depth);&#xA;        void print() const;&#xA;        void print(std::ostream&amp;amp; stream) const;&#xA;        void print(std::ostream&amp;amp; stream, bool color) const;&#xA;        void print_with_snippets() const;&#xA;        void print_with_snippets(std::ostream&amp;amp; stream) const;&#xA;        void print_with_snippets(std::ostream&amp;amp; stream, bool color) const;&#xA;        std::string to_string(bool color = false) const;&#xA;        void clear();&#xA;        bool empty() const noexcept;&#xA;        /* operator&amp;lt;&amp;lt;(ostream, ..), std::format support, and iterators exist for this object */&#xA;    };&#xA;&#xA;    stacktrace generate_trace(std::size_t skip = 0);&#xA;    stacktrace generate_trace(std::size_t skip, std::size_t max_depth);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Object Traces&lt;/h2&gt; &#xA;&lt;p&gt;Object traces contain the most basic information needed to construct a stack trace outside the currently running executable. It contains the raw address, the address in the binary (ASLR and the object file&#39;s memory space and whatnot is resolved), and the path to the object the instruction pointer is located in.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    struct object_frame {&#xA;        std::string object_path;&#xA;        frame_ptr raw_address;&#xA;        frame_ptr object_address;&#xA;    };&#xA;&#xA;    struct object_trace {&#xA;        std::vector&amp;lt;object_frame&amp;gt; frames;&#xA;        static object_trace current(std::size_t skip = 0);&#xA;        static object_trace current(std::size_t skip, std::size_t max_depth);&#xA;        stacktrace resolve() const;&#xA;        void clear();&#xA;        bool empty() const noexcept;&#xA;        /* iterators exist for this object */&#xA;    };&#xA;&#xA;    object_trace generate_object_trace(std::size_t skip = 0);&#xA;    object_trace generate_object_trace(std::size_t skip, std::size_t max_depth);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Raw Traces&lt;/h2&gt; &#xA;&lt;p&gt;Raw trace access: A vector of program counters. These are ideal for fast and cheap traces you want to resolve later.&lt;/p&gt; &#xA;&lt;p&gt;Note it is important executables and shared libraries in memory aren&#39;t somehow unmapped otherwise libdl calls (and &lt;code&gt;GetModuleFileName&lt;/code&gt; in windows) will fail to figure out where the program counter corresponds to.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    struct raw_trace {&#xA;        std::vector&amp;lt;frame_ptr&amp;gt; frames;&#xA;        static raw_trace current(std::size_t skip = 0);&#xA;        static raw_trace current(std::size_t skip, std::size_t max_depth);&#xA;        object_trace resolve_object_trace() const;&#xA;        stacktrace resolve() const;&#xA;        void clear();&#xA;        bool empty() const noexcept;&#xA;        /* iterators exist for this object */&#xA;    };&#xA;&#xA;    raw_trace generate_raw_trace(std::size_t skip = 0);&#xA;    raw_trace generate_raw_trace(std::size_t skip, std::size_t max_depth);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Utilities&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::demangle&lt;/code&gt; provides a helper function for name demangling, since it has to implement that helper internally anyways.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::get_snippet&lt;/code&gt; gets a text snippet, if possible, from for the given source file for +/- &lt;code&gt;context_size&lt;/code&gt; lines around &lt;code&gt;line&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::isatty&lt;/code&gt; and the fileno definitions are useful for deciding whether to use color when printing stack traces.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::register_terminate_handler()&lt;/code&gt; is a helper function to set a custom &lt;code&gt;std::terminate&lt;/code&gt; handler that prints a stack trace from a cpptrace exception (more info below) and otherwise behaves like the normal terminate handler.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    std::string demangle(const std::string&amp;amp; name);&#xA;    std::string get_snippet(&#xA;        const std::string&amp;amp; path,&#xA;        std::size_t line,&#xA;        std::size_t context_size,&#xA;        bool color = false&#xA;    );&#xA;    bool isatty(int fd);&#xA;&#xA;    extern const int stdin_fileno;&#xA;    extern const int stderr_fileno;&#xA;    extern const int stdout_fileno;&#xA;&#xA;    void register_terminate_handler();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Formatting&lt;/h2&gt; &#xA;&lt;p&gt;Cpptrace provides a configurable formatter for stack trace printing which supports some common options. Formatters are configured with a sort of builder pattern, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto formatter = cpptrace::formatter{}&#xA;    .header(&#34;Stack trace:&#34;)&#xA;    .addresses(cpptrace::formatter::address_mode::object)&#xA;    .snippets(true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This API is available through the &lt;code&gt;&amp;lt;cpptrace/formatting.hpp&amp;gt;&lt;/code&gt; header.&lt;/p&gt; &#xA;&lt;p&gt;Synopsis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    class formatter {&#xA;        formatter&amp;amp; header(std::string);&#xA;        enum class color_mode { always, none, automatic };&#xA;        formatter&amp;amp; colors(color_mode);&#xA;        enum class address_mode { raw, object, none };&#xA;        formatter&amp;amp; addresses(address_mode);&#xA;        enum class path_mode { full, basename };&#xA;        formatter&amp;amp; paths(path_mode);&#xA;        formatter&amp;amp; snippets(bool);&#xA;        formatter&amp;amp; snippet_context(int);&#xA;        formatter&amp;amp; columns(bool);&#xA;        formatter&amp;amp; filtered_frame_placeholders(bool);&#xA;        formatter&amp;amp; filter(std::function&amp;lt;bool(const stacktrace_frame&amp;amp;)&amp;gt;);&#xA;        formatter&amp;amp; transform(std::function&amp;lt;stacktrace_frame(stacktrace_frame)&amp;gt;);&#xA;&#xA;        std::string format(const stacktrace_frame&amp;amp;) const;&#xA;        std::string format(const stacktrace_frame&amp;amp;, bool color) const;&#xA;&#xA;        std::string format(const stacktrace&amp;amp;) const;&#xA;        std::string format(const stacktrace&amp;amp;, bool color) const;&#xA;&#xA;        void print(const stacktrace_frame&amp;amp;) const;&#xA;        void print(const stacktrace_frame&amp;amp;, bool color) const;&#xA;        void print(std::ostream&amp;amp;, const stacktrace_frame&amp;amp;) const;&#xA;        void print(std::ostream&amp;amp;, const stacktrace_frame&amp;amp;, bool color) const;&#xA;        void print(std::FILE*, const stacktrace_frame&amp;amp;) const;&#xA;        void print(std::FILE*, const stacktrace_frame&amp;amp;, bool color) const;&#xA;&#xA;        void print(const stacktrace&amp;amp;) const;&#xA;        void print(const stacktrace&amp;amp;, bool color) const;&#xA;        void print(std::ostream&amp;amp;, const stacktrace&amp;amp;) const;&#xA;        void print(std::ostream&amp;amp;, const stacktrace&amp;amp;, bool color) const;&#xA;        void print(std::FILE*, const stacktrace&amp;amp;) const;&#xA;        void print(std::FILE*, const stacktrace&amp;amp;, bool color) const;&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Options:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Setting&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;header&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Header line printed before the trace&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Stack trace (most recent call first):&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;colors&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Default color mode for the trace&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;automatic&lt;/code&gt;, which attempts to detect if the target stream is a terminal&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;addresses&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Raw addresses, object addresses, or no addresses&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;raw&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;paths&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Full paths or just filenames&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;full&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;snippets&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether to include source code snippets&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;snippet_context&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;How many lines of source context to show in a snippet&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;columns&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether to include column numbers if present&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;filtered_frame_placeholders&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Whether to still print filtered frames as just &lt;code&gt;#n (filtered)&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A predicate to filter frames with&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A transformer which takes a stacktrace frame and modifies it&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The &lt;code&gt;automatic&lt;/code&gt; color mode attempts to detect if a stream that may be attached to a terminal. As such, it will not use colors for the &lt;code&gt;formatter::format&lt;/code&gt; method and it may not be able to detect if some ostreams correspond to terminals or not. For this reason, &lt;code&gt;formatter::format&lt;/code&gt; and &lt;code&gt;formatter::print&lt;/code&gt; methods have overloads taking a color parameter. This color parameter will override configured color mode.&lt;/p&gt; &#xA;&lt;p&gt;Recommended practice with formatters: It&#39;s generally preferable to create formatters objects that are long-lived rather than to create them on the fly every time a trace needs to be formatted.&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace provides access to a formatter with default settings with &lt;code&gt;get_default_formatter&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    const formatter&amp;amp; get_default_formatter();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transforms&lt;/h3&gt; &#xA;&lt;p&gt;A transform function can be specified for the formatter. This function is called before the configured &lt;code&gt;filter&lt;/code&gt; is checked. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto formatter = cpptrace::formatter{}&#xA;    .transform([](cpptrace::stacktrace_frame frame) {&#xA;        frame.symbol = replace_all(frame, &#34;std::__cxx11::&#34;, &#34;std::&#34;);&#xA;        return frame;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::absorb_trace_exceptions&lt;/code&gt;: Configure whether the library silently absorbs internal exceptions and continues. Default is true.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::enable_inlined_call_resolution&lt;/code&gt;: Configure whether the library will attempt to resolve inlined call information for release builds. Default is true.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::experimental::set_cache_mode&lt;/code&gt;: Control time-memory tradeoffs within the library. By default speed is prioritized. If using this function, set the cache mode at the very start of your program before any traces are performed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    void absorb_trace_exceptions(bool absorb);&#xA;    void enable_inlined_call_resolution(bool enable);&#xA;&#xA;    enum class cache_mode {&#xA;        // Only minimal lookup tables&#xA;        prioritize_memory,&#xA;        // Build lookup tables but don&#39;t keep them around between trace calls&#xA;        hybrid,&#xA;        // Build lookup tables as needed&#xA;        prioritize_speed&#xA;    };&#xA;&#xA;    namespace experimental {&#xA;        void set_cache_mode(cache_mode mode);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Traces From All Exceptions&lt;/h2&gt; &#xA;&lt;p&gt;Cpptrace provides &lt;code&gt;CPPTRACE_TRY&lt;/code&gt; and &lt;code&gt;CPPTRACE_CATCH&lt;/code&gt; macros that allow a stack trace to be collected from the current thrown exception object, with minimal or no overhead in the non-throwing path:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cpptrace/from_current.hpp&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;&#xA;void foo() {&#xA;    throw std::runtime_error(&#34;foo failed&#34;);&#xA;}&#xA;int main() {&#xA;    CPPTRACE_TRY {&#xA;        foo();&#xA;    } CPPTRACE_CATCH(const std::exception&amp;amp; e) {&#xA;        std::cerr&amp;lt;&amp;lt;&#34;Exception: &#34;&amp;lt;&amp;lt;e.what()&amp;lt;&amp;lt;std::endl;&#xA;        cpptrace::from_current_exception().print();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This functionality is entirely opt-in, to access this use &lt;code&gt;#include &amp;lt;cpptrace/from_current.hpp&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Any declarator &lt;code&gt;catch&lt;/code&gt; accepts works with &lt;code&gt;CPPTRACE_CATCH&lt;/code&gt;, including &lt;code&gt;...&lt;/code&gt;. This works with any thrown object, not just &lt;code&gt;std::exceptions&lt;/code&gt;, it even works with &lt;code&gt;throw 0;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/res/from_current.png&#34; alt=&#34;from_current&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are a few extraneous frames at the top of the stack corresponding to standard library exception handling internals. These are a small price to pay for stack traces on all exceptions.&lt;/p&gt; &#xA;&lt;p&gt;API functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cpptrace::raw_trace_from_current_exception&lt;/code&gt;: Returns &lt;code&gt;const raw_trace&amp;amp;&lt;/code&gt; from the current exception.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cpptrace::from_current_exception&lt;/code&gt;: Returns a resolved &lt;code&gt;const stacktrace&amp;amp;&lt;/code&gt; from the current exception. Invalidates references to traces returned by &lt;code&gt;cpptrace::raw_trace_from_current_exception&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is a performance tradeoff with this functionality: Either the try-block can be zero overhead in the non-throwing path with potential expense in the throwing path, or the try-block can have very minimal overhead in the non-throwing path due to bookkeeping with guarantees about the expense of the throwing path. More details on this tradeoff &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#performance&#34;&gt;below&lt;/a&gt;. Cpptrace provides macros for both sides of this tradeoff:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_TRY&lt;/code&gt;/&lt;code&gt;CPPTRACE_CATCH&lt;/code&gt;: Minimal overhead in the non-throwing path (one &lt;code&gt;mov&lt;/code&gt; on x86, and this may be optimized out if the compiler is able)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_TRYZ&lt;/code&gt;/&lt;code&gt;CPPTRACE_CATCHZ&lt;/code&gt;: Zero overhead in the non-throwing path, potential extra cost in the throwing path&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: It&#39;s important to not mix the &lt;code&gt;Z&lt;/code&gt; variants with the non-&lt;code&gt;Z&lt;/code&gt; variants.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately the try/catch macros are needed to insert some magic to perform a trace during the unwinding search phase. In order to have multiple catch alternatives, either &lt;code&gt;CPPTRACE_CATCH_ALT&lt;/code&gt; or a normal &lt;code&gt;catch&lt;/code&gt; must be used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;CPPTRACE_TRY {&#xA;    foo();&#xA;} CPPTRACE_CATCH(const std::exception&amp;amp;) { // &amp;lt;- First catch must be CPPTRACE_CATCH&#xA;    // ...&#xA;} CPPTRACE_CATCH_ALT(const std::exception&amp;amp;) { // &amp;lt;- Ok&#xA;    // ...&#xA;} catch(const std::exception&amp;amp;) { // &amp;lt;- Also Ok&#xA;    // ...&#xA;} CPPTRACE_CATCH(const std::exception&amp;amp;) { // &amp;lt;- Not Ok&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: The current exception is the exception most recently seen by a cpptrace try-catch macro block.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;CPPTRACE_TRY {&#xA;    throw std::runtime_error(&#34;foo&#34;);&#xA;} CPPTRACE_CATCH(const std::exception&amp;amp; e) {&#xA;    cpptrace::from_current_exception().print(); // the trace for std::runtime_error(&#34;foo&#34;)&#xA;    CPPTRACE_TRY {&#xA;        throw std::runtime_error(&#34;bar&#34;);&#xA;    } CPPTRACE_CATCH(const std::exception&amp;amp; e) {&#xA;        cpptrace::from_current_exception().print(); // the trace for std::runtime_error(&#34;bar&#34;)&#xA;    }&#xA;    cpptrace::from_current_exception().print(); // the trace for std::runtime_error(&#34;bar&#34;), again&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Removing the &lt;code&gt;CPPTRACE_&lt;/code&gt; prefix&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;CPPTRACE_TRY&lt;/code&gt; is a little cumbersome to type. To remove the &lt;code&gt;CPPTRACE_&lt;/code&gt; prefix you can use the &lt;code&gt;CPPTRACE_UNPREFIXED_TRY_CATCH&lt;/code&gt; cmake option or the &lt;code&gt;CPPTRACE_UNPREFIXED_TRY_CATCH&lt;/code&gt; preprocessor definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;TRY {&#xA;    foo();&#xA;} CATCH(const std::exception&amp;amp; e) {&#xA;    std::cerr&amp;lt;&amp;lt;&#34;Exception: &#34;&amp;lt;&amp;lt;e.what()&amp;lt;&amp;lt;std::endl;&#xA;    cpptrace::from_current_exception().print();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is not done by default for macro safety/hygiene reasons. If you do not want &lt;code&gt;TRY&lt;/code&gt;/&lt;code&gt;CATCH&lt;/code&gt; macros defined, as they are common macro names, you can easily modify the following snippet to provide your own aliases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define TRY CPPTRACE_TRY&#xA;#define CATCH(param) CPPTRACE_CATCH(param)&#xA;#define TRYZ CPPTRACE_TRYZ&#xA;#define CATCHZ(param) CPPTRACE_CATCHZ(param)&#xA;#define CATCH_ALT(param) CPPTRACE_CATCH_ALT(param)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How it works&lt;/h3&gt; &#xA;&lt;p&gt;C++ does not provide any language support for collecting stack traces when exceptions are thrown, however, exception handling under both the Itanium ABI and by SEH (used to implement C++ exceptions on windows) involves unwinding the stack twice. The first unwind searches for an appropriate &lt;code&gt;catch&lt;/code&gt; handler, the second actually unwinds the stack and calls destructors. Since the stack remains intact during the search phase it&#39;s possible to collect a stack trace with little to no overhead when the &lt;code&gt;catch&lt;/code&gt; is considered for matching the exception. The try/catch macros for cpptrace set up a special try/catch system that can collect a stack trace when considered during a search phase.&lt;/p&gt; &#xA;&lt;p&gt;N.b.: This mechanism is also discussed in &lt;a href=&#34;https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2490r3.html&#34;&gt;P2490R3&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;The fundamental mechanism for this functionality is generating a trace when a catch block is considered during an exception handler search phase. Internally a lightweight raw trace is generated upon consideration, which is quite fast. This raw trace is only resolved when &lt;code&gt;cpptrace::from_current_exception&lt;/code&gt; is called, or when the user manually resolves a trace from &lt;code&gt;cpptrace::raw_trace_from_current_exception&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s tricky, however, from the library&#39;s standpoint to check if the catch will end up matching. The library could simply generate a trace every time a &lt;code&gt;CPPTRACE_CATCH&lt;/code&gt; is considered, however, in a deep nesting of catch&#39;s, e.g. as a result of recusion, where a matching handler is not found quickly this could introduce a non-trivial cost in the throwing pat due to tracing the stack multiple times. Thus, there is a performance tradeoff between a little book keeping to prevent duplicate tracing or biting the bullet, so to speak, in the throwing path and unwinding multiple times.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP] The choice between the &lt;code&gt;Z&lt;/code&gt; and non-&lt;code&gt;Z&lt;/code&gt; (zero-overhead and non-zero-overhead) variants of the exception handlers should not matter 99% of the time, however, both are provided in the rare case that it does.&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;CPPTRACE_TRY&lt;/code&gt;/&lt;code&gt;CPPTRACE_CATCH&lt;/code&gt; could only hurt performance if used in a hot loop where the compiler can&#39;t optimize away the internal bookkeeping, otherwise the bookkeeping should be completely negligible.&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;CPPTRACE_TRYZ&lt;/code&gt;/&lt;code&gt;CPPTRACE_CATCHZ&lt;/code&gt; could only hurt performance when there is an exceptionally deep nesting of exception handlers in a call stack before a matching handler.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;More information on performance considerations with the zero-overhead variant:&lt;/p&gt; &#xA;&lt;p&gt;Tracing the stack multiple times in throwing paths should not matter for the vast majority applications given that:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Performance very rarely is critical in throwing paths and exceptions should be exceptionally rare&lt;/li&gt; &#xA; &lt;li&gt;Exception handling is not usually used in such a way that you could have a deep nesting of handlers before finding a matching handler&lt;/li&gt; &#xA; &lt;li&gt;Most call stacks are fairly shallow&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To put the scale of this performance consideration into perspective: In my benchmarking I have found generation of raw traces to take on the order of &lt;code&gt;100ns&lt;/code&gt; per frame. Thus, even if there were 100 non-matching handlers before a matching handler in a 100-deep call stack the total time would stil be on the order of one millisecond.&lt;/p&gt; &#xA;&lt;p&gt;Nonetheless, I chose a default bookkeeping behavior for &lt;code&gt;CPPTRACE_TRY&lt;/code&gt;/&lt;code&gt;CPPTRACE_CATCH&lt;/code&gt; since it is safer with better performance guarantees for the most general possible set of users.&lt;/p&gt; &#xA;&lt;h2&gt;Traced Exception Objects&lt;/h2&gt; &#xA;&lt;p&gt;Cpptrace provides a handful of traced exception classes which automatically collect stack traces when thrown. These are useful when throwing exceptions that may not be caught by &lt;code&gt;CPPTRACE_CATCH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The base traced exception class is &lt;code&gt;cpptrace::exception&lt;/code&gt; and cpptrace provides a handful of helper classes for working with traced exceptions. These exceptions generate relatively lightweight raw traces and resolve symbols and line numbers lazily if and when requested.&lt;/p&gt; &#xA;&lt;p&gt;These are provided both as a useful utility and as a reference implementation for traced exceptions.&lt;/p&gt; &#xA;&lt;p&gt;The basic interface is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    class exception : public std::exception {&#xA;    public:&#xA;        virtual const char* what() const noexcept = 0; // The what string both the message and trace&#xA;        virtual const char* message() const noexcept = 0;&#xA;        virtual const stacktrace&amp;amp; trace() const noexcept = 0;&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are two ways to go about traced exception objects: Traces can be resolved eagerly or lazily. Cpptrace provides the basic implementation of exceptions as lazy exceptions. I hate to have anything about the implementation exposed in the interface or type system but this seems to be the best way to do this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    class lazy_exception : public exception {&#xA;        // lazy_trace_holder is basically a std::variant&amp;lt;raw_trace, stacktrace&amp;gt;, more docs later&#xA;        mutable detail::lazy_trace_holder trace_holder;&#xA;        mutable std::string what_string;&#xA;    public:&#xA;        explicit lazy_exception(&#xA;            raw_trace&amp;amp;&amp;amp; trace = detail::get_raw_trace_and_absorb()&#xA;        ) noexcept : trace_holder(std::move(trace)) {}&#xA;        const char* what() const noexcept override;&#xA;        const char* message() const noexcept override;&#xA;        const stacktrace&amp;amp; trace() const noexcept override;&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;cpptrace::lazy_exception&lt;/code&gt; can be freely thrown or overridden. Generally &lt;code&gt;message()&lt;/code&gt; is the only field to override.&lt;/p&gt; &#xA;&lt;p&gt;Lastly cpptrace provides an exception class that takes a user-provided message, &lt;code&gt;cpptrace::exception_with_message&lt;/code&gt;, as well as a number of traced exception classes resembling &lt;code&gt;&amp;lt;stdexcept&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    class exception_with_message : public lazy_exception {&#xA;        mutable std::string user_message;&#xA;    public:&#xA;        explicit exception_with_message(&#xA;            std::string&amp;amp;&amp;amp; message_arg,&#xA;            raw_trace&amp;amp;&amp;amp; trace = detail::get_raw_trace_and_absorb()&#xA;        ) noexcept : lazy_exception(std::move(trace)), user_message(std::move(message_arg)) {}&#xA;        const char* message() const noexcept override;&#xA;    };&#xA;&#xA;    // All stdexcept errors have analogs here. All but system_error have the constructor:&#xA;    // explicit the_error(&#xA;    //     std::string&amp;amp;&amp;amp; message_arg,&#xA;    //     raw_trace&amp;amp;&amp;amp; trace = detail::get_raw_trace_and_absorb()&#xA;    // ) noexcept&#xA;    //     : exception_with_message(std::move(message_arg), std::move(trace)) {}&#xA;    class logic_error      : public exception_with_message { ... };&#xA;    class domain_error     : public exception_with_message { ... };&#xA;    class invalid_argument : public exception_with_message { ... };&#xA;    class length_error     : public exception_with_message { ... };&#xA;    class out_of_range     : public exception_with_message { ... };&#xA;    class runtime_error    : public exception_with_message { ... };&#xA;    class range_error      : public exception_with_message { ... };&#xA;    class overflow_error   : public exception_with_message { ... };&#xA;    class underflow_error  : public exception_with_message { ... };&#xA;    class system_error : public runtime_error {&#xA;    public:&#xA;        explicit system_error(&#xA;            int error_code,&#xA;            std::string&amp;amp;&amp;amp; message_arg,&#xA;            raw_trace&amp;amp;&amp;amp; trace = detail::get_raw_trace_and_absorb()&#xA;        ) noexcept;&#xA;        const std::error_code&amp;amp; code() const noexcept;&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Wrapping std::exceptions&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] This section is largely obsolete now that cpptrace provides a better mechanism for collecting &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traces-from-exceptions&#34;&gt;traces from exceptions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Cpptrace exceptions can provide great information for user-controlled exceptions. For non-cpptrace::exceptions that may originate outside of code you control, e.g. the standard library, cpptrace provides some wrapper utilities that can rethrow these exceptions nested in traced cpptrace exceptions. The trace won&#39;t be perfect, the trace will start where the wrapper caught it, but these utilities can provide good diagnostic information. Unfortunately this is the best solution for this problem, as far as I know.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;int&amp;gt; foo = {1, 2, 3};&#xA;CPPTRACE_WRAP_BLOCK(&#xA;    foo.at(4) = 2;&#xA;    foo.at(5)++;&#xA;);&#xA;std::cout&amp;lt;&amp;lt;CPPTRACE_WRAP(foo.at(12))&amp;lt;&amp;lt;std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Exception handling with cpptrace exception objects&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] This section pertains to cpptrace traced exception objects and not the mechanism for collecting &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traces-from-exceptions&#34;&gt;traces from arbitrary exceptions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Working with cpptrace exceptions in your code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;try {&#xA;    foo();&#xA;} catch(cpptrace::exception&amp;amp; e) {&#xA;    // Prints the exception info and stack trace, conditionally enabling color codes depending on&#xA;    // whether stderr is a terminal&#xA;    std::cerr &amp;lt;&amp;lt; &#34;Error: &#34; &amp;lt;&amp;lt; e.message() &amp;lt;&amp;lt; &#39;\n&#39;;&#xA;    e.trace().print(std::cerr, cpptrace::isatty(cpptrace::stderr_fileno));&#xA;} catch(std::exception&amp;amp; e) {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;Error: &#34; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; &#39;\n&#39;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Terminate Handling&lt;/h2&gt; &#xA;&lt;p&gt;Cpptrace provides a custom &lt;code&gt;std::terminate&lt;/code&gt; handler that prints stacktraces while otherwise behaving like the normal &lt;code&gt;std::terminate&lt;/code&gt; handler. If a cpptrace exception object reaches &lt;code&gt;std::terminate&lt;/code&gt; the trace from that exception is printed, otherwise a stack trace is generated at the point of the terminate handler. Often &lt;code&gt;std::terminate&lt;/code&gt; is called directly without unwinding so the trace is preserved.&lt;/p&gt; &#xA;&lt;p&gt;To register this custom handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cpptrace::register_terminate_handler();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Signal-Safe Tracing&lt;/h2&gt; &#xA;&lt;p&gt;Stack traces from signal handlers can provide very helpful information for debugging application crashes, e.g. from SIGSEGV or SIGTRAP handlers. Signal handlers are really restrictive environments as your application could be interrupted by a signal at any point, including in the middle of malloc or buffered IO or while holding a lock. Doing a stack trace in a signal handler is possible but it requires a lot of care. This is difficult to do correctly and most examples online do this incorrectly.&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace offers an API to walk the stack in a signal handler and produce a raw trace safely. The library also provides an interface for producing a object frame safely:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    std::size_t safe_generate_raw_trace(frame_ptr* buffer, std::size_t size, std::size_t skip = 0);&#xA;    std::size_t safe_generate_raw_trace(frame_ptr* buffer, std::size_t size, std::size_t skip, std::size_t max_depth);&#xA;    struct safe_object_frame {&#xA;        frame_ptr raw_address;&#xA;        frame_ptr address_relative_to_object_start;&#xA;        char object_path[CPPTRACE_PATH_MAX + 1];&#xA;        object_frame resolve() const; // To be called outside a signal handler. Not signal safe.&#xA;    };&#xA;    void get_safe_object_frame(frame_ptr address, safe_object_frame* out);&#xA;    bool can_signal_safe_unwind();&#xA;    bool can_get_safe_object_frame();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is not possible to resolve debug symbols safely in the process from a signal handler without heroic effort. In order to produce a full trace there are three options:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Carefully save the object trace information to be resolved at a later time outside the signal handler&lt;/li&gt; &#xA; &lt;li&gt;Write the object trace information to a file to be resolved later&lt;/li&gt; &#xA; &lt;li&gt;Spawn a new process, communicate object trace information to that process, and have that process do the trace resolution&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For traces on segfaults, e.g., only options 2 and 3 are viable. For more information an implementation of approach 3, see the comprehensive overview and demo at &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/docs/signal-safe-tracing.md&#34;&gt;signal-safe-tracing.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Currently signal-safe stack unwinding is only possible with &lt;code&gt;libunwind&lt;/code&gt;, which must be &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#library-back-ends&#34;&gt;manually enabled&lt;/a&gt;. If signal-safe unwinding isn&#39;t supported, &lt;code&gt;safe_generate_raw_trace&lt;/code&gt; will just produce an empty trace. &lt;code&gt;can_signal_safe_unwind&lt;/code&gt; can be used to check for signal-safe unwinding support and &lt;code&gt;can_get_safe_object_frame&lt;/code&gt; can be used to check &lt;code&gt;get_safe_object_frame&lt;/code&gt; support. If object information can&#39;t be resolved in a signal-safe way then &lt;code&gt;get_safe_object_frame&lt;/code&gt; will not populate fields beyond the &lt;code&gt;raw_address&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] &lt;code&gt;_dl_find_object&lt;/code&gt; is required for signal-safe stack tracing. This is a relatively recent addition to glibc, added in glibc 2.35.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!CAUTION] Calls to shared objects can be lazy-loaded where the first call to the shared object invokes non-signal-safe functions such as &lt;code&gt;malloc()&lt;/code&gt;. To avoid this, call these routines in &lt;code&gt;main()&lt;/code&gt; ahead of a signal handler to &#34;warm up&#34; the library.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Utility Types&lt;/h2&gt; &#xA;&lt;p&gt;A couple utility types are used to provide the library with a good interface.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;nullable&amp;lt;T&amp;gt;&lt;/code&gt; is used for a nullable integer type. Internally the maximum value for &lt;code&gt;T&lt;/code&gt; is used as a sentinel. &lt;code&gt;std::optional&lt;/code&gt; would be used if this library weren&#39;t c++11. But, &lt;code&gt;nullable&amp;lt;T&amp;gt;&lt;/code&gt; provides an &lt;code&gt;std::optional&lt;/code&gt;-like interface and it&#39;s less heavy-duty for this use than an &lt;code&gt;std::optional&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;detail::lazy_trace_holder&lt;/code&gt; is a utility type for &lt;code&gt;lazy_exception&lt;/code&gt; used in place of an &lt;code&gt;std::variant&amp;lt;raw_trace, stacktrace&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    template&amp;lt;typename T, typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, int&amp;gt;::type = 0&amp;gt;&#xA;    struct nullable {&#xA;        T raw_value;&#xA;        // all members are constexpr for c++17 and beyond, some are constexpr before c++17&#xA;        nullable&amp;amp; operator=(T value)&#xA;        bool has_value() const noexcept;&#xA;        T&amp;amp; value() noexcept;&#xA;        const T&amp;amp; value() const noexcept;&#xA;        T value_or(T alternative) const noexcept;&#xA;        void swap(nullable&amp;amp; other) noexcept;&#xA;        void reset() noexcept;&#xA;        bool operator==(const nullable&amp;amp; other) const noexcept;&#xA;        bool operator!=(const nullable&amp;amp; other) const noexcept;&#xA;        constexpr static T null_value() noexcept; // returns the raw null value&#xA;        constexpr static nullable null() noexcept; // returns a null instance&#xA;    };&#xA;&#xA;    namespace detail {&#xA;        class lazy_trace_holder {&#xA;            bool resolved;&#xA;            union {&#xA;                raw_trace trace;&#xA;                stacktrace resolved_trace;&#xA;            };&#xA;        public:&#xA;            // constructors&#xA;            lazy_trace_holder() : trace() {}&#xA;            explicit lazy_trace_holder(raw_trace&amp;amp;&amp;amp; _trace);&#xA;            explicit lazy_trace_holder(stacktrace&amp;amp;&amp;amp; _resolved_trace);&#xA;            // logistics&#xA;            lazy_trace_holder(const lazy_trace_holder&amp;amp; other);&#xA;            lazy_trace_holder(lazy_trace_holder&amp;amp;&amp;amp; other) noexcept;&#xA;            lazy_trace_holder&amp;amp; operator=(const lazy_trace_holder&amp;amp; other);&#xA;            lazy_trace_holder&amp;amp; operator=(lazy_trace_holder&amp;amp;&amp;amp; other) noexcept;&#xA;            ~lazy_trace_holder();&#xA;            // access&#xA;            const raw_trace&amp;amp; get_raw_trace() const;&#xA;            stacktrace&amp;amp; get_resolved_trace();&#xA;            const stacktrace&amp;amp; get_resolved_trace() const; // throws if not already resolved&#xA;        private:&#xA;            void clear();&#xA;        };&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Headers&lt;/h2&gt; &#xA;&lt;p&gt;Cpptrace provides a handful of headers to make inclusion more minimal.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Header&lt;/th&gt; &#xA;   &lt;th&gt;Contents&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/forward.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace::frame_ptr&lt;/code&gt; and a few trace class forward declarations&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/basic.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Definitions for trace classes and the basic tracing APIs (&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#stack-traces&#34;&gt;Stack Traces&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#object-traces&#34;&gt;Object Traces&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#raw-traces&#34;&gt;Raw Traces&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#signal-safe-tracing&#34;&gt;Signal-Safe Tracing&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/exceptions.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traced-exception-objects&#34;&gt;Traced Exception Objects&lt;/a&gt; and related utilities (&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#wrapping-stdexceptions&#34;&gt;Wrapping std::exceptions&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/from_current.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#traces-from-all-exceptions&#34;&gt;Traces From All Exceptions&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/io.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; overloads for &lt;code&gt;std::ostream&lt;/code&gt; and &lt;code&gt;std::formatter&lt;/code&gt;s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/formatting.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Configurable formatter API&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/utils.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Utility functions, configuration functions, and terminate utilities (&lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#utilities&#34;&gt;Utilities&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#configuration&#34;&gt;Configuration&lt;/a&gt;, and &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#terminate-handling&#34;&gt;Terminate Handling&lt;/a&gt;)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/version.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Library version macros&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace/gdb_jit.hpp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Provides a special utility related to &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#jit-support&#34;&gt;JIT support&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The main cpptrace header is &lt;code&gt;cpptrace/cpptrace.hpp&lt;/code&gt; which includes everything other than &lt;code&gt;from_current.hpp&lt;/code&gt; and &lt;code&gt;version.hpp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Libdwarf Tuning&lt;/h2&gt; &#xA;&lt;p&gt;For extraordinarily large binaries (multiple gigabytes), cpptrace&#39;s internal caching can result in a lot of memory usage. Cpptrace provides some options to reduce memory usage in exchange for performance in memory-constrained applications.&lt;/p&gt; &#xA;&lt;p&gt;Synopsis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    namespace experimental {&#xA;        void set_dwarf_resolver_line_table_cache_size(nullable&amp;lt;std::size_t&amp;gt; max_entries);&#xA;        void set_dwarf_resolver_disable_aranges(bool disable);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Explanation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;set_dwarf_resolver_line_table_cache_size&lt;/code&gt; can be used to set a limit to the cache size with evictions done LRU. Cpptrace loads and caches line tables for dwarf compile units. These can take a lot of space for large binaries with lots of debug info. Passing &lt;code&gt;nullable&amp;lt;std::size_t&amp;gt;::null()&lt;/code&gt; will disable the cache size (which is the default behavior).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;set_dwarf_resolver_disable_aranges&lt;/code&gt; can be used to disable use of dwarf &lt;code&gt;.debug_aranges&lt;/code&gt;, an accelerated range lookup table for compile units emitted by many compilers. Cpptrace uses these by default if they are present since they can speed up resolution, however, they can also result in significant memory usage.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;JIT Support&lt;/h2&gt; &#xA;&lt;p&gt;Cpptrace has support for resolving symbols from frames in JIT-compiled code. To do this, cpptrace relies on in-memory object files (elf on linux or mach-o on mac) that contain symbol tables and dwarf debug information. The main reason for this is many JIT implementations already produce these for debugger support.&lt;/p&gt; &#xA;&lt;p&gt;These in-memory object files must be set up in such a way that the symbol table and debug symbol addresses match the run-time addresses of the JIT code.&lt;/p&gt; &#xA;&lt;p&gt;The basic interface for informing cpptrace about these in-memory object files is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    void register_jit_object(const char*, std::size_t);&#xA;    void unregister_jit_object(const char*);&#xA;    void clear_all_jit_objects();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Many JIT implementations follow the GDB &lt;a href=&#34;https://sourceware.org/gdb/current/onlinedocs/gdb.html/JIT-Interface.html&#34;&gt;JIT Compilation Interface&lt;/a&gt; so that JIT code can be debugged. The interface, at a high level, entails adding in-memory object files to a linked list of object files that GDB and other debuggers can reference (stored in the &lt;code&gt;__jit_debug_descriptor&lt;/code&gt;). Cpptrace provides, as a utility, a mechanism for loading all in-memory object files present in the &lt;code&gt;__jit_debug_descriptor&lt;/code&gt; linked list via &lt;code&gt;&amp;lt;cpptrace/gdb_jit.hpp&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace cpptrace {&#xA;    namespace experimental {&#xA;        void register_jit_objects_from_gdb_jit_interface();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Your program must be able to link against a global C symbol &lt;code&gt;__jit_debug_descriptor&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: Calling &lt;code&gt;cpptrace::experimental::register_jit_objects_from_gdb_jit_interface&lt;/code&gt; clears all jit objects previously registered with cpptrace.&lt;/p&gt; &#xA;&lt;h1&gt;Supported Debug Formats&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Format&lt;/th&gt; &#xA;   &lt;th&gt;Supported&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DWARF in binary&lt;/td&gt; &#xA;   &lt;td&gt;✔️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GNU debug link&lt;/td&gt; &#xA;   &lt;td&gt;️️✔️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Split dwarf (debug fission)&lt;/td&gt; &#xA;   &lt;td&gt;✔️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DWARF in dSYM&lt;/td&gt; &#xA;   &lt;td&gt;✔️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DWARF via Mach-O debug map&lt;/td&gt; &#xA;   &lt;td&gt;✔️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Windows debug symbols in PDB&lt;/td&gt; &#xA;   &lt;td&gt;✔️&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;DWARF5 added DWARF package files. As far as I can tell no compiler implements these yet.&lt;/p&gt; &#xA;&lt;h1&gt;How to Include The Library&lt;/h1&gt; &#xA;&lt;h2&gt;CMake FetchContent&lt;/h2&gt; &#xA;&lt;p&gt;With CMake FetchContent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;include(FetchContent)&#xA;FetchContent_Declare(&#xA;  cpptrace&#xA;  GIT_REPOSITORY https://github.com/jeremy-rifkin/cpptrace.git&#xA;  GIT_TAG        v0.8.3 # &amp;lt;HASH or TAG&amp;gt;&#xA;)&#xA;FetchContent_MakeAvailable(cpptrace)&#xA;target_link_libraries(your_target cpptrace::cpptrace)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s as easy as that. Cpptrace will automatically configure itself for your system. Note: On windows and macos some extra work is required, see &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#platform-logistics&#34;&gt;Platform Logistics&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;p&gt;Be sure to configure with &lt;code&gt;-DCMAKE_BUILD_TYPE=Debug&lt;/code&gt; or &lt;code&gt;-DCMAKE_BUILD_TYPE=RelWithDebInfo&lt;/code&gt; for symbols and line information.&lt;/p&gt; &#xA;&lt;h2&gt;System-Wide Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/jeremy-rifkin/cpptrace.git&#xA;git checkout v0.8.3&#xA;mkdir cpptrace/build&#xA;cd cpptrace/build&#xA;cmake .. -DCMAKE_BUILD_TYPE=Release&#xA;make -j&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using through cmake:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;find_package(cpptrace REQUIRED)&#xA;target_link_libraries(&amp;lt;your target&amp;gt; cpptrace::cpptrace)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be sure to configure with &lt;code&gt;-DCMAKE_BUILD_TYPE=Debug&lt;/code&gt; or &lt;code&gt;-DCMAKE_BUILD_TYPE=RelWithDebInfo&lt;/code&gt; for symbols and line information.&lt;/p&gt; &#xA;&lt;p&gt;Or compile with &lt;code&gt;-lcpptrace&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;g++ main.cpp -o main -g -Wall -lcpptrace&#xA;./main&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] If you aren&#39;t using cmake and are linking statically you must manually specify &lt;code&gt;-DCPPTRACE_STATIC_DEFINE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;If you get an error along the lines of&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;error while loading shared libraries: libcpptrace.so: cannot open shared object file: No such file or directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may have to run &lt;code&gt;sudo /sbin/ldconfig&lt;/code&gt; to create any necessary links and update caches so the system can find libcpptrace.so (I had to do this on Ubuntu). Only when installing system-wide. Usually your package manager does this for you when installing new libraries.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] Libdwarf requires a relatively new version of libdwarf. Sometimes a previously-installed system-wide libdwarf may cause issues due to being too old. Libdwarf 8 and newer is known to work.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;System-wide install on windows&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-ps1&#34;&gt;git clone https://github.com/jeremy-rifkin/cpptrace.git&#xA;git checkout v0.8.3&#xA;mkdir cpptrace/build&#xA;cd cpptrace/build&#xA;cmake .. -DCMAKE_BUILD_TYPE=Release&#xA;msbuild cpptrace.sln&#xA;msbuild INSTALL.vcxproj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Note: You&#39;ll need to run as an administrator in a developer powershell, or use vcvarsall.bat distributed with visual studio to get the correct environment variables set.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Local User Installation&lt;/h2&gt; &#xA;&lt;p&gt;To install just for the local user (or any custom prefix):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/jeremy-rifkin/cpptrace.git&#xA;git checkout v0.8.3&#xA;mkdir cpptrace/build&#xA;cd cpptrace/build&#xA;cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$HOME/wherever&#xA;make -j&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using through cmake:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;find_package(cpptrace REQUIRED PATHS $ENV{HOME}/wherever)&#xA;target_link_libraries(&amp;lt;your target&amp;gt; cpptrace::cpptrace)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ main.cpp -o main -g -Wall -I$HOME/wherever/include -L$HOME/wherever/lib -lcpptrace&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] If you aren&#39;t using cmake and are linking statically you must manually specify &lt;code&gt;-DCPPTRACE_STATIC_DEFINE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Use Without CMake&lt;/h2&gt; &#xA;&lt;p&gt;To use the library without cmake first follow the installation instructions at &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#system-wide-installation&#34;&gt;System-Wide Installation&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#local-user-installation&#34;&gt;Local User Installation&lt;/a&gt;, or &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/#package-managers&#34;&gt;Package Managers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In addition to any include or library paths you&#39;ll need to specify to tell the compiler where cpptrace was installed. The typical dependencies for cpptrace are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Compiler&lt;/th&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Dependencies&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gcc, clang, intel, etc.&lt;/td&gt; &#xA;   &lt;td&gt;Linux/macos/unix&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;-lcpptrace -ldwarf -lz -lzstd -ldl&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gcc&lt;/td&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;-lcpptrace -ldbghelp -ldwarf -lz -lzstd&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;msvc&lt;/td&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;cpptrace.lib dbghelp.lib&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;clang&lt;/td&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;-lcpptrace -ldbghelp&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Note: Newer libdwarf requires &lt;code&gt;-lzstd&lt;/code&gt;, older libdwarf does not.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] If you are linking statically, you will additionally need to specify &lt;code&gt;-DCPPTRACE_STATIC_DEFINE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Dependencies may differ if different back-ends are manually selected.&lt;/p&gt; &#xA;&lt;h2&gt;Installation Without Package Managers or FetchContent&lt;/h2&gt; &#xA;&lt;p&gt;Some users may prefer, or need to, to install cpptrace without package managers or fetchcontent (e.g. if their system does not have internet access). Below are instructions for how to install libdwarf and cpptrace.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Installation Without Package Managers or FetchContent&lt;/summary&gt; &#xA; &lt;p&gt;Here is an example for how to build cpptrace and libdwarf. &lt;code&gt;~/scratch/cpptrace-test&lt;/code&gt; is used as a working directory and the libraries are installed to &lt;code&gt;~/scratch/cpptrace-test/resources&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p ~/scratch/cpptrace-test/resources&#xA;&#xA;cd ~/scratch/cpptrace-test&#xA;git clone https://github.com/facebook/zstd.git&#xA;cd zstd&#xA;git checkout 63779c798237346c2b245c546c40b72a5a5913fe&#xA;cd build/cmake&#xA;mkdir build&#xA;cd build&#xA;cmake .. -DCMAKE_INSTALL_PREFIX=~/scratch/cpptrace-test/resources -DZSTD_BUILD_PROGRAMS=On -DZSTD_BUILD_CONTRIB=On -DZSTD_BUILD_TESTS=On -DZSTD_BUILD_STATIC=On -DZSTD_BUILD_SHARED=On -DZSTD_LEGACY_SUPPORT=On&#xA;make -j&#xA;make install&#xA;&#xA;cd ~/scratch/cpptrace-test&#xA;git clone https://github.com/jeremy-rifkin/libdwarf-lite.git&#xA;cd libdwarf-lite&#xA;git checkout fe09ca800b988e2ff21225ac5e7468ceade2a30e&#xA;mkdir build&#xA;cd build&#xA;cmake .. -DPIC_ALWAYS=On -DBUILD_DWARFDUMP=Off -DCMAKE_PREFIX_PATH=~/scratch/cpptrace-test/resources -DCMAKE_INSTALL_PREFIX=~/scratch/cpptrace-test/resources&#xA;make -j&#xA;make install&#xA;&#xA;cd ~/scratch/cpptrace-test&#xA;git clone https://github.com/jeremy-rifkin/cpptrace.git&#xA;cd cpptrace&#xA;git checkout v0.8.3&#xA;mkdir build&#xA;cd build&#xA;cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=On -DCPPTRACE_USE_EXTERNAL_LIBDWARF=On -DCMAKE_PREFIX_PATH=~/scratch/cpptrace-test/resources -DCMAKE_INSTALL_PREFIX=~/scratch/cpptrace-test/resources&#xA;make -j&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The &lt;code&gt;~/scratch/cpptrace-test/resources&lt;/code&gt; directory also serves as a bundle you can ship with all the installed files for cpptrace and its dependencies.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Package Managers&lt;/h2&gt; &#xA;&lt;h3&gt;Conan&lt;/h3&gt; &#xA;&lt;p&gt;Cpptrace is available through conan at &lt;a href=&#34;https://conan.io/center/recipes/cpptrace&#34;&gt;https://conan.io/center/recipes/cpptrace&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[requires]&#xA;cpptrace/0.8.3&#xA;[generators]&#xA;CMakeDeps&#xA;CMakeToolchain&#xA;[layout]&#xA;cmake_layout&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# ...&#xA;find_package(cpptrace REQUIRED)&#xA;# ...&#xA;target_link_libraries(YOUR_TARGET cpptrace::cpptrace)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Vcpkg&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;vcpkg install cpptrace&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;find_package(cpptrace CONFIG REQUIRED)&#xA;target_link_libraries(main PRIVATE cpptrace::cpptrace)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Platform Logistics&lt;/h1&gt; &#xA;&lt;p&gt;Windows and macOS require a little extra work to get everything in the right place.&lt;/p&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;Copying the library &lt;code&gt;.dll&lt;/code&gt; on Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# Copy the cpptrace.dll on windows to the same directory as the executable for your_target.&#xA;# Not required if static linking.&#xA;if(WIN32)&#xA;  add_custom_command(&#xA;    TARGET your_target POST_BUILD&#xA;    COMMAND ${CMAKE_COMMAND} -E copy_if_different&#xA;    $&amp;lt;TARGET_FILE:cpptrace::cpptrace&amp;gt;&#xA;    $&amp;lt;TARGET_FILE_DIR:your_target&amp;gt;&#xA;  )&#xA;endif()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;macOS&lt;/h2&gt; &#xA;&lt;p&gt;On macOS, it is recommended to generate a &lt;code&gt;dSYM&lt;/code&gt; file containing debug information for your program. This is not required as cpptrace makes a good effort at finding and reading the debug information without this, but having a &lt;code&gt;dSYM&lt;/code&gt; file is the most robust method.&lt;/p&gt; &#xA;&lt;p&gt;When using Xcode with CMake, this can be done with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;set_target_properties(your_target PROPERTIES XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT &#34;dwarf-with-dsym&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Outside of Xcode, this can be done with &lt;code&gt;dsymutil yourbinary&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# Create a .dSYM file on macOS&#xA;if(APPLE)&#xA;  add_custom_command(&#xA;    TARGET your_target&#xA;    POST_BUILD&#xA;    COMMAND dsymutil $&amp;lt;TARGET_FILE:your_target&amp;gt;&#xA;  )&#xA;endif()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Library Back-Ends&lt;/h1&gt; &#xA;&lt;p&gt;Cpptrace supports a number of back-ends to produce stack traces. Stack traces are produced in roughly three steps: Unwinding, symbol resolution, and demangling.&lt;/p&gt; &#xA;&lt;p&gt;The library&#39;s CMake automatically configures itself for what your system supports. The ideal configuration is as follows:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Unwinding&lt;/th&gt; &#xA;   &lt;th&gt;Symbols&lt;/th&gt; &#xA;   &lt;th&gt;Demangling&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Linux&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;_Unwind&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;libdwarf&lt;/td&gt; &#xA;   &lt;td&gt;cxxabi.h&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MacOS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;_Unwind&lt;/code&gt; for gcc, execinfo.h for clang and apple clang&lt;/td&gt; &#xA;   &lt;td&gt;libdwarf&lt;/td&gt; &#xA;   &lt;td&gt;cxxabi.h&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;StackWalk64&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;dbghelp&lt;/td&gt; &#xA;   &lt;td&gt;No demangling needed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MinGW&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;StackWalk64&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;libdwarf + dbghelp&lt;/td&gt; &#xA;   &lt;td&gt;cxxabi.h&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Support for these back-ends is the main development focus and they should work well. If you want to use a different back-end such as addr2line, for example, you can configure the library to do so.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Unwinding&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;CMake config&lt;/th&gt; &#xA;   &lt;th&gt;Platforms&lt;/th&gt; &#xA;   &lt;th&gt;Info&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libgcc unwind&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_UNWIND&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Frames are captured with libgcc&#39;s &lt;code&gt;_Unwind_Backtrace&lt;/code&gt;, which currently produces the most accurate stack traces on gcc/clang/mingw. Libgcc is often linked by default, and llvm has something equivalent.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;execinfo.h&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_EXECINFO&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos&lt;/td&gt; &#xA;   &lt;td&gt;Frames are captured with &lt;code&gt;execinfo.h&lt;/code&gt;&#39;s &lt;code&gt;backtrace&lt;/code&gt;, part of libc on linux/unix systems.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;winapi&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_WINAPI&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;windows, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Frames are captured with &lt;code&gt;CaptureStackBackTrace&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbghelp&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_DBGHELP&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;windows, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Frames are captured with &lt;code&gt;StackWalk64&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libunwind&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_LIBUNWIND&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos, windows, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Frames are captured with &lt;a href=&#34;https://github.com/libunwind/libunwind&#34;&gt;libunwind&lt;/a&gt;. &lt;strong&gt;Note:&lt;/strong&gt; This is the only back-end that requires a library to be installed by the user, and a &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; may also be needed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_NOTHING&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;all&lt;/td&gt; &#xA;   &lt;td&gt;Unwinding is not done, stack traces will be empty.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Some back-ends (execinfo and &lt;code&gt;CaptureStackBackTrace&lt;/code&gt;) require a fixed buffer has to be created to read addresses into while unwinding. By default the buffer can hold addresses for 400 frames (beyond the &lt;code&gt;skip&lt;/code&gt; frames). This is configurable with &lt;code&gt;CPPTRACE_HARD_MAX_FRAMES&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Symbol resolution&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;CMake config&lt;/th&gt; &#xA;   &lt;th&gt;Platforms&lt;/th&gt; &#xA;   &lt;th&gt;Info&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libdwarf&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Libdwarf is the preferred method for symbol resolution for cpptrace. Cpptrace will get it via FetchContent or find_package depending on &lt;code&gt;CPPTRACE_USE_EXTERNAL_LIBDWARF&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbghelp&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_DBGHELP&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;windows&lt;/td&gt; &#xA;   &lt;td&gt;Dbghelp.h is the preferred method for symbol resolution on windows under msvc/clang and is supported on all windows machines.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libbacktrace&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBBACKTRACE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos*, mingw*&lt;/td&gt; &#xA;   &lt;td&gt;Libbacktrace is already installed on most systems or available through the compiler directly. For clang you must specify the absolute path to &lt;code&gt;backtrace.h&lt;/code&gt; using &lt;code&gt;CPPTRACE_BACKTRACE_PATH&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;addr2line&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_ADDR2LINE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Symbols are resolved by invoking &lt;code&gt;addr2line&lt;/code&gt; (or &lt;code&gt;atos&lt;/code&gt; on mac) via &lt;code&gt;fork()&lt;/code&gt; (on linux/unix, and &lt;code&gt;popen&lt;/code&gt; under mingw).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;libdl&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBDL&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;linux, macos&lt;/td&gt; &#xA;   &lt;td&gt;Libdl uses dynamic export information. Compiling with &lt;code&gt;-rdynamic&lt;/code&gt; is needed for symbol information to be retrievable. Line numbers won&#39;t be retrievable.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_NOTHING&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;all&lt;/td&gt; &#xA;   &lt;td&gt;No attempt is made to resolve symbols.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;*: Requires installation&lt;/p&gt; &#xA;&lt;p&gt;One back-end should be used. For MinGW &lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF&lt;/code&gt; and &lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_DBGHELP&lt;/code&gt; can be used in conjunction.&lt;/p&gt; &#xA;&lt;p&gt;Note for addr2line: By default cmake will resolve an absolute path to addr2line to bake into the library. This path can be configured with &lt;code&gt;CPPTRACE_ADDR2LINE_PATH&lt;/code&gt;, or &lt;code&gt;CPPTRACE_ADDR2LINE_SEARCH_SYSTEM_PATH&lt;/code&gt; can be used to have the library search the system path for &lt;code&gt;addr2line&lt;/code&gt; at runtime. This is not the default to prevent against path injection attacks.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Demangling&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Lastly, depending on other back-ends used a demangler back-end may be needed.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;CMake config&lt;/th&gt; &#xA;   &lt;th&gt;Platforms&lt;/th&gt; &#xA;   &lt;th&gt;Info&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;cxxabi.h&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_DEMANGLE_WITH_CXXABI&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Linux, macos, mingw&lt;/td&gt; &#xA;   &lt;td&gt;Should be available everywhere other than &lt;a href=&#34;https://godbolt.org/z/93ca9rcdz&#34;&gt;msvc&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbghelp.h&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_DEMANGLE_WITH_WINAPI&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Windows&lt;/td&gt; &#xA;   &lt;td&gt;Demangle with &lt;code&gt;UnDecorateSymbolName&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;CPPTRACE_DEMANGLE_WITH_NOTHING&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;all&lt;/td&gt; &#xA;   &lt;td&gt;Don&#39;t attempt to do anything beyond what the symbol resolution back-end does.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;More?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are plenty more libraries that can be used for unwinding, parsing debug information, and demangling. In the future more back-ends can be added. Ideally this library can &#34;just work&#34; on systems, without additional installation work.&lt;/p&gt; &#xA;&lt;h2&gt;Summary of Library Configurations&lt;/h2&gt; &#xA;&lt;p&gt;Summary of all library configuration options:&lt;/p&gt; &#xA;&lt;p&gt;Back-ends:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_DBGHELP=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBBACKTRACE=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_ADDR2LINE=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_LIBDL=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_GET_SYMBOLS_WITH_NOTHING=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_UNWIND=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_LIBUNWIND=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_EXECINFO=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_WINAPI=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_DBGHELP=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_UNWIND_WITH_NOTHING=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_DEMANGLE_WITH_CXXABI=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_DEMANGLE_WITH_WINAPI=On/Off&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_DEMANGLE_WITH_NOTHING=On/Off&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Back-end configuration:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_BACKTRACE_PATH=&amp;lt;string&amp;gt;&lt;/code&gt;: Path to libbacktrace backtrace.h, needed when compiling with clang/&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_HARD_MAX_FRAMES=&amp;lt;number&amp;gt;&lt;/code&gt;: Some back-ends write to a fixed-size buffer. This is the size of that buffer. Default is &lt;code&gt;400&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_ADDR2LINE_PATH=&amp;lt;string&amp;gt;&lt;/code&gt;: Specify the absolute path to the addr2line binary for cpptrace to invoke. By default the config script will search for a binary and use that absolute path (this is to prevent against path injection).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_ADDR2LINE_SEARCH_SYSTEM_PATH=On/Off&lt;/code&gt;: Specifies whether cpptrace should let the system search the PATH environment variable directories for the binary.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Other useful configurations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_BUILD_SHARED=On/Off&lt;/code&gt;: Override for &lt;code&gt;BUILD_SHARED_LIBS&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_INCLUDES_WITH_SYSTEM=On/Off&lt;/code&gt;: Marks cpptrace headers as &lt;code&gt;SYSTEM&lt;/code&gt; which will hide any warnings that aren&#39;t the fault of your project. Defaults to On.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_INSTALL_CMAKEDIR&lt;/code&gt;: Override for the installation path for the cmake configs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_USE_EXTERNAL_LIBDWARF=On/Off&lt;/code&gt;: Get libdwarf from &lt;code&gt;find_package&lt;/code&gt; rather than &lt;code&gt;FetchContent&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_POSITION_INDEPENDENT_CODE=On/Off&lt;/code&gt;: Compile the library as a position independent code (PIE). Defaults to On.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_STD_FORMAT=On/Off&lt;/code&gt;: Control inclusion of &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; and provision of &lt;code&gt;std::formatter&lt;/code&gt; specializations by cpptrace.hpp. This can also be controlled with the macro &lt;code&gt;CPPTRACE_NO_STD_FORMAT&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Testing:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_BUILD_TESTING&lt;/code&gt; Build small demo and test program&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CPPTRACE_BUILD_TEST_RDYNAMIC&lt;/code&gt; Use &lt;code&gt;-rdynamic&lt;/code&gt; when compiling the test program&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Testing Methodology&lt;/h1&gt; &#xA;&lt;p&gt;Cpptrace currently uses integration and functional testing, building and running under every combination of back-end options. The implementation is based on &lt;a href=&#34;https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs&#34;&gt;github actions matrices&lt;/a&gt; and driven by python scripts located in the &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/ci/&#34;&gt;&lt;code&gt;ci/&lt;/code&gt;&lt;/a&gt; folder. Testing used to be done by github actions matrices directly, however, launching hundreds of two second jobs was extremely inefficient. Test outputs are compared against expected outputs located in &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/test/expected/&#34;&gt;&lt;code&gt;test/expected/&lt;/code&gt;&lt;/a&gt;. Stack trace addresses may point to the address after an instruction depending on the unwinding back-end, and the python script will check for an exact or near-match accordingly.&lt;/p&gt; &#xA;&lt;h1&gt;Notes About the Library&lt;/h1&gt; &#xA;&lt;p&gt;For the most part I&#39;m happy with the state of the library. But I&#39;m sure that there is room for improvement and issues will exist. If you encounter any issue, please let me know! If you find any pain-points in the library, please let me know that too.&lt;/p&gt; &#xA;&lt;p&gt;A note about performance: For handling of DWARF symbols there is a lot of room to explore for performance optimizations and time-memory tradeoffs. If you find the current implementation is either slow or using too much memory, I&#39;d be happy to explore some of these options.&lt;/p&gt; &#xA;&lt;p&gt;A couple things I&#39;d like to improve in the future:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;On Windows when collecting symbols with dbghelp (msvc/clang) parameter types are almost perfect but due to limitations in dbghelp the library cannot accurately show const and volatile qualifiers or rvalue references (these appear as pointers).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;h2&gt;What about C++23 &lt;code&gt;&amp;lt;stacktrace&amp;gt;&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;Some day C++23&#39;s &lt;code&gt;&amp;lt;stacktrace&amp;gt;&lt;/code&gt; will be ubiquitous. And maybe one day the msvc implementation will be acceptable. The original motivation for cpptrace was to support projects using older C++ standards and as the library has grown its functionality has extended beyond the standard library&#39;s implementation.&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace provides functionality beyond what the standard library provides and what implementations provide, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Walking inlined function calls&lt;/li&gt; &#xA; &lt;li&gt;Providing a lightweight interface for &#34;raw traces&#34;&lt;/li&gt; &#xA; &lt;li&gt;Resolving function parameter types&lt;/li&gt; &#xA; &lt;li&gt;Providing traced exception objects&lt;/li&gt; &#xA; &lt;li&gt;Providing an API for signal-safe stacktrace generation&lt;/li&gt; &#xA; &lt;li&gt;Providing a way to retrieve stack traces from arbitrary exceptions, not just special cpptrace traced exception objects. This is a feature coming to C++26, but cpptrace provides a solution for C++11.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What does cpptrace have over other C++ stacktrace libraries?&lt;/h2&gt; &#xA;&lt;p&gt;Other C++ stacktrace libraries, such as boost stacktrace and backward-cpp, fall short when it comes to portability and ease of use. In testing, I found neither to provide adaquate coverage of various environments. Even when they can be made to work in an environment they require manual configuration from the end-user, possibly requiring manual installation of third-party dependencies. This is a highly undesirable burden to impose on users, especially when it is for a software package which just provides diagnostics as opposed to core functionality. Additionally, cpptrace provides support for resolving inlined calls by default for DWARF symbols (boost does not do this, backward-cpp can do this but only for some back-ends), better support for resolving full function signatures, and nicer API, among other features.&lt;/p&gt; &#xA;&lt;h2&gt;I&#39;m getting undefined standard library symbols like &lt;code&gt;std::__1::basic_string&lt;/code&gt; on MacOS&lt;/h2&gt; &#xA;&lt;p&gt;If you see a linker error along the lines of the following on MacOS then it&#39;s highly likely you are mixing standard library ABIs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Undefined symbols for architecture arm64:&#xA;  &#34;std::__1::basic_string&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt;, std::__1::allocator&amp;lt;char&amp;gt; &amp;gt;::find(char, unsigned long) const&#34;, referenced from:&#xA;      cpptrace::detail::demangle(std::__1::basic_string&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt;, std::__1::allocator&amp;lt;char&amp;gt; &amp;gt; const&amp;amp;, bool) in libcpptrace.a(demangle_with_cxxabi.cpp.o)&#xA;      cpptrace::detail::snippet_manager::build_line_table() in libcpptrace.a(snippet.cpp.o)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can happen when using apple clang to compile cpptrace and gcc to compile your code, or vice versa. The reason is that apple clang defaults to libc++ and gcc defaults to libstdc++ and these two standard library implementations are not ABI-compatible. To resolve this, ensure you are compiling both cpptrace and your code with the same standard library by either using the same compiler for both or using &lt;code&gt;-stdlib=libc++&lt;/code&gt;/&lt;code&gt;-stdlib=libstdc++&lt;/code&gt; to control which standard library is used.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;I&#39;m grateful for the help I&#39;ve received with this library and I welcome contributions! For information on contributing please refer to &lt;a href=&#34;https://raw.githubusercontent.com/jeremy-rifkin/cpptrace/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;This library is under the MIT license.&lt;/p&gt; &#xA;&lt;p&gt;Cpptrace uses libdwarf on linux, macos, and mingw/cygwin unless configured to use something else. If this library is statically linked with libdwarf then the library&#39;s binary will itself be LGPL.&lt;/p&gt;</summary>
  </entry>
</feed>