<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-04T01:33:40Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mrousavy/react-native-mmkv</title>
    <updated>2023-06-04T01:33:40Z</updated>
    <id>tag:github.com,2023-06-04:/mrousavy/react-native-mmkv</id>
    <link href="https://github.com/mrousavy/react-native-mmkv" rel="alternate"></link>
    <summary type="html">&lt;p&gt;‚ö°Ô∏è The fastest key/value storage for React Native. ~30x faster than AsyncStorage!&lt;/p&gt;&lt;hr&gt;&lt;a href=&#34;https://margelo.io&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/img/banner.svg?sanitize=true&#34; width=&#34;100%&#34;&gt; &lt;/a&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1 align=&#34;center&#34;&gt;MMKV&lt;/h1&gt; &#xA; &lt;h3 align=&#34;center&#34;&gt;The fastest key/value storage for React Native.&lt;/h3&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a align=&#34;center&#34; href=&#34;https://github.com/mrousavy?tab=followers&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/followers/mrousavy?label=Follow%20%40mrousavy&amp;amp;style=social&#34;&gt; &lt;/a&gt; &#xA; &lt;br&gt; &#xA; &lt;a align=&#34;center&#34; href=&#34;https://twitter.com/mrousavy&#34;&gt; &lt;img src=&#34;https://img.shields.io/twitter/follow/mrousavy?label=Follow%20%40mrousavy&amp;amp;style=social&#34;&gt; &lt;/a&gt; &#xA; &lt;br&gt; &#xA; &lt;a href=&#34;https://github.com/sponsors/mrousavy&#34;&gt; &lt;img align=&#34;right&#34; width=&#34;160&#34; alt=&#34;This library helped you? Consider sponsoring!&#34; src=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/.github/funding-octocat.svg?sanitize=true&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;MMKV&lt;/strong&gt; is an efficient, small mobile key-value storage framework developed by WeChat. See &lt;a href=&#34;https://github.com/Tencent/MMKV&#34;&gt;Tencent/MMKV&lt;/a&gt; for more information&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;react-native-mmkv&lt;/strong&gt; is a library that allows you to easily use &lt;strong&gt;MMKV&lt;/strong&gt; inside your React Native applications. It provides fast and direct bindings to the native C++ library which are accessible through a simple JS API.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Get&lt;/strong&gt; and &lt;strong&gt;set&lt;/strong&gt; strings, booleans and numbers&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fully synchronous&lt;/strong&gt; calls, no async/await, no Promises, no Bridge.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Encryption&lt;/strong&gt; support (secure storage)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multiple instances&lt;/strong&gt; support (separate user-data with global data)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Customize storage location&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;High performance&lt;/strong&gt; because everything is &lt;strong&gt;written in C++&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;~30x faster than AsyncStorage&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Uses &lt;a href=&#34;https://github.com/react-native-community/discussions-and-proposals/issues/91&#34;&gt;&lt;strong&gt;JSI&lt;/strong&gt;&lt;/a&gt; instead of the &#34;old&#34; Bridge&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;iOS&lt;/strong&gt;, &lt;strong&gt;Android&lt;/strong&gt; and &lt;strong&gt;Web&lt;/strong&gt; support&lt;/li&gt; &#xA; &lt;li&gt;Easy to use &lt;strong&gt;React Hooks&lt;/strong&gt; API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;div align=&#34;right&#34;&gt; &#xA; &lt;a href=&#34;https://getstream.io/chat/react-native-chat/tutorial/?utm_source=Github&amp;amp;utm_medium=Github_Repo_Content_Ad&amp;amp;utm_content=Developer&amp;amp;utm_campaign=Github_Jan2022_ReactNative&amp;amp;utm_term=react-native-mmkv&#34;&gt; &lt;img align=&#34;right&#34; src=&#34;https://theme.zdassets.com/theme_assets/9442057/efc3820e436f9150bc8cf34267fff4df052a1f9c.png&#34; height=&#34;40&#34;&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;react-native-mmkv is sponsored by &lt;strong&gt;getstream.io&lt;/strong&gt;. &lt;br&gt; &lt;a href=&#34;https://getstream.io/chat/react-native-chat/tutorial/?utm_source=Github&amp;amp;utm_medium=Github_Repo_Content_Ad&amp;amp;utm_content=Developer&amp;amp;utm_campaign=Github_Jan2022_ReactNative&amp;amp;utm_term=react-native-mmkv&#34;&gt;Try the React Native Chat tutorial üí¨&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Benchmark&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mrousavy/StorageBenchmark&#34;&gt;StorageBenchmark&lt;/a&gt; compares popular storage libraries against each other by reading a value from storage for 1000 times:&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://github.com/mrousavy/StorageBenchmark&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/img/benchmark_1000_get.png&#34;&gt; &lt;/a&gt; &#xA; &lt;p&gt; &lt;b&gt;MMKV vs other storage libraries&lt;/b&gt;: Reading a value from Storage 1000 times. &lt;br&gt; Measured in milliseconds on an iPhone 11 Pro, lower is better. &lt;br&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;React Native&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yarn add react-native-mmkv&#xA;cd ios &amp;amp;&amp;amp; pod install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Expo&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npx expo install react-native-mmkv&#xA;npx expo prebuild&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Create a new instance&lt;/h3&gt; &#xA;&lt;p&gt;To create a new instance of the MMKV storage, use the &lt;code&gt;MMKV&lt;/code&gt; constructor. It is recommended that you re-use this instance throughout your entire app instead of creating a new instance each time, so &lt;code&gt;export&lt;/code&gt; the &lt;code&gt;storage&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;h4&gt;Default&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { MMKV } from &#39;react-native-mmkv&#39;&#xA;&#xA;export const storage = new MMKV()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates a new storage instance using the default MMKV storage ID (&lt;code&gt;mmkv.default&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Customize&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { MMKV } from &#39;react-native-mmkv&#39;&#xA;&#xA;export const storage = new MMKV({&#xA;  id: `user-${userId}-storage`,&#xA;  path: `${USER_DIRECTORY}/storage`,&#xA;  encryptionKey: &#39;hunter2&#39;&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates a new storage instance using a custom MMKV storage ID. By using a custom storage ID, your storage is separated from the default MMKV storage of your app.&lt;/p&gt; &#xA;&lt;p&gt;The following values can be configured:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;id&lt;/code&gt;: The MMKV instance&#39;s ID. If you want to use multiple instances, use different IDs. For example, you can separate the global app&#39;s storage and a logged-in user&#39;s storage. (required if &lt;code&gt;path&lt;/code&gt; or &lt;code&gt;encryptionKey&lt;/code&gt; fields are specified, otherwise defaults to: &lt;code&gt;&#39;mmkv.default&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: The MMKV instance&#39;s root path. By default, MMKV stores file inside &lt;code&gt;$(Documents)/mmkv/&lt;/code&gt;. You can customize MMKV&#39;s root directory on MMKV initialization (documentation: &lt;a href=&#34;https://github.com/Tencent/MMKV/wiki/iOS_advance#customize-location&#34;&gt;iOS&lt;/a&gt; / &lt;a href=&#34;https://github.com/Tencent/MMKV/wiki/android_advance#customize-location&#34;&gt;Android&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;encryptionKey&lt;/code&gt;: The MMKV instance&#39;s encryption/decryption key. By default, MMKV stores all key-values in plain text on file, relying on iOS&#39;s/Android&#39;s sandbox to make sure the file is encrypted. Should you worry about information leaking, you can choose to encrypt MMKV. (documentation: &lt;a href=&#34;https://github.com/Tencent/MMKV/wiki/iOS_advance#encryption&#34;&gt;iOS&lt;/a&gt; / &lt;a href=&#34;https://github.com/Tencent/MMKV/wiki/android_advance#encryption&#34;&gt;Android&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Set&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;storage.set(&#39;user.name&#39;, &#39;Marc&#39;)&#xA;storage.set(&#39;user.age&#39;, 21)&#xA;storage.set(&#39;is-mmkv-fast-asf&#39;, true)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Get&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const username = storage.getString(&#39;user.name&#39;) // &#39;Marc&#39;&#xA;const age = storage.getNumber(&#39;user.age&#39;) // 21&#xA;const isMmkvFastAsf = storage.getBoolean(&#39;is-mmkv-fast-asf&#39;) // true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Keys&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// checking if a specific key exists&#xA;const hasUsername = storage.contains(&#39;user.name&#39;)&#xA;&#xA;// getting all keys&#xA;const keys = storage.getAllKeys() // [&#39;user.name&#39;, &#39;user.age&#39;, &#39;is-mmkv-fast-asf&#39;]&#xA;&#xA;// delete a specific key + value&#xA;storage.delete(&#39;user.name&#39;)&#xA;&#xA;// delete all keys&#xA;storage.clearAll()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Objects&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const user = {&#xA;  username: &#39;Marc&#39;,&#xA;  age: 21&#xA;}&#xA;&#xA;// Serialize the object into a JSON string&#xA;storage.set(&#39;user&#39;, JSON.stringify(user))&#xA;&#xA;// Deserialize the JSON string into an object&#xA;const jsonUser = storage.getString(&#39;user&#39;) // { &#39;username&#39;: &#39;Marc&#39;, &#39;age&#39;: 21 }&#xA;const userObject = JSON.parse(jsonUser)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Encryption&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// encrypt all data with a private key&#xA;storage.recrypt(&#39;hunter2&#39;)&#xA;&#xA;// remove encryption&#xA;storage.recrypt(undefined)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Buffers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;storage.set(&#39;someToken&#39;, new Uint8Array([1, 100, 255]))&#xA;const buffer = storage.getBuffer(&#39;someToken&#39;)&#xA;console.log(buffer) // [1, 100, 255]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing with Jest&lt;/h2&gt; &#xA;&lt;p&gt;A mocked MMKV instance is automatically used when testing with Jest, so you will be able to use &lt;code&gt;new MMKV()&lt;/code&gt; as per normal in your tests. Refer to &lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/example/test/MMKV.test.ts&#34;&gt;example/test/MMKV.test.ts&lt;/a&gt; for an example.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/HOOKS.md&#34;&gt;Hooks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/LISTENERS.md&#34;&gt;Value-change Listeners&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/MIGRATE_FROM_ASYNC_STORAGE.md&#34;&gt;Migrate from AsyncStorage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_REDUX.md&#34;&gt;Using MMKV with redux-persist&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_RECOIL.md&#34;&gt;Using MMKV with recoil&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_MOBX.md&#34;&gt;Using MMKV with mobx-persist-storage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_MOBXPERSIST.md&#34;&gt;Using MMKV with mobx-persist&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_ZUSTAND_PERSIST_MIDDLEWARE.md&#34;&gt;Using MMKV with zustand persist-middleware&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_JOTAI.md&#34;&gt;Using MMKV with jotai&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/docs/WRAPPER_REACT_QUERY.md&#34;&gt;Using MMKV with react-query&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mrousavy/react-native-mmkv/issues/100#issuecomment-886477361&#34;&gt;How is this library different from &lt;strong&gt;react-native-mmkv-storage&lt;/strong&gt;?&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;LocalStorage and In-Memory Storage (Web)&lt;/h2&gt; &#xA;&lt;p&gt;If a user chooses to disable LocalStorage in their browser, the library will automatically provide a limited in-memory storage as an alternative. However, this in-memory storage won&#39;t persist data, and users may experience data loss if they refresh the page or close their browser. To optimize user experience, consider implementing a suitable solution within your app to address this scenario.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;As the library uses JSI for synchronous native methods access, remote debugging (e.g. with Chrome) is no longer possible. Instead, you should use &lt;a href=&#34;https://fbflipper.com&#34;&gt;Flipper&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Debugging&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;a href=&#34;https://github.com/muchobien/flipper-plugin-react-native-mmkv&#34;&gt;flipper-plugin-react-native-mmkv&lt;/a&gt; to debug your MMKV storage using Flipper. You can also simply &lt;code&gt;console.log&lt;/code&gt; an MMKV instance.&lt;/p&gt; &#xA;&lt;h2&gt;Adopting at scale&lt;/h2&gt; &#xA;&lt;p&gt;react-native-mmkv is provided &lt;em&gt;as is&lt;/em&gt;, I work on it in my free time.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;re integrating react-native-mmkv in a production app, consider &lt;a href=&#34;https://github.com/sponsors/mrousavy&#34;&gt;funding this project&lt;/a&gt; and &lt;a href=&#34;mailto:me@mrousavy.com?subject=Adopting react-native-mmkv at scale&#34;&gt;contact me&lt;/a&gt; to receive premium enterprise support, help with issues, prioritize bugfixes, request features, help at integrating react-native-mmkv, and more.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/mrousavy/react-native-mmkv/master/CONTRIBUTING.md&#34;&gt;contributing guide&lt;/a&gt; to learn how to contribute to the repository and the development workflow.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jarro2783/cxxopts</title>
    <updated>2023-06-04T01:33:40Z</updated>
    <id>tag:github.com,2023-06-04:/jarro2783/cxxopts</id>
    <link href="https://github.com/jarro2783/cxxopts" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight C++ command line option parser&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/jarro2783/cxxopts&#34;&gt;&lt;img src=&#34;https://travis-ci.org/jarro2783/cxxopts.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Release versions&lt;/h1&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;master&lt;/code&gt; is generally a work in progress, and you probably want to use a tagged release version.&lt;/p&gt; &#xA;&lt;h2&gt;Version 3 breaking changes&lt;/h2&gt; &#xA;&lt;p&gt;If you have used version 2, there are a couple of breaking changes in version 3 that you should be aware of. If you are new to &lt;code&gt;cxxopts&lt;/code&gt; you can skip this section.&lt;/p&gt; &#xA;&lt;p&gt;The parser no longer modifies its arguments, so you can pass a const &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; and expect them not to be changed.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ParseResult&lt;/code&gt; object no longer depends on the parser. So it can be returned from a scope outside the parser and still work. Now that the inputs are not modified, &lt;code&gt;ParseResult&lt;/code&gt; stores a list of the unmatched arguments. These are retrieved like follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto result = options.parse(argc, argv);&#xA;result.unmatched(); // get the unmatched arguments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Quick start&lt;/h1&gt; &#xA;&lt;p&gt;This is a lightweight C++ option parser library, supporting the standard GNU style syntax for options.&lt;/p&gt; &#xA;&lt;p&gt;Options can be given as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--long&#xA;--long=argument&#xA;--long argument&#xA;-a&#xA;-ab&#xA;-abc argument&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where c takes an argument, but a and b do not.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, anything after &lt;code&gt;--&lt;/code&gt; will be parsed as a positional argument.&lt;/p&gt; &#xA;&lt;h2&gt;Basics&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cxxopts.hpp&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a &lt;code&gt;cxxopts::Options&lt;/code&gt; instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cxxopts::Options options(&#34;MyProgram&#34;, &#34;One line description of MyProgram&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use &lt;code&gt;add_options&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;options.add_options()&#xA;  (&#34;d,debug&#34;, &#34;Enable debugging&#34;) // a bool parameter&#xA;  (&#34;i,integer&#34;, &#34;Int param&#34;, cxxopts::value&amp;lt;int&amp;gt;())&#xA;  (&#34;f,file&#34;, &#34;File name&#34;, cxxopts::value&amp;lt;std::string&amp;gt;())&#xA;  (&#34;v,verbose&#34;, &#34;Verbose output&#34;, cxxopts::value&amp;lt;bool&amp;gt;()-&amp;gt;default_value(&#34;false&#34;))&#xA;  ;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Options are declared with a long and an optional short option. A description must be provided. The third argument is the value, if omitted it is boolean. Any type can be given as long as it can be parsed, with operator&amp;gt;&amp;gt;.&lt;/p&gt; &#xA;&lt;p&gt;To parse the command line do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto result = options.parse(argc, argv);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To retrieve an option use &lt;code&gt;result.count(&#34;option&#34;)&lt;/code&gt; to get the number of times it appeared, and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;result[&#34;opt&#34;].as&amp;lt;type&amp;gt;()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to get its value. If &#34;opt&#34; doesn&#39;t exist, or isn&#39;t of the right type, then an exception will be thrown.&lt;/p&gt; &#xA;&lt;p&gt;Note that the result of &lt;code&gt;options.parse&lt;/code&gt; should only be used as long as the &lt;code&gt;options&lt;/code&gt; object that created it is in scope.&lt;/p&gt; &#xA;&lt;h2&gt;Unrecognised arguments&lt;/h2&gt; &#xA;&lt;p&gt;You can allow unrecognised arguments to be skipped. This applies to both positional arguments that are not parsed into another option, and &lt;code&gt;--&lt;/code&gt; arguments that do not match an argument that you specify. This is done by calling:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;options.allow_unrecognised_options();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and in the result object they are retrieved with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;result.unmatched()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Exceptions&lt;/h2&gt; &#xA;&lt;p&gt;Exceptional situations throw C++ exceptions. There are two types of exceptions: errors defining the options, and errors when parsing a list of arguments. All exceptions derive from &lt;code&gt;cxxopts::exceptions::exception&lt;/code&gt;. Errors defining options derive from &lt;code&gt;cxxopts::exceptions::specification&lt;/code&gt; and errors parsing arguments derive from &lt;code&gt;cxxopts::exceptions::parsing&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All exceptions define a &lt;code&gt;what()&lt;/code&gt; function to get a printable string explaining the error.&lt;/p&gt; &#xA;&lt;h2&gt;Help groups&lt;/h2&gt; &#xA;&lt;p&gt;Options can be placed into groups for the purposes of displaying help messages. To place options in a group, pass the group as a string to &lt;code&gt;add_options&lt;/code&gt;. Then, when displaying the help, pass the groups that you would like displayed as a vector to the &lt;code&gt;help&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h2&gt;Positional Arguments&lt;/h2&gt; &#xA;&lt;p&gt;Positional arguments are those given without a preceding flag and can be used alongside non-positional arguments. There may be multiple positional arguments, and the final positional argument may be a container type to hold a list of all remaining positionals.&lt;/p&gt; &#xA;&lt;p&gt;To set up positional arguments, first declare the options, then configure a set of those arguments as positional like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;options.add_options()&#xA;  (&#34;script&#34;, &#34;The script file to execute&#34;, cxxopts::value&amp;lt;std::string&amp;gt;())&#xA;  (&#34;server&#34;, &#34;The server to execute on&#34;, cxxopts::value&amp;lt;std::string&amp;gt;())&#xA;  (&#34;filenames&#34;, &#34;The filename(s) to process&#34;, cxxopts::value&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;());&#xA;&#xA;options.parse_positional({&#34;script&#34;, &#34;server&#34;, &#34;filenames&#34;});&#xA;&#xA;// Parse options the usual way&#xA;options.parse(argc, argv);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, parsing the following arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;my_script.py my_server.com file1.txt file2.txt file3.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will result in parsed arguments like the following table:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Field&lt;/th&gt; &#xA;   &lt;th&gt;Value&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;script&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;my_script.py&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;server&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;my_server.com&#34;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;filenames&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;{&#34;file1.txt&#34;, &#34;file2.txt&#34;, &#34;file3.txt&#34;}&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Default and implicit values&lt;/h2&gt; &#xA;&lt;p&gt;An option can be declared with a default or an implicit value, or both.&lt;/p&gt; &#xA;&lt;p&gt;A default value is the value that an option takes when it is not specified on the command line. The following specifies a default value for an option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cxxopts::value&amp;lt;std::string&amp;gt;()-&amp;gt;default_value(&#34;value&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An implicit value is the value that an option takes when it is given on the command line without an argument. The following specifies an implicit value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cxxopts::value&amp;lt;std::string&amp;gt;()-&amp;gt;implicit_value(&#34;implicit&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If an option had both, then not specifying it would give the value &lt;code&gt;&#34;value&#34;&lt;/code&gt;, writing it on the command line as &lt;code&gt;--option&lt;/code&gt; would give the value &lt;code&gt;&#34;implicit&#34;&lt;/code&gt;, and writing &lt;code&gt;--option=another&lt;/code&gt; would give it the value &lt;code&gt;&#34;another&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that the default and implicit value is always stored as a string, regardless of the type that you want to store it in. It will be parsed as though it was given on the command line.&lt;/p&gt; &#xA;&lt;p&gt;Default values are not counted by &lt;code&gt;Options::count&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Boolean values&lt;/h2&gt; &#xA;&lt;p&gt;Boolean options have a default implicit value of &lt;code&gt;&#34;true&#34;&lt;/code&gt;, which can be overridden. The effect is that writing &lt;code&gt;-o&lt;/code&gt; by itself will set option &lt;code&gt;o&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. However, they can also be written with various strings using &lt;code&gt;=value&lt;/code&gt;. There is no way to disambiguate positional arguments from the value following a boolean, so we have chosen that they will be positional arguments, and therefore, &lt;code&gt;-o false&lt;/code&gt; does not work.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; values&lt;/h2&gt; &#xA;&lt;p&gt;Parsing of list of values in form of an &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; is also supported, as long as &lt;code&gt;T&lt;/code&gt; can be parsed. To separate single values in a list the definition &lt;code&gt;CXXOPTS_VECTOR_DELIMITER&lt;/code&gt; is used, which is &#39;,&#39; by default. Ensure that you use no whitespaces between values because those would be interpreted as the next command line option. Example for a command line option that can be parsed as a &lt;code&gt;std::vector&amp;lt;double&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--my_list=1,-2.1,3,4.5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Options specified multiple times&lt;/h2&gt; &#xA;&lt;p&gt;The same option can be specified several times, with different arguments, which will all be recorded in order of appearance. An example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--use train --use bus --use ferry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;this is supported through the use of a vector of value for the option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;options.add_options()&#xA;  (&#34;use&#34;, &#34;Usable means of transport&#34;, cxxopts::value&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Custom help&lt;/h2&gt; &#xA;&lt;p&gt;The string after the program name on the first line of the help can be completely replaced by calling &lt;code&gt;options.custom_help&lt;/code&gt;. Note that you might also want to override the positional help by calling &lt;code&gt;options.positional_help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;Putting all together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char** argv)&#xA;{&#xA;    cxxopts::Options options(&#34;test&#34;, &#34;A brief description&#34;);&#xA;&#xA;    options.add_options()&#xA;        (&#34;b,bar&#34;, &#34;Param bar&#34;, cxxopts::value&amp;lt;std::string&amp;gt;())&#xA;        (&#34;d,debug&#34;, &#34;Enable debugging&#34;, cxxopts::value&amp;lt;bool&amp;gt;()-&amp;gt;default_value(&#34;false&#34;))&#xA;        (&#34;f,foo&#34;, &#34;Param foo&#34;, cxxopts::value&amp;lt;int&amp;gt;()-&amp;gt;default_value(&#34;10&#34;))&#xA;        (&#34;h,help&#34;, &#34;Print usage&#34;)&#xA;    ;&#xA;&#xA;    auto result = options.parse(argc, argv);&#xA;&#xA;    if (result.count(&#34;help&#34;))&#xA;    {&#xA;      std::cout &amp;lt;&amp;lt; options.help() &amp;lt;&amp;lt; std::endl;&#xA;      exit(0);&#xA;    }&#xA;    bool debug = result[&#34;debug&#34;].as&amp;lt;bool&amp;gt;();&#xA;    std::string bar;&#xA;    if (result.count(&#34;bar&#34;))&#xA;      bar = result[&#34;bar&#34;].as&amp;lt;std::string&amp;gt;();&#xA;    int foo = result[&#34;foo&#34;].as&amp;lt;int&amp;gt;();&#xA;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Linking&lt;/h1&gt; &#xA;&lt;p&gt;This is a header only library.&lt;/p&gt; &#xA;&lt;h1&gt;Requirements&lt;/h1&gt; &#xA;&lt;p&gt;The only build requirement is a C++ compiler that supports C++11 features such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;regex&lt;/li&gt; &#xA; &lt;li&gt;constexpr&lt;/li&gt; &#xA; &lt;li&gt;default constructors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;GCC &amp;gt;= 4.9 or clang &amp;gt;= 3.1 with libc++ are known to work.&lt;/p&gt; &#xA;&lt;p&gt;The following compilers are known not to work:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MSVC 2013&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>