<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-27T01:30:01Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ETLCPP/etl</title>
    <updated>2025-04-27T01:30:01Z</updated>
    <id>tag:github.com,2025-04-27:/ETLCPP/etl</id>
    <link href="https://github.com/ETLCPP/etl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Embedded Template Library&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Embedded Template Library (ETL)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/jwellbelove/etl&#34; alt=&#34;GitHub release (latest by date)&#34;&gt; &lt;a href=&#34;https://img.shields.io/github/release-date/jwellbelove/etl?color=%231182c3&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/release-date/jwellbelove/etl?color=%231182c3&#34; alt=&#34;Release date&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/C%2B%2B#Standardization&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/c%2B%2B-98/03/11/14/17/20-blue.svg?sanitize=true&#34; alt=&#34;Standard&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/contributors-anon/ETLCPP/etl&#34; alt=&#34;GitHub contributors&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/forks/ETLCPP/etl?style=flat&#34; alt=&#34;GitHub forks&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/stars/ETLCPP/etl?style=flat&#34; alt=&#34;GitHub Repo stars&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ETLCPP/etl/workflows/msvc/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://ci.appveyor.com/project/jwellbelove/etl/branch/master&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/b7jgecv7unqjw4u0/branch/master?svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/gcc-c++11.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/gcc-c++14.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/gcc-c++17.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/gcc-c++20.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/gcc-syntax-checks.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/clang-c++11.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/clang-c++14.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/clang-c++17.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/clang-c++20.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;img src=&#34;https://github.com/ETLCPP/etl/actions/workflows/clang-syntax-checks.yml/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.codacy.com/manual/jwellbelove/etl?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=ETLCPP/etl&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://api.codacy.com/project/badge/Grade/3c14cd918ccf40008d0bcd7b083d5946&#34; alt=&#34;Codacy Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.etlcpp.com/sponsor.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/static/v1?label=Sponsor&amp;amp;message=%E2%9D%A4&amp;amp;logo=GitHub&amp;amp;color=%23fe8e86&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.etlcpp.com/&#34;&gt;Project documentation&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;C++ is a great language to use for embedded applications and templates are a powerful aspect. The standard library can offer a great deal of well tested functionality, but there are some parts of the standard library that do not fit well with deterministic behaviour and limited resource requirements. These limitations usually preclude the use of dynamically allocated memory and containers with open ended sizes.&lt;/p&gt; &#xA;&lt;p&gt;What is needed is a template library where the user can declare the size, or maximum size of any object upfront. Most embedded compilers do not currently support the standard beyond C++ 03, therefore excluding the programmer from using the enhanced features of the later library.&lt;/p&gt; &#xA;&lt;p&gt;This is what the ETL attempts to achieve.&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;p&gt;The ETL is not designed to completely replace the STL, but complement it. Its design objective covers three areas.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create a set of containers where the size or maximum size is determined at compile time. These containers are direct equivalents of those supplied in the STL.&lt;/li&gt; &#xA; &lt;li&gt;Be compatible with C++ 03 but implement as many of the C++ 11/14/17/20 additions as possible.&lt;/li&gt; &#xA; &lt;li&gt;Add other useful components that are not present in the standard library.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The embedded template library has been designed for lower resource embedded applications. It contains a set of containers, algorithms and utilities, some of which emulate parts of the STL. There is no dynamic memory allocation. The library makes no use of the heap. All of the containers have a fixed capacity allowing all memory allocation to be determined at compile time. The library is intended for any compiler that supports C++98/03/11/14/17/20.&lt;/p&gt; &#xA;&lt;h2&gt;Main features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cross platform. This library is not specific to any processor type.&lt;/li&gt; &#xA; &lt;li&gt;No dynamic memory allocation&lt;/li&gt; &#xA; &lt;li&gt;No RTTI required&lt;/li&gt; &#xA; &lt;li&gt;Very little use of virtual functions. They are used only when they are absolutely necessary for the required functionality&lt;/li&gt; &#xA; &lt;li&gt;A set of fixed capacity containers. (array, bitset, deque, forward_list, list, queue, stack, vector, map, set, etc.)&lt;/li&gt; &#xA; &lt;li&gt;As the storage for all of the container types is allocated as a contiguous block, they are extremely cache friendly&lt;/li&gt; &#xA; &lt;li&gt;Templated compile time constants&lt;/li&gt; &#xA; &lt;li&gt;Templated design pattern base classes (Visitor, Observer)&lt;/li&gt; &#xA; &lt;li&gt;Reverse engineered C++ 0x11 features (type traits, algorithms, containers etc.)&lt;/li&gt; &#xA; &lt;li&gt;Type-safe enumerations&lt;/li&gt; &#xA; &lt;li&gt;Type-safe typedefs&lt;/li&gt; &#xA; &lt;li&gt;8, 16, 32 &amp;amp; 64 bit CRC calculations&lt;/li&gt; &#xA; &lt;li&gt;Checksums &amp;amp; hash functions&lt;/li&gt; &#xA; &lt;li&gt;Variants (a type that can store many types in a type-safe interface)&lt;/li&gt; &#xA; &lt;li&gt;Choice of asserts, exceptions, error handler or no checks on errors&lt;/li&gt; &#xA; &lt;li&gt;Unit tested (currently over 9400 tests), using VS2022, GCC 12, Clang 14.&lt;/li&gt; &#xA; &lt;li&gt;Many utilities for template support.&lt;/li&gt; &#xA; &lt;li&gt;Easy to read and documented source.&lt;/li&gt; &#xA; &lt;li&gt;Free support via email, GitHub and Slack&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Any help porting the library to work under different platforms and compilers would be gratefully received. I am especially interested in people who are using Keil, IAR, Green Hills, TI Code Composer etc, bare metal or RTOS, and DSPs.&lt;/p&gt; &#xA;&lt;p&gt;See (&lt;a href=&#34;https://www.etlcpp.com&#34;&gt;https://www.etlcpp.com&lt;/a&gt;) for up-to-date information.&lt;/p&gt; &#xA;&lt;h2&gt;Installing this library&lt;/h2&gt; &#xA;&lt;p&gt;You can find the setup steps &lt;a href=&#34;https://www.etlcpp.com/setup.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;CMake&lt;/h3&gt; &#xA;&lt;p&gt;One way to use this library is to drop it somewhere in your project directory and then make the library available by using &lt;code&gt;add_subdirectory&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_subdirectory(etl)&#xA;add_executable(foo main.cpp)&#xA;target_link_libraries(foo PRIVATE etl::etl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If ETL library is used as a Git submodule it may require additional configuration for proper ETL version resolution by allowing the lookup for Git folder outside of the library root directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;set(GIT_DIR_LOOKUP_POLICY ALLOW_LOOKING_ABOVE_CMAKE_SOURCE_DIR)&#xA;add_subdirectory(etl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to install this library with CMake, you can perform the following steps. On Linux, super user rights might be required to install the library, so it might be necessary to add &lt;code&gt;sudo&lt;/code&gt; before the last command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/ETLCPP/etl.git&#xA;cd etl&#xA;git checkout &amp;lt;targetVersion&amp;gt;&#xA;cmake -B build .&#xA;cmake --install build/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After the library has been installed, you can use &lt;a href=&#34;https://cmake.org/cmake/help/latest/command/find_package.html&#34;&gt;find_package&lt;/a&gt; to use the library. Replace &lt;code&gt;&amp;lt;majorVersionRequirement&amp;gt;&lt;/code&gt; with your desired major version:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;find_package(etl &amp;lt;majorVersionRequirement&amp;gt;)&#xA;add_executable(foo main.cpp)&#xA;target_link_libraries(foo PRIVATE etl::etl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively you can use &lt;a href=&#34;https://cmake.org/cmake/help/latest/module/FetchContent.html&#34;&gt;FetchContent&lt;/a&gt;, replacing &lt;code&gt;&amp;lt;targetVersion&amp;gt;&lt;/code&gt; with the version to install based on a git tag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Include(FetchContent)&#xA;&#xA;FetchContent_Declare(&#xA;  etl&#xA;  GIT_REPOSITORY https://github.com/ETLCPP/etl&#xA;  GIT_TAG        &amp;lt;targetVersion&amp;gt;&#xA;)&#xA;&#xA;FetchContent_MakeAvailable(etl)&#xA;&#xA;add_executable(foo main.cpp)&#xA;target_link_libraries(foo PRIVATE etl::etl)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Arduino library&lt;/h2&gt; &#xA;&lt;p&gt;The content of this repo is available as a library in the Arduino IDE (search for the &#34;Embedded Template Library&#34; in the IDE library manager). The Arduino library repository is available at &lt;code&gt;https://github.com/ETLCPP/etl-arduino&lt;/code&gt;, see there for more details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>intel/pcm</title>
    <updated>2025-04-27T01:30:01Z</updated>
    <id>tag:github.com,2025-04-27:/intel/pcm</id>
    <link href="https://github.com/intel/pcm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Intel® Performance Counter Monitor (Intel® PCM)&lt;/p&gt;&lt;hr&gt;&lt;hr&gt; &#xA;&lt;h2&gt;Intel® Performance Counter Monitor (Intel® PCM)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/intel/pcm/security/code-scanning/tools/CodeQL/status&#34;&gt;&lt;img src=&#34;https://github.com/intel/pcm/actions/workflows/codeql.yml/badge.svg?branch=master&#34; alt=&#34;CodeQL&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://securityscorecards.dev/viewer/?uri=github.com/intel/pcm&#34;&gt;&lt;img src=&#34;https://api.securityscorecards.dev/projects/github.com/intel/pcm/badge&#34; alt=&#34;OpenSSF Scorecard&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.bestpractices.dev/projects/8652&#34;&gt;&lt;img src=&#34;https://www.bestpractices.dev/projects/8652/badge&#34; alt=&#34;OpenSSF Best Practices&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#pcm-tools&#34;&gt;PCM Tools&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#building-pcm-tools&#34;&gt;Building PCM&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#downloading-pre-compiled-pcm-tools&#34;&gt;Downloading Pre-Compiled PCM&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#frequently-asked-questions-faq&#34;&gt;FAQ&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#pcm-api-documentation&#34;&gt;API Documentation&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#pcm-environment-variables&#34;&gt;Environment Variables&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/#custom-compilation-options&#34;&gt;Compilation Options&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Intel® Performance Counter Monitor (Intel® PCM) is an application programming interface (API) and a set of tools based on the API to monitor performance and energy metrics of Intel® Core™, Xeon®, Atom™ and Xeon Phi™ processors. PCM works on Linux, Windows, Mac OS X, FreeBSD, DragonFlyBSD and ChromeOS operating systems.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Github repository statistics:&lt;/em&gt; &lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fhetthbszh0.execute-api.us-east-2.amazonaws.com%2Fdefault%2Fpcm-clones&#34; alt=&#34;Custom badge&#34;&gt; &lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2F5urjfrshcd.execute-api.us-east-2.amazonaws.com%2Fdefault%2Fpcm-yesterday-clones&#34; alt=&#34;Custom badge&#34;&gt; &lt;img src=&#34;https://img.shields.io/endpoint?url=https%3A%2F%2Fcsqqh18g3l.execute-api.us-east-2.amazonaws.com%2Fdefault%2Fpcm-today-clones&#34; alt=&#34;Custom badge&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We welcome bug reports and enhancement requests, which can be submitted via the &#34;Issues&#34; section on GitHub. For those interested in contributing to the code, please refer to the guidelines outlined in the CONTRIBUTING.md file.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Current Build Status&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux: &lt;a href=&#34;https://github.com/intel/pcm/actions/workflows/linux_make.yml?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/intel/pcm/linux_make.yml?branch=master&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Windows: &lt;a href=&#34;https://ci.appveyor.com/project/opcm/pcm&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/github/intel/pcm?branch=master&amp;amp;svg=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;FreeBSD: &lt;a href=&#34;https://github.com/intel/pcm/actions/workflows/freebsd_build.yml?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/intel/pcm/freebsd_build.yml?branch=master&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;OS X: &lt;a href=&#34;https://github.com/intel/pcm/actions/workflows/macosx_build.yml?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/intel/pcm/macosx_build.yml?branch=master&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Docker container: &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/DOCKER_README.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/intel/pcm/docker.yml?branch=master&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;PCM Tools&lt;/h2&gt; &#xA;&lt;p&gt;PCM provides a number of command-line utilities for real-time monitoring:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm&lt;/strong&gt; : basic processor monitoring utility (instructions per cycle, core frequency (including Intel(r) Turbo Boost Technology), memory and Intel(r) Quick Path Interconnect bandwidth, local and remote memory bandwidth, cache misses, core and CPU package sleep C-state residency, core and CPU package thermal headroom, cache utilization, CPU and memory energy consumption)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/intel/pcm/assets/25432609/88485ff5-dc7c-4a1c-974f-8396f03829dc&#34; alt=&#34;pcm output&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pcm-sensor-server&lt;/strong&gt; : pcm collector exposing metrics over http in JSON or Prometheus (exporter text based) format (&lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/PCM-EXPORTER.md&#34;&gt;how-to&lt;/a&gt;). Also available as a &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/DOCKER_README.md&#34;&gt;docker container&lt;/a&gt;. More info about Global PCM events is &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/PCM-SENSOR-SERVER-README.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pcm-memory&lt;/strong&gt; : monitor memory bandwidth (per-channel and per-DRAM DIMM rank) &lt;img src=&#34;https://raw.githubusercontent.com/wiki/intel/pcm/pcm-memory.x.JPG&#34; alt=&#34;pcm-memory output&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pcm-accel&lt;/strong&gt; : &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/PCM_ACCEL_README.md&#34;&gt;monitor Intel® In-Memory Analytics Accelerator (Intel® IAA), Intel® Data Streaming Accelerator (Intel® DSA) and Intel® QuickAssist Technology (Intel® QAT) accelerators&lt;/a&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/25432609/218480696-42ade94f-e0c3-4000-9dd8-39a0e75a210e.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pcm-latency&lt;/strong&gt; : monitor L1 cache miss and DDR/PMM memory latency&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pcm-pcie&lt;/strong&gt; : monitor PCIe bandwidth per-socket&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;pcm-iio&lt;/strong&gt; : &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/PCM_IIO_README.md&#34;&gt;monitor PCIe bandwidth per PCIe bus/device&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wiki/intel/pcm/pcm-iio.png&#34; alt=&#34;pcm-iio output&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-numa&lt;/strong&gt; : monitor local and remote memory accesses&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-power&lt;/strong&gt; : monitor sleep and energy states of processor, Intel(r) Quick Path Interconnect, DRAM memory, reasons of CPU frequency throttling and other energy-related metrics&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-tsx&lt;/strong&gt;: monitor performance metrics for Intel(r) Transactional Synchronization Extensions&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-core&lt;/strong&gt; and &lt;strong&gt;pmu-query&lt;/strong&gt;: query and monitor arbitrary processor core events&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-raw&lt;/strong&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/PCM_RAW_README.md&#34;&gt;program arbitrary &lt;strong&gt;core&lt;/strong&gt; and &lt;strong&gt;uncore&lt;/strong&gt; events by specifying raw register event ID encoding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-bw-histogram&lt;/strong&gt;: collect memory bandwidth utilization histogram&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Graphical front ends:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm Grafana dashboard&lt;/strong&gt; : front-end for Grafana (in &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/scripts/grafana&#34;&gt;scripts/grafana&lt;/a&gt; directory). Full Grafana Readme is &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/scripts/grafana/README.md&#34;&gt;here&lt;/a&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wiki/intel/pcm/pcm-dashboard.png&#34; alt=&#34;pcm grafana output&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-sensor&lt;/strong&gt; : front-end for KDE KSysGuard&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pcm-service&lt;/strong&gt; : front-end for Windows perfmon&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There are also utilities for reading/writing model specific registers (&lt;strong&gt;pcm-msr&lt;/strong&gt;), PCI configuration registers (&lt;strong&gt;pcm-pcicfg&lt;/strong&gt;), memory mapped registers (&lt;strong&gt;pcm-mmio&lt;/strong&gt;) and TPMI registers (&lt;strong&gt;pcm-tpmi&lt;/strong&gt;) supported on Linux, Windows, Mac OS X and FreeBSD.&lt;/p&gt; &#xA;&lt;p&gt;And finally a daemon that stores core, memory and QPI counters in shared memory that can be be accessed by non-root users.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Building PCM Tools&lt;/h2&gt; &#xA;&lt;p&gt;Clone PCM repository with submodules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/intel/pcm&#xA;cd pcm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or clone the repository first, and then update submodules with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install cmake (and libasan on Linux) then:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir build&#xA;cd build&#xA;cmake ..&#xA;cmake --build .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will get all the utilities (pcm, pcm-memory, etc) in &lt;code&gt;build/bin&lt;/code&gt; directory. &#39;--parallel&#39; can be used for faster building:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build . --parallel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Debug is default on Windows. Specify config to build Release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build . --config Release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Windows and MacOs additional drivers and steps are required. Please find instructions here: &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/WINDOWS_HOWTO.md&#34;&gt;WINDOWS_HOWTO.md&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/MAC_HOWTO.txt&#34;&gt;MAC_HOWTO.txt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;FreeBSD/DragonFlyBSD-specific details can be found in &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/FREEBSD_HOWTO.txt&#34;&gt;FREEBSD_HOWTO.txt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/25432609/205663554-c4fa1724-6286-495a-9dbd-0104de3f535f.gif&#34; alt=&#34;pcm-build-run-2&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Downloading Pre-Compiled PCM Tools&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ubuntu/Debian: &lt;code&gt;sudo apt install pcm&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;openSUSE: &lt;code&gt;sudo zypper install pcm&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;RHEL8.5 or later: &lt;code&gt;sudo dnf install pcm&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Fedora: &lt;code&gt;sudo yum install pcm&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;RPMs and DEBs with the &lt;em&gt;latest&lt;/em&gt; PCM version for RHEL/SLE/Ubuntu/Debian/openSUSE/etc distributions (binary and source) are available &lt;a href=&#34;https://software.opensuse.org/download/package?package=pcm&amp;amp;project=home%3Aopcm&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Windows: download PCM binaries as &lt;a href=&#34;https://ci.appveyor.com/project/opcm/pcm/history&#34;&gt;appveyor build service&lt;/a&gt; artifacts and required Visual C++ Redistributable from &lt;a href=&#34;https://www.microsoft.com/en-us/download/details.aspx?id=48145&#34;&gt;www.microsoft.com&lt;/a&gt;. Additional steps and drivers are required, see &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/WINDOWS_HOWTO.md&#34;&gt;WINDOWS_HOWTO.md&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Docker: see &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/DOCKER_README.md&#34;&gt;instructions on how to use pcm-sensor-server pre-compiled container from docker hub&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Executing PCM tools under non-root user on Linux&lt;/h2&gt; &#xA;&lt;p&gt;Executing PCM tools under an unprivileged user on a Linux operating system is feasible. However, there are certain prerequisites that need to be met, such as having Linux perf_event support for your processor in the Linux kernel version you are currently running. To successfully run the PCM tools, you need to set the &lt;code&gt;/proc/sys/kernel/perf_event_paranoid&lt;/code&gt; setting to -1 as root once:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo -1 &amp;gt; /proc/sys/kernel/perf_event_paranoid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and configure two specific environment variables when running the tools under a non-root user:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export PCM_NO_MSR=1&#xA;export PCM_KEEP_NMI_WATCHDOG=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For instance, you can execute the following commands to set the environment variables and run pcm:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export PCM_NO_MSR=1&#xA;export PCM_KEEP_NMI_WATCHDOG=1&#xA;pcm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or (to run the pcm sensor server as non-root):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PCM_NO_MSR=1 PCM_KEEP_NMI_WATCHDOG=1 pcm-sensor-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please keep in mind that when executing PCM tools under an unprivileged user on Linux, certain PCM metrics may be unavailable. This limitation specifically affects metrics that rely solely on direct MSR (Model-Specific Register) register access. Due to the restricted privileges of the user, accessing these registers is not permitted, resulting in the absence of corresponding metrics.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Frequently Asked Questions (FAQ)&lt;/h2&gt; &#xA;&lt;p&gt;PCM&#39;s frequently asked questions (FAQ) are located &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/FAQ.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;PCM API documentation&lt;/h2&gt; &#xA;&lt;p&gt;PCM API documentation is embedded in the source code and can be generated into html format from source using Doxygen (&lt;a href=&#34;http://www.doxygen.org&#34;&gt;www.doxygen.org&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;PCM environment variables&lt;/h2&gt; &#xA;&lt;p&gt;The list of PCM environment variables is located &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/ENVVAR_README.md&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Custom compilation options&lt;/h2&gt; &#xA;&lt;p&gt;The list of custom compilation options is located &lt;a href=&#34;https://raw.githubusercontent.com/intel/pcm/master/doc/CUSTOM-COMPILE-OPTIONS.md&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Packaging&lt;/h2&gt; &#xA;&lt;p&gt;Packaging with CPack is supported on Debian and Redhat/SUSE system families. To create DEB of RPM package need to call cpack after building in build folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd build&#xA;cpack&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This creates package:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;pcm-VERSION-Linux.deb&#34; on Debian family systems;&lt;/li&gt; &#xA; &lt;li&gt;&#34;pcm-VERSION-Linux.rpm&#34; on Redhat/SUSE-family systems. Packages contain pcm-* binaries and required for usage opCode-* files.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>