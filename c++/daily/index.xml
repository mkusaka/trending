<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-26T01:29:48Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>unitreerobotics/unitree_mujoco</title>
    <updated>2025-04-26T01:29:48Z</updated>
    <id>tag:github.com,2025-04-26:/unitreerobotics/unitree_mujoco</id>
    <link href="https://github.com/unitreerobotics/unitree_mujoco" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;h2&gt;Unitree mujoco&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;unitree_mujoco&lt;/code&gt; is a simulator developed based on &lt;code&gt;Unitree sdk2&lt;/code&gt; and &lt;code&gt;mujoco&lt;/code&gt;. Users can easily integrate the control programs developed with &lt;code&gt;Unitree_sdk2&lt;/code&gt;, &lt;code&gt;unitree_ros2&lt;/code&gt;, and &lt;code&gt;unitree_sdk2_python&lt;/code&gt; into this simulator, enabling a seamless transition from simulation to physical development. The repository includes two versions of the simulator implemented in C++ and Python, with a structure as follows: &lt;img src=&#34;https://raw.githubusercontent.com/unitreerobotics/unitree_mujoco/main/doc/func.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Directory Structure&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;simulate&lt;/code&gt;: Simulator implemented based on unitree_sdk2 and mujoco (C++)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;simulate_python&lt;/code&gt;: Simulator implemented based on unitree_sdk2_python and mujoco (Python)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unitree_robots&lt;/code&gt;: MJCF description files for robots supported by unitree_sdk2&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;terrain_tool&lt;/code&gt;: Tool for generating terrain in simulation scenarios&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;example&lt;/code&gt;: Example programs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Unitree sdk2 Messages:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Current version only supports low-level development, mainly used for sim to real verification of controller&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;LowCmd&lt;/code&gt;: Motor control commands&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;LowState&lt;/code&gt;: Motor state information&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SportModeState&lt;/code&gt;: Robot position and velocity data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The numbering of the motors corresponds to the actual robot hardware. Specific details can be found in the &lt;a href=&#34;https://support.unitree.com/home/zh/developer&#34;&gt;Unitree documentation&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;In the actual robot hardware, the &lt;code&gt;SportModeState&lt;/code&gt; message is not readable after the built-in motion control service is turned off. However, the simulator retains this message to allow users to utilize the position and velocity information for analyzing the developed control programs.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Related links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/unitreerobotics/unitree_sdk2&#34;&gt;unitree_sdk2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/unitreerobotics/unitree_sdk2_python&#34;&gt;unitree_sdk2_python&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/unitreerobotics/unitree_ros2&#34;&gt;unitree_ros2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://support.unitree.com/home/zh/developer&#34;&gt;Unitree Doc&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mujoco.readthedocs.io/en/stable/overview.html&#34;&gt;Mujoco Doc&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Message (DDS idl) type description&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Unitree Go2, B2, H1, B2w, Go2w robots use unitree_go idl for low-level communication.&lt;/li&gt; &#xA; &lt;li&gt;Unitree G1 robot uses unitree_hg idl for low-level communication.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;C++ Simulator (simulate)&lt;/h2&gt; &#xA;&lt;h3&gt;1. Dependencies&lt;/h3&gt; &#xA;&lt;h4&gt;unitree_sdk2&lt;/h4&gt; &#xA;&lt;p&gt;It is recommended to install &lt;code&gt;unitree_sdk2&lt;/code&gt; in &lt;code&gt;/opt/unitree_robotics&lt;/code&gt; path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/unitreerobotics/unitree_sdk2.git&#xA;cd unitree_sdk2/&#xA;mkdir build&#xA;cd build&#xA;cmake .. -DCMAKE_INSTALL_PREFIX=/opt/unitree_robotics&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more details, see: &lt;a href=&#34;https://github.com/unitreerobotics/unitree_sdk2&#34;&gt;https://github.com/unitreerobotics/unitree_sdk2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;mujoco&lt;/h4&gt; &#xA;&lt;p&gt;Current version is tested in mujoco-3.2.7&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install libglfw3-dev libxinerama-dev libxcursor-dev libxi-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/google-deepmind/mujoco.git&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake ..&#xA;make -j4&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;simulate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the mujoco simulator pops up, the installation is successful.&lt;/p&gt; &#xA;&lt;h4&gt;yaml-cpp&lt;/h4&gt; &#xA;&lt;p&gt;yaml-cpp is mainly used for reading configuration files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install libyaml-cpp-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. Compile unitree_mujoco&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd unitree_mujoco/simulate&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake ..&#xA;make -j4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;3. Test:&lt;/h3&gt; &#xA;&lt;p&gt;Run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./unitree_mujoco&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see the mujoco simulator with the Go2 robot loaded. In a new terminal, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The program will output the robot&#39;s pose and position information in the simulator, and each motor of the robot will continuously output 1Nm of torque.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The testing program sends the unitree_go message. If you want to test G1 robot, you need to modify the program to use the unitree_hg message.&lt;/p&gt; &#xA;&lt;h2&gt;Python Simulator (simulate_python)&lt;/h2&gt; &#xA;&lt;h3&gt;1. Dependencies&lt;/h3&gt; &#xA;&lt;h4&gt;unitree_sdk2_python&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~&#xA;sudo apt install python3-pip&#xA;git clone https://github.com/unitreerobotics/unitree_sdk2_python.git&#xA;cd unitree_sdk2_python&#xA;pip3 install -e .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you encounter an error during installation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Could not locate cyclonedds. Try to set CYCLONEDDS_HOME or CMAKE_PREFIX_PATH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refer to: &lt;a href=&#34;https://github.com/unitreerobotics/unitree_sdk2_python&#34;&gt;https://github.com/unitreerobotics/unitree_sdk2_python&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;mujoco-python&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip3 install mujoco&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;joystick&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip3 install pygame&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;2. Test&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ./simulate_python&#xA;python3 ./unitree_mujoco.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see the mujoco simulator with the Go2 robot loaded. In a new terminal, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python3 ./test/test_unitree_sdk2.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The program will output the robot&#39;s pose and position information in the simulator, and each motor of the robot will continuously output 1Nm of torque.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The testing program sends the unitree_go message. If you want to test G1 robot, you need to modify the program to use the unitree_hg message.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;h2&gt;1. Simulation Configuration&lt;/h2&gt; &#xA;&lt;h3&gt;C++ Simulator&lt;/h3&gt; &#xA;&lt;p&gt;The configuration file for the C++ simulator is located at &lt;code&gt;/simulate/config.yaml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Robot name loaded by the simulator&#xA;# &#34;go2&#34;, &#34;b2&#34;, &#34;b2w&#34;, &#34;h1&#34;&#xA;robot: &#34;go2&#34;&#xA;# Robot simulation scene file&#xA;# For example, for go2, it refers to the scene.xml file in the /unitree_robots/go2/ folder&#xA;robot_scene: &#34;scene.xml&#34;&#xA;# DDS domain id, it is recommended to distinguish from the real robot (default is 0 on the real robot)&#xA;domain_id: 1&#xA;&#xA;use_joystick: 1 # Simulate Unitree WirelessController using a gamepad&#xA;joystick_type: &#34;xbox&#34; # support &#34;xbox&#34; and &#34;switch&#34; gamepad layout&#xA;joystick_device: &#34;/dev/input/js0&#34; # Device path&#xA;joystick_bits: 16 # Some game controllers may only have 8-bit accuracy&#xA;&#xA;# Network interface name, for simulation, it is recommended to use the local loopback &#34;lo&#34;&#xA;interface: &#34;lo&#34;&#xA;# Whether to output robot link, joint, sensor information, 1 for output&#xA;print_scene_information: 1&#xA;# Whether to use virtual tape, 1 to enable&#xA;# Mainly used to simulate the hanging process of H1 robot initialization&#xA;enable_elastic_band: 0 # For H1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Python Simulator&lt;/h3&gt; &#xA;&lt;p&gt;The configuration file for the Python simulator is located at &lt;code&gt;/simulate_python/config.py&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Robot name loaded by the simulator&#xA;# &#34;go2&#34;, &#34;b2&#34;, &#34;b2w&#34;, &#34;h1&#34;&#xA;ROBOT = &#34;go2&#34;&#xA;# Robot simulation scene file&#xA;ROBOT_SCENE = &#34;../unitree_robots/&#34; + ROBOT + &#34;/scene.xml&#34;  # Robot scene&#xA;# DDS domain id, it is recommended to distinguish from the real robot (default is 0 on the real robot)&#xA;DOMAIN_ID = 1  # Domain id&#xA;# Network interface name, for simulation, it is recommended to use the local loopback &#34;lo&#34;&#xA;INTERFACE = &#34;lo&#34;  # Interface&#xA;# Whether to output robot link, joint, sensor information, True for output&#xA;PRINT_SCENE_INFORMATION = True&#xA;&#xA;USE_JOYSTICK = 1 # Simulate Unitree WirelessController using a gamepad&#xA;JOYSTICK_TYPE = &#34;xbox&#34; # support &#34;xbox&#34; and &#34;switch&#34; gamepad layout&#xA;JOYSTICK_DEVICE = 0 # Joystick number&#xA;&#xA;# Whether to use virtual tape, 1 to enable&#xA;# Mainly used to simulate the hanging process of H1 robot initialization&#xA;ENABLE_ELASTIC_BAND = False&#xA;# Simulation time step (unit: s)&#xA;# To ensure the reliability of the simulation, it needs to be greater than the time required for viewer.sync() to render once&#xA;SIMULATE_DT = 0.003  &#xA;# Visualization interface runtime step, 0.02 corresponds to 50fps/s&#xA;VIEWER_DT = 0.02&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Joystick&lt;/h3&gt; &#xA;&lt;p&gt;The simulator will use an Xbox or Switch gamepad to simulate the wireless controller of the robot. The button and joystick information of the wireless controller will be published through &#34;rt/wireless_controller&#34; topic. &lt;code&gt;use_joystick/USE_JOYSTICK&lt;/code&gt; in &lt;code&gt;config.yaml/config.py&lt;/code&gt; needs to be set to 0, when there is no gamepad. If your gamepad is not in Xbox or Switch layout, you can modify it in the source code (The button and joystick IDs can be determined using &lt;code&gt;jstest&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;simulate/src/unitree_sdk2_bridge/unitree_sdk2_bridge.cc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt; if (js_type == &#34;xbox&#34;)&#xA;{&#xA;    js_id_.axis[&#34;LX&#34;] = 0; // Left stick axis x&#xA;    js_id_.axis[&#34;LY&#34;] = 1; // Left stick axis y&#xA;    js_id_.axis[&#34;RX&#34;] = 3; // Right stick axis x&#xA;    js_id_.axis[&#34;RY&#34;] = 4; // Right stick axis y&#xA;    js_id_.axis[&#34;LT&#34;] = 2; // Left trigger&#xA;    js_id_.axis[&#34;RT&#34;] = 5; // Right trigger&#xA;    js_id_.axis[&#34;DX&#34;] = 6; // Directional pad x&#xA;    js_id_.axis[&#34;DY&#34;] = 7; // Directional pad y&#xA;&#xA;    js_id_.button[&#34;X&#34;] = 2;&#xA;    js_id_.button[&#34;Y&#34;] = 3;&#xA;    js_id_.button[&#34;B&#34;] = 1;&#xA;    js_id_.button[&#34;A&#34;] = 0;&#xA;    js_id_.button[&#34;LB&#34;] = 4;&#xA;    js_id_.button[&#34;RB&#34;] = 5;&#xA;    js_id_.button[&#34;SELECT&#34;] = 6;&#xA;    js_id_.button[&#34;START&#34;] = 7;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In &lt;code&gt;simulate_python/unitree_sdk2_bridge.py&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if js_type == &#34;xbox&#34;:&#xA;    self.axis_id = {&#xA;        &#34;LX&#34;: 0,  # Left stick axis x&#xA;        &#34;LY&#34;: 1,  # Left stick axis y&#xA;        &#34;RX&#34;: 3,  # Right stick axis x&#xA;        &#34;RY&#34;: 4,  # Right stick axis y&#xA;        &#34;LT&#34;: 2,  # Left trigger&#xA;        &#34;RT&#34;: 5,  # Right trigger&#xA;        &#34;DX&#34;: 6,  # Directional pad x&#xA;        &#34;DY&#34;: 7,  # Directional pad y&#xA;    }&#xA;&#xA;    self.button_id = {&#xA;        &#34;X&#34;: 2,&#xA;        &#34;Y&#34;: 3,&#xA;        &#34;B&#34;: 1,&#xA;        &#34;A&#34;: 0,&#xA;        &#34;LB&#34;: 4,&#xA;        &#34;RB&#34;: 5,&#xA;        &#34;SELECT&#34;: 6,&#xA;        &#34;START&#34;: 7,&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Elastic band for humanoid&lt;/h3&gt; &#xA;&lt;p&gt;Consider humanoid robots are not suitable for starting in ground, a virtual elastic band was designed to simulate the lifting and lowering of humanoid robots. Setting &lt;code&gt;enable_elastic_mand/ENABLE_ELSTIC_BAND=1&lt;/code&gt; can enable the virtual elastic band. After loading the robot, press&#39; 9 &#39;to activate or release the strap, press&#39; 7&#39; to lower the robot, and press&#39; 8 &#39;to lift the robot.&lt;/p&gt; &#xA;&lt;h2&gt;2. Terrain Generation Tool&lt;/h2&gt; &#xA;&lt;p&gt;We provide a tool to parametrically create simple terrains in the mujoco simulator, including stairs, rough ground, and height maps. The program is located in the &lt;code&gt;terrain_tool&lt;/code&gt; folder. For specific usage instructions, refer to the README file in the &lt;code&gt;terrain_tool&lt;/code&gt; folder. &lt;img src=&#34;https://raw.githubusercontent.com/unitreerobotics/unitree_mujoco/main/doc/terrain.png&#34; alt=&#34;Terrain Generation Example&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;3. Sim to Real&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;example&lt;/code&gt; folder contains simple examples of using different interfaces to make the Go2 robot stand up and then lie down. These examples demonstrate how to implement the transition from simulation to reality using interfaces provided by Unitree. Here is an explanation of each folder name:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cpp&lt;/code&gt;: Based on C++, using &lt;code&gt;unitree_sdk2&lt;/code&gt; interface&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;python&lt;/code&gt;: Based on Python, using &lt;code&gt;unitree_sdk2_python&lt;/code&gt; interface&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ros2&lt;/code&gt;: Based on ROS2, using &lt;code&gt;unitree_ros2&lt;/code&gt; interface&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;unitree_sdk2&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Compile&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd example/cpp&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake ..&#xA;make -j4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Run:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./stand_go2 # Control the robot in the simulation (make sure the Go2 simulation scene has been loaded)&#xA;./stand_go2 enp3s0 # Control the physical robot, where enp3s0 is the name of the network card connected to the robot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Sim to Real&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (argc &amp;lt; 2)&#xA;{   &#xA;    // If no network card is input, use the simulated domain id and the local network card&#xA;    ChannelFactory::Instance()-&amp;gt;Init(1, &#34;lo&#34;);&#xA;}&#xA;else&#xA;{   &#xA;    // Otherwise, use the specified network card&#xA;    ChannelFactory::Instance()-&amp;gt;Init(0, argv[1]);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;unitree_sdk2_python&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python3 ./stand_go2.py # Control the robot in the simulation (make sure the Go2 simulation scene has been loaded)&#xA;python3 ./stand_go2.py enp3s0 # Control the physical robot, where enp3s0 is the name of the network card connected to the robot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Sim to Real&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if len(sys.argv) &amp;lt; 2:&#xA;    // If no network card is input, use the simulated domain id and the local network card&#xA;    ChannelFactoryInitialize(1, &#34;lo&#34;)&#xA;else:&#xA;    // Otherwise, use the specified network card&#xA;    ChannelFactoryInitialize(0, sys.argv[1])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;unitree_ros2&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Compile First, ensure that the unitree_ros2 environment has been properly configured, see &lt;a href=&#34;https://github.com/unitreerobotics/unitree_ros2&#34;&gt;unitree_ros2&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ~/unitree_ros2/setup.sh&#xA;cd example/ros2&#xA;colcon build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Run simulation&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ~/unitree_ros2/setup_local.sh # Use the local network card&#xA;export ROS_DOMAIN_ID=1 # Modify the domain id to match the simulation&#xA;./install/stand_go2/bin/stand_go2 # Run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Run real robot&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source ~/unitree_ros2/setup.sh # Use the network card connected to the robot&#xA;export ROS_DOMAIN_ID=0 # Use the default domain id&#xA;./install/stand_go2/bin/stand_go2 # Run&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>