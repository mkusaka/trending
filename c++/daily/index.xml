<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-14T01:31:10Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SnapDragon64/ACMFinalsSolutions</title>
    <updated>2022-11-14T01:31:10Z</updated>
    <id>tag:github.com,2022-11-14:/SnapDragon64/ACMFinalsSolutions</id>
    <link href="https://github.com/SnapDragon64/ACMFinalsSolutions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SnapDragon&#39;s solutions for the ACM ICPC World Finals problems.&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>me-no-dev/ESPAsyncWebServer</title>
    <updated>2022-11-14T01:31:10Z</updated>
    <id>tag:github.com,2022-11-14:/me-no-dev/ESPAsyncWebServer</id>
    <link href="https://github.com/me-no-dev/ESPAsyncWebServer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Async Web Server for ESP8266 and ESP32&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ESPAsyncWebServer&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/me-no-dev/ESPAsyncWebServer&#34;&gt;&lt;img src=&#34;https://travis-ci.org/me-no-dev/ESPAsyncWebServer.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://github.com/me-no-dev/ESPAsyncWebServer/workflows/ESP%20Async%20Web%20Server%20CI/badge.svg?sanitize=true&#34; alt=&#34;&#34;&gt; &lt;a href=&#34;https://www.codacy.com/manual/me-no-dev/ESPAsyncWebServer?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=me-no-dev/ESPAsyncWebServer&amp;amp;utm_campaign=Badge_Grade&#34;&gt;&lt;img src=&#34;https://api.codacy.com/project/badge/Grade/395dd42cfc674e6ca2e326af3af80ffc&#34; alt=&#34;Codacy Badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For help and support &lt;a href=&#34;https://gitter.im/me-no-dev/ESPAsyncWebServer?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/me-no-dev/ESPAsyncWebServer.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/me-no-dev/ESPAsyncWebServer&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Async HTTP and WebSocket Server for ESP8266 Arduino&lt;/p&gt; &#xA;&lt;p&gt;For ESP8266 it requires &lt;a href=&#34;https://github.com/me-no-dev/ESPAsyncTCP&#34;&gt;ESPAsyncTCP&lt;/a&gt; To use this library you might need to have the latest git versions of &lt;a href=&#34;https://github.com/esp8266/Arduino&#34;&gt;ESP8266&lt;/a&gt; Arduino Core&lt;/p&gt; &#xA;&lt;p&gt;For ESP32 it requires &lt;a href=&#34;https://github.com/me-no-dev/AsyncTCP&#34;&gt;AsyncTCP&lt;/a&gt; to work To use this library you might need to have the latest git versions of &lt;a href=&#34;https://github.com/espressif/arduino-esp32&#34;&gt;ESP32&lt;/a&gt; Arduino Core&lt;/p&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#espasyncwebserver&#34;&gt;ESPAsyncWebServer&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#table-of-contents&#34;&gt;Table of contents&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#using-platformio&#34;&gt;Using PlatformIO&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#why-should-you-care&#34;&gt;Why should you care&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#important-things-to-remember&#34;&gt;Important things to remember&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#principles-of-operation&#34;&gt;Principles of operation&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#the-async-web-server&#34;&gt;The Async Web server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#request-life-cycle&#34;&gt;Request Life Cycle&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#rewrites-and-how-do-they-work&#34;&gt;Rewrites and how do they work&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#handlers-and-how-do-they-work&#34;&gt;Handlers and how do they work&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#responses-and-how-do-they-work&#34;&gt;Responses and how do they work&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#template-processing&#34;&gt;Template processing&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#libraries-and-projects-that-use-asyncwebserver&#34;&gt;Libraries and projects that use AsyncWebServer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#request-variables&#34;&gt;Request Variables&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#common-variables&#34;&gt;Common Variables&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#headers&#34;&gt;Headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#get-post-and-file-parameters&#34;&gt;GET, POST and FILE parameters&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#file-upload-handling&#34;&gt;FILE Upload handling&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#body-data-handling&#34;&gt;Body data handling&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#json-body-handling-with-arduinojson&#34;&gt;JSON body handling with ArduinoJson&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#responses&#34;&gt;Responses&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#redirect-to-another-url&#34;&gt;Redirect to another URL&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#basic-response-with-http-code&#34;&gt;Basic response with HTTP Code&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#basic-response-with-http-code-and-extra-headers&#34;&gt;Basic response with HTTP Code and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#basic-response-with-string-content&#34;&gt;Basic response with string content&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#basic-response-with-string-content-and-extra-headers&#34;&gt;Basic response with string content and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#send-large-webpage-from-progmem&#34;&gt;Send large webpage from PROGMEM&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#send-large-webpage-from-progmem-and-extra-headers&#34;&gt;Send large webpage from PROGMEM and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#send-large-webpage-from-progmem-containing-templates&#34;&gt;Send large webpage from PROGMEM containing templates&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#send-large-webpage-from-progmem-containing-templates-and-extra-headers&#34;&gt;Send large webpage from PROGMEM containing templates and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#send-binary-content-from-progmem&#34;&gt;Send binary content from PROGMEM&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-stream&#34;&gt;Respond with content coming from a Stream&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-stream-and-extra-headers&#34;&gt;Respond with content coming from a Stream and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-stream-containing-templates&#34;&gt;Respond with content coming from a Stream containing templates&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-stream-containing-templates-and-extra-headers&#34;&gt;Respond with content coming from a Stream containing templates and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-file&#34;&gt;Respond with content coming from a File&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-file-and-extra-headers&#34;&gt;Respond with content coming from a File and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-file-containing-templates&#34;&gt;Respond with content coming from a File containing templates&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-using-a-callback&#34;&gt;Respond with content using a callback&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-using-a-callback-and-extra-headers&#34;&gt;Respond with content using a callback and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-using-a-callback-containing-templates&#34;&gt;Respond with content using a callback containing templates&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-using-a-callback-containing-templates-and-extra-headers&#34;&gt;Respond with content using a callback containing templates and extra headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#chunked-response&#34;&gt;Chunked Response&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#chunked-response-containing-templates&#34;&gt;Chunked Response containing templates&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#print-to-response&#34;&gt;Print to response&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#arduinojson-basic-response&#34;&gt;ArduinoJson Basic Response&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#arduinojson-advanced-response&#34;&gt;ArduinoJson Advanced Response&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#serving-static-files&#34;&gt;Serving static files&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#serving-specific-file-by-name&#34;&gt;Serving specific file by name&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#serving-files-in-directory&#34;&gt;Serving files in directory&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#serving-static-files-with-authentication&#34;&gt;Serving static files with authentication&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#specifying-cache-control-header&#34;&gt;Specifying Cache-Control header&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#specifying-date-modified-header&#34;&gt;Specifying Date-Modified header&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#specifying-template-processor-callback&#34;&gt;Specifying Template Processor callback&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#param-rewrite-with-matching&#34;&gt;Param Rewrite With Matching&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#using-filters&#34;&gt;Using filters&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#serve-different-site-files-in-ap-mode&#34;&gt;Serve different site files in AP mode&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#rewrite-to-different-index-on-ap&#34;&gt;Rewrite to different index on AP&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#serving-different-hosts&#34;&gt;Serving different hosts&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#determine-interface-inside-callbacks&#34;&gt;Determine interface inside callbacks&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#bad-responses&#34;&gt;Bad Responses&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-using-a-callback-without-content-length-to-http10-clients&#34;&gt;Respond with content using a callback without content length to HTTP/1.0 clients&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#async-websocket-plugin&#34;&gt;Async WebSocket Plugin&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#async-websocket-event&#34;&gt;Async WebSocket Event&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#methods-for-sending-data-to-a-socket-client&#34;&gt;Methods for sending data to a socket client&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#direct-access-to-web-socket-message-buffer&#34;&gt;Direct access to web socket message buffer&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#limiting-the-number-of-web-socket-clients&#34;&gt;Limiting the number of web socket clients&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#async-event-source-plugin&#34;&gt;Async Event Source Plugin&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#setup-event-source-on-the-server&#34;&gt;Setup Event Source on the server&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#setup-event-source-in-the-browser&#34;&gt;Setup Event Source in the browser&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#scanning-for-available-wifi-networks&#34;&gt;Scanning for available WiFi Networks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#remove-handlers-and-rewrites&#34;&gt;Remove handlers and rewrites&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#setting-up-the-server&#34;&gt;Setting up the server&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#setup-global-and-class-functions-as-request-handlers&#34;&gt;Setup global and class functions as request handlers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#methods-for-controlling-websocket-connections&#34;&gt;Methods for controlling websocket connections&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#adding-default-headers&#34;&gt;Adding Default Headers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#path-variable&#34;&gt;Path variable&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Using PlatformIO&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://platformio.org&#34;&gt;PlatformIO&lt;/a&gt; is an open source ecosystem for IoT development with cross platform build system, library manager and full support for Espressif ESP8266/ESP32 development. It works on the popular host OS: Mac OS X, Windows, Linux 32/64, Linux ARM (like Raspberry Pi, BeagleBone, CubieBoard).&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;http://platformio.org/platformio-ide&#34;&gt;PlatformIO IDE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Create new project using &#34;PlatformIO Home &amp;gt; New Project&#34;&lt;/li&gt; &#xA; &lt;li&gt;Update dev/platform to staging version: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://docs.platformio.org/en/latest/platforms/espressif8266.html#using-arduino-framework-with-staging-version&#34;&gt;Instruction for Espressif 8266&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;http://docs.platformio.org/en/latest/platforms/espressif32.html#using-arduino-framework-with-staging-version&#34;&gt;Instruction for Espressif 32&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add &#34;ESP Async WebServer&#34; to project using &lt;a href=&#34;http://docs.platformio.org/page/projectconf.html&#34;&gt;Project Configuration File &lt;code&gt;platformio.ini&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://docs.platformio.org/page/projectconf/section_env_library.html#lib-deps&#34;&gt;lib_deps&lt;/a&gt; option:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[env:myboard]&#xA;platform = espressif...&#xA;board = ...&#xA;framework = arduino&#xA;&#xA;# using the latest stable version&#xA;lib_deps = ESP Async WebServer&#xA;&#xA;# or using GIT Url (the latest development version)&#xA;lib_deps = https://github.com/me-no-dev/ESPAsyncWebServer.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Happy coding with PlatformIO!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Why should you care&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using asynchronous network means that you can handle more than one connection at the same time&lt;/li&gt; &#xA; &lt;li&gt;You are called once the request is ready and parsed&lt;/li&gt; &#xA; &lt;li&gt;When you send the response, you are immediately ready to handle other connections while the server is taking care of sending the response in the background&lt;/li&gt; &#xA; &lt;li&gt;Speed is OMG&lt;/li&gt; &#xA; &lt;li&gt;Easy to use API, HTTP Basic and Digest MD5 Authentication (default), ChunkedResponse&lt;/li&gt; &#xA; &lt;li&gt;Easily extendible to handle any type of content&lt;/li&gt; &#xA; &lt;li&gt;Supports Continue 100&lt;/li&gt; &#xA; &lt;li&gt;Async WebSocket plugin offering different locations without extra servers or ports&lt;/li&gt; &#xA; &lt;li&gt;Async EventSource (Server-Sent Events) plugin to send events to the browser&lt;/li&gt; &#xA; &lt;li&gt;URL Rewrite plugin for conditional and permanent url rewrites&lt;/li&gt; &#xA; &lt;li&gt;ServeStatic plugin that supports cache, Last-Modified, default index and more&lt;/li&gt; &#xA; &lt;li&gt;Simple template processing engine to handle templates&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Important things to remember&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This is fully asynchronous server and as such does not run on the loop thread.&lt;/li&gt; &#xA; &lt;li&gt;You can not use yield or delay or any function that uses them inside the callbacks&lt;/li&gt; &#xA; &lt;li&gt;The server is smart enough to know when to close the connection and free resources&lt;/li&gt; &#xA; &lt;li&gt;You can not send more than one response to a single request&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Principles of operation&lt;/h2&gt; &#xA;&lt;h3&gt;The Async Web server&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Listens for connections&lt;/li&gt; &#xA; &lt;li&gt;Wraps the new clients into &lt;code&gt;Request&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Keeps track of clients and cleans memory&lt;/li&gt; &#xA; &lt;li&gt;Manages &lt;code&gt;Rewrites&lt;/code&gt; and apply them on the request url&lt;/li&gt; &#xA; &lt;li&gt;Manages &lt;code&gt;Handlers&lt;/code&gt; and attaches them to Requests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Request Life Cycle&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TCP connection is received by the server&lt;/li&gt; &#xA; &lt;li&gt;The connection is wrapped inside &lt;code&gt;Request&lt;/code&gt; object&lt;/li&gt; &#xA; &lt;li&gt;When the request head is received (type, url, get params, http version and host), the server goes through all &lt;code&gt;Rewrites&lt;/code&gt; (in the order they were added) to rewrite the url and inject query parameters, next, it goes through all attached &lt;code&gt;Handlers&lt;/code&gt;(in the order they were added) trying to find one that &lt;code&gt;canHandle&lt;/code&gt; the given request. If none are found, the default(catch-all) handler is attached.&lt;/li&gt; &#xA; &lt;li&gt;The rest of the request is received, calling the &lt;code&gt;handleUpload&lt;/code&gt; or &lt;code&gt;handleBody&lt;/code&gt; methods of the &lt;code&gt;Handler&lt;/code&gt; if they are needed (POST+File/Body)&lt;/li&gt; &#xA; &lt;li&gt;When the whole request is parsed, the result is given to the &lt;code&gt;handleRequest&lt;/code&gt; method of the &lt;code&gt;Handler&lt;/code&gt; and is ready to be responded to&lt;/li&gt; &#xA; &lt;li&gt;In the &lt;code&gt;handleRequest&lt;/code&gt; method, to the &lt;code&gt;Request&lt;/code&gt; is attached a &lt;code&gt;Response&lt;/code&gt; object (see below) that will serve the response data back to the client&lt;/li&gt; &#xA; &lt;li&gt;When the &lt;code&gt;Response&lt;/code&gt; is sent, the client is closed and freed from the memory&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Rewrites and how do they work&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;Rewrites&lt;/code&gt; are used to rewrite the request url and/or inject get parameters for a specific request url path.&lt;/li&gt; &#xA; &lt;li&gt;All &lt;code&gt;Rewrites&lt;/code&gt; are evaluated on the request in the order they have been added to the server.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;Rewrite&lt;/code&gt; will change the request url only if the request url (excluding get parameters) is fully match the rewrite url, and when the optional &lt;code&gt;Filter&lt;/code&gt; callback return true.&lt;/li&gt; &#xA; &lt;li&gt;Setting a &lt;code&gt;Filter&lt;/code&gt; to the &lt;code&gt;Rewrite&lt;/code&gt; enables to control when to apply the rewrite, decision can be based on request url, http version, request host/port/target host, get parameters or the request client&#39;s localIP or remoteIP.&lt;/li&gt; &#xA; &lt;li&gt;Two filter callbacks are provided: &lt;code&gt;ON_AP_FILTER&lt;/code&gt; to execute the rewrite when request is made to the AP interface, &lt;code&gt;ON_STA_FILTER&lt;/code&gt; to execute the rewrite when request is made to the STA interface.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;Rewrite&lt;/code&gt; can specify a target url with optional get parameters, e.g. &lt;code&gt;/to-url?with=params&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Handlers and how do they work&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;Handlers&lt;/code&gt; are used for executing specific actions to particular requests&lt;/li&gt; &#xA; &lt;li&gt;One &lt;code&gt;Handler&lt;/code&gt; instance can be attached to any request and lives together with the server&lt;/li&gt; &#xA; &lt;li&gt;Setting a &lt;code&gt;Filter&lt;/code&gt; to the &lt;code&gt;Handler&lt;/code&gt; enables to control when to apply the handler, decision can be based on request url, http version, request host/port/target host, get parameters or the request client&#39;s localIP or remoteIP.&lt;/li&gt; &#xA; &lt;li&gt;Two filter callbacks are provided: &lt;code&gt;ON_AP_FILTER&lt;/code&gt; to execute the rewrite when request is made to the AP interface, &lt;code&gt;ON_STA_FILTER&lt;/code&gt; to execute the rewrite when request is made to the STA interface.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;canHandle&lt;/code&gt; method is used for handler specific control on whether the requests can be handled and for declaring any interesting headers that the &lt;code&gt;Request&lt;/code&gt; should parse. Decision can be based on request method, request url, http version, request host/port/target host and get parameters&lt;/li&gt; &#xA; &lt;li&gt;Once a &lt;code&gt;Handler&lt;/code&gt; is attached to given &lt;code&gt;Request&lt;/code&gt; (&lt;code&gt;canHandle&lt;/code&gt; returned true) that &lt;code&gt;Handler&lt;/code&gt; takes care to receive any file/data upload and attach a &lt;code&gt;Response&lt;/code&gt; once the &lt;code&gt;Request&lt;/code&gt; has been fully parsed&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Handlers&lt;/code&gt; are evaluated in the order they are attached to the server. The &lt;code&gt;canHandle&lt;/code&gt; is called only if the &lt;code&gt;Filter&lt;/code&gt; that was set to the &lt;code&gt;Handler&lt;/code&gt; return true.&lt;/li&gt; &#xA; &lt;li&gt;The first &lt;code&gt;Handler&lt;/code&gt; that can handle the request is selected, not further &lt;code&gt;Filter&lt;/code&gt; and &lt;code&gt;canHandle&lt;/code&gt; are called.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Responses and how do they work&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;Response&lt;/code&gt; objects are used to send the response data back to the client&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;Response&lt;/code&gt; object lives with the &lt;code&gt;Request&lt;/code&gt; and is freed on end or disconnect&lt;/li&gt; &#xA; &lt;li&gt;Different techniques are used depending on the response type to send the data in packets returning back almost immediately and sending the next packet when this one is received. Any time in between is spent to run the user loop and handle other network packets&lt;/li&gt; &#xA; &lt;li&gt;Responding asynchronously is probably the most difficult thing for most to understand&lt;/li&gt; &#xA; &lt;li&gt;Many different options exist for the user to make responding a background task&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Template processing&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ESPAsyncWebserver contains simple template processing engine.&lt;/li&gt; &#xA; &lt;li&gt;Template processing can be added to most response types.&lt;/li&gt; &#xA; &lt;li&gt;Currently it supports only replacing template placeholders with actual values. No conditional processing, cycles, etc.&lt;/li&gt; &#xA; &lt;li&gt;Placeholders are delimited with &lt;code&gt;%&lt;/code&gt; symbols. Like this: &lt;code&gt;%TEMPLATE_PLACEHOLDER%&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;It works by extracting placeholder name from response text and passing it to user provided function which should return actual value to be used instead of placeholder.&lt;/li&gt; &#xA; &lt;li&gt;Since it&#39;s user provided function, it is possible for library users to implement conditional processing and cycles themselves.&lt;/li&gt; &#xA; &lt;li&gt;Since it&#39;s impossible to know the actual response size after template processing step in advance (and, therefore, to include it in response headers), the response becomes &lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#chunked-response&#34;&gt;chunked&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Libraries and projects that use AsyncWebServer&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hallard/WebSocketToSerial&#34;&gt;WebSocketToSerial&lt;/a&gt; - Debug serial devices through the web browser&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Hopperpop/Sattrack&#34;&gt;Sattrack&lt;/a&gt; - Track the ISS with ESP8266&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Edzelf/Esp-radio&#34;&gt;ESP Radio&lt;/a&gt; - Icecast radio based on ESP8266 and VS1053&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/andig/vzero&#34;&gt;VZero&lt;/a&gt; - the Wireless zero-config controller for volkszaehler.org&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bitbucket.org/xoseperez/espurna&#34;&gt;ESPurna&lt;/a&gt; - ESPurna (&#34;spark&#34; in Catalan) is a custom C firmware for ESP8266 based smart switches. It was originally developed with the ITead Sonoff in mind.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://bitbucket.org/xoseperez/fauxmoesp&#34;&gt;fauxmoESP&lt;/a&gt; - Belkin WeMo emulator library for ESP8266.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/omersiar/esp-rfid&#34;&gt;ESP-RFID&lt;/a&gt; - MFRC522 RFID Access Control Management project for ESP8266.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Request Variables&lt;/h2&gt; &#xA;&lt;h3&gt;Common Variables&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;request-&amp;gt;version();       // uint8_t: 0 = HTTP/1.0, 1 = HTTP/1.1&#xA;request-&amp;gt;method();        // enum:    HTTP_GET, HTTP_POST, HTTP_DELETE, HTTP_PUT, HTTP_PATCH, HTTP_HEAD, HTTP_OPTIONS&#xA;request-&amp;gt;url();           // String:  URL of the request (not including host, port or GET parameters)&#xA;request-&amp;gt;host();          // String:  The requested host (can be used for virtual hosting)&#xA;request-&amp;gt;contentType();   // String:  ContentType of the request (not avaiable in Handler::canHandle)&#xA;request-&amp;gt;contentLength(); // size_t:  ContentLength of the request (not avaiable in Handler::canHandle)&#xA;request-&amp;gt;multipart();     // bool:    True if the request has content type &#34;multipart&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//List all collected headers&#xA;int headers = request-&amp;gt;headers();&#xA;int i;&#xA;for(i=0;i&amp;lt;headers;i++){&#xA;  AsyncWebHeader* h = request-&amp;gt;getHeader(i);&#xA;  Serial.printf(&#34;HEADER[%s]: %s\n&#34;, h-&amp;gt;name().c_str(), h-&amp;gt;value().c_str());&#xA;}&#xA;&#xA;//get specific header by name&#xA;if(request-&amp;gt;hasHeader(&#34;MyHeader&#34;)){&#xA;  AsyncWebHeader* h = request-&amp;gt;getHeader(&#34;MyHeader&#34;);&#xA;  Serial.printf(&#34;MyHeader: %s\n&#34;, h-&amp;gt;value().c_str());&#xA;}&#xA;&#xA;//List all collected headers (Compatibility)&#xA;int headers = request-&amp;gt;headers();&#xA;int i;&#xA;for(i=0;i&amp;lt;headers;i++){&#xA;  Serial.printf(&#34;HEADER[%s]: %s\n&#34;, request-&amp;gt;headerName(i).c_str(), request-&amp;gt;header(i).c_str());&#xA;}&#xA;&#xA;//get specific header by name (Compatibility)&#xA;if(request-&amp;gt;hasHeader(&#34;MyHeader&#34;)){&#xA;  Serial.printf(&#34;MyHeader: %s\n&#34;, request-&amp;gt;header(&#34;MyHeader&#34;).c_str());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GET, POST and FILE parameters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//List all parameters&#xA;int params = request-&amp;gt;params();&#xA;for(int i=0;i&amp;lt;params;i++){&#xA;  AsyncWebParameter* p = request-&amp;gt;getParam(i);&#xA;  if(p-&amp;gt;isFile()){ //p-&amp;gt;isPost() is also true&#xA;    Serial.printf(&#34;FILE[%s]: %s, size: %u\n&#34;, p-&amp;gt;name().c_str(), p-&amp;gt;value().c_str(), p-&amp;gt;size());&#xA;  } else if(p-&amp;gt;isPost()){&#xA;    Serial.printf(&#34;POST[%s]: %s\n&#34;, p-&amp;gt;name().c_str(), p-&amp;gt;value().c_str());&#xA;  } else {&#xA;    Serial.printf(&#34;GET[%s]: %s\n&#34;, p-&amp;gt;name().c_str(), p-&amp;gt;value().c_str());&#xA;  }&#xA;}&#xA;&#xA;//Check if GET parameter exists&#xA;if(request-&amp;gt;hasParam(&#34;download&#34;))&#xA;  AsyncWebParameter* p = request-&amp;gt;getParam(&#34;download&#34;);&#xA;&#xA;//Check if POST (but not File) parameter exists&#xA;if(request-&amp;gt;hasParam(&#34;download&#34;, true))&#xA;  AsyncWebParameter* p = request-&amp;gt;getParam(&#34;download&#34;, true);&#xA;&#xA;//Check if FILE was uploaded&#xA;if(request-&amp;gt;hasParam(&#34;download&#34;, true, true))&#xA;  AsyncWebParameter* p = request-&amp;gt;getParam(&#34;download&#34;, true, true);&#xA;&#xA;//List all parameters (Compatibility)&#xA;int args = request-&amp;gt;args();&#xA;for(int i=0;i&amp;lt;args;i++){&#xA;  Serial.printf(&#34;ARG[%s]: %s\n&#34;, request-&amp;gt;argName(i).c_str(), request-&amp;gt;arg(i).c_str());&#xA;}&#xA;&#xA;//Check if parameter exists (Compatibility)&#xA;if(request-&amp;gt;hasArg(&#34;download&#34;))&#xA;  String arg = request-&amp;gt;arg(&#34;download&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FILE Upload handling&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void handleUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){&#xA;  if(!index){&#xA;    Serial.printf(&#34;UploadStart: %s\n&#34;, filename.c_str());&#xA;  }&#xA;  for(size_t i=0; i&amp;lt;len; i++){&#xA;    Serial.write(data[i]);&#xA;  }&#xA;  if(final){&#xA;    Serial.printf(&#34;UploadEnd: %s, %u B\n&#34;, filename.c_str(), index+len);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Body data handling&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void handleBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){&#xA;  if(!index){&#xA;    Serial.printf(&#34;BodyStart: %u B\n&#34;, total);&#xA;  }&#xA;  for(size_t i=0; i&amp;lt;len; i++){&#xA;    Serial.write(data[i]);&#xA;  }&#xA;  if(index + len == total){&#xA;    Serial.printf(&#34;BodyEnd: %u B\n&#34;, total);&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If needed, the &lt;code&gt;_tempObject&lt;/code&gt; field on the request can be used to store a pointer to temporary data (e.g. from the body) associated with the request. If assigned, the pointer will automatically be freed along with the request.&lt;/p&gt; &#xA;&lt;h3&gt;JSON body handling with ArduinoJson&lt;/h3&gt; &#xA;&lt;p&gt;Endpoints which consume JSON can use a special handler to get ready to use JSON data in the request callback:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;AsyncJson.h&#34;&#xA;#include &#34;ArduinoJson.h&#34;&#xA;&#xA;AsyncCallbackJsonWebHandler* handler = new AsyncCallbackJsonWebHandler(&#34;/rest/endpoint&#34;, [](AsyncWebServerRequest *request, JsonVariant &amp;amp;json) {&#xA;  JsonObject&amp;amp; jsonObj = json.as&amp;lt;JsonObject&amp;gt;();&#xA;  // ...&#xA;});&#xA;server.addHandler(handler);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Responses&lt;/h2&gt; &#xA;&lt;h3&gt;Redirect to another URL&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//to local url&#xA;request-&amp;gt;redirect(&#34;/login&#34;);&#xA;&#xA;//to external url&#xA;request-&amp;gt;redirect(&#34;http://esp8266.com&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Basic response with HTTP Code&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;request-&amp;gt;send(404); //Sends 404 File Not Found&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Basic response with HTTP Code and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(404); //Sends 404 File Not Found&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Basic response with string content&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;request-&amp;gt;send(200, &#34;text/plain&#34;, &#34;Hello World!&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Basic response with string content and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(200, &#34;text/plain&#34;, &#34;Hello World!&#34;);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send large webpage from PROGMEM&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char index_html[] PROGMEM = &#34;...&#34;; // large char array, tested with 14k&#xA;request-&amp;gt;send_P(200, &#34;text/html&#34;, index_html);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send large webpage from PROGMEM and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char index_html[] PROGMEM = &#34;...&#34;; // large char array, tested with 14k&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse_P(200, &#34;text/html&#34;, index_html);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send large webpage from PROGMEM containing templates&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;const char index_html[] PROGMEM = &#34;...&#34;; // large char array, tested with 14k&#xA;request-&amp;gt;send_P(200, &#34;text/html&#34;, index_html, processor);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send large webpage from PROGMEM containing templates and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;const char index_html[] PROGMEM = &#34;...&#34;; // large char array, tested with 14k&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse_P(200, &#34;text/html&#34;, index_html, processor);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Send binary content from PROGMEM&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;&#xA;//File: favicon.ico.gz, Size: 726&#xA;#define favicon_ico_gz_len 726&#xA;const uint8_t favicon_ico_gz[] PROGMEM = {&#xA; 0x1F, 0x8B, 0x08, 0x08, 0x0B, 0x87, 0x90, 0x57, 0x00, 0x03, 0x66, 0x61, 0x76, 0x69, 0x63, 0x6F,&#xA; 0x6E, 0x2E, 0x69, 0x63, 0x6F, 0x00, 0xCD, 0x53, 0x5F, 0x48, 0x9A, 0x51, 0x14, 0xBF, 0x62, 0x6D,&#xA; 0x86, 0x96, 0xA9, 0x64, 0xD3, 0xFE, 0xA8, 0x99, 0x65, 0x1A, 0xB4, 0x8A, 0xA8, 0x51, 0x54, 0x23,&#xA; 0xA8, 0x11, 0x49, 0x51, 0x8A, 0x34, 0x62, 0x93, 0x85, 0x31, 0x58, 0x44, 0x12, 0x45, 0x2D, 0x58,&#xA; 0xF5, 0x52, 0x41, 0x10, 0x23, 0x82, 0xA0, 0x20, 0x98, 0x2F, 0xC1, 0x26, 0xED, 0xA1, 0x20, 0x89,&#xA; 0x04, 0xD7, 0x83, 0x58, 0x20, 0x28, 0x04, 0xAB, 0xD1, 0x9B, 0x8C, 0xE5, 0xC3, 0x60, 0x32, 0x64,&#xA; 0x0E, 0x56, 0xBF, 0x9D, 0xEF, 0xF6, 0x30, 0x82, 0xED, 0xAD, 0x87, 0xDD, 0x8F, 0xF3, 0xDD, 0x8F,&#xA; 0x73, 0xCF, 0xEF, 0x9C, 0xDF, 0x39, 0xBF, 0xFB, 0x31, 0x26, 0xA2, 0x27, 0x37, 0x97, 0xD1, 0x5B,&#xA; 0xCF, 0x9E, 0x67, 0x30, 0xA6, 0x66, 0x8C, 0x99, 0xC9, 0xC8, 0x45, 0x9E, 0x6B, 0x3F, 0x5F, 0x74,&#xA; 0xA6, 0x94, 0x5E, 0xDB, 0xFF, 0xB2, 0xE6, 0xE7, 0xE7, 0xF9, 0xDE, 0xD6, 0xD6, 0x96, 0xDB, 0xD8,&#xA; 0xD8, 0x78, 0xBF, 0xA1, 0xA1, 0xC1, 0xDA, 0xDC, 0xDC, 0x2C, 0xEB, 0xED, 0xED, 0x15, 0x9B, 0xCD,&#xA; 0xE6, 0x4A, 0x83, 0xC1, 0xE0, 0x2E, 0x29, 0x29, 0x99, 0xD6, 0x6A, 0xB5, 0x4F, 0x75, 0x3A, 0x9D,&#xA; 0x61, 0x75, 0x75, 0x95, 0xB5, 0xB7, 0xB7, 0xDF, 0xC8, 0xD1, 0xD4, 0xD4, 0xF4, 0xB0, 0xBA, 0xBA,&#xA; 0xFA, 0x83, 0xD5, 0x6A, 0xFD, 0x5A, 0x5E, 0x5E, 0x9E, 0x28, 0x2D, 0x2D, 0x0D, 0x10, 0xC6, 0x4B,&#xA; 0x98, 0x78, 0x5E, 0x5E, 0xDE, 0x95, 0x42, 0xA1, 0x40, 0x4E, 0x4E, 0xCE, 0x65, 0x76, 0x76, 0xF6,&#xA; 0x47, 0xB5, 0x5A, 0x6D, 0x4F, 0x26, 0x93, 0xA2, 0xD6, 0xD6, 0x56, 0x8E, 0x6D, 0x69, 0x69, 0xD1,&#xA; 0x11, 0x36, 0x62, 0xB1, 0x58, 0x60, 0x32, 0x99, 0xA0, 0xD7, 0xEB, 0x51, 0x58, 0x58, 0x88, 0xFC,&#xA; 0xFC, 0x7C, 0x10, 0x16, 0x02, 0x56, 0x2E, 0x97, 0x43, 0x2A, 0x95, 0x42, 0x2C, 0x16, 0x23, 0x33,&#xA; 0x33, 0x33, 0xAE, 0x52, 0xA9, 0x1E, 0x64, 0x65, 0x65, 0x71, 0x7C, 0x7D, 0x7D, 0xBD, 0x93, 0xEA,&#xA; 0xFE, 0x30, 0x1A, 0x8D, 0xE8, 0xEC, 0xEC, 0xC4, 0xE2, 0xE2, 0x22, 0x6A, 0x6A, 0x6A, 0x40, 0x39,&#xA; 0x41, 0xB5, 0x38, 0x4E, 0xC8, 0x33, 0x3C, 0x3C, 0x0C, 0x87, 0xC3, 0xC1, 0x6B, 0x54, 0x54, 0x54,&#xA; 0xBC, 0xE9, 0xEB, 0xEB, 0x93, 0x5F, 0x5C, 0x5C, 0x30, 0x8A, 0x9D, 0x2E, 0x2B, 0x2B, 0xBB, 0xA2,&#xA; 0x3E, 0x41, 0xBD, 0x21, 0x1E, 0x8F, 0x63, 0x6A, 0x6A, 0x0A, 0x81, 0x40, 0x00, 0x94, 0x1B, 0x3D,&#xA; 0x3D, 0x3D, 0x42, 0x3C, 0x96, 0x96, 0x96, 0x70, 0x7E, 0x7E, 0x8E, 0xE3, 0xE3, 0x63, 0xF8, 0xFD,&#xA; 0xFE, 0xB4, 0xD7, 0xEB, 0xF5, 0x8F, 0x8F, 0x8F, 0x5B, 0x68, 0x5E, 0x6F, 0x05, 0xCE, 0xB4, 0xE3,&#xA; 0xE8, 0xE8, 0x08, 0x27, 0x27, 0x27, 0xD8, 0xDF, 0xDF, 0xC7, 0xD9, 0xD9, 0x19, 0x6C, 0x36, 0x1B,&#xA; 0x36, 0x36, 0x36, 0x38, 0x9F, 0x85, 0x85, 0x05, 0xAC, 0xAF, 0xAF, 0x23, 0x1A, 0x8D, 0x22, 0x91,&#xA; 0x48, 0x20, 0x16, 0x8B, 0xFD, 0xDA, 0xDA, 0xDA, 0x7A, 0x41, 0x33, 0x7E, 0x57, 0x50, 0x50, 0x80,&#xA; 0x89, 0x89, 0x09, 0x84, 0xC3, 0x61, 0x6C, 0x6F, 0x6F, 0x23, 0x12, 0x89, 0xE0, 0xE0, 0xE0, 0x00,&#xA; 0x43, 0x43, 0x43, 0x58, 0x5E, 0x5E, 0xE6, 0x9C, 0x7D, 0x3E, 0x1F, 0x46, 0x47, 0x47, 0x79, 0xBE,&#xA; 0xBD, 0xBD, 0x3D, 0xE1, 0x3C, 0x1D, 0x0C, 0x06, 0x9F, 0x10, 0xB7, 0xC7, 0x84, 0x4F, 0xF6, 0xF7,&#xA; 0xF7, 0x63, 0x60, 0x60, 0x00, 0x83, 0x83, 0x83, 0x18, 0x19, 0x19, 0xC1, 0xDC, 0xDC, 0x1C, 0x8F,&#xA; 0x17, 0x7C, 0xA4, 0x27, 0xE7, 0x34, 0x39, 0x39, 0x89, 0x9D, 0x9D, 0x1D, 0x6E, 0x54, 0xE3, 0x13,&#xA; 0xE5, 0x34, 0x11, 0x37, 0x49, 0x51, 0x51, 0xD1, 0x4B, 0xA5, 0x52, 0xF9, 0x45, 0x26, 0x93, 0x5D,&#xA; 0x0A, 0xF3, 0x92, 0x48, 0x24, 0xA0, 0x6F, 0x14, 0x17, 0x17, 0xA3, 0xB6, 0xB6, 0x16, 0x5D, 0x5D,&#xA; 0x5D, 0x7C, 0x1E, 0xBB, 0xBB, 0xBB, 0x9C, 0xD7, 0xE1, 0xE1, 0x21, 0x42, 0xA1, 0xD0, 0x6B, 0xD2,&#xA; 0x45, 0x4C, 0x33, 0x12, 0x34, 0xCC, 0xA0, 0x19, 0x54, 0x92, 0x56, 0x0E, 0xD2, 0xD9, 0x43, 0xF8,&#xA; 0xCF, 0x82, 0x56, 0xC2, 0xDC, 0xEB, 0xEA, 0xEA, 0x38, 0x7E, 0x6C, 0x6C, 0x4C, 0xE0, 0xFE, 0x9D,&#xA; 0xB8, 0xBF, 0xA7, 0xFA, 0xAF, 0x56, 0x56, 0x56, 0xEE, 0x6D, 0x6E, 0x6E, 0xDE, 0xB8, 0x47, 0x55,&#xA; 0x55, 0x55, 0x6C, 0x66, 0x66, 0x46, 0x44, 0xDA, 0x3B, 0x34, 0x1A, 0x4D, 0x94, 0xB0, 0x3F, 0x09,&#xA; 0x7B, 0x45, 0xBD, 0xA5, 0x5D, 0x2E, 0x57, 0x8C, 0x7A, 0x73, 0xD9, 0xED, 0xF6, 0x3B, 0x84, 0xFF,&#xA; 0xE7, 0x7D, 0xA6, 0x3A, 0x2C, 0x95, 0x4A, 0xB1, 0x8E, 0x8E, 0x0E, 0x6D, 0x77, 0x77, 0xB7, 0xCD,&#xA; 0xE9, 0x74, 0x3E, 0x73, 0xBB, 0xDD, 0x8F, 0x3C, 0x1E, 0x8F, 0xE6, 0xF4, 0xF4, 0x94, 0xAD, 0xAD,&#xA; 0xAD, 0xDD, 0xDE, 0xCF, 0x73, 0x0B, 0x0B, 0xB8, 0xB6, 0xE0, 0x5D, 0xC6, 0x66, 0xC5, 0xE4, 0x10,&#xA; 0x4C, 0xF4, 0xF7, 0xD8, 0x59, 0xF2, 0x7F, 0xA3, 0xB8, 0xB4, 0xFC, 0x0F, 0xEE, 0x37, 0x70, 0xEC,&#xA; 0x16, 0x4A, 0x7E, 0x04, 0x00, 0x00&#xA;};&#xA;&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse_P(200, &#34;image/x-icon&#34;, favicon_ico_gz, favicon_ico_gz_len);&#xA;response-&amp;gt;addHeader(&#34;Content-Encoding&#34;, &#34;gzip&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a Stream&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//read 12 bytes from Serial and send them as Content Type text/plain&#xA;request-&amp;gt;send(Serial, &#34;text/plain&#34;, 12);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a Stream and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//read 12 bytes from Serial and send them as Content Type text/plain&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(Serial, &#34;text/plain&#34;, 12);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a Stream containing templates&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;//read 12 bytes from Serial and send them as Content Type text/plain&#xA;request-&amp;gt;send(Serial, &#34;text/plain&#34;, 12, processor);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a Stream containing templates and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;//read 12 bytes from Serial and send them as Content Type text/plain&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(Serial, &#34;text/plain&#34;, 12, processor);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a File&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//Send index.htm with default content type&#xA;request-&amp;gt;send(SPIFFS, &#34;/index.htm&#34;);&#xA;&#xA;//Send index.htm as text&#xA;request-&amp;gt;send(SPIFFS, &#34;/index.htm&#34;, &#34;text/plain&#34;);&#xA;&#xA;//Download index.htm&#xA;request-&amp;gt;send(SPIFFS, &#34;/index.htm&#34;, String(), true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a File and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//Send index.htm with default content type&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(SPIFFS, &#34;/index.htm&#34;);&#xA;&#xA;//Send index.htm as text&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(SPIFFS, &#34;/index.htm&#34;, &#34;text/plain&#34;);&#xA;&#xA;//Download index.htm&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(SPIFFS, &#34;/index.htm&#34;, String(), true);&#xA;&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content coming from a File containing templates&lt;/h3&gt; &#xA;&lt;p&gt;Internally uses &lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#chunked-response&#34;&gt;Chunked Response&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Index.htm contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;%HELLO_FROM_TEMPLATE%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Somewhere in source files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;//Send index.htm with template processor function&#xA;request-&amp;gt;send(SPIFFS, &#34;/index.htm&#34;, String(), false, processor);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content using a callback&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//send 128 bytes as plain text&#xA;request-&amp;gt;send(&#34;text/plain&#34;, 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //index equals the amount of bytes that have been already sent&#xA;  //You will not be asked for more bytes once the content length has been reached.&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  //Send what you currently have and you will be asked for more again&#xA;  return mySource.read(buffer, maxLen);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content using a callback and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//send 128 bytes as plain text&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(&#34;text/plain&#34;, 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //index equals the amount of bytes that have been already sent&#xA;  //You will not be asked for more bytes once the content length has been reached.&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  //Send what you currently have and you will be asked for more again&#xA;  return mySource.read(buffer, maxLen);&#xA;});&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content using a callback containing templates&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;//send 128 bytes as plain text&#xA;request-&amp;gt;send(&#34;text/plain&#34;, 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //index equals the amount of bytes that have been already sent&#xA;  //You will not be asked for more bytes once the content length has been reached.&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  //Send what you currently have and you will be asked for more again&#xA;  return mySource.read(buffer, maxLen);&#xA;}, processor);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Respond with content using a callback containing templates and extra headers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;//send 128 bytes as plain text&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginResponse(&#34;text/plain&#34;, 128, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //index equals the amount of bytes that have been already sent&#xA;  //You will not be asked for more bytes once the content length has been reached.&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  //Send what you currently have and you will be asked for more again&#xA;  return mySource.read(buffer, maxLen);&#xA;}, processor);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chunked Response&lt;/h3&gt; &#xA;&lt;p&gt;Used when content length is unknown. Works best if the client supports HTTP/1.1&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;AsyncWebServerResponse *response = request-&amp;gt;beginChunkedResponse(&#34;text/plain&#34;, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //index equals the amount of bytes that have been already sent&#xA;  //You will be asked for more data until 0 is returned&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  return mySource.read(buffer, maxLen);&#xA;});&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Chunked Response containing templates&lt;/h3&gt; &#xA;&lt;p&gt;Used when content length is unknown. Works best if the client supports HTTP/1.1&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;AsyncWebServerResponse *response = request-&amp;gt;beginChunkedResponse(&#34;text/plain&#34;, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //index equals the amount of bytes that have been already sent&#xA;  //You will be asked for more data until 0 is returned&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  return mySource.read(buffer, maxLen);&#xA;}, processor);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Print to response&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;AsyncResponseStream *response = request-&amp;gt;beginResponseStream(&#34;text/html&#34;);&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;response-&amp;gt;printf(&#34;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Webpage at %s&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&#34;, request-&amp;gt;url().c_str());&#xA;&#xA;response-&amp;gt;print(&#34;&amp;lt;h2&amp;gt;Hello &#34;);&#xA;response-&amp;gt;print(request-&amp;gt;client()-&amp;gt;remoteIP());&#xA;response-&amp;gt;print(&#34;&amp;lt;/h2&amp;gt;&#34;);&#xA;&#xA;response-&amp;gt;print(&#34;&amp;lt;h3&amp;gt;General&amp;lt;/h3&amp;gt;&#34;);&#xA;response-&amp;gt;print(&#34;&amp;lt;ul&amp;gt;&#34;);&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;Version: HTTP/1.%u&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;version());&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;Method: %s&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;methodToString());&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;URL: %s&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;url().c_str());&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;Host: %s&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;host().c_str());&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;ContentType: %s&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;contentType().c_str());&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;ContentLength: %u&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;contentLength());&#xA;response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;Multipart: %s&amp;lt;/li&amp;gt;&#34;, request-&amp;gt;multipart()?&#34;true&#34;:&#34;false&#34;);&#xA;response-&amp;gt;print(&#34;&amp;lt;/ul&amp;gt;&#34;);&#xA;&#xA;response-&amp;gt;print(&#34;&amp;lt;h3&amp;gt;Headers&amp;lt;/h3&amp;gt;&#34;);&#xA;response-&amp;gt;print(&#34;&amp;lt;ul&amp;gt;&#34;);&#xA;int headers = request-&amp;gt;headers();&#xA;for(int i=0;i&amp;lt;headers;i++){&#xA;  AsyncWebHeader* h = request-&amp;gt;getHeader(i);&#xA;  response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;%s: %s&amp;lt;/li&amp;gt;&#34;, h-&amp;gt;name().c_str(), h-&amp;gt;value().c_str());&#xA;}&#xA;response-&amp;gt;print(&#34;&amp;lt;/ul&amp;gt;&#34;);&#xA;&#xA;response-&amp;gt;print(&#34;&amp;lt;h3&amp;gt;Parameters&amp;lt;/h3&amp;gt;&#34;);&#xA;response-&amp;gt;print(&#34;&amp;lt;ul&amp;gt;&#34;);&#xA;int params = request-&amp;gt;params();&#xA;for(int i=0;i&amp;lt;params;i++){&#xA;  AsyncWebParameter* p = request-&amp;gt;getParam(i);&#xA;  if(p-&amp;gt;isFile()){&#xA;    response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;FILE[%s]: %s, size: %u&amp;lt;/li&amp;gt;&#34;, p-&amp;gt;name().c_str(), p-&amp;gt;value().c_str(), p-&amp;gt;size());&#xA;  } else if(p-&amp;gt;isPost()){&#xA;    response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;POST[%s]: %s&amp;lt;/li&amp;gt;&#34;, p-&amp;gt;name().c_str(), p-&amp;gt;value().c_str());&#xA;  } else {&#xA;    response-&amp;gt;printf(&#34;&amp;lt;li&amp;gt;GET[%s]: %s&amp;lt;/li&amp;gt;&#34;, p-&amp;gt;name().c_str(), p-&amp;gt;value().c_str());&#xA;  }&#xA;}&#xA;response-&amp;gt;print(&#34;&amp;lt;/ul&amp;gt;&#34;);&#xA;&#xA;response-&amp;gt;print(&#34;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#34;);&#xA;//send the response last&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ArduinoJson Basic Response&lt;/h3&gt; &#xA;&lt;p&gt;This way of sending Json is great for when the result is below 4KB&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;AsyncJson.h&#34;&#xA;#include &#34;ArduinoJson.h&#34;&#xA;&#xA;&#xA;AsyncResponseStream *response = request-&amp;gt;beginResponseStream(&#34;application/json&#34;);&#xA;DynamicJsonBuffer jsonBuffer;&#xA;JsonObject &amp;amp;root = jsonBuffer.createObject();&#xA;root[&#34;heap&#34;] = ESP.getFreeHeap();&#xA;root[&#34;ssid&#34;] = WiFi.SSID();&#xA;root.printTo(*response);&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ArduinoJson Advanced Response&lt;/h3&gt; &#xA;&lt;p&gt;This response can handle really large Json objects (tested to 40KB) There isn&#39;t any noticeable speed decrease for small results with the method above Since ArduinoJson does not allow reading parts of the string, the whole Json has to be passed every time a chunks needs to be sent, which shows speed decrease proportional to the resulting json packets&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;AsyncJson.h&#34;&#xA;#include &#34;ArduinoJson.h&#34;&#xA;&#xA;&#xA;AsyncJsonResponse * response = new AsyncJsonResponse();&#xA;response-&amp;gt;addHeader(&#34;Server&#34;,&#34;ESP Async Web Server&#34;);&#xA;JsonObject&amp;amp; root = response-&amp;gt;getRoot();&#xA;root[&#34;heap&#34;] = ESP.getFreeHeap();&#xA;root[&#34;ssid&#34;] = WiFi.SSID();&#xA;response-&amp;gt;setLength();&#xA;request-&amp;gt;send(response);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Serving static files&lt;/h2&gt; &#xA;&lt;p&gt;In addition to serving files from SPIFFS as described above, the server provide a dedicated handler that optimize the performance of serving files from SPIFFS - &lt;code&gt;AsyncStaticWebHandler&lt;/code&gt;. Use &lt;code&gt;server.serveStatic()&lt;/code&gt; function to initialize and add a new instance of &lt;code&gt;AsyncStaticWebHandler&lt;/code&gt; to the server. The Handler will not handle the request if the file does not exists, e.g. the server will continue to look for another handler that can handle the request. Notice that you can chain setter functions to setup the handler, or keep a pointer to change it at a later time.&lt;/p&gt; &#xA;&lt;h3&gt;Serving specific file by name&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Serve the file &#34;/www/page.htm&#34; when request url is &#34;/page.htm&#34;&#xA;server.serveStatic(&#34;/page.htm&#34;, SPIFFS, &#34;/www/page.htm&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serving files in directory&lt;/h3&gt; &#xA;&lt;p&gt;To serve files in a directory, the path to the files should specify a directory in SPIFFS and ends with &#34;/&#34;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Serve files in directory &#34;/www/&#34; when request url starts with &#34;/&#34;&#xA;// Request to the root or none existing files will try to server the defualt&#xA;// file name &#34;index.htm&#34; if exists&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;);&#xA;&#xA;// Server with different default file&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;).setDefaultFile(&#34;default.html&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serving static files with authentication&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;server&#xA;    .serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;)&#xA;    .setDefaultFile(&#34;default.html&#34;)&#xA;    .setAuthentication(&#34;user&#34;, &#34;pass&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying Cache-Control header&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to specify Cache-Control header value to reduce the number of calls to the server once the client loaded the files. For more information on Cache-Control values see &lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9&#34;&gt;Cache-Control&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Cache responses for 10 minutes (600 seconds)&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;).setCacheControl(&#34;max-age=600&#34;);&#xA;&#xA;//*** Change Cache-Control after server setup ***&#xA;&#xA;// During setup - keep a pointer to the handler&#xA;AsyncStaticWebHandler* handler = &amp;amp;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;).setCacheControl(&#34;max-age=600&#34;);&#xA;&#xA;// At a later event - change Cache-Control&#xA;handler-&amp;gt;setCacheControl(&#34;max-age=30&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying Date-Modified header&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to specify Date-Modified header to enable the server to return Not-Modified (304) response for requests with &#34;If-Modified-Since&#34; header with the same value, instead of responding with the actual file content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Update the date modified string every time files are updated&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;).setLastModified(&#34;Mon, 20 Jun 2016 14:00:00 GMT&#34;);&#xA;&#xA;//*** Chage last modified value at a later stage ***&#xA;&#xA;// During setup - read last modified value from config or EEPROM&#xA;String date_modified = loadDateModified();&#xA;AsyncStaticWebHandler* handler = &amp;amp;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;);&#xA;handler-&amp;gt;setLastModified(date_modified);&#xA;&#xA;// At a later event when files are updated&#xA;String date_modified = getNewDateModfied();&#xA;saveDateModified(date_modified); // Save for next reset&#xA;handler-&amp;gt;setLastModified(date_modified);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specifying Template Processor callback&lt;/h3&gt; &#xA;&lt;p&gt;It is possible to specify template processor for static files. For information on template processor see &lt;a href=&#34;https://raw.githubusercontent.com/me-no-dev/ESPAsyncWebServer/master/#respond-with-content-coming-from-a-file-containing-templates&#34;&gt;Respond with content coming from a File containing templates&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String processor(const String&amp;amp; var)&#xA;{&#xA;  if(var == &#34;HELLO_FROM_TEMPLATE&#34;)&#xA;    return F(&#34;Hello world!&#34;);&#xA;  return String();&#xA;}&#xA;&#xA;// ...&#xA;&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;).setTemplateProcessor(processor);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Param Rewrite With Matching&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to rewrite the request url with parameter matchg. Here is an example with one parameter: Rewrite for example &#34;/radio/{frequence}&#34; -&amp;gt; &#34;/radio?f={frequence}&#34;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class OneParamRewrite : public AsyncWebRewrite&#xA;{&#xA;  protected:&#xA;    String _urlPrefix;&#xA;    int _paramIndex;&#xA;    String _paramsBackup;&#xA;&#xA;  public:&#xA;  OneParamRewrite(const char* from, const char* to)&#xA;    : AsyncWebRewrite(from, to) {&#xA;&#xA;      _paramIndex = _from.indexOf(&#39;{&#39;);&#xA;&#xA;      if( _paramIndex &amp;gt;=0 &amp;amp;&amp;amp; _from.endsWith(&#34;}&#34;)) {&#xA;        _urlPrefix = _from.substring(0, _paramIndex);&#xA;        int index = _params.indexOf(&#39;{&#39;);&#xA;        if(index &amp;gt;= 0) {&#xA;          _params = _params.substring(0, index);&#xA;        }&#xA;      } else {&#xA;        _urlPrefix = _from;&#xA;      }&#xA;      _paramsBackup = _params;&#xA;  }&#xA;&#xA;  bool match(AsyncWebServerRequest *request) override {&#xA;    if(request-&amp;gt;url().startsWith(_urlPrefix)) {&#xA;      if(_paramIndex &amp;gt;= 0) {&#xA;        _params = _paramsBackup + request-&amp;gt;url().substring(_paramIndex);&#xA;      } else {&#xA;        _params = _paramsBackup;&#xA;      }&#xA;    return true;&#xA;&#xA;    } else {&#xA;      return false;&#xA;    }&#xA;  }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  server.addRewrite( new OneParamRewrite(&#34;/radio/{frequence}&#34;, &#34;/radio?f={frequence}&#34;) );&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using filters&lt;/h2&gt; &#xA;&lt;p&gt;Filters can be set to &lt;code&gt;Rewrite&lt;/code&gt; or &lt;code&gt;Handler&lt;/code&gt; in order to control when to apply the rewrite and consider the handler. A filter is a callback function that evaluates the request and return a boolean &lt;code&gt;true&lt;/code&gt; to include the item or &lt;code&gt;false&lt;/code&gt; to exclude it. Two filter callback are provided for convince:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ON_STA_FILTER&lt;/code&gt; - return true when requests are made to the STA (station mode) interface.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ON_AP_FILTER&lt;/code&gt; - return true when requests are made to the AP (access point) interface.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Serve different site files in AP mode&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;).setFilter(ON_STA_FILTER);&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/ap/&#34;).setFilter(ON_AP_FILTER);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rewrite to different index on AP&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Serve the file &#34;/www/index-ap.htm&#34; in AP, and the file &#34;/www/index.htm&#34; on STA&#xA;server.rewrite(&#34;/&#34;, &#34;index.htm&#34;);&#xA;server.rewrite(&#34;/index.htm&#34;, &#34;index-ap.htm&#34;).setFilter(ON_AP_FILTER);&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Serving different hosts&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Filter callback using request host&#xA;bool filterOnHost1(AsyncWebServerRequest *request) { return request-&amp;gt;host() == &#34;host1&#34;; }&#xA;&#xA;// Server setup: server files in &#34;/host1/&#34; to requests for &#34;host1&#34;, and files in &#34;/www/&#34; otherwise.&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/host1/&#34;).setFilter(filterOnHost1);&#xA;server.serveStatic(&#34;/&#34;, SPIFFS, &#34;/www/&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Determine interface inside callbacks&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  String RedirectUrl = &#34;http://&#34;;&#xA;  if (ON_STA_FILTER(request)) {&#xA;    RedirectUrl += WiFi.localIP().toString();&#xA;  } else {&#xA;    RedirectUrl += WiFi.softAPIP().toString();&#xA;  }&#xA;  RedirectUrl += &#34;/index.htm&#34;;&#xA;  request-&amp;gt;redirect(RedirectUrl);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Bad Responses&lt;/h2&gt; &#xA;&lt;p&gt;Some responses are implemented, but you should not use them, because they do not conform to HTTP. The following example will lead to unclean close of the connection and more time wasted than providing the length of the content&lt;/p&gt; &#xA;&lt;h3&gt;Respond with content using a callback without content length to HTTP/1.0 clients&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//This is used as fallback for chunked responses to HTTP/1.0 Clients&#xA;request-&amp;gt;send(&#34;text/plain&#34;, 0, [](uint8_t *buffer, size_t maxLen, size_t index) -&amp;gt; size_t {&#xA;  //Write up to &#34;maxLen&#34; bytes into &#34;buffer&#34; and return the amount written.&#xA;  //You will be asked for more data until 0 is returned&#xA;  //Keep in mind that you can not delay or yield waiting for more data!&#xA;  return mySource.read(buffer, maxLen);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Async WebSocket Plugin&lt;/h2&gt; &#xA;&lt;p&gt;The server includes a web socket plugin which lets you define different WebSocket locations to connect to without starting another listening service or using different port&lt;/p&gt; &#xA;&lt;h3&gt;Async WebSocket Event&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;&#xA;void onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){&#xA;  if(type == WS_EVT_CONNECT){&#xA;    //client connected&#xA;    os_printf(&#34;ws[%s][%u] connect\n&#34;, server-&amp;gt;url(), client-&amp;gt;id());&#xA;    client-&amp;gt;printf(&#34;Hello Client %u :)&#34;, client-&amp;gt;id());&#xA;    client-&amp;gt;ping();&#xA;  } else if(type == WS_EVT_DISCONNECT){&#xA;    //client disconnected&#xA;    os_printf(&#34;ws[%s][%u] disconnect: %u\n&#34;, server-&amp;gt;url(), client-&amp;gt;id());&#xA;  } else if(type == WS_EVT_ERROR){&#xA;    //error was received from the other end&#xA;    os_printf(&#34;ws[%s][%u] error(%u): %s\n&#34;, server-&amp;gt;url(), client-&amp;gt;id(), *((uint16_t*)arg), (char*)data);&#xA;  } else if(type == WS_EVT_PONG){&#xA;    //pong message was received (in response to a ping request maybe)&#xA;    os_printf(&#34;ws[%s][%u] pong[%u]: %s\n&#34;, server-&amp;gt;url(), client-&amp;gt;id(), len, (len)?(char*)data:&#34;&#34;);&#xA;  } else if(type == WS_EVT_DATA){&#xA;    //data packet&#xA;    AwsFrameInfo * info = (AwsFrameInfo*)arg;&#xA;    if(info-&amp;gt;final &amp;amp;&amp;amp; info-&amp;gt;index == 0 &amp;amp;&amp;amp; info-&amp;gt;len == len){&#xA;      //the whole message is in a single frame and we got all of it&#39;s data&#xA;      os_printf(&#34;ws[%s][%u] %s-message[%llu]: &#34;, server-&amp;gt;url(), client-&amp;gt;id(), (info-&amp;gt;opcode == WS_TEXT)?&#34;text&#34;:&#34;binary&#34;, info-&amp;gt;len);&#xA;      if(info-&amp;gt;opcode == WS_TEXT){&#xA;        data[len] = 0;&#xA;        os_printf(&#34;%s\n&#34;, (char*)data);&#xA;      } else {&#xA;        for(size_t i=0; i &amp;lt; info-&amp;gt;len; i++){&#xA;          os_printf(&#34;%02x &#34;, data[i]);&#xA;        }&#xA;        os_printf(&#34;\n&#34;);&#xA;      }&#xA;      if(info-&amp;gt;opcode == WS_TEXT)&#xA;        client-&amp;gt;text(&#34;I got your text message&#34;);&#xA;      else&#xA;        client-&amp;gt;binary(&#34;I got your binary message&#34;);&#xA;    } else {&#xA;      //message is comprised of multiple frames or the frame is split into multiple packets&#xA;      if(info-&amp;gt;index == 0){&#xA;        if(info-&amp;gt;num == 0)&#xA;          os_printf(&#34;ws[%s][%u] %s-message start\n&#34;, server-&amp;gt;url(), client-&amp;gt;id(), (info-&amp;gt;message_opcode == WS_TEXT)?&#34;text&#34;:&#34;binary&#34;);&#xA;        os_printf(&#34;ws[%s][%u] frame[%u] start[%llu]\n&#34;, server-&amp;gt;url(), client-&amp;gt;id(), info-&amp;gt;num, info-&amp;gt;len);&#xA;      }&#xA;&#xA;      os_printf(&#34;ws[%s][%u] frame[%u] %s[%llu - %llu]: &#34;, server-&amp;gt;url(), client-&amp;gt;id(), info-&amp;gt;num, (info-&amp;gt;message_opcode == WS_TEXT)?&#34;text&#34;:&#34;binary&#34;, info-&amp;gt;index, info-&amp;gt;index + len);&#xA;      if(info-&amp;gt;message_opcode == WS_TEXT){&#xA;        data[len] = 0;&#xA;        os_printf(&#34;%s\n&#34;, (char*)data);&#xA;      } else {&#xA;        for(size_t i=0; i &amp;lt; len; i++){&#xA;          os_printf(&#34;%02x &#34;, data[i]);&#xA;        }&#xA;        os_printf(&#34;\n&#34;);&#xA;      }&#xA;&#xA;      if((info-&amp;gt;index + len) == info-&amp;gt;len){&#xA;        os_printf(&#34;ws[%s][%u] frame[%u] end[%llu]\n&#34;, server-&amp;gt;url(), client-&amp;gt;id(), info-&amp;gt;num, info-&amp;gt;len);&#xA;        if(info-&amp;gt;final){&#xA;          os_printf(&#34;ws[%s][%u] %s-message end\n&#34;, server-&amp;gt;url(), client-&amp;gt;id(), (info-&amp;gt;message_opcode == WS_TEXT)?&#34;text&#34;:&#34;binary&#34;);&#xA;          if(info-&amp;gt;message_opcode == WS_TEXT)&#xA;            client-&amp;gt;text(&#34;I got your text message&#34;);&#xA;          else&#xA;            client-&amp;gt;binary(&#34;I got your binary message&#34;);&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Methods for sending data to a socket client&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;&#xA;&#xA;&#xA;//Server methods&#xA;AsyncWebSocket ws(&#34;/ws&#34;);&#xA;//printf to a client&#xA;ws.printf((uint32_t)client_id, arguments...);&#xA;//printf to all clients&#xA;ws.printfAll(arguments...);&#xA;//printf_P to a client&#xA;ws.printf_P((uint32_t)client_id, PSTR(format), arguments...);&#xA;//printfAll_P to all clients&#xA;ws.printfAll_P(PSTR(format), arguments...);&#xA;//send text to a client&#xA;ws.text((uint32_t)client_id, (char*)text);&#xA;ws.text((uint32_t)client_id, (uint8_t*)text, (size_t)len);&#xA;//send text from PROGMEM to a client&#xA;ws.text((uint32_t)client_id, PSTR(&#34;text&#34;));&#xA;const char flash_text[] PROGMEM = &#34;Text to send&#34;&#xA;ws.text((uint32_t)client_id, FPSTR(flash_text));&#xA;//send text to all clients&#xA;ws.textAll((char*)text);&#xA;ws.textAll((uint8_t*)text, (size_t)len);&#xA;//send binary to a client&#xA;ws.binary((uint32_t)client_id, (char*)binary);&#xA;ws.binary((uint32_t)client_id, (uint8_t*)binary, (size_t)len);&#xA;//send binary from PROGMEM to a client&#xA;const uint8_t flash_binary[] PROGMEM = { 0x01, 0x02, 0x03, 0x04 };&#xA;ws.binary((uint32_t)client_id, flash_binary, 4);&#xA;//send binary to all clients&#xA;ws.binaryAll((char*)binary);&#xA;ws.binaryAll((uint8_t*)binary, (size_t)len);&#xA;//HTTP Authenticate before switch to Websocket protocol&#xA;ws.setAuthentication(&#34;user&#34;, &#34;pass&#34;);&#xA;&#xA;//client methods&#xA;AsyncWebSocketClient * client;&#xA;//printf&#xA;client-&amp;gt;printf(arguments...);&#xA;//printf_P&#xA;client-&amp;gt;printf_P(PSTR(format), arguments...);&#xA;//send text&#xA;client-&amp;gt;text((char*)text);&#xA;client-&amp;gt;text((uint8_t*)text, (size_t)len);&#xA;//send text from PROGMEM&#xA;client-&amp;gt;text(PSTR(&#34;text&#34;));&#xA;const char flash_text[] PROGMEM = &#34;Text to send&#34;;&#xA;client-&amp;gt;text(FPSTR(flash_text));&#xA;//send binary&#xA;client-&amp;gt;binary((char*)binary);&#xA;client-&amp;gt;binary((uint8_t*)binary, (size_t)len);&#xA;//send binary from PROGMEM&#xA;const uint8_t flash_binary[] PROGMEM = { 0x01, 0x02, 0x03, 0x04 };&#xA;client-&amp;gt;binary(flash_binary, 4);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Direct access to web socket message buffer&lt;/h3&gt; &#xA;&lt;p&gt;When sending a web socket message using the above methods a buffer is created. Under certain circumstances you might want to manipulate or populate this buffer directly from your application, for example to prevent unnecessary duplications of the data. This example below shows how to create a buffer and print data to it from an ArduinoJson object then send it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void sendDataWs(AsyncWebSocketClient * client)&#xA;{&#xA;    DynamicJsonBuffer jsonBuffer;&#xA;    JsonObject&amp;amp; root = jsonBuffer.createObject();&#xA;    root[&#34;a&#34;] = &#34;abc&#34;;&#xA;    root[&#34;b&#34;] = &#34;abcd&#34;;&#xA;    root[&#34;c&#34;] = &#34;abcde&#34;;&#xA;    root[&#34;d&#34;] = &#34;abcdef&#34;;&#xA;    root[&#34;e&#34;] = &#34;abcdefg&#34;;&#xA;    size_t len = root.measureLength();&#xA;    AsyncWebSocketMessageBuffer * buffer = ws.makeBuffer(len); //  creates a buffer (len + 1) for you.&#xA;    if (buffer) {&#xA;        root.printTo((char *)buffer-&amp;gt;get(), len + 1);&#xA;        if (client) {&#xA;            client-&amp;gt;text(buffer);&#xA;        } else {&#xA;            ws.textAll(buffer);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Limiting the number of web socket clients&lt;/h3&gt; &#xA;&lt;p&gt;Browsers sometimes do not correctly close the websocket connection, even when the close() function is called in javascript. This will eventually exhaust the web server&#39;s resources and will cause the server to crash. Periodically calling the cleanClients() function from the main loop() function limits the number of clients by closing the oldest client when the maximum number of clients has been exceeded. This can called be every cycle, however, if you wish to use less power, then calling as infrequently as once per second is sufficient.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void loop(){&#xA;  ws.cleanupClients();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Async Event Source Plugin&lt;/h2&gt; &#xA;&lt;p&gt;The server includes EventSource (Server-Sent Events) plugin which can be used to send short text events to the browser. Difference between EventSource and WebSockets is that EventSource is single direction, text-only protocol.&lt;/p&gt; &#xA;&lt;h3&gt;Setup Event Source on the server&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;AsyncWebServer server(80);&#xA;AsyncEventSource events(&#34;/events&#34;);&#xA;&#xA;void setup(){&#xA;  // setup ......&#xA;  events.onConnect([](AsyncEventSourceClient *client){&#xA;    if(client-&amp;gt;lastId()){&#xA;      Serial.printf(&#34;Client reconnected! Last message ID that it gat is: %u\n&#34;, client-&amp;gt;lastId());&#xA;    }&#xA;    //send event with message &#34;hello!&#34;, id current millis&#xA;    // and set reconnect delay to 1 second&#xA;    client-&amp;gt;send(&#34;hello!&#34;,NULL,millis(),1000);&#xA;  });&#xA;  //HTTP Basic authentication&#xA;  events.setAuthentication(&#34;user&#34;, &#34;pass&#34;);&#xA;  server.addHandler(&amp;amp;events);&#xA;  // setup ......&#xA;}&#xA;&#xA;void loop(){&#xA;  if(eventTriggered){ // your logic here&#xA;    //send event &#34;myevent&#34;&#xA;    events.send(&#34;my event content&#34;,&#34;myevent&#34;,millis());&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setup Event Source in the browser&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (!!window.EventSource) {&#xA;  var source = new EventSource(&#39;/events&#39;);&#xA;&#xA;  source.addEventListener(&#39;open&#39;, function(e) {&#xA;    console.log(&#34;Events Connected&#34;);&#xA;  }, false);&#xA;&#xA;  source.addEventListener(&#39;error&#39;, function(e) {&#xA;    if (e.target.readyState != EventSource.OPEN) {&#xA;      console.log(&#34;Events Disconnected&#34;);&#xA;    }&#xA;  }, false);&#xA;&#xA;  source.addEventListener(&#39;message&#39;, function(e) {&#xA;    console.log(&#34;message&#34;, e.data);&#xA;  }, false);&#xA;&#xA;  source.addEventListener(&#39;myevent&#39;, function(e) {&#xA;    console.log(&#34;myevent&#34;, e.data);&#xA;  }, false);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Scanning for available WiFi Networks&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//First request will return 0 results unless you start scan from somewhere else (loop/setup)&#xA;//Do not request more often than 3-5 seconds&#xA;server.on(&#34;/scan&#34;, HTTP_GET, [](AsyncWebServerRequest *request){&#xA;  String json = &#34;[&#34;;&#xA;  int n = WiFi.scanComplete();&#xA;  if(n == -2){&#xA;    WiFi.scanNetworks(true);&#xA;  } else if(n){&#xA;    for (int i = 0; i &amp;lt; n; ++i){&#xA;      if(i) json += &#34;,&#34;;&#xA;      json += &#34;{&#34;;&#xA;      json += &#34;\&#34;rssi\&#34;:&#34;+String(WiFi.RSSI(i));&#xA;      json += &#34;,\&#34;ssid\&#34;:\&#34;&#34;+WiFi.SSID(i)+&#34;\&#34;&#34;;&#xA;      json += &#34;,\&#34;bssid\&#34;:\&#34;&#34;+WiFi.BSSIDstr(i)+&#34;\&#34;&#34;;&#xA;      json += &#34;,\&#34;channel\&#34;:&#34;+String(WiFi.channel(i));&#xA;      json += &#34;,\&#34;secure\&#34;:&#34;+String(WiFi.encryptionType(i));&#xA;      json += &#34;,\&#34;hidden\&#34;:&#34;+String(WiFi.isHidden(i)?&#34;true&#34;:&#34;false&#34;);&#xA;      json += &#34;}&#34;;&#xA;    }&#xA;    WiFi.scanDelete();&#xA;    if(WiFi.scanComplete() == -2){&#xA;      WiFi.scanNetworks(true);&#xA;    }&#xA;  }&#xA;  json += &#34;]&#34;;&#xA;  request-&amp;gt;send(200, &#34;application/json&#34;, json);&#xA;  json = String();&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Remove handlers and rewrites&lt;/h2&gt; &#xA;&lt;p&gt;Server goes through handlers in same order as they were added. You can&#39;t simple add handler with same path to override them. To remove handler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-arduino&#34;&gt;// save callback for particular URL path&#xA;auto handler = server.on(&#34;/some/path&#34;, [](AsyncWebServerRequest *request){&#xA;  //do something useful&#xA;});&#xA;// when you don&#39;t need handler anymore remove it&#xA;server.removeHandler(&amp;amp;handler);&#xA;&#xA;// same with rewrites&#xA;server.removeRewrite(&amp;amp;someRewrite);&#xA;&#xA;server.onNotFound([](AsyncWebServerRequest *request){&#xA;  request-&amp;gt;send(404);&#xA;});&#xA;&#xA;// remove server.onNotFound handler&#xA;server.onNotFound(NULL);&#xA;&#xA;// remove all rewrites, handlers and onNotFound/onFileUpload/onRequestBody callbacks&#xA;server.reset();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setting up the server&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;ESPAsyncTCP.h&#34;&#xA;#include &#34;ESPAsyncWebServer.h&#34;&#xA;&#xA;AsyncWebServer server(80);&#xA;AsyncWebSocket ws(&#34;/ws&#34;); // access at ws://[esp ip]/ws&#xA;AsyncEventSource events(&#34;/events&#34;); // event source (Server-Sent events)&#xA;&#xA;const char* ssid = &#34;your-ssid&#34;;&#xA;const char* password = &#34;your-pass&#34;;&#xA;const char* http_username = &#34;admin&#34;;&#xA;const char* http_password = &#34;admin&#34;;&#xA;&#xA;//flag to use from web update to reboot the ESP&#xA;bool shouldReboot = false;&#xA;&#xA;void onRequest(AsyncWebServerRequest *request){&#xA;  //Handle Unknown Request&#xA;  request-&amp;gt;send(404);&#xA;}&#xA;&#xA;void onBody(AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total){&#xA;  //Handle body&#xA;}&#xA;&#xA;void onUpload(AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){&#xA;  //Handle upload&#xA;}&#xA;&#xA;void onEvent(AsyncWebSocket * server, AsyncWebSocketClient * client, AwsEventType type, void * arg, uint8_t *data, size_t len){&#xA;  //Handle WebSocket event&#xA;}&#xA;&#xA;void setup(){&#xA;  Serial.begin(115200);&#xA;  WiFi.mode(WIFI_STA);&#xA;  WiFi.begin(ssid, password);&#xA;  if (WiFi.waitForConnectResult() != WL_CONNECTED) {&#xA;    Serial.printf(&#34;WiFi Failed!\n&#34;);&#xA;    return;&#xA;  }&#xA;&#xA;  // attach AsyncWebSocket&#xA;  ws.onEvent(onEvent);&#xA;  server.addHandler(&amp;amp;ws);&#xA;&#xA;  // attach AsyncEventSource&#xA;  server.addHandler(&amp;amp;events);&#xA;&#xA;  // respond to GET requests on URL /heap&#xA;  server.on(&#34;/heap&#34;, HTTP_GET, [](AsyncWebServerRequest *request){&#xA;    request-&amp;gt;send(200, &#34;text/plain&#34;, String(ESP.getFreeHeap()));&#xA;  });&#xA;&#xA;  // upload a file to /upload&#xA;  server.on(&#34;/upload&#34;, HTTP_POST, [](AsyncWebServerRequest *request){&#xA;    request-&amp;gt;send(200);&#xA;  }, onUpload);&#xA;&#xA;  // send a file when /index is requested&#xA;  server.on(&#34;/index&#34;, HTTP_ANY, [](AsyncWebServerRequest *request){&#xA;    request-&amp;gt;send(SPIFFS, &#34;/index.htm&#34;);&#xA;  });&#xA;&#xA;  // HTTP basic authentication&#xA;  server.on(&#34;/login&#34;, HTTP_GET, [](AsyncWebServerRequest *request){&#xA;    if(!request-&amp;gt;authenticate(http_username, http_password))&#xA;        return request-&amp;gt;requestAuthentication();&#xA;    request-&amp;gt;send(200, &#34;text/plain&#34;, &#34;Login Success!&#34;);&#xA;  });&#xA;&#xA;  // Simple Firmware Update Form&#xA;  server.on(&#34;/update&#34;, HTTP_GET, [](AsyncWebServerRequest *request){&#xA;    request-&amp;gt;send(200, &#34;text/html&#34;, &#34;&amp;lt;form method=&#39;POST&#39; action=&#39;/update&#39; enctype=&#39;multipart/form-data&#39;&amp;gt;&amp;lt;input type=&#39;file&#39; name=&#39;update&#39;&amp;gt;&amp;lt;input type=&#39;submit&#39; value=&#39;Update&#39;&amp;gt;&amp;lt;/form&amp;gt;&#34;);&#xA;  });&#xA;  server.on(&#34;/update&#34;, HTTP_POST, [](AsyncWebServerRequest *request){&#xA;    shouldReboot = !Update.hasError();&#xA;    AsyncWebServerResponse *response = request-&amp;gt;beginResponse(200, &#34;text/plain&#34;, shouldReboot?&#34;OK&#34;:&#34;FAIL&#34;);&#xA;    response-&amp;gt;addHeader(&#34;Connection&#34;, &#34;close&#34;);&#xA;    request-&amp;gt;send(response);&#xA;  },[](AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){&#xA;    if(!index){&#xA;      Serial.printf(&#34;Update Start: %s\n&#34;, filename.c_str());&#xA;      Update.runAsync(true);&#xA;      if(!Update.begin((ESP.getFreeSketchSpace() - 0x1000) &amp;amp; 0xFFFFF000)){&#xA;        Update.printError(Serial);&#xA;      }&#xA;    }&#xA;    if(!Update.hasError()){&#xA;      if(Update.write(data, len) != len){&#xA;        Update.printError(Serial);&#xA;      }&#xA;    }&#xA;    if(final){&#xA;      if(Update.end(true)){&#xA;        Serial.printf(&#34;Update Success: %uB\n&#34;, index+len);&#xA;      } else {&#xA;        Update.printError(Serial);&#xA;      }&#xA;    }&#xA;  });&#xA;&#xA;  // attach filesystem root at URL /fs&#xA;  server.serveStatic(&#34;/fs&#34;, SPIFFS, &#34;/&#34;);&#xA;&#xA;  // Catch-All Handlers&#xA;  // Any request that can not find a Handler that canHandle it&#xA;  // ends in the callbacks below.&#xA;  server.onNotFound(onRequest);&#xA;  server.onFileUpload(onUpload);&#xA;  server.onRequestBody(onBody);&#xA;&#xA;  server.begin();&#xA;}&#xA;&#xA;void loop(){&#xA;  if(shouldReboot){&#xA;    Serial.println(&#34;Rebooting...&#34;);&#xA;    delay(100);&#xA;    ESP.restart();&#xA;  }&#xA;  static char temp[128];&#xA;  sprintf(temp, &#34;Seconds since boot: %u&#34;, millis()/1000);&#xA;  events.send(temp, &#34;time&#34;); //send event &#34;time&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setup global and class functions as request handlers&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;Arduino.h&amp;gt;&#xA;#include &amp;lt;ESPAsyncWebserver.h&amp;gt;&#xA;#include &amp;lt;Hash.h&amp;gt;&#xA;#include &amp;lt;functional&amp;gt;&#xA;&#xA;void handleRequest(AsyncWebServerRequest *request){}&#xA;&#xA;class WebClass {&#xA;public :&#xA;  AsyncWebServer classWebServer = AsyncWebServer(81);&#xA;&#xA;  WebClass(){};&#xA;&#xA;  void classRequest (AsyncWebServerRequest *request){}&#xA;&#xA;  void begin(){&#xA;    // attach global request handler&#xA;    classWebServer.on(&#34;/example&#34;, HTTP_ANY, handleRequest);&#xA;&#xA;    // attach class request handler&#xA;    classWebServer.on(&#34;/example&#34;, HTTP_ANY, std::bind(&amp;amp;WebClass::classRequest, this, std::placeholders::_1));&#xA;  }&#xA;};&#xA;&#xA;AsyncWebServer globalWebServer(80);&#xA;WebClass webClassInstance;&#xA;&#xA;void setup() {&#xA;  // attach global request handler&#xA;  globalWebServer.on(&#34;/example&#34;, HTTP_ANY, handleRequest);&#xA;&#xA;  // attach class request handler&#xA;  globalWebServer.on(&#34;/example&#34;, HTTP_ANY, std::bind(&amp;amp;WebClass::classRequest, webClassInstance, std::placeholders::_1));&#xA;}&#xA;&#xA;void loop() {&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Methods for controlling websocket connections&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  // Disable client connections if it was activated&#xA;  if ( ws.enabled() )&#xA;    ws.enable(false);&#xA;&#xA;  // enable client connections if it was disabled&#xA;  if ( !ws.enabled() )&#xA;    ws.enable(true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example of OTA code&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  // OTA callbacks&#xA;  ArduinoOTA.onStart([]() {&#xA;    // Clean SPIFFS&#xA;    SPIFFS.end();&#xA;&#xA;    // Disable client connections    &#xA;    ws.enable(false);&#xA;&#xA;    // Advertise connected clients what&#39;s going on&#xA;    ws.textAll(&#34;OTA Update Started&#34;);&#xA;&#xA;    // Close them&#xA;    ws.closeAll();&#xA;&#xA;  });&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adding Default Headers&lt;/h3&gt; &#xA;&lt;p&gt;In some cases, such as when working with CORS, or with some sort of custom authentication system, you might need to define a header that should get added to all responses (including static, websocket and EventSource). The DefaultHeaders singleton allows you to do this.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DefaultHeaders::Instance().addHeader(&#34;Access-Control-Allow-Origin&#34;, &#34;*&#34;);&#xA;webServer.begin();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: You will still need to respond to the OPTIONS method for CORS pre-flight in most cases. (unless you are only using GET)&lt;/p&gt; &#xA;&lt;p&gt;This is one option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;webServer.onNotFound([](AsyncWebServerRequest *request) {&#xA;  if (request-&amp;gt;method() == HTTP_OPTIONS) {&#xA;    request-&amp;gt;send(200);&#xA;  } else {&#xA;    request-&amp;gt;send(404);&#xA;  }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Path variable&lt;/h3&gt; &#xA;&lt;p&gt;With path variable you can create a custom regex rule for a specific parameter in a route. For example we want a &lt;code&gt;sensorId&lt;/code&gt; parameter in a route rule to match only a integer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  server.on(&#34;^\\/sensor\\/([0-9]+)$&#34;, HTTP_GET, [] (AsyncWebServerRequest *request) {&#xA;      String sensorId = request-&amp;gt;pathArg(0);&#xA;  });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: All regex patterns starts with &lt;code&gt;^&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To enable the &lt;code&gt;Path variable&lt;/code&gt; support, you have to define the buildflag &lt;code&gt;-DASYNCWEBSERVER_REGEX&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For Arduino IDE create/update &lt;code&gt;platform.local.txt&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Windows&lt;/code&gt;: C:\Users(username)\AppData\Local\Arduino15\packages\&lt;code&gt;{espxxxx}&lt;/code&gt;\hardware\&lt;code&gt;espxxxx&lt;/code&gt;\&lt;code&gt;{version}&lt;/code&gt;\platform.local.txt&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;: ~/.arduino15/packages/&lt;code&gt;{espxxxx}&lt;/code&gt;/hardware/&lt;code&gt;{espxxxx}&lt;/code&gt;/&lt;code&gt;{version}&lt;/code&gt;/platform.local.txt&lt;/p&gt; &#xA;&lt;p&gt;Add/Update the following line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  compiler.cpp.extra_flags=-DDASYNCWEBSERVER_REGEX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For platformio modify &lt;code&gt;platformio.ini&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[env:myboard]&#xA;build_flags = &#xA;  -DASYNCWEBSERVER_REGEX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: By enabling &lt;code&gt;ASYNCWEBSERVER_REGEX&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; will be included. This will add an 100k to your binary.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>xbmc/xbmc</title>
    <updated>2022-11-14T01:31:10Z</updated>
    <id>tag:github.com,2022-11-14:/xbmc/xbmc</id>
    <link href="https://github.com/xbmc/xbmc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Kodi is an award-winning free and open source home theater/media center software and entertainment hub for digital media. With its beautiful interface and powerful skinning engine, it&#39;s available for Android, BSD, Linux, macOS, iOS, tvOS and Windows.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/docs/resources/banner.png&#34; alt=&#34;Kodi Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;strong&gt; &lt;a href=&#34;https://kodi.tv/&#34;&gt;website&lt;/a&gt;  &lt;a href=&#34;https://kodi.wiki/view/Main_Page&#34;&gt;docs&lt;/a&gt;  &lt;a href=&#34;https://forum.kodi.tv/&#34;&gt;community&lt;/a&gt;  &lt;a href=&#34;https://kodi.tv/addons&#34;&gt;add-ons&lt;/a&gt; &lt;/strong&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/LICENSE.md&#34;&gt;&lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/badge/license-GPLv2-blue.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.kodi.tv/&#34;&gt;&lt;img alt=&#34;Documentation&#34; src=&#34;https://img.shields.io/badge/code-documented-brightgreen.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xbmc/xbmc/pulls&#34;&gt;&lt;img alt=&#34;PRs Welcome&#34; src=&#34;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/#how-to-contribute&#34;&gt;&lt;img alt=&#34;Contributions Welcome&#34; src=&#34;https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;http://jenkins.kodi.tv/&#34;&gt;&lt;img alt=&#34;Build&#34; src=&#34;https://img.shields.io/badge/CI-jenkins-brightgreen.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xbmc/xbmc/commits/master&#34;&gt;&lt;img alt=&#34;Commits&#34; src=&#34;https://img.shields.io/github/commits-since/xbmc/xbmc/latest.svg?style=flat-square&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;a href=&#34;https://play.google.com/store/apps/details?id=org.xbmc.kodi&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://play.google.com/intl/en_us/badges/images/generic/en-play-badge.png&#34; height=&#34;80&#34;&gt; &lt;/a&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt; Welcome to Kodi Home Theater Software! &lt;/h1&gt; &#xA;&lt;p&gt;Kodi is an award-winning &lt;strong&gt;free and open source&lt;/strong&gt; software media player and entertainment hub for digital media. Available as a native application for &lt;strong&gt;Android, Linux, BSD, macOS, iOS, tvOS and Windows operating systems&lt;/strong&gt;, Kodi runs on most common processor architectures.&lt;/p&gt; &#xA;&lt;p&gt;Created in 2003 by a group of like minded programmers, Kodi is a non-profit project run by the XBMC Foundation and developed by volunteers located around the world. More than 500 software developers have contributed to Kodi to date, and 100-plus translators have worked to expand its reach, making it available in more than 70 languages.&lt;/p&gt; &#xA;&lt;p&gt;While Kodi functions very well as a standard media player application for your computer, it has been designed to be the perfect companion for your HTPC. With its &lt;strong&gt;beautiful interface and powerful skinning engine&lt;/strong&gt;, Kodi feels very natural to use from the couch with a remote control and is the ideal solution for your home theater.&lt;/p&gt; &#xA;&lt;h2&gt;Give your media the love it deserves&lt;/h2&gt; &#xA;&lt;p&gt;Kodi can be used to play almost all popular audio and video formats around. It was designed for network playback, so you can stream your multimedia from anywhere in the house or directly from the internet using practically any protocol available.&lt;/p&gt; &#xA;&lt;p&gt;Point Kodi to your media and watch it &lt;strong&gt;scan and automagically create a personalized library&lt;/strong&gt; complete with box covers, descriptions, and fanart. There are playlist and slideshow functions, a weather forecast feature and many audio visualizations. Once installed, your computer or HTPC will become a fully functional multimedia jukebox.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/docs/resources/kodi.gif&#34; alt=&#34;Kodi&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Kodi&#39;s developers work hard to make it support a large range of devices and operating systems. We provide final as well as development builds. To get started, head over to the &lt;strong&gt;&lt;a href=&#34;https://kodi.tv/download&#34;&gt;downloads section&lt;/a&gt;&lt;/strong&gt; and simply select the platform that you want to install it on. A &lt;strong&gt;&lt;a href=&#34;https://kodi.wiki/view/quick_start_guide&#34;&gt;quick start guide&lt;/a&gt;&lt;/strong&gt; to help you get acquainted with Kodi is available in our wiki.&lt;/p&gt; &#xA;&lt;h2&gt;How to Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Kodi is created by users for users and &lt;strong&gt;we welcome every contribution&lt;/strong&gt;. There are no highly paid developers or poorly paid support personnel on the phones ready to take your call. There are only users who have seen a problem and done their best to fix it. This means Kodi will always need the contributions of users like you. How can you get involved?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Coding:&lt;/strong&gt; Developers can help Kodi by &lt;strong&gt;&lt;a href=&#34;https://github.com/xbmc/xbmc/issues&#34;&gt;fixing a bug&lt;/a&gt;&lt;/strong&gt;, adding new features, making our technology smaller and faster and making development easier for others. Kodi&#39;s codebase consists mainly of C++ with small parts written in a variety of coding languages. Our add-ons mainly consist of python and XML. For more information, please have a look at our &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/docs/CONTRIBUTING.md&#34;&gt;contributing guide&lt;/a&gt;&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Helping users:&lt;/strong&gt; Our support process relies on enthusiastic contributors like you to help others get the most out of Kodi. The #1 priority is always answering questions in our &lt;strong&gt;&lt;a href=&#34;https://forum.kodi.tv/&#34;&gt;support forums&lt;/a&gt;&lt;/strong&gt;. Everyday new people discover Kodi, and everyday they are virtually guaranteed to have questions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Localization:&lt;/strong&gt; Translate &lt;strong&gt;&lt;a href=&#34;https://kodi.weblate.cloud/projects/kodi-core/kodi-main/&#34;&gt;Kodi&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;a href=&#34;https://kodi.weblate.cloud/&#34;&gt;add-ons, skins etc.&lt;/a&gt;&lt;/strong&gt; into your native language.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Add-ons:&lt;/strong&gt; &lt;strong&gt;&lt;a href=&#34;https://kodi.tv/addons&#34;&gt;Add-ons&lt;/a&gt;&lt;/strong&gt; are what make Kodi the most extensible and customizable entertainment hub available. &lt;strong&gt;&lt;a href=&#34;https://kodi.tv/create-an-addon&#34;&gt;Get started building an add-on&lt;/a&gt;&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Documentation:&lt;/strong&gt; Kodi&#39;s &lt;strong&gt;&lt;a href=&#34;https://kodi.wiki/&#34;&gt;wiki pages&lt;/a&gt;&lt;/strong&gt; are the hub for information about Kodi and surrounding ecosystem. Help make our documentation better by writing new content or correcting existing material.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Not enough free time?&lt;/strong&gt; No problem! There are other ways to help Kodi.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Spread the word:&lt;/strong&gt; Share Kodi with the world! Tell your friends and family about how Kodi creates an amazing entertainment experience. Stay up to date on the latest stories about Kodi reading our &lt;strong&gt;&lt;a href=&#34;https://kodi.tv/blog&#34;&gt;news&lt;/a&gt;&lt;/strong&gt; section, follow us on &lt;strong&gt;&lt;a href=&#34;https://twitter.com/koditv&#34;&gt;Twitter&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&#34;https://www.facebook.com/XBMC/&#34;&gt;Facebook&lt;/a&gt;&lt;/strong&gt;, or &lt;strong&gt;star Kodi&#39;s repo&lt;/strong&gt; if you want to follow development.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Donate:&lt;/strong&gt; We are always happy to receive a &lt;strong&gt;&lt;a href=&#34;https://kodi.tv/contribute/donate&#34;&gt;donation&lt;/a&gt;&lt;/strong&gt;. Donations are typically used for travel to attend conferences, any necessary paperwork and legal fees, and the yearly XBMC Foundation Developers Conference, where a great deal of coding and planning for the following year occurs. Donations may also be used to purchase necessary hardware and licenses for developers, along with t-shirts, stickers, and other accessories for conferences.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Buy Kodi merchandise:&lt;/strong&gt; Purchasing Kodi gear helps just as much as a donation, and you get something in return! Checkout our &lt;strong&gt;&lt;a href=&#34;https://kodi.tv/store&#34;&gt;store&lt;/a&gt;&lt;/strong&gt; for Kodi branded gear. We regularly add new products so check back often.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Kodi uses CMake as its building system but instructions are highly dependent on your operating system and target platform. Fortunately &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/docs/README.md&#34;&gt;we&#39;ve got you covered&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;Kodi couldn&#39;t exist without&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All the &lt;strong&gt;&lt;a href=&#34;https://github.com/xbmc/xbmc/graphs/contributors&#34;&gt;contributors&lt;/a&gt;&lt;/strong&gt;. Big or small a change, it does make a difference.&lt;/li&gt; &#xA; &lt;li&gt;All the developers that write the fantastic &lt;strong&gt;software and libraries&lt;/strong&gt; that Kodi uses. We stand on the shoulders of giants.&lt;/li&gt; &#xA; &lt;li&gt;Our &lt;strong&gt;&lt;a href=&#34;https://forum.kodi.tv/&#34;&gt;fantastic community&lt;/a&gt;&lt;/strong&gt; for the never ending support, inspiration, feedback, and for keeping us on our toes when we screw up!&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://kodi.tv/sponsors&#34;&gt;Our sponsors&lt;/a&gt;&lt;/strong&gt;. Without them, keeping a huge project like this alive would be next to impossible.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Kodi is &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/xbmc/xbmc/master/LICENSE.md&#34;&gt;GPLv2 licensed&lt;/a&gt;&lt;/strong&gt;. You may use, distribute and copy it under the license terms.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/xbmc/xbmc/graphs/contributors&#34;&gt;&lt;img src=&#34;https://forthebadge.com/images/badges/built-by-developers.svg?sanitize=true&#34; height=&#34;25&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xbmc/xbmc&#34;&gt;&lt;img src=&#34;https://forthebadge.com/images/badges/certified-cousin-terio.svg?sanitize=true&#34; height=&#34;25&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xbmc/xbmc&#34;&gt;&lt;img src=&#34;https://forthebadge.com/images/badges/approved-by-george-costanza.svg?sanitize=true&#34; height=&#34;25&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://kodi.tv/download&#34;&gt;&lt;img src=&#34;https://forthebadge.com/images/badges/check-it-out.svg?sanitize=true&#34; height=&#34;25&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/xbmc/xbmc&#34;&gt;&lt;img src=&#34;https://forthebadge.com/images/badges/winter-is-coming.svg?sanitize=true&#34; height=&#34;25&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>