<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-11T02:25:46Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>chiteroman/PlayIntegrityFix</title>
    <updated>2023-11-11T02:25:46Z</updated>
    <id>tag:github.com,2023-11-11:/chiteroman/PlayIntegrityFix</id>
    <link href="https://github.com/chiteroman/PlayIntegrityFix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fix Play Integrity (and SafetyNet) verdicts.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Play Integrity Fix&lt;/h1&gt; &#xA;&lt;p&gt;A Zygisk module which fix &#34;ctsProfileMatch&#34; (SafetyNet) and &#34;MEETS_DEVICE_INTEGRITY&#34; (Play Integrity).&lt;/p&gt; &#xA;&lt;p&gt;To use this module you must have one of this:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Magisk with Zygisk enabled.&lt;/li&gt; &#xA; &lt;li&gt;KernelSU with &lt;a href=&#34;https://github.com/Dr-TSNG/ZygiskNext&#34;&gt;ZygiskNext&lt;/a&gt; module installed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/chiteroman/PlayIntegrityFix/releases/latest&#34;&gt;&lt;strong&gt;Download the latest here&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Donations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://paypal.me/chiteroman&#34;&gt;PayPal&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Official posts&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://xdaforums.com/t/module-play-integrity-fix-safetynet-fix.4607985/&#34;&gt;XDA&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About module&lt;/h2&gt; &#xA;&lt;p&gt;It injects a classes.dex file to modify few fields in android.os.Build class. Also, in native code it creates a hook to modify system properties. The purpouse of the module is to avoid a hardware attestation.&lt;/p&gt; &#xA;&lt;h2&gt;Failing BASIC verdict&lt;/h2&gt; &#xA;&lt;p&gt;If you are failing basicIntegrity (SafetyNet) or MEETS_BASIC_INTEGRITY (Play Integrity) something is wrong in your setup. My recommended steps in order to find the problem:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disable all modules except mine.&lt;/li&gt; &#xA; &lt;li&gt;Check your SELinux (must be enforced).&lt;/li&gt; &#xA; &lt;li&gt;If you are using Shamiko and have deny list disabled, you must manually add GMS main and unstable processes to hide list or DroidGuard will detect root.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Some modules which modify system can trigger DroidGuard detection, never hook GMS processes.&lt;/p&gt; &#xA;&lt;h2&gt;Certify Play Store and fix Google Wallet&lt;/h2&gt; &#xA;&lt;p&gt;Follow this steps:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clear Google Wallet data and cache.&lt;/li&gt; &#xA; &lt;li&gt;Clear Google Play Store data and cache.&lt;/li&gt; &#xA; &lt;li&gt;Clear GSF (com.google.android.gsf) data and cache.&lt;/li&gt; &#xA; &lt;li&gt;Flash my module in Magisk/KernelSU (if you already have my module, just ignore this step)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then reboot device and should work. Also some users recommend to clear GMS data and cache but for me it wasn&#39;t necessary.&lt;/p&gt; &#xA;&lt;h2&gt;Read module logs&lt;/h2&gt; &#xA;&lt;p&gt;You can read module logs using this command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;adb shell &#34;logcat | grep &#39;PIF&#39;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Can this module pass MEETS_STRONG_INTEGRITY?&lt;/h2&gt; &#xA;&lt;p&gt;No&lt;/p&gt; &#xA;&lt;h2&gt;SafetyNet is obsolete&lt;/h2&gt; &#xA;&lt;p&gt;You can read more info here: &lt;a href=&#34;https://xdaforums.com/t/info-play-integrity-api-replacement-for-safetynet.4479337/&#34;&gt;click me&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Current Issues&lt;/h2&gt; &#xA;&lt;p&gt;It doesn&#39;t work in Xiaomi.eu custom ROMs due their fix implementation. Their devs are already working in it: &lt;a href=&#34;https://xiaomi.eu/community/threads/google-wallet-stopped-working-device-doesnt-meet-security-requirements.70444/post-704331&#34;&gt;click me&lt;/a&gt;. If Xiaomi.eu devs drop support for your device and this module doesn&#39;t work you must change the ROM if you want to pass DEVICE verdict.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks to&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/topjohnwu/libcxx&#34;&gt;libcxx&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/bytedance/android-inline-hook&#34;&gt;Shadowhook&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jmpews/Dobby&#34;&gt;Dobby&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Abhishek-Saini/educational</title>
    <updated>2023-11-11T02:25:46Z</updated>
    <id>tag:github.com,2023-11-11:/Abhishek-Saini/educational</id>
    <link href="https://github.com/Abhishek-Saini/educational" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Educational Codes&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;em&gt;If you want to add any optimization or spot a bug, feel free to raise a pull request. &lt;br&gt; If for any solutions you can add 2-3 lines on the top of the file about the solutions, especially for the somewhat harder ones, that&#39;d be great. If you can make this readme nicer (but mainly more useful), welcome to raise PR for that too.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Find below one-line description of each of the directories. I will keep adding educational codes here.&lt;/p&gt; &#xA;&lt;h4&gt;atcoder_educational_dp_problems&lt;/h4&gt; &#xA;&lt;p&gt;Solution of all 26 problems for the Atcoder DP &lt;a href=&#34;https://atcoder.jp/contests/dp&#34;&gt;contest&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;codeforces&lt;/h4&gt; &#xA;&lt;p&gt;Solutions from codeforces rounds&lt;/p&gt; &#xA;&lt;h4&gt;cses&lt;/h4&gt; &#xA;&lt;p&gt;Solutions for &lt;a href=&#34;https://cses.fi/problemset/&#34;&gt;CSES problem set&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sections already added -&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DP - 19/19&lt;/li&gt; &#xA; &lt;li&gt;Sorting and searching - 35/35&lt;/li&gt; &#xA; &lt;li&gt;Tree Algorithms - 17/17&lt;/li&gt; &#xA; &lt;li&gt;Graph - 36/36&lt;/li&gt; &#xA; &lt;li&gt;Mathematics - 31/31&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>p-ranav/argparse</title>
    <updated>2023-11-11T02:25:46Z</updated>
    <id>tag:github.com,2023-11-11:/p-ranav/argparse</id>
    <link href="https://github.com/p-ranav/argparse" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Argument Parser for Modern C++&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img height=&#34;100&#34; src=&#34;https://i.imgur.com/oDXeMUQ.png&#34; alt=&#34;argparse&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/p-ranav/argparse/raw/master/LICENSE&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;license&#34;&gt; &lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/version-3.0-blue.svg?cacheSeconds=2592000&#34; alt=&#34;version&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Highlights&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Single header file&lt;/li&gt; &#xA; &lt;li&gt;Requires C++17&lt;/li&gt; &#xA; &lt;li&gt;MIT License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#quick-start&#34;&gt;Quick Start&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#positional-arguments&#34;&gt;Positional Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#optional-arguments&#34;&gt;Optional Arguments&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#requiring-optional-arguments&#34;&gt;Requiring optional arguments&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#accessing-optional-arguments-without-default-values&#34;&gt;Accessing optional arguments without default values&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#deciding-if-the-value-was-given-by-the-user&#34;&gt;Deciding if the value was given by the user&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#joining-values-of-repeated-optional-arguments&#34;&gt;Joining values of repeated optional arguments&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#repeating-an-argument-to-increase-a-value&#34;&gt;Repeating an argument to increase a value&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#mutually-exclusive-group&#34;&gt;Mutually Exclusive Group&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#negative-numbers&#34;&gt;Negative Numbers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#combining-positional-and-optional-arguments&#34;&gt;Combining Positional and Optional Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#printing-help&#34;&gt;Printing Help&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#adding-a-description-and-an-epilog-to-help&#34;&gt;Adding a description and an epilog to help&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#list-of-arguments&#34;&gt;List of Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#compound-arguments&#34;&gt;Compound Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#converting-to-numeric-types&#34;&gt;Converting to Numeric Types&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#default-arguments&#34;&gt;Default Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#gathering-remaining-arguments&#34;&gt;Gathering Remaining Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#parent-parsers&#34;&gt;Parent Parsers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#subcommands&#34;&gt;Subcommands&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#parse-known-args&#34;&gt;Parse Known Args&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#argumentparser-in-bool-context&#34;&gt;ArgumentParser in bool Context&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#custom-prefix-characters&#34;&gt;Custom Prefix Characters&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#custom-assignment-characters&#34;&gt;Custom Assignment Characters&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#further-examples&#34;&gt;Further Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#construct-a-json-object-from-a-filename-argument&#34;&gt;Construct a JSON object from a filename argument&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#positional-arguments-with-compound-toggle-arguments&#34;&gt;Positional Arguments with Compound Toggle Arguments&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#restricting-the-set-of-values-for-an-argument&#34;&gt;Restricting the set of values for an argument&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#using-optionvalue-syntax&#34;&gt;Using &lt;code&gt;option=value&lt;/code&gt; syntax&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#developer-notes&#34;&gt;Developer Notes&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#copying-and-moving&#34;&gt;Copying and Moving&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#cmake-integration&#34;&gt;CMake Integration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#building-installing-and-testing&#34;&gt;Building, Installing, and Testing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#supported-toolchains&#34;&gt;Supported Toolchains&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;Simply include argparse.hpp and you&#39;re good to go.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To start parsing command-line arguments, create an &lt;code&gt;ArgumentParser&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;program_name&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; There is an optional second argument to the &lt;code&gt;ArgumentParser&lt;/code&gt; which is the program version. Example: &lt;code&gt;argparse::ArgumentParser program(&#34;libfoo&#34;, &#34;1.9.0&#34;);&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; There are optional third and fourth arguments to the &lt;code&gt;ArgumentParser&lt;/code&gt; which control default arguments. Example: &lt;code&gt;argparse::ArgumentParser program(&#34;libfoo&#34;, &#34;1.9.0&#34;, default_arguments::help, false);&lt;/code&gt; See &lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/#default-arguments&#34;&gt;Default Arguments&lt;/a&gt;, below.&lt;/p&gt; &#xA;&lt;p&gt;To add a new argument, simply call &lt;code&gt;.add_argument(...)&lt;/code&gt;. You can provide a variadic list of argument names that you want to group together, e.g., &lt;code&gt;-v&lt;/code&gt; and &lt;code&gt;--verbose&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;foo&#34;);&#xA;program.add_argument(&#34;-v&#34;, &#34;--verbose&#34;); // parameter packing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Argparse supports a variety of argument types including positional, optional, and compound arguments. Below you can see how to configure each of these types:&lt;/p&gt; &#xA;&lt;h3&gt;Positional Arguments&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s an example of a &lt;em&gt;&lt;strong&gt;positional argument&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;program_name&#34;);&#xA;&#xA;  program.add_argument(&#34;square&#34;)&#xA;    .help(&#34;display the square of a given integer&#34;)&#xA;    .scan&amp;lt;&#39;i&#39;, int&amp;gt;();&#xA;&#xA;  try {&#xA;    program.parse_args(argc, argv);&#xA;  }&#xA;  catch (const std::exception&amp;amp; err) {&#xA;    std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;    std::cerr &amp;lt;&amp;lt; program;&#xA;    return 1;&#xA;  }&#xA;&#xA;  auto input = program.get&amp;lt;int&amp;gt;(&#34;square&#34;);&#xA;  std::cout &amp;lt;&amp;lt; (input * input) &amp;lt;&amp;lt; std::endl;&#xA;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And running the code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main 15&#xA;225&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s what&#39;s happening:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;code&gt;add_argument()&lt;/code&gt; method is used to specify which command-line options the program is willing to accept. In this case, I’ve named it square so that it’s in line with its function.&lt;/li&gt; &#xA; &lt;li&gt;Command-line arguments are strings. To square the argument and print the result, we need to convert this argument to a number. In order to do this, we use the &lt;code&gt;.scan&lt;/code&gt; method to convert user input into an integer.&lt;/li&gt; &#xA; &lt;li&gt;We can get the value stored by the parser for a given argument using &lt;code&gt;parser.get&amp;lt;T&amp;gt;(key)&lt;/code&gt; method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Optional Arguments&lt;/h3&gt; &#xA;&lt;p&gt;Now, let&#39;s look at &lt;em&gt;&lt;strong&gt;optional arguments&lt;/strong&gt;&lt;/em&gt;. Optional arguments start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, e.g., &lt;code&gt;--verbose&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt;. Optional arguments can be placed anywhere in the input sequence.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;--verbose&#34;)&#xA;  .help(&#34;increase output verbosity&#34;)&#xA;  .default_value(false)&#xA;  .implicit_value(true);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;if (program[&#34;--verbose&#34;] == true) {&#xA;  std::cout &amp;lt;&amp;lt; &#34;Verbosity enabled&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main --verbose&#xA;Verbosity enabled&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s what&#39;s happening:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The program is written so as to display something when --verbose is specified and display nothing when not.&lt;/li&gt; &#xA; &lt;li&gt;Since the argument is actually optional, no error is thrown when running the program without &lt;code&gt;--verbose&lt;/code&gt;. Note that by using &lt;code&gt;.default_value(false)&lt;/code&gt;, if the optional argument isn’t used, it&#39;s value is automatically set to false.&lt;/li&gt; &#xA; &lt;li&gt;By using &lt;code&gt;.implicit_value(true)&lt;/code&gt;, the user specifies that this option is more of a flag than something that requires a value. When the user provides the --verbose option, it&#39;s value is set to true.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Flag&lt;/h4&gt; &#xA;&lt;p&gt;When defining flag arguments, you can use the shorthand &lt;code&gt;flag()&lt;/code&gt; which is the same as &lt;code&gt;default_value(false).implicit_value(true)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;--verbose&#34;)&#xA;  .help(&#34;increase output verbosity&#34;)&#xA;  .flag();&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;if (program[&#34;--verbose&#34;] == true) {&#xA;  std::cout &amp;lt;&amp;lt; &#34;Verbosity enabled&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Requiring optional arguments&lt;/h4&gt; &#xA;&lt;p&gt;There are scenarios where you would like to make an optional argument &lt;em&gt;&lt;strong&gt;required&lt;/strong&gt;&lt;/em&gt;. As discussed above, optional arguments either begin with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;. You can make these types of arguments required like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;-o&#34;, &#34;--output&#34;)&#xA;  .required()&#xA;  .help(&#34;specify the output file.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the user does not provide a value for this parameter, an exception is thrown.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you could provide a default value like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;-o&#34;, &#34;--output&#34;)&#xA;  .default_value(std::string(&#34;-&#34;))&#xA;  .required()&#xA;  .help(&#34;specify the output file.&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Accessing optional arguments without default values&lt;/h4&gt; &#xA;&lt;p&gt;If you require an optional argument to be present but have no good default value for it, you can combine testing and accessing the argument as following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (auto fn = program.present(&#34;-o&#34;)) {&#xA;    do_something_with(*fn);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similar to &lt;code&gt;get&lt;/code&gt;, the &lt;code&gt;present&lt;/code&gt; method also accepts a template argument. But rather than returning &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;parser.present&amp;lt;T&amp;gt;(key)&lt;/code&gt; returns &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt;, so that when the user does not provide a value to this parameter, the return value compares equal to &lt;code&gt;std::nullopt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Deciding if the value was given by the user&lt;/h4&gt; &#xA;&lt;p&gt;If you want to know whether the user supplied a value for an argument that has a &lt;code&gt;.default_value&lt;/code&gt;, check whether the argument &lt;code&gt;.is_used()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;--color&#34;)&#xA;  .default_value(std::string{&#34;orange&#34;})   // might otherwise be type const char* leading to an error when trying program.get&amp;lt;std::string&amp;gt;&#xA;  .help(&#34;specify the cat&#39;s fur color&#34;);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);    // Example: ./main --color orange&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto color = program.get&amp;lt;std::string&amp;gt;(&#34;--color&#34;);  // &#34;orange&#34;&#xA;auto explicit_color = program.is_used(&#34;--color&#34;);  // true, user provided orange&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Joining values of repeated optional arguments&lt;/h4&gt; &#xA;&lt;p&gt;You may want to allow an optional argument to be repeated and gather all values in one place.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;--color&#34;)&#xA;  .default_value&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;({ &#34;orange&#34; })&#xA;  .append()&#xA;  .help(&#34;specify the cat&#39;s fur color&#34;);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);    // Example: ./main --color red --color green --color blue&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto colors = program.get&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&#34;--color&#34;);  // {&#34;red&#34;, &#34;green&#34;, &#34;blue&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that &lt;code&gt;.default_value&lt;/code&gt; is given an explicit template parameter to match the type you want to &lt;code&gt;.get&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Repeating an argument to increase a value&lt;/h4&gt; &#xA;&lt;p&gt;A common pattern is to repeat an argument to indicate a greater value.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int verbosity = 0;&#xA;program.add_argument(&#34;-V&#34;, &#34;--verbose&#34;)&#xA;  .action([&amp;amp;](const auto &amp;amp;) { ++verbosity; })&#xA;  .append()&#xA;  .default_value(false)&#xA;  .implicit_value(true)&#xA;  .nargs(0);&#xA;&#xA;program.parse_args(argc, argv);    // Example: ./main -VVVV&#xA;&#xA;std::cout &amp;lt;&amp;lt; &#34;verbose level: &#34; &amp;lt;&amp;lt; verbosity &amp;lt;&amp;lt; std::endl;    // verbose level: 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Mutually Exclusive Group&lt;/h4&gt; &#xA;&lt;p&gt;Create a mutually exclusive group using &lt;code&gt;program.add_mutually_exclusive_group(required = false)&lt;/code&gt;. `argparse`` will make sure that only one of the arguments in the mutually exclusive group was present on the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto &amp;amp;group = program.add_mutually_exclusive_group();&#xA;group.add_argument(&#34;--first&#34;);&#xA;group.add_argument(&#34;--second&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with the following usage will yield an error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main --first 1 --second 2&#xA;Argument &#39;--second VAR&#39; not allowed with &#39;--first VAR&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;add_mutually_exclusive_group()&lt;/code&gt; function also accepts a &lt;code&gt;required&lt;/code&gt; argument, to indicate that at least one of the mutually exclusive arguments is required:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto &amp;amp;group = program.add_mutually_exclusive_group(true);&#xA;group.add_argument(&#34;--first&#34;);&#xA;group.add_argument(&#34;--second&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with the following usage will yield an error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main&#xA;One of the arguments &#39;--first VAR&#39; or &#39;--second VAR&#39; is required&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Negative Numbers&lt;/h3&gt; &#xA;&lt;p&gt;Optional arguments start with &lt;code&gt;-&lt;/code&gt;. Can &lt;code&gt;argparse&lt;/code&gt; handle negative numbers? The answer is yes!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program;&#xA;&#xA;program.add_argument(&#34;integer&#34;)&#xA;  .help(&#34;Input number&#34;)&#xA;  .scan&amp;lt;&#39;i&#39;, int&amp;gt;();&#xA;&#xA;program.add_argument(&#34;floats&#34;)&#xA;  .help(&#34;Vector of floats&#34;)&#xA;  .nargs(4)&#xA;  .scan&amp;lt;&#39;g&#39;, float&amp;gt;();&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;// Some code to print arguments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main -5 -1.1 -3.1415 -3.1e2 -4.51329E3&#xA;integer : -5&#xA;floats  : -1.1 -3.1415 -310 -4513.29&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see here, &lt;code&gt;argparse&lt;/code&gt; supports negative integers, negative floats and scientific notation.&lt;/p&gt; &#xA;&lt;h3&gt;Combining Positional and Optional Arguments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;main&#34;);&#xA;&#xA;program.add_argument(&#34;square&#34;)&#xA;  .help(&#34;display the square of a given number&#34;)&#xA;  .scan&amp;lt;&#39;i&#39;, int&amp;gt;();&#xA;&#xA;program.add_argument(&#34;--verbose&#34;)&#xA;  .default_value(false)&#xA;  .implicit_value(true);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;int input = program.get&amp;lt;int&amp;gt;(&#34;square&#34;);&#xA;&#xA;if (program[&#34;--verbose&#34;] == true) {&#xA;  std::cout &amp;lt;&amp;lt; &#34;The square of &#34; &amp;lt;&amp;lt; input &amp;lt;&amp;lt; &#34; is &#34; &amp;lt;&amp;lt; (input * input) &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;else {&#xA;  std::cout &amp;lt;&amp;lt; (input * input) &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main 4&#xA;16&#xA;&#xA;foo@bar:/home/dev/$ ./main 4 --verbose&#xA;The square of 4 is 16&#xA;&#xA;foo@bar:/home/dev/$ ./main --verbose 4&#xA;The square of 4 is 16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Printing Help&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;std::cout &amp;lt;&amp;lt; program&lt;/code&gt; prints a help message, including the program usage and information about the arguments registered with the &lt;code&gt;ArgumentParser&lt;/code&gt;. For the previous example, here&#39;s the default help message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;foo@bar:/home/dev/$ ./main --help&#xA;Usage: main [-h] [--verbose] square&#xA;&#xA;Positional arguments:&#xA;  square       &#x9;display the square of a given number&#xA;&#xA;Optional arguments:&#xA;  -h, --help   &#x9;shows help message and exits&#xA;  -v, --version&#x9;prints version information and exits&#xA;  --verbose&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also get the help message in string via &lt;code&gt;program.help().str()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Adding a description and an epilog to help&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ArgumentParser::add_description&lt;/code&gt; will add text before the detailed argument information. &lt;code&gt;ArgumentParser::add_epilog&lt;/code&gt; will add text after all other help output.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;main&#34;);&#xA;  program.add_argument(&#34;thing&#34;).help(&#34;Thing to use.&#34;).metavar(&#34;THING&#34;);&#xA;  program.add_argument(&#34;--member&#34;).help(&#34;The alias for the member to pass to.&#34;).metavar(&#34;ALIAS&#34;);&#xA;  program.add_argument(&#34;--verbose&#34;).default_value(false).implicit_value(true);&#xA;&#xA;  program.add_description(&#34;Forward a thing to the next member.&#34;);&#xA;  program.add_epilog(&#34;Possible things include betingalw, chiz, and res.&#34;);&#xA;&#xA;  program.parse_args(argc, argv);&#xA;&#xA;  std::cout &amp;lt;&amp;lt; program &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;Usage: main [-h] [--member ALIAS] [--verbose] THING&#xA;&#xA;Forward a thing to the next member.&#xA;&#xA;Positional arguments:&#xA;  THING         &#x9;Thing to use.&#xA;&#xA;Optional arguments:&#xA;  -h, --help    &#x9;shows help message and exits&#xA;  -v, --version &#x9;prints version information and exits&#xA;  --member ALIAS&#x9;The alias for the member to pass to.&#xA;  --verbose&#xA;&#xA;Possible things include betingalw, chiz, and res.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;List of Arguments&lt;/h3&gt; &#xA;&lt;p&gt;ArgumentParser objects usually associate a single command-line argument with a single action to be taken. The &lt;code&gt;.nargs&lt;/code&gt; associates a different number of command-line arguments with a single action. When using &lt;code&gt;nargs(N)&lt;/code&gt;, N arguments from the command line will be gathered together into a list.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;main&#34;);&#xA;&#xA;program.add_argument(&#34;--input_files&#34;)&#xA;  .help(&#34;The list of input files&#34;)&#xA;  .nargs(2);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);   // Example: ./main --input_files config.yml System.xml&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto files = program.get&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&#34;--input_files&#34;);  // {&#34;config.yml&#34;, &#34;System.xml&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;ArgumentParser.get&amp;lt;T&amp;gt;()&lt;/code&gt; has specializations for &lt;code&gt;std::vector&lt;/code&gt; and &lt;code&gt;std::list&lt;/code&gt;. So, the following variant, &lt;code&gt;.get&amp;lt;std::list&amp;gt;&lt;/code&gt;, will also work.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto files = program.get&amp;lt;std::list&amp;lt;std::string&amp;gt;&amp;gt;(&#34;--input_files&#34;);  // {&#34;config.yml&#34;, &#34;System.xml&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using &lt;code&gt;.scan&lt;/code&gt;, one can quickly build a list of desired value types from command line arguments. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;main&#34;);&#xA;&#xA;program.add_argument(&#34;--query_point&#34;)&#xA;  .help(&#34;3D query point&#34;)&#xA;  .nargs(3)&#xA;  .default_value(std::vector&amp;lt;double&amp;gt;{0.0, 0.0, 0.0})&#xA;  .scan&amp;lt;&#39;g&#39;, double&amp;gt;();&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv); // Example: ./main --query_point 3.5 4.7 9.2&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto query_point = program.get&amp;lt;std::vector&amp;lt;double&amp;gt;&amp;gt;(&#34;--query_point&#34;);  // {3.5, 4.7, 9.2}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also make a variable length list of arguments with the &lt;code&gt;.nargs&lt;/code&gt;. Below are some examples.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;--input_files&#34;)&#xA;  .nargs(1, 3);  // This accepts 1 to 3 arguments.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Some useful patterns are defined like &#34;?&#34;, &#34;*&#34;, &#34;+&#34; of argparse in Python.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;--input_files&#34;)&#xA;  .nargs(argparse::nargs_pattern::any);  // &#34;*&#34; in Python. This accepts any number of arguments including 0.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;--input_files&#34;)&#xA;  .nargs(argparse::nargs_pattern::at_least_one);  // &#34;+&#34; in Python. This accepts one or more number of arguments.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;--input_files&#34;)&#xA;  .nargs(argparse::nargs_pattern::optional);  // &#34;?&#34; in Python. This accepts an argument optionally.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compound Arguments&lt;/h3&gt; &#xA;&lt;p&gt;Compound arguments are optional arguments that are combined and provided as a single argument. Example: &lt;code&gt;ps -aux&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;-a&#34;)&#xA;  .default_value(false)&#xA;  .implicit_value(true);&#xA;&#xA;program.add_argument(&#34;-b&#34;)&#xA;  .default_value(false)&#xA;  .implicit_value(true);&#xA;&#xA;program.add_argument(&#34;-c&#34;)&#xA;  .nargs(2)&#xA;  .default_value(std::vector&amp;lt;float&amp;gt;{0.0f, 0.0f})&#xA;  .scan&amp;lt;&#39;g&#39;, float&amp;gt;();&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);                  // Example: ./main -abc 1.95 2.47&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto a = program.get&amp;lt;bool&amp;gt;(&#34;-a&#34;);                  // true&#xA;auto b = program.get&amp;lt;bool&amp;gt;(&#34;-b&#34;);                  // true&#xA;auto c = program.get&amp;lt;std::vector&amp;lt;float&amp;gt;&amp;gt;(&#34;-c&#34;);    // {1.95, 2.47}&#xA;&#xA;/// Some code that prints parsed arguments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main -ac 3.14 2.718&#xA;a = true&#xA;b = false&#xA;c = {3.14, 2.718}&#xA;&#xA;foo@bar:/home/dev/$ ./main -cb&#xA;a = false&#xA;b = true&#xA;c = {0.0, 0.0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s what&#39;s happening:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We have three optional arguments &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-b&lt;/code&gt; and &lt;code&gt;-c&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-a&lt;/code&gt; and &lt;code&gt;-b&lt;/code&gt; are toggle arguments.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-c&lt;/code&gt; requires 2 floating point numbers from the command-line.&lt;/li&gt; &#xA; &lt;li&gt;argparse can handle compound arguments, e.g., &lt;code&gt;-abc&lt;/code&gt; or &lt;code&gt;-bac&lt;/code&gt; or &lt;code&gt;-cab&lt;/code&gt;. This only works with short single-character argument names. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;-a&lt;/code&gt; and &lt;code&gt;-b&lt;/code&gt; become true.&lt;/li&gt; &#xA;   &lt;li&gt;argv is further parsed to identify the inputs mapped to &lt;code&gt;-c&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;If argparse cannot find any arguments to map to c, then c defaults to {0.0, 0.0} as defined by &lt;code&gt;.default_value&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Converting to Numeric Types&lt;/h3&gt; &#xA;&lt;p&gt;For inputs, users can express a primitive type for the value.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;.scan&amp;lt;Shape, T&amp;gt;&lt;/code&gt; method attempts to convert the incoming &lt;code&gt;std::string&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt; following the &lt;code&gt;Shape&lt;/code&gt; conversion specifier. An &lt;code&gt;std::invalid_argument&lt;/code&gt; or &lt;code&gt;std::range_error&lt;/code&gt; exception is thrown for errors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;program.add_argument(&#34;-x&#34;)&#xA;       .scan&amp;lt;&#39;d&#39;, int&amp;gt;();&#xA;&#xA;program.add_argument(&#34;scale&#34;)&#xA;       .scan&amp;lt;&#39;g&#39;, double&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;Shape&lt;/code&gt; specifies what the input &#34;looks like&#34;, and the type template argument specifies the return value of the predefined action. Acceptable types are floating point (i.e float, double, long double) and integral (i.e. signed char, short, int, long, long long).&lt;/p&gt; &#xA;&lt;p&gt;The grammar follows &lt;code&gt;std::from_chars&lt;/code&gt;, but does not exactly duplicate it. For example, hexadecimal numbers may begin with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt; and numbers with a leading zero may be handled as octal values.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Shape&lt;/th&gt; &#xA;   &lt;th&gt;interpretation&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;a&#39; or &#39;A&#39;&lt;/td&gt; &#xA;   &lt;td&gt;hexadecimal floating point&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;e&#39; or &#39;E&#39;&lt;/td&gt; &#xA;   &lt;td&gt;scientific notation (floating point)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;f&#39; or &#39;F&#39;&lt;/td&gt; &#xA;   &lt;td&gt;fixed notation (floating point)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;g&#39; or &#39;G&#39;&lt;/td&gt; &#xA;   &lt;td&gt;general form (either fixed or scientific)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;d&#39;&lt;/td&gt; &#xA;   &lt;td&gt;decimal&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;i&#39;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::from_chars&lt;/code&gt; grammar with base == 10&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;o&#39;&lt;/td&gt; &#xA;   &lt;td&gt;octal (unsigned)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;u&#39;&lt;/td&gt; &#xA;   &lt;td&gt;decimal (unsigned)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&#39;x&#39; or &#39;X&#39;&lt;/td&gt; &#xA;   &lt;td&gt;hexadecimal (unsigned)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Default Arguments&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;argparse&lt;/code&gt; provides predefined arguments and actions for &lt;code&gt;-h&lt;/code&gt;/&lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;-v&lt;/code&gt;/&lt;code&gt;--version&lt;/code&gt;. By default, these actions will &lt;strong&gt;exit&lt;/strong&gt; the program after displaying a help or version message, respectively. This exit does not call destructors, skipping clean-up of taken resources.&lt;/p&gt; &#xA;&lt;p&gt;These default arguments can be disabled during &lt;code&gt;ArgumentParser&lt;/code&gt; creation so that you can handle these arguments in your own way. (Note that a program name and version must be included when choosing default arguments.)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;, &#34;1.0&#34;, default_arguments::none);&#xA;&#xA;program.add_argument(&#34;-h&#34;, &#34;--help&#34;)&#xA;  .action([=](const std::string&amp;amp; s) {&#xA;    std::cout &amp;lt;&amp;lt; help().str();&#xA;  })&#xA;  .default_value(false)&#xA;  .help(&#34;shows help message&#34;)&#xA;  .implicit_value(true)&#xA;  .nargs(0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above code snippet outputs a help message and continues to run. It does not support a &lt;code&gt;--version&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;The default is &lt;code&gt;default_arguments::all&lt;/code&gt; for included arguments. No default arguments will be added with &lt;code&gt;default_arguments::none&lt;/code&gt;. &lt;code&gt;default_arguments::help&lt;/code&gt; and &lt;code&gt;default_arguments::version&lt;/code&gt; will individually add &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default arguments can be used while disabling the default exit with these arguments. This forth argument to &lt;code&gt;ArgumentParser&lt;/code&gt; (&lt;code&gt;exit_on_default_arguments&lt;/code&gt;) is a bool flag with a default &lt;strong&gt;true&lt;/strong&gt; value. The following call will retain &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;, but will not exit when those arguments are used.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;, &#34;1.0&#34;, default_arguments::all, false)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Gathering Remaining Arguments&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;argparse&lt;/code&gt; supports gathering &#34;remaining&#34; arguments at the end of the command, e.g., for use in a compiler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ compiler file1 file2 file3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To enable this, simply create an argument and mark it as &lt;code&gt;remaining&lt;/code&gt;. All remaining arguments passed to argparse are gathered here.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;compiler&#34;);&#xA;&#xA;program.add_argument(&#34;files&#34;)&#xA;  .remaining();&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;try {&#xA;  auto files = program.get&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&#34;files&#34;);&#xA;  std::cout &amp;lt;&amp;lt; files.size() &amp;lt;&amp;lt; &#34; files provided&#34; &amp;lt;&amp;lt; std::endl;&#xA;  for (auto&amp;amp; file : files)&#xA;    std::cout &amp;lt;&amp;lt; file &amp;lt;&amp;lt; std::endl;&#xA;} catch (std::logic_error&amp;amp; e) {&#xA;  std::cout &amp;lt;&amp;lt; &#34;No files provided&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When no arguments are provided:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./compiler&#xA;No files provided&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and when multiple arguments are provided:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./compiler foo.txt bar.txt baz.txt&#xA;3 files provided&#xA;foo.txt&#xA;bar.txt&#xA;baz.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The process of gathering remaining arguments plays nicely with optional arguments too:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;compiler&#34;);&#xA;&#xA;program.add_arguments(&#34;-o&#34;)&#xA;  .default_value(std::string(&#34;a.out&#34;));&#xA;&#xA;program.add_argument(&#34;files&#34;)&#xA;  .remaining();&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto output_filename = program.get&amp;lt;std::string&amp;gt;(&#34;-o&#34;);&#xA;std::cout &amp;lt;&amp;lt; &#34;Output filename: &#34; &amp;lt;&amp;lt; output_filename &amp;lt;&amp;lt; std::endl;&#xA;&#xA;try {&#xA;  auto files = program.get&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&#34;files&#34;);&#xA;  std::cout &amp;lt;&amp;lt; files.size() &amp;lt;&amp;lt; &#34; files provided&#34; &amp;lt;&amp;lt; std::endl;&#xA;  for (auto&amp;amp; file : files)&#xA;    std::cout &amp;lt;&amp;lt; file &amp;lt;&amp;lt; std::endl;&#xA;} catch (std::logic_error&amp;amp; e) {&#xA;  std::cout &amp;lt;&amp;lt; &#34;No files provided&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./compiler -o main foo.cpp bar.cpp baz.cpp&#xA;Output filename: main&#xA;3 files provided&#xA;foo.cpp&#xA;bar.cpp&#xA;baz.cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;NOTE&lt;/strong&gt;&lt;/em&gt;: Remember to place all optional arguments BEFORE the remaining argument. If the optional argument is placed after the remaining arguments, it too will be deemed remaining:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./compiler foo.cpp bar.cpp baz.cpp -o main&#xA;5 arguments provided&#xA;foo.cpp&#xA;bar.cpp&#xA;baz.cpp&#xA;-o&#xA;main&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parent Parsers&lt;/h3&gt; &#xA;&lt;p&gt;A parser may use arguments that could be used by other parsers.&lt;/p&gt; &#xA;&lt;p&gt;These shared arguments can be added to a parser which is then used as a &#34;parent&#34; for parsers which also need those arguments. One or more parent parsers may be added to a parser with &lt;code&gt;.add_parents&lt;/code&gt;. The positional and optional arguments in each parent is added to the child parser.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser surface_parser(&#34;surface&#34;, 1.0, argparse::default_arguments::none);&#xA;parent_parser.add_argument(&#34;--area&#34;)&#xA;  .default_value(0)&#xA;  .scan&amp;lt;&#39;i&#39;, int&amp;gt;();&#xA;&#xA;argparse::ArgumentParser floor_parser(&#34;floor&#34;);&#xA;floor_parser.add_argument(&#34;tile_size&#34;).scan&amp;lt;&#39;i&#39;, int&amp;gt;();&#xA;floor_parser.add_parents(surface_parser);&#xA;floor_parser.parse_args({ &#34;./main&#34;, &#34;--area&#34;, &#34;200&#34;, &#34;12&#34; });  // --area = 200, tile_size = 12&#xA;&#xA;argparse::ArgumentParser ceiling_parser(&#34;ceiling&#34;);&#xA;ceiling_parser.add_argument(&#34;--color&#34;);&#xA;ceiling_parser.add_parents(surface_parser);&#xA;ceiling_parser.parse_args({ &#34;./main&#34;, &#34;--color&#34;, &#34;gray&#34; });  // --area = 0, --color = &#34;gray&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Changes made to parents after they are added to a parser are not reflected in any child parsers. Completely initialize parent parsers before adding them to a parser.&lt;/p&gt; &#xA;&lt;p&gt;Each parser will have the standard set of default arguments. Disable the default arguments in parent parsers to avoid duplicate help output.&lt;/p&gt; &#xA;&lt;h3&gt;Subcommands&lt;/h3&gt; &#xA;&lt;p&gt;Many programs split up their functionality into a number of sub-commands, for example, the &lt;code&gt;git&lt;/code&gt; program can invoke sub-commands like &lt;code&gt;git checkout&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, and &lt;code&gt;git commit&lt;/code&gt;. Splitting up functionality this way can be a particularly good idea when a program performs several different functions which require different kinds of command-line arguments. &lt;code&gt;ArgumentParser&lt;/code&gt; supports the creation of such sub-commands with the &lt;code&gt;add_subparser()&lt;/code&gt; member function.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;git&#34;);&#xA;&#xA;  // git add subparser&#xA;  argparse::ArgumentParser add_command(&#34;add&#34;);&#xA;  add_command.add_description(&#34;Add file contents to the index&#34;);&#xA;  add_command.add_argument(&#34;files&#34;)&#xA;    .help(&#34;Files to add content from. Fileglobs (e.g.  *.c) can be given to add all matching files.&#34;)&#xA;    .remaining();&#xA;&#xA;  // git commit subparser&#xA;  argparse::ArgumentParser commit_command(&#34;commit&#34;);&#xA;  commit_command.add_description(&#34;Record changes to the repository&#34;);&#xA;  commit_command.add_argument(&#34;-a&#34;, &#34;--all&#34;)&#xA;    .help(&#34;Tell the command to automatically stage files that have been modified and deleted.&#34;)&#xA;    .default_value(false)&#xA;    .implicit_value(true);&#xA;&#xA;  commit_command.add_argument(&#34;-m&#34;, &#34;--message&#34;)&#xA;    .help(&#34;Use the given &amp;lt;msg&amp;gt; as the commit message.&#34;);&#xA;&#xA;  // git cat-file subparser&#xA;  argparse::ArgumentParser catfile_command(&#34;cat-file&#34;);&#xA;  catfile_command.add_description(&#34;Provide content or type and size information for repository objects&#34;);&#xA;  catfile_command.add_argument(&#34;-t&#34;)&#xA;    .help(&#34;Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.&#34;);&#xA;&#xA;  catfile_command.add_argument(&#34;-p&#34;)&#xA;    .help(&#34;Pretty-print the contents of &amp;lt;object&amp;gt; based on its type.&#34;);&#xA;&#xA;  // git submodule subparser&#xA;  argparse::ArgumentParser submodule_command(&#34;submodule&#34;);&#xA;  submodule_command.add_description(&#34;Initialize, update or inspect submodules&#34;);&#xA;  argparse::ArgumentParser submodule_update_command(&#34;update&#34;);&#xA;  submodule_update_command.add_description(&#34;Update the registered submodules to match what the superproject expects&#34;);&#xA;  submodule_update_command.add_argument(&#34;--init&#34;)&#xA;    .default_value(false)&#xA;    .implicit_value(true);&#xA;  submodule_update_command.add_argument(&#34;--recursive&#34;)&#xA;    .default_value(false)&#xA;    .implicit_value(true);&#xA;  submodule_command.add_subparser(submodule_update_command);&#xA;&#xA;  program.add_subparser(add_command);&#xA;  program.add_subparser(commit_command);&#xA;  program.add_subparser(catfile_command);&#xA;  program.add_subparser(submodule_command);&#xA;&#xA;  try {&#xA;    program.parse_args(argc, argv);&#xA;  }&#xA;  catch (const std::exception&amp;amp; err) {&#xA;    std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;    std::cerr &amp;lt;&amp;lt; program;&#xA;    return 1;&#xA;  }&#xA;&#xA;  // Use arguments&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./git --help&#xA;Usage: git [-h] {add,cat-file,commit,submodule}&#xA;&#xA;Optional arguments:&#xA;  -h, --help   &#x9;shows help message and exits&#xA;  -v, --version&#x9;prints version information and exits&#xA;&#xA;Subcommands:&#xA;  add           Add file contents to the index&#xA;  cat-file      Provide content or type and size information for repository objects&#xA;  commit        Record changes to the repository&#xA;  submodule     Initialize, update or inspect submodules&#xA;&#xA;foo@bar:/home/dev/$ ./git add --help&#xA;Usage: add [-h] files&#xA;&#xA;Add file contents to the index&#xA;&#xA;Positional arguments:&#xA;  files        &#x9;Files to add content from. Fileglobs (e.g.  *.c) can be given to add all matching files.&#xA;&#xA;Optional arguments:&#xA;  -h, --help   &#x9;shows help message and exits&#xA;  -v, --version&#x9;prints version information and exits&#xA;&#xA;foo@bar:/home/dev/$ ./git commit --help&#xA;Usage: commit [-h] [--all] [--message VAR]&#xA;&#xA;Record changes to the repository&#xA;&#xA;Optional arguments:&#xA;  -h, --help   &#x9;shows help message and exits&#xA;  -v, --version&#x9;prints version information and exits&#xA;  -a, --all    &#x9;Tell the command to automatically stage files that have been modified and deleted.&#xA;  -m, --message&#x9;Use the given &amp;lt;msg&amp;gt; as the commit message.&#xA;&#xA;foo@bar:/home/dev/$ ./git submodule --help&#xA;Usage: submodule [-h] {update}&#xA;&#xA;Initialize, update or inspect submodules&#xA;&#xA;Optional arguments:&#xA;  -h, --help   &#x9;shows help message and exits&#xA;  -v, --version&#x9;prints version information and exits&#xA;&#xA;Subcommands:&#xA;  update        Update the registered submodules to match what the superproject expects&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When a help message is requested from a subparser, only the help for that particular parser will be printed. The help message will not include parent parser or sibling parser messages.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, every parser has the &lt;code&gt;.is_subcommand_used(&#34;&amp;lt;command_name&amp;gt;&#34;)&lt;/code&gt; and &lt;code&gt;.is_subcommand_used(subparser)&lt;/code&gt; member functions to check if a subcommand was used.&lt;/p&gt; &#xA;&lt;p&gt;Sometimes there may be a need to hide part of the subcommands from the user by suppressing information about them in an help message. To do this, &lt;code&gt;ArgumentParser&lt;/code&gt; contains the method &lt;code&gt;.set_suppress(bool suppress)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;argparse::ArgumentParser hidden_cmd(&#34;hidden&#34;);&#xA;hidden_cmd.add_argument(&#34;files&#34;).remaining();&#xA;hidden_cmd.set_suppress(true);&#xA;&#xA;program.add_subparser(hidden_cmd);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main -h&#xA;Usage: test [--help] [--version] {}&#xA;&#xA;Optional arguments:&#xA;  -h, --help    shows help message and exits&#xA;  -v, --version prints version information and exits&#xA;&#xA;foo@bar:/home/dev/$ ./main hidden -h&#xA;Usage: hidden [--help] [--version] files&#xA;&#xA;Positional arguments:&#xA;  files         [nargs: 0 or more]&#xA;&#xA;Optional arguments:&#xA;  -h, --help    shows help message and exits&#xA;  -v, --version prints version information and exits&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Getting Argument and Subparser Instances&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Argument&lt;/code&gt; and &lt;code&gt;ArgumentParser&lt;/code&gt; instances added to an &lt;code&gt;ArgumentParser&lt;/code&gt; can be retrieved with &lt;code&gt;.at&amp;lt;T&amp;gt;()&lt;/code&gt;. The default return type is &lt;code&gt;Argument&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;--dir&#34;);&#xA;program.at(&#34;--dir&#34;).default_value(std::string(&#34;/home/user&#34;));&#xA;&#xA;program.add_subparser(argparse::ArgumentParser{&#34;walk&#34;});&#xA;program.at&amp;lt;argparse::ArgumentParser&amp;gt;(&#34;walk&#34;).add_argument(&#34;depth&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parse Known Args&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes a program may only parse a few of the command-line arguments, passing the remaining arguments on to another script or program. In these cases, the &lt;code&gt;parse_known_args()&lt;/code&gt; function can be useful. It works much like &lt;code&gt;parse_args()&lt;/code&gt; except that it does not produce an error when extra arguments are present. Instead, it returns a list of remaining argument strings.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;#include &amp;lt;cassert&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;test&#34;);&#xA;  program.add_argument(&#34;--foo&#34;).implicit_value(true).default_value(false);&#xA;  program.add_argument(&#34;bar&#34;);&#xA;&#xA;  auto unknown_args =&#xA;    program.parse_known_args({&#34;test&#34;, &#34;--foo&#34;, &#34;--badger&#34;, &#34;BAR&#34;, &#34;spam&#34;});&#xA;&#xA;  assert(program.get&amp;lt;bool&amp;gt;(&#34;--foo&#34;) == true);&#xA;  assert(program.get&amp;lt;std::string&amp;gt;(&#34;bar&#34;) == std::string{&#34;BAR&#34;});&#xA;  assert((unknown_args == std::vector&amp;lt;std::string&amp;gt;{&#34;--badger&#34;, &#34;spam&#34;}));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ArgumentParser in bool Context&lt;/h3&gt; &#xA;&lt;p&gt;An &lt;code&gt;ArgumentParser&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; until it (or one of its subparsers) have extracted known value(s) with &lt;code&gt;.parse_args&lt;/code&gt; or &lt;code&gt;.parse_known_args&lt;/code&gt;. When using &lt;code&gt;.parse_known_args&lt;/code&gt;, unknown arguments will not make a parser &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Custom Prefix Characters&lt;/h3&gt; &#xA;&lt;p&gt;Most command-line options will use &lt;code&gt;-&lt;/code&gt; as the prefix, e.g. &lt;code&gt;-f/--foo&lt;/code&gt;. Parsers that need to support different or additional prefix characters, e.g. for options like &lt;code&gt;+f&lt;/code&gt; or &lt;code&gt;/foo&lt;/code&gt;, may specify them using the &lt;code&gt;set_prefix_chars()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default prefix character is &lt;code&gt;-&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;#include &amp;lt;cassert&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;test&#34;);&#xA;  program.set_prefix_chars(&#34;-+/&#34;);&#xA;&#xA;  program.add_argument(&#34;+f&#34;);&#xA;  program.add_argument(&#34;--bar&#34;);&#xA;  program.add_argument(&#34;/foo&#34;);&#xA;&#xA;  try {&#xA;    program.parse_args(argc, argv);&#xA;  }&#xA;  catch (const std::exception&amp;amp; err) {&#xA;    std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;    std::cerr &amp;lt;&amp;lt; program;&#xA;    return 1;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;+f&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;+f    : &#34; &amp;lt;&amp;lt; program.get(&#34;+f&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;--bar&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;--bar : &#34; &amp;lt;&amp;lt; program.get(&#34;--bar&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;/foo&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;/foo  : &#34; &amp;lt;&amp;lt; program.get(&#34;/foo&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main +f 5 --bar 3.14f /foo &#34;Hello&#34;&#xA;+f    : 5&#xA;--bar : 3.14f&#xA;/foo  : Hello&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Custom Assignment Characters&lt;/h3&gt; &#xA;&lt;p&gt;In addition to prefix characters, custom &#39;assign&#39; characters can be set. This setting is used to allow invocations like &lt;code&gt;./test --foo=Foo /B:Bar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The default assign character is &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;argparse/argparse.hpp&amp;gt;&#xA;#include &amp;lt;cassert&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;test&#34;);&#xA;  program.set_prefix_chars(&#34;-+/&#34;);&#xA;  program.set_assign_chars(&#34;=:&#34;);&#xA;&#xA;  program.add_argument(&#34;--foo&#34;);&#xA;  program.add_argument(&#34;/B&#34;);&#xA;&#xA;  try {&#xA;    program.parse_args(argc, argv);&#xA;  }&#xA;  catch (const std::exception&amp;amp; err) {&#xA;    std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;    std::cerr &amp;lt;&amp;lt; program;&#xA;    return 1;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;--foo&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;--foo : &#34; &amp;lt;&amp;lt; program.get(&#34;--foo&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;/B&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;/B    : &#34; &amp;lt;&amp;lt; program.get(&#34;/B&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main --foo=Foo /B:Bar&#xA;--foo : Foo&#xA;/B    : Bar&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Further Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Construct a JSON object from a filename argument&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;json_test&#34;);&#xA;&#xA;program.add_argument(&#34;config&#34;)&#xA;  .action([](const std::string&amp;amp; value) {&#xA;    // read a JSON file&#xA;    std::ifstream stream(value);&#xA;    nlohmann::json config_json;&#xA;    stream &amp;gt;&amp;gt; config_json;&#xA;    return config_json;&#xA;  });&#xA;&#xA;try {&#xA;  program.parse_args({&#34;./test&#34;, &#34;config.json&#34;});&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;nlohmann::json config = program.get&amp;lt;nlohmann::json&amp;gt;(&#34;config&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Positional Arguments with Compound Toggle Arguments&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;numbers&#34;)&#xA;  .nargs(3)&#xA;  .scan&amp;lt;&#39;i&#39;, int&amp;gt;();&#xA;&#xA;program.add_argument(&#34;-a&#34;)&#xA;  .default_value(false)&#xA;  .implicit_value(true);&#xA;&#xA;program.add_argument(&#34;-b&#34;)&#xA;  .default_value(false)&#xA;  .implicit_value(true);&#xA;&#xA;program.add_argument(&#34;-c&#34;)&#xA;  .nargs(2)&#xA;  .scan&amp;lt;&#39;g&#39;, float&amp;gt;();&#xA;&#xA;program.add_argument(&#34;--files&#34;)&#xA;  .nargs(3);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto numbers = program.get&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;(&#34;numbers&#34;);        // {1, 2, 3}&#xA;auto a = program.get&amp;lt;bool&amp;gt;(&#34;-a&#34;);                               // true&#xA;auto b = program.get&amp;lt;bool&amp;gt;(&#34;-b&#34;);                               // true&#xA;auto c = program.get&amp;lt;std::vector&amp;lt;float&amp;gt;&amp;gt;(&#34;-c&#34;);                 // {3.14f, 2.718f}&#xA;auto files = program.get&amp;lt;std::vector&amp;lt;std::string&amp;gt;&amp;gt;(&#34;--files&#34;);  // {&#34;a.txt&#34;, &#34;b.txt&#34;, &#34;c.txt&#34;}&#xA;&#xA;/// Some code that prints parsed arguments&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main 1 2 3 -abc 3.14 2.718 --files a.txt b.txt c.txt&#xA;numbers = {1, 2, 3}&#xA;a = true&#xA;b = true&#xA;c = {3.14, 2.718}&#xA;files = {&#34;a.txt&#34;, &#34;b.txt&#34;, &#34;c.txt&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Restricting the set of values for an argument&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;input&#34;)&#xA;  .default_value(std::string{&#34;baz&#34;})&#xA;  .choices(&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto input = program.get(&#34;input&#34;);&#xA;std::cout &amp;lt;&amp;lt; input &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main fex&#xA;Invalid argument &#34;fex&#34; - allowed options: {foo, bar, baz}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using choices also works with integer types, e.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;argparse::ArgumentParser program(&#34;test&#34;);&#xA;&#xA;program.add_argument(&#34;input&#34;)&#xA;  .default_value(0)&#xA;  .choices(0, 1, 2, 3, 4, 5);&#xA;&#xA;try {&#xA;  program.parse_args(argc, argv);&#xA;}&#xA;catch (const std::exception&amp;amp; err) {&#xA;  std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;  std::cerr &amp;lt;&amp;lt; program;&#xA;  std::exit(1);&#xA;}&#xA;&#xA;auto input = program.get(&#34;input&#34;);&#xA;std::cout &amp;lt;&amp;lt; input &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./main 6&#xA;Invalid argument &#34;6&#34; - allowed options: {0, 1, 2, 3, 4, 5}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;option=value&lt;/code&gt; syntax&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;argparse.hpp&#34;&#xA;#include &amp;lt;cassert&amp;gt;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;  argparse::ArgumentParser program(&#34;test&#34;);&#xA;  program.add_argument(&#34;--foo&#34;).implicit_value(true).default_value(false);&#xA;  program.add_argument(&#34;--bar&#34;);&#xA;&#xA;  try {&#xA;    program.parse_args(argc, argv);&#xA;  }&#xA;  catch (const std::exception&amp;amp; err) {&#xA;    std::cerr &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;    std::cerr &amp;lt;&amp;lt; program;&#xA;    return 1;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;--foo&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;--foo: &#34; &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; program.get&amp;lt;bool&amp;gt;(&#34;--foo&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }&#xA;&#xA;  if (program.is_used(&#34;--bar&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;--bar: &#34; &amp;lt;&amp;lt; program.get(&#34;--bar&#34;) &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;  }  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;foo@bar:/home/dev/$ ./test --bar=BAR --foo&#xA;--foo: true&#xA;--bar: BAR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Developer Notes&lt;/h2&gt; &#xA;&lt;h3&gt;Copying and Moving&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;argparse::ArgumentParser&lt;/code&gt; is intended to be used in a single function - setup everything and parse arguments in one place. Attempting to move or copy invalidates internal references (issue #260). Thus, starting with v3.0, &lt;code&gt;argparse::ArgumentParser&lt;/code&gt; copy and move constructors are marked as &lt;code&gt;delete&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;CMake Integration&lt;/h2&gt; &#xA;&lt;p&gt;Use the latest argparse in your CMake project without copying any content.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;cmake_minimum_required(VERSION 3.14)&#xA;&#xA;PROJECT(myproject)&#xA;&#xA;# fetch latest argparse&#xA;include(FetchContent)&#xA;FetchContent_Declare(&#xA;    argparse&#xA;    GIT_REPOSITORY https://github.com/p-ranav/argparse.git&#xA;)&#xA;FetchContent_MakeAvailable(argparse)&#xA;&#xA;add_executable(myproject main.cpp)&#xA;target_link_libraries(myproject argparse)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building, Installing, and Testing&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Clone the repository&#xA;git clone https://github.com/p-ranav/argparse&#xA;cd argparse&#xA;&#xA;# Build the tests&#xA;mkdir build&#xA;cd build&#xA;cmake -DARGPARSE_BUILD_SAMPLES=on -DARGPARSE_BUILD_TESTS=on ..&#xA;make&#xA;&#xA;# Run tests&#xA;./test/tests&#xA;&#xA;# Install the library&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Supported Toolchains&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Compiler&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Standard Library&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Test Environment&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;GCC &amp;gt;= 8.3.0&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;libstdc++&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Ubuntu 18.04&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Clang &amp;gt;= 7.0.0&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;libc++&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Xcode 10.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;MSVC &amp;gt;= 16.8&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Microsoft STL&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Visual Studio 2019&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome, have a look at the &lt;a href=&#34;https://raw.githubusercontent.com/p-ranav/argparse/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; document for more information.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The project is available under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;</summary>
  </entry>
</feed>