<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-07T01:31:55Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>matthieu-hackwitharts/Win32_Offensive_Cheatsheet</title>
    <updated>2022-09-07T01:31:55Z</updated>
    <id>tag:github.com,2022-09-07:/matthieu-hackwitharts/Win32_Offensive_Cheatsheet</id>
    <link href="https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Win32 and Kernel abusing techniques for pentesters&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Win32 Offensive Cheatsheet&lt;/h1&gt; &#xA;&lt;p&gt;Win32 and Kernel abusing techniques for pentesters &amp;amp; red-teamers made by &lt;a href=&#34;https://github.com/matthieu-hackwitharts&#34;&gt;@UVision&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/RistBs&#34;&gt;@RistBS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dev mode enabled, open to any help :)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#windows-binary-documentation&#34;&gt;Windows Binary Documentation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#pe-headers&#34;&gt;PE structure&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#pe-headers&#34;&gt;PE Headers &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#parsing-pe&#34;&gt;Parsing PE &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#export-address-table-eat&#34;&gt;Export Address Table (EAT) &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#export-address-table&#34;&gt;Resolve function address &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#import-address-table-iat&#34;&gt;Import Address Table (IAT) &lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#parsing-iat&#34;&gt;Parsing IAT &lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#import-lookup-table&#34;&gt;Import Lookup Table (ILT) &lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#execute-some-binary&#34;&gt;Execute some binary&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#classic-shellcode-execution&#34;&gt;Classic shellcode execution&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#dll-execute&#34;&gt;DLL execute &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#raw-file-to-pe&#34;&gt;RAW file to PE&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#code-injection-techniques&#34;&gt;Code injection techniques&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#createremotethread-injection&#34;&gt;CreateRemoteThread injection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#process-hollowing&#34;&gt;Process Hollowing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#apc-queue-technique&#34;&gt;APC Queue technique&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#early-bird&#34;&gt;Early Bird&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#reflective-dll-injection&#34;&gt;Reflective DLL Injection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#dll-injection&#34;&gt;Dll injection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#process-doppelganging&#34;&gt;Process Doppelganging&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#fibers&#34;&gt;Fibers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;CreateThreadPoolWait ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Thread Hijacking ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;MapView code injection ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Module Stomping ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#function-stomping&#34;&gt;Function Stomping&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#hooking-techniques&#34;&gt;Hooking techniques&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#inline-hooking&#34;&gt;Inline hooking&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#iat-hooking&#34;&gt;IAT hooking&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#re-bypass-techniques&#34;&gt;RE Bypass techniques&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#call-and-strings-obfuscation&#34;&gt;Call and Strings obfuscation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#manual-function-resolve&#34;&gt;Manual function resolve&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#win32-api-hashing&#34;&gt;Win32 API Hashing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#edrendpoint-bypass&#34;&gt;EDR/Endpoint bypass&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#direct-syscall&#34;&gt;Direct syscall &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#high-level-languages&#34;&gt;High level languages &lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#patch-inline-hooking&#34;&gt;Patch inline hooking&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#detect-hooks&#34;&gt;Detect hooks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#patch-etw&#34;&gt;Patch ETW&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#sandbox-bypass&#34;&gt;Sandbox bypass&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#debugging-bypass&#34;&gt;Debugging Bypass&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#virtualprotect-technique&#34;&gt;VirtualProtect technique&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#fresh-copy-unhook&#34;&gt;Fresh copy unhook&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#hells-gate&#34;&gt;Hell&#39;s Gate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#heavens-gate&#34;&gt;Heaven&#39;s Gate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#ppid-spoofing&#34;&gt;PPID spoofing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Patch Kernel callbacks ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Heap &amp;amp; Stack Encryption ⏳&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#driver-programming-basics&#34;&gt;Driver Programming basics&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#general-concepts&#34;&gt;General concepts&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#system-service-dispatch-table-ssdt&#34;&gt;System Service Dispatch Table (SSDT)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#driver-entry&#34;&gt;Driver entry&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#input-output&#34;&gt;Input Output)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#communicate-with-the-driver&#34;&gt;Communicate with driver&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#driver-signing&#34;&gt;Driver signing (Microsoft)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#offensive-driver-programming&#34;&gt;Offensive Driver Programming&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#process-protection-removing&#34;&gt;Process protection removing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Patch kernel callback (dev way) ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Integrity and privileges levels ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Enable SeDebug privilege ⏳&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#using-win32-api-to-increase-opsec&#34;&gt;Using Win32 API to increase OPSEC&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Persistence ⏳&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;&#34;&gt;Scheduled Tasks ⏳&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#command-line-spoofing&#34;&gt;Command line spoofing&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#misc-stuff&#34;&gt;Misc Stuff&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;HTTP/S communication ⏳&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;&#34;&gt;Indirect Execution ⏳&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;&#34;&gt;CFG Bypass with SetProcessValidCallTargets ⏳&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#malwaresophisticated-techniques&#34;&gt;Malware/Sophisticated techniques&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#emotet-ppid-spoofing&#34;&gt;Case of Emotet : PPID Spoofing using WMI&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#zeus-malware-hidden-files&#34;&gt;Zeus malware hidden files technique&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#spyeye-keyloger-hooking-technique&#34;&gt;SpyEye keyloger hooking technique&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#wannacry-killswitch&#34;&gt;Most ridiculous malware stop (WannaCry)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Windows Binary Documentation&lt;/h1&gt; &#xA;&lt;h2&gt;Useful tools and Websites/Books/Cheatsheet&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://github.com/RistBS/Awesome-RedTeam-Cheatsheet/&#34;&gt;https://github.com/RistBS/Awesome-RedTeam-Cheatsheet/&lt;/a&gt; (Very Good Cheatsheet)&lt;/li&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://www.ired.team/&#34;&gt;https://www.ired.team/&lt;/a&gt; (Awesome red team cheatsheet with great code injection notes)&lt;/li&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://undocumented.ntinternals.net/&#34;&gt;https://undocumented.ntinternals.net/&lt;/a&gt; (Undocumented NT functions)&lt;/li&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/api/&#34;&gt;https://docs.microsoft.com/en-us/windows/win32/api/&lt;/a&gt; (Microsoft Official Doc)&lt;/li&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://www.amazon.fr/Windows-Kernel-Programming-Pavel-Yosifovich/dp/1977593372&#34;&gt;Windows Kernel Programming - Pavel Yosifovich&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://research.checkpoint.com/&#34;&gt;https://research.checkpoint.com/&lt;/a&gt; (Very interesting docs about evasion, anti-debug and so more)&lt;/li&gt; &#xA; &lt;li&gt;🔹 &lt;a href=&#34;https://www.vx-underground.org/&#34;&gt;https://www.vx-underground.org/&lt;/a&gt; (Awesome content about malware dev and reverse)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;PE Structure&lt;/h2&gt; &#xA;&lt;h3&gt;PE Headers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;DOS_HEADER&lt;/code&gt; : First Header of PE, contains MS DOS message (&#34;This programm cannot be run in DOS mode....&#34;), MZ Header (Magic bytes to identify PE) and some stub content.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IMAGE_NT_HEADER&lt;/code&gt; : Contains PE file signature, File Header and Optionnal Header&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SECTION_TABLE&lt;/code&gt; : Contains sections headers&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SECTIONS&lt;/code&gt; : Not a header but useful to know : these are sections of the PE&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Details : &lt;a href=&#34;https://www.researchgate.net/figure/PE-structure-of-normal-executable_fig1_259647266&#34;&gt;https://www.researchgate.net/figure/PE-structure-of-normal-executable_fig1_259647266&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Parsing PE&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Simple PE parsing to retrieve IAT and ILT absolute address:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Obtain base address&lt;/strong&gt; : &lt;code&gt;GetModuleHandleA(NULL);&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PIMAGE_DOS_HEADER&lt;/strong&gt; = base address, dos header&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;PIMAGE_NT_HEADER&lt;/strong&gt; = &lt;code&gt;BaseAddress+PIMAGE_DOS_HEADER.e_lfnanew&lt;/code&gt; (RVA NT_HEADER)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;IMAGE_DATA_DIRECTORY&lt;/strong&gt; = &lt;code&gt;OptionnalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]&lt;/code&gt; of PIMAGE_NT_HEADER&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;IMAGE_IMPORT_DIRECTORY&lt;/strong&gt; = &lt;code&gt;IMAGE_DATA_DIRECTORY.VirtualAddress&lt;/code&gt; (RVA of IMAGE_IMPORT_DIRECTORY)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;IMAGE_IMPORT_DESCRIPTOR&lt;/strong&gt; = &lt;code&gt;BaseAddress + IMAGE_IMPORT_DIRECTORY.VirtualAddress&lt;/code&gt; (RVA of IMAGE_IMPORT_DESCRIPTOR)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;IAT absolute address&lt;/strong&gt; : IMAGE_IMPORT_DESCRIPTOR.FirstThunk (RVA IAT) + BaseAddress&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ILT absolute address&lt;/strong&gt; : IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk (RVA ILT) + BaseAddress&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Export Address Table (EAT)&lt;/h3&gt; &#xA;&lt;p&gt;The EAT Resolves all functions that are exported by the PE &amp;amp; resolves also DLLs. It Defined in IMAGE_EXPORT_DIRECTORY structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _IMAGE_EXPORT_DIRECTORY {&#xA;&#x9;&#x9;DWORD Characteristics;&#xA;&#x9;&#x9;DWORD TimeDateStamp;&#xA;&#x9;&#x9;WORD  MajorVersion;&#xA;&#x9;&#x9;WORD  MinorVersion;&#xA;&#x9;&#x9;DWORD Name;   // name of DLL&#xA;&#x9;&#x9;DWORD Base;   // first ordinal number&#xA;&#x9;&#x9;DWORD NumberOfFunctions; // number of entries in EAT&#xA;&#x9;&#x9;DWORD NumberOfNames; // number of entries in (1) (2)&#xA;&#x9;&#x9;DWORD AddressOfFunctions; // RVA EAT and contains also RVA of exported functions&#xA;&#x9;&#x9;DWORD AddressOfNames;   // Pointer array contains address of function names&#xA;&#x9;&#x9;DWORD AddressOfNameOrdinals; // Pointer array contains address of ordinal number of functions (index in AddressOfFunctions)&#xA;} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;   &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Resolve function address&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using function address&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;What do you wait ? Find this function !&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using ordinal number&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;An ordinal number is an &lt;strong&gt;index position&lt;/strong&gt; to the corresponding function address in &lt;code&gt;AddressOfFunctions&lt;/code&gt; array. It can be used to &lt;strong&gt;retrieve the correct address of function&lt;/strong&gt;, like below :&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s try to find the corresponding address (Addr4) with given ordinal number 3.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;AddressOfFunctions&lt;/strong&gt; : &lt;em&gt;Addr1 Addr2 Addr3 Addr4 .... AddrN&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;AdressOfNameOrdinals&lt;/strong&gt; : &lt;em&gt;2 5 7 3 ... N&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The address we are looking for is on 3th position (from 0), and our ordinal number corresponds to the &lt;strong&gt;index of this address&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Using function name&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The Nth element in AddressOfNames array corresponding to the Nth element in AddressOfNameOrdinals array : using a given name, you can retrieve the corresponding ordinal number, and proceed to find the function address using this number.&lt;/p&gt; &#xA;&lt;h2&gt;Import Address Table (IAT)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The PE loader doesn&#39;t know what address is corresponding to which function (again more with ASLR) : Let&#39;s call IAT to save us&lt;/li&gt; &#xA; &lt;li&gt;Defined in IMAGE_IMPORT_DIRECTORY struct:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct _IMAGE_IMPORT_DESCRIPTOR {&#xA;    DWORD&#x9;Characteristics; &#xA;    DWORD&#x9;OriginalFirstThunk;&#x9;// RVA to ILT&#xA;    DWORD&#x9;TimeDateStamp;&#x9;&#xA;    DWORD&#x9;ForwarderChain;&#xA;    DWORD&#x9;Name; &#x9;&#x9;        // RVA of imported DLL name&#xA;    DWORD&#x9;FirstThunk;             // RVA to IAT&#xA;} IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Parsing IAT&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Obtain RVA of IAT&lt;/li&gt; &#xA; &lt;li&gt;Parse trough IMPORT_DESCRIPTOR structure : Name member is the RVA of the name of current DLL&lt;/li&gt; &#xA; &lt;li&gt;To get the real DLL name : find it in ILT (originalFirstThunk+BaseAddress)&lt;/li&gt; &#xA; &lt;li&gt;To get exported functions of current DLL : PIMAGE_IMPORT_BY_NAME function_name-&amp;gt;Name = ImageBase+AdressOfData&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Detailed code example here : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/miscellaneous/iat_parser.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/miscellaneous/iat_parser.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Import Lookup Table&lt;/h2&gt; &#xA;&lt;p&gt;Every DLLs imported by PE has its own ILT.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Absolute address of ILT = BaseAddress + OriginalFirstThunk (IAT)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It contains all functions name that are in imported DLL.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Execute some binary&lt;/h1&gt; &#xA;&lt;h2&gt;Classic shellcode execution&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/classic.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/classic.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;DLL Execute&lt;/h2&gt; &#xA;&lt;p&gt;This technique had some good successful bypass rates few years ago; however, because of increasing number of EDR and other endpoint solutions, writing on disk should as possible be avoided.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/dll_classic.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/dll_classic.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Raw File To PE&lt;/h2&gt; &#xA;&lt;p&gt;You can execute some raw binary file in memory by allocate its size space in a memory region :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;HANDLE binfile = CreateFileA(&#34;myfile.bin&#34;,GENERIC_READ,NULL,NULL,OPEN_EXISTING,NULL,NULL);&#xA;SIZE_T size = GetFileSize(binfile,NULL);&#xA;LPVOID buffer=NULL;&#xA;ReadFile(binfile,buffer,size,NULL,NULL);&#xA;HANDLE hProc = GetCurrentProcess();&#xA;&#xA;CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);&#xA;CloseHandle(hProc);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Code injection techniques&lt;/h1&gt; &#xA;&lt;h2&gt;CreateRemoteThread injection&lt;/h2&gt; &#xA;&lt;p&gt;Simply write your shellcode in previously allocated memory space inside the target process. (Not OPSEC)&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/create_thread_injection.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/create_thread_injection.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Process Hollowing&lt;/h2&gt; &#xA;&lt;p&gt;Process Hollowing is made in several steps :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create the targeted process (&#34;hollowed&#34; one) in suspended mode : it is needed to modify it&lt;/li&gt; &#xA; &lt;li&gt;Unmap the targeted process from its PEB (You must declare this structure first)&lt;/li&gt; &#xA; &lt;li&gt;Write the content of the new exe in this process : headers + content&lt;/li&gt; &#xA; &lt;li&gt;Parse and apply relocation table&lt;/li&gt; &#xA; &lt;li&gt;Let the process continue to run in its thread&lt;/li&gt; &#xA; &lt;li&gt;Enjoy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Complete POC can be found here : &lt;a href=&#34;https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations&#34;&gt;https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;APC Queue Technique&lt;/h2&gt; &#xA;&lt;p&gt;Inject your shellcode in all available threads in a process, then use &lt;code&gt;QueueUserAPC()&lt;/code&gt; function to query an APC call. This technique can not be reliable when there are no many threads in the compromised process.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/apc.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/apc.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Early Bird&lt;/h2&gt; &#xA;&lt;p&gt;Similar to APC Queue injection, here the APC call must be set in a suspended process. The created process main thread is then resume; the main advantage of this technique is that avoiding writing the shellcode in a running process will be less detected by AV/EDRs.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/earlybird.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/earlybird.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Reflective DLL Injection&lt;/h2&gt; &#xA;&lt;p&gt;As with the &#34;static&#34; dll injection (by using dll file), you can inject your own DLL in most processes by reflecting it in memory. It has the advantage to easily bypass some AV/EDrs products despite it&#39;s a quite flagged way today.&lt;/p&gt; &#xA;&lt;p&gt;You must first allocate memory and do some reloc work to make it works.&lt;/p&gt; &#xA;&lt;p&gt;The well-knowned Poc about this technique was published by stephenfewer : &lt;a href=&#34;https://github.com/stephenfewer/ReflectiveDLLInjection&#34;&gt;https://github.com/stephenfewer/ReflectiveDLLInjection&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Dll injection&lt;/h2&gt; &#xA;&lt;p&gt;You can inject some code stored in a dll in a remote process. Unfortunately, EDRs product will likely catch it easily, especially if malicious dll touch the disk.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/dll_injection.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/dll_injection.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Process Doppelganging&lt;/h2&gt; &#xA;&lt;p&gt;Process Doppelganging was until a few years an untected method of launching your own payload into some tricky way. It has been demonstrated at BlackHat 2017 by Tal Liberman and Eugene Kogan, see their amazing work : &lt;a href=&#34;https://www.youtube.com/watch?v=Cch8dvp836w&#34;&gt;https://www.youtube.com/watch?v=Cch8dvp836w&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;It is an &#34;intermediate&#34; step before the process hollowing technique : the PE image is indeed overwrited before to get executed, so the WindowsLoader make the Process Hollowing for us (so cool, right ?).&lt;/p&gt; &#xA;&lt;p&gt;Hasherezade has maked some cool POC of this technique, availabe here : &lt;a href=&#34;https://github.com/hasherezade/process_doppelganging&#34;&gt;https://github.com/hasherezade/process_doppelganging&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Fibers&lt;/h2&gt; &#xA;&lt;p&gt;Fibers can be defined as &lt;code&gt;cooperatively scheduled threads (https://nullprogram.com/blog/2019/03/28/)&lt;/code&gt;. It allows the main program to execute the shellcode trough this new thread type.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/shellcode_samples/fiber.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/shellcode_samples/fiber.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;CreateThreadPoolWait ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;Thread Hijacking ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;MapView code injection ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;Module Stomping ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;Function Stomping&lt;/h2&gt; &#xA;&lt;p&gt;Simply replace the original function address (obtained with GetProcAddress) with the new one. This technique is well detailed by his author : &lt;a href=&#34;https://idov31.github.io/2022-01-28-function-stomping/&#34;&gt;https://idov31.github.io/2022-01-28-function-stomping/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Hooking techniques&lt;/h1&gt; &#xA;&lt;h2&gt;Inline hooking&lt;/h2&gt; &#xA;&lt;p&gt;Inline hooking is the most basic way to hook a function : it simply consists to redirect the API call to your own function (jump)&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/hooking/inline.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/hooking/inline.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;IAT hooking&lt;/h2&gt; &#xA;&lt;p&gt;By modifying the corresponding function address to a pointer on your own function, you can make the programm executing your own code.&lt;/p&gt; &#xA;&lt;p&gt;It can be done by following several steps :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Find the relative address of IAT&lt;/li&gt; &#xA; &lt;li&gt;Parse the IAT to find the function you want to hook&lt;/li&gt; &#xA; &lt;li&gt;Replace this function address (&#34;patch&#34;) with the adress of your function&lt;/li&gt; &#xA; &lt;li&gt;Enjoy&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/hooking/iat.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/hooking/iat.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;RE Bypass techniques&lt;/h1&gt; &#xA;&lt;h2&gt;Call and Strings obfuscation&lt;/h2&gt; &#xA;&lt;p&gt;There are several techniques you can use to hide your calls to win32 api, here are some of them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use &lt;code&gt;char[]&lt;/code&gt; array to splice your function/dll names into multiple chars&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char sWrite[] = {&#39;W&#39;,&#39;r&#39;,&#39;i&#39;,&#39;t&#39;,&#39;e&#39;,&#39;P&#39;,&#39;r&#39;,&#39;o&#39;,&#39;c&#39;,&#39;e&#39;,&#39;s&#39;,&#39;s&#39;,&#39;M&#39;,&#39;e&#39;,&#39;m&#39;,&#39;o&#39;,&#39;r&#39;,&#39;y&#39;,0x0}; //don&#39;t forget the null byte&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;You can even combine this trick with some ASCII char code convert.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Manual function resolve&lt;/h2&gt; &#xA;&lt;p&gt;You can manually resolve a pointer to any function of kernel32, ntdll and so more.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First declare the template of your function, based on the real function header :&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef HANDLE(WINAPI* myOpenProcess)(DWORD,BOOL,DWORD); //if you work directly with ntdll, use NTAPI*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Then resolve a pointer to the function :&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;myOpenProcess op_proc = (myOpenProcess*)GetProcAddress(LoadLibraryA(&#34;ndll.dll&#34;),&#34;OpenProcess&#34;));&#xA;op_proc(PROCESS_ALL_ACCESS,NULL,12345);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Don&#39;t hesitate to combine this technique with some strings obfuscation to avoid passing the real func name in plaintext.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Win32 API Hashing&lt;/h2&gt; &#xA;&lt;p&gt;You can hide your API function calls by hash them with some hash algorithm (djb2 is the most used), be careful of hash collision that are possible with some special funcs. Then combine this technique with a direct address resolving in EAT, and let reversers cry :)&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;EDR/Endpoint bypass&lt;/h1&gt; &#xA;&lt;h2&gt;Direct Syscall&lt;/h2&gt; &#xA;&lt;p&gt;Most EDR products will hook win32 api calls in user mode (PatchGuard strongly decrease kernel hooks availability). To avoid these hooks, you can directly call Nt() equivalent to your api functions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;.code&#xA;&#x9;SysNtCreateFile proc&#xA;&#x9;&#x9;&#x9;mov r10, rcx //syscall convention&#xA;&#x9;&#x9;&#x9;mov eax, 55h //syscall number : in this case it&#39;s NtCreateFile&#xA;&#x9;&#x9;&#x9;syscall //call nt function&#xA;&#x9;&#x9;&#x9;ret&#xA;&#x9;SysNtCreateFile endp&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Find the right syscall number at this table : &lt;a href=&#34;https://j00ru.vexillium.org/syscalls/nt/64/&#34;&gt;https://j00ru.vexillium.org/syscalls/nt/64/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Build the Function Prototype using &lt;code&gt;NTSTATUS&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;EXTERN_C NTSTATUS SysNtCreateFile(&#xA;&#x9;PHANDLE FileHandle, &#xA;&#x9;ACCESS_MASK DesiredAccess, &#xA;&#x9;POBJECT_ATTRIBUTES ObjectAttributes, &#xA;&#x9;PIO_STATUS_BLOCK IoStatusBlock, &#xA;&#x9;PLARGE_INTEGER AllocationSize, &#xA;&#x9;ULONG FileAttributes, &#xA;&#x9;ULONG ShareAccess, &#xA;&#x9;ULONG CreateDisposition, &#xA;&#x9;ULONG CreateOptions, &#xA;&#x9;PVOID EaBuffer, &#xA;&#x9;ULONG EaLength);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resolve the NT address&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;FARPROC addr = GetProcAddress(LoadLibraryA(&#34;ntdll&#34;), &#34;NtCreateFile&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample : &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/evasion/direct_syscall.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/evasion/direct_syscall.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;High Level Languages&lt;/h2&gt; &#xA;&lt;p&gt;C++/C are often more flagged by AV/EDR products than high level equivalent languages : use Go, Rust or other language to craft your best templates,&lt;/p&gt; &#xA;&lt;h2&gt;Patch Inline Hooking&lt;/h2&gt; &#xA;&lt;p&gt;Simply (re) hook your hooked functions by apply the right function call: &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/raw/main/hooking/inline.cpp&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/blob/main/hooking/inline.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Detect hooks&lt;/h2&gt; &#xA;&lt;p&gt;To detect hooks, you&#39;ll first get the base address of the NTDLL with &lt;code&gt;LoadLibrary&lt;/code&gt;, then you will parse the PE headers to locate EAT (IMAGE_EXPORT_DIRECTORY) and its offsets which will contain all the important information (exported functions + name). just resolve function names &amp;amp; addresses while iterating through exported functions and apply the following &lt;code&gt;if&lt;/code&gt; statements to sort functions&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;sort functions to get only Nt or Zw functions&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (strncmp(functionName, (char*)&#34;Nt&#34;, 2) == 0 || strncmp(functionName, (char*)&#34;Zw&#34;, 2) == 0) { // ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;⚠️&lt;/strong&gt; : some functions are false positive I recommand you to detect them :&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;        if (strncmp(functionName, (char*)&#34;NtGetTickCount&#34;, 14) == 0 ||&#xA;             strncmp(functionName, (char*)&#34;NtQuerySystemTime&#34;, 17) == 0 ||&#xA;              strncmp(functionName, (char*)&#34;NtdllDefWindowProc_A&#34;, 20) == 0 ||&#xA;               strncmp(functionName, (char*)&#34;NtdllDefWindowProc_W&#34;, 20) == 0 ||&#xA;                strncmp(functionName, (char*)&#34;NtdllDialogWndProc_A&#34;, 20) == 0 ||&#xA;                 strncmp(functionName, (char*)&#34;NtdllDialogWndProc_W&#34;, 20) == 0 ||&#xA;                  strncmp(functionName, (char*)&#34;ZwQuerySystemTime&#34;, 17) == 0) { }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;for the last &lt;code&gt;if&lt;/code&gt; statement, check if the first 4 bytes of &lt;code&gt;functionName&lt;/code&gt; is equal to &lt;code&gt;mov r10, rcx; mov eax, ##&lt;/code&gt; which is the beginning of the syscall stub&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (memcmp(functionAddress, syscallPrologue, 4) != 0) { // ... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Code sample: &lt;a href=&#34;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/tree/main/evasion/detect_hooks.c&#34;&gt;https://github.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/tree/main/evasion/detect_hooks.c&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Patch ETW&lt;/h2&gt; &#xA;&lt;p&gt;Event Tracing for Windows (ETW) is a logging low-level API which can be used for debugging/logging kernel and usermode process. It has been first implemented in Windows 2000, but realtime monitoring is really available since Windows XP.&lt;/p&gt; &#xA;&lt;p&gt;ETW API is available from headers files provided by Microsoft : &lt;a href=&#34;https://docs.microsoft.com/fr-fr/windows/win32/api/_etw/&#34;&gt;https://docs.microsoft.com/fr-fr/windows/win32/api/_etw/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;In a pentest operation, you should care about this functionality by patching it : the most used way is to write arbitrary &lt;code&gt;ret&lt;/code&gt; opcodes into the ETW event writing function (&lt;code&gt;EtwEventWrite&lt;/code&gt;) to avoid logs be writing somewhere.&lt;/p&gt; &#xA;&lt;p&gt;Code sample : //&lt;/p&gt; &#xA;&lt;h2&gt;Sandbox Bypass&lt;/h2&gt; &#xA;&lt;p&gt;Sandbox are quite used by AV/EDRs to test some API calls and other part of code before to really execute your programm. There are several techniques to avoid this tool, here are some of them below :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Wait. Seriously. Such function as &lt;code&gt;Sleep()&lt;/code&gt; or &lt;code&gt;time.sleep()&lt;/code&gt; or equivalent will do the job, for some seconds before to execute the real shellcode.&lt;/li&gt; &#xA; &lt;li&gt;Try to allocate lot of memory (malloc), like 100000000 bytes.&lt;/li&gt; &#xA; &lt;li&gt;Try to detect if you are actually in a sandbox (VM) environnement : test for open process,files and others suspicious things.&lt;/li&gt; &#xA; &lt;li&gt;Try to resolve a fake (not working) URL : many AVs products will respond with fake page.&lt;/li&gt; &#xA; &lt;li&gt;Use strange and rarely used Api calls, like &lt;code&gt;VirtualAllocExNuma()&lt;/code&gt; most sandbox cannot emulate this type of call.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Debugging Bypass&lt;/h2&gt; &#xA;&lt;p&gt;Not a real AV evasion technique, but still useful to avoid being reversed too easily by RE engineers. There are so many ways to detect or make debuggers crazy, but here are some of them below :&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Flags way&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;IsDebuggerPresent()&lt;/code&gt; (Win32) or direct call &lt;code&gt;NtQueryInformationProcess()&lt;/code&gt; (not so very documented) to check for debug flags.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Handles way&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Try to close invalid (missing) handles with CloseHandle() API. The debugger will try to catch the exception, which can be easily detected :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool Check() //https://anti-debug.checkpoint.com/techniques/object-handles.html#closehandle&#xA;{&#xA;    __try&#xA;    {&#xA;        CloseHandle((HANDLE)0xDEADBEEF);&#xA;        return false;&#xA;    }&#xA;    __except (EXCEPTION_INVALID_HANDLE == GetExceptionCode()&#xA;                ? EXCEPTION_EXECUTE_HANDLER &#xA;                : EXCEPTION_CONTINUE_SEARCH)&#xA;    {&#xA;        return true;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;ASM way&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Try to make an INT 3 call (ASM) : it&#39;s an equivalent to a software breakpoint, which will trigger a debugger. There are so many other ways to detect any debugger, a lot of them are compiled at : &lt;a href=&#34;https://anti-debug.checkpoint.com/&#34;&gt;https://anti-debug.checkpoint.com/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;VirtualProtect technique&lt;/h2&gt; &#xA;&lt;p&gt;By using some tricks with &lt;code&gt;VirtualProtect()&lt;/code&gt; you can easily avoid been flagged in-memory : change between &lt;code&gt;PAGE_EXECUTE_READWRITE&lt;/code&gt; and &lt;code&gt;PAGE_READWRITE&lt;/code&gt; (less suspicious) to avoid triggering your favorite AV.&lt;/p&gt; &#xA;&lt;h2&gt;Fresh Copy Unhook&lt;/h2&gt; &#xA;&lt;p&gt;Avoid hooks by replacing the &#34;hooked&#34; ntdll by a fresh one, directly mapped from the disk.&lt;/p&gt; &#xA;&lt;p&gt;Code sample : // to add&lt;/p&gt; &#xA;&lt;h2&gt;Hells Gate&lt;/h2&gt; &#xA;&lt;p&gt;To avoid using hardcoded syscalls, Hell&#39;s Gate (Hells Gates ?) retrieve them dynamically by parsing EAT (compare memory bytes to syscall opcodes). The original Poc has been made by the great VX-Underground team, and can be found here : &lt;a href=&#34;https://papers.vx-underground.org/papers/Windows/Evasion%20-%20Systems%20Call%20and%20Memory%20Evasion/Dynamically%20Retrieving%20SYSCALLs%20-%20Hells%20Gate.7z&#34;&gt;https://papers.vx-underground.org/papers/Windows/Evasion%20-%20Systems%20Call%20and%20Memory%20Evasion/Dynamically%20Retrieving%20SYSCALLs%20-%20Hells%20Gate.7z&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Heavens Gate&lt;/h2&gt; &#xA;&lt;p&gt;Use Wow64 to inject 64 bits payload in 32 bits loader. Can be useful to bypass some AV/EDRs because Wow64 will avoid you to be catch in userland.&lt;/p&gt; &#xA;&lt;p&gt;The most known version of this technique has been created by the MSF team, see their awesome work here : &lt;a href=&#34;https://github.com/rapid7/metasploit-framework/raw/21fa8a89044220a3bf335ed77293300969b81e78/external/source/shellcode/windows/x86/src/migrate/executex64.asm&#34;&gt;https://github.com/rapid7/metasploit-framework/blob/21fa8a89044220a3bf335ed77293300969b81e78/external/source/shellcode/windows/x86/src/migrate/executex64.asm&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;PPID Spoofing&lt;/h2&gt; &#xA;&lt;p&gt;When a suspicious/anormal process start below a &#34;legit&#34; or unattended process parent, it become very suspicious. Think about a malicious Word macro which deploy a powershell process : such strange, right ?&lt;/p&gt; &#xA;&lt;p&gt;PPID Spoofing can avoid that by allowing you to modify the parent process id (PPID) of your spawned process.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;windows.h&amp;gt;&#xA;#include &amp;lt;TlHelp32.h&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;&#xA;//code from : https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing&#xA;int main() &#xA;{&#xA;&#x9;STARTUPINFOEXA si;&#xA;&#x9;PROCESS_INFORMATION pi;&#xA;&#x9;SIZE_T attributeSize;&#xA;&#x9;ZeroMemory(&amp;amp;si, sizeof(STARTUPINFOEXA));&#xA;&#x9;&#xA;&#x9;HANDLE parentProcessHandle = OpenProcess(MAXIMUM_ALLOWED, false, 6200);&#xA;&#xA;&#x9;InitializeProcThreadAttributeList(NULL, 1, 0, &amp;amp;attributeSize);&#xA;&#x9;si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, attributeSize);&#xA;&#x9;InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &amp;amp;attributeSize);&#xA;&#x9;UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;amp;parentProcessHandle, sizeof(HANDLE), NULL, NULL);&#xA;&#x9;si.StartupInfo.cb = sizeof(STARTUPINFOEXA);&#xA;&#xA;&#x9;CreateProcessA(NULL, (LPSTR)&#34;notepad&#34;, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &amp;amp;si.StartupInfo, &amp;amp;pi);&#xA;&#xA;&#x9;return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Patch Kernel callbacks ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;Heap &amp;amp; Stack Encryption ⏳&lt;/h2&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Driver Programming basics&lt;/h1&gt; &#xA;&lt;h2&gt;General concepts&lt;/h2&gt; &#xA;&lt;p&gt;Driver are used to execute code in kernel mode rather than in user mode. It is a powerful technique to bypass all usermode hooks and monitoring which were set by AV/EDRs. It can be also used to bypass kernel callbacks and other kernel monitoring.&lt;/p&gt; &#xA;&lt;p&gt;The code of any driver must be verified (any warning should be treated as an error) to ensure it will be crash-free (You don&#39;t want to cause BSOD during pentest, right ?).&lt;/p&gt; &#xA;&lt;p&gt;Few years ago, Microsoft decided to ban unsigned drivers from his operating system : you must disable it before to load your own driver, or use any vulnerability (like &lt;a href=&#34;https://github.com/hmnthabit/CVE-2018-19320-LPE&#34;&gt;https://github.com/hmnthabit/CVE-2018-19320-LPE&lt;/a&gt;) to disable driver signing.&lt;/p&gt; &#xA;&lt;p&gt;In a real pentest, you must find any vulnerable driver and profit:)&lt;/p&gt; &#xA;&lt;h2&gt;System Service Dispatch Table (SSDT)&lt;/h2&gt; &#xA;&lt;p&gt;SSDT, or System Service Dispatch Table is a table (obvious) which can resolve by its current index the corresponding Nt function. When any usermode call is made, it is resolved as below :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;OpenProcess&lt;/code&gt; (Win32 API function is called)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;NtOpenProcess&lt;/code&gt; (Resolved in ntdll.dll)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;mov r10, rcx&#xA;mov eax, 26 &#xA;syscall&#xA;ret&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ntdll contains system call procedures for each Nt function&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;26 is the &lt;strong&gt;service system number&lt;/strong&gt; : it is an index in the SSDT that resolves the address of the kernel NtOpenProcess function.&lt;/li&gt; &#xA; &lt;li&gt;Kernelmode NtOpenProcess is called, and communicate with I/O as a part of a driver.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;SSDT is defined in a &lt;strong&gt;Service Descriptor Table&lt;/strong&gt; :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef struct tagSERVICE_DESCRIPTOR_TABLE {&#xA;    SYSTEM_SERVICE_TABLE nt; //effectively a pointer to Service Dispatch Table (SSDT) itself&#xA;    SYSTEM_SERVICE_TABLE win32k;&#xA;    SYSTEM_SERVICE_TABLE sst3; //pointer to a memory address that contains how many routines are defined in the table&#xA;    SYSTEM_SERVICE_TABLE sst4;&#xA;} SERVICE_DESCRIPTOR_TABLE;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;SSDT is/was often hooked by rootkits as it was possible to modify the corresponding address to their own functions. &lt;strong&gt;Patchguard&lt;/strong&gt; has disabled this possibility, unless in case of some internal vulnerability.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Many antivirus products are also using this trick today, probably by using the same techniques than evil hackers;)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Driver entry&lt;/h2&gt; &#xA;&lt;p&gt;Driver entry proc is defined as below :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;ntddk.h&amp;gt;&#xA;&#xA;NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {&#xA;&#x9;return STATUS_SUCCESS;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is very important to use &lt;code&gt;UNREFERENCED_PARAMETER()&lt;/code&gt; macro on &lt;code&gt;DriverObject&lt;/code&gt; and &lt;code&gt;RegistryPath&lt;/code&gt; parameters, unless they are referenced by adding some code later.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;UNREFERENCED_PARAMETER(DriverObject);&#xA;UNREFERENCED_PARAMETER(RegistryPath);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Input Output&lt;/h2&gt; &#xA;&lt;p&gt;Use MajorFunction &lt;code&gt;IRP_MJ_CREATE&lt;/code&gt; and &lt;code&gt;IRP_MJ_CLOSE&lt;/code&gt; to act as &#34;interrupt&#34; to communicate with your driver from client-side.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DriverObject-&amp;gt;MajorFunction[IRP_MJ_CREATE] = CreateClose;&#xA;&#x9;DriverObject-&amp;gt;MajorFunction[IRP_MJ_CLOSE] = CreateClose;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then define your CreateClose function :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NTSTATUS&#xA;CreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp) {&#xA;&#x9;UNREFERENCED_PARAMETER(DeviceObject);&#xA;&#xA;&#x9;DbgPrint(&#34;[+] Hello from FirstDriver CreateClose\n&#34;);&#xA;&#xA;&#x9;Irp-&amp;gt;IoStatus.Status = STATUS_SUCCESS;&#xA;&#x9;Irp-&amp;gt;IoStatus.Information = 0;&#xA;&#xA;&#x9;IoCompleteRequest(Irp, IO_NO_INCREMENT);&#xA;&#x9;return STATUS_SUCCESS;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Complete sample code here : //&lt;/p&gt; &#xA;&lt;h2&gt;Communicate with the driver&lt;/h2&gt; &#xA;&lt;p&gt;User-mode applications send IOCTLs to drivers by calling DeviceIoControl, which is described in Microsoft Windows SDK documentation. Calls to DeviceIoControl cause the I/O manager to create an IRP_MJ_DEVICE_CONTROL request and send it to the topmost driver (&lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-i-o-control-codes&#34;&gt;https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-i-o-control-codes&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;p&gt;The userland app must use DeviceIoControl (ioapiset.h) function to communicate with a driver. It will be used to send various requests to its &lt;strong&gt;Device&lt;/strong&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;Simple sample code here : //todo&lt;/p&gt; &#xA;&lt;h2&gt;Driver signing (Microsoft)&lt;/h2&gt; &#xA;&lt;p&gt;As described in &lt;a href=&#34;https://raw.githubusercontent.com/matthieu-hackwitharts/Win32_Offensive_Cheatsheet/main/#general-concepts&#34;&gt;General concepts&lt;/a&gt; section, drivers must be signed before to install on a Windows system. Despite the fact you must use some driver or kernel exploit to bypass it (Gigabyte driver CVE for example), you can still disable it manually:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;bcdedit.exe -set loadoptions DISABLE_INTEGRITY_CHECKS&#xA;bcdedit.exe -set TESTSIGNING ON&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then restart your computer. Obviously you need local admin rights on the machine you want to execute these command. As a restart is needed, &lt;strong&gt;this not OPSEC at all&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Offensive Driver Programming&lt;/h1&gt; &#xA;&lt;h2&gt;Process protection removing&lt;/h2&gt; &#xA;&lt;p&gt;A &lt;strong&gt;protected process&lt;/strong&gt; have the &#34;protected&#34; mode enable in the kernel : using the PPL (Protected Process Light) technology, it can be protected from various things like code injection, memory dump, etc. You can enable it for lsass to avoid password dumping by modifying some reg keys.&lt;/p&gt; &#xA;&lt;p&gt;To remove this protection, you must load some malicious driver.&lt;/p&gt; &#xA;&lt;p&gt;Code sample : //&lt;/p&gt; &#xA;&lt;h2&gt;Patch kernel callback (dev way) ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;Integrity and privileges levels ⏳&lt;/h2&gt; &#xA;&lt;h2&gt;Enable SeDebug privilege ⏳&lt;/h2&gt; &#xA;&lt;h1&gt;Using Win32 API to increase OPSEC&lt;/h1&gt; &#xA;&lt;h2&gt;Persistence ⏳&lt;/h2&gt; &#xA;&lt;h3&gt;Scheduled Tasks ⏳&lt;/h3&gt; &#xA;&lt;h2&gt;Command line spoofing&lt;/h2&gt; &#xA;&lt;p&gt;Works perfectly even with sysmon/process hacker monitoring; it enables the ability to hide your command args, which can be useful in pentest/red team ops (&lt;code&gt;powershell -enc .....&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;To achieve that objective, you can spawn a new process with &#34;legit&#34; command args in supended mode, then edit these args directly in PEB.&lt;/p&gt; &#xA;&lt;p&gt;Poc : &lt;a href=&#34;https://github.com/NVISOsecurity/blogposts/raw/master/examples-commandlinespoof/Example%203%20-%20CMD%20spawn%20with%20fake%20procexp%20args/code.cpp&#34;&gt;https://github.com/NVISOsecurity/blogposts/blob/master/examples-commandlinespoof/Example%203%20-%20CMD%20spawn%20with%20fake%20procexp%20args/code.cpp&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Misc Stuff&lt;/h1&gt; &#xA;&lt;h2&gt;HTTP/S communication&lt;/h2&gt; &#xA;&lt;h2&gt;Indirect Execution&lt;/h2&gt; &#xA;&lt;h3&gt;CFG Bypass with SetProcessValidCallTargets&lt;/h3&gt; &#xA;&lt;h1&gt;Malware/Sophisticated techniques&lt;/h1&gt; &#xA;&lt;h2&gt;Emotet PPID Spoofing&lt;/h2&gt; &#xA;&lt;p&gt;This technique has been discovered in the well-known malware Emotet. To spawn a new powershell process (intented to execute some payload), it use the COM api with a WMI instance. With this trick, the powershell process is spawned as a child process of the WMIPrvSE process, which far less suspicious than be spawning by a suspicious exe or even a Word file.&lt;/p&gt; &#xA;&lt;h2&gt;Zeus Malware Hidden Files&lt;/h2&gt; &#xA;&lt;p&gt;The well-know Zeus malware use some quite ingenious trick to hide its logs (keystrokes, password ,etc) in the compromised system. It hooks the &lt;code&gt;NtQueryDirectoryFile()&lt;/code&gt; function to filter displayed results.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef struct _FILE_NAMES_INFORMATION {&#xA; ULONG NextEntryOffset;&#xA; ULONG FileIndex;&#xA; ULONG FileNameLength;&#xA; WCHAR FileName[1];&#xA;} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;&#xA;&#xA; if (file_matches)&#xA; {&#xA;&#xA; // Check for end of list&#xA; if (pCurrentFileNames-&amp;gt;NextEntryOffset == 0)&#xA; {&#xA; // Hide current file&#xA; if (pPrev)&#xA; pPrevFileNames-&amp;gt;NextEntryOffset = 0;&#xA; else&#xA; return STATUS_NO_SUCH_FILE; &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Source : &lt;a href=&#34;https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf&#34;&gt;https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;SpyEye keyloger hooking technique&lt;/h2&gt; &#xA;&lt;p&gt;SpyEye malware hooks &lt;code&gt;TranslateMessage()&lt;/code&gt; function to save keystrokes : the hook procedure use &lt;code&gt;GetKeyboardState&lt;/code&gt; function to add the typed char to a 20000 bytes buffer.&lt;/p&gt; &#xA;&lt;p&gt;Source : &lt;a href=&#34;https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf&#34;&gt;https://ioactive.com/pdfs/ZeusSpyEyeBankingTrojanAnalysis.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Wannacry KillSwitch&lt;/h2&gt; &#xA;&lt;p&gt;Wannacry ransomware used a killswitch URL which was resolved before the execution of the main payload. After this domaine has been registred, all wannacry samples has been disabled. This technique was related here : &lt;a href=&#34;https://www.malwaretech.com/2017/05/how-to-accidentally-stop-a-global-cyber-attacks.html&#34;&gt;https://www.malwaretech.com/2017/05/how-to-accidentally-stop-a-global-cyber-attacks.html&lt;/a&gt; Fun fact: this domain was in clear string, without any obfuscation. Quite funny:)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>recastnavigation/recastnavigation</title>
    <updated>2022-09-07T01:31:55Z</updated>
    <id>tag:github.com,2022-09-07:/recastnavigation/recastnavigation</id>
    <link href="https://github.com/recastnavigation/recastnavigation" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Navigation-mesh Toolset for Games&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Recast &amp;amp; Detour&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/recastnavigation/recastnavigation&#34;&gt;&lt;img src=&#34;https://travis-ci.org/recastnavigation/recastnavigation.svg?branch=master&#34; alt=&#34;Travis (Linux) Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/recastnavigation/recastnavigation/branch/master&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/20w84u25b3f8h179/branch/master?svg=true&#34; alt=&#34;Appveyor (Windows) Build  Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/recastnavigation/recastnavigation/master/RecastDemo/screenshot.png?raw=true&#34; alt=&#34;screenshot of a navmesh baked with the sample program&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Recast&lt;/h2&gt; &#xA;&lt;p&gt;Recast is state of the art navigation mesh construction toolset for games.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It is automatic, which means that you can throw any level geometry at it and you will get robust mesh out&lt;/li&gt; &#xA; &lt;li&gt;It is fast which means swift turnaround times for level designers&lt;/li&gt; &#xA; &lt;li&gt;It is open source so it comes with full source and you can customize it to your heart&#39;s content.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Recast process starts with constructing a voxel mold from a level geometry and then casting a navigation mesh over it. The process consists of three steps, building the voxel mold, partitioning the mold into simple regions, peeling off the regions as simple polygons.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The voxel mold is built from the input triangle mesh by rasterizing the triangles into a multi-layer heightfield. Some simple filters are then applied to the mold to prune out locations where the character would not be able to move.&lt;/li&gt; &#xA; &lt;li&gt;The walkable areas described by the mold are divided into simple overlayed 2D regions. The resulting regions have only one non-overlapping contour, which simplifies the final step of the process tremendously.&lt;/li&gt; &#xA; &lt;li&gt;The navigation polygons are peeled off from the regions by first tracing the boundaries and then simplifying them. The resulting polygons are finally converted to convex polygons which makes them perfect for pathfinding and spatial reasoning about the level.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Detour&lt;/h2&gt; &#xA;&lt;p&gt;Recast is accompanied with Detour, path-finding and spatial reasoning toolkit. You can use any navigation mesh with Detour, but of course the data generated with Recast fits perfectly.&lt;/p&gt; &#xA;&lt;p&gt;Detour offers simple static navigation mesh which is suitable for many simple cases, as well as tiled navigation mesh which allows you to plug in and out pieces of the mesh. The tiled mesh allows you to create systems where you stream new navigation data in and out as the player progresses the level, or you may regenerate tiles as the world changes.&lt;/p&gt; &#xA;&lt;h2&gt;Recast Demo&lt;/h2&gt; &#xA;&lt;p&gt;You can find a comprehensive demo project in RecastDemo folder. It is a kitchen sink demo containing all the functionality of the library. If you are new to Recast &amp;amp; Detour, check out &lt;a href=&#34;https://raw.githubusercontent.com/recastnavigation/recastnavigation/master/RecastDemo/Source/Sample_SoloMesh.cpp&#34;&gt;Sample_SoloMesh.cpp&lt;/a&gt; to get started with building navmeshes and &lt;a href=&#34;https://raw.githubusercontent.com/recastnavigation/recastnavigation/master/RecastDemo/Source/NavMeshTesterTool.cpp&#34;&gt;NavMeshTesterTool.cpp&lt;/a&gt; to see how Detour can be used to find paths.&lt;/p&gt; &#xA;&lt;h3&gt;Building RecastDemo&lt;/h3&gt; &#xA;&lt;p&gt;RecastDemo uses &lt;a href=&#34;http://premake.github.io/&#34;&gt;premake5&lt;/a&gt; to build platform specific projects. Download it and make sure it&#39;s available on your path, or specify the path to it.&lt;/p&gt; &#xA;&lt;h4&gt;Linux&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install SDL2 and its dependencies according to your distro&#39;s guidelines.&lt;/li&gt; &#xA; &lt;li&gt;run &lt;code&gt;premake5 gmake&lt;/code&gt; from the &lt;code&gt;RecastDemo&lt;/code&gt; folder.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd Build/gmake&lt;/code&gt; then &lt;code&gt;make&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd RecastDemo/Bin&lt;/code&gt; and then run &lt;code&gt;./RecastDemo&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;OSX&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Grab the latest SDL2 development library dmg from &lt;a href=&#34;https://www.libsdl.org/download-2.0.php&#34;&gt;here&lt;/a&gt; and place &lt;code&gt;SDL2.framework&lt;/code&gt; in &lt;code&gt;/Library/Frameworks/&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Navigate to the &lt;code&gt;RecastDemo&lt;/code&gt; folder and run &lt;code&gt;premake5 xcode4&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Open &lt;code&gt;Build/xcode4/recastnavigation.xcworkspace&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select the &#34;RecastDemo&#34; project in the left pane, go to the &#34;BuildPhases&#34; tab and expand &#34;Link Binary With Libraries&#34;&lt;/li&gt; &#xA; &lt;li&gt;Remove the existing entry for SDL2 (it should have a white box icon) and re-add it by hitting the plus, selecting &#34;Add Other&#34;, and selecting &lt;code&gt;/Library/Frameworks/SDL2.framework&lt;/code&gt;. It should now have a suitcase icon.&lt;/li&gt; &#xA; &lt;li&gt;Set the RecastDemo project as the target and build.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Windows&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Grab the latest SDL2 development library release from &lt;a href=&#34;https://www.libsdl.org/download-2.0.php&#34;&gt;here&lt;/a&gt; and unzip it &lt;code&gt;RecastDemo\Contrib&lt;/code&gt;. Rename the SDL folder such that the path &lt;code&gt;RecastDemo\Contrib\SDL\lib\x86&lt;/code&gt; is valid.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;&#34;premake5&#34; vs2019&lt;/code&gt; from the &lt;code&gt;RecastDemo&lt;/code&gt; folder&lt;/li&gt; &#xA; &lt;li&gt;Open the solution, build, and run.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running Unit tests&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Follow the instructions to build RecastDemo above. Premake should generate another build target called &#34;Tests&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Build the &#34;Tests&#34; project. This will generate an executable named &#34;Tests&#34; in &lt;code&gt;RecastDemo/Bin/&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run the &#34;Tests&#34; executable. It will execute all the unit tests, indicate those that failed, and display a count of those that succeeded.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Integrating with your own project&lt;/h2&gt; &#xA;&lt;p&gt;It is recommended to add the source directories &lt;code&gt;DebugUtils&lt;/code&gt;, &lt;code&gt;Detour&lt;/code&gt;, &lt;code&gt;DetourCrowd&lt;/code&gt;, &lt;code&gt;DetourTileCache&lt;/code&gt;, and &lt;code&gt;Recast&lt;/code&gt; into your own project depending on which parts of the project you need. For example your level building tool could include &lt;code&gt;DebugUtils&lt;/code&gt;, &lt;code&gt;Recast&lt;/code&gt;, and &lt;code&gt;Detour&lt;/code&gt;, and your game runtime could just include &lt;code&gt;Detour&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/recastnavigation/recastnavigation/master/CONTRIBUTING.md&#34;&gt;Contributing document&lt;/a&gt; for guidelines for making contributions.&lt;/p&gt; &#xA;&lt;h2&gt;Discuss&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Discuss Recast &amp;amp; Detour: &lt;a href=&#34;http://groups.google.com/group/recastnavigation&#34;&gt;http://groups.google.com/group/recastnavigation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Development blog: &lt;a href=&#34;http://digestingduck.blogspot.com/&#34;&gt;http://digestingduck.blogspot.com/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Recast &amp;amp; Detour is licensed under ZLib license, see License.txt for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Xaymar/obs-StreamFX</title>
    <updated>2022-09-07T01:31:55Z</updated>
    <id>tag:github.com,2022-09-07:/Xaymar/obs-StreamFX</id>
    <link href="https://github.com/Xaymar/obs-StreamFX" rel="alternate"></link>
    <summary type="html">&lt;p&gt;StreamFX is a plugin for OBS® Studio which adds many new effects, filters, sources, transitions and encoders - all for free! Be it 3D Transform, Blur, complex Masking, or even custom shaders, you&#39;ll find it all here.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Xaymar/obs-StreamFX/master/media/logo.png&#34; alt=&#34;StreamFX Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;StreamFX&lt;/h1&gt; &#xA;&lt;p&gt;StreamFX is a plugin to libOBS (OBS Studio, StreamElements OBS Live) that adds new sources, filters and transitions to give you the ability to drastically improve your stream and recording setup past what was possible in OBS Studio until now. Whether it is blurring out a region, moving something in 3D, or just writing your own shaders as a new transition, source or filter - StreamFX has it all.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Xaymar/obs-StreamFX/actions&#34;&gt;&lt;img src=&#34;https://github.com/Xaymar/obs-StreamFX/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crowdin.com/project/obs-stream-effects&#34;&gt;&lt;img src=&#34;https://badges.crowdin.net/obs-stream-effects/localized.svg?sanitize=true&#34; alt=&#34;Crowdin&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support the StreamFX project!&lt;/h2&gt; &#xA;&lt;p&gt;Like any other free project, StreamFX relies on donations to be continuously developed and stay free. If StreamFX helped you, consider helping the StreamFX project by making a one time donation via &lt;a href=&#34;https://www.paypal.me/xaymar&#34;&gt;PayPal&lt;/a&gt;, or a continuous donation via &lt;a href=&#34;https://www.patreon.com/Xaymar&#34;&gt;Patreon&lt;/a&gt; or &lt;a href=&#34;https://github.com/sponsors/Xaymar&#34;&gt;Github Sponsors&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;There&#39;s two ways you can directly contribute to the project. One is by &lt;a href=&#34;https://crowdin.com/project/obs-stream-effects&#34;&gt;submitting translations into your language on Crowdin&lt;/a&gt;, and the other is &lt;a href=&#34;https://github.com/Xaymar/obs-StreamFX/raw/master/CONTRIBUTING.md&#34;&gt;by contributing code to the project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Further Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Xaymar/obs-StreamFX/wiki&#34;&gt;Wiki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xaymar/obs-streamfx/wiki/Installation&#34;&gt;Installation Guide&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>