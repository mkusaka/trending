<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-10-01T01:29:21Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>getml/reflect-cpp</title>
    <updated>2024-10-01T01:29:21Z</updated>
    <id>tag:github.com,2024-10-01:/getml/reflect-cpp</id>
    <link href="https://github.com/getml/reflect-cpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A C++20 library for fast serialization, deserialization and validation using reflection. Supports JSON, BSON, CBOR, flexbuffers, msgpack, TOML, XML, YAML / msgpack.org[C++20]&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://img.shields.io/badge/c++-%2300599C.svg?style=for-the-badge&amp;amp;logo=c%2B%2B&amp;amp;logoColor=white&#34; alt=&#34;C++&#34;&gt; reflect-cpp&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://GitHub.com/Naereen/StrapDown.js/graphs/commit-activity&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Maintained%3F-yes-green.svg?sanitize=true&#34; alt=&#34;Maintenance&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://shields.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/C++-20-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://shields.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/gcc-11+-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://shields.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/clang-14+-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://shields.io/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/MSVC-17+-blue.svg?sanitize=true&#34; alt=&#34;Generic badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/getml/reflect-cpp/main/banner1.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;reflect-cpp&lt;/strong&gt; is a C++-20 library for &lt;strong&gt;fast serialization, deserialization and validation&lt;/strong&gt; using reflection, similar to &lt;a href=&#34;https://github.com/pydantic/pydantic&#34;&gt;pydantic&lt;/a&gt; in Python, &lt;a href=&#34;https://github.com/serde-rs&#34;&gt;serde&lt;/a&gt; in Rust, &lt;a href=&#34;https://github.com/golang/go/tree/master/src/encoding&#34;&gt;encoding&lt;/a&gt; in Go or &lt;a href=&#34;https://github.com/haskell/aeson/tree/master&#34;&gt;aeson&lt;/a&gt; in Haskell.&lt;/p&gt; &#xA;&lt;p&gt;As the aforementioned libraries are among the most widely used in the respective languages, reflect-cpp fills an important gap in C++ development. It reduces boilerplate code and increases code safety.&lt;/p&gt; &#xA;&lt;p&gt;Design principles for reflect-cpp include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Close integration with containers from the C++ standard library&lt;/li&gt; &#xA; &lt;li&gt;Close adherence to C++ idioms&lt;/li&gt; &#xA; &lt;li&gt;Out-of-the-box support for JSON&lt;/li&gt; &#xA; &lt;li&gt;Simple installation&lt;/li&gt; &#xA; &lt;li&gt;Simple extendability to other serialization formats&lt;/li&gt; &#xA; &lt;li&gt;Simple extendability to custom classes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Serialization formats&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp provides a unified reflection-based interface across different serialization formats. It is deliberately designed in a very modular way, using &lt;a href=&#34;https://en.cppreference.com/w/cpp/language/constraints&#34;&gt;concepts&lt;/a&gt;, to make it as easy as possible to interface various C or C++ libraries related to serialization. Refer to the &lt;a href=&#34;https://github.com/getml/reflect-cpp/tree/main/docs&#34;&gt;documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;The following table lists the serialization formats currently supported by reflect-cpp and the underlying libraries used:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Format&lt;/th&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;   &lt;th&gt;License&lt;/th&gt; &#xA;   &lt;th&gt;Remarks&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ibireme/yyjson&#34;&gt;yyjson&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;0.8.0&lt;/td&gt; &#xA;   &lt;td&gt;MIT&lt;/td&gt; &#xA;   &lt;td&gt;out-of-the-box support, included in this repository&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;BSON&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/mongodb/mongo-c-driver&#34;&gt;libbson&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 1.25.1&lt;/td&gt; &#xA;   &lt;td&gt;Apache 2.0&lt;/td&gt; &#xA;   &lt;td&gt;JSON-like binary format&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CBOR&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/intel/tinycbor&#34;&gt;tinycbor&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 0.6.0&lt;/td&gt; &#xA;   &lt;td&gt;MIT&lt;/td&gt; &#xA;   &lt;td&gt;JSON-like binary format&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;flexbuffers&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/google/flatbuffers&#34;&gt;flatbuffers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 23.5.26&lt;/td&gt; &#xA;   &lt;td&gt;Apache 2.0&lt;/td&gt; &#xA;   &lt;td&gt;Schema-less version of flatbuffers, binary format&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;msgpack&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/msgpack/msgpack-c&#34;&gt;msgpack-c&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 6.0.0&lt;/td&gt; &#xA;   &lt;td&gt;BSL 1.0&lt;/td&gt; &#xA;   &lt;td&gt;JSON-like binary format&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TOML&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/marzer/tomlplusplus&#34;&gt;toml++&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 3.4.0&lt;/td&gt; &#xA;   &lt;td&gt;MIT&lt;/td&gt; &#xA;   &lt;td&gt;Textual format with an emphasis on readability&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;XML&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/zeux/pugixml&#34;&gt;pugixml&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 1.14&lt;/td&gt; &#xA;   &lt;td&gt;MIT&lt;/td&gt; &#xA;   &lt;td&gt;Textual format used in many legacy projects&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;YAML&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/jbeder/yaml-cpp&#34;&gt;yaml-cpp&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;gt;= 0.8.0&lt;/td&gt; &#xA;   &lt;td&gt;MIT&lt;/td&gt; &#xA;   &lt;td&gt;Textual format with an emphasis on readability&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Support for more serialization formats is in development. Refer to the &lt;a href=&#34;https://github.com/getml/reflect-cpp/issues&#34;&gt;issues&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;Please also refer to the &lt;em&gt;vcpkg.json&lt;/em&gt; in this repository.&lt;/p&gt; &#xA;&lt;h2&gt;Simple Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;rfl/json.hpp&amp;gt;&#xA;#include &amp;lt;rfl.hpp&amp;gt;&#xA;&#xA;struct Person {&#xA;  std::string first_name;&#xA;  std::string last_name;&#xA;  int age;&#xA;};&#xA;&#xA;const auto homer =&#xA;    Person{.first_name = &#34;Homer&#34;,&#xA;           .last_name = &#34;Simpson&#34;,&#xA;           .age = 45};&#xA;&#xA;// We can now write into and read from a JSON string.&#xA;const std::string json_string = rfl::json::write(homer);&#xA;auto homer2 = rfl::json::read&amp;lt;Person&amp;gt;(json_string).value();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting JSON string looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;first_name&#34;:&#34;Homer&#34;,&#34;last_name&#34;:&#34;Simpson&#34;,&#34;age&#34;:45}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can transform the field names from &lt;code&gt;snake_case&lt;/code&gt; to &lt;code&gt;camelCase&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const std::string json_string = &#xA;  rfl::json::write&amp;lt;rfl::SnakeCaseToCamelCase&amp;gt;(homer);&#xA;auto homer2 = &#xA;  rfl::json::read&amp;lt;Person, rfl::SnakeCaseToCamelCase&amp;gt;(json_string).value();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting JSON string looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;firstName&#34;:&#34;Homer&#34;,&#34;lastName&#34;:&#34;Simpson&#34;,&#34;age&#34;:45}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can use another format, such as YAML.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;rfl/yaml.hpp&amp;gt;&#xA;&#xA;// ... (same as above)&#xA;&#xA;const std::string yaml_string = rfl::yaml::write(homer);&#xA;auto homer2 = rfl::yaml::read&amp;lt;Person&amp;gt;(yaml_string).value();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting YAML string looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;first_name: Homer&#xA;last_name: Simpson&#xA;age: 45&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will work for just about any example in the entire documentation and any supported format, except where explicitly noted otherwise:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;rfl::bson::write(homer);&#xA;rfl::cbor::write(homer);&#xA;rfl::flexbuf::write(homer);&#xA;rfl::msgpack::write(homer);&#xA;rfl::toml::write(homer);&#xA;rfl::xml::write(homer);&#xA;&#xA;rfl::bson::read&amp;lt;Person&amp;gt;(bson_bytes);&#xA;rfl::cbor::read&amp;lt;Person&amp;gt;(cbor_bytes);&#xA;rfl::flexbuf::read&amp;lt;Person&amp;gt;(flexbuf_bytes);&#xA;rfl::msgpack::read&amp;lt;Person&amp;gt;(msgpack_bytes);&#xA;rfl::toml::read&amp;lt;Person&amp;gt;(toml_string);&#xA;rfl::xml::read&amp;lt;Person&amp;gt;(xml_string);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More Comprehensive Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;&#xA;#include &amp;lt;rfl/json.hpp&amp;gt;&#xA;#include &amp;lt;rfl.hpp&amp;gt;&#xA;&#xA;// Age must be a plausible number, between 0 and 130. This will&#xA;// be validated automatically.&#xA;using Age = rfl::Validator&amp;lt;int, rfl::Minimum&amp;lt;0&amp;gt;, rfl::Maximum&amp;lt;130&amp;gt;&amp;gt;;&#xA;&#xA;struct Person {&#xA;  rfl::Rename&amp;lt;&#34;firstName&#34;, std::string&amp;gt; first_name;&#xA;  rfl::Rename&amp;lt;&#34;lastName&#34;, std::string&amp;gt; last_name = &#34;Simpson&#34;;&#xA;  std::string town = &#34;Springfield&#34;;&#xA;  rfl::Timestamp&amp;lt;&#34;%Y-%m-%d&#34;&amp;gt; birthday;&#xA;  Age age;&#xA;  rfl::Email email;&#xA;  std::vector&amp;lt;Person&amp;gt; children;&#xA;};&#xA;&#xA;const auto bart = Person{.first_name = &#34;Bart&#34;,&#xA;                         .birthday = &#34;1987-04-19&#34;,&#xA;                         .age = 10,&#xA;                         .email = &#34;bart@simpson.com&#34;};&#xA;&#xA;const auto lisa = Person{.first_name = &#34;Lisa&#34;,&#xA;                         .birthday = &#34;1987-04-19&#34;,&#xA;                         .age = 8,&#xA;                         .email = &#34;lisa@simpson.com&#34;};&#xA;&#xA;const auto maggie = Person{.first_name = &#34;Maggie&#34;,&#xA;                           .birthday = &#34;1987-04-19&#34;,&#xA;                           .age = 0,&#xA;                           .email = &#34;maggie@simpson.com&#34;};&#xA;&#xA;const auto homer =&#xA;    Person{.first_name = &#34;Homer&#34;,&#xA;           .birthday = &#34;1987-04-19&#34;,&#xA;           .age = 45,&#xA;           .email = &#34;homer@simpson.com&#34;,&#xA;           .children = std::vector&amp;lt;Person&amp;gt;({bart, lisa, maggie})};&#xA;&#xA;// We can now transform this into a JSON string.&#xA;const std::string json_string = rfl::json::write(homer);&#xA;std::cout &amp;lt;&amp;lt; json_string &amp;lt;&amp;lt; std::endl;&#xA;&#xA;// We can also directly write into std::cout (or any other std::ostream).&#xA;rfl::json::write(homer, std::cout) &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This results in the following JSON string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;firstName&#34;:&#34;Homer&#34;,&#34;lastName&#34;:&#34;Simpson&#34;,&#34;town&#34;:&#34;Springfield&#34;,&#34;birthday&#34;:&#34;1987-04-19&#34;,&#34;age&#34;:45,&#34;email&#34;:&#34;homer@simpson.com&#34;,&#34;children&#34;:[{&#34;firstName&#34;:&#34;Bart&#34;,&#34;lastName&#34;:&#34;Simpson&#34;,&#34;town&#34;:&#34;Springfield&#34;,&#34;birthday&#34;:&#34;1987-04-19&#34;,&#34;age&#34;:10,&#34;email&#34;:&#34;bart@simpson.com&#34;,&#34;children&#34;:[]},{&#34;firstName&#34;:&#34;Lisa&#34;,&#34;lastName&#34;:&#34;Simpson&#34;,&#34;town&#34;:&#34;Springfield&#34;,&#34;birthday&#34;:&#34;1987-04-19&#34;,&#34;age&#34;:8,&#34;email&#34;:&#34;lisa@simpson.com&#34;,&#34;children&#34;:[]},{&#34;firstName&#34;:&#34;Maggie&#34;,&#34;lastName&#34;:&#34;Simpson&#34;,&#34;town&#34;:&#34;Springfield&#34;,&#34;birthday&#34;:&#34;1987-04-19&#34;,&#34;age&#34;:0,&#34;email&#34;:&#34;maggie@simpson.com&#34;,&#34;children&#34;:[]}]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also create structs from the string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto homer2 = rfl::json::read&amp;lt;Person&amp;gt;(json_string).value();&#xA;&#xA;// Fields can be accessed like this:&#xA;std::cout &amp;lt;&amp;lt; &#34;Hello, my name is &#34; &amp;lt;&amp;lt; homer.first_name() &amp;lt;&amp;lt; &#34; &#34;&#xA;          &amp;lt;&amp;lt; homer.last_name() &amp;lt;&amp;lt; &#34;.&#34; &amp;lt;&amp;lt; std::endl;&#xA;&#xA;// Since homer2 is mutable, we can also change the values like this:&#xA;homer2.first_name = &#34;Marge&#34;;&#xA;&#xA;std::cout &amp;lt;&amp;lt; &#34;Hello, my name is &#34; &amp;lt;&amp;lt; homer2.first_name() &amp;lt;&amp;lt; &#34; &#34;&#xA;          &amp;lt;&amp;lt; homer2.last_name() &amp;lt;&amp;lt; &#34;.&#34; &amp;lt;&amp;lt; std::endl;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Error messages&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp returns clear and comprehensive error messages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const std::string faulty_json_string =&#xA;    R&#34;({&#34;firstName&#34;:&#34;Homer&#34;,&#34;lastName&#34;:12345,&#34;town&#34;:&#34;Springfield&#34;,&#34;birthday&#34;:&#34;04/19/1987&#34;,&#34;age&#34;:145,&#34;email&#34;:&#34;homer(at)simpson.com&#34;})&#34;;&#xA;const auto result = rfl::json::read&amp;lt;Person&amp;gt;(faulty_json_string);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Yields the following error message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Found 5 errors:&#xA;1) Failed to parse field &#39;lastName&#39;: Could not cast to string.&#xA;2) Failed to parse field &#39;birthday&#39;: String &#39;04/19/1987&#39; did not match format &#39;%Y-%m-%d&#39;.&#xA;3) Failed to parse field &#39;age&#39;: Value expected to be less than or equal to 130, but got 145.&#xA;4) Failed to parse field &#39;email&#39;: String &#39;homer(at)simpson.com&#39; did not match format &#39;Email&#39;: &#39;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&#39;.&#xA;5) Field named &#39;children&#39; not found.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;JSON schema&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp also supports generating JSON schemata:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Person {&#xA;  std::string first_name;&#xA;  std::string last_name;&#xA;  rfl::Description&amp;lt;&#34;Must be a proper email in the form xxx@xxx.xxx.&#34;,&#xA;                   rfl::Email&amp;gt;&#xA;      email;&#xA;  rfl::Description&amp;lt;&#xA;      &#34;The person&#39;s children. Pass an empty array for no children.&#34;,&#xA;      std::vector&amp;lt;Person&amp;gt;&amp;gt;&#xA;      children;&#xA;  float salary;&#xA;};&#xA;&#xA;const std::string json_schema = rfl::json::to_schema&amp;lt;Person&amp;gt;();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting JSON schema looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;$schema&#34;:&#34;https://json-schema.org/draft/2020-12/schema&#34;,&#34;$ref&#34;:&#34;#/definitions/Person&#34;,&#34;definitions&#34;:{&#34;Person&#34;:{&#34;type&#34;:&#34;object&#34;,&#34;properties&#34;:{&#34;children&#34;:{&#34;type&#34;:&#34;array&#34;,&#34;description&#34;:&#34;The person&#39;s children. Pass an empty array for no children.&#34;,&#34;items&#34;:{&#34;$ref&#34;:&#34;#/definitions/Person&#34;}},&#34;email&#34;:{&#34;type&#34;:&#34;string&#34;,&#34;description&#34;:&#34;Must be a proper email in the form xxx@xxx.xxx.&#34;,&#34;pattern&#34;:&#34;^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$&#34;},&#34;first_name&#34;:{&#34;type&#34;:&#34;string&#34;},&#34;last_name&#34;:{&#34;type&#34;:&#34;string&#34;},&#34;salary&#34;:{&#34;type&#34;:&#34;number&#34;}},&#34;required&#34;:[&#34;children&#34;,&#34;email&#34;,&#34;first_name&#34;,&#34;last_name&#34;,&#34;salary&#34;]}}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that this is currently supported for JSON only, since most other formats do not support schemata in the first place.&lt;/p&gt; &#xA;&lt;h2&gt;Enums&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp supports scoped enumerations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class Shape { circle, square, rectangle };&#xA;&#xA;enum class Color { red = 256, green = 512, blue = 1024, yellow = 2048 };&#xA;&#xA;struct Item {&#xA;  float pos_x;&#xA;  float pos_y;&#xA;  Shape shape;&#xA;  Color color;&#xA;};&#xA;&#xA;const auto item = Item{.pos_x = 2.0,  &#xA;                       .pos_y = 3.0,&#xA;                       .shape = Shape::square,&#xA;                       .color = Color::red | Color::blue};&#xA;&#xA;rfl::json::write(item);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This results in the following JSON string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;pos_x&#34;:2.0,&#34;pos_y&#34;:3.0,&#34;shape&#34;:&#34;square&#34;,&#34;color&#34;:&#34;red|blue&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also directly convert between enumerator values and strings with &lt;code&gt;rfl::enum_to_string()&lt;/code&gt; and &lt;code&gt;rfl::string_to_enum()&lt;/code&gt;, or obtain list of enumerator name and value pairs with &lt;code&gt;rfl::get_enumerators&amp;lt;EnumType&amp;gt;()&lt;/code&gt; or &lt;code&gt;rfl::get_enumerator_array&amp;lt;EnumType&amp;gt;()&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Algebraic data types&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp supports Pydantic-style tagged unions, which allow you to form algebraic data types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Circle {&#xA;    double radius;&#xA;};&#xA;&#xA;struct Rectangle {&#xA;    double height;&#xA;    double width;&#xA;};&#xA;&#xA;struct Square {&#xA;    double width;&#xA;};&#xA;&#xA;using Shapes = rfl::TaggedUnion&amp;lt;&#34;shape&#34;, Circle, Square, Rectangle&amp;gt;;&#xA;&#xA;const Shapes r = Rectangle{.height = 10, .width = 5};&#xA;&#xA;const auto json_string = rfl::json::write(r);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This results in the following JSON string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;shape&#34;:&#34;Rectangle&#34;,&#34;height&#34;:10.0,&#34;width&#34;:5.0}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Other forms of tagging are supported as well. Refer to the &lt;a href=&#34;https://github.com/getml/reflect-cpp/tree/main/docs&#34;&gt;documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Extra fields&lt;/h2&gt; &#xA;&lt;p&gt;If you don&#39;t know all of your fields at compile time, no problem. Just use &lt;code&gt;rfl::ExtraFields&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Person {&#xA;  std::string first_name;&#xA;  std::string last_name = &#34;Simpson&#34;;&#xA;  rfl::ExtraFields&amp;lt;rfl::Generic&amp;gt; extra_fields;&#xA;};&#xA;&#xA;auto homer = Person{.first_name = &#34;Homer&#34;};&#xA;&#xA;homer.extra_fields[&#34;age&#34;] = 45;&#xA;homer.extra_fields[&#34;email&#34;] = &#34;homer@simpson.com&#34;;&#xA;homer.extra_fields[&#34;town&#34;] = &#34;Springfield&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This results in the following JSON string:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;firstName&#34;:&#34;Homer&#34;,&#34;lastName&#34;:&#34;Simpson&#34;,&#34;age&#34;:45,&#34;email&#34;:&#34;homer@simpson.com&#34;,&#34;town&#34;:&#34;Springfield&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reflective programming&lt;/h2&gt; &#xA;&lt;p&gt;Beyond serialization and deserialization, reflect-cpp also supports reflective programming in general.&lt;/p&gt; &#xA;&lt;p&gt;For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Person {&#xA;  std::string first_name;&#xA;  std::string last_name = &#34;Simpson&#34;;&#xA;  std::string town = &#34;Springfield&#34;;&#xA;  unsigned int age;&#xA;  std::vector&amp;lt;Person&amp;gt; children;&#xA;};&#xA;&#xA;for (const auto&amp;amp; f : rfl::fields&amp;lt;Person&amp;gt;()) {&#xA;  std::cout &amp;lt;&amp;lt; &#34;name: &#34; &amp;lt;&amp;lt; f.name() &amp;lt;&amp;lt; &#34;, type: &#34; &amp;lt;&amp;lt; f.type() &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also create a view and then access these fields using &lt;code&gt;std::get&lt;/code&gt; or &lt;code&gt;rfl::get&lt;/code&gt;, or iterate over the fields at compile-time:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto lisa = Person{.first_name = &#34;Lisa&#34;, .last_name = &#34;Simpson&#34;, .age = 8};&#xA;&#xA;const auto view = rfl::to_view(lisa);&#xA;&#xA;// view.values() is a std::tuple containing&#xA;// pointers to the original fields.&#xA;// This will modify the struct `lisa`:&#xA;*std::get&amp;lt;0&amp;gt;(view.values()) = &#34;Maggie&#34;;&#xA;&#xA;// All of this is supported as well:&#xA;*view.get&amp;lt;1&amp;gt;() = &#34;Simpson&#34;;&#xA;*view.get&amp;lt;&#34;age&#34;&amp;gt;() = 0;&#xA;*rfl::get&amp;lt;0&amp;gt;(view) = &#34;Maggie&#34;;&#xA;*rfl::get&amp;lt;&#34;first_name&#34;&amp;gt;(view) = &#34;Maggie&#34;;&#xA;&#xA;view.apply([](const auto&amp;amp; f) {&#xA;  // f is an rfl::Field pointing to the original field.&#xA;  std::cout &amp;lt;&amp;lt; f.name() &amp;lt;&amp;lt; &#34;: &#34; &amp;lt;&amp;lt; rfl::json::write(*f.value()) &amp;lt;&amp;lt; std::endl;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It also possible to replace fields:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Person {&#xA;  std::string first_name;&#xA;  std::string last_name;&#xA;  std::vector&amp;lt;Person&amp;gt; children;&#xA;};&#xA;&#xA;const auto lisa = Person{.first_name = &#34;Lisa&#34;, .last_name = &#34;Simpson&#34;};&#xA;&#xA;// Returns a deep copy of &#34;lisa&#34; with the first_name replaced.&#xA;const auto maggie = rfl::replace(&#xA;    lisa, rfl::make_field&amp;lt;&#34;first_name&#34;&amp;gt;(std::string(&#34;Maggie&#34;)));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or you can create structs from other structs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A {&#xA;  std::string f1;&#xA;  std::string f2;&#xA;};&#xA;&#xA;struct B {&#xA;  std::string f3;&#xA;  std::string f4;&#xA;};&#xA;&#xA;struct C {&#xA;  std::string f1;&#xA;  std::string f2;&#xA;  std::string f4;&#xA;};&#xA;&#xA;const auto a = A{.f1 = &#34;Hello&#34;, .f2 = &#34;World&#34;};&#xA;&#xA;const auto b = B{.f3 = &#34;Hello&#34;, .f4 = &#34;World&#34;};&#xA;&#xA;// f1 and f2 are taken from a, f4 is taken from b, f3 is ignored.&#xA;const auto c = rfl::as&amp;lt;C&amp;gt;(a, b);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also replace fields in structs using fields from other structs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const auto a = A{.f1 = &#34;Hello&#34;, .f2 = &#34;World&#34;};&#xA;&#xA;const auto c = C{.f1 = &#34;C++&#34;, .f2 = &#34;is&#34;, .f4 = &#34;great&#34;};&#xA;&#xA;// The fields f1 and f2 are replaced with the fields f1 and f2 in a.&#xA;const auto c2 = rfl::replace(c, a);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Support for containers&lt;/h2&gt; &#xA;&lt;h3&gt;C++ standard library&lt;/h3&gt; &#xA;&lt;p&gt;reflect-cpp supports the following containers from the C++ standard library:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;std::array&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::deque&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::filesystem::path&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::forward_list&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::multimap&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::multiset&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::list&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::optional&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::set&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::tuple&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unordered_map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unordered_multimap&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unordered_multiset&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unordered_set&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::variant&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::vector&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::wstring&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Additional containers&lt;/h3&gt; &#xA;&lt;p&gt;In addition, it supports the following custom containers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Binary&lt;/code&gt;: Used to express numbers in binary format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Box&lt;/code&gt;: Similar to &lt;code&gt;std::unique_ptr&lt;/code&gt;, but (almost) guaranteed to never be null.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Bytestring&lt;/code&gt;: An alias for &lt;code&gt;std::basic_string&amp;lt;std::byte&amp;gt;&lt;/code&gt;. Supported by BSON, CBOR, flexbuffers and msgpack.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Generic&lt;/code&gt;: A catch-all type that can represent (almost) anything.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Hex&lt;/code&gt;: Used to express numbers in hex format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Literal&lt;/code&gt;: An explicitly enumerated string.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::NamedTuple&lt;/code&gt;: Similar to &lt;code&gt;std::tuple&lt;/code&gt;, but with named fields that can be retrieved via their name at compile time.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Object&lt;/code&gt;: A map-like type representing a object with field names that are unknown at compile time.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Oct&lt;/code&gt;: Used to express numbers in octal format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Ref&lt;/code&gt;: Similar to &lt;code&gt;std::shared_ptr&lt;/code&gt;, but (almost) guaranteed to never be null.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Result&lt;/code&gt;: Allows for exception-free programming.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::TaggedUnion&lt;/code&gt;: Similar to &lt;code&gt;std::variant&lt;/code&gt;, but with explicit tags that make parsing more efficient.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Tuple&lt;/code&gt;: An alternative to &lt;code&gt;std::tuple&lt;/code&gt; that compiles considerably faster.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Validator&lt;/code&gt;: Allows for automatic input validation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rfl::Variant&lt;/code&gt;: An alternative to &lt;code&gt;std::variant&lt;/code&gt; that compiles considerably faster.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Custom classes&lt;/h3&gt; &#xA;&lt;p&gt;Finally, it is very easy to extend full support to your own classes, refer to the &lt;a href=&#34;https://github.com/getml/reflect-cpp/tree/main/docs&#34;&gt;documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Why do we need this?&lt;/h2&gt; &#xA;&lt;p&gt;Suppose your C++ program has complex data structures it needs to save and load. Or maybe it needs to interact with some kind of external API. If you do this the traditional way, you will have a lot of boilerplate code. This is annoying and error-prone.&lt;/p&gt; &#xA;&lt;p&gt;reflect-cpp is not just a reflection library, it is for &lt;strong&gt;serialization, deserialization and validation&lt;/strong&gt; through reflection.&lt;/p&gt; &#xA;&lt;p&gt;That means that you can encode your requirements about the input data in the type system and have them validated upfront. This is why the library also includes algebraic data types like tagged unions and numerous validation routines. Having your requirements encoded in the type system is the most reliable way of ensuring they are met. If your requirements are not met, the user of your software gets a very clear error message. Encoding your requirements in the type system also makes it a lot easier for anyone reading your code.&lt;/p&gt; &#xA;&lt;p&gt;This increases user experience and developer experience, it makes your code safer (fewer bugs) and more secure (less prone to malicious attacks).&lt;/p&gt; &#xA;&lt;p&gt;For a more in-depth theoretical discussions of these topics, the following books are warmly recommended:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Category Theory for Programmers&lt;/em&gt; by Bartosz Milewski (&lt;a href=&#34;https://github.com/hmemcpy/milewski-ctfp-pdf/releases&#34;&gt;https://github.com/hmemcpy/milewski-ctfp-pdf/releases&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Domain Modeling Made Functional&lt;/em&gt; by Scott Wlaschin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Click &lt;a href=&#34;https://github.com/getml/reflect-cpp/tree/main/docs&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp conducts continuuous benchmarking across different operating systems, compilers and architectures and publishes the results on its &lt;a href=&#34;https://github.com/getml/reflect-cpp/actions&#34;&gt;Actions tab&lt;/a&gt;. Refer to the &lt;a href=&#34;https://github.com/getml/reflect-cpp/tree/main/benchmarks&#34;&gt;benchmarks folder&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;The benchmarks show that reflect-cpp is not only very convenient, but also one the fastest JSON libraries for C++. It is faster than RapidJSON and about 10 times faster than nlohmann/json. It can be even faster than that, if you choose to use a different format supported by reflect-cpp, such as msgpack.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The following compilers are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GCC 11.4 or higher&lt;/li&gt; &#xA; &lt;li&gt;Clang 14.0 or higher&lt;/li&gt; &#xA; &lt;li&gt;MSVC 17.8 (19.38) or higher&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Option 1: Include source files into your own build&lt;/h3&gt; &#xA;&lt;p&gt;Simply copy the contents of the folder &lt;code&gt;include&lt;/code&gt; into your source repository or add it to your include path and also add &lt;code&gt;src/reflectcpp.cpp&lt;/code&gt; and &lt;code&gt;src/yyjson.c&lt;/code&gt; to your source files for compilation. If you don&#39;t need JSON support or want to link to your own version of YYJSON, then only copy &lt;code&gt;src/reflectcpp.cpp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you need support for other serialization formats like flexbuffers or XML, you should also include and link the respective libraries, as listed in the section on serialization formats.&lt;/p&gt; &#xA;&lt;h3&gt;Option 2: Compilation using cmake&lt;/h3&gt; &#xA;&lt;p&gt;This will simply compile YYJSON, which is the JSON library underlying reflect-cpp. You can then include reflect-cpp in your project and link to the binary to get reflect-cpp with JSON support.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake -S . -B build -DCMAKE_BUILD_TYPE=Release&#xA;cmake --build build -j 4  # gcc, clang&#xA;cmake --build build --config Release -j 4  # MSVC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Option 3: Compilation using cmake and vcpkg&lt;/h3&gt; &#xA;&lt;p&gt;If you want serialization formats other than JSON, you can either install them manually or use vcpkg.&lt;/p&gt; &#xA;&lt;p&gt;To install vcpkg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule update --init&#xA;./vcpkg/bootstrap-vcpkg.sh # Linux, macOS&#xA;./vcpkg/bootstrap-vcpkg.bat # Windows&#xA;# You may be prompted to install additional dependencies.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use reflect-cpp in your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_subdirectory(reflect-cpp) # Add this project as a subdirectory&#xA;&#xA;set(REFLECTCPP_BSON ON) # Optional&#xA;set(REFLECTCPP_CBOR ON) # Optional&#xA;set(REFLECTCPP_FLEXBUFFERS ON) # Optional&#xA;set(REFLECTCPP_MSGPACK ON) # Optional&#xA;set(REFLECTCPP_TOML ON) # Optional&#xA;set(REFLECTCPP_XML ON) # Optional&#xA;set(REFLECTCPP_YAML ON) # Optional&#xA;&#xA;target_link_libraries(your_project PRIVATE reflectcpp) # Link against the library&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Troubleshooting vcpkg&lt;/h2&gt; &#xA;&lt;p&gt;vcpkg is a great, but very ambitious and complex project (just like C++ is a great, but very ambitious and complex language). Here are some of the you might run into and how to resolve them:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;A lot of problems can simply be resolved by deleting the build directory using &lt;code&gt;rm -rf build&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;em&gt;Environment variable VCPKG_FORCE_SYSTEM_BINARIES must be set on arm, s390x, ppc64le and riscv platforms.&lt;/em&gt; - This usually happens on arm platforms like the Apple Silicon chips and can be resolved by simply preceding your build with &lt;code&gt;export VCPKG_FORCE_SYSTEM_BINARIES=arm&lt;/code&gt; or &lt;code&gt;export VCPKG_FORCE_SYSTEM_BINARIES=1&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On some occasions you might be asked to specify a compiler. You can do so by simply adding it to the cmake command as follows: &lt;code&gt;cmake -S . -B build ... -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++&lt;/code&gt; or &lt;code&gt;cmake -S . -B build ... -DCMAKE_C_COMPILER=clang-17 -DCMAKE_CXX_COMPILER=clang++-17&lt;/code&gt; (or whatever supported compiler you would like to use).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Compiling and running the tests&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp uses vcpkg for dependency management, including gtest, which is required for the tests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# bootstrap vcpkg if you haven&#39;t done so already &#xA;git submodule update --init&#xA;./vcpkg/bootstrap-vcpkg.sh # Linux, macOS&#xA;./vcpkg/bootstrap-vcpkg.bat # Windows&#xA;# You may be prompted to install additional dependencies.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;JSON only&lt;/h3&gt; &#xA;&lt;p&gt;To compile the tests, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DREFLECTCPP_BUILD_TESTS=ON&#xA;cmake --build build -j 4 # gcc, clang&#xA;cmake --build build --config Release -j 4 # MSVC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the tests, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./build/tests/json/reflect-cpp-json-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;All serialization formats&lt;/h3&gt; &#xA;&lt;p&gt;To compile the tests with serialization formats other than JSON, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake -S . -B build -DREFLECTCPP_BUILD_TESTS=ON -DREFLECTCPP_BSON=ON -DREFLECTCPP_CBOR=ON -DREFLECTCPP_FLEXBUFFERS=ON -DREFLECTCPP_MSGPACK=ON -DREFLECTCPP_XML=ON -DREFLECTCPP_TOML=ON -DREFLECTCPP_YAML=ON -DCMAKE_BUILD_TYPE=Release&#xA;cmake --build build -j 4 # gcc, clang&#xA;cmake --build build --config Release -j 4 # MSVC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the tests, do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./build/tests/bson/reflect-cpp-bson-tests&#xA;./build/tests/cbor/reflect-cpp-cbor-tests&#xA;./build/tests/flexbuffers/reflect-cpp-flexbuffers-tests&#xA;./build/tests/msgpack/reflect-cpp-msgpack-tests&#xA;./build/tests/json/reflect-cpp-json-tests&#xA;./build/tests/toml/reflect-cpp-toml-tests&#xA;./build/tests/xml/reflect-cpp-xml-tests&#xA;./build/tests/yaml/reflect-cpp-yaml-tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to contribute&lt;/h2&gt; &#xA;&lt;h3&gt;Make sure includes are relative&lt;/h3&gt; &#xA;&lt;p&gt;We need internal includes to be relative and not depend on any externally set include directory.&lt;/p&gt; &#xA;&lt;p&gt;That is, for example, if you are within any file in &lt;code&gt;rfl/internal&lt;/code&gt;, prefer&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;to_ptr_named_tuple.hpp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;over&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;rfl/internal/to_ptr_named_tuple.hpp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For further details and reasoning, please refer to &lt;a href=&#34;https://github.com/getml/reflect-cpp/issues/30&#34;&gt;#30&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Related projects&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp was originally developed for &lt;a href=&#34;https://github.com/getml/getml-community&#34;&gt;getml-community&lt;/a&gt;, the fastest open-source tool for feature engineering on relational data and time series. If you are interested in Data Science and/or Machine Learning, please check it out.&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp has been developed by &lt;a href=&#34;https://www.scaleml.de&#34;&gt;scaleML&lt;/a&gt;, a company specializing in software engineering and machine learning for enterprise applications. It is extensively used for &lt;a href=&#34;https://getml.com&#34;&gt;getML&lt;/a&gt;, a software for automated feature engineering using relational learning.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;reflect-cpp is released under the MIT License. Refer to the LICENSE file for details.&lt;/p&gt; &#xA;&lt;p&gt;reflect-cpp includes &lt;a href=&#34;https://github.com/ibireme/yyjson&#34;&gt;YYJSON&lt;/a&gt;, the fastest JSON library currently in existence. YYJSON is written by YaoYuan and also released under the MIT License.&lt;/p&gt; &#xA;&lt;p&gt;reflect-cpp includes &lt;a href=&#34;https://github.com/hanickadot/compile-time-regular-expressions&#34;&gt;compile-time-regular-expressions&lt;/a&gt;. CTRE is written by Hana Dusíková and released under the Apache-2.0 License with LLVM exceptions.&lt;/p&gt;</summary>
  </entry>
</feed>