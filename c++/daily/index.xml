<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-14T01:32:13Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>isledecomp/isle</title>
    <updated>2023-06-14T01:32:13Z</updated>
    <id>tag:github.com,2023-06-14:/isledecomp/isle</id>
    <link href="https://github.com/isledecomp/isle" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A work-in-progress decompilation of LEGO Island (1997)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LEGO Island Decompilation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLbpl-gZkNl2COf_bB6cfgTapD5WduAfPz&#34;&gt;Development Vlog&lt;/a&gt; | &lt;a href=&#34;https://matrix.to/#/#isledecomp:matrix.org&#34;&gt;Matrix&lt;/a&gt; | &lt;a href=&#34;https://forum.mattkc.com/viewforum.php?f=1&#34;&gt;Forums&lt;/a&gt; | &lt;a href=&#34;https://www.patreon.com/mattkc&#34;&gt;Patreon&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is a &lt;strong&gt;work-in-progress&lt;/strong&gt; decompilation of LEGO Island version 1.1. It aims to be relatively faithful, but not byte accurate. The goal is to provide a workable codebase that can be modified, improved, and ported to other platforms later on.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;TODO: A progress bar showing the percentage progress of this decompilation.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Currently &lt;code&gt;ISLE.EXE&lt;/code&gt; is completely decompiled, however there are some known inaccuracies. It should work if you pair it with the original game&#39;s &lt;code&gt;LEGO1.DLL&lt;/code&gt; (and other files), however small things may not work correctly yet. Work on decompiling &lt;code&gt;LEGO1.DLL&lt;/code&gt; has only just started and currently it is too incomplete to be usable.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;LEGO Island was compiled with Microsoft Visual C++ 4.20, so that&#39;s what this decompilation targets. However it should compile with NMAKE on newer versions of Visual Studio too.&lt;/p&gt; &#xA;&lt;h3&gt;Recommended Instructions:&lt;/h3&gt; &#xA;&lt;p&gt;These instructions use the development IDE from Visual C++ 4.20. By modern standards, it can be a little clunky to use, especially on newer versions of Windows, however it&#39;s still relatively straightforward. If you prefer a command line process that can fit into a modern workflow/IDE, see the instructions below.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Microsoft Visual C++ 4.20. This can be found on many abandonware sites, but the installer can be a little iffy on modern versions of Windows. For convenience, I made a &lt;a href=&#34;https://github.com/itsmattkc/msvc420&#34;&gt;portable version&lt;/a&gt; that can be downloaded and used quickly instead.&lt;/li&gt; &#xA; &lt;li&gt;Download and install the DirectX 5 SDK. Similarly, this can be found on many abandonware sites.&lt;/li&gt; &#xA; &lt;li&gt;Open &#34;Microsoft Developer Studio&#34; (&lt;code&gt;BIN/MSDEV.EXE&lt;/code&gt; for those using the portable).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Open Workspace&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Select &lt;code&gt;ISLE.MDP&lt;/code&gt; from this repository.&lt;/li&gt; &#xA; &lt;li&gt;Select a build configuration. &lt;code&gt;ISLE - Win32 Release&lt;/code&gt; is recommended because, at this point in time, you&#39;ll almost certainly be pairing it with the retail &lt;code&gt;LEGO1.DLL&lt;/code&gt;, which is also a release build.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Build&lt;/code&gt; &amp;gt; &lt;code&gt;Build ISLE.EXE&lt;/code&gt;. This will build &lt;code&gt;ISLE.EXE&lt;/code&gt; in a folder called &lt;code&gt;Release&lt;/code&gt;. It will also build &lt;code&gt;LEGO1.DLL&lt;/code&gt; since it&#39;s listed as a dependency, however the &lt;code&gt;LEGO1.DLL&lt;/code&gt; produced is too incomplete to be usable at this time.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Command Line Instructions&lt;/h3&gt; &#xA;&lt;p&gt;For some users, this may be preferable to using an obsolete graphical IDE. Any modern IDE should support custom command line build steps, making this potentially easier to fit into a familiar contemporary workflow. This guide assumes a general familiarity with the Windows command prompt.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Acquire Visual Studio/Visual C++. Any version after 4.20 should work here, but 4.20 is the only one guaranteed to work. If you wish to use 4.20, it can be found on many abandonware sites, but the installer can be a little iffy on modern versions of Windows. For convenience, I made a &lt;a href=&#34;https://github.com/itsmattkc/msvc420&#34;&gt;portable version&lt;/a&gt; that can be downloaded and used quickly instead.&lt;/li&gt; &#xA; &lt;li&gt;Download and install the DirectX 5 SDK. Similarly, this can be found on many abandonware sites, but later versions of Visual Studio include the DirectX SDK by default, so this step may be skippable (you definitely need it for MSVC 4.20).&lt;/li&gt; &#xA; &lt;li&gt;Open an x86/32-bit developer command prompt. Depending on the version of VS you&#39;re using, you may have a start menu item for it already (e.g. &lt;code&gt;x86 Native Tools Command Prompt&lt;/code&gt;). Alternatively, you can start a normal command prompt (&lt;code&gt;cmd&lt;/code&gt;) and run &lt;code&gt;vcvars32.bat&lt;/code&gt; from the Visual Studio folder (run &lt;code&gt;BIN/VCVARS32.BAT x86&lt;/code&gt; if you&#39;re using the portable 4.20).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd&lt;/code&gt; to the folder you cloned this repository to.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;mkdir Release&lt;/code&gt; if the folder doesn&#39;t already exist. Some versions of NMAKE may make this folder by itself, but some don&#39;t.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;nmake /f isle.mak CFG=&#34;ISLE - Win32 Release&#34;&lt;/code&gt;. This will build &lt;code&gt;ISLE.EXE&lt;/code&gt; in the &lt;code&gt;Release&lt;/code&gt; folder you just made. It will also build &lt;code&gt;LEGO1.DLL&lt;/code&gt; since it&#39;s listed as a dependency, however the &lt;code&gt;LEGO1.DLL&lt;/code&gt; produced is too incomplete to be usable at this time.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Simply place the compiled &lt;code&gt;ISLE.EXE&lt;/code&gt; into LEGO Island&#39;s install folder (usually &lt;code&gt;C:\Program Files\LEGO Island&lt;/code&gt; or &lt;code&gt;C:\Program Files (x86)\LEGO Island&lt;/code&gt;). Unless you&#39;re a developer, disregard the compiled &lt;code&gt;LEGO1.DLL&lt;/code&gt; for now as it is too incomplete to be usable. Alternatively, LEGO Island can run from any directory as long as &lt;code&gt;ISLE.EXE&lt;/code&gt; and &lt;code&gt;LEGO1.DLL&lt;/code&gt; are in the same directory, and the registry keys point to the correct location for the asset files.&lt;/p&gt; &#xA;&lt;p&gt;Ideally, this decompilation should be paired with version 1.1. It may work on 1.0 too, however this is not guaranteed.&lt;/p&gt; &#xA;&lt;h2&gt;Additional Information&lt;/h2&gt; &#xA;&lt;h3&gt;Which version of LEGO Island do I have?&lt;/h3&gt; &#xA;&lt;p&gt;Right click on &lt;code&gt;LEGO1.DLL&lt;/code&gt;, select &lt;code&gt;Properties&lt;/code&gt;, and switch to the &lt;code&gt;Details&lt;/code&gt; tab. Under &lt;code&gt;Version&lt;/code&gt; you should either see &lt;code&gt;1.0.0.0&lt;/code&gt; (1.0) or &lt;code&gt;1.1.0.0&lt;/code&gt; (1.1). Additionally, you can look at the game disc files; 1.0&#39;s files will all say August 8, 1997, and 1.1&#39;s files will all say September 8, 1997. Version 1.1 is by far the most common, especially if you&#39;re not using the English or Japanese versions, so that&#39;s most likely the version you have.&lt;/p&gt; &#xA;&lt;h3&gt;SmartHeap&lt;/h3&gt; &#xA;&lt;p&gt;Both &lt;code&gt;ISLE.EXE&lt;/code&gt; and &lt;code&gt;LEGO1.DLL&lt;/code&gt; were originally statically linked with &lt;a href=&#34;http://www.microquill.com/smartheap/sh_tspec.htm&#34;&gt;SmartHeap&lt;/a&gt;, a drop-in replacement for malloc/free that presumably provides better heap memory management on the old low-memory (16MB) systems this game was designed for. Unfortunately, acquiring SmartHeap legally is expensive, and the chances of acquiring the exact same version used by Mindscape in the late 90s is very low. Since it&#39;s a drop-in binary-compatible replacement, this decomp can just stick with the standard malloc/free functions while still achieving matching assembly on a per-function level, however the resulting binaries will never be byte accurate as a result of this. If you notice significant size disparities, particularly in ISLE.EXE, the lack of statically linked SmartHeap libraries is why.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vectr-ucla/direct_lidar_inertial_odometry</title>
    <updated>2023-06-14T01:32:13Z</updated>
    <id>tag:github.com,2023-06-14:/vectr-ucla/direct_lidar_inertial_odometry</id>
    <link href="https://github.com/vectr-ucla/direct_lidar_inertial_odometry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;[IEEE ICRA&#39;23] A new lightweight LiDAR-inertial odometry algorithm with a novel coarse-to-fine approach in constructing continuous-time trajectories for precise motion correction.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Direct LiDAR-Inertial Odometry: Lightweight LIO with Continuous-Time Motion Correction&lt;/h1&gt; &#xA;&lt;h4&gt;[&lt;a href=&#34;https://arxiv.org/abs/2203.03749&#34;&gt;Paper&lt;/a&gt;] [&lt;a href=&#34;https://www.youtube.com/watch?v=4-oXjG8ow10&#34;&gt;Video&lt;/a&gt;] [&lt;a href=&#34;https://www.youtube.com/watch?v=Hmiw66KZ1tU&#34;&gt;Presentation&lt;/a&gt;]&lt;/h4&gt; &#xA;&lt;p&gt;DLIO is a new lightweight LiDAR-inertial odometry algorithm with a novel coarse-to-fine approach in constructing continuous-time trajectories for precise motion correction. It features several algorithmic improvements over its predecessor, &lt;a href=&#34;https://github.com/vectr-ucla/direct_lidar_odometry&#34;&gt;DLO&lt;/a&gt;, and was presented at the IEEE International Conference on Robotics and Automation (ICRA) in London, UK in 2023.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/vectr-ucla/direct_lidar_inertial_odometry/master/doc/img/dlio.png&#34; alt=&#34;drawing&#34; width=&#34;720&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Instructions&lt;/h2&gt; &#xA;&lt;h3&gt;Sensor Setup&lt;/h3&gt; &#xA;&lt;p&gt;DLIO has been extensively tested using a variety of sensor configurations. DLIO requires only a point cloud input of type &lt;code&gt;sensor_msgs::PointCloud2&lt;/code&gt; and a 6-axis IMU input of type &lt;code&gt;sensor_msgs::Imu&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For best performance, extrinsic calibration between the LiDAR/IMU sensors and the robot&#39;s center-of-gravity should be inputted into &lt;code&gt;cfg/dlio.yaml&lt;/code&gt;. If the exact values of these are unavailable, a rough LiDAR-to-IMU extrinsics can also be used (note however that performance will be degraded).&lt;/p&gt; &#xA;&lt;p&gt;IMU intrinsics are also necessary for best performance, and there are several open-source calibration tools to get these values. These values should also go into &lt;code&gt;cfg/dlio.yaml&lt;/code&gt;. In practice however, if you are just testing this work, using the default ideal values and performing the initial calibration procedure should be fine.&lt;/p&gt; &#xA;&lt;p&gt;Also note that the LiDAR and IMU sensors &lt;em&gt;need&lt;/em&gt; to be properly time-synchronized, otherwise DLIO will not work. We recommend using a LiDAR with an integrated IMU (such as an Ouster) for simplicity of extrinsics and synchronization.&lt;/p&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;The following has been verified to be compatible, although other configurations may work too:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ubuntu 20.04&lt;/li&gt; &#xA; &lt;li&gt;ROS Noetic (&lt;code&gt;roscpp&lt;/code&gt;, &lt;code&gt;std_msgs&lt;/code&gt;, &lt;code&gt;sensor_msgs&lt;/code&gt;, &lt;code&gt;geometry_msgs&lt;/code&gt;, &lt;code&gt;nav_msgs&lt;/code&gt;, &lt;code&gt;pcl_ros&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;C++ 14&lt;/li&gt; &#xA; &lt;li&gt;CMake &amp;gt;= &lt;code&gt;3.12.4&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;OpenMP &amp;gt;= &lt;code&gt;4.5&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Point Cloud Library &amp;gt;= &lt;code&gt;1.10.0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Eigen &amp;gt;= &lt;code&gt;3.3.7&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install libomp-dev libpcl-dev libeigen3-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;DLIO currently only supports ROS1, but we welcome any contributions by the community to add ROS2 support!&lt;/p&gt; &#xA;&lt;h3&gt;Compiling&lt;/h3&gt; &#xA;&lt;p&gt;Compile using the &lt;a href=&#34;https://catkin-tools.readthedocs.io/en/latest/&#34;&gt;&lt;code&gt;catkin_tools&lt;/code&gt;&lt;/a&gt; package via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir ws &amp;amp;&amp;amp; cd ws &amp;amp;&amp;amp; mkdir src &amp;amp;&amp;amp; catkin init &amp;amp;&amp;amp; cd src&#xA;git clone https://github.com/vectr-ucla/direct_lidar_inertial_odometry.git&#xA;catkin build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Execution&lt;/h3&gt; &#xA;&lt;p&gt;After compiling, source the workspace and execute via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;roslaunch direct_lidar_inertial_odometry dlio.launch \&#xA;  rviz:={true, false} \&#xA;  pointcloud_topic:=/robot/lidar \&#xA;  imu_topic:=/robot/imu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Be sure to change the topic names to your corresponding topics. Alternatively, edit the launch file directly if desired. If successful, you should see the following output in your terminal: &lt;br&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/vectr-ucla/direct_lidar_inertial_odometry/master/doc/img/terminal.png&#34; alt=&#34;drawing&#34; width=&#34;480&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Services&lt;/h3&gt; &#xA;&lt;p&gt;To save DLIO&#39;s generated map into &lt;code&gt;.pcd&lt;/code&gt; format, call the following service:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rosservice call /robot/dlio_map/save_pcd LEAF_SIZE SAVE_PATH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test Data&lt;/h3&gt; &#xA;&lt;p&gt;For your convenience, we provide test data &lt;a href=&#34;https://drive.google.com/file/d/1Sp_Mph4rekXKY2euxYxv6SD6WIzB-wVU/view?usp=sharing&#34;&gt;here&lt;/a&gt; (1.2GB, 1m 13s) of an aggressive motion to test our motion correction scheme. Try this data with both deskewing on and off!&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/vectr-ucla/direct_lidar_inertial_odometry/master/doc/gif/aggressive.gif&#34; alt=&#34;drawing&#34; width=&#34;720&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;p&gt;If you found this work useful, please cite our manuscript:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@article{chen2022dlio,&#xA;  title={Direct LiDAR-Inertial Odometry: Lightweight LIO with Continuous-Time Motion Correction},&#xA;  author={Chen, Kenny and Nemiroff, Ryan and Lopez, Brett T},&#xA;  journal={IEEE International Conference on Robotics and Automation (ICRA)},&#xA;  year={2023}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;We thank the authors of the &lt;a href=&#34;https://github.com/SMRT-AIST/fast_gicp&#34;&gt;FastGICP&lt;/a&gt; and &lt;a href=&#34;https://github.com/jlblancoc/nanoflann&#34;&gt;NanoFLANN&lt;/a&gt; open-source packages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Kenji Koide, Masashi Yokozuka, Shuji Oishi, and Atsuhiko Banno, “Voxelized GICP for Fast and Accurate 3D Point Cloud Registration,” in &lt;em&gt;IEEE International Conference on Robotics and Automation (ICRA)&lt;/em&gt;, IEEE, 2021, pp. 11 054–11 059.&lt;/li&gt; &#xA; &lt;li&gt;Jose Luis Blanco and Pranjal Kumar Rai, “NanoFLANN: a C++ Header-Only Fork of FLANN, A Library for Nearest Neighbor (NN) with KD-Trees,” &lt;a href=&#34;https://github.com/jlblancoc/nanoflann&#34;&gt;https://github.com/jlblancoc/nanoflann&lt;/a&gt;, 2014.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We would also like to thank Helene Levy and David Thorne for their help with data collection.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This work is licensed under the terms of the MIT license.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/vectr-ucla/direct_lidar_inertial_odometry/master/doc/img/ucla.png&#34; alt=&#34;drawing&#34; width=&#34;720&#34;&gt; &lt;/p&gt;</summary>
  </entry>
</feed>