<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-02T01:31:52Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ZeroMemoryEx/Amsi-Killer</title>
    <updated>2023-03-02T01:31:52Z</updated>
    <id>tag:github.com,2023-03-02:/ZeroMemoryEx/Amsi-Killer</id>
    <link href="https://github.com/ZeroMemoryEx/Amsi-Killer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lifetime AMSI bypass&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lifetime AMSI bypass&lt;/h1&gt; &#xA;&lt;h2&gt;Opcode Scan&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;we get the exact address of the jump instruction by searching for the first byte of each instruction this technique is effective even in the face of updates or modifications to the target data set.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;for example :&lt;/p&gt; &lt;p&gt;&lt;code&gt; | 48:85D2 | test rdx, rdx |&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; | 74 3F | je amsi.7FFAE957C694 |&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; | 48 : 85C9 | test rcx, rcx |&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; | 74 3A | je amsi.7FFAE957C694 |&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; | 48 : 8379 08 00 | cmp qword ptr ds : [rcx + 8] , 0 |&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; | 74 33 | je amsi.7FFAE957C694 |&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;the search pattern will be like this :&lt;/p&gt; &lt;p&gt;&lt;code&gt;{ 0x48,&#39;?&#39;,&#39;?&#39;, 0x74,&#39;?&#39;,0x48,&#39;?&#39; ,&#39;?&#39; ,0x74,&#39;?&#39; ,0x48,&#39;?&#39; ,&#39;?&#39; ,&#39;?&#39; ,&#39;?&#39;,0x74,0x33}&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221431685-60fb2012-db0f-41aa-bd7b-3a19f07c91c4.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Patch&lt;/h1&gt; &#xA;&lt;h2&gt;Before Patch&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The program tests the value of RDX against itself. If the comparison evaluates to 0, the program executes a jump to return. Otherwise, the program proceeds to evaluate the next instruction&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221431975-73c78c9c-5358-44c2-b0de-41d68024e2bb.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;we cant execute &#34;Invoke-Mimikatz&#34;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221432132-20993ccf-c53e-493d-8b22-feaea86fb6bf.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;After Patch&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;we patch the first byte and change it from JE to JMP so it return directly&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221444031-5b8c365f-cb38-4ce4-89b5-153ecc12208d.png&#34; alt=&#34;Screenshot 2023-02-26 195848&#34;&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221432418-841db688-879c-4915-8d6e-926236a3732c.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;now we execute &#34;Invoke-Mimikatz&#34;&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221432425-5c121433-33f4-4b8d-add6-63c078d5edb8.png&#34; alt=&#34;Screenshot 2023-02-26 195914&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>llvm/circt</title>
    <updated>2023-03-02T01:31:52Z</updated>
    <id>tag:github.com,2023-03-02:/llvm/circt</id>
    <link href="https://github.com/llvm/circt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Circuit IR Compilers and Tools&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/llvm/circt/main/docs/includes/img/circt-logo.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/llvm/circt/actions?query=workflow%3A%22Build+and+Test%22&#34;&gt;&lt;img src=&#34;https://github.com/llvm/circt/workflows/Build%20and%20Test/badge.svg?event=push&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/llvm/circt/actions?query=workflow%3A%22Nightly+integration+tests%22&#34;&gt;&lt;img src=&#34;https://github.com/llvm/circt/workflows/Nightly%20integration%20tests/badge.svg?sanitize=true&#34; alt=&#34;Nightly integration tests&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/llvm/circt/actions/workflows/trackLLVMChanges.yml&#34;&gt;&lt;img src=&#34;https://github.com/llvm/circt/actions/workflows/trackLLVMChanges.yml/badge.svg?sanitize=true&#34; alt=&#34;Track LLVM Changes&#34;&gt;&lt;/a&gt; &lt;br&gt;↳ If failing, there exists an upstream LLVM commit which breaks CIRCT.&lt;/p&gt; &#xA;&lt;h1&gt;⚡️ &#34;CIRCT&#34; / Circuit IR Compilers and Tools&lt;/h1&gt; &#xA;&lt;p&gt;&#34;CIRCT&#34; stands for &#34;Circuit IR Compilers and Tools&#34;. One might also interpret it as the recursively as &#34;CIRCT IR Compiler and Tools&#34;. The T can be selectively expanded as Tool, Translator, Team, Technology, Target, Tree, Type, ... we&#39;re ok with the ambiguity.&lt;/p&gt; &#xA;&lt;p&gt;The CIRCT community is an open and welcoming community. If you&#39;d like to participate, you can do so in a number of different ways:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Join our &lt;a href=&#34;https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/&#34;&gt;Discourse Forum&lt;/a&gt; on the LLVM Discourse server. To get a &#34;mailing list&#34; like experience click the bell icon in the upper right and switch to &#34;Watching&#34;. It is also helpful to go to your Discourse profile, then the &#34;emails&#34; tab, and check &#34;Enable mailing list mode&#34;. You can also do chat with us on &lt;a href=&#34;https://discord.com/channels/636084430946959380/742572728787402763&#34;&gt;CIRCT channel&lt;/a&gt; of LLVM discord server.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Join our weekly video chat. Please see the &lt;a href=&#34;https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#&#34;&gt;meeting notes document&lt;/a&gt; for more information.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Contribute code. CIRCT follows all of the LLVM Policies: you can create pull requests for the CIRCT repository, and gain commit access using the &lt;a href=&#34;https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access&#34;&gt;standard LLVM policies&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;The EDA industry has well-known and widely used proprietary and open source tools. However, these tools are inconsistent, have usability concerns, and were not designed together into a common platform. Furthermore these tools are generally built with &lt;a href=&#34;https://en.wikipedia.org/wiki/Verilog&#34;&gt;Verilog&lt;/a&gt; (also &lt;a href=&#34;https://en.wikipedia.org/wiki/VHDL&#34;&gt;VHDL&lt;/a&gt;) as the IRs that they interchange. Verilog has well known design issues, and limitations, e.g. suffering from poor location tracking support.&lt;/p&gt; &#xA;&lt;p&gt;The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools. Many of us dream of having reusable infrastructure that is modular, uses library-based design techniques, is more consistent, and builds on the best practices in compiler infrastructure and compiler design techniques.&lt;/p&gt; &#xA;&lt;p&gt;By working together, we hope that we can build a new center of gravity to draw contributions from the small (but enthusiastic!) community of people who work on open hardware tooling. In turn we hope this will propel open tools forward, enables new higher-level abstractions for hardware design, and perhaps some pieces may even be adopted by proprietary tools in time.&lt;/p&gt; &#xA;&lt;p&gt;For more information, please see our longer &lt;a href=&#34;https://raw.githubusercontent.com/llvm/circt/main/docs/Charter.md&#34;&gt;charter document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Setting this up&lt;/h2&gt; &#xA;&lt;p&gt;These commands can be used to setup CIRCT project:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Install Dependencies&lt;/strong&gt; of LLVM/MLIR according to &lt;a href=&#34;https://mlir.llvm.org/getting_started/&#34;&gt;the instructions&lt;/a&gt;, including cmake and ninja.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Check out LLVM and CIRCT repos.&lt;/strong&gt; CIRCT contains LLVM as a git submodule. The LLVM repo here includes staged changes to MLIR which may be necessary to support CIRCT. It also represents the version of LLVM that has been tested. MLIR is still changing relatively rapidly, so feel free to use the current version of LLVM, but APIs may have changed.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:llvm/circt.git&#xA;$ cd circt&#xA;$ git submodule init&#xA;$ git submodule update&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The repository is set up so that &lt;code&gt;git submodule update&lt;/code&gt; performs a shallow clone, meaning it downloads just enough of the LLVM repository to check out the currently specified commit. If you wish to work with the full history of the LLVM repository, you can manually &#34;unshallow&#34; the the submodule:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd llvm&#xA;$ git fetch --unshallow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Build and test LLVM/MLIR:&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd circt&#xA;$ mkdir llvm/build&#xA;$ cd llvm/build&#xA;$ cmake -G Ninja ../llvm \&#xA;    -DLLVM_ENABLE_PROJECTS=&#34;mlir&#34; \&#xA;    -DLLVM_TARGETS_TO_BUILD=&#34;host&#34; \&#xA;    -DLLVM_ENABLE_ASSERTIONS=ON \&#xA;    -DCMAKE_BUILD_TYPE=DEBUG \&#xA;    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON&#xA;$ ninja&#xA;$ ninja check-mlir&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;Build and test CIRCT:&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd circt&#xA;$ mkdir build&#xA;$ cd build&#xA;$ cmake -G Ninja .. \&#xA;    -DMLIR_DIR=$PWD/../llvm/build/lib/cmake/mlir \&#xA;    -DLLVM_DIR=$PWD/../llvm/build/lib/cmake/llvm \&#xA;    -DLLVM_ENABLE_ASSERTIONS=ON \&#xA;    -DCMAKE_BUILD_TYPE=DEBUG \&#xA;    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON&#xA;$ ninja&#xA;$ ninja check-circt&#xA;$ ninja check-circt-integration # Run the integration tests.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-DCMAKE_BUILD_TYPE=DEBUG&lt;/code&gt; flag enables debug information, which makes the whole tree compile slower, but allows you to step through code into the LLVM and MLIR frameworks. The &lt;code&gt;-DCMAKE_EXPORT_COMPILE_COMMANDS=ON&lt;/code&gt; flag generates a &lt;code&gt;build/compile_commands.json&lt;/code&gt; file, which can be used by editors (or plugins) for autocomplete and/or IDE-like features.&lt;/p&gt; &#xA;&lt;p&gt;To get something that runs fast, use &lt;code&gt;-DCMAKE_BUILD_TYPE=Release&lt;/code&gt; or &lt;code&gt;-DCMAKE_BUILD_TYPE=RelWithDebInfo&lt;/code&gt; if you want to go fast and optionally if you want debug info to go with it. &lt;code&gt;Release&lt;/code&gt; mode makes a very large difference in performance.&lt;/p&gt; &#xA;&lt;p&gt;Consult the &lt;a href=&#34;https://raw.githubusercontent.com/llvm/circt/main/docs/GettingStarted.md&#34;&gt;Getting Started&lt;/a&gt; page for detailed information on configuring and compiling CIRCT.&lt;/p&gt; &#xA;&lt;p&gt;Consult the &lt;a href=&#34;https://raw.githubusercontent.com/llvm/circt/main/docs/PythonBindings.md&#34;&gt;Python Bindings&lt;/a&gt; page if you are mainly interested in using CIRCT from a Python prompt or script.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ZeroMemoryEx/APT38-0day-Stealer</title>
    <updated>2023-03-02T01:31:52Z</updated>
    <id>tag:github.com,2023-03-02:/ZeroMemoryEx/APT38-0day-Stealer</id>
    <link href="https://github.com/ZeroMemoryEx/APT38-0day-Stealer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;APT38 Tactic PoC for Stealing 0days&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lazarus-Tactic&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;program based on APT38 North Korea-backed hackers tactic that used in targeting security researchers using a malicious Visual Studio project file (vcxproj) to steal their 0days.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Once the program runs, it will infect all of your Visual Studio projects&lt;/p&gt; &lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60795188/221369862-ef3bd034-66ac-46e1-b2ac-d349a6cf6aa8.png&#34; alt=&#34;Screenshot 2023-02-25 180210&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;DEMO&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/60795188/221441360-f727834f-3759-444c-a8bb-2a8562a433c8.mp4&#34;&gt;https://user-images.githubusercontent.com/60795188/221441360-f727834f-3759-444c-a8bb-2a8562a433c8.mp4&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>