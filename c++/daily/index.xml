<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-05T01:26:35Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lfranke/TRIPS</title>
    <updated>2024-02-05T01:26:35Z</updated>
    <id>tag:github.com,2024-02-05:/lfranke/TRIPS</id>
    <link href="https://github.com/lfranke/TRIPS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TRIPS: Trilinear Point Splatting for Real-Time Radiance Field Rendering&lt;/h1&gt; &#xA;&lt;div style=&#34;text-align: center;&#34;&gt;&#xA; Linus Franke, Darius Rückert, Laura Fink, Marc Stamminger&#xA;&lt;/div&gt; &#xA;&lt;p&gt;Point-based radiance field rendering has demonstrated impressive results for novel view synthesis, offering a compelling blend of rendering quality and computational efficiency. However, also latest approaches in this domain are not without their shortcomings. 3D Gaussian Splatting [Kerbl and Kopanas et al. 2023] struggles when tasked with rendering highly detailed scenes, due to blurring and cloudy artifacts. On the other hand, ADOP [Rückert et al. 2022] can accommodate crisper images, but the neural reconstruction network decreases performance, it grapples with temporal instability and it is unable to effectively address large gaps in the point cloud. In this paper, we present TRIPS (Trilinear Point Splatting), an approach that combines ideas from both Gaussian Splatting and ADOP. The fundamental concept behind our novel technique involves rasterizing points into a screen-space image pyramid, with the selection of the pyramid layer determined by the projected point size. This approach allows rendering arbitrarily large points using a single trilinear write. A lightweight neural network is then used to reconstruct a hole-free image including detail beyond splat resolution. Importantly, our render pipeline is entirely differentiable, allowing for automatic optimization of both point sizes and positions. Our evaluation demonstrate that TRIPS surpasses existing state-of-the-art methods in terms of rendering quality while maintaining a real-time frame rate of 60 frames per second on readily available hardware. This performance extends to challenging scenarios, such as scenes featuring intricate geometry, expansive landscapes, and auto-exposed footage.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://lfranke.github.io/trips/&#34;&gt;[Project Page]&lt;/a&gt; &lt;a href=&#34;https://arxiv.org/abs/2401.06003&#34;&gt;[Paper]&lt;/a&gt; &lt;a href=&#34;https://youtu.be/Nw4A1tIcErQ&#34;&gt;[Youtube]&lt;/a&gt; &lt;a href=&#34;https://zenodo.org/records/10606698&#34;&gt;[Supplemental Data]&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{franke2024trips,&#xA;    title={TRIPS: Trilinear Point Splatting for Real-Time Radiance Field Rendering},&#xA;    author={Linus Franke and Darius R{\&#34;u}ckert and Laura Fink and Marc Stamminger},&#xA;    journal={arXiv preprint arXiv:2401.06003},&#xA;    year = {2024}&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install Requirements&lt;/h2&gt; &#xA;&lt;p&gt;Supported Operating Systems: Ubuntu 22.04, Windows&lt;/p&gt; &#xA;&lt;p&gt;Nvidia GPU (lowest we tested was an RTX2070)&lt;/p&gt; &#xA;&lt;p&gt;Supported Compiler: g++-9 (Linux), MSVC (Windows, we used 19.31.31105.0)&lt;/p&gt; &#xA;&lt;p&gt;Software Requirement: Conda (Anaconda/Miniconda)&lt;/p&gt; &#xA;&lt;h2&gt;Install Instructions Linux&lt;/h2&gt; &#xA;&lt;h3&gt;Install Ubuntu Dependancies&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install git build-essential gcc-9 g++-9&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the viewer, also install:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install xorg-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(There exists a headless mode without window management meant for training on a cluster, see below)&lt;/p&gt; &#xA;&lt;h3&gt;Clone Repo&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone git@github.com:lfranke/TRIPS.git&#xA;cd TRIPS/&#xA;git submodule update --init --recursive --jobs 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create Conda Environment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd TRIPS&#xA;./create_environment.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install Pytorch&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd TRIPS&#xA;./install_pytorch_precompiled.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install CuDNN&lt;/h3&gt; &#xA;&lt;p&gt;Either download the latest version and add it to the conda environment (where CUDA 11.8 was installed) or install via conda:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conda activate trips&#xA;conda install -y -c conda-forge cudnn=8.9.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For our experiments, we used CuDNN 8.9.5, however the conda installed version (8.9.2) should also work fine.&lt;/p&gt; &#xA;&lt;h3&gt;Compile TRIPS&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd TRIPS&#xA;&#xA;conda activate trips&#xA;&#xA;export CONDA=${CONDA_PREFIX:-&#34;$(dirname $(which conda))/../&#34;}&#xA;export CC=gcc-9&#xA;export CXX=g++-9&#xA;export CUDAHOSTCXX=g++-9&#xA;&#xA;mkdir build&#xA;cd build&#xA;&#xA;cmake -DCMAKE_PREFIX_PATH=&#34;./External/libtorch/;${CONDA}&#34; ..&#xA;&#xA;make -j10&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;make can take a long time, especially for some CUDA files.&lt;/p&gt; &#xA;&lt;p&gt;If you get a &lt;code&gt;undefined reference to ...@GLIBCXX_3.4.30&#39; &lt;/code&gt; error during linking, most likely your linker fails to resolve the global and conda version of the c++ standard library.&lt;/p&gt; &#xA;&lt;p&gt;Consider removing the libstdc++ lib from the conda environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd TRIPS&#xA;&#xA;conda activate trips&#xA;&#xA;export CONDA=${CONDA_PREFIX:-&#34;$(dirname $(which conda))/../&#34;}&#xA;&#xA;rm $CONDA_PREFIX/lib/libstdc++.so*&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install Instructions Windows&lt;/h2&gt; &#xA;&lt;h3&gt;Software Requirements:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;VS2022&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;CUDA 11.8&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Cudnn (copy into 11.8 folder as per install instructions) (we used version 8.9.7)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;conda (we used Anaconda3)&lt;/p&gt; &lt;p&gt;[Start VS2022 once for CUDA integration setup]&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Clone Repo&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone git@github.com:lfranke/TRIPS.git&#xA;cd TRIPS/&#xA;git submodule update --init --recursive --jobs 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Setup Environment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conda update -n base -c defaults conda&#xA;&#xA;conda create -y -n trips python=3.9.7&#xA;&#xA;conda activate trips&#xA;&#xA;conda install -y cmake=3.26.4&#xA;conda install -y -c intel mkl=2024.0.0&#xA;conda install -y -c intel mkl-static=2024.0.0&#xA;conda install openmp=8.0.1 -c conda-forge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install libtorch:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download: &lt;a href=&#34;https://download.pytorch.org/libtorch/cu116/libtorch-win-shared-with-deps-1.13.1%2Bcu116.zip&#34;&gt;https://download.pytorch.org/libtorch/cu116/libtorch-win-shared-with-deps-1.13.1%2Bcu116.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Unzip&lt;/li&gt; &#xA; &lt;li&gt;Copy into TRIPS/External&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Folder structure should look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;TRIPS/&#xA;    External/&#xA;        libtorch/&#xA;            bin/&#xA;            cmake/&#xA;            include/&#xA;            lib/&#xA;            ...&#xA;        saiga/&#xA;        ...&#xA;    src/&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Compile&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -Bbuild -DCMAKE_CUDA_COMPILER=&#34;$ENV:CUDA_PATH\bin\nvcc.exe&#34; -DCMAKE_PREFIX_PATH=&#34;.\External\libtorch&#34; -DCONDA_P_PATH=&#34;$ENV:CONDA_PREFIX&#34; -DCUDA_P_PATH=&#34;$ENV:CUDA_PATH&#34; -DCMAKE_BUILD_TYPE=RelWithDebInfo .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake --build build --config RelWithDebInfo -j&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The last cmake build call can take a lot of time.&lt;/p&gt; &#xA;&lt;h2&gt;Running on pretrained models&lt;/h2&gt; &#xA;&lt;p&gt;Supplemental materials link: &lt;a href=&#34;https://zenodo.org/records/10606698&#34;&gt;https://zenodo.org/records/10606698&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;After a successful compilation, the best way to get started is to run &lt;code&gt;viewer&lt;/code&gt; on the &lt;em&gt;tanks and temples&lt;/em&gt; scenes using our pretrained models. First, download the scenes and extract them into &lt;code&gt;scenes/&lt;/code&gt;. Now, download the model checkpoints and extract them into &lt;code&gt;experiments/&lt;/code&gt;. Your folder structure should look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;TRIPS/&#xA;    build/&#xA;        ...&#xA;    experiments/&#xA;        checkpoint_train&#xA;        checkpoint_playground&#xA;        ...&#xA;    scenes/&#xA;        tt_train/&#xA;        tt_playground/&#xA;        ...&#xA;    ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Viewer&lt;/h2&gt; &#xA;&lt;p&gt;Your working directory should be the trips root directory.&lt;/p&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;p&gt;Start the viewer with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conda activate trips&#xA;export CONDA=${CONDA_PREFIX:-&#34;$(dirname $(which conda))/../&#34;}&#xA;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CONDA/lib&#xA;./build/bin/viewer --scene_dir scenes/tt_train&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/bin/RelWithDebInfo/viewer.exe  --scene_dir scenes/tt_train&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The path is different to the Linux path, the compile configuration is added (RelWithDebInfo)!&lt;/p&gt; &#xA;&lt;h3&gt;Viewer Controls&lt;/h3&gt; &#xA;&lt;p&gt;The most important keyboard shortcuts are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;F1: Switch to 3DView&lt;/li&gt; &#xA; &lt;li&gt;F2: Switch to neural view&lt;/li&gt; &#xA; &lt;li&gt;F3: Switch to split view (default)&lt;/li&gt; &#xA; &lt;li&gt;F4: Switch to point rendering view&lt;/li&gt; &#xA; &lt;li&gt;WASD: Move camera&lt;/li&gt; &#xA; &lt;li&gt;Center Mouse + Drag: Rotate around camera center&lt;/li&gt; &#xA; &lt;li&gt;Left Mouse + Drag: Rotate around world center&lt;/li&gt; &#xA; &lt;li&gt;Right click in 3DView: Select camera&lt;/li&gt; &#xA; &lt;li&gt;Q: Move camera to selected camera&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img width=&#34;400&#34; src=&#34;https://raw.githubusercontent.com/lfranke/TRIPS/main/images/adop_viewer.png&#34;&gt; &lt;img width=&#34;400&#34; src=&#34;https://raw.githubusercontent.com/lfranke/TRIPS/main/images/adop_viewer_demo.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;By default, TRIPS is compiled with a reduced GUI. If you want all GUI buttons present, you can add a &lt;code&gt;-DMINIMAL_GUI=OFF&lt;/code&gt; to the first cmake call to compile this in.&lt;/p&gt; &#xA;&lt;h2&gt;Scene Description&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TRIPS uses &lt;a href=&#34;https://github.com/darglein/ADOP&#34;&gt;ADOP&lt;/a&gt;&#39;s scene format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/darglein/ADOP&#34;&gt;ADOP&lt;/a&gt; uses a simple, text-based scene description format.&lt;/li&gt; &#xA; &lt;li&gt;To run on your scenes you have to convert them into this format.&lt;/li&gt; &#xA; &lt;li&gt;If you have created your scene with COLMAP (like us) you can use the colmap2adop converter.&lt;/li&gt; &#xA; &lt;li&gt;More infos on this topic can be found here: &lt;a href=&#34;https://raw.githubusercontent.com/lfranke/TRIPS/main/scenes/README.md&#34;&gt;scenes/README.md&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Training&lt;/h2&gt; &#xA;&lt;p&gt;The pipeline is fitted to your scenes by the &lt;code&gt;train&lt;/code&gt; executable. All training parameters are stored in a separate config file. The basic syntax is:&lt;/p&gt; &#xA;&lt;p&gt;Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/bin/train --config configs/train_normalnet.ini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/bin/RelWithDebInfo/train.exe --config configs/train_normalnet.ini&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make again sure that the working directory is the root. Otherwise, the loss models will not be found.&lt;/p&gt; &#xA;&lt;p&gt;Two configs are given for the two networks used in the paper: train_normalnet.ini and train_sphericalnet.ini You can override the options in these configs easily via the command line.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/bin/train --config configs/train_normalnet.ini --TrainParams.scene_names tt_train --TrainParams.name new_name_for_this_training&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For scenes with extensive environments, consider adding an environment map with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;--PipelineParams.enable_environment_map true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If GPU memory is sparse, consider lowering &lt;code&gt;batch_size&lt;/code&gt; (standard is 4), &lt;code&gt;inner_batch_size&lt;/code&gt; (standard is 4) or &lt;code&gt;train_crop_size&lt;/code&gt; (standard is 512) with for example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;--TrainParams.batch_size 1&#xA;--TrainParams.inner_batch_size 2&#xA;--TrainParams.train_crop_size 256&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(however this may impact quality).&lt;/p&gt; &#xA;&lt;p&gt;By default, every 8th image is removed during training and used as a test image. If you want to change this split, consider overriding which percentage of images should be kept out of training with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;--TrainParams.train_factor 0.1 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;default is 0.125 (so 1/8).&lt;/p&gt; &#xA;&lt;h3&gt;Live Viewer during Training&lt;/h3&gt; &#xA;&lt;p&gt;An experimental live viewer is implemented which shows the fitting process during training in an OpenGL window. If headless mode is not required (see below) you can add a &lt;code&gt;-DLIVE_TRAIN_VIEWER=ON&lt;/code&gt; to the first cmake call to compile this version in.&lt;/p&gt; &#xA;&lt;p&gt;Note: This will have an impact on training speed, as intermediate (full) images will we rendered during training.&lt;/p&gt; &#xA;&lt;h2&gt;Headless Mode&lt;/h2&gt; &#xA;&lt;p&gt;If you do not want the viewer application, consider calling cmake with an additional &lt;code&gt;-DHEADLESS=ON&lt;/code&gt;. This is usually done for training on remote machines.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>finalburnneo/FBNeo</title>
    <updated>2024-02-05T01:26:35Z</updated>
    <id>tag:github.com,2024-02-05:/finalburnneo/FBNeo</id>
    <link href="https://github.com/finalburnneo/FBNeo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;FinalBurn Neo - We are Team FBNeo.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FinalBurn Neo&lt;/h1&gt; &#xA;&lt;p&gt;Official Forum: &lt;a href=&#34;https://neo-source.com&#34;&gt;https://neo-source.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Discord: &lt;a href=&#34;https://discord.gg/8EGVd9v&#34;&gt;https://discord.gg/8EGVd9v&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is the official repository of FinalBurn Neo, an Emulator for Arcade Games &amp;amp; Select Consoles. It is based on the emulators FinalBurn and old versions of &lt;a href=&#34;https://www.mamedev.org&#34;&gt;MAME&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use of this program and its source code is subject to the license conditions provided in the &lt;a href=&#34;https://raw.githubusercontent.com/finalburnneo/FBNeo/master/src/license.txt&#34;&gt;license.txt&lt;/a&gt; file in the src folder.&lt;/p&gt; &#xA;&lt;h1&gt;Work in Progress builds&lt;/h1&gt; &#xA;&lt;p&gt;You can download the latest builds by clicking on the badge below. Please note that the downloads might not be available immediately after a new commit. As this build is of the last commit occasionally you might run into incomplete code, crashes or other issues that &lt;a href=&#34;https://github.com/finalburnneo/FBNeo/releases&#34;&gt;official releases&lt;/a&gt; will not have.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/finalburnneo/FBNeo/releases/tag/latest&#34;&gt;&lt;img src=&#34;https://github.com/finalburnneo/FBNeo/actions/workflows/nightly-release.yml/badge.svg?sanitize=true&#34; alt=&#34;nightly-release&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Ports&lt;/h1&gt; &#xA;&lt;p&gt;Raspberry Pi &lt;a href=&#34;https://raw.githubusercontent.com/finalburnneo/FBNeo/master/README-PI.md&#34;&gt;build instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;macOS &lt;a href=&#34;https://raw.githubusercontent.com/finalburnneo/FBNeo/master/README-macOS.md&#34;&gt;build instructions&lt;/a&gt; and &lt;a href=&#34;https://github.com/fbn-mac/FBNeo/releases&#34;&gt;releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/libretro/FBNeo&#34;&gt;LibRetro port&lt;/a&gt; with builds availble via &lt;a href=&#34;https://www.retroarch.com/&#34;&gt;RetroArch&lt;/a&gt; for a lot of cool platforms.&lt;/p&gt; &#xA;&lt;p&gt;For SDL1.2 builds just type &lt;code&gt;make sdl&lt;/code&gt; (requires SDL1.2 and GCC, make, perl and nasm) &lt;a href=&#34;https://raw.githubusercontent.com/finalburnneo/FBNeo/master/README-SDL.md&#34;&gt;instructions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For SDL2 builds just type &lt;code&gt;make sdl2&lt;/code&gt; (requires SDL2, SDL2_image, gcc, make, perl and nasm) &lt;a href=&#34;https://raw.githubusercontent.com/finalburnneo/FBNeo/master/README-SDL.md&#34;&gt;instructions&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Reporting Issues&lt;/h1&gt; &#xA;&lt;p&gt;Please raise an issue on the &lt;a href=&#34;https://github.com/finalburnneo/FBNeo/issues&#34;&gt;project GitHub&lt;/a&gt; or report on the forums at &lt;a href=&#34;https://neo-source.com&#34;&gt;Neosource&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;What about FB Alpha?&lt;/h1&gt; &#xA;&lt;p&gt;Many of the developers of this project also worked on FB Alpha. Due to a &lt;a href=&#34;https://www.google.com/search?q=capcom+home+arcade+illegal&amp;amp;oq=capcom+home+arcade+illegal&#34;&gt;controversy&lt;/a&gt;, we no longer do, and recommend that everyone use this emulator instead.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;We welcome pull requests and other submissions from anyone. We maintain a list of known bugs and features that would be nice to add on the &lt;a href=&#34;https://github.com/finalburnneo/FBNeo/issues&#34;&gt;issue tracker&lt;/a&gt;, some of which would be a good starting point for new contributors.&lt;/p&gt; &#xA;&lt;p&gt;One of the focuses of FBNeo is ensuring that the codebase is compilable on older systems. This is for many reasons, not least because older hardware still has a use outside of landfill or being stored in a recycling center, but also it can be a lot of fun porting and running FBNeo to other platforms. Currently, this means we will always aim for &lt;a href=&#34;https://en.wikipedia.org/wiki/C%2B%2B03&#34;&gt;C++03 compliance&lt;/a&gt; as a minimum. Any pull requests should keep this in mind!&lt;/p&gt; &#xA;&lt;h2&gt;Notes on Contributions&lt;/h2&gt; &#xA;&lt;p&gt;In the root of the source tree there is an &lt;a href=&#34;https://editorconfig.org/&#34;&gt;.editorconfig&lt;/a&gt; that mandates:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;tabs for indentation&lt;/li&gt; &#xA; &lt;li&gt;tabs use 4 columns&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please see the following function for some ideas on how naming, brackets and braces should be&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void FunctionName(UINT8 var1, UINT16 var2)&#xA;{&#xA;&#x9;UINT64 result;&#xA;&#x9;if (var1 * var2 &amp;gt;= 10) {&#xA;&#x9;&#x9;result = var1 * var2;&#xA;&#x9;} else {&#xA;&#x9;&#x9;result = var1;&#xA;&#x9;}&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Source tree structure&lt;/h2&gt; &#xA;&lt;p&gt;The source for FBNeo is layed out in a similar way to how things were in the days of the original FinalBurn. It&#39;s just that there are now more directories and source files as the emulator has grown significantly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;src/&#xA;--/burn&#x9;&#x9;&#x9;&amp;lt;-- This is where the emulation code lives&#xA;----/devices&#x9;&#x9;&amp;lt;-- This is where emulated devices (EEPROMS, etc) live&#xA;----/drv&#x9;&#x9;&amp;lt;-- This is where the drivers for Games and Systems live&#xA;----/snd&#x9;&#x9;&amp;lt;-- This is where the emulation for sound chips and other sound generating devices live&#xA;--/burner&#x9;&#x9;&amp;lt;-- This is where the frontend code lives&#xA;--/cpu&#x9;&#x9;&#x9;&amp;lt;-- This is where the CPU emulation lives&#xA;--/dep&#x9;&#x9;&#x9;&amp;lt;-- This is where external dependencies live (such as libpng)&#xA;--/intf&#x9;&#x9;&#x9;&amp;lt;-- This is where the platform specific code for each platform that FBNeo supports live (e.g. Video and Sound output)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Porting FBNeo to different systems&lt;/h2&gt; &#xA;&lt;p&gt;In the main source tree, you will see in the intf directory various implementations for different platforms. You should look in here when porting to new platforms. We also encourage new ports, and are happy to have them merged in to the main sourcetree. There is probably a project there for someone to re-implement some of the older ports using the intf standard, should they want to.&lt;/p&gt; &#xA;&lt;p&gt;For portability we define the following types&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;unsigned char   UINT8;&#xA;signed char     INT8;&#xA;unsigned short&#x9;UINT16;&#xA;signed short&#x9;INT16;&#xA;unsigned int&#x9;UINT32;&#xA;signed int      INT32;&#xA;signed int64&#x9;INT64;&#xA;unsigned int64  UINT64;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is recommended that you take a look at the other #defines and structs in the header files in Burn and Burner, and don&#39;t forget that some of the existing code in the intf directory will come in handy for new ports.&lt;/p&gt;</summary>
  </entry>
</feed>