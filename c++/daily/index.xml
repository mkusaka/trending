<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-11-13T01:29:13Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lava/matplotlib-cpp</title>
    <updated>2024-11-13T01:29:13Z</updated>
    <id>tag:github.com,2024-11-13:/lava/matplotlib-cpp</id>
    <link href="https://github.com/lava/matplotlib-cpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extremely simple yet powerful header-only C++ plotting library built on the popular matplotlib&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;matplotlib-cpp&lt;/h1&gt; &#xA;&lt;p&gt;Welcome to matplotlib-cpp, possibly the simplest C++ plotting library. It is built to resemble the plotting API used by Matlab and matplotlib.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Complete minimal example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;matplotlibcpp.h&#34;&#xA;namespace plt = matplotlibcpp;&#xA;int main() {&#xA;    plt::plot({1,3,2,4});&#xA;    plt::show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ minimal.cpp -std=c++11 -I/usr/include/python2.7 -lpython2.7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lava/matplotlib-cpp/master/examples/minimal.png&#34; alt=&#34;Minimal example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;A more comprehensive example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;matplotlibcpp.h&#34;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;&#xA;namespace plt = matplotlibcpp;&#xA;&#xA;int main()&#xA;{&#xA;    // Prepare data.&#xA;    int n = 5000;&#xA;    std::vector&amp;lt;double&amp;gt; x(n), y(n), z(n), w(n,2);&#xA;    for(int i=0; i&amp;lt;n; ++i) {&#xA;        x.at(i) = i*i;&#xA;        y.at(i) = sin(2*M_PI*i/360.0);&#xA;        z.at(i) = log(i);&#xA;    }&#xA;&#xA;    // Set the size of output image to 1200x780 pixels&#xA;    plt::figure_size(1200, 780);&#xA;    // Plot line from given x and y data. Color is selected automatically.&#xA;    plt::plot(x, y);&#xA;    // Plot a red dashed line from given x and y data.&#xA;    plt::plot(x, w,&#34;r--&#34;);&#xA;    // Plot a line whose name will show up as &#34;log(x)&#34; in the legend.&#xA;    plt::named_plot(&#34;log(x)&#34;, x, z);&#xA;    // Set x-axis to interval [0,1000000]&#xA;    plt::xlim(0, 1000*1000);&#xA;    // Add graph title&#xA;    plt::title(&#34;Sample figure&#34;);&#xA;    // Enable legend.&#xA;    plt::legend();&#xA;    // Save the image (file format is determined by the extension)&#xA;    plt::save(&#34;./basic.png&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ basic.cpp -I/usr/include/python2.7 -lpython2.7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lava/matplotlib-cpp/master/examples/basic.png&#34; alt=&#34;Basic example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, matplotlib-cpp also supports some C++11-powered syntactic sugar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cmath&amp;gt;&#xA;#include &#34;matplotlibcpp.h&#34;&#xA;&#xA;using namespace std;&#xA;namespace plt = matplotlibcpp;&#xA;&#xA;int main()&#xA;{&#xA;    // Prepare data.&#xA;    int n = 5000; // number of data points&#xA;    vector&amp;lt;double&amp;gt; x(n),y(n);&#xA;    for(int i=0; i&amp;lt;n; ++i) {&#xA;        double t = 2*M_PI*i/n;&#xA;        x.at(i) = 16*sin(t)*sin(t)*sin(t);&#xA;        y.at(i) = 13*cos(t) - 5*cos(2*t) - 2*cos(3*t) - cos(4*t);&#xA;    }&#xA;&#xA;    // plot() takes an arbitrary number of (x,y,format)-triples.&#xA;    // x must be iterable (that is, anything providing begin(x) and end(x)),&#xA;    // y must either be callable (providing operator() const) or iterable.&#xA;    plt::plot(x, y, &#34;r-&#34;, x, [](double d) { return 12.5+abs(sin(d)); }, &#34;k-&#34;);&#xA;&#xA;&#xA;    // show plots&#xA;    plt::show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ modern.cpp -std=c++11 -I/usr/include/python2.7 -lpython&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lava/matplotlib-cpp/master/examples/modern.png&#34; alt=&#34;Modern example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or some &lt;em&gt;funny-looking xkcd-styled&lt;/em&gt; example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;matplotlibcpp.h&#34;&#xA;#include &amp;lt;vector&amp;gt;&#xA;#include &amp;lt;cmath&amp;gt;&#xA;&#xA;namespace plt = matplotlibcpp;&#xA;&#xA;int main() {&#xA;    std::vector&amp;lt;double&amp;gt; t(1000);&#xA;    std::vector&amp;lt;double&amp;gt; x(t.size());&#xA;&#xA;    for(size_t i = 0; i &amp;lt; t.size(); i++) {&#xA;        t[i] = i / 100.0;&#xA;        x[i] = sin(2.0 * M_PI * 1.0 * t[i]);&#xA;    }&#xA;&#xA;    plt::xkcd();&#xA;    plt::plot(t, x);&#xA;    plt::title(&#34;AN ORDINARY SIN WAVE&#34;);&#xA;    plt::save(&#34;xkcd.png&#34;);&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ xkcd.cpp -std=c++11 -I/usr/include/python2.7 -lpython2.7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lava/matplotlib-cpp/master/examples/xkcd.png&#34; alt=&#34;xkcd example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When working with vector fields, you might be interested in quiver plots:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;../matplotlibcpp.h&#34;&#xA;&#xA;namespace plt = matplotlibcpp;&#xA;&#xA;int main()&#xA;{&#xA;    // u and v are respectively the x and y components of the arrows we&#39;re plotting&#xA;    std::vector&amp;lt;int&amp;gt; x, y, u, v;&#xA;    for (int i = -5; i &amp;lt;= 5; i++) {&#xA;        for (int j = -5; j &amp;lt;= 5; j++) {&#xA;            x.push_back(i);&#xA;            u.push_back(-i);&#xA;            y.push_back(j);&#xA;            v.push_back(-j);&#xA;        }&#xA;    }&#xA;&#xA;    plt::quiver(x, y, u, v);&#xA;    plt::show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ quiver.cpp -std=c++11 -I/usr/include/python2.7 -lpython2.7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lava/matplotlib-cpp/master/examples/quiver.png&#34; alt=&#34;quiver example&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When working with 3d functions, you might be interested in 3d plots:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;../matplotlibcpp.h&#34;&#xA;&#xA;namespace plt = matplotlibcpp;&#xA;&#xA;int main()&#xA;{&#xA;    std::vector&amp;lt;std::vector&amp;lt;double&amp;gt;&amp;gt; x, y, z;&#xA;    for (double i = -5; i &amp;lt;= 5;  i += 0.25) {&#xA;        std::vector&amp;lt;double&amp;gt; x_row, y_row, z_row;&#xA;        for (double j = -5; j &amp;lt;= 5; j += 0.25) {&#xA;            x_row.push_back(i);&#xA;            y_row.push_back(j);&#xA;            z_row.push_back(::std::sin(::std::hypot(i, j)));&#xA;        }&#xA;        x.push_back(x_row);&#xA;        y.push_back(y_row);&#xA;        z.push_back(z_row);&#xA;    }&#xA;&#xA;    plt::plot_surface(x, y, z);&#xA;    plt::show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lava/matplotlib-cpp/master/examples/surface.png&#34; alt=&#34;surface example&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;matplotlib-cpp works by wrapping the popular python plotting library matplotlib. (matplotlib.org) This means you have to have a working python installation, including development headers. On Ubuntu:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install python-matplotlib python-numpy python2.7-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If, for some reason, you&#39;re unable to get a working installation of numpy on your system, you can define the macro &lt;code&gt;WITHOUT_NUMPY&lt;/code&gt; before including the header file to erase this dependency.&lt;/p&gt; &#xA;&lt;p&gt;The C++-part of the library consists of the single header file &lt;code&gt;matplotlibcpp.h&lt;/code&gt; which can be placed anywhere.&lt;/p&gt; &#xA;&lt;p&gt;Since a python interpreter is opened internally, it is necessary to link against &lt;code&gt;libpython&lt;/code&gt; in order to user matplotlib-cpp. Most versions should work, although python likes to randomly break compatibility from time to time so some caution is advised when using the bleeding edge.&lt;/p&gt; &#xA;&lt;h1&gt;CMake&lt;/h1&gt; &#xA;&lt;p&gt;The C++ code is compatible to both python2 and python3. However, the &lt;code&gt;CMakeLists.txt&lt;/code&gt; file is currently set up to use python3 by default, so if python2 is required this has to be changed manually. (a PR that adds a cmake option for this would be highly welcomed)&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: By design (of python), only a single python interpreter can be created per process. When using this library, &lt;em&gt;no other&lt;/em&gt; library that is spawning a python interpreter internally can be used.&lt;/p&gt; &#xA;&lt;p&gt;To compile the code without using cmake, the compiler invocation should look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ example.cpp -I/usr/include/python2.7 -lpython2.7&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be used for linking against a custom build of python&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;g++ example.cpp -I/usr/local/include/fancy-python4 -L/usr/local/lib -lfancy-python4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Vcpkg&lt;/h1&gt; &#xA;&lt;p&gt;You can download and install matplotlib-cpp using the &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt; dependency manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;vcpkg install matplotlib-cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The matplotlib-cpp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;create an issue or pull request&lt;/a&gt; on the vcpkg repository.&lt;/p&gt; &#xA;&lt;h1&gt;C++11&lt;/h1&gt; &#xA;&lt;p&gt;Currently, c++11 is required to build matplotlib-cpp. The last working commit that did not have this requirement was &lt;code&gt;717e98e752260245407c5329846f5d62605eff08&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that support for c++98 was dropped more or less accidentally, so if you have to work with an ancient compiler and still want to enjoy the latest additional features, I&#39;d probably merge a PR that restores support.&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;I initially started this library during my diploma thesis. The usual approach of writing data from the c++ algorithm to a file and afterwards parsing and plotting it in python using matplotlib proved insufficient: Keeping the algorithm and plotting code in sync requires a lot of effort when the C++ code frequently and substantially changes. Additionally, the python yaml parser was not able to cope with files that exceed a few hundred megabytes in size.&lt;/p&gt; &#xA;&lt;p&gt;Therefore, I was looking for a C++ plotting library that was extremely easy to use and to add into an existing codebase, preferably header-only. When I found none, I decided to write one myself, which is basically a C++ wrapper around matplotlib. As you can see from the above examples, plotting data and saving it to an image file can be done as few as two lines of code.&lt;/p&gt; &#xA;&lt;p&gt;The general approach of providing a simple C++ API for utilizing python code was later generalized and extracted into a separate, more powerful library in another project of mine, &lt;a href=&#34;http://www.github.com/lava/wrappy&#34;&gt;wrappy&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Todo/Issues/Wishlist&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;This library is not thread safe. Protect all concurrent access with a mutex. Sadly, this is not easy to fix since it is not caused by the library itself but by the python interpreter, which is itself not thread-safe.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;It would be nice to have a more object-oriented design with a Plot class which would allow multiple independent plots per program.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Right now, only a small subset of matplotlibs functionality is exposed. Stuff like xlabel()/ylabel() etc. should be easy to add.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you use Anaconda on Windows, you might need to set PYTHONHOME to Anaconda home directory and QT_QPA_PLATFORM_PLUGIN_PATH to %PYTHONHOME%Library/plugins/platforms. The latter is for especially when you get the error which says &#39;This application failed to start because it could not find or load the Qt platform plugin &#34;windows&#34; in &#34;&#34;.&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;MacOS: &lt;code&gt;Unable to import matplotlib.pyplot&lt;/code&gt;. Cause: In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os. Solution is described &lt;a href=&#34;https://stackoverflow.com/questions/21784641/installation-issue-with-matplotlib-python?noredirect=1&amp;amp;lq=1&#34;&gt;here&lt;/a&gt;, additional information can be found there too(see links in answers).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>