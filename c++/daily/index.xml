<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-10T01:27:44Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lilipads/gradient_descent_viz</title>
    <updated>2024-05-10T01:27:44Z</updated>
    <id>tag:github.com,2024-05-10:/lilipads/gradient_descent_viz</id>
    <link href="https://github.com/lilipads/gradient_descent_viz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;interactive visualization of 5 popular gradient descent methods with step-by-step illustration and hyperparameter tuning UI&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Gradient Descent Visualization&lt;/h1&gt; &#xA;&lt;p&gt;Gradient Descent Viz is a desktop app that visualizes some popular &lt;a href=&#34;https://en.wikipedia.org/wiki/Stochastic_gradient_descent&#34;&gt;gradient descent methods&lt;/a&gt; in machine learning, including (vanilla) gradient descent, momentum, AdaGrad, RMSProp and Adam. My hope is that by playing around with the different settings, anyone -- beginner or expert -- can come away with new intuitive understanding of these methods. Read here for the &lt;a href=&#34;https://towardsdatascience.com/a-visual-explanation-of-gradient-descent-methods-momentum-adagrad-rmsprop-adam-f898b102325c&#34;&gt;accompanying blog post&lt;/a&gt; that explains these methods in detail.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/demo-overview.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Choose between a few different surfaces. For example, in the screen recording below, you can see that Adam and RMSProp handle saddle points much better than simple gradient descent or momentum.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/demo-surface.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tune parameters. The demo shows a surface with a plateau (right click and drag to rotate, arrow keys to navigate, and ctrl (or cmd) + plus / minus to zoom). Momentum method with a low learning rate is not enough to propel it through the flat region. Dialing up the learning rate solves the issue. Play around with the other parameters too and see what you find.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/demo-parameter-tuning.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Watch step-by-step cartoon to visualize the calculation process of each method. Below is a demo of inner workings of momentum descent.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/demo-step-by-step.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use visual elements to track things such as the gradient, the momentum, sum of squared gradient (visualized by squares whose sizes correspond to the magnitude of the term), adjusted gradient (after dividing by the sum of squared gradient or adding on momentum, depending on the method), and the path. In the example below, you can see that after adjusted by the sum of squared gradient, RMSProp takes a very different direction. Comparing that with AdaGrad, one will visually see that the sum of squared gradient for AdaGrad is much bigger in scale (because it doesn&#39;t decay). You can use this feature to understand what makes each method work or not work under different circumstances.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/demo-visual-elements.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Draw path of the descents. See how different methods reach the destination in different manners.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/demo-path.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;This is a C++ app written in Qt, using the free Qt open-source licensed version. It works cross platform.&lt;/p&gt; &#xA;&lt;p&gt;For pre-built app for MacOS (64 bits), download the file &lt;a href=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/gradient_descent_visualization-macOS64bit.dmg&#34;&gt;gradient_descent_visualization-macOS64bit.dmg&lt;/a&gt; from this repository. Extract the image and run the app (you may need to right click -&amp;gt; open to grant permission to open an app from an unknown developer).&lt;/p&gt; &#xA;&lt;p&gt;For pre-built app for Windows (64 bits), download the file &lt;a href=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/gradient_descent_viz_windows64bit.zip&#34;&gt;gradient_descent_viz_windows64bit.zip&lt;/a&gt; from this repository. Decompress the zip and run the .exe file.&lt;/p&gt; &#xA;&lt;p&gt;To build it from source code, download and install Qt 5.10 or above (&lt;a href=&#34;https://www.qt.io/download&#34;&gt;https://www.qt.io/download&lt;/a&gt;) for your platform. This app uses the Qt Data Visualization package; make sure to include that in your installation as well. Checkout this repository, and build and run gradient_descent_visualization.pro within the Qt Creator IDE.&lt;/p&gt; &#xA;&lt;h2&gt;Code Structure&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The window class is responsible for the UI layout, including all the widgets (spinbox, input text box, etc) on the side bar.&lt;/li&gt; &#xA; &lt;li&gt;The plot_area class is responsible for actions happen inside the plot region, including methods that respond to user inputs using the widgets (e.g. play / pause, change playback speed, change surface, etc).&lt;/li&gt; &#xA; &lt;li&gt;The animation class controls the logic for animation. Each descent method has its own derived animation class, which owns the animated ball, arrows, etc. The class controls the creation and destruction of these objects as well as their placement and properties (such as magnitude and color).&lt;/li&gt; &#xA; &lt;li&gt;The item class and its derived classes inherit QtCustom3DItem and are implementations of our customed items such as the arrows, the squares, the path (which is really just a 3D surface), etc.&lt;/li&gt; &#xA; &lt;li&gt;The GradientDescent class and its derived classes are the mathematic implementations of each descent method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/code_structure_diagram.png&#34; alt=&#34;code structure&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/lilipads/gradient_descent_viz/master/resources/screenshots/code_structure_visual.png&#34; alt=&#34;code strucutre&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome. Looking for help to turn this project into a webapp.&lt;/p&gt;</summary>
  </entry>
</feed>