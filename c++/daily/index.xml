<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-23T01:31:45Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mortbopet/Ripes</title>
    <updated>2023-02-23T01:31:45Z</updated>
    <id>tag:github.com,2023-02-23:/mortbopet/Ripes</id>
    <link href="https://github.com/mortbopet/Ripes" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A graphical processor simulator and assembly editor for the RISC-V ISA&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ripes&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mortbopet/Ripes/actions/workflows/windows-release.yml&#34;&gt;&lt;img src=&#34;https://github.com/mortbopet/Ripes/actions/workflows/windows-release.yml/badge.svg?sanitize=true&#34; alt=&#34;Windows / Qt 5.15&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mortbopet/Ripes/actions/workflows/mac-release.yml&#34;&gt;&lt;img src=&#34;https://github.com/mortbopet/Ripes/actions/workflows/mac-release.yml/badge.svg?sanitize=true&#34; alt=&#34;Mac release / Qt 5.15&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mortbopet/Ripes/actions/workflows/linux-release.yml&#34;&gt;&lt;img src=&#34;https://github.com/mortbopet/Ripes/actions/workflows/linux-release.yml/badge.svg?sanitize=true&#34; alt=&#34;Ubuntu release 16.04 / Qt 5.15&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mortbopet/Ripes/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/mortbopet/Ripes/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;Ripes CI tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/Ripes-VSRTL/&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Ripes-VSRTL/Ripes.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ripes is a visual computer architecture simulator and assembly code editor built for the &lt;a href=&#34;https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf&#34;&gt;RISC-V instruction set architecture&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you enjoy using Ripes, or find it useful in teaching, feel free to leave a tip through &lt;a href=&#34;https://ko-fi.com/mortbopet&#34;&gt;Ko-Fi&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For questions, comments, feature requests, or new ideas, don&#39;t hesitate to share these at the &lt;a href=&#34;https://github.com/mortbopet/Ripes/discussions&#34;&gt;discussions page&lt;/a&gt;.&lt;br&gt; For bugs or issues, please report these at the &lt;a href=&#34;https://github.com/mortbopet/Ripes/issues&#34;&gt;issues page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/mortbopet/Ripes/raw/master/resources/images/animation.gif?raw=true&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Ripes may be used to explore concepts such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;How machine code is executed on a variety of microarchitectures (RV32IMC/RV64IMC based)&lt;/li&gt; &#xA; &lt;li&gt;How different cache designs influence performance&lt;/li&gt; &#xA; &lt;li&gt;How C and assembly code is compiled and assembled to executable machine code&lt;/li&gt; &#xA; &lt;li&gt;How a processor interacts with memory-mapped I/O&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If this is your first time using Ripes, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/mortbopet/Ripes/master/docs/introduction.md&#34;&gt;introduction/tutorial&lt;/a&gt;.&lt;br&gt; For further information, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/mortbopet/Ripes/master/docs/README.md&#34;&gt;Ripes documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Downloading &amp;amp; Installation&lt;/h2&gt; &#xA;&lt;p&gt;Prebuilt binaries are available for Linux, Windows &amp;amp; Mac through the &lt;a href=&#34;https://github.com/mortbopet/Ripes/releases&#34;&gt;Releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Linux&lt;/h3&gt; &#xA;&lt;p&gt;Releases for Linux are distributed in the AppImage format. To run an AppImage:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run &lt;code&gt;chmod a+x&lt;/code&gt; on the AppImage file&lt;/li&gt; &#xA; &lt;li&gt;Run the file! The AppImage for Linux should be compatible with most Linux distributions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;For Windows, the C++ runtime library must be available (if not, a msvcp140.dll error will be produced). You most likely already have this installed, but if this is not the case, you download it &lt;a href=&#34;https://www.microsoft.com/en-us/download/details.aspx?id=48145&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Initially, the following dependencies must be made available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A recent (&amp;gt;=5.15) version of &lt;a href=&#34;https://www.qt.io/download&#34;&gt;Qt&lt;/a&gt; + Qt Charts (&lt;strong&gt;not&lt;/strong&gt; bundled with Qt by default, but can be selected during Qt installation)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then, Ripes can be checked out and built as a standard CMake project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --recursive https://github.com/mortbopet/Ripes.git&#xA;cd Ripes/&#xA;cmake .&#xA;Unix:               Windows:&#xA;make                jom.exe / nmake.exe / ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, that you must have Qt available in your &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt;. For further information on building Qt projects with CMake, refer to &lt;a href=&#34;https://doc.qt.io/qt-5/cmake-manual.html&#34;&gt;Qt: Build with CMake&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;In papers and reports, please refer to Ripes as follows: &#39;Morten Borup Petersen. Ripes. &lt;a href=&#34;https://github.com/mortbopet/Ripes&#34;&gt;https://github.com/mortbopet/Ripes&lt;/a&gt;&#39; or by referring to the &lt;a href=&#34;https://ieeexplore.ieee.org/document/9707149&#34;&gt;WCAE&#39;21 paper on the project&lt;/a&gt;, e.g. using the following BibTeX code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@MISC{Ripes,&#xA;&#x9;author = {Morten Borup Petersen},&#xA;&#x9;title = {Ripes},&#xA;&#x9;howpublished = &#34;\url{https://github.com/mortbopet/Ripes}&#34;&#xA;}&#xA;&#xA;@inproceedings{petersen2021ripes,&#xA;  title={Ripes: A Visual Computer Architecture Simulator},&#xA;  author={Petersen, Morten B},&#xA;  booktitle={2021 ACM/IEEE Workshop on Computer Architecture Education (WCAE)},&#xA;  pages={1--8},&#xA;  year={2021},&#xA;  organization={IEEE}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>google/oboe</title>
    <updated>2023-02-23T01:31:45Z</updated>
    <id>tag:github.com,2023-02-23:/google/oboe</id>
    <link href="https://github.com/google/oboe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Oboe is a C++ library that makes it easy to build high-performance audio apps on Android.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Oboe &lt;a href=&#34;https://github.com/google/oboe/actions&#34;&gt;&lt;img src=&#34;https://github.com/google/oboe/workflows/Build%20CI/badge.svg?sanitize=true&#34; alt=&#34;Build CI&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=csfHAbr5ilI&amp;amp;list=PLWz5rJ2EKKc_duWv9IPNvx9YBudNMmLSa&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/images/getting-started-video.jpg&#34; alt=&#34;Introduction to Oboe video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Oboe is a C++ library which makes it easy to build high-performance audio apps on Android. It was created primarily to allow developers to target a simplified API that works across multiple API levels back to API level 16 (Jelly Bean).&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Compatible with API 16 onwards - runs on 99% of Android devices&lt;/li&gt; &#xA; &lt;li&gt;Chooses the audio API (OpenSL ES on API 16+ or AAudio on API 27+) which will give the best audio performance on the target Android device&lt;/li&gt; &#xA; &lt;li&gt;Automatic latency tuning&lt;/li&gt; &#xA; &lt;li&gt;Modern C++ allowing you to write clean, elegant code&lt;/li&gt; &#xA; &lt;li&gt;Workarounds for some known issues&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/oboe/wiki/AppsUsingOboe&#34;&gt;Used by popular apps and frameworks&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/GettingStarted.md&#34;&gt;Getting Started Guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/FullGuide.md&#34;&gt;Full Guide to Oboe&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://google.github.io/oboe&#34;&gt;API reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/notes/&#34;&gt;Tech Notes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/AndroidAudioHistory.md&#34;&gt;History of Audio features/bugs by Android version&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/OpenSLESMigration.md&#34;&gt;Migration guide for apps using OpenSL ES&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/docs/FAQ.md&#34;&gt;Frequently Asked Questions&lt;/a&gt; (FAQ)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/oboe/milestones&#34;&gt;Our roadmap&lt;/a&gt; - Vote on a feature/issue by adding a thumbs up to the first comment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Community&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reddit: &lt;a href=&#34;https://www.reddit.com/r/androidaudiodev/&#34;&gt;r/androidaudiodev&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;StackOverflow: &lt;a href=&#34;https://stackoverflow.com/questions/tagged/oboe&#34;&gt;#oboe&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/apps/OboeTester/docs&#34;&gt;&lt;strong&gt;OboeTester&lt;/strong&gt; app for measuring latency, glitches, etc.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/tests&#34;&gt;Oboe unit tests&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Videos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLWz5rJ2EKKc_duWv9IPNvx9YBudNMmLSa&#34;&gt;Getting started with Oboe&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=8vOf_fDtur4&#34;&gt;Low Latency Audio - Because Your Ears Are Worth It&lt;/a&gt; (Android Dev Summit &#39;18)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=tWBojmBpS74&#34;&gt;Winning on Android&lt;/a&gt; - How to optimize an Android audio app. (ADC &#39;18)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sample code and apps&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sample apps can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/samples&#34;&gt;samples directory&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A complete &#34;effects processor&#34; app called FXLab can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/apps/fxlab&#34;&gt;apps/fxlab folder&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Also check out the &lt;a href=&#34;https://developer.android.com/codelabs/musicalgame-using-oboe?hl=en#0&#34;&gt;Rhythm Game codelab&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Third party sample code&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jbloit/AndroidLinkAudio&#34;&gt;Ableton Link integration demo&lt;/a&gt; (author: jbloit)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We would love to receive your pull requests. Before we can though, please read the &lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/CONTRIBUTING.md&#34;&gt;contributing&lt;/a&gt; guidelines.&lt;/p&gt; &#xA;&lt;h2&gt;Version history&lt;/h2&gt; &#xA;&lt;p&gt;View the &lt;a href=&#34;https://raw.githubusercontent.com/google/releases&#34;&gt;releases page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/oboe/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>async-profiler/async-profiler</title>
    <updated>2023-02-23T01:31:45Z</updated>
    <id>tag:github.com,2023-02-23:/async-profiler/async-profiler</id>
    <link href="https://github.com/async-profiler/async-profiler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Sampling CPU and HEAP profiler for Java featuring AsyncGetCallTrace + perf_events&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;async-profiler&lt;/h1&gt; &#xA;&lt;p&gt;This project is a low overhead sampling profiler for Java that does not suffer from &lt;a href=&#34;http://psy-lob-saw.blogspot.ru/2016/02/why-most-sampling-java-profilers-are.html&#34;&gt;Safepoint bias problem&lt;/a&gt;. It features HotSpot-specific APIs to collect stack traces and to track memory allocations. The profiler works with OpenJDK, Oracle JDK and other Java runtimes based on the HotSpot JVM.&lt;/p&gt; &#xA;&lt;p&gt;async-profiler can trace the following kinds of events:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CPU cycles&lt;/li&gt; &#xA; &lt;li&gt;Hardware and Software performance counters like cache misses, branch misses, page faults, context switches etc.&lt;/li&gt; &#xA; &lt;li&gt;Allocations in Java Heap&lt;/li&gt; &#xA; &lt;li&gt;Contented lock attempts, including both Java object monitors and ReentrantLocks&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/wiki&#34;&gt;Wiki&lt;/a&gt; or &lt;a href=&#34;https://www.youtube.com/playlist?list=PLNCLTEx3B8h4Yo_WvKWdLvI9mj1XpTKBr&#34;&gt;3 hours playlist&lt;/a&gt; to learn about all features.&lt;/p&gt; &#xA;&lt;h2&gt;Download&lt;/h2&gt; &#xA;&lt;p&gt;Current release (2.9):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux x64 (glibc): &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-x64.tar.gz&#34;&gt;async-profiler-2.9-linux-x64.tar.gz&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Linux x64 (musl): &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-musl-x64.tar.gz&#34;&gt;async-profiler-2.9-linux-musl-x64.tar.gz&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Linux arm64: &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-arm64.tar.gz&#34;&gt;async-profiler-2.9-linux-arm64.tar.gz&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;macOS x64/arm64: &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-macos.zip&#34;&gt;async-profiler-2.9-macos.zip&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Converters between profile formats: &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/converter.jar&#34;&gt;converter.jar&lt;/a&gt;&lt;br&gt; (JFR to Flame Graph, JFR to FlameScope, collapsed stacks to Flame Graph)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/releases&#34;&gt;Previous releases&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: async-profiler also comes bundled with IntelliJ IDEA Ultimate 2018.3 and later. For more information refer to &lt;a href=&#34;https://www.jetbrains.com/help/idea/cpu-and-allocation-profiling-basic-concepts.html&#34;&gt;IntelliJ IDEA documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Supported platforms&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Linux&lt;/strong&gt; / x64 / x86 / arm64 / arm32 / ppc64le&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;macOS&lt;/strong&gt; / x64 / arm64&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Community supported builds&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt; / x64 - &lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/9/9c/IntelliJ_IDEA_Icon.svg?sanitize=true&#34; width=&#34;16&#34; height=&#34;16&#34;&gt; &lt;a href=&#34;https://www.jetbrains.com/idea/&#34;&gt;IntelliJ IDEA&lt;/a&gt; 2021.2 and later&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jvm-profiling-tools/ap-loader&#34;&gt;&lt;strong&gt;ap-loader&lt;/strong&gt;&lt;/a&gt; - all-in-one JAR for using async-profiler in Java programs and as a CLI tool&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;CPU profiling&lt;/h2&gt; &#xA;&lt;p&gt;In this mode profiler collects stack trace samples that include &lt;strong&gt;Java&lt;/strong&gt; methods, &lt;strong&gt;native&lt;/strong&gt; calls, &lt;strong&gt;JVM&lt;/strong&gt; code and &lt;strong&gt;kernel&lt;/strong&gt; functions.&lt;/p&gt; &#xA;&lt;p&gt;The general approach is receiving call stacks generated by &lt;code&gt;perf_events&lt;/code&gt; and matching them up with call stacks generated by &lt;code&gt;AsyncGetCallTrace&lt;/code&gt;, in order to produce an accurate profile of both Java and native code. Additionally, async-profiler provides a workaround to recover stack traces in some &lt;a href=&#34;https://bugs.openjdk.java.net/browse/JDK-8178287&#34;&gt;corner cases&lt;/a&gt; where &lt;code&gt;AsyncGetCallTrace&lt;/code&gt; fails.&lt;/p&gt; &#xA;&lt;p&gt;This approach has the following advantages compared to using &lt;code&gt;perf_events&lt;/code&gt; directly with a Java agent that translates addresses to Java method names:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Works on older Java versions because it doesn&#39;t require &lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt;, which is only available in JDK 8u60 and later.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Does not introduce the performance overhead from &lt;code&gt;-XX:+PreserveFramePointer&lt;/code&gt;, which can in rare cases be as high as 10%.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Does not require generating a map file to map Java code addresses to method names.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Works with interpreter frames.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Does not require writing out a perf.data file for further processing in user space scripts.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you wish to resolve frames within &lt;code&gt;libjvm&lt;/code&gt;, the &lt;a href=&#34;https://raw.githubusercontent.com/async-profiler/async-profiler/master/#installing-debug-symbols&#34;&gt;debug symbols&lt;/a&gt; are required.&lt;/p&gt; &#xA;&lt;h2&gt;ALLOCATION profiling&lt;/h2&gt; &#xA;&lt;p&gt;Instead of detecting CPU-consuming code, the profiler can be configured to collect call sites where the largest amount of heap memory is allocated.&lt;/p&gt; &#xA;&lt;p&gt;async-profiler does not use intrusive techniques like bytecode instrumentation or expensive DTrace probes which have significant performance impact. It also does not affect Escape Analysis or prevent from JIT optimizations like allocation elimination. Only actual heap allocations are measured.&lt;/p&gt; &#xA;&lt;p&gt;The profiler features TLAB-driven sampling. It relies on HotSpot-specific callbacks to receive two kinds of notifications:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;when an object is allocated in a newly created TLAB (aqua frames in a Flame Graph);&lt;/li&gt; &#xA; &lt;li&gt;when an object is allocated on a slow path outside TLAB (brown frames).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This means not each allocation is counted, but only allocations every &lt;em&gt;N&lt;/em&gt; kB, where &lt;em&gt;N&lt;/em&gt; is the average size of TLAB. This makes heap sampling very cheap and suitable for production. On the other hand, the collected data may be incomplete, though in practice it will often reflect the top allocation sources.&lt;/p&gt; &#xA;&lt;p&gt;Sampling interval can be adjusted with &lt;code&gt;--alloc&lt;/code&gt; option. For example, &lt;code&gt;--alloc 500k&lt;/code&gt; will take one sample after 500 KB of allocated space on average. However, intervals less than TLAB size will not take effect.&lt;/p&gt; &#xA;&lt;p&gt;The minimum supported JDK version is 7u40 where the TLAB callbacks appeared.&lt;/p&gt; &#xA;&lt;h3&gt;Installing Debug Symbols&lt;/h3&gt; &#xA;&lt;p&gt;Prior to JDK 11, the allocation profiler required HotSpot debug symbols. Oracle JDK already has them embedded in &lt;code&gt;libjvm.so&lt;/code&gt;, but in OpenJDK builds they are typically shipped in a separate package. For example, to install OpenJDK debug symbols on Debian / Ubuntu, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# apt install openjdk-8-dbg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or for OpenJDK 11:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# apt install openjdk-11-dbg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On CentOS, RHEL and some other RPM-based distributions, this could be done with &lt;a href=&#34;http://man7.org/linux/man-pages/man1/debuginfo-install.1.html&#34;&gt;debuginfo-install&lt;/a&gt; utility:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# debuginfo-install java-1.8.0-openjdk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Gentoo the &lt;code&gt;icedtea&lt;/code&gt; OpenJDK package can be built with the per-package setting &lt;code&gt;FEATURES=&#34;nostrip&#34;&lt;/code&gt; to retain symbols.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;gdb&lt;/code&gt; tool can be used to verify if the debug symbols are properly installed for the &lt;code&gt;libjvm&lt;/code&gt; library. For example on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ gdb $JAVA_HOME/lib/server/libjvm.so -ex &#39;info address UseG1GC&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command&#39;s output will either contain &lt;code&gt;Symbol &#34;UseG1GC&#34; is at 0xxxxx&lt;/code&gt; or &lt;code&gt;No symbol &#34;UseG1GC&#34; in current context&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Wall-clock profiling&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;-e wall&lt;/code&gt; option tells async-profiler to sample all threads equally every given period of time regardless of thread status: Running, Sleeping or Blocked. For instance, this can be helpful when profiling application start-up time.&lt;/p&gt; &#xA;&lt;p&gt;Wall-clock profiler is most useful in per-thread mode: &lt;code&gt;-t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Example: &lt;code&gt;./profiler.sh -e wall -t -i 5ms -f result.html 8983&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Java method profiling&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;-e ClassName.methodName&lt;/code&gt; option instruments the given Java method in order to record all invocations of this method with the stack traces.&lt;/p&gt; &#xA;&lt;p&gt;Example: &lt;code&gt;-e java.util.Properties.getProperty&lt;/code&gt; will profile all places where &lt;code&gt;getProperty&lt;/code&gt; method is called from.&lt;/p&gt; &#xA;&lt;p&gt;Only non-native Java methods are supported. To profile a native method, use hardware breakpoint event instead, e.g. &lt;code&gt;-e Java_java_lang_Throwable_fillInStackTrace&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Be aware&lt;/strong&gt; that if you attach async-profiler at runtime, the first instrumentation of a non-native Java method may cause the &lt;a href=&#34;https://github.com/openjdk/jdk/raw/bf2e9ee9d321ed289466b2410f12ad10504d01a2/src/hotspot/share/prims/jvmtiRedefineClasses.cpp#L4092-L4096&#34;&gt;deoptimization&lt;/a&gt; of all compiled methods. The subsequent instrumentation flushes only the &lt;em&gt;dependent code&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The massive CodeCache flush doesn&#39;t occur if attaching async-profiler as an agent.&lt;/p&gt; &#xA;&lt;p&gt;Here are some useful native methods that you may want to profile:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;G1CollectedHeap::humongous_obj_allocate&lt;/code&gt; - trace the &lt;em&gt;humongous allocation&lt;/em&gt; of the G1 GC,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;JVM_StartThread&lt;/code&gt; - trace the new thread creation,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Java_java_lang_ClassLoader_defineClass1&lt;/code&gt; - trace class loading.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Build status: &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/actions/workflows/cpp.yml&#34;&gt;&lt;img src=&#34;https://github.com/jvm-profiling-tools/async-profiler/actions/workflows/cpp.yml/badge.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Make sure the &lt;code&gt;JAVA_HOME&lt;/code&gt; environment variable points to your JDK installation, and then run &lt;code&gt;make&lt;/code&gt;. GCC is required. After building, the profiler agent binary will be in the &lt;code&gt;build&lt;/code&gt; subdirectory. Additionally, a small application &lt;code&gt;jattach&lt;/code&gt; that can load the agent into the target process will also be compiled to the &lt;code&gt;build&lt;/code&gt; subdirectory. If the build fails due to &lt;code&gt;Source option 7 is no longer supported. Use 8 or later.&lt;/code&gt;, use &lt;code&gt;make JAVA_TARGET=8&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;As of Linux 4.6, capturing kernel call stacks using &lt;code&gt;perf_events&lt;/code&gt; from a non-root process requires setting two runtime variables. You can set them using sysctl or as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# sysctl kernel.perf_event_paranoid=1&#xA;# sysctl kernel.kptr_restrict=0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the agent and pass commands to it, the helper script &lt;code&gt;profiler.sh&lt;/code&gt; is provided. A typical workflow would be to launch your Java application, attach the agent and start profiling, exercise your performance scenario, and then stop profiling. The agent&#39;s output, including the profiling results, will be displayed in the Java application&#39;s standard output.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ jps&#xA;9234 Jps&#xA;8983 Computey&#xA;$ ./profiler.sh start 8983&#xA;$ ./profiler.sh stop 8983&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following may be used in lieu of the &lt;code&gt;pid&lt;/code&gt; (8983):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The keyword &lt;code&gt;jps&lt;/code&gt;, which will use the most recently launched Java process.&lt;/li&gt; &#xA; &lt;li&gt;The application name as it appears in the &lt;code&gt;jps&lt;/code&gt; output: e.g. &lt;code&gt;Computey&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Alternatively, you may specify &lt;code&gt;-d&lt;/code&gt; (duration) argument to profile the application for a fixed period of time with a single command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./profiler.sh -d 30 8983&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the profiling frequency is 100Hz (every 10ms of CPU time). Here is a sample of the output printed to the Java application&#39;s terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;--- Execution profile ---&#xA;Total samples:           687&#xA;Unknown (native):        1 (0.15%)&#xA;&#xA;--- 6790000000 (98.84%) ns, 679 samples&#xA;  [ 0] Primes.isPrime&#xA;  [ 1] Primes.primesThread&#xA;  [ 2] Primes.access$000&#xA;  [ 3] Primes$1.run&#xA;  [ 4] java.lang.Thread.run&#xA;&#xA;... a lot of output omitted for brevity ...&#xA;&#xA;          ns  percent  samples  top&#xA;  ----------  -------  -------  ---&#xA;  6790000000   98.84%      679  Primes.isPrime&#xA;    40000000    0.58%        4  __do_softirq&#xA;&#xA;... more output omitted ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This indicates that the hottest method was &lt;code&gt;Primes.isPrime&lt;/code&gt;, and the hottest call stack leading to it comes from &lt;code&gt;Primes.primesThread&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Launching as an Agent&lt;/h2&gt; &#xA;&lt;p&gt;If you need to profile some code as soon as the JVM starts up, instead of using the &lt;code&gt;profiler.sh&lt;/code&gt; script, it is possible to attach async-profiler as an agent on the command line. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ java -agentpath:/path/to/libasyncProfiler.so=start,event=cpu,file=profile.html ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Agent library is configured through the JVMTI argument interface. The format of the arguments string is described &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/raw/v2.9/src/arguments.cpp#L52&#34;&gt;in the source code&lt;/a&gt;. The &lt;code&gt;profiler.sh&lt;/code&gt; script actually converts command line arguments to that format.&lt;/p&gt; &#xA;&lt;p&gt;For instance, &lt;code&gt;-e wall&lt;/code&gt; is converted to &lt;code&gt;event=wall&lt;/code&gt;, &lt;code&gt;-f profile.html&lt;/code&gt; is converted to &lt;code&gt;file=profile.html&lt;/code&gt;, and so on. However, some arguments are processed directly by &lt;code&gt;profiler.sh&lt;/code&gt; script. E.g. &lt;code&gt;-d 5&lt;/code&gt; results in 3 actions: attaching profiler agent with start command, sleeping for 5 seconds, and then attaching the agent again with stop command.&lt;/p&gt; &#xA;&lt;h2&gt;Multiple events&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to profile CPU, allocations, and locks at the same time. Or, instead of CPU, you may choose any other execution event: wall-clock, perf event, tracepoint, Java method, etc.&lt;/p&gt; &#xA;&lt;p&gt;The only output format that supports multiple events together is JFR. The recording will contain the following event types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;jdk.ExecutionSample&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jdk.ObjectAllocationInNewTLAB&lt;/code&gt; (alloc)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jdk.ObjectAllocationOutsideTLAB&lt;/code&gt; (alloc)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jdk.JavaMonitorEnter&lt;/code&gt; (lock)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;jdk.ThreadPark&lt;/code&gt; (lock)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To start profiling cpu + allocations + locks together, specify&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./profiler.sh -e cpu,alloc,lock -f profile.jfr ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or use &lt;code&gt;--alloc&lt;/code&gt; and &lt;code&gt;--lock&lt;/code&gt; parameters with the desired threshold:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./profiler.sh -e cpu --alloc 2m --lock 10ms -f profile.jfr ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The same, when starting profiler as an agent:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-agentpath:/path/to/libasyncProfiler.so=start,event=cpu,alloc=2m,lock=10ms,file=profile.jfr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Flame Graph visualization&lt;/h2&gt; &#xA;&lt;p&gt;async-profiler provides out-of-the-box &lt;a href=&#34;https://github.com/BrendanGregg/FlameGraph&#34;&gt;Flame Graph&lt;/a&gt; support. Specify &lt;code&gt;-o flamegraph&lt;/code&gt; argument to dump profiling results as an interactive HTML Flame Graph. Also, Flame Graph output format will be chosen automatically if the target filename ends with &lt;code&gt;.html&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ jps&#xA;9234 Jps&#xA;8983 Computey&#xA;$ ./profiler.sh -d 30 -f /tmp/flamegraph.html 8983&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://htmlpreview.github.io/?https://github.com/jvm-profiling-tools/async-profiler/raw/master/demo/flamegraph.html&#34;&gt;&lt;img src=&#34;https://github.com/jvm-profiling-tools/async-profiler/raw/master/demo/flamegraph.png&#34; alt=&#34;Example&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Profiler Options&lt;/h2&gt; &#xA;&lt;p&gt;The following is a complete list of the command-line options accepted by &lt;code&gt;profiler.sh&lt;/code&gt; script.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;start&lt;/code&gt; - starts profiling in semi-automatic mode, i.e. profiler will run until &lt;code&gt;stop&lt;/code&gt; command is explicitly called.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;resume&lt;/code&gt; - starts or resumes earlier profiling session that has been stopped. All the collected data remains valid. The profiling options are not preserved between sessions, and should be specified again.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;stop&lt;/code&gt; - stops profiling and prints the report.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;dump&lt;/code&gt; - dump collected data without stopping profiling session.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;check&lt;/code&gt; - check if the specified profiling event is available.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;status&lt;/code&gt; - prints profiling status: whether profiler is active and for how long.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;meminfo&lt;/code&gt; - prints used memory statistics.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;list&lt;/code&gt; - show the list of profiling events available for the target process (if PID is specified) or for the default JVM.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-d N&lt;/code&gt; - the profiling duration, in seconds. If no &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;resume&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; option is given, the profiler will run for the specified period of time and then automatically stop.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -d 30 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-e event&lt;/code&gt; - the profiling event: &lt;code&gt;cpu&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;cache-misses&lt;/code&gt; etc. Use &lt;code&gt;list&lt;/code&gt; to see the complete list of available events.&lt;/p&gt; &lt;p&gt;In allocation profiling mode the top frame of every call trace is the class of the allocated object, and the counter is the heap pressure (the total size of allocated TLABs or objects outside TLAB).&lt;/p&gt; &lt;p&gt;In lock profiling mode the top frame is the class of lock/monitor, and the counter is number of nanoseconds it took to enter this lock/monitor.&lt;/p&gt; &lt;p&gt;Two special event types are supported on Linux: hardware breakpoints and kernel tracepoints:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;-e mem:&amp;lt;func&amp;gt;[:rwx]&lt;/code&gt; sets read/write/exec breakpoint at function &lt;code&gt;&amp;lt;func&amp;gt;&lt;/code&gt;. The format of &lt;code&gt;mem&lt;/code&gt; event is the same as in &lt;code&gt;perf-record&lt;/code&gt;. Execution breakpoints can be also specified by the function name, e.g. &lt;code&gt;-e malloc&lt;/code&gt; will trace all calls of native &lt;code&gt;malloc&lt;/code&gt; function.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;-e trace:&amp;lt;id&amp;gt;&lt;/code&gt; sets a kernel tracepoint. It is possible to specify tracepoint symbolic name, e.g. &lt;code&gt;-e syscalls:sys_enter_open&lt;/code&gt; will trace all &lt;code&gt;open&lt;/code&gt; syscalls.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-i N&lt;/code&gt; - sets the profiling interval in nanoseconds or in other units, if N is followed by &lt;code&gt;ms&lt;/code&gt; (for milliseconds), &lt;code&gt;us&lt;/code&gt; (for microseconds), or &lt;code&gt;s&lt;/code&gt; (for seconds). Only CPU active time is counted. No samples are collected while CPU is idle. The default is 10000000 (10ms).&lt;br&gt; Example: &lt;code&gt;./profiler.sh -i 500us 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--alloc N&lt;/code&gt; - allocation profiling interval in bytes or in other units, if N is followed by &lt;code&gt;k&lt;/code&gt; (kilobytes), &lt;code&gt;m&lt;/code&gt; (megabytes), or &lt;code&gt;g&lt;/code&gt; (gigabytes).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--live&lt;/code&gt; - retain allocation samples with live objects only (object that have not been collected by the end of profiling session). Useful for finding Java heap memory leaks.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--lock N&lt;/code&gt; - lock profiling threshold in nanoseconds (or other units). In lock profiling mode, record contended locks that the JVM has waited for longer than the specified duration.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-j N&lt;/code&gt; - sets the Java stack profiling depth. This option will be ignored if N is greater than default 2048.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -j 30 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-t&lt;/code&gt; - profile threads separately. Each stack trace will end with a frame that denotes a single thread.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -t 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-s&lt;/code&gt; - print simple class names instead of FQN.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-g&lt;/code&gt; - print method signatures.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-a&lt;/code&gt; - annotate JIT compiled methods with &lt;code&gt;_[j]&lt;/code&gt;, inlined methods with &lt;code&gt;_[i]&lt;/code&gt;, interpreted methods with &lt;code&gt;_[0]&lt;/code&gt; and C1 compiled methods with &lt;code&gt;_[1]&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-l&lt;/code&gt; - prepend library names to symbols, e.g. &lt;code&gt;libjvm.so`JVM_DefineClassWithSource&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-o fmt&lt;/code&gt; - specifies what information to dump when profiling ends. &lt;code&gt;fmt&lt;/code&gt; can be one of the following options:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;traces[=N]&lt;/code&gt; - dump call traces (at most N samples);&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;flat[=N]&lt;/code&gt; - dump flat profile (top N hot methods);&lt;br&gt; can be combined with &lt;code&gt;traces&lt;/code&gt;, e.g. &lt;code&gt;traces=200,flat=200&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;jfr&lt;/code&gt; - dump events in Java Flight Recorder format readable by Java Mission Control. This &lt;em&gt;does not&lt;/em&gt; require JDK commercial features to be enabled.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;collapsed&lt;/code&gt; - dump collapsed call traces in the format used by &lt;a href=&#34;https://github.com/brendangregg/FlameGraph&#34;&gt;FlameGraph&lt;/a&gt; script. This is a collection of call stacks, where each line is a semicolon separated list of frames followed by a counter.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;flamegraph&lt;/code&gt; - produce Flame Graph in HTML format.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;tree&lt;/code&gt; - produce Call Tree in HTML format.&lt;br&gt; &lt;code&gt;--reverse&lt;/code&gt; option will generate backtrace view.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--total&lt;/code&gt; - count the total value of the collected metric instead of the number of samples, e.g. total allocation size.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--chunksize N&lt;/code&gt;, &lt;code&gt;--chunktime N&lt;/code&gt; - approximate size and time limits for a single JFR chunk. A new chunk will be started whenever either limit is reached. The default &lt;code&gt;chunksize&lt;/code&gt; is 100MB, and the default &lt;code&gt;chunktime&lt;/code&gt; is 1 hour.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -f profile.jfr --chunksize 100m --chunktime 1h 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-I include&lt;/code&gt;, &lt;code&gt;-X exclude&lt;/code&gt; - filter stack traces by the given pattern(s). &lt;code&gt;-I&lt;/code&gt; defines the name pattern that &lt;em&gt;must&lt;/em&gt; be present in the stack traces, while &lt;code&gt;-X&lt;/code&gt; is the pattern that &lt;em&gt;must not&lt;/em&gt; occur in any of stack traces in the output. &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; options can be specified multiple times. A pattern may begin or end with a star &lt;code&gt;*&lt;/code&gt; that denotes any (possibly empty) sequence of characters.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -I &#39;Primes.*&#39; -I &#39;java/*&#39; -X &#39;*Unsafe.park*&#39; 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--title TITLE&lt;/code&gt;, &lt;code&gt;--minwidth PERCENT&lt;/code&gt;, &lt;code&gt;--reverse&lt;/code&gt; - FlameGraph parameters.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -f profile.html --title &#34;Sample CPU profile&#34; --minwidth 0.5 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-f FILENAME&lt;/code&gt; - the file name to dump the profile information to.&lt;br&gt; &lt;code&gt;%p&lt;/code&gt; in the file name is expanded to the PID of the target JVM;&lt;br&gt; &lt;code&gt;%t&lt;/code&gt; - to the timestamp;&lt;br&gt; &lt;code&gt;%n{MAX}&lt;/code&gt; - to the sequence number;&lt;br&gt; &lt;code&gt;%{ENV}&lt;/code&gt; - to the value of the given environment variable.&lt;br&gt; Example: &lt;code&gt;./profiler.sh -o collapsed -f /tmp/traces-%t.txt 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--loop TIME&lt;/code&gt; - run profiler in a loop (continuous profiling). The argument is either a clock time (&lt;code&gt;hh:mm:ss&lt;/code&gt;) or a loop duration in &lt;code&gt;s&lt;/code&gt;econds, &lt;code&gt;m&lt;/code&gt;inutes, &lt;code&gt;h&lt;/code&gt;ours, or &lt;code&gt;d&lt;/code&gt;ays. Make sure the filename includes a timestamp pattern, or the output will be overwritten on each iteration.&lt;br&gt; Example: &lt;code&gt;./profiler.sh --loop 1h -f /var/log/profile-%t.jfr 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--all-user&lt;/code&gt; - include only user-mode events. This option is helpful when kernel profiling is restricted by &lt;code&gt;perf_event_paranoid&lt;/code&gt; settings.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--sched&lt;/code&gt; - group threads by Linux-specific scheduling policy: BATCH/IDLE/OTHER.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--cstack MODE&lt;/code&gt; - how to walk native frames (C stack). Possible modes are &lt;code&gt;fp&lt;/code&gt; (Frame Pointer), &lt;code&gt;dwarf&lt;/code&gt; (DWARF unwind info), &lt;code&gt;lbr&lt;/code&gt; (Last Branch Record, available on Haswell since Linux 4.1), and &lt;code&gt;no&lt;/code&gt; (do not collect C stack).&lt;/p&gt; &lt;p&gt;By default, C stack is shown in cpu, itimer, wall-clock and perf-events profiles. Java-level events like &lt;code&gt;alloc&lt;/code&gt; and &lt;code&gt;lock&lt;/code&gt; collect only Java stack.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--begin function&lt;/code&gt;, &lt;code&gt;--end function&lt;/code&gt; - automatically start/stop profiling when the specified native function is executed.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--ttsp&lt;/code&gt; - time-to-safepoint profiling. An alias for&lt;br&gt; &lt;code&gt;--begin SafepointSynchronize::begin --end RuntimeService::record_safepoint_synchronized&lt;/code&gt;&lt;br&gt; It is not a separate event type, but rather a constraint. Whatever event type you choose (e.g. &lt;code&gt;cpu&lt;/code&gt; or &lt;code&gt;wall&lt;/code&gt;), the profiler will work as usual, except that only events between the safepoint request and the start of the VM operation will be recorded.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--jfrsync CONFIG&lt;/code&gt; - start Java Flight Recording with the given configuration synchronously with the profiler. The output .jfr file will include all regular JFR events, except that execution samples will be obtained from async-profiler. This option implies &lt;code&gt;-o jfr&lt;/code&gt;.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;CONFIG&lt;/code&gt; is a predefined JFR profile or a JFR configuration file (.jfc).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;Example: &lt;code&gt;./profiler.sh -e cpu --jfrsync profile -f combined.jfr 8983&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;--fdtransfer&lt;/code&gt; - runs &#34;fdtransfer&#34; alongside, which is a small program providing an interface for the profiler to access &lt;code&gt;perf_event_open&lt;/code&gt; even while this syscall is unavailable for the profiled process (due to low privileges). See &lt;a href=&#34;https://raw.githubusercontent.com/async-profiler/async-profiler/master/#profiling-java-in-a-container&#34;&gt;Profiling Java in a container&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-v&lt;/code&gt;, &lt;code&gt;--version&lt;/code&gt; - prints the version of profiler library. If PID is specified, gets the version of the library loaded into the given process.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Profiling Java in a container&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to profile Java processes running in a Docker or LXC container both from within a container and from the host system.&lt;/p&gt; &#xA;&lt;p&gt;When profiling from the host, &lt;code&gt;pid&lt;/code&gt; should be the Java process ID in the host namespace. Use &lt;code&gt;ps aux | grep java&lt;/code&gt; or &lt;code&gt;docker top &amp;lt;container&amp;gt;&lt;/code&gt; to find the process ID.&lt;/p&gt; &#xA;&lt;p&gt;async-profiler should be run from the host by a privileged user - it will automatically switch to the proper pid/mount namespace and change user credentials to match the target process. Also make sure that the target container can access &lt;code&gt;libasyncProfiler.so&lt;/code&gt; by the same absolute path as on the host.&lt;/p&gt; &#xA;&lt;p&gt;By default, Docker container restricts the access to &lt;code&gt;perf_event_open&lt;/code&gt; syscall. There are 3 alternatives to allow profiling in a container:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You can modify the &lt;a href=&#34;https://docs.docker.com/engine/security/seccomp/&#34;&gt;seccomp profile&lt;/a&gt; or disable it altogether with &lt;code&gt;--security-opt seccomp=unconfined&lt;/code&gt; option. In addition, &lt;code&gt;--cap-add SYS_ADMIN&lt;/code&gt; may be required.&lt;/li&gt; &#xA; &lt;li&gt;You can use &#34;fdtransfer&#34;: see the help for &lt;code&gt;--fdtransfer&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Last, you may fall back to &lt;code&gt;-e itimer&lt;/code&gt; profiling mode, see &lt;a href=&#34;https://raw.githubusercontent.com/async-profiler/async-profiler/master/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Restrictions/Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;macOS profiling is limited to user space code only.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On most Linux systems, &lt;code&gt;perf_events&lt;/code&gt; captures call stacks with a maximum depth of 127 frames. On recent Linux kernels, this can be configured using &lt;code&gt;sysctl kernel.perf_event_max_stack&lt;/code&gt; or by writing to the &lt;code&gt;/proc/sys/kernel/perf_event_max_stack&lt;/code&gt; file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Profiler allocates 8kB perf_event buffer for each thread of the target process. Make sure &lt;code&gt;/proc/sys/kernel/perf_event_mlock_kb&lt;/code&gt; value is large enough (more than &lt;code&gt;8 * threads&lt;/code&gt;) when running under unprivileged user. Otherwise the message &lt;em&gt;&#34;perf_event mmap failed: Operation not permitted&#34;&lt;/em&gt; will be printed, and no native stack traces will be collected.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There is no bullet-proof guarantee that the &lt;code&gt;perf_events&lt;/code&gt; overflow signal is delivered to the Java thread in a way that guarantees no other code has run, which means that in some rare cases, the captured Java stack might not match the captured native (user+kernel) stack.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You will not see the non-Java frames &lt;em&gt;preceding&lt;/em&gt; the Java frames on the stack. For example, if &lt;code&gt;start_thread&lt;/code&gt; called &lt;code&gt;JavaMain&lt;/code&gt; and then your Java code started running, you will not see the first two frames in the resulting stack. On the other hand, you &lt;em&gt;will&lt;/em&gt; see non-Java frames (user and kernel) invoked by your Java code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No Java stacks will be collected if &lt;code&gt;-XX:MaxJavaStackTraceDepth&lt;/code&gt; is zero or negative.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Too short profiling interval may cause continuous interruption of heavy system calls like &lt;code&gt;clone()&lt;/code&gt;, so that it will never complete; see &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/issues/97&#34;&gt;#97&lt;/a&gt;. The workaround is simply to increase the interval.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;When agent is not loaded at JVM startup (by using -agentpath option) it is highly recommended to use &lt;code&gt;-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints&lt;/code&gt; JVM flags. Without those flags the profiler will still work correctly but results might be less accurate. For example, without &lt;code&gt;-XX:+DebugNonSafepoints&lt;/code&gt; there is a high chance that simple inlined methods will not appear in the profile. When the agent is attached at runtime, &lt;code&gt;CompiledMethodLoad&lt;/code&gt; JVMTI event enables debug info, but only for methods compiled after attaching.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Failed to change credentials to match the target process: Operation not permitted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Due to limitation of HotSpot Dynamic Attach mechanism, the profiler must be run by exactly the same user (and group) as the owner of target JVM process. If profiler is run by a different user, it will try to automatically change current user and group. This will likely succeed for &lt;code&gt;root&lt;/code&gt;, but not for other users, resulting in the above error.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Could not start attach mechanism: No such file or directory&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The profiler cannot establish communication with the target JVM through UNIX domain socket.&lt;/p&gt; &#xA;&lt;p&gt;Usually this happens in one of the following cases:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Attach socket &lt;code&gt;/tmp/.java_pidNNN&lt;/code&gt; has been deleted. It is a common practice to clean &lt;code&gt;/tmp&lt;/code&gt; automatically with some scheduled script. Configure the cleanup software to exclude &lt;code&gt;.java_pid*&lt;/code&gt; files from deletion.&lt;br&gt; How to check: run &lt;code&gt;lsof -p PID | grep java_pid&lt;/code&gt;&lt;br&gt; If it lists a socket file, but the file does not exist, then this is exactly the described problem.&lt;/li&gt; &#xA; &lt;li&gt;JVM is started with &lt;code&gt;-XX:+DisableAttachMechanism&lt;/code&gt; option.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt; directory of Java process is not physically the same directory as &lt;code&gt;/tmp&lt;/code&gt; of your shell, because Java is running in a container or in &lt;code&gt;chroot&lt;/code&gt; environment. &lt;code&gt;jattach&lt;/code&gt; attempts to solve this automatically, but it might lack the required permissions to do so.&lt;br&gt; Check &lt;code&gt;strace build/jattach PID properties&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;JVM is busy and cannot reach a safepoint. For instance, JVM is in the middle of long-running garbage collection.&lt;br&gt; How to check: run &lt;code&gt;kill -3 PID&lt;/code&gt;. Healthy JVM process should print a thread dump and heap info in its console.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;Failed to inject profiler into &amp;lt;pid&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The connection with the target JVM has been established, but JVM is unable to load profiler shared library. Make sure the user of JVM process has permissions to access &lt;code&gt;libasyncProfiler.so&lt;/code&gt; by exactly the same absolute path. For more information see &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/issues/78&#34;&gt;#78&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;No access to perf events. Try --fdtransfer or --all-user option or &#39;sysctl kernel.perf_event_paranoid=1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Perf events unavailable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;perf_event_open()&lt;/code&gt; syscall has failed.&lt;/p&gt; &#xA;&lt;p&gt;Typical reasons include:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;/proc/sys/kernel/perf_event_paranoid&lt;/code&gt; is set to restricted mode (&amp;gt;=2).&lt;/li&gt; &#xA; &lt;li&gt;seccomp disables &lt;code&gt;perf_event_open&lt;/code&gt; API in a container.&lt;/li&gt; &#xA; &lt;li&gt;OS runs under a hypervisor that does not virtualize performance counters.&lt;/li&gt; &#xA; &lt;li&gt;perf_event_open API is not supported on this system, e.g. WSL.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For permissions-related reasons (such as 1 and 2), using &lt;code&gt;--fdtransfer&lt;/code&gt; while running the profiler as a privileged user will allow using perf_events.&lt;/p&gt; &#xA;&lt;p&gt;If changing the configuration is not possible, you may fall back to &lt;code&gt;-e itimer&lt;/code&gt; profiling mode. It is similar to &lt;code&gt;cpu&lt;/code&gt; mode, but does not require perf_events support. As a drawback, there will be no kernel stack traces.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;No AllocTracer symbols found. Are JDK debug symbols installed?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The OpenJDK debug symbols are required for allocation profiling. See &lt;a href=&#34;https://raw.githubusercontent.com/async-profiler/async-profiler/master/#installing-debug-symbols&#34;&gt;Installing Debug Symbols&lt;/a&gt; for more details. If the error message persists after a successful installation of the debug symbols, it is possible that the JDK was upgraded when installing the debug symbols. In this case, profiling any Java process which had started prior to the installation will continue to display this message, since the process had loaded the older version of the JDK which lacked debug symbols. Restarting the affected Java processes should resolve the issue.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;VMStructs unavailable. Unsupported JVM?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;JVM shared library does not export &lt;code&gt;gHotSpotVMStructs*&lt;/code&gt; symbols - apparently this is not a HotSpot JVM. Sometimes the same message can be also caused by an incorrectly built JDK (see &lt;a href=&#34;https://github.com/jvm-profiling-tools/async-profiler/issues/218&#34;&gt;#218&lt;/a&gt;). In these cases installing JDK debug symbols may solve the problem.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Could not parse symbols from &amp;lt;libname.so&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Async-profiler was unable to parse non-Java function names because of the corrupted contents in &lt;code&gt;/proc/[pid]/maps&lt;/code&gt;. The problem is known to occur in a container when running Ubuntu with Linux kernel 5.x. This is the OS bug, see &lt;a href=&#34;https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1843018&#34;&gt;https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1843018&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Could not open output file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output file is written by the target JVM process, not by the profiler script. Make sure the path specified in &lt;code&gt;-f&lt;/code&gt; option is correct and is accessible by the JVM.&lt;/p&gt;</summary>
  </entry>
</feed>