<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-17T01:33:14Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>HowardHinnant/date</title>
    <updated>2022-08-17T01:33:14Z</updated>
    <id>tag:github.com,2022-08-17:/HowardHinnant/date</id>
    <link href="https://github.com/HowardHinnant/date" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A date and time library based on the C++11/14/17 &lt;chrono&gt; header&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Date&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/HowardHinnant/date&#34;&gt;&lt;img src=&#34;https://travis-ci.org/HowardHinnant/date.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/HowardHinnant/date?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/HowardHinnant/date.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/HowardHinnant/date&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://wandbox.org/permlink/oyXjibyF680HHoyS&#34;&gt;Try it out on wandbox!&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;p&gt;This is actually several separate C++11/C++14/C++17 libraries:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&#34;date.h&#34;&lt;/code&gt; is a header-only library which builds upon &lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;. It adds some new &lt;code&gt;duration&lt;/code&gt; types, and new &lt;code&gt;time_point&lt;/code&gt; types. It also adds &#34;field&#34; types such as &lt;code&gt;year_month_day&lt;/code&gt; which is a struct &lt;code&gt;{year, month, day}&lt;/code&gt;. And it provides convenient means to convert between the &#34;field&#34; types and the &lt;code&gt;time_point&lt;/code&gt; types.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Documentation: &lt;a href=&#34;http://howardhinnant.github.io/date/date.html&#34;&gt;http://howardhinnant.github.io/date/date.html&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Video: &lt;a href=&#34;https://www.youtube.com/watch?v=tzyGjOm8AKo&#34;&gt;https://www.youtube.com/watch?v=tzyGjOm8AKo&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Slides: &lt;a href=&#34;http://schd.ws/hosted_files/cppcon2015/43/hinnant_dates.pdf&#34;&gt;http://schd.ws/hosted_files/cppcon2015/43/hinnant_dates.pdf&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&#34;tz.h&#34;&lt;/code&gt; / &lt;code&gt;&#34;tz.cpp&#34;&lt;/code&gt; are a timezone library built on top of the &lt;code&gt;&#34;date.h&#34;&lt;/code&gt; library. This timezone library is a complete parser of the IANA timezone database. It provides for an easy way to access all of the data in this database, using the types from &lt;code&gt;&#34;date.h&#34;&lt;/code&gt; and &lt;code&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;. The IANA database also includes data on leap seconds, and this library provides utilities to compute with that information as well.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Documentation: &lt;a href=&#34;http://howardhinnant.github.io/date/tz.html&#34;&gt;http://howardhinnant.github.io/date/tz.html&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Video: &lt;a href=&#34;https://www.youtube.com/watch?v=Vwd3pduVGKY&#34;&gt;https://www.youtube.com/watch?v=Vwd3pduVGKY&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Slides: &lt;a href=&#34;http://schd.ws/hosted_files/cppcon2016/0f/Welcome%20To%20The%20Time%20Zone%20-%20Howard%20Hinnant%20-%20CppCon%202016.pdf&#34;&gt;http://schd.ws/hosted_files/cppcon2016/0f/Welcome%20To%20The%20Time%20Zone%20-%20Howard%20Hinnant%20-%20CppCon%202016.pdf&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&#34;iso_week.h&#34;&lt;/code&gt; is a header-only library built on top of the &lt;code&gt;&#34;date.h&#34;&lt;/code&gt; library which implements the ISO week date calendar.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Documentation: &lt;a href=&#34;http://howardhinnant.github.io/date/iso_week.html&#34;&gt;http://howardhinnant.github.io/date/iso_week.html&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&#34;julian.h&#34;&lt;/code&gt; is a header-only library built on top of the &lt;code&gt;&#34;date.h&#34;&lt;/code&gt; library which implements a proleptic Julian calendar which is fully interoperable with everything above.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Documentation: &lt;a href=&#34;http://howardhinnant.github.io/date/julian.html&#34;&gt;http://howardhinnant.github.io/date/julian.html&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;&#34;islamic.h&#34;&lt;/code&gt; is a header-only library built on top of the &lt;code&gt;&#34;date.h&#34;&lt;/code&gt; library which implements a proleptic Islamic calendar which is fully interoperable with everything above.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Documentation: &lt;a href=&#34;http://howardhinnant.github.io/date/islamic.html&#34;&gt;http://howardhinnant.github.io/date/islamic.html&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Standardization&lt;/h2&gt; &#xA;&lt;p&gt;Slightly modified versions of &lt;code&gt;&#34;date.h&#34;&lt;/code&gt; and &lt;code&gt;&#34;tz.h&#34;&lt;/code&gt; were voted into the C++20 working draft at the Jacksonville FL meeting on 2018-03-17:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://howardhinnant.github.io/date/d0355r7.html&#34;&gt;http://howardhinnant.github.io/date/d0355r7.html&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Build &amp;amp; Test&lt;/h2&gt; &#xA;&lt;p&gt;The recommended way to use any of these libraries besides &lt;code&gt;&#34;tz.h&#34;&lt;/code&gt; is to just include it. These are header-only libraries (except &lt;code&gt;&#34;tz.h&#34;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;To use &lt;code&gt;&#34;tz.h&#34;&lt;/code&gt;, there is a single source file (&lt;code&gt;src/tz.cpp&lt;/code&gt;) that needs to be compiled. Here are the recommended directions: &lt;a href=&#34;https://howardhinnant.github.io/date/tz.html#Installation&#34;&gt;https://howardhinnant.github.io/date/tz.html#Installation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;One can run tests by cd&#39;ing into the &lt;code&gt;test&lt;/code&gt; subdirectory and running &lt;code&gt;testit&lt;/code&gt;. There are known failures on all platforms except for macOS. And even on macOS if C++11 is used. If any of these failures present problems for you, there exist workarounds.&lt;/p&gt; &#xA;&lt;p&gt;Additionally there is &lt;em&gt;unsupported&lt;/em&gt; support for &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt; and &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;. I don&#39;t personally use or maintain these systems as for me they cause more problems than they solve (for this small project). If you would like to contribute to these build systems please feel free to file a PR.&lt;/p&gt; &#xA;&lt;p&gt;You can download and install Date using the &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt; dependency manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;vcpkg install date&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Date port in vcpkg is updated by Microsoft team members and community contributors. If the version falls behind, please &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;create an issue or pull request&lt;/a&gt; on the vcpkg repository.&lt;/p&gt; &#xA;&lt;p&gt;You can optionally build using &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;. Here is a guide of how to build and test using the CMake Makefile generator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir build&#xA;cd build&#xA;cmake -DENABLE_DATE_TESTING=ON -DBUILD_TZ_LIB=ON ../&#xA;cmake --build . --target testit #&amp;nbsp;Consider &#39;-- -j4&#39; for multithreading&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Projects using this library&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.safe.com&#34;&gt;www.safe.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.webtoolkit.eu/wt&#34;&gt;www.webtoolkit.eu/wt&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ViewTouch/viewtouch&#34;&gt;https://github.com/ViewTouch/viewtouch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://routinghub.com&#34;&gt;https://routinghub.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/valhalla&#34;&gt;https://github.com/valhalla&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/siodb/siodb&#34;&gt;https://github.com/siodb/siodb&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KomodoPlatform/atomicDEX-Pro&#34;&gt;https://github.com/KomodoPlatform/atomicDEX-Pro&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Kotlin/kotlinx-datetime&#34;&gt;https://github.com/Kotlin/kotlinx-datetime&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/royalbee/jewish_date&#34;&gt;https://github.com/royalbee/jewish_date&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/apache/arrow/&#34;&gt;https://github.com/apache/arrow/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you would like your project (or product) on this list, just let me know.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>openai/triton</title>
    <updated>2022-08-17T01:33:14Z</updated>
    <id>tag:github.com,2022-08-17:/openai/triton</id>
    <link href="https://github.com/openai/triton" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Development repository for the Triton language and compiler&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://cdn.openai.com/triton/assets/triton-logo.png&#34; alt=&#34;Triton logo&#34; width=&#34;88&#34; height=&#34;100&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/openai/triton/actions/workflows/wheels.yml&#34;&gt;&lt;img src=&#34;https://github.com/openai/triton/actions/workflows/wheels.yml/badge.svg?sanitize=true&#34; alt=&#34;Wheels&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;&lt;code&gt;Documentation&lt;/code&gt;&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://triton-lang.org/&#34;&gt;&lt;img src=&#34;https://github.com/openai/triton/actions/workflows/documentation.yml/badge.svg?sanitize=true&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;Triton&lt;/h1&gt; &#xA;&lt;p&gt;This is the development repository of Triton, a language and compiler for writing highly efficient custom Deep-Learning primitives. The aim of Triton is to provide an open-source environment to write fast code at higher productivity than CUDA, but also with higher flexibility than other existing DSLs.&lt;/p&gt; &#xA;&lt;p&gt;The foundations of this project are described in the following MAPL2019 publication: &lt;a href=&#34;http://www.eecs.harvard.edu/~htk/publication/2019-mapl-tillet-kung-cox.pdf&#34;&gt;Triton: An Intermediate Language and Compiler for Tiled Neural Network Computations&lt;/a&gt;. Please consider citing this work if you use Triton!&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://triton-lang.org&#34;&gt;official documentation&lt;/a&gt; contains installation instructions and tutorials.&lt;/p&gt; &#xA;&lt;h1&gt;Quick Installation&lt;/h1&gt; &#xA;&lt;p&gt;You can install the latest stable release of Triton from pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install triton&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Binary wheels are available for CPython 3.6-3.9 and PyPy 3.6-3.7.&lt;/p&gt; &#xA;&lt;p&gt;And the latest nightly release:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -U --pre triton&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Changelog&lt;/h1&gt; &#xA;&lt;p&gt;Version 1.1 is out! New features include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Many, many bugfixes&lt;/li&gt; &#xA; &lt;li&gt;More documentation&lt;/li&gt; &#xA; &lt;li&gt;Automatic on-disk caching of compiled binary objects&lt;/li&gt; &#xA; &lt;li&gt;Random Number Generation&lt;/li&gt; &#xA; &lt;li&gt;Faster (up to 2x on A100), cleaner blocksparse ops&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Community contributions are more than welcome, whether it be to fix bugs or to add new features. Feel free to open GitHub issues about your contribution ideas, and we will review them. A contributor&#39;s guide containing general guidelines is coming soon!&lt;/p&gt; &#xA;&lt;p&gt;If you’re interested in joining our team and working on Triton &amp;amp; GPU kernels, &lt;a href=&#34;https://openai.com/jobs/#acceleration&#34;&gt;we’re hiring&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;Supported Platforms:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Supported Hardware:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NVIDIA GPUs (Compute Capability 7.0+)&lt;/li&gt; &#xA; &lt;li&gt;Under development: AMD GPUs, CPUs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Disclaimer&lt;/h1&gt; &#xA;&lt;p&gt;Triton is a fairly recent project, and it is under active development. We expect it to be pretty useful in a wide variety of cases, but don&#39;t be surprised if it&#39;s a bit rough around the edges :)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>baidu/lac</title>
    <updated>2022-08-17T01:33:14Z</updated>
    <id>tag:github.com,2022-08-17:/baidu/lac</id>
    <link href="https://github.com/baidu/lac" rel="alternate"></link>
    <summary type="html">&lt;p&gt;百度NLP：分词，词性标注，命名实体识别，词重要性&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;工具介绍&lt;/h2&gt; &#xA;&lt;p&gt;LAC全称Lexical Analysis of Chinese，是百度自然语言处理部研发的一款联合的词法分析工具，实现中文分词、词性标注、专名识别等功能。该工具具有以下特点与优势：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;效果好&lt;/strong&gt;：通过深度学习模型联合学习分词、词性标注、专名识别任务，词语重要性，整体效果F1值超过0.91，词性标注F1值超过0.94，专名识别F1值超过0.85，效果业内领先。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;效率高&lt;/strong&gt;：精简模型参数，结合Paddle预测库的性能优化，CPU单线程性能达800QPS，效率业内领先。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;可定制&lt;/strong&gt;：实现简单可控的干预机制，精准匹配用户词典对模型进行干预。词典支持长片段形式，使得干预更为精准。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;调用便捷&lt;/strong&gt;：&lt;strong&gt;支持一键安装&lt;/strong&gt;，同时提供了Python、Java和C++调用接口与调用示例，实现快速调用和集成。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;支持移动端&lt;/strong&gt;: 定制超轻量级模型，体积仅为2M，主流千元手机单线程性能达200QPS，满足大多数移动端应用的需求，同等体积量级效果业内领先。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;安装与使用&lt;/h2&gt; &#xA;&lt;p&gt;在此我们主要介绍Python安装与使用，其他语言使用：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/baidu/lac/master/c++/README.md&#34;&gt;C++&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/baidu/lac/master/java/README.md&#34;&gt;JAVA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/baidu/lac/master/Android/README.md&#34;&gt;Android&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;安装说明&lt;/h3&gt; &#xA;&lt;p&gt;代码兼容Python2/3&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;全自动安装: &lt;code&gt;pip install lac&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;半自动下载：先下载&lt;a href=&#34;http://pypi.python.org/pypi/lac/&#34;&gt;http://pypi.python.org/pypi/lac/&lt;/a&gt;，解压后运行 &lt;code&gt;python setup.py install&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;安装完成后可在命令行输入&lt;code&gt;lac&lt;/code&gt;或&lt;code&gt;lac --segonly&lt;/code&gt;,&lt;code&gt;lac --rank&lt;/code&gt;启动服务，进行快速体验。&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;国内网络可使用百度源安装，安装速率更快：&lt;code&gt;pip install lac -i https://mirror.baidu.com/pypi/simple&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;功能与使用&lt;/h3&gt; &#xA;&lt;h4&gt;分词&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;代码示例：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from LAC import LAC&#xA;&#xA;# 装载分词模型&#xA;lac = LAC(mode=&#39;seg&#39;)&#xA;&#xA;# 单个样本输入，输入为Unicode编码的字符串&#xA;text = u&#34;LAC是个优秀的分词工具&#34;&#xA;seg_result = lac.run(text)&#xA;&#xA;# 批量样本输入, 输入为多个句子组成的list，平均速率会更快&#xA;texts = [u&#34;LAC是个优秀的分词工具&#34;, u&#34;百度是一家高科技公司&#34;]&#xA;seg_result = lac.run(texts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;输出：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;【单样本】：seg_result = [LAC, 是, 个, 优秀, 的, 分词, 工具]&#xA;【批量样本】：seg_result = [[LAC, 是, 个, 优秀, 的, 分词, 工具], [百度, 是, 一家, 高科技, 公司]]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;词性标注与实体识别&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;代码示例：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from LAC import LAC&#xA;&#xA;# 装载LAC模型&#xA;lac = LAC(mode=&#39;lac&#39;)&#xA;&#xA;# 单个样本输入，输入为Unicode编码的字符串&#xA;text = u&#34;LAC是个优秀的分词工具&#34;&#xA;lac_result = lac.run(text)&#xA;&#xA;# 批量样本输入, 输入为多个句子组成的list，平均速率更快&#xA;texts = [u&#34;LAC是个优秀的分词工具&#34;, u&#34;百度是一家高科技公司&#34;]&#xA;lac_result = lac.run(texts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;输出：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;每个句子的输出其切词结果word_list以及对每个单词的标注tags_list，其格式为（word_list, tags_list)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;【单样本】： lac_result = ([百度, 是, 一家, 高科技, 公司], [ORG, v, m, n, n])&#xA;【批量样本】：lac_result = [&#xA;                    ([百度, 是, 一家, 高科技, 公司], [ORG, v, m, n, n]),&#xA;                    ([LAC, 是, 个, 优秀, 的, 分词, 工具], [nz, v, q, a, u, n, n])&#xA;                ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;词性和专名类别标签集合如下表，其中我们将最常用的4个专名类别标记为大写的形式：&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;标签&lt;/th&gt; &#xA;   &lt;th&gt;含义&lt;/th&gt; &#xA;   &lt;th&gt;标签&lt;/th&gt; &#xA;   &lt;th&gt;含义&lt;/th&gt; &#xA;   &lt;th&gt;标签&lt;/th&gt; &#xA;   &lt;th&gt;含义&lt;/th&gt; &#xA;   &lt;th&gt;标签&lt;/th&gt; &#xA;   &lt;th&gt;含义&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;n&lt;/td&gt; &#xA;   &lt;td&gt;普通名词&lt;/td&gt; &#xA;   &lt;td&gt;f&lt;/td&gt; &#xA;   &lt;td&gt;方位名词&lt;/td&gt; &#xA;   &lt;td&gt;s&lt;/td&gt; &#xA;   &lt;td&gt;处所名词&lt;/td&gt; &#xA;   &lt;td&gt;nw&lt;/td&gt; &#xA;   &lt;td&gt;作品名&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;nz&lt;/td&gt; &#xA;   &lt;td&gt;其他专名&lt;/td&gt; &#xA;   &lt;td&gt;v&lt;/td&gt; &#xA;   &lt;td&gt;普通动词&lt;/td&gt; &#xA;   &lt;td&gt;vd&lt;/td&gt; &#xA;   &lt;td&gt;动副词&lt;/td&gt; &#xA;   &lt;td&gt;vn&lt;/td&gt; &#xA;   &lt;td&gt;名动词&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;a&lt;/td&gt; &#xA;   &lt;td&gt;形容词&lt;/td&gt; &#xA;   &lt;td&gt;ad&lt;/td&gt; &#xA;   &lt;td&gt;副形词&lt;/td&gt; &#xA;   &lt;td&gt;an&lt;/td&gt; &#xA;   &lt;td&gt;名形词&lt;/td&gt; &#xA;   &lt;td&gt;d&lt;/td&gt; &#xA;   &lt;td&gt;副词&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;m&lt;/td&gt; &#xA;   &lt;td&gt;数量词&lt;/td&gt; &#xA;   &lt;td&gt;q&lt;/td&gt; &#xA;   &lt;td&gt;量词&lt;/td&gt; &#xA;   &lt;td&gt;r&lt;/td&gt; &#xA;   &lt;td&gt;代词&lt;/td&gt; &#xA;   &lt;td&gt;p&lt;/td&gt; &#xA;   &lt;td&gt;介词&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;c&lt;/td&gt; &#xA;   &lt;td&gt;连词&lt;/td&gt; &#xA;   &lt;td&gt;u&lt;/td&gt; &#xA;   &lt;td&gt;助词&lt;/td&gt; &#xA;   &lt;td&gt;xc&lt;/td&gt; &#xA;   &lt;td&gt;其他虚词&lt;/td&gt; &#xA;   &lt;td&gt;w&lt;/td&gt; &#xA;   &lt;td&gt;标点符号&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;PER&lt;/td&gt; &#xA;   &lt;td&gt;人名&lt;/td&gt; &#xA;   &lt;td&gt;LOC&lt;/td&gt; &#xA;   &lt;td&gt;地名&lt;/td&gt; &#xA;   &lt;td&gt;ORG&lt;/td&gt; &#xA;   &lt;td&gt;机构名&lt;/td&gt; &#xA;   &lt;td&gt;TIME&lt;/td&gt; &#xA;   &lt;td&gt;时间&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;词语重要性&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;代码示例：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from LAC import LAC&#xA;&#xA;# 装载词语重要性模型&#xA;lac = LAC(mode=&#39;rank&#39;)&#xA;&#xA;# 单个样本输入，输入为Unicode编码的字符串&#xA;text = u&#34;LAC是个优秀的分词工具&#34;&#xA;rank_result = lac.run(text)&#xA;&#xA;# 批量样本输入, 输入为多个句子组成的list，平均速率会更快&#xA;texts = [u&#34;LAC是个优秀的分词工具&#34;, u&#34;百度是一家高科技公司&#34;]&#xA;rank_result = lac.run(texts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;输出：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;【单样本】：rank_result = [[&#39;LAC&#39;, &#39;是&#39;, &#39;个&#39;, &#39;优秀&#39;, &#39;的&#39;, &#39;分词&#39;, &#39;工具&#39;], &#xA;                        [nz, v, q, a, u, n, n],[3, 0, 0, 2, 0, 3, 1]]&#xA;【批量样本】：rank_result = [&#xA;                    ([&#39;LAC&#39;, &#39;是&#39;, &#39;个&#39;, &#39;优秀&#39;, &#39;的&#39;, &#39;分词&#39;, &#39;工具&#39;], &#xA;                     [nz, v, q, a, u, n, n], [3, 0, 0, 2, 0, 3, 1]),  &#xA;                    ([&#39;百度&#39;, &#39;是&#39;, &#39;一家&#39;, &#39;高科技&#39;, &#39;公司&#39;], &#xA;                     [ORG, v, m, n, n], [3, 0, 2, 3, 1])&#xA;                ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;词语重要性各类别标签集合如下表，我们使用4-Level梯度进行分类：&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;标签&lt;/th&gt; &#xA;   &lt;th&gt;含义&lt;/th&gt; &#xA;   &lt;th&gt;常见于词性&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;   &lt;td&gt;query中表述的冗余词&lt;/td&gt; &#xA;   &lt;td&gt;p, w, xc ...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;query中限定较弱的词&lt;/td&gt; &#xA;   &lt;td&gt;r, c, u ...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;query中强限定的词&lt;/td&gt; &#xA;   &lt;td&gt;n, s, v ...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;query中的核心词&lt;/td&gt; &#xA;   &lt;td&gt;nz, nw, LOC ...&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;定制化功能&lt;/h4&gt; &#xA;&lt;p&gt;在模型输出的基础上，LAC还支持用户配置定制化的切分结果和专名类型输出。当模型预测匹配到词典的中的item时，会用定制化的结果替代原有结果。为了实现更加精确的匹配，我们支持以由多个单词组成的长片段作为一个item。&lt;/p&gt; &#xA;&lt;p&gt;我们通过装载词典文件的形式实现该功能，词典文件每行表示一个定制化的item，由一个单词或多个连续的单词组成，每个单词后使用&#39;/&#39;表示标签，如果没有&#39;/&#39;标签则会使用模型默认的标签。每个item单词数越多，干预效果会越精准。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;词典文件示例&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;这里仅作为示例，展现各种需求情况下的结果。后续还将开放以通配符配置词典的模式，敬请期待。&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;春天/SEASON&#xA;花/n 开/v&#xA;秋天的风&#xA;落 阳&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;代码示例&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from LAC import LAC&#xA;lac = LAC()&#xA;&#xA;# 装载干预词典, sep参数表示词典文件采用的分隔符，为None时默认使用空格或制表符&#39;\t&#39;&#xA;lac.load_customization(&#39;custom.txt&#39;, sep=None)&#xA;&#xA;# 干预后结果&#xA;custom_result = lac.run(u&#34;春天的花开秋天的风以及冬天的落阳&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;以输入“春天的花开秋天的风以及冬天的落阳”为例，原本输出结果为：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;春天/TIME 的/u 花开/v 秋天/TIME 的/u 风/n 以及/c 冬天/TIME 的/u 落阳/n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加示例中的词典文件后的结果为：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;春天/SEASON 的/u 花/n 开/v 秋天的风/n 以及/c 冬天/TIME 的/u 落/n 阳/n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;增量训练&lt;/h4&gt; &#xA;&lt;p&gt;我们也提供了增量训练的接口，用户可以使用自己的数据，进行增量训练，首先需要将数据转换为模型输入的格式，并且所有数据文件均为&#34;UTF-8&#34;编码：&lt;/p&gt; &#xA;&lt;h5&gt;1. 分词训练&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;数据样例&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;与大多数开源分词数据集格式一致，使用空格作为单词切分标记，如下所示：&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;LAC 是 个 优秀 的 分词 工具 。&#xA;百度 是 一家 高科技 公司 。&#xA;春天 的 花开 秋天 的 风 以及 冬天 的 落阳 。&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;代码示例&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;from LAC import LAC&#xA;&#xA;# 选择使用分词模型&#xA;lac = LAC(mode = &#39;seg&#39;)&#xA;&#xA;# 训练和测试数据集，格式一致&#xA;train_file = &#34;./data/seg_train.tsv&#34;&#xA;test_file = &#34;./data/seg_test.tsv&#34;&#xA;lac.train(model_save_dir=&#39;./my_seg_model/&#39;,train_data=train_file, test_data=test_file)&#xA;&#xA;# 使用自己训练好的模型&#xA;my_lac = LAC(model_path=&#39;my_seg_model&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;2. 词法分析训练&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;样例数据&lt;/p&gt; &#xA;  &lt;blockquote&gt; &#xA;   &lt;p&gt;在分词数据的基础上，每个单词以“/type”的形式标记其词性或实体类别。值得注意的是，词法分析的训练目前仅支持标签体系与我们一致的数据。后续也会开放支持新的标签体系，敬请期待。&lt;/p&gt; &#xA;  &lt;/blockquote&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;LAC/nz 是/v 个/q 优秀/a 的/u 分词/n 工具/n 。/w&#xA;百度/ORG 是/v 一家/m 高科技/n 公司/n 。/w&#xA;春天/TIME 的/u 花开/v 秋天/TIME 的/u 风/n 以及/c 冬天/TIME 的/u 落阳/n 。/w&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;代码示例&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;from LAC import LAC&#xA;&#xA;# 选择使用默认的词法分析模型&#xA;lac = LAC()&#xA;&#xA;# 训练和测试数据集，格式一致&#xA;train_file = &#34;./data/lac_train.tsv&#34;&#xA;test_file = &#34;./data/lac_test.tsv&#34;&#xA;lac.train(model_save_dir=&#39;./my_lac_model/&#39;,train_data=train_file, test_data=test_file)&#xA;&#xA;# 使用自己训练好的模型&#xA;my_lac = LAC(model_path=&#39;my_lac_model&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;文件结构&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;.&#xA;├── python                      # Python调用的脚本&#xA;├── c++                         # C++调用的代码&#xA;├── java                        # Java调用的代码&#xA;├── Android                     # Android调用的示例&#xA;├── README.md                   # 本文件&#xA;└── CMakeList.txt               # 编译C++和Java调用的脚本&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;在论文中引用LAC&lt;/h2&gt; &#xA;&lt;p&gt;如果您的学术工作成果中使用了LAC，请您增加下述引用。我们非常欣慰LAC能够对您的学术工作带来帮助。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;@article{jiao2018LAC,&#xA;&#x9;title={Chinese Lexical Analysis with Deep Bi-GRU-CRF Network},&#xA;&#x9;author={Jiao, Zhenyu and Sun, Shuqi and Sun, Ke},&#xA;&#x9;journal={arXiv preprint arXiv:1807.01882},&#xA;&#x9;year={2018},&#xA;&#x9;url={https://arxiv.org/abs/1807.01882}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;贡献代码&lt;/h2&gt; &#xA;&lt;p&gt;我们欢迎开发者向LAC贡献代码。如果您开发了新功能，发现了bug……欢迎提交Pull request与issue到Github。&lt;/p&gt;</summary>
  </entry>
</feed>