<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-24T01:28:14Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Daiyouqi/Convenience_QThread</title>
    <updated>2024-03-24T01:28:14Z</updated>
    <id>tag:github.com,2024-03-24:/Daiyouqi/Convenience_QThread</id>
    <link href="https://github.com/Daiyouqi/Convenience_QThread" rel="alternate"></link>
    <summary type="html">&lt;p&gt;在c++/qt中使用c#的async/await语法糖&lt;/p&gt;&lt;hr&gt;&lt;p&gt;在c++/qt中使用c#的async/await语法糖 简介 c++/qt编程中，经常有模糊需求“这段代码太慢了，将它移到多线程中”。本框架使用一个大括号标识异步代码段，另一个的大括号标识事件回调代码段，就像C# 中的 async/await 机制一样，使业务开发人员用同步代码的逻辑开发异步代码。并包含任务管理与线程的安全删除接口。&lt;/p&gt; &#xA;&lt;p&gt;示例 以下是一个简单的使用示例，用于异步执行某段代码。通过添加标识符，使函数的上半部分变为异步，下半部分为同步，在不改变代码结构的前提下，将同步改为异步。&lt;/p&gt; &#xA;&lt;p&gt;void Test::SyncCalculate() { m_pi = 计算圆周率(); setText(m_pi); } void Test::ASyncCalculate() { int taskID=easyThread-&amp;gt;async_task(&lt;a href=&#34;&#34;&gt;=&lt;/a&gt; { m_pi = 计算圆周率(); }, &lt;a href=&#34;&#34;&gt;=&lt;/a&gt; { setText(m_pi); }); } 在传统的多线程编程中，首先继承 QThread 类并重载 run方法，然后附加自定义信号，最后链接信号槽调用，此流程相对繁琐。我们通过将这一流程的关键部分抽象出来，用std::function配合std容器存储可调用对象，并由 QThread 线程执行，在任务完成后将回调任务插入调用方事件循环中，以实现异步编程。这个思路也同样适用于其他带事件回调的框架，如 libevent 和 OSG。因为将事件直接插入了事件循环所以无需调用方主动管理，比c++20的coroutine更加新手友好。&lt;/p&gt; &#xA;&lt;p&gt;进阶功能：任务管理与线程的安全删除 在实际应用中，用户常常需要对尚未执行异步任务进行管理，例如查询的幕等性或者撤销查询;C++/Qt 中直接删除一个正在运行的线程对象后子线程仍会执行，可能造成潜在的bug，这是与业务开发无关的语言特性。为了解决这一问题，通过成员变量标识任务状态的方式，我们提供了任务管理接口。同时实现了对象同步 delete 不崩溃，并提供了异步删除接口。&lt;/p&gt; &#xA;&lt;p&gt;开发理念 现在是chatgpt的时代了，并且我们开源的目标就是初级开发人员或是边缘业务。所以我尽量的简化逻辑并去除了实际使用中的远程RPC多路复用、线程池模式，确保gpt和仅6有月开发经验的同事能看懂。 由于人员预算限制，业务变迁等原因，我们不能仅接受高级开发人员或忽略时间的投入产出比。希望这个框架或思路对您的业务开发有所帮助。&lt;/p&gt;</summary>
  </entry>
</feed>