<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-07T01:30:17Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>klezVirus/SilentMoonwalk</title>
    <updated>2022-12-07T01:30:17Z</updated>
    <id>tag:github.com,2022-12-07:/klezVirus/SilentMoonwalk</id>
    <link href="https://github.com/klezVirus/SilentMoonwalk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PoC Implementation of a TRUE call stack spoofer&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;SilentMoonwalk&lt;/h1&gt; &#xA;&lt;p&gt;PoC Implementation of a true call stack spoofer&lt;/p&gt; &#xA;&lt;h2&gt;TL;DR&lt;/h2&gt; &#xA;&lt;p&gt;SilentMoonwalk is a PoC implementation of a true call stack spoofer, implementing a technique to remove the original caller from the call stack, using ROP to desynchronize unwinding from control flow.&lt;/p&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;This PoC is the result of a joint research done on the topic of stack spoofing. The authors of the research are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/KlezVirus&#34;&gt;KlezVirus&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/waldoirc&#34;&gt;Waldo-IRC&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/trickster012&#34;&gt;Trickster0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I want to stress that this work would have been impossible without the work of &lt;a href=&#34;https://twitter.com/waldoirc&#34;&gt;Waldo-IRC&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/trickster012&#34;&gt;Trickster0&lt;/a&gt;, which both contributed to the early stages of the PoC, and to the research behind the PoC.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This repository demonstrates a PoC implementation to spoof the call stack when calling arbitrary Windows APIs.&lt;/p&gt; &#xA;&lt;p&gt;This attempt was inspired by &lt;a href=&#34;https://twitter.com/_Kudaes_/status/1594753842310434816&#34;&gt;this Twitter thread&lt;/a&gt;, and &lt;a href=&#34;https://twitter.com/namazso/status/1442314742488567808&#34;&gt;this Twitter thread&lt;/a&gt;, where sensei &lt;a href=&#34;https://twitter.com/namazso&#34;&gt;namazso&lt;/a&gt; showed and suggested to extend the stack unwinding approach with a ROP chain to both desynchronize the unwinding from real control flow and restore the original stack afterwards.&lt;/p&gt; &#xA;&lt;p&gt;This PoC attempts to do something similar to the above, and uses a desync stack to completely hide the original call stack, also removing the EXE image base from it. Upon return, a ROP gadget is invoked to restore the original stack. In the code, this process is repeated 10 times in a loop, using different frames at each iteration, to prove stability.&lt;/p&gt; &#xA;&lt;h3&gt;Supported Modes&lt;/h3&gt; &#xA;&lt;p&gt;The tool currently supports 2 modes, where one is actually a wrong patch to a non-working pop RBP frame identified, which operates by shifting the current RSP and adding two fake frames to the call stack. As it operates using synthetic frames, I refer to this mode as &#34;SYNTHETIC&#34;.&lt;/p&gt; &#xA;&lt;p&gt;When selecting the frame that unwinds by popping the RBP register from the stack, the tool might select an unsuitable frame, ending up in an abruptly cut call stack, as observable below.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/klezVirus/SilentMoonwalk/master/assets/img/stack_cut.png&#34; alt=&#34;Windows 10 Call Stack - Cut&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Synthetic Call Stack Mode&lt;/h3&gt; &#xA;&lt;p&gt;A silly solution to the problem would be to create two fake frames and link them back to the cut call stack. This would create a sort of apparently legit call stack, even without a suitable frame which unwinds calling POP RBP, but:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You would lose the advantage of the desync technique&lt;/li&gt; &#xA; &lt;li&gt;The stack would be still unwindable&lt;/li&gt; &#xA; &lt;li&gt;The resulting call stack could seem legit just on the first glance, but it would probably not pass a strict check&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The result of the _synthetic spoof can be observed in the image below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/klezVirus/SilentMoonwalk/master/assets/img/stack_win10_getchar.png&#34; alt=&#34;Windows 10 Call Stack - Apparently Legit, non unwinding - getchar&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Figure 1: Windows 10 - Valid call stack whereby the EXE module was completely removed (calling no parameters function getchar)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: This operation mode is disabled by default. To enable this mode, change the CALLSTACK_TYPE to 1&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Desync Stack Mode&lt;/h3&gt; &#xA;&lt;p&gt;This mode is the right solution to the above problem, whereby the non-suitable frame is simply replaced by another, suitable one.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/klezVirus/SilentMoonwalk/master/assets/img/stack_win10_msgbox_ex.png&#34; alt=&#34;Windows 10 Call Stack - Legit, unwinding - MessageBoxExA&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Figure 2: Windows 10 - Valid call stack whereby the EXE module was completely removed (calling 4 parameters function MessageBoxA)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Utility&lt;/h2&gt; &#xA;&lt;p&gt;In the repository, you can find also a little util to inspect runtime functions, which might be useful to analyse runtime function entries.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;UnwindInspector.exe -h&#xA;&#xA; Unwind Inspector v0.100000&#xA;&#xA; Mandatory args:&#xA;   -m &amp;lt;module&amp;gt;: Target DLL&#xA;   -f &amp;lt;function&amp;gt;: Target Function&#xA;   -a &amp;lt;function-address&amp;gt;: Target Function Address&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Sample Output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;UnwindInspector.exe -m kernelbase -a 0x7FFAAE12182C&#xA;[*] Using function address 0x7ffaae12182c&#xA;&#xA;  Runtime Function (0x000000000000182C, 0x00000000000019ED)&#xA;  Unwind Info Address: 0x000000000026AA88&#xA;    Version: 0&#xA;    Ver + Flags: 00000000&#xA;    SizeOfProlog: 0x1f&#xA;    CountOfCodes: 0xc&#xA;    FrameRegister: 0x0&#xA;    FrameOffset: 0x0&#xA;    UnwindCodes:&#xA;    [00h] Frame: 0x741f - 0x04  - UWOP_SAVE_NONVOL     (RDI, 0x001f)&#xA;    [01h] Frame: 0x0015 - 0x00  - UWOP_PUSH_NONVOL     (RAX, 0x0015)&#xA;    [02h] Frame: 0x641f - 0x04  - UWOP_SAVE_NONVOL     (RSI, 0x001f)&#xA;    [03h] Frame: 0x0014 - 0x00  - UWOP_PUSH_NONVOL     (RAX, 0x0014)&#xA;    [04h] Frame: 0x341f - 0x04  - UWOP_SAVE_NONVOL     (RBX, 0x001f)&#xA;    [05h] Frame: 0x0012 - 0x00  - UWOP_PUSH_NONVOL     (RAX, 0x0012)&#xA;    [06h] Frame: 0xb21f - 0x02  - UWOP_ALLOC_SMALL     (R11, 0x001f)&#xA;    [07h] Frame: 0xf018 - 0x00  - UWOP_PUSH_NONVOL     (R15, 0x0018)&#xA;    [08h] Frame: 0xe016 - 0x00  - UWOP_PUSH_NONVOL     (R14, 0x0016)&#xA;    [09h] Frame: 0xd014 - 0x00  - UWOP_PUSH_NONVOL     (R13, 0x0014)&#xA;    [0ah] Frame: 0xc012 - 0x00  - UWOP_PUSH_NONVOL     (R12, 0x0012)&#xA;    [0bh] Frame: 0x5010 - 0x00  - UWOP_PUSH_NONVOL     (RBP, 0x0010)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;In order to build the POC and observe a similar behaviour to the one in the picture, ensure to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disable GS (&lt;code&gt;/GS-&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Disable Code Optimisation (&lt;code&gt;/Od&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Disable Whole Program Optimisation (Remove &lt;code&gt;/GL&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Disable size and speed preference (Remove &lt;code&gt;/Os&lt;/code&gt;, &lt;code&gt;/Ot&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Enable&lt;/strong&gt; intrinsic if not enabled (&lt;code&gt;/Oi&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Previous Work&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s worth mentioning previous work done on this topic, which built the foundation of this work.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html&#34;&gt;Return Address Spoofing&lt;/a&gt;: Original technique and idea, by Namaszo. Every other PoC I&#39;m aware of was built on top of that.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/waldo-irc/YouMayPasser&#34;&gt;YouMayPasser&lt;/a&gt;: This amazing work by Arash is the first properly done extension of the Return Address Spoofing PoC by Namaszo.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WithSecureLabs/CallStackSpoofer/&#34;&gt;VulcanRaven&lt;/a&gt;: A call stack spoofer that operates the spoofing by synthetically creating a Thread Stack mirroring another real call stack.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Kudaes/Unwinder/&#34;&gt;Unwinder&lt;/a&gt;: A very nice Rust PoC implementation of a call stack spoofer which operates by parsing unwind code information to replace frames in the call stack.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Huge shoutout to &lt;a href=&#34;https://twitter.com/waldoirc&#34;&gt;waldo-irc&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/trickster012&#34;&gt;trickster0&lt;/a&gt;, which collaborated with me on this research. I owe everything to them.&lt;/li&gt; &#xA; &lt;li&gt;All the credit for the idea behind this goes to &lt;a href=&#34;https://twitter.com/namazso&#34;&gt;namaszo&lt;/a&gt;, which I personally consider a genius. He also cross checked this PoC before release, so huge thanks to him.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[SYNTHETIC STACK ONLY]: For a limitation in the way I&#39;m locating the gadgets, the maximum number of arguments is 8 for now (it is TRIVIAL to modify and add more params, but I couldn&#39;t bother).&lt;/li&gt; &#xA; &lt;li&gt;Testing on this one was pretty limited. There might be exceptions I&#39;m not aware of at the moment.&lt;/li&gt; &#xA; &lt;li&gt;Unwinding involving 128-bit registers was no tested.&lt;/li&gt; &#xA; &lt;li&gt;Calling functions that use 128-bit registers is not officially supported.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>autowarefoundation/autoware.universe</title>
    <updated>2022-12-07T01:30:17Z</updated>
    <id>tag:github.com,2022-12-07:/autowarefoundation/autoware.universe</id>
    <link href="https://github.com/autowarefoundation/autoware.universe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;autoware.universe&lt;/h1&gt; &#xA;&lt;p&gt;For Autoware&#39;s general documentation, see &lt;a href=&#34;https://autowarefoundation.github.io/autoware-documentation/&#34;&gt;Autoware Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For detailed documents of Autoware Universe components, see &lt;a href=&#34;https://autowarefoundation.github.io/autoware.universe/&#34;&gt;Autoware Universe Documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
</feed>