<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-13T01:25:29Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>laverdet/isolated-vm</title>
    <updated>2023-08-13T01:25:29Z</updated>
    <id>tag:github.com,2023-08-13:/laverdet/isolated-vm</id>
    <link href="https://github.com/laverdet/isolated-vm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Secure &amp; isolated JS environments for nodejs&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/isolated-vm&#34;&gt;&lt;img src=&#34;https://badgen.now.sh/npm/v/isolated-vm&#34; alt=&#34;npm version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/laverdet/isolated-vm/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://badgen.now.sh/npm/license/isolated-vm&#34; alt=&#34;isc license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/laverdet/isolated-vm/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/laverdet/isolated-vm/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;github action&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.npmjs.com/package/isolated-vm&#34;&gt;&lt;img src=&#34;https://badgen.now.sh/npm/dm/isolated-vm&#34; alt=&#34;npm downloads&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;isolated-vm -- Access to multiple isolates in nodejs&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/isolated-vm&#34;&gt;&lt;img src=&#34;https://nodei.co/npm/isolated-vm.png&#34; alt=&#34;NPM&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;isolated-vm&lt;/code&gt; is a library for nodejs which gives you access to v8&#39;s &lt;code&gt;Isolate&lt;/code&gt; interface. This allows you to create JavaScript environments which are completely &lt;em&gt;isolated&lt;/em&gt; from each other. This can be a powerful tool to run code in a fresh JavaScript environment completely free of extraneous capabilities provided by the nodejs runtime.&lt;/p&gt; &#xA;&lt;h2&gt;PROJECT STATUS&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;isolated-vm&lt;/code&gt; is currently in &lt;em&gt;maintenance mode&lt;/em&gt;. New features are not actively being added but existing features and new versions of nodejs are supported as possible. There are some major architectural changes which need to be added to improve the stability and security of the project. I don&#39;t have as much spare time as I did when I started this project, so there is not currently any plan for these improvements.&lt;/p&gt; &#xA;&lt;h4&gt;Wishlist&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Multi-process architecture. v8 is &lt;em&gt;not&lt;/em&gt; resilient to out of memory conditions and is unable to gracefully unwind from these errors. Therefore it is possible, and even common, to crash a process with poorly-written or hostile software. I implemented a band-aid for this with the &lt;code&gt;onCatastrophicError&lt;/code&gt; callback which quarantines a corrupted isolate, but it is not reliable.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Bundled v8 version. nodejs uses a patched version of v8 which makes development of this module more difficult than it needs to be. For some reason they&#39;re also allowed to change the v8 ABI in semver minor releases as well, which causes issues for users while upgrading nodejs. Also, some Linux distributions strip &#34;internal&#34; symbols from their nodejs binaries which makes usage of this module impossible. I think the way to go is to compile and link against our own version of v8.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;CONTENTS&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#requirements&#34;&gt;Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#who-is-using-isolated-vm&#34;&gt;Who Is Using isolated-vm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#security&#34;&gt;Security&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#api-documentation&#34;&gt;API Documentation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-isolate-transferable&#34;&gt;Isolate&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-context-transferable&#34;&gt;Context&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-script-transferable&#34;&gt;Script&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-module-transferable&#34;&gt;Module&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-callback-transferable&#34;&gt;Callback&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;Reference&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-externalcopy-transferable&#34;&gt;ExternalCopy&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#alternatives&#34;&gt;Alternatives&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;REQUIREMENTS&lt;/h2&gt; &#xA;&lt;p&gt;This project requires nodejs version 16.x (or later).&lt;/p&gt; &#xA;&lt;p&gt;ðŸš¨ If you are using a version of nodejs 20.x or later, you must pass &lt;code&gt;--no-node-snapshot&lt;/code&gt; to &lt;code&gt;node&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Furthermore, to install this module you will need a compiler installed. If you run into errors while running &lt;code&gt;npm install isolated-vm&lt;/code&gt; it is likely you don&#39;t have a compiler set up, or your compiler is too old.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows + OS X users should follow the instructions here: &lt;a href=&#34;https://github.com/nodejs/node-gyp&#34;&gt;node-gyp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu users should run: &lt;code&gt;sudo apt-get install python g++ build-essential&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Alpine users should run: &lt;code&gt;sudo apk add python3 make g++&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Amazon Linux AMI users should run: &lt;code&gt;sudo yum install gcc72 gcc72-c++&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Arch Linux users should run: &lt;code&gt;sudo pacman -S make gcc python&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;WHO IS USING ISOLATED-VM&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://screeps.com/&#34;&gt;Screeps&lt;/a&gt; - Screeps is an online JavaScript-based MMO+RPG game. They are using isolated-vm to run arbitrary player-supplied code in secure environments which can persistent for several days at a time.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://fly.io/&#34;&gt;Fly&lt;/a&gt; - Fly is a programmable CDN which hosts dynamic endpoints as opposed to just static resources. They are using isolated-vm to run globally distributed applications, where each application may have wildly different traffic patterns.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.algolia.com&#34;&gt;Algolia&lt;/a&gt; - Algolia is a Search as a Service provider. They use &lt;code&gt;isolated-vm&lt;/code&gt; to power their &lt;a href=&#34;https://www.algolia.com/products/crawler/&#34;&gt;Custom Crawler&lt;/a&gt; product, which allows them to safely execute user-provided code for content extraction.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.tripadvisor.com&#34;&gt;Tripadvisor&lt;/a&gt; - Tripadvisor is the worldâ€™s largest travel platform. They use &lt;code&gt;isolated-vm&lt;/code&gt; to server-side render thousands of React pages per second.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;SECURITY&lt;/h2&gt; &#xA;&lt;p&gt;Running untrusted code is an extraordinarily difficult problem which must be approached with great care. Use of &lt;code&gt;isolated-vm&lt;/code&gt; to run untrusted code does not automatically make your application safe. Through carelessness or misuse of the library it can be possible to leak sensitive data or grant undesired privileges to an isolate.&lt;/p&gt; &#xA;&lt;p&gt;At a minimum you should take care not to leak any instances of &lt;code&gt;isolated-vm&lt;/code&gt; objects (&lt;code&gt;Reference&lt;/code&gt;, &lt;code&gt;ExternalCopy&lt;/code&gt;, etc) to untrusted code. It is usually trivial for an attacker to use these instances as a springboard back into the nodejs isolate which will yield complete control over a process.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, it is wise to keep nodejs up to date through point releases which affect v8. You can find these on the &lt;a href=&#34;https://github.com/nodejs/node/raw/master/CHANGELOG.md&#34;&gt;nodejs changelog&lt;/a&gt; by looking for entries such as &#34;update V8 to 9.1.269.36 (MichaÃ«l Zasso) #38273&#34;. Historically there have usually been 3-5 of these updates within a single nodejs LTS release cycle. It is &lt;em&gt;not&lt;/em&gt; recommended to use odd-numbered nodejs releases since these frequently break ABI and API compatibility and isolated-vm doesn&#39;t aim to be compatible with bleeding edge v8.&lt;/p&gt; &#xA;&lt;p&gt;Against potentially hostile code you should also consider turning on &lt;a href=&#34;https://v8.dev/docs/untrusted-code-mitigations&#34;&gt;v8 untrusted code mitigations&lt;/a&gt;, which helps address the class of speculative execution attacks known as Spectre and Meltdown. You can enable this feature by running &lt;code&gt;node&lt;/code&gt; with the &lt;code&gt;--untrusted-code-mitigations&lt;/code&gt; flag. This feature comes with a slight performance cost and must be enabled per-process, therefore nodejs disables it by default.&lt;/p&gt; &#xA;&lt;p&gt;v8 is a relatively robust runtime, but there are always new and exciting ways to crash, hang, exploit, or otherwise disrupt a process with plain old JavaScript. Your application must be resilient to these kinds of issues and attacks. It&#39;s a good idea to keep instances of &lt;code&gt;isolated-vm&lt;/code&gt; in a different nodejs process than other critical infrastructure.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;a href=&#34;https://en.wikipedia.org/wiki/Advanced_persistent_threat&#34;&gt;advanced persistent threats&lt;/a&gt; are within your threat model it&#39;s a very good idea to architect your application using a foundation similar to Chromium&#39;s &lt;a href=&#34;https://www.chromium.org/Home/chromium-security/site-isolation&#34;&gt;site isolation&lt;/a&gt;. You&#39;ll also need to make sure to keep your system kernel up to date against &lt;a href=&#34;https://en.wikipedia.org/wiki/Privilege_escalation&#34;&gt;local privilege escalation&lt;/a&gt; attacks. Running your service in a container such as a Docker may be a good idea but it is important to research container escape attacks as well.&lt;/p&gt; &#xA;&lt;h2&gt;API DOCUMENTATION&lt;/h2&gt; &#xA;&lt;p&gt;Since isolates share no resources with each other, most of this API is built to provide primitives which make marshalling data between many isolates quick and easy. The only way to pass data from one isolate to another is to first make that data &lt;em&gt;transferable&lt;/em&gt;. Primitives (except for &lt;code&gt;Symbol&lt;/code&gt;) are always transferable. This means if you invoke a function in a different isolate with a number or string as the argument, it will work fine. If you need to pass more complex information you will have to first make the data transferable with one of the methods here.&lt;/p&gt; &#xA;&lt;p&gt;Most methods will provide both a synchronous and an asynchronous version. Calling the synchronous functions will block your thread while the method runs and eventually returns a value. The asynchronous functions will return a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt; while the work runs in a separate thread pool.&lt;/p&gt; &#xA;&lt;p&gt;There are some rules about which functions may be called from certain contexts:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Asynchronous functions may be called at any time&lt;/li&gt; &#xA; &lt;li&gt;Synchronous functions usually may not be called from an asynchronous function&lt;/li&gt; &#xA; &lt;li&gt;You may call a synchronous function from an asynchronous function as long as that function belongs to current isolate&lt;/li&gt; &#xA; &lt;li&gt;You may call a synchronous function belonging to the default nodejs isolate at any time&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Additionally, some methods will provide an &#34;ignored&#34; version which runs asynchronously but returns no promise. This can be a good option when the calling isolate would ignore the promise anyway, since the ignored versions can skip an extra thread synchronization. Just be careful because this swallows any thrown exceptions which might make problems hard to track down.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s also worth noting that all asynchronous invocations will run in the order they were queued, regardless of whether or not you wait on them. So, for instance, you could call several &#34;ignored&#34; methods in a row and then &lt;code&gt;await&lt;/code&gt; on a final async method to observe some side-effect of the ignored methods.&lt;/p&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;Isolate&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This is the main reference to an isolate. Every handle to an isolate is transferable, which means you can give isolates references to each other. An isolate will remain valid as long as someone holds a handle to the isolate or anything created inside that isolate. Once an isolate is lost the garbage collector should eventually find it and clean up its memory. Since an isolate and all it contains can represent quite a large chunk of memory though you may want to explicitly call the &lt;code&gt;dispose()&lt;/code&gt; method on isolates that you are finished with to get that memory back immediately.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;new ivm.Isolate(options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;memoryLimit&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Memory limit that this isolate may use, in MB. Note that this is more of a guideline instead of a strict limit. A determined attacker could use 2-3 times this limit before their script is terminated. Against non-hostile code this limit should be pretty close. The default is 128MB and the minimum is 8MB.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;inspector&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Enable v8 inspector support in this isolate. See &lt;code&gt;inspector-example.js&lt;/code&gt; in this repository for an example of how to use this.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;snapshot&lt;/code&gt; &lt;em&gt;[ExternalCopy[ArrayBuffer]]&lt;/em&gt; - This is an optional snapshot created from &lt;code&gt;createSnapshot&lt;/code&gt; which will be used to initialize the heap of this isolate.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;onCatastrophicError&lt;/code&gt; &lt;em&gt;[function]&lt;/em&gt; - Callback to be invoked when a &lt;em&gt;very bad&lt;/em&gt; error occurs. If this is invoked it means that v8 has lost all control over the isolate, and all resources in use are totally unrecoverable. If you receive this error you should log the error, stop serving requests, finish outstanding work, and end the process by calling &lt;code&gt;process.abort()&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;&lt;code&gt;ivm.Isolate.createSnapshot(scripts, warmup_script)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;scripts&lt;/code&gt; &lt;em&gt;[array]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;code&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - Source code to set up this snapshot&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#scriptorigin&#34;&gt;&lt;code&gt;{ ...ScriptOrigin }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;warmup_script&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - Optional script to &#34;warmup&#34; the snapshot by triggering code compilation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;ðŸš¨ You should not use this feature. It was never all that stable to begin with and has grown increasingly unstable due to changes in v8.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;createSnapshot&lt;/code&gt; does not provide the same isolate protection like the rest of isolated-vm. If the script passed to &lt;code&gt;createSnapshot&lt;/code&gt; uses too much memory the process will crash, and if it has an infinite loop it will stall the process. Furthermore newer v8 features may simply fail when attempting to take a snapshot that uses them. It is best to snapshot code that only defines functions, class, and simple data structures.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.compileScript(code)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.compileScriptSync(code)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;code&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - The JavaScript code to compile.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#cacheddataoptions&#34;&gt;&lt;code&gt;{ ...CachedDataOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#scriptorigin&#34;&gt;&lt;code&gt;{ ...ScriptOrigin }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;return&lt;/strong&gt; A &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-script-transferable&#34;&gt;&lt;code&gt;Script&lt;/code&gt;&lt;/a&gt; object.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that a &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-script-transferable&#34;&gt;&lt;code&gt;Script&lt;/code&gt;&lt;/a&gt; can only run in the isolate which created it.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.compileModule(code)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.compileModuleSync(code)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;code&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - The JavaScript code to compile.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;meta&lt;/code&gt; &lt;em&gt;[function]&lt;/em&gt; - Callback which will be invoked the first time this module accesses &lt;code&gt;import.meta&lt;/code&gt;. The &lt;code&gt;meta&lt;/code&gt; object will be passed as the first argument. This option may only be used when invoking &lt;code&gt;compileModule&lt;/code&gt; from within the same isolate. &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#cacheddataoptions&#34;&gt;&lt;code&gt;{ ...CachedDataOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#scriptorigin&#34;&gt;&lt;code&gt;{ ...ScriptOrigin }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;return&lt;/strong&gt; A &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-module-transferable&#34;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; object.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that a &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-module-transferable&#34;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; can only run in the isolate which created it.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.createContext()&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.createContextSync()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;inspector&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Enable the v8 inspector for this context. The inspector must have been enabled for the isolate as well.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;return&lt;/strong&gt; A &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-context-transferable&#34;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; object.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.dispose()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Destroys this isolate and invalidates all references obtained from it.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.getHeapStatistics()&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.getHeapStatisticsSync()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; [object]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Returns heap statistics from v8. The return value is almost identical to the nodejs function &lt;a href=&#34;https://nodejs.org/dist/latest-v8.x/docs/api/v8.html#v8_v8_getheapstatistics&#34;&gt;v8.getHeapStatistics()&lt;/a&gt;. This function returns one additional property: &lt;code&gt;externally_allocated_size&lt;/code&gt; which is the total amount of currently allocated memory which is not included in the v8 heap but counts against this isolate&#39;s &lt;code&gt;memoryLimit&lt;/code&gt;. ArrayBuffer instances over a certain size are externally allocated and will be counted here.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.cpuTime&lt;/code&gt; &lt;em&gt;bigint&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.wallTime&lt;/code&gt; &lt;em&gt;bigint&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;The total CPU and wall time spent in this isolate, in nanoseconds. CPU time is the amount of time the isolate has spent actively doing work on the CPU. Wall time is the amount of time the isolate has been running, including passive time spent waiting (think &#34;wall&#34; like a clock on the wall). For instance, if an isolate makes a call into another isolate, wall time will continue increasing while CPU time will remain the same.&lt;/p&gt; &#xA;&lt;p&gt;Note that in nodejs v10.x the return value is a regular number, since bigint isn&#39;t supported on earlier versions.&lt;/p&gt; &#xA;&lt;p&gt;Also note that CPU time may vary drastically if there is contention for the CPU. This could occur if other processes are trying to do work, or if you have more than &lt;code&gt;require(&#39;os&#39;).cpus().length&lt;/code&gt; isolates currently doing work in the same nodejs process.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.isDisposed&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Flag that indicates whether this isolate has been disposed.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.referenceCount&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Returns the total count of active &lt;code&gt;Reference&lt;/code&gt; instances that belong to this isolate. Note that in certain cases many &lt;code&gt;Reference&lt;/code&gt; instances in JavaScript will point to the same underlying reference handle, in which case this number will only reflect the underlying reference handle. This happens when you transfer a &lt;code&gt;Reference&lt;/code&gt; instance via some method which accepts transferable values. This will also include underlying reference handles created by isolated-vm like &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Context&lt;/code&gt; objects.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.startCpuProfiler(title)&lt;/code&gt; &lt;em&gt;[void]&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Start a CPU profiler in the isolate, for performance profiling. It only collects cpu profiles when the isolate is active in a thread.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;isolate.stopCpuProfiler(title)&lt;/code&gt; &lt;em&gt;[Promise&amp;lt;Array&#xA;  &lt;threadcpuprofile&gt;&#xA;   &amp;gt;]&#xA;  &lt;/threadcpuprofile&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Stop a CPU profiler previously started using the same title. It returns an array of profiles dependening on how many times the isolate get activated in a thread.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; An array of &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#thread-cpu-profile&#34;&gt;&lt;code&gt;ThreadCpuProfile&lt;/code&gt;&lt;/a&gt; objects.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;Context&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A context is a sandboxed execution environment within an isolate. Each context contains its own built-in objects and global space.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.global&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt; to this context&#39;s global object. Note that if you call &lt;code&gt;context.release()&lt;/code&gt; the global reference will be released as well.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.eval(code, options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.evalIgnored(code, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.evalSync(code, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;code&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - The code to run&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Maximum amount of time in milliseconds this script is allowed to run before execution is canceled. Default is no timeout.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#scriptorigin&#34;&gt;&lt;code&gt;{ ...ScriptOrigin }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compiles and executes a script within a context. This will return the last value evaluated, as long as that value was transferable, otherwise &lt;code&gt;undefined&lt;/code&gt; will be returned.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.evalClosure(code, arguments, options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.evalClosureIgnored(code, arguments, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.evalClosureSync(code, arguments, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;code&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - The code to run&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;arguments&lt;/code&gt; *[array]` - Arguments to pass to this code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Maximum amount of time in milliseconds this script is allowed to run before execution is canceled. Default is no timeout.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#scriptorigin&#34;&gt;&lt;code&gt;{ ...ScriptOrigin }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arguments&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;result&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; `&lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compiles and runs code as if it were inside a function, similar to the seldom-used &lt;code&gt;new Function(code)&lt;/code&gt; constructor. You can pass arguments to the function and they will be available as &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, and so on. You can also use &lt;code&gt;return&lt;/code&gt; from the code.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;context.release()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Releases this reference to the context. You can call this to free up v8 resources immediately, or you can let the garbage collector handle it when it feels like it. Note that if there are other references to this context it will not be disposed. This only affects this reference to the context.&lt;/p&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;Script&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A script is a compiled chunk of JavaScript which can be executed in any context within a single isolate.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;script.release()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Releases the reference to this script, allowing the script data to be garbage collected. Functions and data created in the isolate by previous invocations to &lt;code&gt;script.run(...)&lt;/code&gt; will still be alive in their respective contexts-- this only means that you can&#39;t invoke &lt;code&gt;script.run(...)&lt;/code&gt; again with this reference.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;script.run(context, options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;script.runIgnored(context, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;script.runSync(context, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;context&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-context-transferable&#34;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;&lt;/em&gt; - The context in which this script will run.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;release&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true &lt;code&gt;release()&lt;/code&gt; will automatically be called on this instance.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Maximum amount of time in milliseconds this script is allowed to run before execution is canceled. Default is no timeout.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Runs a given script within a context. This will return the last value evaluated in a given script, as long as that value was transferable, otherwise &lt;code&gt;undefined&lt;/code&gt; will be returned. For instance if your script was &#34;let foo = 1; let bar = 2; bar = foo + bar&#34; then the return value will be 3 because that is the last expression.&lt;/p&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;Module&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A JavaScript module. Note that a &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-module-transferable&#34;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; can only run in the isolate which created it.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.dependencySpecifiers&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;A read-only array of all dependency specifiers the module has.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#x9;const code = `import something from &#39;./something&#39;;`;&#xA;&#x9;const module = await isolate.compileModule(code);&#xA;&#x9;const dependencySpecifiers = module.dependencySpecifiers;&#xA;&#x9;// dependencySpecifiers =&amp;gt; [&#34;./something&#34;];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.namespace&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Returns a &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt; containing all exported values.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.instantiate(context, resolveCallback)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.instantiateSync(context, resolveCallback)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;context&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-context-transferable&#34;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;&lt;/em&gt; - The context the module should use.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;resolveCallback&lt;/code&gt; - This callback is responsible for resolving all direct and indirect dependencies of this module. It accepts two parameters: &lt;code&gt;specifier&lt;/code&gt; and &lt;code&gt;referrer&lt;/code&gt;. It must return a &lt;code&gt;Module&lt;/code&gt; instance which will be used to satisfy the dependency. The asynchronous version of &lt;code&gt;instantiate&lt;/code&gt; may return a promise from &lt;code&gt;resolveCallback&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Instantiate the module together with all its dependencies. Calling this more than once on a single module will have no effect.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.evaluate(options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.evaluateSync(options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; - Optional. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Maximum amount of time in milliseconds this module is allowed to run before execution is canceled. Default is no timeout.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Evaluate the module and return the last expression (same as script.run). If &lt;code&gt;evaluate&lt;/code&gt; is called more than once on the same module the return value from the first invocation will be returned (or thrown).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; nodejs v14.8.0 enabled top-level await by default which has the effect of breaking the return value of this function.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;module.release()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Releases this module. This behaves the same as other &lt;code&gt;.release()&lt;/code&gt; methods.&lt;/p&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;Callback&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Callbacks can be used to create cross-isolate references to simple functions. This can be easier and safer than dealing with the more flexible &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt; class. Arguments passed to and returned from callbacks are always copied using the same method as &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-externalcopy-transferable&#34;&gt;&lt;code&gt;ExternalCopy&lt;/code&gt;&lt;/a&gt;. When transferred to another isolate, instances of &lt;code&gt;Callback&lt;/code&gt; will turn into a plain old function. Callbacks are created automatically when passing functions to most isolated-vm functions.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;new ivm.Callback(fn, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;async&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Function will invoke the callback in &#34;async&#34; mode, which immediately returns a promise.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;ignored&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Function will invoke the callback in &#34;ignored&#34; mode, which immediately returns &lt;code&gt;undefined&lt;/code&gt; and ignores the result of the function (including thrown exceptions)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sync&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Function will invoke the callback in &#34;sync&#34; mode, blocking for a response (default).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;Reference&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;A instance of &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt; is a pointer to a value stored in any isolate.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;new ivm.Reference(value, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value&lt;/code&gt; - The value to create a reference to.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;unsafeInherit&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If enabled then the &lt;code&gt;get&lt;/code&gt; family of functions will follow the object&#39;s prototype chain. References created with this option should never be given to untrusted code.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.typeof&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;This is the typeof the referenced value, and is available at any time from any isolate. Note that this differs from the real &lt;code&gt;typeof&lt;/code&gt; operator in that &lt;code&gt;null&lt;/code&gt; is &#34;null&#34;, and Symbols are &#34;object&#34;.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.copy()&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.copySync()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; JavaScript value of the reference.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Creates a copy of the referenced value and internalizes it into this isolate. This uses the same copy rules as &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-externalcopy-transferable&#34;&gt;&lt;code&gt;ExternalCopy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.deref()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;release&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true &lt;code&gt;release()&lt;/code&gt; will automatically be called on this instance.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; The value referenced by this handle.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Will attempt to return the actual value or object pointed to by this reference. Note that in order to call this function the reference must be owned by the current isolate, otherwise an error will be thrown.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.derefInto()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;release&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true &lt;code&gt;release()&lt;/code&gt; will automatically be called on this instance.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Returns an object, which when passed to another isolate will cause that isolate to dereference the handle.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.release()&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;Releases this reference. If you&#39;re passing around a lot of references between isolates it&#39;s wise to release the references when you are done. Otherwise you may run into issues with isolates running out of memory because other isolates haven&#39;t garbage collected recently. After calling this method all attempts to access the reference will throw an error.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.delete(property)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.deleteIgnored(property)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.deleteSync(property)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;property&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt; - The property to access on this object.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Delete a property from this reference, as if using &lt;code&gt;delete reference[property]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.get(property, options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.getSync(property, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;property&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt; - The property to access on this object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;accessors&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Whether or not to invoke accessors and proxies on the underlying object. Note that there is no way to supply a timeout to this function so only use this option in trusted code.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; A &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt; object.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Will access a reference as if using &lt;code&gt;reference[property]&lt;/code&gt; and transfer the value out.&lt;/p&gt; &#xA;&lt;p&gt;If the object is a proxy, or if the property is a getter, this method will throw unless the &lt;code&gt;accessors&lt;/code&gt; option is true.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.set(property, value, options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.setIgnored(property, value, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.setSync(property, value, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;property&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt; - The property to set on this object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;value&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt; - The value to set on this object.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.apply(receiver, arguments, options)&lt;/code&gt; &lt;em&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.applyIgnored(receiver, arguments, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.applySync(receiver, arguments, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;h5&gt;&lt;code&gt;reference.applySyncPromise(receiver, arguments, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;receiver&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt; - The value which will be &lt;code&gt;this&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;arguments&lt;/code&gt; &lt;em&gt;[array]&lt;/em&gt; - Array of transferables which will be passed to the function.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Maximum amount of time in milliseconds this function is allowed to run before execution is canceled. Default is no timeout.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;arguments&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;result&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#transferoptions&#34;&gt;&lt;code&gt;{ ...TransferOptions }&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Will attempt to invoke an object as if it were a function. If the return value is transferable it will be returned to the caller of &lt;code&gt;apply&lt;/code&gt;, otherwise it will return an instance of &lt;code&gt;Reference&lt;/code&gt;. This behavior can be changed with the &lt;code&gt;result&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;applySyncPromise&lt;/code&gt; is a special version of &lt;code&gt;applySync&lt;/code&gt; which may only be invoked on functions belonging to the default isolate AND may only be invoked from a non-default thread. Functions invoked in this way may return a promise and the invoking isolate will wait for that promise to resolve before resuming execution. You can use this to implement functions like &lt;code&gt;readFileSync&lt;/code&gt; in a way that doesn&#39;t block the default isolate. Note that the invoking isolate will not respond to any async functions until this promise is resolved, however synchronous functions will still function correctly. Misuse of this feature may result in deadlocked isolates, though the default isolate will never be at risk of a deadlock.&lt;/p&gt; &#xA;&lt;h3&gt;Class: &lt;code&gt;ExternalCopy&lt;/code&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Instances of this class represent some value that is stored outside of any v8 isolate. This value can then be quickly copied into any isolate without any extra thread synchronization.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;new ivm.ExternalCopy(value, options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;value&lt;/code&gt; - The value to copy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;transferList&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - An array of &lt;code&gt;ArrayBuffer&lt;/code&gt; instances to transfer ownership. This behaves in a similar way to &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage&#34;&gt;&lt;code&gt;postMessage&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;transferOut&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true this will release ownership of the given resource from this isolate. This operation completes in constant time since it doesn&#39;t have to copy an arbitrarily large object. This only applies to ArrayBuffer and TypedArray instances.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Primitive values can be copied exactly as they are. Date objects will be copied as as Dates. ArrayBuffers, TypedArrays, and DataViews will be copied in an efficient format. SharedArrayBuffers will simply copy a reference to the existing memory and when copied into another isolate the new SharedArrayBuffer will point to the same underlying data. After passing a SharedArrayBuffer to ExternalCopy for the first time isolated-vm will take over management of the underlying memory block, so a &#34;copied&#34; SharedArrayBuffer can outlive the isolate that created the memory originally.&lt;/p&gt; &#xA;&lt;p&gt;All other objects will be copied in seralized form using the &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm&#34;&gt;structured clone algorithm&lt;/a&gt;. &lt;code&gt;ExternalCopy&lt;/code&gt; can copy objects with deeply nested &lt;em&gt;transferable&lt;/em&gt; objects. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let isolate = new ivm.Isolate;&#xA;let context = isolate.createContextSync();&#xA;let global = context.global;&#xA;let data = new ExternalCopy({ isolate, context, global });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;&lt;code&gt;ExternalCopy.totalExternalSize&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt;&lt;/h5&gt; &#xA;&lt;p&gt;This is a static property which will return the total number of bytes that isolated-vm has allocated outside of v8 due to instances of &lt;code&gt;ExternalCopy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;externalCopy.copy(options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;release&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true &lt;code&gt;release()&lt;/code&gt; will automatically be called on this instance.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;transferIn&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true this will transfer the resource directly into this isolate, invalidating the ExternalCopy handle.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; - JavaScript value of the external copy.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Internalizes the ExternalCopy data into this isolate.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;externalCopy.copyInto(options)&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;options&lt;/code&gt; &lt;em&gt;[object]&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;release&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true &lt;code&gt;release()&lt;/code&gt; will automatically be called on this instance.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;transferIn&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - If true this will transfer the resource directly into this isolate, invalidating the ExternalCopy handle.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;return&lt;/strong&gt; &lt;em&gt;[transferable]&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Returns an object, which when passed to another isolate will cause that isolate to internalize a copy of this value.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;externalCopy.release()&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Releases the reference to this copy. If there are other references to this copy elsewhere the copy will still remain in memory, but this handle will no longer be active. Disposing ExternalCopy instances isn&#39;t super important, v8 is a lot better at cleaning these up automatically because there&#39;s no inter-isolate dependencies.&lt;/p&gt; &#xA;&lt;h3&gt;Shared Options&lt;/h3&gt; &#xA;&lt;p&gt;Many methods in this library accept common options between them. They are documented here instead of being colocated with each instance.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;CachedDataOptions&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cachedData&lt;/code&gt; &lt;em&gt;[ExternalCopy[ArrayBuffer]]&lt;/em&gt; - This will consume cached compilation data from a previous call to this function. &lt;code&gt;cachedDataRejected&lt;/code&gt; will be set to &lt;code&gt;true&lt;/code&gt; if the supplied data was rejected by V8.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;produceCachedData&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Produce V8 cache data. Similar to the &lt;a href=&#34;https://nodejs.org/api/vm.html&#34;&gt;VM.Script&lt;/a&gt; option of the same name. If this is true then the returned object will have &lt;code&gt;cachedData&lt;/code&gt; set to an ExternalCopy handle. Note that this differs from the VM.Script option slightly in that &lt;code&gt;cachedDataProduced&lt;/code&gt; is never set.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most functions which compile or run code can produce and consume cached data. You can produce cached data and use the data in later invocations to drastically speed up parsing of the same script. You can even save this data to disk and use it in a different process. You can set both &lt;code&gt;cachedData&lt;/code&gt; and &lt;code&gt;produceCachedData&lt;/code&gt;, in which case new cached data will only be produced if the data supplied was invalid.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: CachedData contains compiled machine code. That means you should not accept &lt;code&gt;cachedData&lt;/code&gt; payloads from a user, otherwise they may be able to run arbitrary code.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;ScriptOrigin&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;filename&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - Filename of this source code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;columnOffset&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Column offset of this source code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lineOffset&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - Line offset of this source code&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You may optionally specify information on compiled code&#39;s filename. This is used in various debugging contexts within v8, including stack traces and the inspector. It is recommended to use a valid URI scheme, for example: &lt;code&gt;{ filename: &#39;file:///test.js&#39; }&lt;/code&gt;, otherwise some devtools may malfunction.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;TransferOptions&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;copy&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Automatically deep copy value&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;externalCopy&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Automatically wrap value in &lt;code&gt;ExternalCopy&lt;/code&gt; instance&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;reference&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Automatically wrap value in &lt;code&gt;Reference&lt;/code&gt; instance&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;promise&lt;/code&gt; &lt;em&gt;[boolean]&lt;/em&gt; - Automatically proxy any returned promises between isolates. This can be used in combination with the other transfer options.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Any function which moves data between isolates will accept these transfer options. By default only &lt;em&gt;[transferable]&lt;/em&gt; values may pass between isolates. Without specifying one of these options the function may ignore the value, throw, or wrap it in a reference depending on the context.&lt;/p&gt; &#xA;&lt;p&gt;More advanced situations like transferring ownership of &lt;code&gt;ArrayBuffer&lt;/code&gt; instances will require direct use of &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-externalcopy-transferable&#34;&gt;&lt;code&gt;ExternalCopy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#class-reference-transferable&#34;&gt;&lt;code&gt;Reference&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;ThreadCpuProfile&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;It&#39;s a object that contains a thread id and a &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#cpuprofile&#34;&gt;CpuProfile&lt;/a&gt; info.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;threadId&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - The thread that isolate runs on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;profile&lt;/code&gt; &lt;em&gt;[CpuProfile]&lt;/em&gt; - The &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#cpuprofile&#34;&gt;CpuProfile&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;&lt;code&gt;CpuProfile&lt;/code&gt;&lt;/h5&gt; &#xA;&lt;p&gt;The CpuProfile Object that can be &lt;code&gt;JSON.stringify(cpuProfile)&lt;/code&gt;, and save to any external file system for later reloaded into chrome dev tool or any other js performance tool to review.&lt;/p&gt; &#xA;&lt;p&gt;The format should matches the definition in: &lt;a href=&#34;https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile&#34;&gt;https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#type-Profile&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;startTime&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - The start timestamp when calling &lt;code&gt;.startProfiling&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;endTime&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt; - The end timestamp when calling &lt;code&gt;.stopProfiling&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;samples&lt;/code&gt; &lt;em&gt;[Array&#xA;   &lt;number&gt;&#xA;    ]&#xA;   &lt;/number&gt;&lt;/em&gt; - All sample node id has been collected.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;timeDeltas&lt;/code&gt; &lt;em&gt;[Array&#xA;   &lt;number&gt;&#xA;    ]&#xA;   &lt;/number&gt;&lt;/em&gt; - All the time deltas related to the &lt;code&gt;samples&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nodes&lt;/code&gt; &lt;em&gt;[Array&#xA;   &lt;node&gt;&#xA;    ]&#xA;   &lt;/node&gt;&lt;/em&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;hitCount&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;id&lt;/code&gt; &lt;em&gt;[id]&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;children&lt;/code&gt; &lt;em&gt;[Array&#xA;     &lt;number&gt;&#xA;      ]&#xA;     &lt;/number&gt;&lt;/em&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;callFrame&lt;/code&gt; &lt;em&gt;[CallFrame]&lt;/em&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;functionName&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;url&lt;/code&gt; &lt;em&gt;[string]&lt;/em&gt; - The &lt;code&gt;filename&lt;/code&gt; used in &lt;a href=&#34;https://raw.githubusercontent.com/laverdet/isolated-vm/main/#scriptorigin&#34;&gt;&lt;code&gt;ScriptOrigin&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;scriptId&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;lineNumber&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;columnNumber&lt;/code&gt; &lt;em&gt;[number]&lt;/em&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;bailoutReason&lt;/code&gt; &lt;em&gt;[string?]&lt;/em&gt; - When the JavaScript function bailed out from v8 optimization, this field will present.&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;EXAMPLES&lt;/h2&gt; &#xA;&lt;p&gt;Below is a sample program which shows basic usage of the library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Create a new isolate limited to 128MB&#xA;const ivm = require(&#39;isolated-vm&#39;);&#xA;const isolate = new ivm.Isolate({ memoryLimit: 128 });&#xA;&#xA;// Create a new context within this isolate. Each context has its own copy of all the builtin&#xA;// Objects. So for instance if one context does Object.prototype.foo = 1 this would not affect any&#xA;// other contexts.&#xA;const context = isolate.createContextSync();&#xA;&#xA;// Get a Reference{} to the global object within the context.&#xA;const jail = context.global;&#xA;&#xA;// This makes the global object available in the context as `global`. We use `derefInto()` here&#xA;// because otherwise `global` would actually be a Reference{} object in the new isolate.&#xA;jail.setSync(&#39;global&#39;, jail.derefInto());&#xA;&#xA;// We will create a basic `log` function for the new isolate to use.&#xA;jail.setSync(&#39;log&#39;, function(...args) {&#xA;&#x9;console.log(...args);&#xA;});&#xA;&#xA;// And let&#39;s test it out:&#xA;context.evalSync(&#39;log(&#34;hello world&#34;)&#39;);&#xA;// &amp;gt; hello world&#xA;&#xA;// Let&#39;s see what happens when we try to blow the isolate&#39;s memory&#xA;const hostile = isolate.compileScriptSync(`&#xA;&#x9;const storage = [];&#xA;&#x9;const twoMegabytes = 1024 * 1024 * 2;&#xA;&#x9;while (true) {&#xA;&#x9;&#x9;const array = new Uint8Array(twoMegabytes);&#xA;&#x9;&#x9;for (let ii = 0; ii &amp;lt; twoMegabytes; ii += 4096) {&#xA;&#x9;&#x9;&#x9;array[ii] = 1; // we have to put something in the array to flush to real memory&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;storage.push(array);&#xA;&#x9;&#x9;log(&#39;I\\&#39;ve wasted &#39;+ (storage.length * 2)+ &#39;MB&#39;);&#xA;&#x9;}&#xA;`);&#xA;&#xA;// Using the async version of `run` so that calls to `log` will get to the main node isolate&#xA;hostile.run(context).catch(err =&amp;gt; console.error(err));&#xA;// I&#39;ve wasted 2MB&#xA;// I&#39;ve wasted 4MB&#xA;// ...&#xA;// I&#39;ve wasted 130MB&#xA;// I&#39;ve wasted 132MB&#xA;// RangeError: Array buffer allocation failed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;ALTERNATIVES&lt;/h2&gt; &#xA;&lt;p&gt;Below is a quick summary of some other options available on nodejs and how they differ from isolated-vm. The table headers are defined as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Secure&lt;/strong&gt;: Obstructs access to unsafe nodejs capabilities&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Memory Limits&lt;/strong&gt;: Possible to set memory limits / safe against heap overflow DoS attacks&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Isolated&lt;/strong&gt;: Is garbage collection, heap, etc isolated from application&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multithreaded&lt;/strong&gt;: Run code on many threads from a single process&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Module Support&lt;/strong&gt;: Is &lt;code&gt;require&lt;/code&gt; supported out of the box&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Inspector Support&lt;/strong&gt;: Chrome DevTools supported&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Module&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Secure&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Memory Limits&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Isolated&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Multithreaded&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Module Support&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Inspector Support&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://nodejs.org/api/vm.html&#34;&gt;vm&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://nodejs.org/api/worker_threads.html&#34;&gt;worker_threads&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/patriksimek/vm2&#34;&gt;vm2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/avoidwork/tiny-worker&#34;&gt;tiny-worker&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;isolated-vm&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;âœ…&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>