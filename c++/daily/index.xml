<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-31T01:29:34Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hedge-dev/XenonRecomp</title>
    <updated>2025-03-31T01:29:34Z</updated>
    <id>tag:github.com,2025-03-31:/hedge-dev/XenonRecomp</id>
    <link href="https://github.com/hedge-dev/XenonRecomp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tool for recompiling Xbox 360 games to native executables.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;XenonRecomp&lt;/h1&gt; &#xA;&lt;p&gt;XenonRecomp is a tool that converts Xbox 360 executables into C++ code, which can then be recompiled for any platform. Currently, it only supports x86 platforms due to the use of x86 intrinsics.&lt;/p&gt; &#xA;&lt;p&gt;This project was heavily inspired by &lt;a href=&#34;https://github.com/N64Recomp/N64Recomp&#34;&gt;N64: Recompiled&lt;/a&gt;, a similar tool for N64 executables.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Details&lt;/h2&gt; &#xA;&lt;h3&gt;Instructions&lt;/h3&gt; &#xA;&lt;p&gt;The instructions are directly converted without any effort to make them resemble decompiled code, meaning the output is not very human-readable. The CPU state is passed as an argument to every PPC function, which includes definitions for every PPC register and their current values at the time of execution. The second argument is the base address pointer, as the Xbox 360 CPU uses 32-bit pointers.&lt;/p&gt; &#xA;&lt;p&gt;A good amount of PPC instructions are implemented, with missing ones primarily being variants of already implemented instructions. Some instructions, like the D3D unpack/pack instructions, do not support all operand types. When a missing case is encountered, a warning is generated, or a debug break is inserted into the converted C++ code.&lt;/p&gt; &#xA;&lt;p&gt;The instruction implementations operate on little-endian values. However, since the Xbox 360 is a big-endian machine, the memory load instructions swap endianness when reading values, and memory store instructions reverse it to big-endian before writing. All the memory loads and stores are marked volatile to prevent Clang from doing unsafe code reordering.&lt;/p&gt; &#xA;&lt;p&gt;Vector registers&#39; endianness handling is more complicated. Instead of swapping individual 32-bit elements, the recompiler chooses to reverse the entire 16-byte vector. Instructions must account for this reversed order, such as using the WZY components instead of XYZ in dot products or requiring reversed arguments for vector pack instructions.&lt;/p&gt; &#xA;&lt;p&gt;The FPU expects denormalized numbers to remain unmodified, while VMX instructions always flush them. This is managed by storing the current floating-point state in the CPU state struct and enabling or disabling denormal flushing as necessary before executing each instruction.&lt;/p&gt; &#xA;&lt;p&gt;Most VMX instructions are implemented using x86 intrinsics. Luckily, the number of AVX intrinsics used is relatively low, so adding support for other architectures using libraries like &lt;a href=&#34;https://github.com/simd-everywhere/simde&#34;&gt;SIMD Everywhere&lt;/a&gt; might be possible.&lt;/p&gt; &#xA;&lt;h3&gt;MMIO&lt;/h3&gt; &#xA;&lt;p&gt;MMIO, which is typically used for hardware operations such as XMA decoding, is currently unimplemented. There is an unfinished attempt to implement MMIO, but supporting it may be non-trivial and could require advanced analysis of instructions.&lt;/p&gt; &#xA;&lt;h3&gt;Indirect Functions&lt;/h3&gt; &#xA;&lt;p&gt;Virtual function calls are resolved by creating a &#34;perfect hash table&#34; at runtime, where dereferencing a 64-bit pointer (using the original instruction address multiplied by 2) gives the address of the recompiled function. This was previously implemented by creating an 8 GB virtual allocation, but it had too much memory pressure. Now it relies on function addresses being placed after the valid XEX memory region in the base memory pointer. These regions are exported as macros in the output &lt;code&gt;ppc_config.h&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h3&gt;Jump Tables&lt;/h3&gt; &#xA;&lt;p&gt;Jump tables, at least in older Xbox 360 binaries, often have predictable assembly patterns, making them easy to detect statically without needing a virtual machine. XenonAnalyse has logic for detecting jump tables in Sonic Unleashed, though variations in other games (likely due to updates in the Xbox 360 compiler) may require modifications to the detection logic. Currently, there is no fully generic solution for handling jump tables, so updates to the detection logic may be needed for other games.&lt;/p&gt; &#xA;&lt;p&gt;The typical way to find jump tables is by searching for the &lt;code&gt;mtctr r0&lt;/code&gt; instruction. It will almost always be followed with a &lt;code&gt;bctr&lt;/code&gt;, with the previous instructions computing the jump address.&lt;/p&gt; &#xA;&lt;p&gt;XenonAnalyse generates a TOML file containing detected jump tables, which can be referenced in the main TOML config file. This allows the recompiler to generate real switch cases for these jump tables.&lt;/p&gt; &#xA;&lt;h3&gt;Function Boundary Analysis&lt;/h3&gt; &#xA;&lt;p&gt;XenonAnalyse includes a function boundary analyzer that works well in most cases. Functions with stack space have their boundaries defined in the &lt;code&gt;.pdata&lt;/code&gt; segment of the XEX. For functions not found in this segment, the analyzer detects the start of functions by searching for branch link instructions, and determines their length via static analysis.&lt;/p&gt; &#xA;&lt;p&gt;However, the analyzer struggles with functions containing jump tables, since they look like tail calls without enough information. While there is currently no solution for this, it might be relatively simple to extend the function analyzer to account for jump tables defined in the TOML file. As a workaround, the recompiler TOML file allows users to manually define function boundaries.&lt;/p&gt; &#xA;&lt;h3&gt;Exceptions&lt;/h3&gt; &#xA;&lt;p&gt;The recompiler currently does not support exceptions. This is challenging due to the use of the link register and the fact that exception handlers can jump to arbitrary code locations.&lt;/p&gt; &#xA;&lt;h3&gt;setjmp&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt; are implemented by redirecting them to native implementations. Thanks to the Xbox 360&#39;s large number of vector registers, the guest CPU state struct is large enough to hold the x86 CPU state and potentially states from other architectures.&lt;/p&gt; &#xA;&lt;h3&gt;Optimizations&lt;/h3&gt; &#xA;&lt;p&gt;Since Xbox 360 binaries typically follow a stable ABI, we can make certain assumptions about code structure, allowing the Clang compiler to generate better code. Several optimization options are available in the recompiler, but it&#39;s recommended to test them only after having a successfully functioning recompilation.&lt;/p&gt; &#xA;&lt;p&gt;The link register can be skipped assuming the game does not utilize exceptions, as the whole process of recompilation already takes care of function return behavior.&lt;/p&gt; &#xA;&lt;p&gt;The following registers, assuming the game doesn&#39;t violate the ABI, can be safely converted into local variables, as they never leave the function scope:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Count register&lt;/li&gt; &#xA; &lt;li&gt;XER&lt;/li&gt; &#xA; &lt;li&gt;Reserved register&lt;/li&gt; &#xA; &lt;li&gt;Condition registers&lt;/li&gt; &#xA; &lt;li&gt;Non argument registers&lt;/li&gt; &#xA; &lt;li&gt;Non volatile registers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The local variable optimization particularly introduces the most improvements, as the calls to the register restore/save functions can be completely removed, and the redundant stores to the PPC context struct can be eliminated. In &lt;a href=&#34;https://github.com/hedge-dev/UnleashedRecomp&#34;&gt;Unleashed Recompiled&lt;/a&gt;, the executable size decreases by around 20 MB with these optimizations, and frame times are reduced by several milliseconds.&lt;/p&gt; &#xA;&lt;h3&gt;Patch Mechanisms&lt;/h3&gt; &#xA;&lt;p&gt;XenonRecomp defines PPC functions in a way that makes them easy to hook, using techniques in the Clang compiler. By aliasing a PPC function to an &#34;implementation function&#34; and marking the original function as weakly linked, users can override it with a custom implementation while retaining access to the original function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;PPC_FUNC_IMPL(__imp__sub_XXXXXXXX);&#xA;PPC_FUNC(sub_XXXXXXXX)&#xA;{&#xA;    __imp__sub_XXXXXXXX(ctx, base);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, mid-asm hooks can be inserted directly into the translated C++ code at specific instruction addresses. The recompiler inserts these function calls, and users are responsible for implementing them in their recompilation project. The linker resolves them during compilation.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;XenonAnalyse&lt;/h3&gt; &#xA;&lt;p&gt;XenonAnalyse, when used as a command-line application, allows an XEX file to be passed as an input argument to output a TOML file containing all the detected jump tables in the executable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XenonAnalyse [input XEX file path] [output jump table TOML file path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, as explained in the earlier sections, due to variations between games, additional support may be needed to handle different patterns.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hedge-dev/UnleashedRecomp/raw/main/UnleashedRecompLib/config/SWA_switch_tables.toml&#34;&gt;An example jump table TOML file can be viewed in the Unleashed Recompiled repository.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;XenonRecomp&lt;/h3&gt; &#xA;&lt;p&gt;XenonRecomp accepts a TOML file with recompiler configurations and the path to the &lt;code&gt;ppc_context.h&lt;/code&gt; file located in the XenonUtils directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XenonRecomp [input TOML file path] [input PPC context header file path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hedge-dev/UnleashedRecomp/raw/main/UnleashedRecompLib/config/SWA.toml&#34;&gt;An example recompiler TOML file can be viewed in the Unleashed Recompiled repository.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Main&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[main]&#xA;file_path = &#34;../private/default.xex&#34;&#xA;patch_file_path = &#34;../private/default.xexp&#34;&#xA;patched_file_path = &#34;../private/default_patched.xex&#34;&#xA;out_directory_path = &#34;../ppc&#34;&#xA;switch_table_file_path = &#34;SWA_switch_tables.toml&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the paths are relative to the directory where the TOML file is stored.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the XEX file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;patch_file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the XEXP file. This is not required if the game has no title updates.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;patched_file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the patched XEX file. XenonRecomp will create this file automatically if it is missing and reuse it in subsequent recompilations. It does nothing if no XEXP file is specified. You can pass this output file to XenonAnalyse.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;out_directory_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the directory that will contain the output C++ code. This directory must exist before running the recompiler.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;switch_table_file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the TOML file containing the jump table definitions. The recompiler uses this file to convert jump tables to real switch cases.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Optimizations&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;skip_lr = false&#xA;skip_msr = false&#xA;ctr_as_local = false&#xA;xer_as_local = false&#xA;reserved_as_local = false&#xA;cr_as_local = false&#xA;non_argument_as_local = false&#xA;non_volatile_as_local = false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enables or disables various optimizations explained earlier in the documentation. It is recommended not to enable these optimizations until you have a successfully running recompilation.&lt;/p&gt; &#xA;&lt;h4&gt;Register Restore &amp;amp; Save Functions&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;restgprlr_14_address = 0x831B0B40&#xA;savegprlr_14_address = 0x831B0AF0&#xA;restfpr_14_address = 0x831B144C&#xA;savefpr_14_address = 0x831B1400&#xA;restvmx_14_address = 0x831B36E8&#xA;savevmx_14_address = 0x831B3450&#xA;restvmx_64_address = 0x831B377C&#xA;savevmx_64_address = 0x831B34E4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Xbox 360 binaries feature specialized register restore &amp;amp; save functions that act similarly to switch case fallthroughs. Every function that utilizes non-volatile registers either has an inlined version of these functions or explicitly calls them. The recompiler requires the starting address of each restore/save function in the TOML file to recompile them correctly. These functions could likely be auto-detected, but there is currently no mechanism for it.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Byte Pattern&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restgprlr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restgprlr_14&lt;/code&gt; function. It starts with &lt;code&gt;ld r14, -0x98(r1)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile registers and restoring the link register at the end.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;e9 c1 ff 68&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savegprlr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savegprlr_14&lt;/code&gt; function. It starts with &lt;code&gt;std r14, -0x98(r1)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile registers and saving the link register at the end.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;f9 c1 ff 68&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restfpr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restfpr_14&lt;/code&gt; function. It starts with &lt;code&gt;lfd f14, -0x90(r12)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile FPU registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;c9 cc ff 70&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savefpr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savefpr_14&lt;/code&gt; function. It starts with &lt;code&gt;stfd r14, -0x90(r12)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile FPU registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;d9 cc ff 70&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restvmx_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restvmx_14&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x120&lt;/code&gt; and &lt;code&gt;lvx v14, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers until &lt;code&gt;v31&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fe e0 7d cb 60 ce&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savevmx_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savevmx_14&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x120&lt;/code&gt; and &lt;code&gt;stvx v14, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers until &lt;code&gt;v31&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fe e0 7d cb 61 ce&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restvmx_64_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restvmx_64&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x400&lt;/code&gt; and &lt;code&gt;lvx128 v64, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fc 00 10 0b 60 cb&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savevmx_64_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savevmx_64&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x400&lt;/code&gt; and &lt;code&gt;stvx128 v64, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fc 00 10 0b 61 cb&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;longjmp &amp;amp; setjmp&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;longjmp_address = 0x831B6790&#xA;setjmp_address = 0x831B6AB0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These are addresses for the &lt;code&gt;longjmp&lt;/code&gt; and &lt;code&gt;setjmp&lt;/code&gt; functions in the executable. The recompiler directly redirects these functions to native versions. The implementation of these functions might vary between games. In some cases, you might find &lt;code&gt;longjmp&lt;/code&gt; by looking for calls to &lt;code&gt;RtlUnwind&lt;/code&gt;, and &lt;code&gt;setjmp&lt;/code&gt; typically appears just after it.&lt;/p&gt; &#xA;&lt;p&gt;If the game does not use these functions, you can remove the properties from the TOML file.&lt;/p&gt; &#xA;&lt;h4&gt;Explicit Function Boundaries&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;functions = [&#xA;    { address = 0x824E7EF0, size = 0x98 },&#xA;    { address = 0x824E7F28, size = 0x60 },&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can define function boundaries explicitly using the &lt;code&gt;functions&lt;/code&gt; property if XenonAnalyse fails to analyze them correctly, for example, with functions containing jump tables.&lt;/p&gt; &#xA;&lt;h4&gt;Invalid Instruction Skips&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;invalid_instructions = [&#xA;    { data = 0x00000000, size = 4 }, # Padding&#xA;    { data = 0x831B1C90, size = 8 }, # C++ Frame Handler&#xA;    { data = 0x8324B3BC, size = 8 }, # C Specific Frame Handler&#xA;    { data = 0x831C8B50, size = 8 },&#xA;    { data = 0x00485645, size = 44 } # End of .text&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;invalid_instructions&lt;/code&gt; property, you can define 32-bit integer values that instruct the recompiler to skip over certain bytes when it encounters them. For example, in Unleashed Recompiled, these are used to skip over exception handling data, which is placed between functions but is not valid code.&lt;/p&gt; &#xA;&lt;h4&gt;Mid-asm Hooks&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[midasm_hook]]&#xA;name = &#34;IndexBufferLengthMidAsmHook&#34;&#xA;address = 0x82E26244&#xA;registers = [&#34;r3&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void IndexBufferLengthMidAsmHook(PPCRegister&amp;amp; r3)&#xA;{&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can define multiple mid-asm hooks in the TOML file, allowing the recompiler to insert function calls at specified addresses. When implementing them in your recompilation project, the linker will resolve the calls automatically.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;name&lt;/td&gt; &#xA;   &lt;td&gt;Function name of the mid-asm hook. You can reuse function names to place the same implementation at multiple addresses. Otherwise, unique implementations must have unique names.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;address&lt;/td&gt; &#xA;   &lt;td&gt;Address of the instruction where the function call will be placed. This does not overwrite the instruction at the specified address.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;registers&lt;/td&gt; &#xA;   &lt;td&gt;Registers to pass as arguments to the mid-asm hook. This is a list of registers because the local variable optimization does not keep optimized registers within the PPC context struct.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;return&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to indicate that the function where the hook was inserted should immediately return after calling the mid-asm hook.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;return_on_true&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to indicate that the function should return if the mid-asm hook call returns &lt;code&gt;true&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;return_on_false&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to indicate that the function should return if the mid-asm hook call returns &lt;code&gt;false&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jump_address&lt;/td&gt; &#xA;   &lt;td&gt;The address to jump to immediately after calling the mid-asm hook. The address must be within the same function where the hook was placed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jump_address_on_true&lt;/td&gt; &#xA;   &lt;td&gt;The address to jump to if the mid-asm hook returns &lt;code&gt;true&lt;/code&gt;. The address must be within the same function where the hook was placed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jump_address_on_false&lt;/td&gt; &#xA;   &lt;td&gt;The address to jump to if the mid-asm hook returns &lt;code&gt;false&lt;/code&gt;. The address must be within the same function where the hook was placed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;after_instruction&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to place the mid-asm hook immediately after the instruction, instead of before.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Certain properties are mutually exclusive. For example, you cannot use both &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;jump_address&lt;/code&gt;, and direct or conditional returns/jumps cannot be mixed. The recompiler is going to show warnings if this is not followed.&lt;/p&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;XenonRecomp can recompile Xenia&#39;s PPC tests and execute them through the XenonTests project in the repository. After building the tests using Xenia&#39;s build system, XenonRecomp can process the &lt;code&gt;src/xenia/cpu/ppc/testing/bin&lt;/code&gt; directory as input, generating C++ files in the specified output directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XenonRecomp [input testing directory path] [input PPC context header file path] [output directory path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the files are generated, refresh XenonTests&#39; CMake cache to make them appear in the project. The tests can then be executed to compare the results of instructions against the expected values.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;The project requires CMake 3.20 or later and Clang 18 or later to build. Since the repository includes submodules, ensure you clone it recursively.&lt;/p&gt; &#xA;&lt;p&gt;Compilers other than Clang have not been tested and are not recommended, including for recompilation output. The project relies on compiler-specific intrinsics and techniques that may not function correctly on other compilers, and many optimization methods depend on Clang&#39;s code generation.&lt;/p&gt; &#xA;&lt;p&gt;On Windows, you can use the clang-cl toolset and open the project in Visual Studio&#39;s CMake integration.&lt;/p&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;p&gt;This project could not have been possible without the &lt;a href=&#34;https://github.com/xenia-project/xenia&#34;&gt;Xenia&lt;/a&gt; emulator, as many parts of the CPU code conversion process has been implemented by heavily referencing its PPC code translator. The project also uses code from &lt;a href=&#34;https://github.com/xenia-canary/xenia-canary&#34;&gt;Xenia Canary&lt;/a&gt; to patch XEX binaries.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>apache/incubator-graphar</title>
    <updated>2025-03-31T01:29:34Z</updated>
    <id>tag:github.com,2025-03-31:/apache/incubator-graphar</id>
    <link href="https://github.com/apache/incubator-graphar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An open source, standard data file format for graph data storage and retrieval.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34; style=&#34;clear: both;&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/graphar-logo.svg?sanitize=true&#34; width=&#34;350&#34; alt=&#34;GraphAr&#34;&gt; &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; An open source, standard data file format for graph data storage and retrieval &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/apache/incubator-graphar/actions&#34;&gt;&lt;img src=&#34;https://github.com/apache/incubator-graphar/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;GraphAr CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/apache/incubator-graphar/actions&#34;&gt;&lt;img src=&#34;https://github.com/apache/incubator-graphar/actions/workflows/docs.yml/badge.svg?sanitize=true&#34; alt=&#34;Docs CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/apache/incubator-graphar&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/apache/incubator-graphar/graph/badge.svg?sanitize=true&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://graphar.apache.org/docs/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docs-latest-brightgreen.svg?sanitize=true&#34; alt=&#34;GraphAr Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/apache/incubator-graphar/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/labels/apache/incubator-graphar/Good%20First%20Issue?color=green&amp;amp;label=Contribute&#34; alt=&#34;Good First Issue&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/README-zh-cn.md&#34;&gt;&lt;img src=&#34;https://shields.io/badge/README-%E4%B8%AD%E6%96%87-blue&#34; alt=&#34;README-zh&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What is GraphAr?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/overview.png&#34; class=&#34;align-center&#34; width=&#34;770&#34; alt=&#34;Overview&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Graph processing serves as the essential building block for a diverse variety of real-world applications such as social network analytics, data mining, network routing, and scientific computing.&lt;/p&gt; &#xA;&lt;p&gt;GraphAr (short for &#34;Graph Archive&#34;) is a project that aims to make it easier for diverse applications and systems (in-memory and out-of-core storages, databases, graph computing systems, and interactive graph query frameworks) to build and access graph data conveniently and efficiently.&lt;/p&gt; &#xA;&lt;p&gt;It can be used for importing/exporting and persistent storage of graph data, thereby reducing the burden on systems when working together. Additionally, it can serve as a direct data source for graph processing applications.&lt;/p&gt; &#xA;&lt;p&gt;To achieve this, GraphAr project provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The GraphAr format: a standardized system-independent format for storing graph data&lt;/li&gt; &#xA; &lt;li&gt;Libraries: a set of libraries for reading, writing and transforming GraphAr format data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By using GraphAr, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Store and persist your graph data in a system-independent way with the GraphAr format&lt;/li&gt; &#xA; &lt;li&gt;Easily access and generate GraphAr format data using the libraries&lt;/li&gt; &#xA; &lt;li&gt;Utilize Apache Spark to quickly manipulate and transform your graphar format data&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;The GraphAr Format&lt;/h2&gt; &#xA;&lt;p&gt;The GraphAr format is designed for storing property graphs. It uses metadata to record all the necessary information of a graph, and maintains the actual data in a chunked way.&lt;/p&gt; &#xA;&lt;p&gt;A property graph consists of vertices and edges, with each vertex contains a unique identifier and:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A text label that describes the vertex type.&lt;/li&gt; &#xA; &lt;li&gt;A collection of properties, with each property can be represented by a key-value pair.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each edge contains a unique identifier and:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The outgoing vertex (source).&lt;/li&gt; &#xA; &lt;li&gt;The incoming vertex (destination).&lt;/li&gt; &#xA; &lt;li&gt;A text label that describes the relationship between the two vertices.&lt;/li&gt; &#xA; &lt;li&gt;A collection of properties.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following is an example property graph containing two types of vertices (&#34;person&#34; and &#34;comment&#34;) and three types of edges.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/property_graph.png&#34; class=&#34;align-center&#34; width=&#34;700&#34; alt=&#34;property graph&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Vertices in GraphAr&lt;/h3&gt; &#xA;&lt;h4&gt;Logical table of vertices&lt;/h4&gt; &#xA;&lt;p&gt;Each type of vertices (with the same type) constructs a logical vertex table, with each vertex assigned with a global index inside this type (called internal vertex id) starting from 0, corresponding to the row number of the vertex in the logical vertex table. An example layout for a logical table of vertices under the type &#34;person&#34; is provided for reference.&lt;/p&gt; &#xA;&lt;p&gt;Given an internal vertex id and the vertex type, a vertex is uniquely identifiable and its respective properties can be accessed from this table. The internal vertex id is further used to identify the source and destination vertices when maintaining the topology of the graph.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/vertex_logical_table.png&#34; class=&#34;align-center&#34; width=&#34;650&#34; alt=&#34;vertex logical table&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Physical table of vertices&lt;/h3&gt; &#xA;&lt;p&gt;The logical vertex table will be partitioned into multiple continuous vertex chunks for enhancing the reading/writing efficiency. To maintain the ability of random access, the size of vertex chunks for the same type is fixed. To support to access required properties avoiding reading all properties from the files, and to add properties for vertices without modifying the existing files, the columns of the logical table will be divided into several column groups.&lt;/p&gt; &#xA;&lt;p&gt;Take the &lt;code&gt;person&lt;/code&gt; vertex table as an example, if the chunk size is set to be 500, the logical table will be separated into sub-logical-tables of 500 rows with the exception of the last one, which may have less than 500 rows. The columns for maintaining properties will also be divided into distinct groups (e.g., 2 for our example). As a result, a total of 4 physical vertex tables are created for storing the example logical table, which can be seen from the following figure.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/vertex_physical_table.png&#34; class=&#34;align-center&#34; width=&#34;650&#34; alt=&#34;vertex physical table&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] For efficiently utilize the filter push-down of the payload file format like Parquet, the internal vertex id is stored in the payload file as a column. And since the internal vertex id is continuous, the payload file format can use the delta encoding for the internal vertex id column, which would not bring too much overhead for the storage.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Edges in GraphAr&lt;/h3&gt; &#xA;&lt;h4&gt;Logical table of edges&lt;/h4&gt; &#xA;&lt;p&gt;For maintaining a type of edges (that with the same triplet of the source type, edge type, and destination type), a logical edge table is established. And in order to support quickly creating a graph from the graph storage file, the logical edge table could maintain the topology information in a way similar to &lt;a href=&#34;https://en.wikipedia.org/wiki/Sparse_matrix&#34;&gt;CSR/CSC&lt;/a&gt;, that is, the edges are ordered by the internal vertex id of either source or destination. In this way, an offset table is required to store the start offset for each vertex&#39;s edges, and the edges with the same source/destination will be stored continuously in the logical table.&lt;/p&gt; &#xA;&lt;p&gt;Take the logical table for &lt;code&gt;person knows person&lt;/code&gt; edges as an example, the logical edge table looks like:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/edge_logical_table.png&#34; class=&#34;align-center&#34; width=&#34;650&#34; alt=&#34;edge logical table&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Physical table of edges&lt;/h4&gt; &#xA;&lt;p&gt;As same with the vertex table, the logical edge table is also partitioned into some sub-logical-tables, with each sub-logical-table contains edges that the source (or destination) vertices are in the same vertex chunk. According to the partition strategy and the order of the edges, edges can be stored in GraphAr following one of the four types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;ordered_by_source&lt;/strong&gt;: all the edges in the logical table are ordered and further partitioned by the internal vertex id of the source, which can be seen as the CSR format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ordered_by_dest&lt;/strong&gt;: all the edges in the logical table are ordered and further partitioned by the internal vertex id of the destination, which can be seen as the CSC format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;unordered_by_source&lt;/strong&gt;: the internal id of the source vertex is used as the partition key to divide the edges into different sub-logical-tables, and the edges in each sub-logical-table are unordered, which can be seen as the COO format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;unordered_by_dest&lt;/strong&gt;: the internal id of the destination vertex is used as the partition key to divide the edges into different sub-logical-tables, and the edges in each sub-logical-table are unordered, which can also be seen as the COO format.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After that, a sub-logical-table is further divided into edge chunks of a predefined, fixed number of rows (referred to as edge chunk size). Finally, an edge chunk is separated into physical tables in the following way:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;an adjList table (which contains only two columns: the internal vertex id of the source and the destination).&lt;/li&gt; &#xA; &lt;li&gt;0 or more edge property tables, with each table contains a group of properties.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, there would be an offset table for &lt;strong&gt;ordered_by_source&lt;/strong&gt; or &lt;strong&gt;ordered_by_dest&lt;/strong&gt; edges. The offset table is used to record the starting point of the edges for each vertex. The partition of the offset table should be in alignment with the partition of the corresponding vertex table. The first row of each offset chunk is always 0, indicating the starting point for the corresponding sub-logical-table for edges.&lt;/p&gt; &#xA;&lt;p&gt;Take the &lt;code&gt;person knows person&lt;/code&gt; edges to illustrate. Suppose the vertex chunk size is set to 500 and the edge chunk size is 1024, and the edges are &lt;strong&gt;ordered_by_source&lt;/strong&gt;, then the edges could be saved in the following physical tables:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/edge_physical_table1.png&#34; class=&#34;align-center&#34; width=&#34;650&#34; alt=&#34;edge logical table1&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/docs/images/edge_physical_table2.png&#34; class=&#34;align-center&#34; width=&#34;650&#34; alt=&#34;edge logical table2&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Libraries&lt;/h2&gt; &#xA;&lt;p&gt;GraphAr offers a collection of libraries for the purpose of reading, writing and transforming files. Currently, the following libraries are available, and plans are in place to expand support to additional programming language.&lt;/p&gt; &#xA;&lt;h3&gt;The C++ Library&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/cpp&#34;&gt;GraphAr C++ Library&lt;/a&gt; for details about the building of the C++ library.&lt;/p&gt; &#xA;&lt;h3&gt;The Scala with Spark Library&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/maven-projects/spark&#34;&gt;GraphAr Spark Library&lt;/a&gt; for details about the Scala with Spark library.&lt;/p&gt; &#xA;&lt;h3&gt;The Java Library&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] The Java library is under development.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The GraphAr Java library is created with bindings to the C++ library (currently at version v0.10.0), utilizing &lt;a href=&#34;https://github.com/alibaba/fastFFI&#34;&gt;Alibaba-FastFFI&lt;/a&gt; for implementation. See &lt;a href=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/maven-projects/java&#34;&gt;GraphAr Java Library&lt;/a&gt; for details about the building of the Java library.&lt;/p&gt; &#xA;&lt;h3&gt;The Python with PySpark Library&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] The Python with PySpark library is under development.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The PySpark library is developed as bindings to the GraphAr Spark library. See &lt;a href=&#34;https://raw.githubusercontent.com/apache/incubator-graphar/main/pyspark&#34;&gt;GraphAr PySpark Library&lt;/a&gt; for details about the PySpark library.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Start with &lt;a href=&#34;https://github.com/apache/incubator-graphar/raw/main/CONTRIBUTING.md&#34;&gt;Contributing Guide&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Submit &lt;a href=&#34;https://github.com/apache/incubator-graphar/issues&#34;&gt;Issues&lt;/a&gt; for bug reports, feature requests.&lt;/li&gt; &#xA; &lt;li&gt;Discuss at &lt;a href=&#34;mailto:dev@graphar.apache.org&#34;&gt;dev mailing list&lt;/a&gt; (&lt;a href=&#34;mailto:dev-subscribe@graphar.apache.org?subject=(send%20this%20email%20to%20subscribe)&#34;&gt;subscribe&lt;/a&gt; / &lt;a href=&#34;mailto:dev-unsubscribe@graphar.apache.org?subject=(send%20this%20email%20to%20unsubscribe)&#34;&gt;unsubscribe&lt;/a&gt; / &lt;a href=&#34;https://lists.apache.org/list.html?dev@graphar.apache.org&#34;&gt;archives&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Asking questions on &lt;a href=&#34;https://github.com/apache/graphar/discussions/new?category=q-a&#34;&gt;GitHub Discussions&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Join our &lt;a href=&#34;https://github.com/apache/incubator-graphar/wiki/GraphAr-Community-Meeting&#34;&gt;Biweekly Community Meeting&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;GraphAr&lt;/strong&gt; is distributed under &lt;a href=&#34;https://github.com/apache/incubator-graphar/raw/main/LICENSE&#34;&gt;Apache License 2.0&lt;/a&gt;. Please note that third-party libraries may not have the same license as GraphAr.&lt;/p&gt; &#xA;&lt;h2&gt;Publication&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Xue Li, Weibin Zeng, Zhibin Wang, Diwen Zhu, Jingbo Xu, Wenyuan Yu, Jingren Zhou. GraphAr: An Efficient Storage Scheme for Graph Data in Data Lakes. PVLDB, 18(3): 530 - 543, 2024.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@article{li2024graphar,&#xA;  author = {Xue Li and Weibin Zeng and Zhibin Wang and Diwen Zhu and Jingbo Xu and Wenyuan Yu and Jingren Zhou},&#xA;  title = {GraphAr: An Efficient Storage Scheme for Graph Data in Data Lakes},&#xA;  journal = {Proceedings of the VLDB Endowment},&#xA;  year = {2024},&#xA;  volume = {18},&#xA;  number = {3},&#xA;  pages = {530--543},&#xA;  publisher = {VLDB Endowment},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The source code, data, and/or other artifacts of the research paper have been made available at the &lt;a href=&#34;https://github.com/apache/incubator-graphar/tree/research&#34;&gt;research branch&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>