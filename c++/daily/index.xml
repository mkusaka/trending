<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-05T01:28:44Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>pxmkv/Balance-Tech</title>
    <updated>2023-11-05T01:28:44Z</updated>
    <id>tag:github.com,2023-11-05:/pxmkv/Balance-Tech</id>
    <link href="https://github.com/pxmkv/Balance-Tech" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Self Balancing Bicycle using LQR controller&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/logo.png&#34;&gt; &#xA;&lt;p&gt;The basic goal of this project was to create a two-wheel self balancing object reminiscent of a motorcycle with the ability to move and turn&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/cad.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/bike1.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/bike2.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/bike3.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Integrated device with labeled actuators and sensors:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/bike.png&#34;&gt; &#xA;&lt;p&gt;The bulk of the circuit design lies within a three “story” structure. Three circuit boards with a gap of about an inch between each house all the circuitry and key parts within. Battery power is wired in a position that will decrease center of mass and aid in smoother balancing. The Buck converter allows for an adjustable power supply and the LDO AMS1117 serves as a voltage regulator for the MCU. Other smaller parts exist in the circuit but the critical parts are provided here&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/circuit.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/diagram.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;** Engineering Analysis ** A. External Torque Requirements&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/diagram2.png&#34;&gt; &#xA;&lt;p&gt;The system’s center of mass is above its pivot point, which makes it inherently unstable; any tilt will result in a gravitational torque. The Euler angle quantifies the angular displacement of the system about the axis of rotation. If the Euler angle reaches a threshold of 22°, the motor is programmed to stop. Taking that as the maximum angle of operation, the maximum gravitational torque is as follows:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation1.png&#34;&gt; &#xA;&lt;p&gt;The following calculations verify the reaction wheel’s ability to apply a neutralizing torque of equal magnitude or higher&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation2.png&#34;&gt; &#xA;&lt;p&gt;Additionally, the performance curve of the brushless DC motor shows that it is capable of delivering enough torque to the reaction wheel.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/curve.png&#34;&gt; &#xA;&lt;p&gt;B. Optimization of the K Gain Matrix&lt;/p&gt; &#xA;&lt;p&gt;There are four parameters that provide information about the system&#39;s state and help to determine the appropriate control actions to maintain balance: the Euler angle, the angular velocity of the system, the motor speed, and the motor position. The Euler angle and angular velocity describe the effect of the gravitational torque; the desired states are 0° and 0 rad/s respectively. The motor speed and motor position describe the effect of the torque applied by the momentum wheel; the desired states of these parameters depend on the system’s dynamics. In order to maintain balance of the system, a feedback control approach is used to bring the actual states closer to the desired states. The K gain matrix is the set of feedback gains that are used to adjust the speed and direction of the momentum wheel based on the difference between the desired and actual states of the system. The LQR algorithm is used to find the optimal K gain matrix that minimizes the control effort (i.e. motor speed/torque) while also minimizing the system’s deviation from the desired state. The calculation of the optimal K gain matrix was done using the lqr() function in MATLAB. This function requires four inputs: two linearized state-space matrices A and B, the state-cost weighted matrix Q, and the control weighted matrix R. The K feedback gain is multiplied by the difference between the actual state and desired state to generate the control signal (u) that will minimize the quadratic cost function J(u) [3], which is constricted to linear system dynamics [13]. The optimal K gain matrix is found using the lqr() function in MATLAB [11], which uses matrices A,B,Q, and R to find P via the Ricatti equation [6] and solve for K [5].&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation3.png&#34;&gt; &#xA;&lt;p&gt;Matrices A and B are found by modeling the system’s motion using the Lagrange equations [7][8], then linearizing the results into the state space equations [9].&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation4.png&#34;&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation5.png&#34;&gt; &#xA;&lt;p&gt;The values in the state-cost weighted matrix Q determine the level of emphasis placed on minimizing the state’s deviations in the cost function. The Q matrix for this system places equal weight to the Euler angle, angular velocity, and motor speed state, and a much smaller weight (0.001) to the motor position. This means that it is much less important for the motor position to match the desired state than it is for the Euler angle, angular velocity, and motor speed state. The control weighted matrix R equals one, which means that minimizing the state’s deviations is equally as important as minimizing the control effort.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation6.png&#34;&gt; &#xA;&lt;p&gt;Plugging the four matrices into the lqr() function [4], the theoretical K matrix was determined. By conducted a series of experiments to fine-tune the K values until get the final K matrix [11] provided stable performance. This process allowed us to identify a more effective set of feedback gains that ultimately improved the system&#39;s stability and control accuracy. &lt;a href=&#34;https://github.com/pxmkv/Balance-Tech/tree/main/main_LQR&#34;&gt;About LQR calculation using MATLAB&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/pxmkv/Balance-Tech/main/pics/equation7.png&#34;&gt; &#xA;&lt;img src=&#34;https://i1.wp.com/www.esp32learning.com/wp-content/uploads/2018/12/MH-ET_LIVE_D1_mini_ESP32_pinout.png&#34; width=&#34;600&#34; height=&#34;400&#34;&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pin Used&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;M_Encoder GPIO 19, 23&lt;/p&gt; &#xA;&lt;p&gt;​ PWM : GPIO 26&lt;/p&gt; &#xA;&lt;p&gt;​ PWS : GPIO 18&lt;/p&gt; &#xA;&lt;p&gt;​ DIR : GPIO 5&lt;/p&gt; &#xA;&lt;p&gt;Drive Motor&lt;/p&gt; &#xA;&lt;p&gt;​ GPIO 4, 33 Servo Motor ​ GPIO 17&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Basic structure:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CPU1:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Kalman Filter&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Accurate angle and angular velocity estimation.Precise sensor fusion of accelerometer and gyroscope data from the MPU6050 sensor.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dynamic system stability&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Implementing &lt;strong&gt;Linear–quadratic regulator(LQR)&lt;/strong&gt; with adjustable gains for stable balancing under various conditions. The LQR controller takes 4 parameters: Euler Angle, Angular velocity, reaction wheel actual speed and reaction wheel position, then calculates the PWM output.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CPU0:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Read Game Controller input using &lt;a href=&#34;https://github.com/ricardoquesada/bluepad32/raw/main/docs/plat_arduino.md&#34;&gt;Bluepad32&lt;/a&gt; library and mapping joystick reading value to the drivetrain motor and servo motor&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Something useful&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;References&lt;/p&gt; &#xA;&lt;p&gt;[1] Olfati-Saber, Reza. “Global Stabilization of a Flat Underactuated System: The Inertia Wheel Pendulum.” Conference of Decision and Control, 3 Dec. 2001. authors.library.caltech.edu/5154/1/OLFcdc01b.pdf&lt;/p&gt; &#xA;&lt;p&gt;[2]Çakan, Abdullah, and Ümit Önen. “Multibody Modeling and Balance Control of AReaction Wheel Inverted Pendulum Using LQRController.” ResearchGate, International Journal of Robotics and Control, 3 Apr. 2021. &lt;a href=&#34;http://www.researchgate.net/publication/351314795_Multibody_Modeling_and_Balance_Control_of_a_Reaction_Wheel_Inverted_Pendulum_Using_LQR_Controller&#34;&gt;www.researchgate.net/publication/351314795_Multibody_Modeling_and_Balance_Control_of_a_Reaction_Wheel_Inverted_Pendulum_Using_LQR_Controller&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[3]Lacey, Tony . Tutorial: The Kalman Filter. &lt;a href=&#34;http://web.mit.edu/kirtley/kirtley/binlustuff/literature/control/Kalman%20filter.pdf&#34;&gt;http://web.mit.edu/kirtley/kirtley/binlustuff/literature/control/Kalman%20filter.pdf&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[4] Hau Nguyen, Binh, and Minh Phuoc Cu. “LQR AND FUZZY CONTROL FOR REACTION WHEEL INVERTED PENDULUM MODEL.” Index Copernicus, 24 1 2019, &lt;a href=&#34;https://journals.indexcopernicus.com/api/file/viewByFileId/746635.pdf&#34;&gt;https://journals.indexcopernicus.com/api/file/viewByFileId/746635.pdf&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[5] Leroy, Etienne. “Guide to Gyro and Accelerometer With Arduino Including Kalman Filtering.” Instructables, 2011, &lt;a href=&#34;https://www.instructables.com/Guide-to-gyro-and-accelerometer-with-Arduino-inclu/&#34;&gt;https://www.instructables.com/Guide-to-gyro-and-accelerometer-with-Arduino-inclu/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;[6] Polotski, Vladimir. “Kalman filter, how do I choose initial P_0?” ResearchGate, 2017, &lt;a href=&#34;https://www.researchgate.net/post/Kalman_filter_how_do_I_choose_initial_P_0&#34;&gt;https://www.researchgate.net/post/Kalman_filter_how_do_I_choose_initial_P_0&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[7] Vathsangam, Harsh. “Complementary filter - My IMU estimation experience.” Google Sites, 29 May 2010, &lt;a href=&#34;https://sites.google.com/site/myimuestimationexperience/filters/complementary-filter&#34;&gt;https://sites.google.com/site/myimuestimationexperience/filters/complementary-filter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[8] Abbeel, Pieter. “Optimal Control for Linear Dynamical Systems and Quadratic Cost.” EECS at UC Berkeley, &lt;a href=&#34;https://people.eecs.berkeley.edu/~pabbeel/cs287-fa12/slides/LQR.pdf&#34;&gt;https://people.eecs.berkeley.edu/~pabbeel/cs287-fa12/slides/LQR.pdf&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[9] Sears-Collins, Addison. “Combine the Extended Kalman Filter With LQR – Automatic Addison.” Automatic Addison, 13 December 2020, &lt;a href=&#34;https://automaticaddison.com/combine-the-extended-kalman-filter-with-lqr/&#34;&gt;https://automaticaddison.com/combine-the-extended-kalman-filter-with-lqr/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[10] Quesada, Ricardo. “bluepad32/plat_arduino.md at main · ricardoquesada/bluepad32.” GitHub, &lt;a href=&#34;https://github.com/ricardoquesada/bluepad32/raw/main/docs/plat_arduino.md&#34;&gt;https://github.com/ricardoquesada/bluepad32/blob/main/docs/plat_arduino.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[11] “1-Axis Attitude Control Module with ATOM - M5Stack Projects.” M5Stack Projects, 13 August 2020, &lt;a href=&#34;https://m5stack.hackster.io/homemadegarbage/1-axis-attitude-control-module-with-atom-d56138&#34;&gt;https://m5stack.hackster.io/homemadegarbage/1-axis-attitude-control-module-with-atom-d56138&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mmp/pbrt-v4</title>
    <updated>2023-11-05T01:28:44Z</updated>
    <id>tag:github.com,2023-11-05:/mmp/pbrt-v4</id>
    <link href="https://github.com/mmp/pbrt-v4" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Source code to pbrt, the ray tracer described in the forthcoming 4th edition of the &#34;Physically Based Rendering: From Theory to Implementation&#34; book.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;pbrt, Version 4 (Early Release)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mmp/pbrt-v4/actions?query=workflow%3Acpu-linux-build-and-test&#34;&gt;&lt;img src=&#34;https://github.com/mmp/pbrt-v4/workflows/cpu-linux-build-and-test/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mmp/pbrt-v4/actions?query=workflow%3Acpu-macos-build-and-test&#34;&gt;&lt;img src=&#34;https://github.com/mmp/pbrt-v4/workflows/cpu-macos-build-and-test/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mmp/pbrt-v4/actions?query=workflow%3Acpu-windows-build-and-test&#34;&gt;&lt;img src=&#34;https://github.com/mmp/pbrt-v4/workflows/cpu-windows-build-and-test/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mmp/pbrt-v4/actions?query=workflow%3Agpu-build-only&#34;&gt;&lt;img src=&#34;https://github.com/mmp/pbrt-v4/workflows/gpu-build-only/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mmp/pbrt-v4/master/images/teaser-transparent-machines.png&#34; alt=&#34;Transparent Machines frame, via @beeple&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is an early release of pbrt-v4, the rendering system that will be described in the forthcoming fourth edition of &lt;em&gt;Physically Based Rendering: From Theory to Implementation&lt;/em&gt;. (The printed book will be available in mid-February 2023; a few chapters will be made available in late Fall of 2022; and the full contents of the book will be freely available six months after the book&#39;s release, like the &lt;a href=&#34;https://pbr-book.org&#34;&gt;third edition&lt;/a&gt; is already.)&lt;/p&gt; &#xA;&lt;p&gt;We are making this code available for hardy adventurers; it&#39;s not yet extensively documented, but if you are familiar with previous versions of pbrt, you should be able to make your way around it. Our hope is that the system will be useful to some people in its current form and that any bugs in the current implementation might be found now, allowing us to correct them before the book is final.&lt;/p&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A number of scenes for pbrt-v4 are &lt;a href=&#34;https://github.com/mmp/pbrt-v4-scenes&#34;&gt;available in a git repository&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://pbrt.org/users-guide-v4.html&#34;&gt;pbrt-v4 User&#39;s Guide&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Documentation on the &lt;a href=&#34;https://pbrt.org/fileformat-v4.html&#34;&gt;pbrt-v4 Scene Description Format&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;pbrt-v4 represents a substantial update to the previous version of pbrt-v3. Major changes include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Spectral rendering &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Rendering computations are always performed using point-sampled spectra; the use of RGB color is limited to the scene description (e.g., image texture maps), and final image output.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Modernized volumetric scattering &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;An all-new &lt;code&gt;VolPathIntegrator&lt;/code&gt; based on the null-scattering path integral formulation of &lt;a href=&#34;https://cs.dartmouth.edu/~wjarosz/publications/miller19null.html&#34;&gt;Miller et al. 2019&lt;/a&gt; has been added.&lt;/li&gt; &#xA;   &lt;li&gt;Tighter majorants are used for null-scattering with the &lt;code&gt;GridDensityMedium&lt;/code&gt; via a separate low-resolution grid of majorants.&lt;/li&gt; &#xA;   &lt;li&gt;Both emissive volumes and volumes with RGB-valued absorption and scattering coefficients are now supported.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Support for rendering on GPUs is available on systems that have CUDA and OptiX. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The GPU path provides all of the functionality of the CPU-based &lt;code&gt;VolPathIntegrator&lt;/code&gt;, including volumetric scattering, subsurface scattering, all of pbrt&#39;s cameras, samplers, shapes, lights, materials and BxDFs, etc.&lt;/li&gt; &#xA;   &lt;li&gt;Performance is substantially faster than rendering on the CPU.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;New BxDFs and Materials &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The provided BxDFs and Materials have been redesigned to be more closely tied to physical scattering processes, along the lines of Mitsuba&#39;s materials. (Among other things, the kitchen-sink UberMaterial is now gone.)&lt;/li&gt; &#xA;   &lt;li&gt;Measured BRDFs are now represented using &lt;a href=&#34;https://rgl.epfl.ch/publications/Dupuy2018Adaptive&#34;&gt;Dupuy and Jakob&#39;s approach&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Scattering from layered materials is accurately simulated using Monte Carlo random walks (after &lt;a href=&#34;https://shuangz.com/projects/layered-sa18/&#34;&gt;Guo et al. 2018&lt;/a&gt;.)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;A variety of light sampling improvements have been implemented. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&#34;Many-light&#34; sampling is available via light BVHs (&lt;a href=&#34;http://aconty.com/pdf/many-lights-hpg2018.pdf&#34;&gt;Conty and Kulla 2018&lt;/a&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;Solid angle sampling is used for triangle (&lt;a href=&#34;https://dl.acm.org/doi/10.1145/218380.218500&#34;&gt;Arvo1995&lt;/a&gt;) and quadrilateral (&lt;a href=&#34;https://www.arnoldrenderer.com/research/egsr2013_spherical_rectangle.pdf&#34;&gt;Ureña et al. 2013&lt;/a&gt;) light sources.&lt;/li&gt; &#xA;   &lt;li&gt;A single ray is now traced for both indirect lighting and BSDF-sampled direct-lighting.&lt;/li&gt; &#xA;   &lt;li&gt;Warp product sampling is used for approximate cosine-weighted solid angle sampling (&lt;a href=&#34;https://onlinelibrary.wiley.com/doi/abs/10.1111/cgf.14060&#34;&gt;Hart et al. 2019&lt;/a&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;An implementation of Bitterli et al&#39;s environment light &lt;a href=&#34;https://benedikt-bitterli.me/pmems.html&#34;&gt;portal sampling&lt;/a&gt; technique is included.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Rendering can now be performed in absolute physical units with modelling of real cameras as per &lt;a href=&#34;https://github.com/wetadigital/physlight&#34;&gt;Langlands &amp;amp; Fascione 2020&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;And also... &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Various improvements have been made to the &lt;code&gt;Sampler&lt;/code&gt; classes, including better randomization and a new sampler that implements &lt;a href=&#34;http://abdallagafar.com/publications/zsampler/&#34;&gt;Ahmed and Wonka&#39;s blue noise Sobol&#39; sampler&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;A new &lt;code&gt;GBufferFilm&lt;/code&gt; that provides position, normal, albedo, etc., at each pixel is now available. (This is particularly useful for denoising and ML training.)&lt;/li&gt; &#xA;   &lt;li&gt;Path regularization (optionally).&lt;/li&gt; &#xA;   &lt;li&gt;A bilinear patch primitive has been added (&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-1-4842-4427-2_8&#34;&gt;Reshetov 2019&lt;/a&gt;).&lt;/li&gt; &#xA;   &lt;li&gt;Various improvements to ray--shape intersection precision.&lt;/li&gt; &#xA;   &lt;li&gt;Most of the low-level sampling code has been factored out into stand-alone functions for easier reuse. Also, functions that invert many sampling techniques are provided.&lt;/li&gt; &#xA;   &lt;li&gt;Unit test coverage has been substantially increased.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have also made a refactoring pass throughout the entire system, cleaning up various APIs and data types to improve both readability and usability.&lt;/p&gt; &#xA;&lt;p&gt;Finally, pbrt-v4 can work together with the &lt;a href=&#34;https://github.com/Tom94/tev&#34;&gt;tev&lt;/a&gt; image viewer to display the image as it&#39;s being rendered. As of recent versions, &lt;em&gt;tev&lt;/em&gt; can display images provided to it via a network socket; by default, it listens to port 14158, though this can be changed via its &lt;code&gt;--hostname&lt;/code&gt; command-line option. If you have an instance of &lt;em&gt;tev&lt;/em&gt; running, you can run pbrt like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pbrt --display-server localhost:14158 scene.pbrt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In that case, the image will be progressively displayed as it renders.&lt;/p&gt; &#xA;&lt;h2&gt;Building the code&lt;/h2&gt; &#xA;&lt;p&gt;As before, pbrt uses git submodules for a number of third-party libraries that it depends on. Therefore, be sure to use the &lt;code&gt;--recursive&lt;/code&gt; flag when cloning the repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --recursive https://github.com/mmp/pbrt-v4.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you accidentally clone pbrt without using &lt;code&gt;--recursive&lt;/code&gt; (or to update the pbrt source tree after a new submodule has been added, run the following command to also fetch the dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git submodule update --init --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;pbrt uses &lt;a href=&#34;http://www.cmake.org/&#34;&gt;cmake&lt;/a&gt; for its build system. Note that a release build is the default; provide &lt;code&gt;-DCMAKE_BUILD_TYPE=Debug&lt;/code&gt; to cmake for a debug build.&lt;/p&gt; &#xA;&lt;p&gt;pbrt should build on any system that has C++ compiler with support for C++17; we have verified that it builds on Ubuntu 20.04, MacOS 10.14, and Windows 10. We welcome PRs that fix any issues that prevent it from building on other systems.&lt;/p&gt; &#xA;&lt;h2&gt;Bug Reports and PRs&lt;/h2&gt; &#xA;&lt;p&gt;Please use the &lt;a href=&#34;https://github.com/mmp/pbrt-v4/issues&#34;&gt;pbrt-v4 github issue tracker&lt;/a&gt; to report bugs in pbrt-v4. (We have pre-populated it with a number of issues corresponding to known bugs in the initial release.)&lt;/p&gt; &#xA;&lt;p&gt;We are always happy to receive pull requests that fix bugs, including bugs you find yourself or fixes for open issues in the issue tracker. We are also happy to hear suggestions about improvements to the implementations of the various algorithms we have implemented.&lt;/p&gt; &#xA;&lt;p&gt;Note, however, that in the interests of finishing the book in a finite amount of time, the functionality of pbrt-v4 is basically fixed at this point. We therefore will not be accepting PRs that make major changes to the system&#39;s operation or structure (but feel free to keep them in your own forks!). Also, don&#39;t bother sending PRs for anything marked &#34;TODO&#34; or &#34;FIXME&#34; in the source code; we&#39;ll take care of those as we finish polishing things up.&lt;/p&gt; &#xA;&lt;h2&gt;Updating pbrt-v3 scenes&lt;/h2&gt; &#xA;&lt;p&gt;There are a variety of changes to the input file format and, as noted above, the new format is not yet documented. However, pbrt-v4 partially makes up for that by providing an automatic upgrade mechanism:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pbrt --upgrade old.pbrt &amp;gt; new.pbrt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Most scene files can be automatically updated. In some cases manual intervention is required; an error message will be printed in this case.&lt;/p&gt; &#xA;&lt;p&gt;The environment map parameterization has also changed (from equi-rect to an equi-area mapping); you can upgrade environment maps using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ imgtool makeequiarea old.exr --outfile new.exr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Converting scenes to pbrt&#39;s file format&lt;/h2&gt; &#xA;&lt;p&gt;The best option for importing scenes to pbrt is to use &lt;a href=&#34;https://www.assimp.org/&#34;&gt;assimp&lt;/a&gt;, which as of January 21, 2021 includes support for exporting to pbrt-v4&#39;s file format:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ assimp export scene.fbx scene.pbrt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;While the converter tries to convert materials to pbrt&#39;s material model, some manual tweaking may be necessary after export. Furthermore, area light sources are not always successfully detected; manual intervention may be required for them as well. Use of pbrt&#39;s built-in support for converting meshes to use the binary PLY format is also recommended after conversion. (&lt;code&gt;pbrt --toply scene.pbrt &amp;gt; newscene.pbrt&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Using pbrt on the GPU&lt;/h2&gt; &#xA;&lt;p&gt;To run on the GPU, pbrt requires:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C++17 support on the GPU, including kernel launch with C++ lambdas.&lt;/li&gt; &#xA; &lt;li&gt;Unified memory so that the CPU can allocate and initialize data structures for code that runs on the GPU.&lt;/li&gt; &#xA; &lt;li&gt;An API for ray-object intersections on the GPU.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These requirements are effectively what makes it possible to bring pbrt to the GPU with limited changes to the core system. As a practical matter, these capabilities are only available via CUDA and OptiX on NVIDIA GPUs today, though we&#39;d be happy to see pbrt running on any other GPUs that provide those capabilities.&lt;/p&gt; &#xA;&lt;p&gt;pbrt&#39;s GPU path currently requires CUDA 11.0 or later and OptiX 7.1 or later. Both Linux and Windows are supported.&lt;/p&gt; &#xA;&lt;p&gt;The build scripts automatically attempt to find a CUDA compiler, looking in the usual places; the cmake output will indicate whether it was successful. It is necessary to manually set the cmake &lt;code&gt;PBRT_OPTIX7_PATH&lt;/code&gt; configuration option to point at an OptiX installation. By default, the GPU shader model that pbrt targets is set automatically based on the GPU in the system. Alternatively, the &lt;code&gt;PBRT_GPU_SHADER_MODEL&lt;/code&gt; option can be set manually (e.g., &lt;code&gt;-DPBRT_GPU_SHADER_MODEL=sm_80&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Even when compiled with GPU support, pbrt uses the CPU by default unless the &lt;code&gt;--gpu&lt;/code&gt; command-line option is given. Note that when rendering with the GPU, the &lt;code&gt;--spp&lt;/code&gt; command-line flag can be helpful to easily crank up the number of samples per pixel. Also, it&#39;s extra fun to use &lt;em&gt;tev&lt;/em&gt; to watch rendering progress.&lt;/p&gt; &#xA;&lt;p&gt;The imgtool program that is built as part of pbrt provides support for the OptiX denoiser in the GPU build. The denoiser is capable of operating on RGB-only images, but gives better results with &#34;deep&#34; images that include auxiliary channels like albedo and normal. Setting the scene&#39;s &#34;Film&#34; type to be &#34;gbuffer&#34; when rendering and using EXR for the image format causes pbrt to generate such a &#34;deep&#34; image. In either case, using the denoiser is straightforward:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ imgtool denoise-optix noisy.exr --outfile denoised.exr&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>