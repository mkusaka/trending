<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-30T01:32:57Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Omyyyy/pycom</title>
    <updated>2022-07-30T01:32:57Z</updated>
    <id>tag:github.com,2022-07-30:/Omyyyy/pycom</id>
    <link href="https://github.com/Omyyyy/pycom" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Python compiler, down to native code, using C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Pycom: A Python Compiler&lt;/h1&gt; &#xA;&lt;h4&gt;It&#39;s called README.md for a reason. Read it thoroughly before creating a new issue.&lt;/h4&gt; &#xA;&lt;h4&gt;Supported platforms: Windows, Linux&lt;/h4&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#what-is-pycom&#34;&gt;What is Pycom?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#why-and-when-use-pycom&#34;&gt;Why and when?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#speed-benchmarks-and-comparisons&#34;&gt;Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#flags&#34;&gt;Flags&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#python-dependencies&#34;&gt;Dependencies&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#run-tests&#34;&gt;Tests&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#supported-features&#34;&gt;Supported Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#not-supported-yet&#34;&gt;Features Not Yet Supported&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#small-quirks-and-differences-to-cpython&#34;&gt;Differences to CPython&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/CONTRIBUTING.md&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Simply:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Omyyyy/pycom.git&#xA;cd pycom/src&#xA;pip install -r requirements.txt&#xA;pip install -e .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: Do not touch the &lt;code&gt;pycom.py.egg-info&lt;/code&gt; folder that the last command will create. It will not work otherwise.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;If you followed the installation instructions correctly, this will work in every directory:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;pycom (flags) [source file]&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Flags&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-i&lt;/code&gt; | &lt;code&gt;--info&lt;/code&gt; (bool):&lt;br&gt; Print additional information about compilation (such as time taken). Defaults to off.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-r&lt;/code&gt; | &lt;code&gt;--run&lt;/code&gt; (bool):&lt;br&gt; Run the generated executable automatically after compilation. Defaults to off.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-rd&lt;/code&gt; | &lt;code&gt;--runandelete&lt;/code&gt; (bool):&lt;br&gt; Run the generated executable automatically after compilation, and then delete it. Defaults to off.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-o&lt;/code&gt; | &lt;code&gt;--output&lt;/code&gt; [output] (string):&lt;br&gt; The string specified after the flag will be the name of the generated executable. Defaults to the name of the Python file that was passed in.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-fm&lt;/code&gt; | &lt;code&gt;--fastmath&lt;/code&gt; (bool):&lt;br&gt; Perform aggressive optimisations speed on calculations at the cost of some precision. Defaults to off.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;-c&lt;/code&gt; | &lt;code&gt;--check&lt;/code&gt; (bool):&lt;br&gt; Check if the program will compile without actually compiling it. Defaults to off.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Python dependencies:&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Python version 3.10+&lt;br&gt; &#39;colorama&#39; module (install with pip install -r requirements.txt)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;C++ dependencies:&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;A recent version of the g++ compiler&lt;br&gt; The Boost C++ library; download here: &lt;a href=&#34;https://www.boost.org/users/history/version_1_79_0.html&#34;&gt;https://www.boost.org/users/history/version_1_79_0.html&lt;/a&gt; (put the folder into usr/gcc/include/)&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Run tests&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Unit tests&#xA;pytest tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Integration tests&#xA;pytest integration&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is Pycom?&lt;/h2&gt; &#xA;&lt;p&gt;Pycom is effectively a compiler for Python code, bringing it down to a native executable (20-30x the speed of Python interpretation) with C++ as &#39;intermediate representation&#39;. It supports almost all Pythonic syntax along with a lot of the standard library and inbuilt functions. To see what is currently supported and not supported, check the &lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#examples&#34;&gt;Examples&lt;/a&gt; section below.&lt;/p&gt; &#xA;&lt;h2&gt;Why and when use Pycom?&lt;/h2&gt; &#xA;&lt;p&gt;Python is slow. While many optimisations and new implementations of it have vastly improved its speed, generating native code that can run as a standalone executable from Python code has never really been done. As a result, no matter what, Python code has never hit levels of speed and portability that C/C++. Pycom aims to tackle this.&lt;/p&gt; &#xA;&lt;p&gt;Due to Pycom (currently) not supporting all Python features from all versions, you should only really use it if you want to run simple applications with nothing too crazy or pythonic going on (again, check &lt;a href=&#34;https://raw.githubusercontent.com/Omyyyy/pycom/main/#examples&#34;&gt;Examples&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;What Pycom supports and is good at:&lt;/p&gt; &#xA;&lt;p&gt;High iteration loops:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;for i in range(1, 1000001):&#xA;    if i % 3 == 0:&#xA;        print(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def is_prime(n):&#xA;    if n == 1:&#xA;        return 0&#xA;    for i in range(2, n):&#xA;        if n%i == 0:&#xA;            return 0&#xA;&#xA;    return 1&#xA;&#xA;def main():&#xA;    total = 0&#xA;    for i in range(1, 101):&#xA;        total += is_prime(i)&#xA;&#xA;    print(total)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Speed benchmarks and comparisons&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Benchmark&lt;/th&gt; &#xA;   &lt;th&gt;CPython&lt;/th&gt; &#xA;   &lt;th&gt;Pycom&lt;/th&gt; &#xA;   &lt;th&gt;Pycom with --fastmath&lt;/th&gt; &#xA;   &lt;th&gt;pypy&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Multiples of 3 and 5&lt;/td&gt; &#xA;   &lt;td&gt;9.383s&lt;/td&gt; &#xA;   &lt;td&gt;0.133s&lt;/td&gt; &#xA;   &lt;td&gt;0.106s&lt;/td&gt; &#xA;   &lt;td&gt;0.495s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Primes&lt;/td&gt; &#xA;   &lt;td&gt;17.127s&lt;/td&gt; &#xA;   &lt;td&gt;4.441s&lt;/td&gt; &#xA;   &lt;td&gt;3.994s&lt;/td&gt; &#xA;   &lt;td&gt;4.577s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Stack Operations&lt;/td&gt; &#xA;   &lt;td&gt;8.857s&lt;/td&gt; &#xA;   &lt;td&gt;2.132s&lt;/td&gt; &#xA;   &lt;td&gt;1.992s&lt;/td&gt; &#xA;   &lt;td&gt;3.113s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;(All of these can be found under &lt;code&gt;./benchmarks&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;h2&gt;Supported Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;All &#39;turing complete&#39; features of Python: &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;f&#39;&#39;&lt;/code&gt; strings&lt;/li&gt; &#xA; &lt;li&gt;Some in built functions&lt;/li&gt; &#xA; &lt;li&gt;Some math library functions&lt;/li&gt; &#xA; &lt;li&gt;List comprehensions&lt;/li&gt; &#xA; &lt;li&gt;Python-style arbitarily large intergers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Not supported yet&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pythonic ways of writing certain blocks (one line &lt;code&gt;if&lt;/code&gt;...&lt;code&gt;else&lt;/code&gt;, etc.)&lt;/li&gt; &#xA; &lt;li&gt;Multi-line string literals&lt;/li&gt; &#xA; &lt;li&gt;A lot of libraries included in stdlib&lt;/li&gt; &#xA; &lt;li&gt;Classes&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;finally&lt;/code&gt; keywords&lt;/li&gt; &#xA; &lt;li&gt;Heterogeneous lists; lists with more than one data type in them&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Small quirks and differences to CPython:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you declare an integer variable like &lt;code&gt;n = 3&lt;/code&gt;, this will be interpreted as a C++ 64 bit integer instead of Python&#39;s arbitrary size integers; to declare an integer of infinite size, use &lt;code&gt;n: int = 3&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Don&#39;t use semicolons in your Python source; Pycom will throw an error.&lt;/li&gt; &#xA; &lt;li&gt;Cannot support an &lt;code&gt;if __name__ == &#34;__main__&#34;: &lt;/code&gt; type thing; the &lt;code&gt;main()&lt;/code&gt; function is already entry point&lt;/li&gt; &#xA; &lt;li&gt;If you have no functions in your code, you can do everything as you normally would:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;print(&#34;Hello, World&#34;) # This will compile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;But if you have at least one user defined function, the starting point needs to be in a main() function block, as such:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def printhello():&#xA;    print(&#34;Hello!&#34;)&#xA;&#xA;def main():&#xA;    printhello() &#xA;&#xA;# Will compile &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def printhello():&#xA;    print(&#34;Hello!&#34;)&#xA;&#xA;printhello() &#xA;&#xA;# Will not compile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s inconvenient and the latter may be supported sometime, but this is just how it is for now. Also, if you do have a &lt;code&gt;main()&lt;/code&gt; function, it cannot return a value as it an entry point. The compiler will throw an error.&lt;/p&gt; &#xA;&lt;p&gt;I will work on trying to remove these exceptions and quirks and try to make Pycom and CPython completely identical, but right now, it is quite experimental and has quite a bit of room for improvement.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>facebookresearch/faiss</title>
    <updated>2022-07-30T01:32:57Z</updated>
    <id>tag:github.com,2022-07-30:/facebookresearch/faiss</id>
    <link href="https://github.com/facebookresearch/faiss" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A library for efficient similarity search and clustering of dense vectors.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Faiss&lt;/h1&gt; &#xA;&lt;p&gt;Faiss is a library for efficient similarity search and clustering of dense vectors. It contains algorithms that search in sets of vectors of any size, up to ones that possibly do not fit in RAM. It also contains supporting code for evaluation and parameter tuning. Faiss is written in C++ with complete wrappers for Python/numpy. Some of the most useful algorithms are implemented on the GPU. It is developed primarily at &lt;a href=&#34;https://ai.facebook.com/&#34;&gt;Facebook AI Research&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;News&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/faiss/main/CHANGELOG.md&#34;&gt;CHANGELOG.md&lt;/a&gt; for detailed information about latest features.&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Faiss contains several methods for similarity search. It assumes that the instances are represented as vectors and are identified by an integer, and that the vectors can be compared with L2 (Euclidean) distances or dot products. Vectors that are similar to a query vector are those that have the lowest L2 distance or the highest dot product with the query vector. It also supports cosine similarity, since this is a dot product on normalized vectors.&lt;/p&gt; &#xA;&lt;p&gt;Some of the methods, like those based on binary vectors and compact quantization codes, solely use a compressed representation of the vectors and do not require to keep the original vectors. This generally comes at the cost of a less precise search but these methods can scale to billions of vectors in main memory on a single server. Other methods, like HNSW and NSG add an indexing structure on top of the raw vectors to make searching more efficient.&lt;/p&gt; &#xA;&lt;p&gt;The GPU implementation can accept input from either CPU or GPU memory. On a server with GPUs, the GPU indexes can be used a drop-in replacement for the CPU indexes (e.g., replace &lt;code&gt;IndexFlatL2&lt;/code&gt; with &lt;code&gt;GpuIndexFlatL2&lt;/code&gt;) and copies to/from GPU memory are handled automatically. Results will be faster however if both input and output remain resident on the GPU. Both single and multi-GPU usage is supported.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;Faiss comes with precompiled libraries for Anaconda in Python, see &lt;a href=&#34;https://anaconda.org/pytorch/faiss-cpu&#34;&gt;faiss-cpu&lt;/a&gt; and &lt;a href=&#34;https://anaconda.org/pytorch/faiss-gpu&#34;&gt;faiss-gpu&lt;/a&gt;. The library is mostly implemented in C++, the only dependency is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms&#34;&gt;BLAS&lt;/a&gt; implementation. Optional GPU support is provided via CUDA, and the Python interface is also optional. It compiles with cmake. See &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/faiss/main/INSTALL.md&#34;&gt;INSTALL.md&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;How Faiss works&lt;/h2&gt; &#xA;&lt;p&gt;Faiss is built around an index type that stores a set of vectors, and provides a function to search in them with L2 and/or dot product vector comparison. Some index types are simple baselines, such as exact search. Most of the available indexing structures correspond to various trade-offs with respect to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;search time&lt;/li&gt; &#xA; &lt;li&gt;search quality&lt;/li&gt; &#xA; &lt;li&gt;memory used per index vector&lt;/li&gt; &#xA; &lt;li&gt;training time&lt;/li&gt; &#xA; &lt;li&gt;adding time&lt;/li&gt; &#xA; &lt;li&gt;need for external data for unsupervised training&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The optional GPU implementation provides what is likely (as of March 2017) the fastest exact and approximate (compressed-domain) nearest neighbor search implementation for high-dimensional vectors, fastest Lloyd&#39;s k-means, and fastest small k-selection algorithm known. &lt;a href=&#34;https://arxiv.org/abs/1702.08734&#34;&gt;The implementation is detailed here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Full documentation of Faiss&lt;/h2&gt; &#xA;&lt;p&gt;The following are entry points for documentation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the full documentation can be found on the &lt;a href=&#34;http://github.com/facebookresearch/faiss/wiki&#34;&gt;wiki page&lt;/a&gt;, including a &lt;a href=&#34;https://github.com/facebookresearch/faiss/wiki/Getting-started&#34;&gt;tutorial&lt;/a&gt;, a &lt;a href=&#34;https://github.com/facebookresearch/faiss/wiki/FAQ&#34;&gt;FAQ&lt;/a&gt; and a &lt;a href=&#34;https://github.com/facebookresearch/faiss/wiki/Troubleshooting&#34;&gt;troubleshooting section&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://faiss.ai/&#34;&gt;doxygen documentation&lt;/a&gt; gives per-class information extracted from code comments&lt;/li&gt; &#xA; &lt;li&gt;to reproduce results from our research papers, &lt;a href=&#34;https://arxiv.org/abs/1609.01882&#34;&gt;Polysemous codes&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/1702.08734&#34;&gt;Billion-scale similarity search with GPUs&lt;/a&gt;, refer to the &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/faiss/main/benchs/README.md&#34;&gt;benchmarks README&lt;/a&gt;. For &lt;a href=&#34;https://arxiv.org/abs/1804.09996&#34;&gt; Link and code: Fast indexing with graphs and compact regression codes&lt;/a&gt;, see the &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/faiss/main/benchs/link_and_code&#34;&gt;link_and_code README&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Authors&lt;/h2&gt; &#xA;&lt;p&gt;The main authors of Faiss are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jegou&#34;&gt;Herv√© J√©gou&lt;/a&gt; initiated the Faiss project and wrote its first implementation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mdouze&#34;&gt;Matthijs Douze&lt;/a&gt; implemented most of the CPU Faiss&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wickedfoo&#34;&gt;Jeff Johnson&lt;/a&gt; implemented all of the GPU Faiss&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/beauby&#34;&gt;Lucas Hosseini&lt;/a&gt; implemented the binary indexes and the build system&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/KinglittleQ&#34;&gt;Chengqi Deng&lt;/a&gt; implemented NSG, NNdescent and much of the additive quantization code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;p&gt;Reference to cite when you use Faiss in a research paper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@article{johnson2019billion,&#xA;  title={Billion-scale similarity search with {GPUs}},&#xA;  author={Johnson, Jeff and Douze, Matthijs and J{\&#39;e}gou, Herv{\&#39;e}},&#xA;  journal={IEEE Transactions on Big Data},&#xA;  volume={7},&#xA;  number={3},&#xA;  pages={535--547},&#xA;  year={2019},&#xA;  publisher={IEEE}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Join the Faiss community&lt;/h2&gt; &#xA;&lt;p&gt;For public discussion of Faiss or for questions, there is a Facebook group at &lt;a href=&#34;https://www.facebook.com/groups/faissusers/&#34;&gt;https://www.facebook.com/groups/faissusers/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We monitor the &lt;a href=&#34;http://github.com/facebookresearch/faiss/issues&#34;&gt;issues page&lt;/a&gt; of the repository. You can report bugs, ask questions, etc.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Faiss is MIT-licensed.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>taichi-dev/taichi</title>
    <updated>2022-07-30T01:32:57Z</updated>
    <id>tag:github.com,2022-07-30:/taichi-dev/taichi</id>
    <link href="https://github.com/taichi-dev/taichi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Productive &amp; portable high-performance programming in Python.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img width=&#34;500px&#34; src=&#34;https://github.com/taichi-dev/taichi/raw/master/misc/logo.png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/taichi-dev/taichi?color=blue&amp;amp;label=Latest%20Release&#34; alt=&#34;Latest Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pepy.tech/project/taichi&#34;&gt;&lt;img src=&#34;https://pepy.tech/badge/taichi&#34; alt=&#34;downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/taichi/actions/workflows/testing.yml&#34;&gt;&lt;img src=&#34;https://github.com/taichi-dev/taichi/actions/workflows/testing.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/taichi/actions/workflows/release.yml&#34;&gt;&lt;img src=&#34;https://github.com/taichi-dev/taichi/actions/workflows/release.yml/badge.svg?sanitize=true&#34; alt=&#34;Nightly Release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://join.slack.com/t/taichicommunity/shared_invite/zt-14ic8j6no-Fd~wKNpfskXLfqDr58Tddg&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/join-us%20on%20slack-gray.svg?longCache=true&amp;amp;logo=slack&amp;amp;colorB=red&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install taichi  # Install Taichi Lang&#xA;ti gallery          # Launch demo gallery&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;What is Taichi Lang?&lt;/h2&gt; &#xA;&lt;p&gt;Taichi Lang is an open-source, imperative, parallel programming language for high-performance numerical computation. It is embedded in Python and uses just-in-time (JIT) compiler frameworks, for example LLVM, to offload the compute-intensive Python code to the native GPU or CPU instructions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/raw/master/python/taichi/examples/simulation/fractal.py#L1-L31&#34;&gt; &lt;img src=&#34;https://github.com/taichi-dev/public_files/raw/master/taichi/fractal_code.png&#34; height=&#34;270px&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fractal_small.gif&#34; height=&#34;270px&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The language has broad applications spanning real-time physical simulation, numberical computation, augmented reality, artificial intelligence, vision and robotics, visual effects in films and games, general-purpose computing, and much more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/raw/master/python/taichi/examples/simulation/mpm128.py&#34;&gt;&lt;img src=&#34;https://github.com/taichi-dev/public_files/raw/master/taichi/mpm128.gif&#34; height=&#34;192px&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/quantaichi&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/smoke_3d.gif&#34; height=&#34;192px&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/taichi/raw/master/python/taichi/examples/rendering/sdf_renderer.py&#34;&gt;&lt;img src=&#34;https://github.com/taichi-dev/public_files/raw/master/taichi/sdf_renderer.jpg&#34; height=&#34;192px&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/taichi/raw/master/python/taichi/examples/simulation/euler.py&#34;&gt;&lt;img src=&#34;https://github.com/taichi-dev/public_files/raw/master/taichi/euler.gif&#34; height=&#34;192px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taichi-dev/quantaichi&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/elastic_letters.gif&#34; height=&#34;213px&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/quantaichi&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fluid_with_bunnies.gif&#34; height=&#34;213px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taichi-dev/taichi/master/#demos&#34;&gt;...More&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why Taichi Lang?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Built around Python: Taichi Lang shares almost the same syntax with Python, allowing you to write algorithms with minimal language barrier. It is also well integrated into the Python ecosystem, including NumPy and PyTorch.&lt;/li&gt; &#xA; &lt;li&gt;Flexibility: Taichi Lang provides a set of generic data containers known as &lt;em&gt;SNode&lt;/em&gt; (/Ààsno äd/), an effective mechanism for composing hierarchical, multi-dimensional fields. This can cover many use patterns in numerical simulation (e.g. &lt;a href=&#34;https://docs.taichi-lang.org/docs/sparse&#34;&gt;spatially sparse computing&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Performance: With the &lt;code&gt;@ti.kernel&lt;/code&gt; decorator, Taichi Lang&#39;s JIT compiler automatically compiles your Python functions into efficient GPU or CPU machine code for parallel execution.&lt;/li&gt; &#xA; &lt;li&gt;Portability: Write your code once and run it everywhere. Currently, Taichi Lang supports most mainstream GPU APIs, such as CUDA and Vulkan.&lt;/li&gt; &#xA; &lt;li&gt;... and many more features! A cross-platform, Vulkan-based 3D visualizer, &lt;a href=&#34;https://docs.taichi-lang.org/docs/differentiable_programming&#34;&gt;differentiable programming&lt;/a&gt;, &lt;a href=&#34;https://github.com/taichi-dev/quantaichi&#34;&gt;quantized computation&lt;/a&gt; (experimental), etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Prerequisites&lt;/summary&gt; &#xA; &lt;!--TODO: Precise OS versions--&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Operating systems &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;Windows&lt;/li&gt; &#xA;    &lt;li&gt;Linux&lt;/li&gt; &#xA;    &lt;li&gt;macOS&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;li&gt;Python: 3.6 ~ 3.10 (64-bit only)&lt;/li&gt; &#xA;  &lt;li&gt;Compute backends &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;x64/ARM CPUs&lt;/li&gt; &#xA;    &lt;li&gt;CUDA&lt;/li&gt; &#xA;    &lt;li&gt;Vulkan&lt;/li&gt; &#xA;    &lt;li&gt;OpenGL (4.3+)&lt;/li&gt; &#xA;    &lt;li&gt;Apple Metal&lt;/li&gt; &#xA;    &lt;li&gt;WebAssembly (experiemental)&lt;/li&gt; &#xA;   &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Use Python&#39;s package installer &lt;strong&gt;pip&lt;/strong&gt; to install Taichi Lang:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install --upgrade taichi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;We also provide a nightly package. Note that nighly packages may crash because they are not fully tested. We cannot guarantee their validity, and you are at your own risk trying out our latest, untested features. The nightly packages can be installed from our self-hosted PyPI (Using self-hosted PyPI allows us to provide more frequent releases over a longer period of time)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install -i https://pypi.taichi.graphics/simple/ taichi-nightly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run your &#34;Hello, world!&#34;&lt;/h3&gt; &#xA;&lt;p&gt;Here is how you can program a 2D fractal in Taichi:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# python/taichi/examples/simulation/fractal.py&#xA;&#xA;import taichi as ti&#xA;&#xA;ti.init(arch=ti.gpu)&#xA;&#xA;n = 320&#xA;pixels = ti.field(dtype=float, shape=(n * 2, n))&#xA;&#xA;&#xA;@ti.func&#xA;def complex_sqr(z):&#xA;    return ti.Vector([z[0]**2 - z[1]**2, z[1] * z[0] * 2])&#xA;&#xA;&#xA;@ti.kernel&#xA;def paint(t: float):&#xA;    for i, j in pixels:  # Parallelized over all pixels&#xA;        c = ti.Vector([-0.8, ti.cos(t) * 0.2])&#xA;        z = ti.Vector([i / n - 1, j / n - 0.5]) * 2&#xA;        iterations = 0&#xA;        while z.norm() &amp;lt; 20 and iterations &amp;lt; 50:&#xA;            z = complex_sqr(z) + c&#xA;            iterations += 1&#xA;        pixels[i, j] = 1 - iterations * 0.02&#xA;&#xA;&#xA;gui = ti.GUI(&#34;Julia Set&#34;, res=(n * 2, n))&#xA;&#xA;for i in range(1000000):&#xA;    paint(i * 0.03)&#xA;    gui.set_image(pixels)&#xA;    gui.show()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;If Taichi Lang is properly installed, you should get the animation below üéâ:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/raw/master/python/taichi/examples/simulation/fractal.py#L1-L31&#34;&gt; &lt;/a&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fractal_small.gif&#34; height=&#34;270px&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://docs.taichi-lang.org&#34;&gt;Get started&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Build from source&lt;/h3&gt; &#xA;&lt;p&gt;If you wish to try our our experimental features or build Taichi Lang for your own environments, see &lt;a href=&#34;https://docs.taichi-lang.org/docs/dev_install&#34;&gt;Developer installation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.taichi-lang.org/&#34;&gt;Technical documents&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.taichi-lang.org/api/&#34;&gt;API Reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.taichi-lang.org/blog&#34;&gt;Blog&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Kudos to all of our amazing contributors! Taichi Lang thrives through open-source. In that spirit, we welcome all kinds of contributions from the community. If you would like to participate, check out the &lt;a href=&#34;https://raw.githubusercontent.com/taichi-dev/taichi/master/CONTRIBUTING.md&#34;&gt;Contribution Guidelines&lt;/a&gt; first.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/graphs/contributors&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/contributors_taichi-dev_taichi_12.png&#34; width=&#34;800px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Contributor avatars are randomly shuffled.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Taichi Lang is distributed under the terms of Apache License (Version 2.0).&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/taichi-dev/taichi/raw/master/LICENSE&#34;&gt;Apache License&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;h3&gt;Event&lt;/h3&gt; &#xA;&lt;p&gt;Voxel Challenge 2022 is open for &lt;a href=&#34;https://github.com/taichi-dev/voxel-challenge/issues/11&#34;&gt;submissions&lt;/a&gt; until 18th May. Find out more &lt;a href=&#34;https://github.com/taichi-dev/community/tree/main/events/voxel-challenge&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Join our discussions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://join.slack.com/t/taichicommunity/shared_invite/zt-14ic8j6no-Fd~wKNpfskXLfqDr58Tddg&#34;&gt;Slack Channel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/discussions&#34;&gt;GitHub Discussions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://forum.taichi.graphics/&#34;&gt;Â§™ÊûÅÁºñÁ®ãËØ≠Ë®Ä‰∏≠ÊñáËÆ∫Âùõ&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Report an issue&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you spot an technical or documentation issue, file an issue at &lt;a href=&#34;https://github.com/taichi-dev/taichi/issues&#34;&gt;GitHub Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you spot any security issue, mail directly to &lt;a href=&#34;mailto:security@taichi.graphics?subject = Taichi Security Problem&#34;&gt;&lt;/a&gt;&lt;a href=&#34;mailto:security@taichi.graphics&#34;&gt;security@taichi.graphics&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Contact us&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://taichicommunity.slack.com/join/shared_invite/zt-14ic8j6no-Fd~wKNpfskXLfqDr58Tddg#/shared-invite/email&#34;&gt;Slack&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;WeChat: Drop us a message at &lt;a href=&#34;mailto:community@taichi.graphics&#34;&gt;&lt;/a&gt;&lt;a href=&#34;mailto:community@taichi.graphics&#34;&gt;community@taichi.graphics&lt;/a&gt; first, and we&#39;ll follow up.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;h3&gt;Demos&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi/tree/master/python/taichi/examples&#34;&gt;Taichi Lang examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/advanced_examples&#34;&gt;Advanced Taichi Lang examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/awesome-taichi&#34;&gt;Awesome Taichi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/difftaichi&#34;&gt;DiffTaichi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi_elements&#34;&gt;Taichi elements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichi_houdini&#34;&gt;Taichi Houdini&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/links.md&#34;&gt;More...&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Lectures &amp;amp; talks&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SIGGRAPH 2020 course on Taichi basics: &lt;a href=&#34;https://youtu.be/Y0-76n3aZFA&#34;&gt;YouTube&lt;/a&gt;, &lt;a href=&#34;https://www.bilibili.com/video/BV1kA411n7jk/&#34;&gt;Bilibili&lt;/a&gt;, &lt;a href=&#34;https://yuanming.taichi.graphics/publication/2020-taichi-tutorial/taichi-tutorial.pdf&#34;&gt;slides (pdf)&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Chinagraph 2020 Áî®Â§™ÊûÅÁºñÂÜôÁâ©ÁêÜÂºïÊìé: &lt;a href=&#34;https://www.bilibili.com/video/BV1gA411j7H5&#34;&gt;ÂìîÂì©ÂìîÂì©&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;GAMES 201 È´òÁ∫ßÁâ©ÁêÜÂºïÊìéÂÆûÊàòÊåáÂçó 2020: &lt;a href=&#34;https://github.com/taichi-dev/games201&#34;&gt;ËØæ‰ª∂&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Â§™ÊûÅÂõæÂΩ¢ËØæÁ¨¨‰∏ÄÂ≠£Ôºö&lt;a href=&#34;https://github.com/taichiCourse01&#34;&gt;ËØæ‰ª∂&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/taichi-dev/taichicon&#34;&gt;TaichiCon&lt;/a&gt;: Taichi Developer Conferences&lt;/li&gt; &#xA; &lt;li&gt;More to come...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Citations&lt;/h3&gt; &#xA;&lt;p&gt;If you use Taichi Lang in your research, please cite the corresponding papers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://yuanming.taichi.graphics/publication/2019-taichi/taichi-lang.pdf&#34;&gt;&lt;strong&gt;(SIGGRAPH Asia 2019) Taichi: High-Performance Computation on Sparse Data Structures&lt;/strong&gt;&lt;/a&gt; &lt;a href=&#34;https://youtu.be/wKw8LMF3Djo&#34;&gt;[Video]&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/taichi_bibtex.txt&#34;&gt;[BibTex]&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/taichi&#34;&gt;[Code]&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://arxiv.org/abs/1910.00935&#34;&gt;&lt;strong&gt;(ICLR 2020) DiffTaichi: Differentiable Programming for Physical Simulation&lt;/strong&gt;&lt;/a&gt; &lt;a href=&#34;https://www.youtube.com/watch?v=Z1xvAZve9aE&#34;&gt;[Video]&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/difftaichi_bibtex.txt&#34;&gt;[BibTex]&lt;/a&gt; &lt;a href=&#34;https://github.com/yuanming-hu/difftaichi&#34;&gt;[Code]&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://yuanming.taichi.graphics/publication/2021-quantaichi/quantaichi.pdf&#34;&gt;&lt;strong&gt;(SIGGRAPH 2021) QuanTaichi: A Compiler for Quantized Simulations&lt;/strong&gt;&lt;/a&gt; &lt;a href=&#34;https://www.youtube.com/watch?v=0jdrAQOxJlY&#34;&gt;[Video]&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/quantaichi_bibtex.txt&#34;&gt;[BibTex]&lt;/a&gt; &lt;a href=&#34;https://github.com/taichi-dev/quantaichi&#34;&gt;[Code]&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>