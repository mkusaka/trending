<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-05T01:25:14Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bombela/backward-cpp</title>
    <updated>2023-04-05T01:25:14Z</updated>
    <id>tag:github.com,2023-04-05:/bombela/backward-cpp</id>
    <link href="https://github.com/bombela/backward-cpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A beautiful stack trace pretty printer for C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Backward-cpp &lt;a href=&#34;http://www.conan.io/source/backward/1.3.0/Manu343726/testing&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/conan.io-backward%2F1.3.0-green.svg?logo=data:image/png;base64%2CiVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAMAAAAolt3jAAAA1VBMVEUAAABhlctjlstkl8tlmMtlmMxlmcxmmcxnmsxpnMxpnM1qnc1sn85voM91oM11oc1xotB2oc56pNF6pNJ2ptJ8ptJ8ptN9ptN8p9N5qNJ9p9N9p9R8qtOBqdSAqtOAqtR%2BrNSCrNJ/rdWDrNWCsNWCsNaJs9eLs9iRvNuVvdyVv9yXwd2Zwt6axN6dxt%2Bfx%2BChyeGiyuGjyuCjyuGly%2BGlzOKmzOGozuKoz%2BKqz%2BOq0OOv1OWw1OWw1eWx1eWy1uay1%2Baz1%2Baz1%2Bez2Oe02Oe12ee22ujUGwH3AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBQkREyOxFIh/AAAAiklEQVQI12NgAAMbOwY4sLZ2NtQ1coVKWNvoc/Eq8XDr2wB5Ig62ekza9vaOqpK2TpoMzOxaFtwqZua2Bm4makIM7OzMAjoaCqYuxooSUqJALjs7o4yVpbowvzSUy87KqSwmxQfnsrPISyFzWeWAXCkpMaBVIC4bmCsOdgiUKwh3JojLgAQ4ZCE0AMm2D29tZwe6AAAAAElFTkSuQmCC&#34; alt=&#34;badge&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Backward is a beautiful stack trace pretty printer for C++.&lt;/p&gt; &#xA;&lt;p&gt;If you are bored to see this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bombela/backward-cpp/master/doc/rude.png&#34; alt=&#34;default trace&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Backward will spice it up for you:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bombela/backward-cpp/master/doc/pretty.png&#34; alt=&#34;pretty stackstrace&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There is not much to say. Of course it will be able to display the code snippets only if the source files are accessible (else see trace #4 in the example).&lt;/p&gt; &#xA;&lt;p&gt;All &#34;Source&#34; lines and code snippet prefixed by a pipe &#34;|&#34; are frames inline the next frame. You can see that for the trace #1 in the example, the function &lt;code&gt;you_shall_not_pass()&lt;/code&gt; was inlined in the function &lt;code&gt;...read2::do_test()&lt;/code&gt; by the compiler.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h4&gt;Install backward.hpp&lt;/h4&gt; &#xA;&lt;p&gt;Backward is a header only library. So installing Backward is easy, simply drop a copy of &lt;code&gt;backward.hpp&lt;/code&gt; along with your other source files in your C++ project. You can also use a git submodule or really any other way that best fits your environment, as long as you can include &lt;code&gt;backward.hpp&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Install backward.cpp&lt;/h4&gt; &#xA;&lt;p&gt;If you want Backward to automatically print a stack trace on most common fatal errors (segfault, abort, un-handled exception...), simply add a copy of &lt;code&gt;backward.cpp&lt;/code&gt; to your project, and don&#39;t forget to tell your build system.&lt;/p&gt; &#xA;&lt;p&gt;The code in &lt;code&gt;backward.cpp&lt;/code&gt; is trivial anyway, you can simply copy what it&#39;s doing at your convenience.&lt;/p&gt; &#xA;&lt;p&gt;Note for &lt;a href=&#34;https://github.com/facebook/folly&#34;&gt;folly&lt;/a&gt; library users: must define &lt;code&gt;backward::SignalHandling sh;&lt;/code&gt; after &lt;code&gt;folly::init(&amp;amp;argc, &amp;amp;argv);&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration &amp;amp; Dependencies&lt;/h2&gt; &#xA;&lt;h3&gt;Integration with CMake&lt;/h3&gt; &#xA;&lt;p&gt;If you are using CMake and want to use its configuration abilities to save you the trouble, you can easily integrate Backward, depending on how you obtained the library.&lt;/p&gt; &#xA;&lt;h4&gt;With &lt;code&gt;FetchContent()&lt;/code&gt;:&lt;/h4&gt; &#xA;&lt;p&gt;If you are using a recent version of CMake, you can integrate &lt;code&gt;backward&lt;/code&gt; via &lt;code&gt;FetchContent&lt;/code&gt; like below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;include(FetchContent)&#xA;&#xA;# Also requires one of: libbfd (gnu binutils), libdwarf, libdw (elfutils)&#xA;FetchContent_Declare(backward&#xA;        GIT_REPOSITORY https://github.com/bombela/backward-cpp&#xA;        GIT_TAG v1.6)&#xA;FetchContent_MakeAvailable(backward)&#xA;&#xA;file(GLOB_RECURSE SOURCES CONFIGURE_DEPENDS src/*.cpp)&#xA;add_executable(example ${SOURCES} ${BACKWARD_ENABLE}) # Notice the &#34;BACKWARD_ENABLE&#34; here&#xA;add_backward(example)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;As a subdirectory:&lt;/h4&gt; &#xA;&lt;p&gt;In this case you have a subdirectory containing the whole repository of Backward (eg.: using git-submodules), in this case you can do:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;add_subdirectory(/path/to/backward-cpp)&#xA;&#xA;# This will add backward.cpp to your target&#xA;add_executable(mytarget mysource.cpp ${BACKWARD_ENABLE})&#xA;&#xA;# This will add libraries, definitions and include directories needed by backward&#xA;# by setting each property on the target.&#xA;add_backward(mytarget)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Modifying CMAKE_MODULE_PATH&lt;/h4&gt; &#xA;&lt;p&gt;In this case you can have Backward installed as a subdirectory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;list(APPEND CMAKE_MODULE_PATH /path/to/backward-cpp)&#xA;find_package(Backward)&#xA;&#xA;# This will add libraries, definitions and include directories needed by backward&#xA;# through an IMPORTED target.&#xA;target_link_libraries(mytarget PUBLIC Backward::Backward)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that this is equivalent to using the the approach that uses &lt;code&gt;add_subdirectory()&lt;/code&gt;, however it uses cmake&#39;s &lt;a href=&#34;https://cmake.org/Wiki/CMake/Tutorials/Exporting_and_Importing_Targets&#34;&gt;imported target&lt;/a&gt; mechanism.&lt;/p&gt; &#xA;&lt;h4&gt;Installation through a regular package manager&lt;/h4&gt; &#xA;&lt;p&gt;In this case you have obtained Backward through a package manager.&lt;/p&gt; &#xA;&lt;p&gt;Packages currently available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://anaconda.org/conda-forge/backward-cpp&#34;&gt;conda-forge&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;find_package(Backward)&#xA;&#xA;# This will add libraries, definitions and include directories needed by backward&#xA;# through an IMPORTED target.&#xA;target_link_libraries(mytarget PUBLIC Backward::Backward)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Libraries to unwind the stack&lt;/h3&gt; &#xA;&lt;p&gt;On Linux and macOS, backtrace can back-trace or &#34;walk&#34; the stack using the following libraries:&lt;/p&gt; &#xA;&lt;h4&gt;unwind&lt;/h4&gt; &#xA;&lt;p&gt;Unwind comes from libgcc, but there is an equivalent inside clang itself. With unwind, the stacktrace is as accurate as it can possibly be, since this is used by the C++ runtine in gcc/clang for stack unwinding on exception.&lt;/p&gt; &#xA;&lt;p&gt;Normally libgcc is already linked to your program by default.&lt;/p&gt; &#xA;&lt;h4&gt;libunwind from the &lt;a href=&#34;https://github.com/libunwind/libunwind&#34;&gt;libunwind project&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get install binutils-dev (or equivalent)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Libunwind provides, in some cases, a more accurate stacktrace as it knows to decode signal handler frames and lets us edit the context registers when unwinding, allowing stack traces over bad function references.&lt;/p&gt; &#xA;&lt;p&gt;For best results make sure you are using libunwind 1.3 or later, which added &lt;code&gt;unw_init_local2&lt;/code&gt; and support for handling signal frames.&lt;/p&gt; &#xA;&lt;p&gt;CMake will warn you when configuring if your libunwind version doesn&#39;t support signal frames.&lt;/p&gt; &#xA;&lt;p&gt;On macOS clang provides a libunwind API compatible library as part of its environment, so no third party libraries are necessary.&lt;/p&gt; &#xA;&lt;h3&gt;Compile with debug info&lt;/h3&gt; &#xA;&lt;p&gt;You need to compile your project with generation of debug symbols enabled, usually &lt;code&gt;-g&lt;/code&gt; with clang++ and g++.&lt;/p&gt; &#xA;&lt;p&gt;Note that you can use &lt;code&gt;-g&lt;/code&gt; with any level of optimization, with modern debug information encoding like DWARF, it only takes space in the binary (it&#39;s not loaded in memory until your debugger or Backward makes use of it, don&#39;t worry), and it doesn&#39;t impact the code generation (at least on GNU/Linux x86_64 for what I know).&lt;/p&gt; &#xA;&lt;p&gt;If you are missing debug information, the stack trace will lack details about your sources.&lt;/p&gt; &#xA;&lt;h3&gt;Libraries to read the debug info&lt;/h3&gt; &#xA;&lt;p&gt;Backward supports pretty printed stack traces on GNU/Linux, macOS and Windows, it will compile fine under other platforms but will not do anything. &lt;strong&gt;Pull requests are welcome :)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Also, by default you will get a really basic stack trace, based on the &lt;code&gt;backtrace_symbols&lt;/code&gt; API:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bombela/backward-cpp/master/doc/nice.png&#34; alt=&#34;default trace&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You will need to install some dependencies to get the ultimate stack trace. Three libraries are currently supported, the only difference is which one is the easiest for you to install, so pick your poison:&lt;/p&gt; &#xA;&lt;h4&gt;libbfd from the &lt;a href=&#34;http://www.gnu.org/software/binutils/&#34;&gt;GNU/binutils&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get install binutils-dev (or equivalent)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And do not forget to link with the lib: &lt;code&gt;g++/clang++ -lbfd -ldl ...&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This library requires dynamic loading. Which is provided by the library &lt;code&gt;dl&lt;/code&gt;. Hence why we also link with &lt;code&gt;-ldl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then define the following before every inclusion of &lt;code&gt;backward.hpp&lt;/code&gt; (don&#39;t forget to update &lt;code&gt;backward.cpp&lt;/code&gt; as well):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#define BACKWARD_HAS_BFD 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;libdw from the &lt;a href=&#34;https://fedorahosted.org/elfutils/&#34;&gt;elfutils&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get install libdw-dev (or equivalent)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And do not forget to link with the lib and inform Backward to use it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#define BACKWARD_HAS_DW 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Of course you can simply add the define (&lt;code&gt;-DBACKWARD_HAS_...=1&lt;/code&gt;) and the linkage details in your build system and even auto-detect which library is installed, it&#39;s up to you.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;a href=&#34;https://sourceforge.net/projects/libdwarf/&#34;&gt;libdwarf&lt;/a&gt; and &lt;a href=&#34;http://www.mr511.de/software/english.html&#34;&gt;libelf&lt;/a&gt;&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;apt-get install libdwarf-dev (or equivalent)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And do not forget to link with the lib and inform Backward to use it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#define BACKWARD_HAS_DWARF 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are several alternative implementations of libdwarf and libelf that are API compatible so it&#39;s possible, although it hasn&#39;t been tested, to replace the ones used when developing backward (in bold, below):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;em&gt;libelf&lt;/em&gt;&lt;/strong&gt; by &lt;a href=&#34;http://www.mr511.de/software/english.html&#34;&gt;Michael &#34;Tired&#34; Riepe&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;em&gt;libdwarf&lt;/em&gt;&lt;/strong&gt; by &lt;a href=&#34;https://www.prevanders.net/dwarf.html&#34;&gt;David Anderson&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;libelf from &lt;a href=&#34;https://fedorahosted.org/elfutils/&#34;&gt;elfutils&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;libelf and libdwarf from FreeBSD&#39;s &lt;a href=&#34;https://sourceforge.net/p/elftoolchain/wiki/Home/&#34;&gt;ELF Tool Chain&lt;/a&gt; project&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Of course you can simply add the define (&lt;code&gt;-DBACKWARD_HAS_...=1&lt;/code&gt;) and the linkage details in your build system and even auto-detect which library is installed, it&#39;s up to you.&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s it, you are all set, you should be getting nice stack traces like the one at the beginning of this document.&lt;/p&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;If you don&#39;t want to limit yourself to the defaults offered by &lt;code&gt;backward.cpp&lt;/code&gt;, and you want to take some random stack traces for whatever reason and pretty print them the way you love or you decide to send them all to your buddies over the Internet, you will appreciate the simplicity of Backward&#39;s API.&lt;/p&gt; &#xA;&lt;h3&gt;Stacktrace&lt;/h3&gt; &#xA;&lt;p&gt;The StackTrace class lets you take a &#34;snapshot&#34; of the current stack. You can use it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using namespace backward;&#xA;StackTrace st; st.load_here(32);&#xA;Printer p; p.print(st);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The public methods are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class StackTrace { public:&#xA;&#x9;// Take a snapshot of the current stack, with at most &#34;trace_cnt_max&#34;&#xA;&#x9;// traces in it. The first trace is the most recent (ie the current&#xA;&#x9;// frame). You can also provide a trace address to load_from() assuming&#xA;&#x9;// the address is a valid stack frame (useful for signal handling traces).&#xA;&#x9;// Both function return size().&#xA;&#x9;size_t load_here(size_t trace_cnt_max)&#xA;&#x9;size_t load_from(void* address, size_t trace_cnt_max)&#xA;&#xA;&#x9;// The number of traces loaded. This can be less than &#34;trace_cnt_max&#34;.&#xA;&#x9;size_t size() const&#xA;&#xA;&#x9;// A unique id for the thread in which the trace was taken. The value&#xA;&#x9;// 0 means the stack trace comes from the main thread.&#xA;&#x9;size_t thread_id() const&#xA;&#xA;&#x9;// Retrieve a trace by index. 0 is the most recent trace, size()-1 is&#xA;&#x9;// the oldest one.&#xA;&#x9;Trace operator[](size_t trace_idx)&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;TraceResolver&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;TraceResolver&lt;/code&gt; does the heavy lifting, and intends to transform a simple &lt;code&gt;Trace&lt;/code&gt; from its address into a fully detailed &lt;code&gt;ResolvedTrace&lt;/code&gt; with the filename of the source, line numbers, inlined functions and so on.&lt;/p&gt; &#xA;&lt;p&gt;You can use it like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using namespace backward;&#xA;StackTrace st; st.load_here(32);&#xA;&#xA;TraceResolver tr; tr.load_stacktrace(st);&#xA;for (size_t i = 0; i &amp;lt; st.size(); ++i) {&#xA;&#x9;ResolvedTrace trace = tr.resolve(st[i]);&#xA;&#x9;std::cout &amp;lt;&amp;lt; &#34;#&#34; &amp;lt;&amp;lt; i&#xA;&#x9;&#x9;&amp;lt;&amp;lt; &#34; &#34; &amp;lt;&amp;lt; trace.object_filename&#xA;&#x9;&#x9;&amp;lt;&amp;lt; &#34; &#34; &amp;lt;&amp;lt; trace.object_function&#xA;&#x9;&#x9;&amp;lt;&amp;lt; &#34; [&#34; &amp;lt;&amp;lt; trace.addr &amp;lt;&amp;lt; &#34;]&#34;&#xA;&#x9;&amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The public methods are:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class TraceResolver { public:&#xA;&#x9;// Pre-load whatever is necessary from the stack trace.&#xA;&#x9;template &amp;lt;class ST&amp;gt;&#xA;&#x9;&#x9;void load_stacktrace(ST&amp;amp;)&#xA;&#xA;&#x9;// Resolve a trace. It takes a ResolvedTrace, because a `Trace` is&#xA;&#x9;// implicitly convertible to it.&#xA;&#x9;ResolvedTrace resolve(ResolvedTrace t)&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SnippetFactory&lt;/h3&gt; &#xA;&lt;p&gt;The SnippetFactory is a simple helper class to automatically load and cache source files in order to extract code snippets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class SnippetFactory { public:&#xA;&#x9;// A snippet is a list of line numbers and line contents.&#xA;&#x9;typedef std::vector&amp;lt;std::pair&amp;lt;size_t, std::string&amp;gt; &amp;gt; lines_t;&#xA;&#xA;&#x9;// Return a snippet starting at line_start with up to context_size lines.&#xA;&#x9;lines_t get_snippet(const std::string&amp;amp; filename,&#xA;&#x9;&#x9;&#x9;size_t line_start, size_t context_size)&#xA;&#xA;&#x9;// Return a combined snippet from two different locations and combine them.&#xA;&#x9;// context_size / 2 lines will be extracted from each location.&#xA;&#x9;lines_t get_combined_snippet(&#xA;&#x9;&#x9;&#x9;const std::string&amp;amp; filename_a, size_t line_a,&#xA;&#x9;&#x9;&#x9;const std::string&amp;amp; filename_b, size_t line_b,&#xA;&#x9;&#x9;&#x9;size_t context_size)&#xA;&#xA;&#x9;// Tries to return a unified snippet if the two locations from the same&#xA;&#x9;// file are close enough to fit inside one context_size, else returns&#xA;&#x9;// the equivalent of get_combined_snippet().&#xA;&#x9;lines_t get_coalesced_snippet(const std::string&amp;amp; filename,&#xA;&#x9;&#x9;&#x9;size_t line_a, size_t line_b, size_t context_size)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Printer&lt;/h3&gt; &#xA;&lt;p&gt;A simpler way to pretty print a stack trace to the terminal. It will automatically resolve the traces for you:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using namespace backward;&#xA;StackTrace st; st.load_here(32);&#xA;Printer p;&#xA;p.object = true;&#xA;p.color_mode = ColorMode::always;&#xA;p.address = true;&#xA;p.print(st, stderr);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can set a few options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Printer { public:&#xA;&#x9;// Print a little snippet of code if possible.&#xA;&#x9;bool snippet = true;&#xA;&#xA;&#x9;// Colorize the trace&#xA;&#x9;//  - ColorMode::automatic: Activate colors if possible. For example, when using a TTY on linux.&#xA;&#x9;//  - ColorMode::always: Always use colors.&#xA;&#x9;//  - ColorMode::never: Never use colors.&#xA;&#x9;bool color_mode = ColorMode::automatic;&#xA;&#xA;&#x9;// Add the addresses of every source location to the trace.&#xA;&#x9;bool address = false;&#xA;&#xA;&#x9;// Even if there is a source location, also prints the object&#xA;&#x9;// from where the trace came from.&#xA;&#x9;bool object = false;&#xA;&#xA;&#x9;// Resolve and print a stack trace to the given C FILE* object.&#xA;&#x9;// On linux, if the FILE* object is attached to a TTY,&#xA;&#x9;// color will be used if color_mode is set to automatic.&#xA;&#x9;template &amp;lt;typename StackTrace&amp;gt;&#xA;&#x9;&#x9;FILE* print(StackTrace&amp;amp; st, FILE* fp = stderr);&#xA;&#xA;&#x9;// Resolve and print a stack trace to the given std::ostream object.&#xA;&#x9;// Color will only be used if color_mode is set to always. &#xA;&#x9;template &amp;lt;typename ST&amp;gt;&#xA;&#x9;&#x9;std::ostream&amp;amp; print(ST&amp;amp; st, std::ostream&amp;amp; os);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;SignalHandling&lt;/h3&gt; &#xA;&lt;p&gt;A simple helper class that registers for you the most common signals and other callbacks to segfault, hardware exception, un-handled exception etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;backward.cpp&lt;/code&gt; simply uses it like that:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;backward::SignalHandling sh;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Creating the object registers all the different signals and hooks. Destroying this object doesn&#39;t do anything. It exposes only one method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool loaded() const // true if loaded with success&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Trace object&lt;/h3&gt; &#xA;&lt;p&gt;To keep the memory footprint of a loaded &lt;code&gt;StackTrace&lt;/code&gt; on the low-side, there a hierarchy of trace object, from a minimal &lt;code&gt;Trace &lt;/code&gt;to a &lt;code&gt;ResolvedTrace&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Simple trace&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Trace {&#xA;&#x9;void*  addr; // address of the trace&#xA;&#x9;size_t idx;  // its index (0 == most recent)&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Resolved trace&lt;/h4&gt; &#xA;&lt;p&gt;A &lt;code&gt;ResolvedTrace&lt;/code&gt; should contains a maximum of details about the location of the trace in the source code. Note that not all fields might be set.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct ResolvedTrace: public Trace {&#xA;&#xA;&#x9;struct SourceLoc {&#xA;&#x9;&#x9;std::string function;&#xA;&#x9;&#x9;std::string filename;&#xA;&#x9;&#x9;size_t      line;&#xA;&#x9;&#x9;size_t      col;&#xA;&#x9;};&#xA;&#xA;&#x9;// In which binary object this trace is located.&#xA;&#x9;std::string                    object_filename;&#xA;&#xA;&#x9;// The function in the object that contains the trace. This is not the same&#xA;&#x9;// as source.function which can be an function inlined in object_function.&#xA;&#x9;std::string                    object_function;&#xA;&#xA;&#x9;// The source location of this trace. It is possible for filename to be&#xA;&#x9;// empty and for line/col to be invalid (value 0) if this information&#xA;&#x9;// couldn&#39;t be deduced, for example if there is no debug information in the&#xA;&#x9;// binary object.&#xA;&#x9;SourceLoc                      source;&#xA;&#xA;&#x9;// An optional list of &#34;inliners&#34;. All of these sources locations where&#xA;&#x9;// inlined in the source location of the trace (the attribute right above).&#xA;&#x9;// This is especially useful when you compile with optimizations turned on.&#xA;&#x9;typedef std::vector&amp;lt;SourceLoc&amp;gt; source_locs_t;&#xA;&#x9;source_locs_t                  inliners;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contact and copyright&lt;/h2&gt; &#xA;&lt;p&gt;François-Xavier Bourlet &lt;a href=&#34;mailto:bombela@gmail.com&#34;&gt;bombela@gmail.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Copyright 2013-2017 Google Inc. All Rights Reserved. MIT License.&lt;/p&gt; &#xA;&lt;h3&gt;Disclaimer&lt;/h3&gt; &#xA;&lt;p&gt;Although this project is owned by Google Inc. this is not a Google supported or affiliated project.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>vit-vit/CTPL</title>
    <updated>2023-04-05T01:25:14Z</updated>
    <id>tag:github.com,2023-04-05:/vit-vit/CTPL</id>
    <link href="https://github.com/vit-vit/CTPL" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern and efficient C++ Thread Pool Library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CTPL&lt;/h1&gt; &#xA;&lt;p&gt;Modern and efficient C++ Thread Pool Library&lt;/p&gt; &#xA;&lt;p&gt;A thread pool is a programming pattern for parallel execution of jobs, &lt;a href=&#34;http://en.wikipedia.org/wiki/Thread_pool_pattern&#34;&gt;http://en.wikipedia.org/wiki/Thread_pool_pattern&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More specifically, there are some threads dedicated to the pool and a container of jobs. The jobs come to the pool dynamically. A job is fetched and deleted from the container when there is an idle thread. The job is then run on that thread.&lt;/p&gt; &#xA;&lt;p&gt;A thread pool is helpful when you want to minimize time of loading and destroying threads and when you want to limit the number of parallel jobs that run simultanuasly. For example, time consuming event handlers may be processed in a thread pool to make UI more responsive.&lt;/p&gt; &#xA;&lt;p&gt;Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;standard c++ language, tested to compile on MS Visual Studio 2013 (2012?), gcc 4.8.2 and mingw 4.8.1(with posix threads)&lt;/li&gt; &#xA; &lt;li&gt;simple but effiecient solution, one header only, no need to compile a binary library&lt;/li&gt; &#xA; &lt;li&gt;query the number of idle threads and resize the pool dynamically&lt;/li&gt; &#xA; &lt;li&gt;one API to push to the thread pool any collable object: lambdas, functors, functions, result of bind expression&lt;/li&gt; &#xA; &lt;li&gt;collable objects with variadic number of parameters plus index of the thread running the object&lt;/li&gt; &#xA; &lt;li&gt;automatic template argument deduction&lt;/li&gt; &#xA; &lt;li&gt;get returned value of any type with standard c++ futures&lt;/li&gt; &#xA; &lt;li&gt;get fired exceptions with standard c++ futures&lt;/li&gt; &#xA; &lt;li&gt;use for any purpose under Apache license&lt;/li&gt; &#xA; &lt;li&gt;two variants, one depends on Boost Lockfree Queue library, &lt;a href=&#34;http://boost.org&#34;&gt;http://boost.org&lt;/a&gt;, which is a header only library&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Sample usage&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;void first(int id) { std::cout &amp;lt;&amp;lt; &#34;hello from &#34; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &#39;\n&#39;; }&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt; struct Second { void operator()(int id) const { std::cout &amp;lt;&amp;lt; &#34;hello from &#34; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &#39;\n&#39;; } } second;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;code&gt; &lt;p&gt;&lt;code&gt;void third(int id, const std::string &amp;amp; additional_param) {}&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;int main () {&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; ctpl::thread_pool p(2 /* two threads in the pool */);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; p.push(first); // function&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; p.push(third, &#34;additional_param&#34;);&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; p.push( [] (int id){ std::cout &amp;lt;&amp;lt; &#34;hello from &#34; &amp;lt;&amp;lt; id &amp;lt;&amp;lt; &#39;\n&#39;; }); // lambda&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; p.push(std::ref(second)); // functor, reference&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; p.push(const_cast&amp;lt;const Second &amp;amp;&amp;gt;(second)); // functor, copy ctor&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt; p.push(std::move(second)); // functor, move ctor&lt;/code&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;}&lt;/code&gt;&lt;/p&gt; &lt;/code&gt;</summary>
  </entry>
  <entry>
    <title>spotify/annoy</title>
    <updated>2023-04-05T01:25:14Z</updated>
    <id>tag:github.com,2023-04-05:/spotify/annoy</id>
    <link href="https://github.com/spotify/annoy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Approximate Nearest Neighbors in C++/Python optimized for memory usage and loading/saving to disk&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Annoy&lt;/h2&gt; &#xA;&lt;p&gt;.. figure:: &lt;a href=&#34;https://raw.github.com/spotify/annoy/master/ann.png&#34;&gt;https://raw.github.com/spotify/annoy/master/ann.png&lt;/a&gt; :alt: Annoy example :align: center&lt;/p&gt; &#xA;&lt;p&gt;.. image:: &lt;a href=&#34;https://img.shields.io/travis/spotify/annoy/master.svg?style=flat&#34;&gt;https://img.shields.io/travis/spotify/annoy/master.svg?style=flat&lt;/a&gt; :target: &lt;a href=&#34;https://travis-ci.org/spotify/annoy&#34;&gt;https://travis-ci.org/spotify/annoy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. image:: &lt;a href=&#34;https://ci.appveyor.com/api/projects/status/github/spotify/annoy?svg=true&amp;amp;pendingText=windows%20-%20Pending&amp;amp;passingText=windows%20-%20OK&amp;amp;failingText=windows%20-%20Failing&#34;&gt;https://ci.appveyor.com/api/projects/status/github/spotify/annoy?svg=true&amp;amp;pendingText=windows%20-%20Pending&amp;amp;passingText=windows%20-%20OK&amp;amp;failingText=windows%20-%20Failing&lt;/a&gt; :target: &lt;a href=&#34;https://ci.appveyor.com/project/erikbern/annoy&#34;&gt;https://ci.appveyor.com/project/erikbern/annoy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. image:: &lt;a href=&#34;https://img.shields.io/pypi/v/annoy.svg?style=flat&#34;&gt;https://img.shields.io/pypi/v/annoy.svg?style=flat&lt;/a&gt; :target: &lt;a href=&#34;https://pypi.python.org/pypi/annoy&#34;&gt;https://pypi.python.org/pypi/annoy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Annoy (&lt;code&gt;Approximate Nearest Neighbors &amp;lt;http://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor&amp;gt;&lt;/code&gt;__ Oh Yeah) is a C++ library with Python bindings to search for points in space that are close to a given query point. It also creates large read-only file-based data structures that are &lt;code&gt;mmapped &amp;lt;https://en.wikipedia.org/wiki/Mmap&amp;gt;&lt;/code&gt;__ into memory so that many processes may share the same data.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;To install, simply do &lt;code&gt;pip install --user annoy&lt;/code&gt; to pull down the latest version from &lt;code&gt;PyPI &amp;lt;https://pypi.python.org/pypi/annoy&amp;gt;&lt;/code&gt;_.&lt;/p&gt; &#xA;&lt;p&gt;For the C++ version, just clone the repo and &lt;code&gt;#include &#34;annoylib.h&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;There are some other libraries to do nearest neighbor search. Annoy is almost as fast as the fastest libraries, (see below), but there is actually another feature that really sets Annoy apart: it has the ability to &lt;strong&gt;use static files as indexes&lt;/strong&gt;. In particular, this means you can &lt;strong&gt;share index across processes&lt;/strong&gt;. Annoy also decouples creating indexes from loading them, so you can pass around indexes as files and map them into memory quickly. Another nice thing of Annoy is that it tries to minimize memory footprint so the indexes are quite small.&lt;/p&gt; &#xA;&lt;p&gt;Why is this useful? If you want to find nearest neighbors and you have many CPU&#39;s, you only need to build the index once. You can also pass around and distribute static files to use in production environment, in Hadoop jobs, etc. Any process will be able to load (mmap) the index into memory and will be able to do lookups immediately.&lt;/p&gt; &#xA;&lt;p&gt;We use it at &lt;code&gt;Spotify &amp;lt;http://www.spotify.com/&amp;gt;&lt;/code&gt;__ for music recommendations. After running matrix factorization algorithms, every user/item can be represented as a vector in f-dimensional space. This library helps us search for similar users/items. We have many millions of tracks in a high-dimensional space, so memory usage is a prime concern.&lt;/p&gt; &#xA;&lt;p&gt;Annoy was built by &lt;code&gt;Erik Bernhardsson &amp;lt;http://www.erikbern.com&amp;gt;&lt;/code&gt;__ in a couple of afternoons during &lt;code&gt;Hack Week &amp;lt;http://labs.spotify.com/2013/02/15/organizing-a-hack-week/&amp;gt;&lt;/code&gt;__.&lt;/p&gt; &#xA;&lt;h2&gt;Summary of features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Euclidean distance &amp;lt;https://en.wikipedia.org/wiki/Euclidean_distance&amp;gt;&lt;/code&gt;&lt;strong&gt;, &lt;code&gt;Manhattan distance &amp;lt;https://en.wikipedia.org/wiki/Taxicab_geometry&amp;gt;&lt;/code&gt;&lt;/strong&gt;, &lt;code&gt;cosine distance &amp;lt;https://en.wikipedia.org/wiki/Cosine_similarity&amp;gt;&lt;/code&gt;&lt;strong&gt;, &lt;code&gt;Hamming distance &amp;lt;https://en.wikipedia.org/wiki/Hamming_distance&amp;gt;&lt;/code&gt;&lt;/strong&gt;, or &lt;code&gt;Dot (Inner) Product distance &amp;lt;https://en.wikipedia.org/wiki/Dot_product&amp;gt;&lt;/code&gt;__&lt;/li&gt; &#xA; &lt;li&gt;Cosine distance is equivalent to Euclidean distance of normalized vectors = sqrt(2-2*cos(u, v))&lt;/li&gt; &#xA; &lt;li&gt;Works better if you don&#39;t have too many dimensions (like &amp;lt;100) but seems to perform surprisingly well even up to 1,000 dimensions&lt;/li&gt; &#xA; &lt;li&gt;Small memory usage&lt;/li&gt; &#xA; &lt;li&gt;Lets you share memory between multiple processes&lt;/li&gt; &#xA; &lt;li&gt;Index creation is separate from lookup (in particular you can not add more items once the tree has been created)&lt;/li&gt; &#xA; &lt;li&gt;Native Python support, tested with 2.7, 3.6, and 3.7.&lt;/li&gt; &#xA; &lt;li&gt;Build index on disk to enable indexing big datasets that won&#39;t fit into memory (contributed by &lt;code&gt;Rene Hollander &amp;lt;https://github.com/ReneHollander&amp;gt;&lt;/code&gt;__)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Python code example&lt;/h2&gt; &#xA;&lt;p&gt;.. code-block:: python&lt;/p&gt; &#xA;&lt;p&gt;from annoy import AnnoyIndex import random&lt;/p&gt; &#xA;&lt;p&gt;f = 40 # Length of item vector that will be indexed&lt;/p&gt; &#xA;&lt;p&gt;t = AnnoyIndex(f, &#39;angular&#39;) for i in range(1000): v = [random.gauss(0, 1) for z in range(f)] t.add_item(i, v)&lt;/p&gt; &#xA;&lt;p&gt;t.build(10) # 10 trees t.save(&#39;test.ann&#39;)&lt;/p&gt; &#xA;&lt;h1&gt;...&lt;/h1&gt; &#xA;&lt;p&gt;u = AnnoyIndex(f, &#39;angular&#39;) u.load(&#39;test.ann&#39;) # super fast, will just mmap the file print(u.get_nns_by_item(0, 1000)) # will find the 1000 nearest neighbors&lt;/p&gt; &#xA;&lt;p&gt;Right now it only accepts integers as identifiers for items. Note that it will allocate memory for max(id)+1 items because it assumes your items are numbered 0 … n-1. If you need other id&#39;s, you will have to keep track of a map yourself.&lt;/p&gt; &#xA;&lt;h2&gt;Full Python API&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;AnnoyIndex(f, metric)&lt;/code&gt; returns a new index that&#39;s read-write and stores vector of &lt;code&gt;f&lt;/code&gt; dimensions. Metric can be &lt;code&gt;&#34;angular&#34;&lt;/code&gt;, &lt;code&gt;&#34;euclidean&#34;&lt;/code&gt;, &lt;code&gt;&#34;manhattan&#34;&lt;/code&gt;, &lt;code&gt;&#34;hamming&#34;&lt;/code&gt;, or &lt;code&gt;&#34;dot&#34;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.add_item(i, v)&lt;/code&gt; adds item &lt;code&gt;i&lt;/code&gt; (any nonnegative integer) with vector &lt;code&gt;v&lt;/code&gt;. Note that it will allocate memory for &lt;code&gt;max(i)+1&lt;/code&gt; items.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.build(n_trees, n_jobs=-1)&lt;/code&gt; builds a forest of &lt;code&gt;n_trees&lt;/code&gt; trees. More trees gives higher precision when querying. After calling &lt;code&gt;build&lt;/code&gt;, no more items can be added. &lt;code&gt;n_jobs&lt;/code&gt; specifies the number of threads used to build the trees. &lt;code&gt;n_jobs=-1&lt;/code&gt; uses all available CPU cores.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.save(fn, prefault=False)&lt;/code&gt; saves the index to disk and loads it (see next function). After saving, no more items can be added.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.load(fn, prefault=False)&lt;/code&gt; loads (mmaps) an index from disk. If &lt;code&gt;prefault&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, it will pre-read the entire file into memory (using mmap with &lt;code&gt;MAP_POPULATE&lt;/code&gt;). Default is &lt;code&gt;False&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.unload()&lt;/code&gt; unloads.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.get_nns_by_item(i, n, search_k=-1, include_distances=False)&lt;/code&gt; returns the &lt;code&gt;n&lt;/code&gt; closest items. During the query it will inspect up to &lt;code&gt;search_k&lt;/code&gt; nodes which defaults to &lt;code&gt;n_trees * n&lt;/code&gt; if not provided. &lt;code&gt;search_k&lt;/code&gt; gives you a run-time tradeoff between better accuracy and speed. If you set &lt;code&gt;include_distances&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt;, it will return a 2 element tuple with two lists in it: the second one containing all corresponding distances.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.get_nns_by_vector(v, n, search_k=-1, include_distances=False)&lt;/code&gt; same but query by vector &lt;code&gt;v&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.get_item_vector(i)&lt;/code&gt; returns the vector for item &lt;code&gt;i&lt;/code&gt; that was previously added.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.get_distance(i, j)&lt;/code&gt; returns the distance between items &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. NOTE: this used to return the &lt;em&gt;squared&lt;/em&gt; distance, but has been changed as of Aug 2016.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.get_n_items()&lt;/code&gt; returns the number of items in the index.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.get_n_trees()&lt;/code&gt; returns the number of trees in the index.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.on_disk_build(fn)&lt;/code&gt; prepares annoy to build the index in the specified file instead of RAM (execute before adding items, no need to save after build)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a.set_seed(seed)&lt;/code&gt; will initialize the random number generator with the given seed. Only used for building up the tree, i. e. only necessary to pass this before adding the items. Will have no effect after calling &lt;code&gt;a.build(n_trees)&lt;/code&gt; or &lt;code&gt;a.load(fn)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There&#39;s no bounds checking performed on the values so be careful.&lt;/li&gt; &#xA; &lt;li&gt;Annoy uses Euclidean distance of normalized vectors for its angular distance, which for two vectors u,v is equal to &lt;code&gt;sqrt(2(1-cos(u,v)))&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The C++ API is very similar: just &lt;code&gt;#include &#34;annoylib.h&#34;&lt;/code&gt; to get access to it.&lt;/p&gt; &#xA;&lt;h2&gt;Tradeoffs&lt;/h2&gt; &#xA;&lt;p&gt;There are just two main parameters needed to tune Annoy: the number of trees &lt;code&gt;n_trees&lt;/code&gt; and the number of nodes to inspect during searching &lt;code&gt;search_k&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;n_trees&lt;/code&gt; is provided during build time and affects the build time and the index size. A larger value will give more accurate results, but larger indexes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;search_k&lt;/code&gt; is provided in runtime and affects the search performance. A larger value will give more accurate results, but will take longer time to return.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If &lt;code&gt;search_k&lt;/code&gt; is not provided, it will default to &lt;code&gt;n * n_trees&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of approximate nearest neighbors. Otherwise, &lt;code&gt;search_k&lt;/code&gt; and &lt;code&gt;n_trees&lt;/code&gt; are roughly independent, i.e. the value of &lt;code&gt;n_trees&lt;/code&gt; will not affect search time if &lt;code&gt;search_k&lt;/code&gt; is held constant and vice versa. Basically it&#39;s recommended to set &lt;code&gt;n_trees&lt;/code&gt; as large as possible given the amount of memory you can afford, and it&#39;s recommended to set &lt;code&gt;search_k&lt;/code&gt; as large as possible given the time constraints you have for the queries.&lt;/p&gt; &#xA;&lt;p&gt;You can also accept slower search times in favour of reduced loading times, memory usage, and disk IO. On supported platforms the index is prefaulted during &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;, causing the file to be pre-emptively read from disk into memory. If you set &lt;code&gt;prefault&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;, pages of the mmapped index are instead read from disk and cached in memory on-demand, as necessary for a search to complete. This can significantly increase early search times but may be better suited for systems with low memory compared to index size, when few queries are executed against a loaded index, and/or when large areas of the index are unlikely to be relevant to search queries.&lt;/p&gt; &#xA;&lt;h2&gt;How does it work&lt;/h2&gt; &#xA;&lt;p&gt;Using &lt;code&gt;random projections &amp;lt;http://en.wikipedia.org/wiki/Locality-sensitive_hashing#Random_projection&amp;gt;&lt;/code&gt;__ and by building up a tree. At every intermediate node in the tree, a random hyperplane is chosen, which divides the space into two subspaces. This hyperplane is chosen by sampling two points from the subset and taking the hyperplane equidistant from them.&lt;/p&gt; &#xA;&lt;p&gt;We do this k times so that we get a forest of trees. k has to be tuned to your need, by looking at what tradeoff you have between precision and performance.&lt;/p&gt; &#xA;&lt;p&gt;Hamming distance (contributed by &lt;code&gt;Martin Aumüller &amp;lt;https://github.com/maumueller&amp;gt;&lt;/code&gt;__) packs the data into 64-bit integers under the hood and uses built-in bit count primitives so it could be quite fast. All splits are axis-aligned.&lt;/p&gt; &#xA;&lt;p&gt;Dot Product distance (contributed by &lt;code&gt;Peter Sobot &amp;lt;https://github.com/psobot&amp;gt;&lt;/code&gt;&lt;strong&gt;) reduces the provided vectors from dot (or &#34;inner-product&#34;) space to a more query-friendly cosine space using &lt;code&gt;a method by Bachrach et al., at Microsoft Research, published in 2014 &amp;lt;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/XboxInnerProduct.pdf&amp;gt;&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;More info&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Dirk Eddelbuettel &amp;lt;https://github.com/eddelbuettel&amp;gt;&lt;/code&gt;__ provides an &lt;code&gt;R version of Annoy &amp;lt;http://dirk.eddelbuettel.com/code/rcpp.annoy.html&amp;gt;&lt;/code&gt;__.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Andy Sloane &amp;lt;https://github.com/a1k0n&amp;gt;&lt;/code&gt;__ provides a &lt;code&gt;Java version of Annoy &amp;lt;https://github.com/spotify/annoy-java&amp;gt;&lt;/code&gt;__ although currently limited to cosine and read-only.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Pishen Tsai &amp;lt;https://github.com/pishen&amp;gt;&lt;/code&gt;__ provides a &lt;code&gt;Scala wrapper of Annoy &amp;lt;https://github.com/pishen/annoy4s&amp;gt;&lt;/code&gt;__ which uses JNA to call the C++ library of Annoy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Atsushi Tatsuma &amp;lt;https://github.com/yoshoku&amp;gt;&lt;/code&gt;__ provides &lt;code&gt;Ruby bindings for Annoy &amp;lt;https://github.com/yoshoku/annoy.rb&amp;gt;&lt;/code&gt;__.&lt;/li&gt; &#xA; &lt;li&gt;There is &lt;code&gt;experimental support for Go &amp;lt;https://github.com/spotify/annoy/blob/master/README_GO.rst&amp;gt;&lt;/code&gt;__ provided by &lt;code&gt;Taneli Leppä &amp;lt;https://github.com/rosmo&amp;gt;&lt;/code&gt;__.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Boris Nagaev &amp;lt;https://github.com/starius&amp;gt;&lt;/code&gt;__ wrote &lt;code&gt;Lua bindings &amp;lt;https://github.com/spotify/annoy/blob/master/README_Lua.md&amp;gt;&lt;/code&gt;__.&lt;/li&gt; &#xA; &lt;li&gt;During part of Spotify Hack Week 2016 (and a bit afterward), &lt;code&gt;Jim Kang &amp;lt;https://github.com/jimkang&amp;gt;&lt;/code&gt;__ wrote &lt;code&gt;Node bindings &amp;lt;https://github.com/jimkang/annoy-node&amp;gt;&lt;/code&gt;__ for Annoy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Min-Seok Kim &amp;lt;https://github.com/mskimm&amp;gt;&lt;/code&gt;__ built a &lt;code&gt;Scala version &amp;lt;https://github.com/mskimm/ann4s&amp;gt;&lt;/code&gt;__ of Annoy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;hanabi1224 &amp;lt;https://github.com/hanabi1224&amp;gt;&lt;/code&gt;__ built a read-only &lt;code&gt;Rust version &amp;lt;https://github.com/hanabi1224/RuAnnoy&amp;gt;&lt;/code&gt;__ of Annoy, together with &lt;strong&gt;dotnet, jvm and dart&lt;/strong&gt; read-only bindings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Presentation from New York Machine Learning meetup &amp;lt;http://www.slideshare.net/erikbern/approximate-nearest-neighbor-methods-and-vector-models-nyc-ml-meetup&amp;gt;&lt;/code&gt;__ about Annoy&lt;/li&gt; &#xA; &lt;li&gt;Annoy is available as a &lt;code&gt;conda package &amp;lt;https://anaconda.org/conda-forge/python-annoy&amp;gt;&lt;/code&gt;__ on Linux, OS X, and Windows.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ann-benchmarks &amp;lt;https://github.com/erikbern/ann-benchmarks&amp;gt;&lt;/code&gt;__ is a benchmark for several approximate nearest neighbor libraries. Annoy seems to be fairly competitive, especially at higher precisions:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;.. figure:: &lt;a href=&#34;https://github.com/erikbern/ann-benchmarks/raw/master/results/glove-100-angular.png&#34;&gt;https://github.com/erikbern/ann-benchmarks/raw/master/results/glove-100-angular.png&lt;/a&gt; :alt: ANN benchmarks :align: center :target: &lt;a href=&#34;https://github.com/erikbern/ann-benchmarks&#34;&gt;https://github.com/erikbern/ann-benchmarks&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Source code&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s all written in C++ with a handful of ugly optimizations for performance and memory usage. You have been warned :)&lt;/p&gt; &#xA;&lt;p&gt;The code should support Windows, thanks to &lt;code&gt;Qiang Kou &amp;lt;https://github.com/thirdwing&amp;gt;&lt;/code&gt;__ and &lt;code&gt;Timothy Riley &amp;lt;https://github.com/tjrileywisc&amp;gt;&lt;/code&gt;__.&lt;/p&gt; &#xA;&lt;p&gt;To run the tests, execute &lt;code&gt;python setup.py nosetests&lt;/code&gt;. The test suite includes a big real world dataset that is downloaded from the internet, so it will take a few minutes to execute.&lt;/p&gt; &#xA;&lt;h2&gt;Discuss&lt;/h2&gt; &#xA;&lt;p&gt;Feel free to post any questions or comments to the &lt;code&gt;annoy-user &amp;lt;https://groups.google.com/group/annoy-user&amp;gt;&lt;/code&gt;__ group. I&#39;m &lt;code&gt;@fulhack &amp;lt;https://twitter.com/fulhack&amp;gt;&lt;/code&gt;__ on Twitter.&lt;/p&gt;</summary>
  </entry>
</feed>