<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-02-27T01:29:26Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ROCm/composable_kernel</title>
    <updated>2025-02-27T01:29:26Z</updated>
    <id>tag:github.com,2025-02-27:/ROCm/composable_kernel</id>
    <link href="https://github.com/ROCm/composable_kernel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Composable Kernel: Performance Portable Programming Model for Machine Learning Tensor Operators&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Composable Kernel&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] The published documentation is available at &lt;a href=&#34;https://rocm.docs.amd.com/projects/composable_kernel/en/latest/&#34;&gt;Composable Kernel&lt;/a&gt; in an organized, easy-to-read format, with search and a table of contents. The documentation source files reside in the &lt;code&gt;docs&lt;/code&gt; folder of this repository. As with all ROCm projects, the documentation is open source. For more information on contributing to the documentation, see &lt;a href=&#34;https://rocm.docs.amd.com/en/latest/contribute/contributing.html&#34;&gt;Contribute to ROCm documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The Composable Kernel (CK) library provides a programming model for writing performance-critical kernels for machine learning workloads across multiple architectures (GPUs, CPUs, etc.). The CK library uses general purpose kernel languages, such as HIP C++.&lt;/p&gt; &#xA;&lt;p&gt;CK uses two concepts to achieve performance portability and code maintainability:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A tile-based programming model&lt;/li&gt; &#xA; &lt;li&gt;Algorithm complexity reduction for complex machine learning (ML) operators. This uses an innovative technique called &lt;em&gt;Tensor Coordinate Transformation&lt;/em&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/docs/data/ck_component.png&#34; alt=&#34;ALT&#34; title=&#34;CK Components&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The current CK library is structured into four layers:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Templated Tile Operators&lt;/li&gt; &#xA; &lt;li&gt;Templated Kernel and Invoker&lt;/li&gt; &#xA; &lt;li&gt;Instantiated Kernel and Invoker&lt;/li&gt; &#xA; &lt;li&gt;Client API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/docs/data/ck_layer.png&#34; alt=&#34;ALT&#34; title=&#34;CK Layers&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;General information&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/include/ck/README.md&#34;&gt;CK supported operations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/include/ck_tile/README.md&#34;&gt;CK Tile supported operations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/client_example/25_wrapper/README.md&#34;&gt;CK wrapper&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/codegen/README.md&#34;&gt;CK codegen&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/profiler/README.md&#34;&gt;CK profiler&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/example/README.md&#34;&gt;Examples (Custom use of CK supported operations)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/client_example/README.md&#34;&gt;Client examples (Use of CK supported operations with instance factory)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/TERMINOLOGY.md&#34;&gt;Terminology&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/CONTRIBUTORS.md&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;CK is released under the &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/LICENSE&#34;&gt;MIT license&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building CK&lt;/h2&gt; &#xA;&lt;p&gt;We recommend building CK inside Docker containers, which include all necessary packages. Pre-built Docker images are available on &lt;a href=&#34;https://hub.docker.com/r/rocm/composable_kernel/tags&#34;&gt;DockerHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;To build a new Docker image, use the Dockerfile provided with the source code:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;DOCKER_BUILDKIT=1 docker build -t ck:latest -f Dockerfile .&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Launch the Docker container:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run                                     \&#xA;-it                                            \&#xA;--privileged                                   \&#xA;--group-add sudo                               \&#xA;-w /root/workspace                             \&#xA;-v ${PATH_TO_LOCAL_WORKSPACE}:/root/workspace  \&#xA;ck:latest                                      \&#xA;/bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone CK source code from the GitHub repository and start the build:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/ROCm/composable_kernel.git &amp;amp;&amp;amp; \&#xA;cd composable_kernel &amp;amp;&amp;amp; \&#xA;mkdir build &amp;amp;&amp;amp; \&#xA;cd build&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You must set the &lt;code&gt;GPU_TARGETS&lt;/code&gt; macro to specify the GPU target architecture(s) you want to run CK on. You can specify single or multiple architectures. If you specify multiple architectures, use a semicolon between each; for example, &lt;code&gt;gfx908;gfx90a;gfx940&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake                                                                                             \&#xA;-D CMAKE_PREFIX_PATH=/opt/rocm                                                                    \&#xA;-D CMAKE_CXX_COMPILER=/opt/rocm/bin/hipcc                                                         \&#xA;-D CMAKE_BUILD_TYPE=Release                                                                       \&#xA;-D GPU_TARGETS=&#34;gfx908;gfx90a&#34;                                                                    \&#xA;..&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If you don&#39;t set &lt;code&gt;GPU_TARGETS&lt;/code&gt; on the cmake command line, CK is built for all GPU targets supported by the current compiler (this may take a long time). Tests and examples will only get built if the GPU_TARGETS is set by the user on the cmake command line.&lt;/p&gt; &lt;p&gt;NOTE: If you try setting &lt;code&gt;GPU_TARGETS&lt;/code&gt; to a list of architectures, the build will only work if the architectures are similar, e.g., &lt;code&gt;gfx908;gfx90a&lt;/code&gt;, or &lt;code&gt;gfx1100;gfx1101;gfx11012&lt;/code&gt;. Otherwise, if you want to build the library for a list of different architectures, you should use the &lt;code&gt;GPU_ARCHS&lt;/code&gt; build argument, for example &lt;code&gt;GPU_ARCHS=gfx908;gfx1030;gfx1100;gfx942&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the entire CK library:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install CK:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j install&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Optional post-install steps&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Build examples and tests:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j examples tests&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build and run all examples and tests:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j check&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can find instructions for running each individual example in &lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/example&#34;&gt;example&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build and run smoke/regression examples and tests:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j smoke # tests and examples that run for &amp;lt; 30 seconds each&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j regression # tests and examples that run for &amp;gt;= 30 seconds each&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build ckProfiler:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make -j ckProfiler&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You can find instructions for running ckProfiler in &lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/profiler&#34;&gt;profiler&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build our documentation locally:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd docs&#xA;pip3 install -r sphinx/requirements.txt&#xA;python3 -m sphinx -T -E -b html -d _build/doctrees -D language=en . _build/html&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note the &lt;code&gt;-j&lt;/code&gt; option for building with multiple threads in parallel, which speeds up the build significantly. However, &lt;code&gt;-j&lt;/code&gt; launches unlimited number of threads, which can cause the build to run out of memory and crash. On average, you should expect each thread to use ~2Gb of RAM. Depending on the number of CPU cores and the amount of RAM on your system, you may want to limit the number of threads. For example, if you have a 128-core CPU and 128 Gb of RAM it&#39;s advisable to use &lt;code&gt;-j32&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additional cmake flags can be used to significantly speed-up the build:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DTYPES&lt;/code&gt; (default is not set) can be set to any subset of &#34;fp64;fp32;fp16;fp8;bf16;int8&#34; to build instances of select data types only. The main default data types are fp32 and fp16; you can safely skip other data types.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DL_KERNELS&lt;/code&gt; (default is OFF) must be set to ON in order to build instances, such as &lt;code&gt;gemm_dl&lt;/code&gt; or &lt;code&gt;batched_gemm_multi_d_dl&lt;/code&gt;. These instances are useful on architectures like the NAVI2x, as most other platforms have faster instances, such as &lt;code&gt;xdl&lt;/code&gt; or &lt;code&gt;wmma&lt;/code&gt;, available.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;DPP_KERNELS&lt;/code&gt; (default is OFF) must be set to ON in order to build instances, such as &lt;code&gt;gemm_dpp&lt;/code&gt;. These instances are useful on architectures like the NAVI2x, as most other platforms have faster instances, such as &lt;code&gt;xdl&lt;/code&gt; or &lt;code&gt;wmma&lt;/code&gt;, available.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CK_USE_FP8_ON_UNSUPPORTED_ARCH&lt;/code&gt; (default is OFF) must be set to ON in order to build instances, such as &lt;code&gt;gemm_universal&lt;/code&gt;, &lt;code&gt;gemm_universal_streamk&lt;/code&gt; and &lt;code&gt;gemm_multiply_multiply&lt;/code&gt; for fp8 data type for GPU targets which do not have native support for fp8 data type, such as gfx908 or gfx90a. These instances are useful on architectures like the MI100/MI200 for the functional support only.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Using sccache for building&lt;/h2&gt; &#xA;&lt;p&gt;The default CK Docker images come with a pre-installed version of sccache, which supports clang being used as hip-compiler (&#34; -x hip&#34;). Using sccache can help reduce the time to re-build code from hours to 1-2 minutes. In order to invoke sccache, you need to run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; sccache --start-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then add the following flags to the cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; -DCMAKE_CXX_COMPILER_LAUNCHER=sccache -DCMAKE_C_COMPILER_LAUNCHER=sccache&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may need to clean up the build folder and repeat the cmake and make steps in order to take advantage of the sccache during subsequent builds.&lt;/p&gt; &#xA;&lt;h2&gt;Using CK as pre-built kernel library&lt;/h2&gt; &#xA;&lt;p&gt;You can find instructions for using CK as a pre-built kernel library in &lt;a href=&#34;https://raw.githubusercontent.com/ROCm/composable_kernel/develop/client_example&#34;&gt;client_example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to CK&lt;/h2&gt; &#xA;&lt;p&gt;When you contribute to CK, make sure you run &lt;code&gt;clang-format&lt;/code&gt; on all changed files. We highly recommend using git hooks that are managed by the &lt;code&gt;pre-commit&lt;/code&gt; framework. To install hooks, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo script/install_precommit.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this approach, &lt;code&gt;pre-commit&lt;/code&gt; adds the appropriate hooks to your local repository and automatically runs &lt;code&gt;clang-format&lt;/code&gt; (and possibly additional checks) before any commit is created.&lt;/p&gt; &#xA;&lt;p&gt;If you need to uninstall hooks from the repository, you can do so by running the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;script/uninstall_precommit.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to temporarily disable pre-commit hooks, you can add the &lt;code&gt;--no-verify&lt;/code&gt; option to the &lt;code&gt;git commit&lt;/code&gt; command.&lt;/p&gt;</summary>
  </entry>
</feed>