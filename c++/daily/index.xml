<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-12T01:29:02Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>linkdd/aitoolkit</title>
    <updated>2024-01-12T01:29:02Z</updated>
    <id>tag:github.com,2024-01-12:/linkdd/aitoolkit</id>
    <link href="https://github.com/linkdd/aitoolkit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Give a brain to your game&#39;s NPCs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AI Toolkit&lt;/h1&gt; &#xA;&lt;center&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/linkdd/aitoolkit/tests.yml?style=flat-square&amp;amp;logo=github&amp;amp;label=tests&#34; alt=&#34;tests&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/linkdd/aitoolkit/docs.yml?style=flat-square&amp;amp;logo=github&amp;amp;label=docs&#34; alt=&#34;docs&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/linkdd/aitoolkit?style=flat-square&amp;amp;color=blue&#34; alt=&#34;license&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/linkdd/aitoolkit?style=flat-square&amp;amp;color=red&#34; alt=&#34;version&#34;&gt;&lt;/p&gt; &#xA;&lt;/center&gt; &#xA;&lt;p&gt;&lt;strong&gt;AI Toolkit&lt;/strong&gt; is a header-only C++ library which provides tools for building the brain of your game&#39;s NPCs.&lt;/p&gt; &#xA;&lt;p&gt;It provides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Finite State Machines&lt;/li&gt; &#xA; &lt;li&gt;Behavior Tree&lt;/li&gt; &#xA; &lt;li&gt;Utility AI&lt;/li&gt; &#xA; &lt;li&gt;Goal Oriented Action Planning&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Why this project? Well, I wrote about it &lt;a href=&#34;https://david-delassus.medium.com/ai-toolkit-give-a-brain-to-your-npcs-a-header-only-c-library-02a50ae9faed?sk=011cd1ed8e61d22f1be6b6430847f430&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add the &lt;code&gt;include&lt;/code&gt; folder of this repository to your include paths.&lt;/p&gt; &#xA;&lt;p&gt;Or add it as a submodule:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ git submodule add https://github.com/linkdd/aitoolkit.git&#xA;$ g++ -std=c++23 -Iaiotoolkit/include main.cpp -o mygame&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NB:&lt;/strong&gt; This library is compatible with C++20.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Finite State Machine&lt;/h3&gt; &#xA;&lt;p&gt;First, include the header:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;aitoolkit/fsm.hpp&amp;gt;&#xA;&#xA;using namespace aitoolkit::fsm;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create your blackboard type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct blackboard_type {&#xA;  // ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create a state type for each of your states:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class state_dummy final : public state&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual void enter(blackboard_type&amp;amp; blackboard) override {&#xA;      // ...&#xA;    }&#xA;&#xA;    virtual void exit(blackboard_type&amp;amp; blackboard) override {&#xA;      // ...&#xA;    }&#xA;&#xA;    virtual void pause(blackboard_type&amp;amp; blackboard) override {&#xA;      // ...&#xA;    }&#xA;&#xA;    virtual void resume(blackboard_type&amp;amp; blackboard) override {&#xA;      // ...&#xA;    }&#xA;&#xA;    virtual void update(blackboard_type&amp;amp; blackboard) override {&#xA;      // ...&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create your simple state machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto simple_bb = blackboard_type{};&#xA;auto simple_fsm = simple_machine&amp;lt;blackboard_type&amp;gt;();&#xA;&#xA;simple_fsm.set_state(std::make_shared&amp;lt;state_dummy&amp;gt;(), simple_bb);&#xA;simple_fsm.pause(simple_bb);&#xA;simple_fsm.resume(simple_bb);&#xA;simple_fsm.update(simple_bb);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or with a stack state machine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto stack_bb = blackboard_type{};&#xA;auto stack_fsm = stack_machine&amp;lt;blackboard_type&amp;gt;{};&#xA;&#xA;stack_fsm.push_state(std::make_shared&amp;lt;state_dummy&amp;gt;(), stack_bb);&#xA;stack_fsm.push_state(std::make_shared&amp;lt;state_dummy&amp;gt;(), stack_bb);&#xA;&#xA;stack_fsm.update(stack_bb);&#xA;&#xA;stack_fsm.pop_state(stack_bb);&#xA;stack_fsm.pop_state(stack_bb);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Behavior Tree&lt;/h3&gt; &#xA;&lt;p&gt;First, include the header:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;aitoolkit/behtree.hpp&amp;gt;&#xA;&#xA;using namespace aitoolkit::bt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create your blackboard type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct blackboard_type {&#xA;  // ...&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create your tree:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto tree = seq&amp;lt;blackboard_type&amp;gt;::make({&#xA;  check&amp;lt;blackboard_type&amp;gt;::make([](const blackboard_type&amp;amp; bb) {&#xA;    // check some condition&#xA;    return true;&#xA;  }),&#xA;  task&amp;lt;blackboard_type&amp;gt;::make([](blackboard_type&amp;amp; bb) {&#xA;    // perform some action&#xA;    return execution_state::success;&#xA;  })&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, evaluate it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto blackboard = blackboard_type{&#xA;  // ...&#xA;};&#xA;&#xA;auto state = tree-&amp;gt;evaluate(blackboard);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more informations, consult the &lt;a href=&#34;https://linkdd.github.io/aitoolkit/group__behtree.html&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Utility AI&lt;/h3&gt; &#xA;&lt;p&gt;First, include the header file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;aitoolkit/utility.hpp&amp;gt;&#xA;&#xA;using namespace aitoolkit::utility;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create a blackboard type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct blackboard_type {&#xA;  int food{0};&#xA;  int wood{0};&#xA;  int stone{0};&#xA;  int gold{0};&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, create a class for each action that you want to be able to perform:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class collect_food final : public action&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual float score(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return 50.0f;&#xA;    }&#xA;&#xA;    virtual void apply(blackboard_type&amp;amp; blackboard) const override {&#xA;      blackboard.food += 1;&#xA;    }&#xA;};&#xA;&#xA;class collect_wood final : public action&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual float score(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return 150.0f;&#xA;    }&#xA;&#xA;    virtual void apply(blackboard_type&amp;amp; blackboard) const override {&#xA;      blackboard.wood += 1;&#xA;    }&#xA;};&#xA;&#xA;class collect_stone final : public action&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual float score(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return -10.0f;&#xA;    }&#xA;&#xA;    virtual void apply(blackboard_type&amp;amp; blackboard) const override {&#xA;      blackboard.stone += 1;&#xA;    }&#xA;};&#xA;&#xA;class collect_gold final : public action&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual float score(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return 75.0f;&#xA;    }&#xA;&#xA;    virtual void apply(blackboard_type&amp;amp; blackboard) const override {&#xA;      blackboard.gold += 1;&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, create an evaluator and run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto evaluator = evaluator&amp;lt;blackboard_type&amp;gt;{&#xA;  std::make_shared&amp;lt;collect_food&amp;gt;(),&#xA;  std::make_shared&amp;lt;collect_wood&amp;gt;(),&#xA;  std::make_shared&amp;lt;collect_stone&amp;gt;(),&#xA;  std::make_shared&amp;lt;collect_gold&amp;gt;()&#xA;};&#xA;&#xA;auto blackboard = blackboard_type{};&#xA;evaluator.run(blackboard);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Goal Oriented Action Planning&lt;/h3&gt; &#xA;&lt;p&gt;First, include the header file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;aitoolkit/goap.hpp&amp;gt;&#xA;&#xA;using namespace aitoolkit::goap;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, create a blackboard class that will hold the state of the planner:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct blackboard_type {&#xA;  bool has_axe{false};&#xA;  int wood{0};&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;NB:&lt;/strong&gt; The blackboard needs to be comparable (&lt;code&gt;a == b&lt;/code&gt;) and hashable.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Next, create a class for each action that you want to be able to perform:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class get_axe final : public action&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual float cost(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return 1.0f;&#xA;    }&#xA;&#xA;    virtual bool check_preconditions(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return !blackboard.has_axe;&#xA;    }&#xA;&#xA;    virtual void apply_effects(blackboard_type&amp;amp; blackboard, bool dry_run) const override {&#xA;      blackboard.has_axe = true;&#xA;    }&#xA;};&#xA;&#xA;class chop_tree final : public action&amp;lt;blackboard_type&amp;gt; {&#xA;  public:&#xA;    virtual float cost(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return 1.0f;&#xA;    }&#xA;&#xA;    virtual bool check_preconditions(const blackboard_type&amp;amp; blackboard) const override {&#xA;      return blackboard.has_axe;&#xA;    }&#xA;&#xA;    virtual void apply_effects(blackboard_type&amp;amp; blackboard, bool dry_run) const override {&#xA;      blackboard.wood += 1;&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, create a plan and run it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto actions = std::vector&amp;lt;action_ptr&amp;lt;blackboard_type&amp;gt;&amp;gt;{&#xA;  std::make_shared&amp;lt;get_axe&amp;gt;(),&#xA;  std::make_shared&amp;lt;chop_tree&amp;gt;()&#xA;};&#xA;auto initial = blackboard_type{};&#xA;auto goal = blackboard_type{&#xA;  .has_axe = true,&#xA;  .wood = 3&#xA;};&#xA;&#xA;auto p = planner&amp;lt;blackboard_type&amp;gt;(actions, initial, goal);&#xA;&#xA;auto blackboard = initial;&#xA;while (p) {&#xA;  p.run_next(blackboard); // will mutate the blackboard&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more informations, consult the &lt;a href=&#34;https://linkdd.github.io/aitoolkit/group__goap.html&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The documentation is available online &lt;a href=&#34;https://linkdd.github.io/aitoolkit&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can build it locally using &lt;a href=&#34;https://www.doxygen.nl/&#34;&gt;doxygen&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ make docs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is released under the terms of the &lt;a href=&#34;https://raw.githubusercontent.com/linkdd/aitoolkit/main/LICENSE.txt&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hku-mars/M-detector</title>
    <updated>2024-01-12T01:29:02Z</updated>
    <id>tag:github.com,2024-01-12:/hku-mars/M-detector</id>
    <link href="https://github.com/hku-mars/M-detector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;M-detector&lt;/h1&gt; &#xA;&lt;h2&gt;1.Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;M-detector&lt;/strong&gt; is a moving event detection package, which determines if a point from LiDAR is moving immediately after its arrival, resulting in a point-by-point detection with a latency of just several microseconds. M-detector is designed based on occlusion principles and can be used in different environments with various types of LiDAR sensors.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;1.1 Related paper&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Our related papers has been accepted by Nature Communications. &lt;a href=&#34;https://www.nature.com/articles/s41467-023-44554-8&#34;&gt;Moving Event Detection from LiDAR Stream Points&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If our code is used in your project, please cite our paper.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;1.2 Related video&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Our accompanying videos are now available on &lt;strong&gt;YouTube&lt;/strong&gt; (click below images to open) and &lt;a href=&#34;https://www.bilibili.com/video/BV1ke411i7t7/?share_source=copy_web&#34;&gt;&lt;strong&gt;Bilibili&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://www.youtube.com/watch?v=SYaig2eHV5I&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hku-mars/M-detector/main/img/cover.bmp&#34; alt=&#34;video&#34; width=&#34;60%&#34;&gt;&lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h3&gt;1.3 Developers&lt;/h3&gt; &#xA;&lt;p&gt;The codes of this repo are contributed by: &lt;a href=&#34;https://github.com/HuajieWu99&#34;&gt;Huajie Wu (吴花洁)&lt;/a&gt;, &lt;a href=&#34;https://github.com/yihangHKU&#34;&gt;Yihang Li (李一航)&lt;/a&gt; and &lt;a href=&#34;https://github.com/XW-HKU&#34;&gt;Wei Xu (徐威)&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;2. Prerequisites&lt;/h2&gt; &#xA;&lt;h3&gt;2.1 &lt;strong&gt;Ubuntu&lt;/strong&gt; and &lt;strong&gt;ROS&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Ubuntu ≥ 18.04.&lt;/p&gt; &#xA;&lt;p&gt;ROS ≥ Melodic. Follow [&lt;a href=&#34;http://wiki.ros.org/ROS/Installation&#34;&gt;ROS Installation&lt;/a&gt;]&lt;/p&gt; &#xA;&lt;h3&gt;2.2 &lt;strong&gt;PCL&lt;/strong&gt; and &lt;strong&gt;Eigen&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;PCL ≥ 1.8&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo apt install libpcl-dev&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Eigen ≥ 3.3.4&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo apt install libeigen3-dev&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;2.3 &lt;strong&gt;livox_ros_driver&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Follow &lt;a href=&#34;https://github.com/Livox-SDK/livox_ros_driver&#34;&gt;livox_ros_driver Installation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Remarks:&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Since the M-detector support Livox serials LiDAR firstly, so the &lt;strong&gt;livox_ros_driver&lt;/strong&gt; must be installed and &lt;strong&gt;sourced&lt;/strong&gt; before run any M-detector launch file.&lt;/li&gt; &#xA; &lt;li&gt;How to source? The easiest way is add the line &lt;code&gt;source $Livox_ros_driver_dir$/devel/setup.bash&lt;/code&gt; to the end of file &lt;code&gt;~/.bashrc&lt;/code&gt;, where &lt;code&gt;$Livox_ros_driver_dir$&lt;/code&gt; is the directory of the livox ros driver workspace (should be the &lt;code&gt;ws_livox&lt;/code&gt; directory if you completely followed the livox official document).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;2.4 TBB&lt;/h3&gt; &#xA;&lt;p&gt;Install gcc-9 g++-9&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntu-toolchain-r/test&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo apt update&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo apt install gcc-9 g++-9&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cd /usr/bin&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo rm gcc g++&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo ln -s gcc-9 gcc&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo ln -s g++-9 g++&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Follow [&lt;a href=&#34;https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/&#34;&gt;TBB Installation&lt;/a&gt;] (&lt;strong&gt;Note:&lt;/strong&gt; change the gcc-9.1/g++-9.1 to gcc-9/g++-9)&lt;/p&gt; &#xA;&lt;h2&gt;3. Build&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository and catkin_make:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cd ~/catkin_ws/src&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;git clone git@github.com:hku-mars/M-detector.git&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;catkin_make&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;source devel/setup.bash&lt;/code&gt; (&lt;strong&gt;Note:&lt;/strong&gt; change the path for TBB in CMakeList.txt)&lt;/p&gt; &#xA;&lt;h2&gt;4. Key Information&lt;/h2&gt; &#xA;&lt;h3&gt;4.1 Key parameters&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;dataset: 3    #0 for kitti, 1 for nuscenes, 2 for waymo&#xA;buffer_delay: 0.1&#xA;buffer_size: 100000&#xA;points_num_perframe: 30000&#xA;depth_map_dur: 0.2&#xA;max_depth_map_num: 5&#xA;max_pixel_points: 5&#xA;frame_dur: 0.1&#xA;hor_resolution_max: 0.005&#xA;ver_resolution_max: 0.01&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The parameters are provided in folder &#34;config&#34; for different LiDARs.&lt;/p&gt; &#xA;&lt;p&gt;For methods of parameters tuning, please follow the section 8 introduced in [&lt;a href=&#34;https://www.nature.com/articles/s41467-023-44554-8&#34;&gt;Supplementary Information&lt;/a&gt;].&lt;/p&gt; &#xA;&lt;p&gt;To save the label files, please pass the parameter via the corresponding launch files.&lt;/p&gt; &#xA;&lt;h3&gt;4.2 Folder structure for dataset&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;├── XXX (dataset name)&#xA;│   ├── bags&#xA;│   │   ├── XXX_0000.bag&#xA;│   │   ├── ...&#xA;│   ├── sequences&#xA;│   │   ├── 0000&#xA;│   │   │   ├── labels&#xA;│   │   │   ├── predictionsx_origin (results in point-out mode with xth parameter file)&#xA;│   │   │   ├── predictionsx (in frame-out mode with xth parameter file)&#xA;│   │   │   ├── ...&#xA;│   │   ├── ...&#xA;├── ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The dataset can be downloaded at [&lt;a href=&#34;https://drive.google.com/drive/folders/1ASNfrjZB7n9Q-nB4Pm2IwvArFWnTcFAj?usp=drive_link&#34;&gt;this link&lt;/a&gt;].&lt;/p&gt; &#xA;&lt;h2&gt;5. Directly Run&lt;/h2&gt; &#xA;&lt;h3&gt;5.1 Run with odometry and point clouds (in local frame)&lt;/h3&gt; &#xA;&lt;p&gt;At first, please run a odometery node, such as [&lt;a href=&#34;https://github.com/hku-mars/FAST_LIO&#34;&gt;Fast Lio&lt;/a&gt;] (Download Fast Lio provided in Releases into the same location as M-detector&#39;s and complie them).&lt;/p&gt; &#xA;&lt;p&gt;Then:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;roslaunch fast_lio mapping_XXX(for dataset).launch&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;roslaunch m_detector detector_(dataset).launch&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;rosbag play YOURBAG.bag&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;5.2 Generate the label files for every point&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;roslaunch m_detector detector_XXX.launch out_path:=&#34;your path for frame-out results&#34; out_origin_path:=&#34;your path for point-out results&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: Follow the folder structure introduced before, the &lt;code&gt;out_path&lt;/code&gt; should be in the format of &#34;(the path to dataset folder)/(dataset name)/sequences/(sequence number)/predictionsx(x is the parameter file&#39;s number)/&#34;, and the &lt;code&gt;out_origin_path&lt;/code&gt; should be in the format of &#34;(the path to dataset folder)/(dataset name)/sequences/(sequence number)/predictionsx_origin(x is the parameter file&#39;s number)/&#34;.&lt;/p&gt; &#xA;&lt;h3&gt;5.3 Calculate the IoU of results&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;roslaunch m_detector cal_recall.launch dataset:=(0 for kitti, 1 for nuscenes, 2 for waymo, 3 for avia) dataset_folder:=&#34;the path to the dataset_folder&#34; start_se:=(the first sequence number for calculation) end_se:=(the last sequence number for calculation) start_param:=(the first parameter file&#39;s number for calculation) end_param:=(the last parameter file&#39;s number for calculation) is_origin:=(true for point-out results, false for frame-out results)&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note: Follow the folder structure introduced before, the &lt;code&gt;dataset_folder&lt;/code&gt; should be the path to dataset folder. This step will calculate all the IoU for all designated results listed in the dataset folder and generate a new folder named &#34;recall&#34; or &#34;recall_origin&#34; containing the results.&lt;/p&gt; &#xA;&lt;h2&gt;6. Run with Embedded in FAST LIO&lt;/h2&gt; &#xA;&lt;p&gt;Download the embedded version provided in Releases into a new workspace and complie them.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;roslaunch fast_lio mapping_(dataset).launch&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;rosbag play YOURBAG.bag&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;7. Rosbag Download&lt;/h2&gt; &#xA;&lt;p&gt;The bags used in paper can be download at [&lt;a href=&#34;https://drive.google.com/drive/folders/1ASNfrjZB7n9Q-nB4Pm2IwvArFWnTcFAj?usp=sharing&#34;&gt;this link&lt;/a&gt;].&lt;/p&gt; &#xA;&lt;h2&gt;8. License&lt;/h2&gt; &#xA;&lt;p&gt;The source code of this package is released under &lt;a href=&#34;http://www.gnu.org/licenses/&#34;&gt;&lt;strong&gt;GPLv2&lt;/strong&gt;&lt;/a&gt; license. We only allow it free for &lt;strong&gt;academic usage&lt;/strong&gt;. For commercial use, please contact Dr. Fu Zhang &lt;a href=&#34;mailto:fuzhang@hku.hk&#34;&gt;fuzhang@hku.hk&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For any technical issues, please contact me via email &lt;a href=&#34;mailto:wu2020@connect.hku.hk&#34;&gt;wu2020@connect.hku.hk&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>