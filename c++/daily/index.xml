<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-11T01:32:35Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>eversinc33/Banshee</title>
    <updated>2023-06-11T01:32:35Z</updated>
    <id>tag:github.com,2023-06-11:/eversinc33/Banshee</id>
    <link href="https://github.com/eversinc33/Banshee" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Experimental Windows x64 Kernel Rootkit.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Banshee&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/eversinc33/Banshee/main/img/Banshee.jpg&#34; alt=&#34;Banshee&#34; width=&#34;400&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;Learning about Windows rootkits lately, so here is my own implementation of some techniques. For an overview, see &lt;strong&gt;Features&lt;/strong&gt; below.&lt;/p&gt; &#xA;&lt;p&gt;This is not ready to use as the code is bad and I am just learning about kernel driver development, so this is for educational purposes mainly.&lt;/p&gt; &#xA;&lt;h2&gt;What is a Rootkit?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://phrack.org/issues/55/5.html&#34;&gt;http://phrack.org/issues/55/5.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;You can integrate Banshee into your tooling, by including the &lt;code&gt;Banshee.hpp&lt;/code&gt; file in your project, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Banshee banshee = Banshee();&#xA;banshee.Install(driverPath);&#xA;banshee.Initialize();&#xA;&#xA;int targetPid = GetDefenderPID();    // this would be your implementation&#xA;banshee.IoCtlKillProcess(targetPid); // instruct banshee to kill the targetprocess&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example implementation of all the features in a command line client is found in &lt;a href=&#34;https://raw.githubusercontent.com/eversinc33/Banshee/main/BansheeClient/BansheeClient.cpp&#34;&gt;./BansheeClient/BansheeClient.cpp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eversinc33/Banshee/main/img/CLI.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Testing &amp;amp; debugging the driver&lt;/h2&gt; &#xA;&lt;p&gt;You need to enable testsigning to load the driver. I also recommend to enable debugging for the kernel.&lt;/p&gt; &#xA;&lt;p&gt;Run the following from an administrative prompt and reboot afterwards:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;bcdedit /set testsigning on&#xA;bcdedit /debug on&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Afterwards you can run the client, after compiling the solution, with e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;.\x64\Debug\BansheeClient.exe C:\Users\eversinc33\source\repos\Banshee\x64\Debug\Banshee.sys&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run this in a VM and create a snapshot. You will probably Bluescreen a lot when developing and can corrupt your system. Be warned.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;Get in everyone, we&#39;re going to Kernel Land!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Kill any process by PID&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;ZwTerminateProcess&lt;/code&gt; is simply called from kernel land to terminate any process.&lt;/p&gt; &#xA;&lt;h3&gt;&#34;Bury&#34; a Process&lt;/h3&gt; &#xA;&lt;p&gt;Terminating processes, but they come back alive? Bury a process to avoid it to restart by setting a kernel callback to process creation.&lt;/p&gt; &#xA;&lt;p&gt;If the target process is created, Banshee will set the &lt;code&gt;CreationStatus&lt;/code&gt; of the target process to &lt;code&gt;STATUS_ACCESS_DENIED&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The match is case insensitive on a substring - e.g. to block defender, run &lt;code&gt;bury&lt;/code&gt; with &lt;code&gt;defender&lt;/code&gt;, then &lt;code&gt;kill &amp;lt;defender pid&amp;gt;&lt;/code&gt; and it won&#39;t come back anymore, since all process creation events with &lt;code&gt;defender&lt;/code&gt; in the image full path will be blocked.&lt;/p&gt; &#xA;&lt;p&gt;For this feature, &lt;code&gt;INTEGRITYCHECK&lt;/code&gt; has to be specified when linking (&lt;a href=&#34;https://learn.microsoft.com/en-us/cpp/build/reference/integritycheck-require-signature-check?view=msvc-170&#34;&gt;https://learn.microsoft.com/en-us/cpp/build/reference/integritycheck-require-signature-check?view=msvc-170&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Change protection level of any process by PID&lt;/h3&gt; &#xA;&lt;p&gt;This is done by modifying the &lt;code&gt;EPROCESS&lt;/code&gt; structur, which is an kernel object that describes a processes attributes. It also holds a value that specifies the protection level of the process.&lt;/p&gt; &#xA;&lt;p&gt;On my machine, that value can be found at offset &lt;code&gt;0x87a&lt;/code&gt;. Since that offset is dynamic, we can dynamically parse it from &lt;code&gt;PspIsProtectedProcessLight&lt;/code&gt; instead of hardcoding it (thanks &lt;a href=&#34;https://twitter.com/never_unsealed&#34;&gt;@never_unsealed&lt;/a&gt; for the trick):&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eversinc33/Banshee/main/img/EPROCESS_Protection.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;We can directly modify this value (aka Direct Kernel Object Modification or DKOM), since we are operating in Ring 0.&lt;/p&gt; &#xA;&lt;p&gt;The values for the different protection levels can be found e.g. in Windows Internals Part 1 (page 115 in the 7th edition (english)).&lt;/p&gt; &#xA;&lt;h3&gt;Elevate any process token to SYSTEM&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;EPROCESS&lt;/code&gt; also holds a pointer to the current access token, so we can just make it point to e.g. the token of process 4 (&lt;code&gt;SYSTEM&lt;/code&gt;) to elevate any process to &lt;code&gt;SYSTEM&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Hide Process by PID&lt;/h3&gt; &#xA;&lt;p&gt;Again, &lt;code&gt;EPROCESS&lt;/code&gt; comes to help here - it contains a &lt;code&gt;LIST_ENTRY&lt;/code&gt; of a doubly linked list called &lt;code&gt;ActiveProcessLink&lt;/code&gt; which is queried by Windows to enumerate running processes. If we simply unlink an entry here, we can hide our process from tools like Process Monitor or Task Manager.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;This can cause Bluescreens, e.g. when the process is closed while being hidden or due to patchguard scanning the kernel memory.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;TODO&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Shellcode injection from kernel land&lt;/li&gt; &#xA; &lt;li&gt;ETW provider disabling à la &lt;a href=&#34;https://securityintelligence.com/posts/direct-kernel-object-manipulation-attacks-etw-providers/&#34;&gt;https://securityintelligence.com/posts/direct-kernel-object-manipulation-attacks-etw-providers/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Registry key and file protection&lt;/li&gt; &#xA; &lt;li&gt;MSR hooking à la &lt;a href=&#34;https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1&#34;&gt;https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;GPU shenanigans&lt;/li&gt; &#xA; &lt;li&gt;Usability&lt;/li&gt; &#xA; &lt;li&gt;Communication over direct TCP to bypass &lt;code&gt;netstat&lt;/code&gt; and others&lt;/li&gt; &#xA; &lt;li&gt;Locks, dereferencing, ... - stability basically&lt;/li&gt; &#xA; &lt;li&gt;Hiding only on special ocassion, e.g. on opening of task manager, to avoid patchguard crashes&lt;/li&gt; &#xA; &lt;li&gt;Backdoor authentication as described in the phrack article linked above&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Some offset code from: &lt;a href=&#34;https://github.com/Idov31/Nidhogg&#34;&gt;https://github.com/Idov31/Nidhogg&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Great introduction to drivers: &lt;a href=&#34;https://www.codeproject.com/articles/9504/driver-development-part-1-introduction-to-drivers&#34;&gt;https://www.codeproject.com/articles/9504/driver-development-part-1-introduction-to-drivers&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Great overview of techniques: &lt;a href=&#34;https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1&#34;&gt;https://www.cyberark.com/resources/threat-research-blog/fantastic-rootkits-and-where-to-find-them-part-1&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;WinDbg and the Windows Internals book for helping me (kinda) understand what I am doing here lol&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>