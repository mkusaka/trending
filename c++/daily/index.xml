<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-19T01:29:37Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ip7z/7zip</title>
    <updated>2024-05-19T01:29:37Z</updated>
    <id>tag:github.com,2024-05-19:/ip7z/7zip</id>
    <link href="https://github.com/ip7z/7zip" rel="alternate"></link>
    <summary type="html">&lt;p&gt;7-Zip&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;7-Zip on GitHub&lt;/h1&gt; &#xA;&lt;p&gt;7-Zip website: &lt;a href=&#34;https://7-zip.org&#34;&gt;7-zip.org&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>snake-4/Zygisk-Assistant</title>
    <updated>2024-05-19T01:29:37Z</updated>
    <id>tag:github.com,2024-05-19:/snake-4/Zygisk-Assistant</id>
    <link href="https://github.com/snake-4/Zygisk-Assistant" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Zygisk module to hide root for KernelSU, Magisk and APatch, designed to work on Android 5.0 and above.&lt;/p&gt;&lt;hr&gt;&lt;h3 align=&#34;center&#34;&gt;Zygisk Assistant&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; A Zygisk module that aims to hide the existence root and Zygisk. &lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://github.com/snake-4/Zygisk-Assistant/issues&#34;&gt;Report Bug&lt;/a&gt; · &lt;a href=&#34;https://github.com/snake-4/Zygisk-Assistant/issues&#34;&gt;Request Feature&lt;/a&gt; · &lt;a href=&#34;https://github.com/snake-4/Zygisk-Assistant/releases&#34;&gt;Latest Release&lt;/a&gt; &lt;/p&gt;  &#xA;&lt;!-- ABOUT THE PROJECT --&gt; &#xA;&lt;h2&gt;About The Project&lt;/h2&gt; &#xA;&lt;p&gt;Using the &lt;strong&gt;release&lt;/strong&gt; build is recommended over the debug build. Only use debug builds if you are going to make a bug report.&lt;/p&gt; &#xA;&lt;h3&gt;KernelSU &amp;amp; APatch users:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install ZygiskNext.&lt;/li&gt; &#xA; &lt;li&gt;Make sure the unmount setting is enabled for the target app in the KernelSU/APatch Manager.&lt;/li&gt; &#xA; &lt;li&gt;Disable &lt;code&gt;Enforce DenyList&lt;/code&gt; in ZygiskNext settings if there is one.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Magisk users:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Update your Magisk to 27.0 or newer for better hiding capabilities. (optional)&lt;/li&gt; &#xA; &lt;li&gt;Turn on Zygisk in Magisk settings.&lt;/li&gt; &#xA; &lt;li&gt;Turn off &lt;code&gt;Enforce DenyList&lt;/code&gt; in Magisk settings.&lt;/li&gt; &#xA; &lt;li&gt;Add the target app to the deny list unless you&#39;re using a Magisk fork with a white list instead.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- CONTRIBUTING --&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are &lt;strong&gt;greatly appreciated&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have a suggestion that would make this better, please fork the repo and create a pull request. You can also simply open an issue with the tag &#34;enhancement&#34;. Don&#39;t forget to give the project a star! Thanks again!&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork the Project&lt;/li&gt; &#xA; &lt;li&gt;Create your Feature Branch (&lt;code&gt;git checkout -b feature/FeatureName&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Commit your Changes (&lt;code&gt;git commit -m &#39;Add some FeatureName&#39;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Push to the Branch (&lt;code&gt;git push origin feature/FeatureName&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Open a Pull Request&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;!-- LICENSE --&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Distributed under the MIT License. See &lt;code&gt;LICENSE&lt;/code&gt; for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/lyra</title>
    <updated>2024-05-19T01:29:37Z</updated>
    <id>tag:github.com,2024-05-19:/google/lyra</id>
    <link href="https://github.com/google/lyra" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Very Low-Bitrate Codec for Speech Compression&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Lyra: a generative low bitrate speech codec&lt;/h1&gt; &#xA;&lt;h2&gt;What is Lyra?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ai.googleblog.com/2021/08/soundstream-end-to-end-neural-audio.html&#34;&gt;Lyra&lt;/a&gt; is a high-quality, low-bitrate speech codec that makes voice communication available even on the slowest networks. To do this it applies traditional codec techniques while leveraging advances in machine learning (ML) with models trained on thousands of hours of data to create a novel method for compressing and transmitting voice signals.&lt;/p&gt; &#xA;&lt;h3&gt;Overview&lt;/h3&gt; &#xA;&lt;p&gt;The basic architecture of the Lyra codec is quite simple. Features are extracted from speech every 20ms and are then compressed for transmission at a desired bitrate between 3.2kbps and 9.2kbps. On the other end, a generative model uses those features to recreate the speech signal.&lt;/p&gt; &#xA;&lt;p&gt;Lyra harnesses the power of new natural-sounding generative models to maintain the low bitrate of parametric codecs while achieving high quality, on par with state-of-the-art waveform codecs used in most streaming and communication platforms today.&lt;/p&gt; &#xA;&lt;p&gt;Computational complexity is reduced by using a cheaper convolutional generative model called SoundStream, which enables Lyra to not only run on cloud servers, but also on-device on low-end phones in real time (with a processing latency of 20ms). This whole system is then trained end-to-end on thousands of hours of speech data with speakers in over 90 languages and optimized to accurately recreate the input audio.&lt;/p&gt; &#xA;&lt;p&gt;Lyra is supported on Android, Linux, Mac and Windows.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;There are a few things you&#39;ll need to do to set up your computer to build Lyra.&lt;/p&gt; &#xA;&lt;h3&gt;Common setup&lt;/h3&gt; &#xA;&lt;p&gt;Lyra is built using Google&#39;s build system, Bazel. Install it following these &lt;a href=&#34;https://docs.bazel.build/versions/master/install.html&#34;&gt;instructions&lt;/a&gt;. Bazel verson 5.0.0 is required, and some Linux distributions may make an older version available in their application repositories, so make sure you are using the required version or newer. The latest version can be downloaded via &lt;a href=&#34;https://github.com/bazelbuild/bazel/releases&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You will also need python3 and numpy installed.&lt;/p&gt; &#xA;&lt;p&gt;Lyra can be built from Linux using Bazel for an ARM Android target, or a Linux target, as well as Mac and Windows for native targets.&lt;/p&gt; &#xA;&lt;h3&gt;Android requirements&lt;/h3&gt; &#xA;&lt;p&gt;Building on android requires downloading a specific version of the android NDK toolchain. If you develop with Android Studio already, you might not need to do these steps if ANDROID_HOME and ANDROID_NDK_HOME are defined and pointing at the right version of the NDK.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Download command line tools from &lt;a href=&#34;https://developer.android.com/studio&#34;&gt;https://developer.android.com/studio&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Unzip and cd to the directory&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Check the available packages to install in case they don&#39;t match the following steps.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bin/sdkmanager  --sdk_root=$HOME/android/sdk --list&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Some systems will already have the java runtime set up. But if you see an error here like &lt;code&gt;ERROR: JAVA_HOME is not set and no &#39;java&#39; command could be found on your PATH.&lt;/code&gt;, this means you need to install the java runtime with &lt;code&gt;sudo apt install default-jdk&lt;/code&gt; first. You will also need to add &lt;code&gt;export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64&lt;/code&gt; (type &lt;code&gt;ls /usr/lib/jvm&lt;/code&gt; to see which path was installed) to your $HOME/.bashrc and reload it with &lt;code&gt;source $HOME/.bashrc&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the r21 ndk, android sdk 30, and build tools:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bin/sdkmanager  --sdk_root=$HOME/android/sdk --install  &#34;platforms;android-30&#34; &#34;build-tools;30.0.3&#34; &#34;ndk;21.4.7075529&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add the following to .bashrc (or export the variables)&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export ANDROID_NDK_HOME=$HOME/android/sdk/ndk/21.4.7075529&#xA;export ANDROID_HOME=$HOME/android/sdk&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Reload .bashrc (with &lt;code&gt;source $HOME/.bashrc&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;The building and running process differs slightly depending on the selected platform.&lt;/p&gt; &#xA;&lt;h3&gt;Building for Linux&lt;/h3&gt; &#xA;&lt;p&gt;You can build the cc_binaries with the default config. &lt;code&gt;encoder_main&lt;/code&gt; is an example of a file encoder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bazel build -c opt lyra/cli_example:encoder_main&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can run &lt;code&gt;encoder_main&lt;/code&gt; to encode a test .wav file with some speech in it, specified by &lt;code&gt;--input_path&lt;/code&gt;. The &lt;code&gt;--output_dir&lt;/code&gt; specifies where to write the encoded (compressed) representation, and the desired bitrate can be specified using the &lt;code&gt;--bitrate&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bazel-bin/lyra/cli_example/encoder_main --input_path=lyra/testdata/sample1_16kHz.wav --output_dir=$HOME/temp --bitrate=3200&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, you can build decoder_main and use it on the output of encoder_main to decode the encoded data back into speech.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bazel build -c opt lyra/cli_example:decoder_main&#xA;bazel-bin/lyra/cli_example/decoder_main --encoded_path=$HOME/temp/sample1_16kHz.lyra --output_dir=$HOME/temp/ --bitrate=3200&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the default Bazel toolchain is automatically configured and likely uses gcc/libstdc++ on Linux. This should be satisfactory for most users, but will differ from the NDK toolchain, which uses clang/libc++. To use a custom clang toolchain on Linux, see toolchain/README.md and .bazelrc.&lt;/p&gt; &#xA;&lt;h3&gt;Building for Android&lt;/h3&gt; &#xA;&lt;h4&gt;Android App&lt;/h4&gt; &#xA;&lt;p&gt;There is an example APK target called &lt;code&gt;lyra_android_example&lt;/code&gt; that you can build after you have set up the NDK.&lt;/p&gt; &#xA;&lt;p&gt;This example is an app with a minimal GUI that has buttons for two options. One option is to record from the microphone and encode/decode with Lyra so you can test what Lyra would sound like for your voice. The other option runs a benchmark that encodes and decodes in the background and prints the timings to logcat.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bazel build -c opt lyra/android_example:lyra_android_example --config=android_arm64 --copt=-DBENCHMARK&#xA;adb install bazel-bin/lyra/android_example/lyra_android_example.apk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After this you should see an app called &#34;Lyra Example App&#34;.&lt;/p&gt; &#xA;&lt;p&gt;You can open it, and you will see a simple TextView that says the benchmark is running, and when it finishes.&lt;/p&gt; &#xA;&lt;p&gt;Press &#34;Record from microphone&#34;, say a few words, and then press &#34;Encode and decode to speaker&#34;. You should hear your voice being played back after being coded with Lyra.&lt;/p&gt; &#xA;&lt;p&gt;If you press &#39;Benchmark&#39;, you should see something like the following in logcat on a Pixel 6 Pro when running the benchmark:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;lyra_benchmark:  feature_extractor:  max: 1.836 ms  min: 0.132 ms  mean: 0.153 ms  stdev: 0.042 ms&#xA;lyra_benchmark: quantizer_quantize:  max: 1.042 ms  min: 0.120 ms  mean: 0.130 ms  stdev: 0.028 ms&#xA;lyra_benchmark:   quantizer_decode:  max: 0.103 ms  min: 0.026 ms  mean: 0.029 ms  stdev: 0.003 ms&#xA;lyra_benchmark:       model_decode:  max: 0.820 ms  min: 0.191 ms  mean: 0.212 ms  stdev: 0.031 ms&#xA;lyra_benchmark:              total:  max: 2.536 ms  min: 0.471 ms  mean: 0.525 ms  stdev: 0.088 ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This shows that decoding a 50Hz frame (each frame is 20 milliseconds) takes 0.525 milliseconds on average. So decoding is performed at around 38 (20/0.525) times faster than realtime.&lt;/p&gt; &#xA;&lt;p&gt;To build your own android app, you can either use the cc_library target outputs to create a .so that you can use in your own build system. Or you can use it with an &lt;a href=&#34;https://docs.bazel.build/versions/master/be/android.html&#34;&gt;&lt;code&gt;android_binary&lt;/code&gt;&lt;/a&gt; rule within bazel to create an .apk file as in this example.&lt;/p&gt; &#xA;&lt;p&gt;There is a tutorial on building for android with Bazel in the &lt;a href=&#34;https://docs.bazel.build/versions/master/android-ndk.html&#34;&gt;bazel docs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Android command-line binaries&lt;/h4&gt; &#xA;&lt;p&gt;There are also the binary targets that you can use to experiment with encoding and decoding .wav files.&lt;/p&gt; &#xA;&lt;p&gt;You can build the example cc_binary targets with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bazel build -c opt lyra/cli_example:encoder_main --config=android_arm64&#xA;bazel build -c opt lyra/cli_example:decoder_main --config=android_arm64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This builds an executable binary that can be run on android 64-bit arm devices (not an android app). You can then push it to your android device and run it as a binary through the shell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Push the binary and the data it needs, including the model and .wav files:&#xA;adb push bazel-bin/lyra/cli_example/encoder_main /data/local/tmp/&#xA;adb push bazel-bin/lyra/cli_example/decoder_main /data/local/tmp/&#xA;adb push lyra/model_coeffs/ /data/local/tmp/&#xA;adb push lyra/testdata/ /data/local/tmp/&#xA;&#xA;adb shell&#xA;cd /data/local/tmp&#xA;./encoder_main --model_path=/data/local/tmp/model_coeffs --output_dir=/data/local/tmp --input_path=testdata/sample1_16kHz.wav&#xA;./decoder_main --model_path=/data/local/tmp/model_coeffs --output_dir=/data/local/tmp --encoded_path=sample1_16kHz.lyra&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The encoder_main/decoder_main as above should also work.&lt;/p&gt; &#xA;&lt;h3&gt;Building for Mac&lt;/h3&gt; &#xA;&lt;p&gt;You will need to install the XCode command line tools in addition to the prerequisites common to all platforms. XCode setup is a required step for using Bazel on Mac. See this &lt;a href=&#34;https://bazel.build/install/os-x&#34;&gt;guide&lt;/a&gt; for how to install XCode command line tools. Lyra has been built successfully using XCode 13.3.&lt;/p&gt; &#xA;&lt;p&gt;You can follow the instructions in the &lt;a href=&#34;https://raw.githubusercontent.com/google/lyra/main/#building-for-linux&#34;&gt;Building for Linux&lt;/a&gt; section once this is completed.&lt;/p&gt; &#xA;&lt;h3&gt;Building for Windows&lt;/h3&gt; &#xA;&lt;p&gt;You will need to install Build Tools for Visual Studio 2019 in addition to the prerequisites common to all platforms. Visual Studio setup is a required step for building C++ for Bazel on Windows. See this &lt;a href=&#34;https://bazel.build/install/windows&#34;&gt;guide&lt;/a&gt; for how to install MSVC. You may also need to install python 3 support, which is also described in the guide.&lt;/p&gt; &#xA;&lt;p&gt;You can follow the instructions in the &lt;a href=&#34;https://raw.githubusercontent.com/google/lyra/main/#building-for-linux&#34;&gt;Building for Linux&lt;/a&gt; section once this is completed.&lt;/p&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;For integrating Lyra into any project only two APIs are relevant: &lt;a href=&#34;https://raw.githubusercontent.com/google/lyra/main/lyra/lyra_encoder.h&#34;&gt;LyraEncoder&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/google/lyra/main/lyra/lyra_decoder.h&#34;&gt;LyraDecoder&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;DISCLAIMER: At this time Lyra&#39;s API and bit-stream are &lt;strong&gt;not&lt;/strong&gt; guaranteed to be stable and might change in future versions of the code.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;On the sending side, &lt;code&gt;LyraEncoder&lt;/code&gt; can be used to encode an audio stream using the following interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class LyraEncoder : public LyraEncoderInterface {&#xA; public:&#xA;  static std::unique_ptr&amp;lt;LyraEncoder&amp;gt; Create(&#xA;      int sample_rate_hz, int num_channels, int bitrate, bool enable_dtx,&#xA;      const ghc::filesystem::path&amp;amp; model_path);&#xA;&#xA;  std::optional&amp;lt;std::vector&amp;lt;uint8_t&amp;gt;&amp;gt; Encode(&#xA;      const absl::Span&amp;lt;const int16_t&amp;gt; audio) override;&#xA;&#xA;  bool set_bitrate(int bitrate) override;&#xA;&#xA;  int sample_rate_hz() const override;&#xA;&#xA;  int num_channels() const override;&#xA;&#xA;  int bitrate() const override;&#xA;&#xA;  int frame_rate() const override;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The static &lt;code&gt;Create&lt;/code&gt; method instantiates a &lt;code&gt;LyraEncoder&lt;/code&gt; with the desired sample rate in Hertz, number of channels and bitrate, as long as those parameters are supported (see &lt;code&gt;lyra_encoder.h&lt;/code&gt; for supported parameters). Otherwise it returns a nullptr. The &lt;code&gt;Create&lt;/code&gt; method also needs to know if DTX should be enabled and where the model weights are stored. It also checks that these weights exist and are compatible with the current Lyra version.&lt;/p&gt; &#xA;&lt;p&gt;Given a &lt;code&gt;LyraEncoder&lt;/code&gt;, any audio stream can be compressed using the &lt;code&gt;Encode&lt;/code&gt; method. The provided span of int16-formatted samples is assumed to contain 20ms of data at the sample rate chosen at &lt;code&gt;Create&lt;/code&gt; time. As long as this condition is met the &lt;code&gt;Encode&lt;/code&gt; method returns the encoded packet as a vector of bytes that is ready to be stored or transmitted over the network.&lt;/p&gt; &#xA;&lt;p&gt;The bitrate can be dynamically modified using the &lt;code&gt;set_bitrate&lt;/code&gt; setter. It returns true if the desired bitrate is supported and correctly set.&lt;/p&gt; &#xA;&lt;p&gt;The rest of the &lt;code&gt;LyraEncoder&lt;/code&gt; methods are just getters for the different predetermined parameters.&lt;/p&gt; &#xA;&lt;p&gt;On the receiving end, &lt;code&gt;LyraDecoder&lt;/code&gt; can be used to decode the encoded packet using the following interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class LyraDecoder : public LyraDecoderInterface {&#xA; public:&#xA;  static std::unique_ptr&amp;lt;LyraDecoder&amp;gt; Create(&#xA;      int sample_rate_hz, int num_channels,&#xA;      const ghc::filesystem::path&amp;amp; model_path);&#xA;&#xA;  bool SetEncodedPacket(absl::Span&amp;lt;const uint8_t&amp;gt; encoded) override;&#xA;&#xA;  std::optional&amp;lt;std::vector&amp;lt;int16_t&amp;gt;&amp;gt; DecodeSamples(int num_samples) override;&#xA;&#xA;  int sample_rate_hz() const override;&#xA;&#xA;  int num_channels() const override;&#xA;&#xA;  int frame_rate() const override;&#xA;&#xA;  bool is_comfort_noise() const override;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once again, the static &lt;code&gt;Create&lt;/code&gt; method instantiates a &lt;code&gt;LyraDecoder&lt;/code&gt; with the desired sample rate in Hertz and number of channels, as long as those parameters are supported. Else it returns a &lt;code&gt;nullptr&lt;/code&gt;. These parameters don&#39;t need to be the same as the ones in &lt;code&gt;LyraEncoder&lt;/code&gt;. And once again, the &lt;code&gt;Create&lt;/code&gt; method also needs to know where the model weights are stored. It also checks that these weights exist and are compatible with the current Lyra version.&lt;/p&gt; &#xA;&lt;p&gt;Given a &lt;code&gt;LyraDecoder&lt;/code&gt;, any packet can be decoded by first feeding it into &lt;code&gt;SetEncodedPacket&lt;/code&gt;, which returns true if the provided span of bytes is a valid Lyra-encoded packet.&lt;/p&gt; &#xA;&lt;p&gt;Then the int16-formatted samples can be obtained by calling &lt;code&gt;DecodeSamples&lt;/code&gt;. If there isn&#39;t a packet available, but samples still need to be generated, the decoder might switch to a comfort noise generation mode, which can be checked using &lt;code&gt;is_comfort_noise&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The rest of the &lt;code&gt;LyraDecoder&lt;/code&gt; methods are just getters for the different predetermined parameters.&lt;/p&gt; &#xA;&lt;p&gt;For an example on how to use &lt;code&gt;LyraEncoder&lt;/code&gt; and &lt;code&gt;LyraDecoder&lt;/code&gt; to encode and decode a stream of audio, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/google/lyra/main/lyra/lyra_integration_test.cc&#34;&gt;integration test&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Use of this source code is governed by a Apache v2.0 license that can be found in the LICENSE file.&lt;/p&gt; &#xA;&lt;h2&gt;Papers&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Kleijn, W. B., Lim, F. S., Luebs, A., Skoglund, J., Stimberg, F., Wang, Q., &amp;amp; Walters, T. C. (2018, April). &lt;a href=&#34;https://arxiv.org/pdf/1712.01120&#34;&gt;Wavenet based low rate speech coding&lt;/a&gt;. In 2018 IEEE international conference on acoustics, speech and signal processing (ICASSP) (pp. 676-680). IEEE.&lt;/li&gt; &#xA; &lt;li&gt;Denton, T., Luebs, A., Chinen, M., Lim, F. S., Storus, A., Yeh, H., Kleijn, W. B., &amp;amp; Skoglund, J. (2020, November). &lt;a href=&#34;https://arxiv.org/pdf/2102.11906&#34;&gt;Handling Background Noise in Neural Speech Generation&lt;/a&gt;. In 2020 54th Asilomar Conference on Signals, Systems, and Computers (pp. 667-671). IEEE.&lt;/li&gt; &#xA; &lt;li&gt;Kleijn, W. B., Storus, A., Chinen, M., Denton, T., Lim, F. S., Luebs, A., Skoglund, J., &amp;amp; Yeh, H. (2021, June). &lt;a href=&#34;https://arxiv.org/pdf/2102.09660&#34;&gt;Generative speech coding with predictive variance regularization&lt;/a&gt;. In ICASSP 2021-2021 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP) (pp. 6478-6482). IEEE.&lt;/li&gt; &#xA; &lt;li&gt;Zeghidour, N., Luebs, A., Omran, A., Skoglund, J., &amp;amp; Tagliasacchi, M. (2021). &lt;a href=&#34;https://arxiv.org/pdf/2107.03312&#34;&gt;SoundStream: An end-to-end neural audio codec&lt;/a&gt;. IEEE/ACM Transactions on Audio, Speech, and Language Processing.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>