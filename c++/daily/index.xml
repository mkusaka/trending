<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-19T01:31:57Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>intel/x86-simd-sort</title>
    <updated>2023-02-19T01:31:57Z</updated>
    <id>tag:github.com,2023-02-19:/intel/x86-simd-sort</id>
    <link href="https://github.com/intel/x86-simd-sort" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C++ header file library for high performance SIMD based sorting algorithms for primitive datatypes&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;x86-simd-sort&lt;/h1&gt; &#xA;&lt;p&gt;C++ header file library for SIMD based 16-bit, 32-bit and 64-bit data type sorting on x86 processors. Source header files are available in src directory. We currently only have AVX-512 based implementation of quicksort. This repository also includes a test suite which can be built and run to test the sorting algorithms for correctness. It also has benchmarking code to compare its performance relative to std::sort.&lt;/p&gt; &#xA;&lt;h2&gt;Algorithm details&lt;/h2&gt; &#xA;&lt;p&gt;The ideas and code are based on these two research papers [1] and [2]. On a high level, the idea is to vectorize quicksort partitioning using AVX-512 compressstore instructions. If the array size is &amp;lt; 128, then use Bitonic sorting network implemented on 512-bit registers. The precise network definitions depend on the size of the dtype and are defined in separate files: &lt;code&gt;avx512-16bit-qsort.hpp&lt;/code&gt;, &lt;code&gt;avx512-32bit-qsort.hpp&lt;/code&gt; and &lt;code&gt;avx512-64bit-qsort.hpp&lt;/code&gt;. Article [4] is a good resource for bitonic sorting network. The core implementations of the vectorized qsort functions &lt;code&gt;avx512_qsort&amp;lt;T&amp;gt;(T*, int64_t)&lt;/code&gt; are modified versions of avx2 quicksort presented in the paper [2] and source code associated with that paper [3].&lt;/p&gt; &#xA;&lt;h2&gt;Handling NAN in float and double arrays&lt;/h2&gt; &#xA;&lt;p&gt;If you expect your array to contain NANs, please be aware that the these routines &lt;strong&gt;do not preserve your NANs as you pass them&lt;/strong&gt;. The &lt;code&gt;avx512_qsort&amp;lt;T&amp;gt;()&lt;/code&gt; routine will put all your NAN&#39;s at the end of the sorted array and replace them with &lt;code&gt;std::nan(&#34;1&#34;)&lt;/code&gt;. Please take a look at &lt;code&gt;avx512_qsort&amp;lt;float&amp;gt;()&lt;/code&gt; and &lt;code&gt;avx512_qsort&amp;lt;double&amp;gt;()&lt;/code&gt; functions for details.&lt;/p&gt; &#xA;&lt;h2&gt;Example to include and build this in a C++ code&lt;/h2&gt; &#xA;&lt;h3&gt;Sample code &lt;code&gt;main.cpp&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;src/avx512-32bit-qsort.hpp&#34;&#xA;&#xA;int main() {&#xA;    const int ARRSIZE = 10;&#xA;    std::vector&amp;lt;float&amp;gt; arr;&#xA;&#xA;    /* Initialize elements is reverse order */&#xA;    for (int ii = 0; ii &amp;lt; ARRSIZE; ++ii) {&#xA;        arr.push_back(ARRSIZE - ii);&#xA;    }&#xA;&#xA;    /* call avx512 quicksort */&#xA;    avx512_qsort&amp;lt;float&amp;gt;(arr.data(), ARRSIZE);&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build using gcc&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;gcc main.cpp -mavx512f -mavx512dq -O3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is a header file only library and we do not provide any compile time and run time checks which is recommended while including this your source code. A slightly modified version of this source code has been contributed to &lt;a href=&#34;https://github.com/numpy/numpy&#34;&gt;NumPy&lt;/a&gt; (see this &lt;a href=&#34;https://github.com/numpy/numpy/pull/22315&#34;&gt;pull request&lt;/a&gt; for details). This NumPy pull request is a good reference for how to include and build this library with your source code.&lt;/p&gt; &#xA;&lt;h2&gt;Build requirements&lt;/h2&gt; &#xA;&lt;p&gt;None, its header files only. However you will need &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;meson&lt;/code&gt; to build the unit tests and benchmarking suite. You will need a relatively modern compiler to build.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;gcc &amp;gt;= 8.x&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build using Make&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;make&lt;/code&gt; command builds two executables:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;testexe&lt;/code&gt;: runs a bunch of tests written in ./tests directory.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;benchexe&lt;/code&gt;: measures performance of these algorithms for various data types and compares them to std::sort.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;make test&lt;/code&gt; and &lt;code&gt;make bench&lt;/code&gt; to build just the &lt;code&gt;testexe&lt;/code&gt; and &lt;code&gt;benchexe&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;h3&gt;Build using Meson&lt;/h3&gt; &#xA;&lt;p&gt;You can also build &lt;code&gt;testexe&lt;/code&gt; and &lt;code&gt;benchexe&lt;/code&gt; using Meson/Ninja with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;meson setup builddir &amp;amp;&amp;amp; cd builddir &amp;amp;&amp;amp; ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Requirements and dependencies&lt;/h2&gt; &#xA;&lt;p&gt;The sorting routines relies only on the C++ Standard Library and requires a relatively modern compiler to build (gcc 8.x and above). Since they use the AVX-512 instruction set, they can only run on processors that have AVX-512. Specifically, the 32-bit and 64-bit require AVX-512F and AVX-512DQ instruction set. The 16-bit sorting requires the AVX-512F, AVX-512BW and AVX-512 VMBI2 instruction set. The test suite is written using the Google test framework.&lt;/p&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;[1] Fast and Robust Vectorized In-Place Sorting of Primitive Types &lt;a href=&#34;https://drops.dagstuhl.de/opus/volltexte/2021/13775/&#34;&gt;https://drops.dagstuhl.de/opus/volltexte/2021/13775/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[2] A Novel Hybrid Quicksort Algorithm Vectorized using AVX-512 on Intel Skylake &lt;a href=&#34;https://arxiv.org/pdf/1704.08579.pdf&#34;&gt;https://arxiv.org/pdf/1704.08579.pdf&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[3] &lt;a href=&#34;https://github.com/simd-sorting/fast-and-robust&#34;&gt;https://github.com/simd-sorting/fast-and-robust&lt;/a&gt;: SPDX-License-Identifier: MIT&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;[4] &lt;a href=&#34;http://mitp-content-server.mit.edu:18180/books/content/sectbyfn?collid=books_pres_0&amp;amp;fn=Chapter%2027.pdf&amp;amp;id=8030&#34;&gt;http://mitp-content-server.mit.edu:18180/books/content/sectbyfn?collid=books_pres_0&amp;amp;fn=Chapter%2027.pdf&amp;amp;id=8030&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>SleepTheGod/SSH-Remote-Code-Execution</title>
    <updated>2023-02-19T01:31:57Z</updated>
    <id>tag:github.com,2023-02-19:/SleepTheGod/SSH-Remote-Code-Execution</id>
    <link href="https://github.com/SleepTheGod/SSH-Remote-Code-Execution" rel="alternate"></link>
    <summary type="html">&lt;p&gt;SSH Zero-Day Made By ClumsyLulz&lt;/p&gt;&lt;hr&gt;&lt;p&gt;| # SSH Remote Code Execution | | SSH Zero-Day | Made By ClumsyLulz | Taylor Christian Newsome | Summary: The code provided is a C program that receives input parameters and generates a packet to be sent to a server via the SSH protocol. The program creates a buffer to store data to be sent, and then writes it to a file. It then creates a command line string to execute an SSH connection to the specified host and port, using the &#34;system&#34; function. Issues: There are several issues with the code that have been identified: The program contains a buffer overflow vulnerability in the malloc function where only 28 bytes are allocated for the buffer, but 29 bytes are written to it. This can lead to memory corruption or a segmentation fault. The return address calculation is incorrect. The program is using the value of the packet length instead of the buffer size to determine the return address, resulting in an incorrect value. The format string in the printf statement for the return address is incorrect, resulting in an undefined behavior. The program does not check the return value of the &#34;open&#34; and &#34;write&#34; functions, which can lead to data loss or failure to write the buffer to the file. The program does not free the memory allocated for the &#34;buffer&#34; and &#34;ssh&#34; pointers, which can lead to memory leaks. The program uses the &#34;system&#34; function to execute the SSH command, which can lead to security vulnerabilities, as it allows arbitrary commands to be executed with elevated privileges. Recommendations: To address the issues outlined above, the following recommendations are proposed: Increase the size of the buffer allocation to 29 bytes to avoid buffer overflow issues. Correct the return address calculation by using the buffer size instead of the packet length. Correct the format string in the printf statement for the return address. Check the return values of the &#34;open&#34; and &#34;write&#34; functions, and handle errors appropriately. Free the memory allocated for the &#34;buffer&#34; and &#34;ssh&#34; pointers. Replace the &#34;system&#34; function with a safer alternative, such as &#34;execvp&#34;, to avoid potential security vulnerabilities. It is recommended that these changes be made to the program to ensure its stability and security.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cpputest/cpputest</title>
    <updated>2023-02-19T01:31:57Z</updated>
    <id>tag:github.com,2023-02-19:/cpputest/cpputest</id>
    <link href="https://github.com/cpputest/cpputest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CppUTest unit testing and mocking framework for C/C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CppUTest&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cpputest/cpputest/actions/workflows/basic.yml&#34;&gt;&lt;img src=&#34;https://github.com/cpputest/cpputest/actions/workflows/basic.yml/badge.svg?sanitize=true&#34; alt=&#34;GitHub Actions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://ci.appveyor.com/project/basvodde/cpputest&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/irh38i4wblsb5tew?svg=true&#34; alt=&#34;AppveyorBuild status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/cpputest/cpputest?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/cpputest/cpputest/badge.svg?branch=master&amp;amp;service=github&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://conan.io/center/cpputest&#34;&gt;&lt;img src=&#34;https://repology.org/badge/version-for-repo/conancenter/cpputest.svg?sanitize=true&#34; alt=&#34;ConanCenter package&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;CppUTest unit testing and mocking framework for C/C++&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cpputest.github.io&#34;&gt;More information on the project page&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Slack channel: &lt;a href=&#34;https://join.slack.com/t/cpputest/shared_invite/zt-epq97u9h-6yBQHHl2cvUADjEENtdASw&#34;&gt;Join if link not expired&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;You&#39;ll need to do the following to get started:&lt;/p&gt; &#xA;&lt;p&gt;Building from source (Unix-based, Cygwin, MacOS):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/cpputest/cpputest.git&#xA;cd cpputest_build&#xA;autoreconf .. -i&#xA;../configure&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;make install&lt;/code&gt; if you want to install CppUTest system-wide.&lt;/p&gt; &#xA;&lt;p&gt;You can also use CMake, which also works for Windows Visual Studio.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git://github.com/cpputest/cpputest.git&#xA;cmake -B cpputest_build&#xA;cmake --build cpputest_build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then to get started, you&#39;ll need to do the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add the include path to the Makefile. Something like: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;CPPFLAGS += -I$(CPPUTEST_HOME)/include&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add the memory leak macros to your Makefile (needed for additional debug info!). Something like: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;CXXFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorNewMacros.h&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;CFLAGS += -include $(CPPUTEST_HOME)/include/CppUTest/MemoryLeakDetectorMallocMacros.h&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Add the library linking to your Makefile. Something like: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;LD_LIBRARIES = -L$(CPPUTEST_HOME)/lib -lCppUTest -lCppUTestExt&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After this, you can write your first test:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;TEST_GROUP(FirstTestGroup)&#xA;{&#xA;};&#xA;&#xA;TEST(FirstTestGroup, FirstTest)&#xA;{&#xA;   FAIL(&#34;Fail me!&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can build and install cpputest using &lt;a href=&#34;https://github.com/Microsoft/vcpkg/&#34;&gt;vcpkg&lt;/a&gt; dependency manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ vcpkg install cpputest (More information: https://github.com/microsoft/vcpkg)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Command line switches&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-h&lt;/code&gt; help, shows the latest help, including the parameters we&#39;ve implemented after updating this README page.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-v&lt;/code&gt; verbose, print each test name as it runs&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-r#&lt;/code&gt; repeat the tests some number of times, default is one, default if # is not specified is 2. This is handy if you are experiencing memory leaks related to statics and caches.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-s#&lt;/code&gt; random shuffle the test execution order. # is an integer used for seeding the random number generator. # is optional, and if omitted, the seed value is chosen automatically, which results in a different order every time. The seed value is printed to console to make it possible to reproduce a previously generated execution order. Handy for detecting problems related to dependencies between tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-g&lt;/code&gt; group only run test whose group contains the substring group&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-n&lt;/code&gt; name only run test whose name contains the substring name&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-f&lt;/code&gt; crash on fail, run the tests as normal but, when a test fails, crash rather than report the failure in the normal way&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Test Macros&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;TEST(group, name)&lt;/code&gt; - define a test&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IGNORE_TEST(group, name)&lt;/code&gt; - turn off the execution of a test&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TEST_GROUP(group)&lt;/code&gt; - Declare a test group to which certain tests belong. This will also create the link needed from another library.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TEST_GROUP_BASE(group, base)&lt;/code&gt; - Same as &lt;code&gt;TEST_GROUP&lt;/code&gt;, just use a different base class than Utest&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TEST_SETUP()&lt;/code&gt; - Declare a void setup method in a &lt;code&gt;TEST_GROUP&lt;/code&gt; - this is the same as declaring void &lt;code&gt;setup()&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TEST_TEARDOWN()&lt;/code&gt; - Declare a void setup method in a &lt;code&gt;TEST_GROUP&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IMPORT_TEST_GROUP(group)&lt;/code&gt; - Export the name of a test group so it can be linked in from a library. Needs to be done in &lt;code&gt;main&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Set up and tear down support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each &lt;code&gt;TEST_GROUP&lt;/code&gt; may contain a &lt;code&gt;setup&lt;/code&gt; and/or a &lt;code&gt;teardown&lt;/code&gt; method.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;setup()&lt;/code&gt; is called prior to each &lt;code&gt;TEST&lt;/code&gt; body and &lt;code&gt;teardown()&lt;/code&gt; is called after the test body.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Assertion Macros&lt;/h2&gt; &#xA;&lt;p&gt;The failure of one of these macros causes the current test to immediately exit&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;CHECK(boolean condition)&lt;/code&gt; - checks any boolean result&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CHECK_TRUE(boolean condition)&lt;/code&gt; - checks for true&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CHECK_FALSE(boolean condition)&lt;/code&gt; - checks for false&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;CHECK_EQUAL(expected, actual)&lt;/code&gt; - checks for equality between entities using &lt;code&gt;==&lt;/code&gt;. So if you have a class that supports &lt;code&gt;operator==()&lt;/code&gt; you can use this macro to compare two instances.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;STRCMP_EQUAL(expected, actual)&lt;/code&gt; - check const &lt;code&gt;char*&lt;/code&gt; strings for equality using &lt;code&gt;strcmp&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;LONGS_EQUAL(expected, actual)&lt;/code&gt; - Compares two numbers&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BYTES_EQUAL(expected, actual)&lt;/code&gt; - Compares two numbers, eight bits wide&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;POINTERS_EQUAL(expected, actual)&lt;/code&gt; - Compares two &lt;code&gt;const void *&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;DOUBLES_EQUAL(expected, actual, tolerance)&lt;/code&gt; - Compares two doubles within some tolerance&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ENUMS_EQUAL_INT(excepted, actual)&lt;/code&gt; - Compares two enums which their underlying type is &lt;code&gt;int&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ENUMS_EQUAL_TYPE(underlying_type, excepted, actual)&lt;/code&gt; - Compares two enums which they have the same underlying type&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;FAIL(text)&lt;/code&gt; - always fails&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TEST_EXIT&lt;/code&gt; - Exit the test without failure - useful for contract testing (implementing an assert fake)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Customize &lt;code&gt;CHECK_EQUAL&lt;/code&gt; to work with your types that support &lt;code&gt;operator==()&lt;/code&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Create the function: &lt;code&gt;SimpleString StringFrom(const yourType&amp;amp;)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Extensions directory has a few of these.&lt;/p&gt; &#xA;&lt;h2&gt;Building default checks with TestPlugin&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CppUTest can support extra checking functionality by inserting TestPlugins&lt;/li&gt; &#xA; &lt;li&gt;TestPlugin is derived from the TestPlugin class and can be inserted in the TestRegistry via the installPlugin method.&lt;/li&gt; &#xA; &lt;li&gt;TestPlugins can be used for, for example, system stability and resource handling like files, memory or network connection clean-up.&lt;/li&gt; &#xA; &lt;li&gt;In CppUTest, the memory leak detection is done via a default enabled TestPlugin&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example of a main with a TestPlugin:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int ac, char** av)&#xA;{&#xA;   LogPlugin logPlugin;&#xA;   TestRegistry::getCurrentRegistry()-&amp;gt;installPlugin(&amp;amp;logPlugin);&#xA;   int result = CommandLineTestRunner::RunAllTests(ac, av);&#xA;   TestRegistry::getCurrentRegistry()-&amp;gt;resetPlugins();&#xA;   return result;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Memory leak detection&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A platform specific memory leak detection mechanism is provided.&lt;/li&gt; &#xA; &lt;li&gt;If a test fails and has allocated memory prior to the fail and that memory is not cleaned up by TearDown, a memory leak is reported. It is best to only chase memory leaks when other errors have been eliminated.&lt;/li&gt; &#xA; &lt;li&gt;Some code uses lazy initialization and appears to leak when it really does not (for example: gcc stringstream used to in an earlier release). One cause is that some standard library calls allocate something and do not free it until after &lt;code&gt;main&lt;/code&gt; (or never). To find out if a memory leak is due to lazy initialization set the &lt;code&gt;-r&lt;/code&gt; switch to run tests twice. The signature of this situation is that the first run shows leaks and the second run shows no leaks. When both runs show leaks, you have a leak to find.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How is memory leak detection implemented?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Before &lt;code&gt;setup()&lt;/code&gt; a memory usage checkpoint is recorded&lt;/li&gt; &#xA; &lt;li&gt;After &lt;code&gt;teardown()&lt;/code&gt; another checkpoint is taken and compared to the original checkpoint&lt;/li&gt; &#xA; &lt;li&gt;In Visual Studio the MS debug heap capabilities are used&lt;/li&gt; &#xA; &lt;li&gt;For GCC a simple new/delete count is used in overridden operators &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new[]&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you use some leaky code that you can&#39;t or won&#39;t fix you can tell a TEST to ignore a certain number of leaks as in this example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;TEST(MemoryLeakWarningTest, Ignore1)&#xA;{&#xA;    EXPECT_N_LEAKS(1);&#xA;    char* arrayToLeak1 = new char[100];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example Main&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;CppUTest/CommandLineTestRunner.h&#34;&#xA;&#xA;int main(int ac, char** av)&#xA;{&#xA;  return RUN_ALL_TESTS(ac, av);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Example Test&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;CppUTest/TestHarness.h&#34;&#xA;#include &#34;ClassName.h&#34;&#xA;&#xA;TEST_GROUP(ClassName)&#xA;{&#xA;  ClassName* className;&#xA;&#xA;  void setup()&#xA;  {&#xA;    className = new ClassName();&#xA;  }&#xA;  void teardown()&#xA;  {&#xA;    delete className;&#xA;  }&#xA;};&#xA;&#xA;TEST(ClassName, Create)&#xA;{&#xA;  CHECK(0 != className);&#xA;  CHECK(true);&#xA;  CHECK_EQUAL(1,1);&#xA;  LONGS_EQUAL(1,1);&#xA;  DOUBLES_EQUAL(1.000, 1.001, .01);&#xA;  STRCMP_EQUAL(&#34;hello&#34;, &#34;hello&#34;);&#xA;  FAIL(&#34;The prior tests pass, but this one doesn&#39;t&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are some scripts that are helpful in creating your initial h, cpp, and Test files. See scripts/README.TXT&lt;/p&gt; &#xA;&lt;h2&gt;Conan&lt;/h2&gt; &#xA;&lt;p&gt;CppUTest is available through &lt;a href=&#34;https://conan.io/center/cpputest&#34;&gt;conan-center&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;conanfile.txt&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[requires]&#xA;cpputest/4.0&#xA;&#xA;[generators]&#xA;cmake_find_package&#xA;cmake_paths&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;CMake&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;find_package(CppUTest REQUIRED)&#xA;&#xA;add_executable(example_test ExampleTest.cpp)&#xA;&#xA;target_link_libraries(example_test PRIVATE&#xA;    CppUTest::CppUTest&#xA;    CppUTest::CppUTestExt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integration as external CMake project&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you want to use CppUTest in your project without installing it to your system or for having control over the version you are using. This little snippet get the wanted version from GitHub and builds it as a library.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;# CppUTest&#xA;include(FetchContent)&#xA;FetchContent_Declare(&#xA;    CppUTest&#xA;    GIT_REPOSITORY https://github.com/cpputest/cpputest.git&#xA;    GIT_TAG        master # or use release tag, eg. v4.0&#xA;)&#xA;# Set this to ON if you want to have the CppUTests in your project as well.&#xA;set(TESTS OFF CACHE BOOL &#34;Switch off CppUTest Test build&#34;)&#xA;FetchContent_MakeAvailable(CppUTest)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can be used then like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;add_executable(run_tests UnitTest1.cpp UnitTest2.cpp)&#xA;&#xA;target_link_libraries(example_test PRIVATE&#xA;    CppUTest::CppUTest&#xA;    CppUTest::CppUTestExt)&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>