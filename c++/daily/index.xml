<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-17T01:27:27Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>okalachev/flix</title>
    <updated>2024-05-17T01:27:27Z</updated>
    <id>tag:github.com,2024-05-17:/okalachev/flix</id>
    <link href="https://github.com/okalachev/flix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Making an ESP32-based quadcopter from scratch&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;flix&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;flix&lt;/strong&gt; (&lt;em&gt;flight + X&lt;/em&gt;) — making an open source ESP32-based quadcopter from scratch.&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/flix.jpg&#34; width=&#34;500&#34; alt=&#34;Flix quadcopter&#34;&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple and clean Arduino based source code.&lt;/li&gt; &#xA; &lt;li&gt;Acro and Stabilized flight using remote control.&lt;/li&gt; &#xA; &lt;li&gt;Precise simulation using Gazebo.&lt;/li&gt; &#xA; &lt;li&gt;In-RAM logging.&lt;/li&gt; &#xA; &lt;li&gt;Command line interface through USB port.&lt;/li&gt; &#xA; &lt;li&gt;Wi-Fi support.&lt;/li&gt; &#xA; &lt;li&gt;MAVLink support.&lt;/li&gt; &#xA; &lt;li&gt;Control using mobile phone (with QGroundControl app).&lt;/li&gt; &#xA; &lt;li&gt;ESCs with reverse mode support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Textbook and videos for students on writing a flight controller*.&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Completely 3D-printed frame&lt;/em&gt;.*&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Position control and autonomous flights using external camera*&lt;/em&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/build.md&#34;&gt;Building and running instructions&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;em&gt;* — planned.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;It actually flies&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://youtu.be/8GzzIQ3C6DQ&#34;&gt;&lt;img width=&#34;500&#34; src=&#34;https://i3.ytimg.com/vi/8GzzIQ3C6DQ/maxresdefault.jpg&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;See YouTube demo video: &lt;a href=&#34;https://youtu.be/8GzzIQ3C6DQ&#34;&gt;https://youtu.be/8GzzIQ3C6DQ&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Simulation&lt;/h2&gt; &#xA;&lt;p&gt;Simulation in Gazebo using a plugin that runs original Arduino code is implemented:&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/simulator.png&#34; width=&#34;500&#34; alt=&#34;Flix simulator&#34;&gt; &#xA;&lt;h2&gt;Schematics&lt;/h2&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/schematics.svg?sanitize=true&#34; width=&#34;800&#34; alt=&#34;Flix schematics&#34;&gt; &#xA;&lt;p&gt;You can also check a user contributed &lt;a href=&#34;https://miro.com/app/board/uXjVN-dTjoo=/&#34;&gt;variant of complete circuit diagram&lt;/a&gt; of the drone.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;* — SBUS inverter is not needed as ESP32 supports &lt;a href=&#34;https://github.com/bolderflight/sbus#inverted-serial&#34;&gt;software pin inversion&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Components (version 0)&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Component&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Image&lt;/th&gt; &#xA;   &lt;th&gt;Quantity&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ESP32 Mini&lt;/td&gt; &#xA;   &lt;td&gt;Microcontroller board&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/esp32.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GY-91&lt;/td&gt; &#xA;   &lt;td&gt;IMU+LDO+barometer board&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/gy-91.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;K100&lt;/td&gt; &#xA;   &lt;td&gt;Quadcopter frame&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/frame.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;8520 3.7V brushed motor (&lt;strong&gt;shaft 0.8mm!&lt;/strong&gt;)&lt;/td&gt; &#xA;   &lt;td&gt;Motor&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/motor.jpeg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Hubsan 55 mm&lt;/td&gt; &#xA;   &lt;td&gt;Propeller&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/prop.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2.7A 1S Dual Way Micro Brush ESC&lt;/td&gt; &#xA;   &lt;td&gt;Motor ESC&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/esc.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;KINGKONG TINY X8&lt;/td&gt; &#xA;   &lt;td&gt;RC transmitter&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/tx.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DF500 (SBUS)&lt;/td&gt; &#xA;   &lt;td&gt;RC receiver&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/rx.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;del&gt;SBUS inverter&lt;/del&gt;*&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/inv.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;del&gt;1&lt;/del&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3.7 Li-Po 850 MaH 60C&lt;/td&gt; &#xA;   &lt;td&gt;Battery&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Battery charger&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okalachev/flix/master/docs/img/charger.jpg&#34; width=&#34;100&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Wires, connectors, tape, ...&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;3D-printed frame parts&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;em&gt;* — not needed as ESP32 supports &lt;a href=&#34;https://github.com/bolderflight/sbus#inverted-serial&#34;&gt;software pin inversion&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Telegram-channel&lt;/h2&gt; &#xA;&lt;p&gt;Subscribe to Telegram-channel on developing the drone and the flight controller (in Russian): &lt;a href=&#34;https://t.me/opensourcequadcopter&#34;&gt;https://t.me/opensourcequadcopter&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ValveSoftware/halflife</title>
    <updated>2024-05-17T01:27:27Z</updated>
    <id>tag:github.com,2024-05-17:/ValveSoftware/halflife</id>
    <link href="https://github.com/ValveSoftware/halflife" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Half-Life 1 engine based games&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Half Life 1 SDK LICENSE&lt;/h1&gt; &#xA;&lt;p&gt;Half Life 1 SDK Copyright© Valve Corp.&lt;/p&gt; &#xA;&lt;p&gt;THIS DOCUMENT DESCRIBES A CONTRACT BETWEEN YOU AND VALVE CORPORATION (“Valve”). PLEASE READ IT BEFORE DOWNLOADING OR USING THE HALF LIFE 1 SDK (“SDK”). BY DOWNLOADING AND/OR USING THE SOURCE ENGINE SDK YOU ACCEPT THIS LICENSE. IF YOU DO NOT AGREE TO THE TERMS OF THIS LICENSE PLEASE DON’T DOWNLOAD OR USE THE SDK.&lt;/p&gt; &#xA;&lt;p&gt;You may, free of charge, download and use the SDK to develop a modified Valve game running on the Half-Life engine. You may distribute your modified Valve game in source and object code form, but only for free. Terms of use for Valve games are found in the Steam Subscriber Agreement located here: &lt;a href=&#34;http://store.steampowered.com/subscriber_agreement/&#34;&gt;http://store.steampowered.com/subscriber_agreement/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You may copy, modify, and distribute the SDK and any modifications you make to the SDK in source and object code form, but only for free. Any distribution of this SDK must include this license.txt and third_party_licenses.txt.&lt;/p&gt; &#xA;&lt;p&gt;Any distribution of the SDK or a substantial portion of the SDK must include the above copyright notice and the following:&lt;/p&gt; &#xA;&lt;p&gt;DISCLAIMER OF WARRANTIES. THE SOURCE SDK AND ANY OTHER MATERIAL DOWNLOADED BY LICENSEE IS PROVIDED “AS IS”. VALVE AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES WITH RESPECT TO THE SDK, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, TITLE AND FITNESS FOR A PARTICULAR PURPOSE.&lt;/p&gt; &#xA;&lt;p&gt;LIMITATION OF LIABILITY. IN NO EVENT SHALL VALVE OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE ENGINE AND/OR THE SDK, EVEN IF VALVE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.&lt;/p&gt; &#xA;&lt;p&gt;If you would like to use the SDK for a commercial purpose, please contact Valve at &lt;a href=&#34;mailto:sourceengine@valvesoftware.com&#34;&gt;sourceengine@valvesoftware.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Half-Life 1&lt;/h1&gt; &#xA;&lt;p&gt;This is the README for the Half-Life 1 engine and its associated games.&lt;/p&gt; &#xA;&lt;p&gt;Please use this repository to report bugs and feature requests for Half-Life 1 related products.&lt;/p&gt; &#xA;&lt;h2&gt;Reporting Issues&lt;/h2&gt; &#xA;&lt;p&gt;If you encounter an issue while using Half-Life 1 games, first search the &lt;a href=&#34;https://github.com/ValveSoftware/halflife/issues&#34;&gt;issue list&lt;/a&gt; to see if it has already been reported. Include closed issues in your search.&lt;/p&gt; &#xA;&lt;p&gt;If it has not been reported, create a new issue with at least the following information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a short, descriptive title;&lt;/li&gt; &#xA; &lt;li&gt;a detailed description of the issue, including any output from the command line;&lt;/li&gt; &#xA; &lt;li&gt;steps for reproducing the issue;&lt;/li&gt; &#xA; &lt;li&gt;your system information.*; and&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;version&lt;/code&gt; output from the in‐game console.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please place logs either in a code block (press &lt;code&gt;M&lt;/code&gt; in your browser for a GFM cheat sheet) or a &lt;a href=&#34;https://gist.github.com&#34;&gt;gist&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;* The preferred and easiest way to get this information is from Steam&#39;s Hardware Information viewer from the menu (&lt;code&gt;Help -&amp;gt; System Information&lt;/code&gt;). Once your information appears: right-click within the dialog, choose &lt;code&gt;Select All&lt;/code&gt;, right-click again, and then choose &lt;code&gt;Copy&lt;/code&gt;. Paste this information into your report, preferably in a code block.&lt;/p&gt; &#xA;&lt;h2&gt;Conduct&lt;/h2&gt; &#xA;&lt;p&gt;There are basic rules of conduct that should be followed at all times by everyone participating in the discussions. While this is generally a relaxed environment, please remember the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Do not insult, harass, or demean anyone.&lt;/li&gt; &#xA; &lt;li&gt;Do not intentionally multi-post an issue.&lt;/li&gt; &#xA; &lt;li&gt;Do not use ALL CAPS when creating an issue report.&lt;/li&gt; &#xA; &lt;li&gt;Do not repeatedly update an open issue remarking that the issue persists.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Remember: Just because the issue you reported was reported here does not mean that it is an issue with Half-Life. As well, should your issue not be resolved immediately, it does not mean that a resolution is not being researched or tested. Patience is always appreciated.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>GJDuck/RRFuzz</title>
    <updated>2024-05-17T01:27:27Z</updated>
    <id>tag:github.com,2024-05-17:/GJDuck/RRFuzz</id>
    <link href="https://github.com/GJDuck/RRFuzz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fuzz anything with Program Environment Fuzzing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Program Environment Fuzzing (EFuzz)&lt;/h1&gt; &#xA;&lt;p&gt;EFuzz (εFuzz) is a new type of fuzzer that can &lt;strong&gt;fuzz just about anything&lt;/strong&gt;, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Network servers/clients&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Graphical User Interface&lt;/em&gt; (GUI) applications&lt;/li&gt; &#xA; &lt;li&gt;Editors&lt;/li&gt; &#xA; &lt;li&gt;Compilers&lt;/li&gt; &#xA; &lt;li&gt;Databases&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;any other Linux user-mode software&lt;/em&gt;, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example, the following demo shows how to fuzz a &lt;em&gt;GUI application&lt;/em&gt; using EFuzz:&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/GJDuck/RRFuzz/master/img/demo.gif&#34; alt=&#34;EFuzz demo&#34; style=&#34;width: 85%;&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;[&lt;em&gt;Demo of EFuzz fuzzing a GUI application binary (&lt;code&gt;gnome-calculator&lt;/code&gt;). First, the app is run normally, and all environmental interactions (including user inputs) are recorded to a file. Next, the app is fuzzed, this time by repeatedly replaying the original recording but with one or mutations applied. EFuzz quickly finds several crashes, as highlighted in red.&lt;/em&gt;]&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Unlike existing fuzzers, which only fuzz a specific input source (like AFL), EFuzz fuzzes the &lt;strong&gt;entire interaction&lt;/strong&gt; between the subject and its environment (ε)---including all files (configuration, cache, resource, fonts, etc.), sockets (session manager, accessibility service, name service, etc.), user interactions via the windowing system, special files, devices, and standard streams, as illustrated below:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/GJDuck/RRFuzz/master/img/calc-full.png&#34; alt=&#34;Full calculator app environment&#34; style=&#34;width: 60%;&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;In other words, EFuzz considers the entire environment (ε) itself is the fuzz target---a.k.a. &lt;em&gt;program environment fuzzing&lt;/em&gt;. This even includes user interactions via the windowing system (e.g., mouse movements, button clicks, etc.), which are treated as just another input source, no different than any other socket or file. This makes EFuzz a very comprehensive fuzzer, as it will automatically fuzz all inputs (and input combinations), even obscure inputs that are normally overlooked in a typical fuzz campaign.&lt;/p&gt; &#xA;&lt;p&gt;EFuzz is also very general, and is designed to fuzz off-the-shelf user-mode Linux binaries with &lt;strong&gt;zero configuration or set-up&lt;/strong&gt;. See the demo above.&lt;/p&gt; &#xA;&lt;h2&gt;How EFuzz Works?&lt;/h2&gt; &#xA;&lt;p&gt;EFuzz is based on an underlying full environmental &lt;em&gt;Record and Replay&lt;/em&gt; (rr) and fuzzing infrastructure (RR+Fuzzing=RRFuzz). The infrastructure is based on the insight that, for typical user-mode programs, all environmental interactions pass through the kernel-user mode interface. Thus, by recording this interface, we also implicitly record the program&#39;s interaction with the environment, which then can be subject to fuzzing. Basically, EFuzz works in two phases:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A &lt;em&gt;Recording&lt;/em&gt; phase that executes the program normally, and records all interactions (e.g., system calls, signals, thread switches, etc.) between the subject and its environment into a file.&lt;/li&gt; &#xA; &lt;li&gt;Next, a &lt;em&gt;Replay-with-Fuzzing&lt;/em&gt; phase that repeatedly re-executes the program in a fuzzing loop. However, this time the original environmental interactions are replayed from the recording, but with one or more possible mutations applied. These mutations can induce new program behaviours and possible crashes.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Since EFuzz works at the abstraction of environmental interactions, it can fuzz a very diverse range of subjects without any special-case handling. This makes EFuzz powerful and easy-to-use.&lt;/p&gt; &#xA;&lt;p&gt;An example of EFuzz usage is shown in the simple demo above:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The first phase &lt;strong&gt;records&lt;/strong&gt; the &lt;code&gt;gnome-calculator&lt;/code&gt; app using the command:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ ./EFuzz record gnome-calculator&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This creates an &lt;code&gt;out/&lt;/code&gt; sub-directory, and the recording is stored in a &lt;code&gt;out/RECORD.pcap.gz&lt;/code&gt; file.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The second phase &lt;strong&gt;fuzzes&lt;/strong&gt; the &lt;code&gt;gnome-calculator&lt;/code&gt; app using the command:&lt;/p&gt; &lt;pre&gt;&lt;code&gt; $ ./EFuzz fuzz&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The fuzzer uses the original recording from step (1.) as the initial seed, and repeatedly re-executes the program. Rather than replaying the original recording exactly, the fuzzer will apply one (or more) mutations, inducing new program behaviours and possible crashes.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Discovered crashes are stored in the &lt;code&gt;out/crash/&lt;/code&gt; sub-directory, and can be replayed using the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz replay out/crash/SIGSEGV_XXXX_m0YYYY.patch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We applied EFuzz to a diverse range of programs and discovered several new bugs, including those that are difficult or impossible to find with traditional fuzzers. For more information, please see the preprint listed below.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;To build EFuzz, simply run the &lt;code&gt;build.sh&lt;/code&gt; script.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This has only been tested on Ubuntu-based systems.&lt;/p&gt; &#xA;&lt;h2&gt;EFuzz Usage&lt;/h2&gt; &#xA;&lt;p&gt;Record:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz record -- vim hello.txt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replay:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz replay&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fuzz:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz fuzz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replay crash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz replay out/crash/SIGSEGV_XXXX_mYYYYY.patch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Debug crash:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz replay out/crash/SIGSEGV_XXXX_mYYYYY.patch -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;EFuzz also supports (optional) AFL-style coverage instrumentation:&lt;/p&gt; &#xA;&lt;p&gt;Instrument program binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz instrument program&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will generate an instrumented &lt;code&gt;program.rr&lt;/code&gt; binary, that can be substituted for the original.&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to instrument library code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;    $ ./EFuzz instrument /path/to/library.so&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will place an instrumented version of the library into the &lt;code&gt;lib/&lt;/code&gt; sub-directory, which is included in the library search path.&lt;/p&gt; &#xA;&lt;h2&gt;EFuzz Files&lt;/h2&gt; &#xA;&lt;p&gt;During fuzzing, several files will be generated:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;out/COMMAND.cmd&lt;/code&gt;: The command-line&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;out/RECORD.pcap.gz&lt;/code&gt;: The recording&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;out/crash/*.patch&lt;/code&gt;: Crashing patches&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;out/hang/*.patch&lt;/code&gt;: Hanging patches&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;out/abort/*.patch&lt;/code&gt;: Aborting patches&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;out/queue/m*/*.patch&lt;/code&gt;: Interesting patches&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lib/&lt;/code&gt;: Location where the patched &lt;code&gt;libc&lt;/code&gt; and instrumented libraries are stored.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that interactions stored in the &lt;code&gt;out/RECORD.pcap.gz&lt;/code&gt; file can be viewed using Wireshark.&lt;/p&gt; &#xA;&lt;h2&gt;EFuzz Technical Information&lt;/h2&gt; &#xA;&lt;p&gt;EFuzz uses &lt;a href=&#34;https://github.com/GJDuck/e9patch&#34;&gt;E9Patch&lt;/a&gt; to statically rewrite all &lt;code&gt;syscall&lt;/code&gt; instructions in &lt;code&gt;libc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/GJDuck/e9patch&#34;&gt;https://github.com/GJDuck/e9patch&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thus, whenever the program invokes a system call (e.g., &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, etc.), the call will be diverted to our record-and-replay infrastructure (RR+Fuzzing=RRFuzz). For recording, the infrastructure acts as a &lt;em&gt;man-in-the-middle&lt;/em&gt; between user and kernel-mode, and all interactions are saved to a file. For replay (with fuzzing), the program is (repeatedly) executed again, but this time each system call is &lt;em&gt;replayed&lt;/em&gt; from the original recording, possibly with one or more mutations applied. During replay, system calls are almost entirely serviced from the recording, and there is no interaction with the kernel and the real environment. In addition to &lt;code&gt;libc&lt;/code&gt; system calls, EFuzz also special methods for handling the vDSO, signals, thread switches, and syscall instructions outside of &lt;code&gt;libc&lt;/code&gt;. EFuzz does not use ptrace.&lt;/p&gt; &#xA;&lt;p&gt;One problem is that program behaviour can (and will) diverge after a mutation is applied. Indeed, the main point of fuzzing is to induce new behaviours in the hope of finding new bugs. To handle this case, EFuzz resorts to &#34;system call emulation&#34; after mutation, in a &#34;relaxed&#34; replay-mode. This allows for diverse program behaviours to be explored using only the original recording. Please see the preprint below for more information.&lt;/p&gt; &#xA;&lt;h2&gt;EFuzz Status&lt;/h2&gt; &#xA;&lt;p&gt;Implementing a full environmental record and replay infrastructure is notoriously challenging. For example, the related &lt;code&gt;rr-debug&lt;/code&gt; project estimates a total of &lt;em&gt;five person-years total&lt;/em&gt; (&lt;a href=&#34;https://arxiv.org/pdf/1705.05937&#34;&gt;source&lt;/a&gt;) was spent on development (as of 2017), and even then it cannot perfectly record and replay all programs. Our underlying RRFuzz framework has not nearly had as much development time, and the current implementation should be viewed as a &#34;research prototype&#34; that will not necessarily work for all programs. Nevertheless, we provide the system &#34;as-is&#34;, &lt;em&gt;since EFuzz has been proven effective at finding bugs that other fuzzers cannot detect&lt;/em&gt;, even if the implementation is not fully polished.&lt;/p&gt; &#xA;&lt;p&gt;We will continue to develop and improve EFuzz depending on the level of interest from the community.&lt;/p&gt; &#xA;&lt;h2&gt;EFuzz Issues&lt;/h2&gt; &#xA;&lt;p&gt;Please keep in mind that EFuzz is alpha-quality software and a research prototype.&lt;/p&gt; &#xA;&lt;p&gt;Please report obvious bugs here:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/GJDuck/RRFuzz/issues&#34;&gt;https://github.com/GJDuck/RRFuzz/issues&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Issues relating to unexpected divergence during replay should generally not be reported. That said, pull requests that fix divergence issues are very welcome.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, issues relating to missing ioctls, fcntls, and prctls should not be reported. Instead, you should update the corresponding &lt;code&gt;.tab&lt;/code&gt; file if possible, and consider making a pull request.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgement&lt;/h2&gt; &#xA;&lt;p&gt;This research is supported by the National Research Foundation, Singapore, and Cyber Security Agency of Singapore under its National Cybersecurity R&amp;amp;D Programme (Fuzz Testing NRF-NCR25-Fuzz-0001). Any opinions, findings and conclusions, or recommendations expressed in this material are those of the author(s) and do not reflect the views of National Research Foundation, Singapore, and Cyber Security Agency of Singapore.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This software has been released under the GNU Public License (GPL) Version 3. See the &lt;code&gt;LICENSE&lt;/code&gt; file for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Preprint&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ruijie Meng, Gregory J. Duck, Abhik Roychoudhury, &lt;a href=&#34;https://arxiv.org/abs/2404.13951&#34;&gt;&lt;em&gt;Program Environment Fuzzing&lt;/em&gt;&lt;/a&gt;, 2024&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>