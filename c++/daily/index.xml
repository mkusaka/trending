<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-17T01:31:15Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>gperftools/gperftools</title>
    <updated>2023-06-17T01:31:15Z</updated>
    <id>tag:github.com,2023-06-17:/gperftools/gperftools</id>
    <link href="https://github.com/gperftools/gperftools" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Main gperftools repository&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;gperftools&lt;/h2&gt; &#xA;&lt;p&gt;(originally Google Performance Tools)&lt;/p&gt; &#xA;&lt;p&gt;The fastest malloc weâ€™ve seen; works particularly well with threads and STL. Also: thread-friendly heap-checker, heap-profiler, and cpu-profiler.&lt;/p&gt; &#xA;&lt;h2&gt;OVERVIEW&lt;/h2&gt; &#xA;&lt;p&gt;gperftools is a collection of a high-performance multi-threaded malloc() implementation, plus some pretty nifty performance analysis tools.&lt;/p&gt; &#xA;&lt;p&gt;gperftools is distributed under the terms of the BSD License. Join our mailing list at &lt;a href=&#34;mailto:gperftools@googlegroups.com&#34;&gt;gperftools@googlegroups.com&lt;/a&gt; for updates: &lt;a href=&#34;https://groups.google.com/forum/#!forum/gperftools&#34;&gt;https://groups.google.com/forum/#!forum/gperftools&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;gperftools was original home for pprof program. But do note that original pprof (which is still included with gperftools) is now deprecated in favor of Go version at &lt;a href=&#34;https://github.com/google/pprof&#34;&gt;https://github.com/google/pprof&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;TCMALLOC&lt;/h2&gt; &#xA;&lt;p&gt;Just link in -ltcmalloc or -ltcmalloc_minimal to get the advantages of tcmalloc -- a replacement for malloc and new. See below for some environment variables you can use with tcmalloc, as well.&lt;/p&gt; &#xA;&lt;p&gt;tcmalloc functionality is available on all systems we&#39;ve tested; see INSTALL for more details. See README_windows.txt for instructions on using tcmalloc on Windows.&lt;/p&gt; &#xA;&lt;p&gt;when compiling. gcc makes some optimizations assuming it is using its own, built-in malloc; that assumption obviously isn&#39;t true with tcmalloc. In practice, we haven&#39;t seen any problems with this, but the expected risk is highest for users who register their own malloc hooks with tcmalloc (using gperftools/malloc_hook.h). The risk is lowest for folks who use tcmalloc_minimal (or, of course, who pass in the above flags :-) ).&lt;/p&gt; &#xA;&lt;h2&gt;HEAP PROFILER&lt;/h2&gt; &#xA;&lt;p&gt;See docs/heapprofile.html for information about how to use tcmalloc&#39;s heap profiler and analyze its output.&lt;/p&gt; &#xA;&lt;p&gt;As a quick-start, do the following after installing this package:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Link your executable with -ltcmalloc&lt;/li&gt; &#xA; &lt;li&gt;Run your executable with the HEAPPROFILE environment var set: $ HEAPPROFILE=/tmp/heapprof &amp;lt;path/to/binary&amp;gt; [binary args]&lt;/li&gt; &#xA; &lt;li&gt;Run pprof to analyze the heap usage $ pprof &amp;lt;path/to/binary&amp;gt; /tmp/heapprof.0045.heap # run &#39;ls&#39; to see options $ pprof --gv &amp;lt;path/to/binary&amp;gt; /tmp/heapprof.0045.heap&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;You can also use LD_PRELOAD to heap-profile an executable that you didn&#39;t compile.&lt;/p&gt; &#xA;&lt;p&gt;There are other environment variables, besides HEAPPROFILE, you can set to adjust the heap-profiler behavior; c.f. &#34;ENVIRONMENT VARIABLES&#34; below.&lt;/p&gt; &#xA;&lt;p&gt;The heap profiler is available on all unix-based systems we&#39;ve tested; see INSTALL for more details. It is not currently available on Windows.&lt;/p&gt; &#xA;&lt;h2&gt;HEAP CHECKER&lt;/h2&gt; &#xA;&lt;p&gt;See docs/heap_checker.html for information about how to use tcmalloc&#39;s heap checker.&lt;/p&gt; &#xA;&lt;p&gt;In order to catch all heap leaks, tcmalloc must be linked &lt;em&gt;last&lt;/em&gt; into your executable. The heap checker may mischaracterize some memory accesses in libraries listed after it on the link line. For instance, it may report these libraries as leaking memory when they&#39;re not. (See the source code for more details.)&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s a quick-start for how to use:&lt;/p&gt; &#xA;&lt;p&gt;As a quick-start, do the following after installing this package:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Link your executable with -ltcmalloc&lt;/li&gt; &#xA; &lt;li&gt;Run your executable with the HEAPCHECK environment var set: $ HEAPCHECK=1 &amp;lt;path/to/binary&amp;gt; [binary args]&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Other values for HEAPCHECK: normal (equivalent to &#34;1&#34;), strict, draconian&lt;/p&gt; &#xA;&lt;p&gt;You can also use LD_PRELOAD to heap-check an executable that you didn&#39;t compile.&lt;/p&gt; &#xA;&lt;p&gt;The heap checker is only available on Linux at this time; see INSTALL for more details.&lt;/p&gt; &#xA;&lt;h2&gt;CPU PROFILER&lt;/h2&gt; &#xA;&lt;p&gt;See docs/cpuprofile.html for information about how to use the CPU profiler and analyze its output.&lt;/p&gt; &#xA;&lt;p&gt;As a quick-start, do the following after installing this package:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Link your executable with -lprofiler&lt;/li&gt; &#xA; &lt;li&gt;Run your executable with the CPUPROFILE environment var set: $ CPUPROFILE=/tmp/prof.out &amp;lt;path/to/binary&amp;gt; [binary args]&lt;/li&gt; &#xA; &lt;li&gt;Run pprof to analyze the CPU usage $ pprof &amp;lt;path/to/binary&amp;gt; /tmp/prof.out # -pg-like text output $ pprof --gv &amp;lt;path/to/binary&amp;gt; /tmp/prof.out # really cool graphical output&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;There are other environment variables, besides CPUPROFILE, you can set to adjust the cpu-profiler behavior; cf &#34;ENVIRONMENT VARIABLES&#34; below.&lt;/p&gt; &#xA;&lt;p&gt;The CPU profiler is available on all unix-based systems we&#39;ve tested; see INSTALL for more details. It is not currently available on Windows.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: CPU profiling doesn&#39;t work after fork (unless you immediately do an exec()-like call afterwards). Furthermore, if you do fork, and the child calls exit(), it may corrupt the profile data. You can use _exit() to work around this. We hope to have a fix for both problems in the next release of perftools (hopefully perftools 1.2).&lt;/p&gt; &#xA;&lt;h2&gt;EVERYTHING IN ONE&lt;/h2&gt; &#xA;&lt;p&gt;If you want the CPU profiler, heap profiler, and heap leak-checker to all be available for your application, you can do: gcc -o myapp ... -lprofiler -ltcmalloc&lt;/p&gt; &#xA;&lt;p&gt;However, if you have a reason to use the static versions of the library, this two-library linking won&#39;t work: gcc -o myapp ... /usr/lib/libprofiler.a /usr/lib/libtcmalloc.a # errors!&lt;/p&gt; &#xA;&lt;p&gt;Instead, use the special libtcmalloc_and_profiler library, which we make for just this purpose: gcc -o myapp ... /usr/lib/libtcmalloc_and_profiler.a&lt;/p&gt; &#xA;&lt;h2&gt;CONFIGURATION OPTIONS&lt;/h2&gt; &#xA;&lt;p&gt;For advanced users, there are several flags you can pass to &#39;./configure&#39; that tweak tcmalloc performance. (These are in addition to the environment variables you can set at runtime to affect tcmalloc, described below.) See the INSTALL file for details.&lt;/p&gt; &#xA;&lt;h2&gt;ENVIRONMENT VARIABLES&lt;/h2&gt; &#xA;&lt;p&gt;The cpu profiler, heap checker, and heap profiler will lie dormant, using no memory or CPU, until you turn them on. (Thus, there&#39;s no harm in linking -lprofiler into every application, and also -ltcmalloc assuming you&#39;re ok using the non-libc malloc library.)&lt;/p&gt; &#xA;&lt;p&gt;The easiest way to turn them on is by setting the appropriate environment variables. We have several variables that let you enable/disable features as well as tweak parameters.&lt;/p&gt; &#xA;&lt;p&gt;Here are some of the most important variables:&lt;/p&gt; &#xA;&lt;p&gt;HEAPPROFILE=&lt;/p&gt;&#xA;&lt;pre&gt; -- turns on heap profiling and dumps data using this prefix&#xA;HEAPCHECK=&#xA; &lt;type&gt;&#xA;    -- turns on heap checking with strictness &#39;type&#39;&#xA;CPUPROFILE=&#xA;  &lt;file&gt;&#xA;    -- turns on cpu profiling and dumps data to this file. PROFILESELECTED=1 -- if set, cpu-profiler will only profile regions of code surrounded with ProfilerEnable()/ProfilerDisable(). CPUPROFILE_FREQUENCY=x-- how many interrupts/second the cpu-profiler samples.&#xA;   &lt;p&gt;&lt;/p&gt; &#xA;   &lt;p&gt;PERFTOOLS_VERBOSE=&#xA;    &lt;level&gt;&#xA;      -- the higher level, the more messages malloc emits MALLOCSTATS=&#xA;     &lt;level&gt;&#xA;       -- prints memory-use stats at program-exit&#xA;     &lt;/level&gt;&#xA;    &lt;/level&gt;&lt;/p&gt; &#xA;   &lt;p&gt;For a full list of variables, see the documentation pages: docs/cpuprofile.html docs/heapprofile.html docs/heap_checker.html&lt;/p&gt; &#xA;   &lt;h2&gt;COMPILING ON NON-LINUX SYSTEMS&lt;/h2&gt; &#xA;   &lt;p&gt;Perftools was developed and tested on x86 Linux systems, and it works in its full generality only on those systems. However, we&#39;ve successfully ported much of the tcmalloc library to FreeBSD, Solaris x86, and Darwin (Mac OS X) x86 and ppc; and we&#39;ve ported the basic functionality in tcmalloc_minimal to Windows. See INSTALL for details. See README_windows.txt for details on the Windows port.&lt;/p&gt; &#xA;   &lt;h2&gt;PERFORMANCE&lt;/h2&gt; &#xA;   &lt;p&gt;If you&#39;re interested in some third-party comparisons of tcmalloc to other malloc libraries, here are a few web pages that have been brought to our attention. The first discusses the effect of using various malloc libraries on OpenLDAP. The second compares tcmalloc to win32&#39;s malloc. &lt;a href=&#34;http://www.highlandsun.com/hyc/malloc/&#34;&gt;http://www.highlandsun.com/hyc/malloc/&lt;/a&gt; &lt;a href=&#34;http://gaiacrtn.free.fr/articles/win32perftools.html&#34;&gt;http://gaiacrtn.free.fr/articles/win32perftools.html&lt;/a&gt;&lt;/p&gt; &#xA;   &lt;p&gt;It&#39;s possible to build tcmalloc in a way that trades off faster performance (particularly for deletes) at the cost of more memory fragmentation (that is, more unusable memory on your system). See the INSTALL file for details.&lt;/p&gt; &#xA;   &lt;h2&gt;OLD SYSTEM ISSUES&lt;/h2&gt; &#xA;   &lt;p&gt;When compiling perftools on some old systems, like RedHat 8, you may get an error like this: ___tls_get_addr: symbol not found&lt;/p&gt; &#xA;   &lt;p&gt;This means that you have a system where some parts are updated enough to support Thread Local Storage, but others are not. The perftools configure script can&#39;t always detect this kind of case, leading to that error. To fix it, just comment out (or delete) the line #define HAVE_TLS 1 in your config.h file before building.&lt;/p&gt; &#xA;   &lt;h2&gt;64-BIT ISSUES&lt;/h2&gt; &#xA;   &lt;p&gt;There are two issues that can cause program hangs or crashes on x86_64 64-bit systems, which use the libunwind library to get stack-traces. Neither issue should affect the core tcmalloc library; they both affect the perftools tools such as cpu-profiler, heap-checker, and heap-profiler.&lt;/p&gt; &#xA;   &lt;ol&gt; &#xA;    &lt;li&gt; &lt;p&gt;Some libc&#39;s -- at least glibc 2.4 on x86_64 -- have a bug where the libc function dl_iterate_phdr() acquires its locks in the wrong order. This bug should not affect tcmalloc, but may cause occasional deadlock with the cpu-profiler, heap-profiler, and heap-checker. Its likeliness increases the more dlopen() commands an executable has. Most executables don&#39;t have any, though several library routines like getgrgid() call dlopen() behind the scenes.&lt;/p&gt; &lt;/li&gt; &#xA;    &lt;li&gt; &lt;p&gt;On x86-64 64-bit systems, while tcmalloc itself works fine, the cpu-profiler tool is unreliable: it will sometimes work, but sometimes cause a segfault. I&#39;ll explain the problem first, and then some workarounds.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;/ol&gt; &#xA;   &lt;p&gt;Note that this only affects the cpu-profiler, which is a gperftools feature you must turn on manually by setting the CPUPROFILE environment variable. If you do not turn on cpu-profiling, you shouldn&#39;t see any crashes due to perftools.&lt;/p&gt; &#xA;   &lt;p&gt;The gory details: The underlying problem is in the backtrace() function, which is a built-in function in libc. Backtracing is fairly straightforward in the normal case, but can run into problems when having to backtrace across a signal frame. Unfortunately, the cpu-profiler uses signals in order to register a profiling event, so every backtrace that the profiler does crosses a signal frame.&lt;/p&gt; &#xA;   &lt;p&gt;In our experience, the only time there is trouble is when the signal fires in the middle of pthread_mutex_lock. pthread_mutex_lock is called quite a bit from system libraries, particularly at program startup and when creating a new thread.&lt;/p&gt; &#xA;   &lt;p&gt;The solution: The dwarf debugging format has support for &#39;cfi annotations&#39;, which make it easy to recognize a signal frame. Some OS distributions, such as Fedora and gentoo 2007.0, already have added cfi annotations to their libc. A future version of libunwind should recognize these annotations; these systems should not see any crashes.&lt;/p&gt; &#xA;   &lt;p&gt;Workarounds: If you see problems with crashes when running the cpu-profiler, consider inserting ProfilerStart()/ProfilerStop() into your code, rather than setting CPUPROFILE. This will profile only those sections of the codebase. Though we haven&#39;t done much testing, in theory this should reduce the chance of crashes by limiting the signal generation to only a small part of the codebase. Ideally, you would not use ProfilerStart()/ProfilerStop() around code that spawns new threads, or is otherwise likely to cause a call to pthread_mutex_lock!&lt;/p&gt; &#xA;   &lt;hr&gt; &#xA;   &lt;p&gt;17 May 2011&lt;/p&gt; &#xA;  &lt;/file&gt;&#xA; &lt;/type&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>