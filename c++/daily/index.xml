<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-22T01:29:43Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>LuisaGroup/LuisaCompute</title>
    <updated>2024-12-22T01:29:43Z</updated>
    <id>tag:github.com,2024-12-22:/LuisaGroup/LuisaCompute</id>
    <link href="https://github.com/LuisaGroup/LuisaCompute" rel="alternate"></link>
    <summary type="html">&lt;p&gt;High-Performance Rendering Framework on Stream Architectures&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LuisaCompute&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/7614925/195987646-fe932ebe-ca6e-4d6e-ab2a-203bcfd3d559.jpg&#34; alt=&#34;teaser&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;LuisaCompute is a high-performance cross-platform computing framework for graphics and beyond.&lt;/p&gt; &#xA;&lt;p&gt;LuisaCompute is also the &lt;em&gt;rendering framework&lt;/em&gt; described in the &lt;strong&gt;SIGGRAPH Asia 2022&lt;/strong&gt; paper&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;em&gt;&lt;strong&gt;LuisaRender: A High-Performance Rendering Framework with Layered and Unified Interfaces on Stream Architectures&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;See also &lt;a href=&#34;https://github.com/LuisaGroup/LuisaRender&#34;&gt;LuisaRender&lt;/a&gt; for the &lt;em&gt;rendering application&lt;/em&gt; as described in the paper; and please visit the &lt;a href=&#34;https://luisa-render.com&#34;&gt;project page&lt;/a&gt; for other information about the paper and the project.&lt;/p&gt; &#xA;&lt;p&gt;Welcome to join the &lt;a href=&#34;https://discord.com/invite/ymYEBkUa7F&#34;&gt;discussion channel on Discord&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;p&gt;对于中国大陆的用户，也欢迎加入我们的 QQ 群组：295618382。&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#luisacompute&#34;&gt;LuisaCompute&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#table-of-contents&#34;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#overview&#34;&gt;Overview&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#embedded-domain-specific-language&#34;&gt;Embedded Domain-Specific Language&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#unified-runtime-with-resource-wrappers&#34;&gt;Unified Runtime with Resource Wrappers&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#multiple-backends&#34;&gt;Multiple Backends&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#python-frontend&#34;&gt;Python Frontend&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#c-api-and-frontends-in-other-languages&#34;&gt;C API and Frontends in Other Languages&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#building&#34;&gt;Building&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#a-minimal-example&#34;&gt;A Minimal Example&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#basic-types&#34;&gt;Basic Types&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#structures&#34;&gt;Structures&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#built-in-functions&#34;&gt;Built-in Functions&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#control-flows&#34;&gt;Control Flows&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#callable-and-kernels&#34;&gt;Callable and Kernels&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#backends-context-devices-and-resources&#34;&gt;Backends, Context, Devices and Resources&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#command-submission-and-synchronization&#34;&gt;Command Submission and Synchronization&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#automatic-differentiation&#34;&gt;Automatic Differentiation&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#applications&#34;&gt;Applications&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#documentation-and-tutorials&#34;&gt;Documentation and Tutorials&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#roadmap&#34;&gt;Roadmap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/#citation&#34;&gt;Citation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;LuisaCompute seeks to balance the seemingly ever-conflicting pursuits for &lt;em&gt;&lt;strong&gt;unification&lt;/strong&gt;&lt;/em&gt;, &lt;em&gt;&lt;strong&gt;programmability&lt;/strong&gt;&lt;/em&gt;, and &lt;em&gt;&lt;strong&gt;performance&lt;/strong&gt;&lt;/em&gt;. To achieve this goal, we design three major components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A domain-specific language (DSL) embedded inside modern C++ for kernel programming exploiting JIT code generation and compilation;&lt;/li&gt; &#xA; &lt;li&gt;A unified runtime with resource wrappers for cross-platform resource management and command scheduling; and&lt;/li&gt; &#xA; &lt;li&gt;Multiple optimized backends, including CUDA, DirectX, Metal, and CPU.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To demonstrate the practicality of the system, we also build a Monte Carlo renderer, &lt;a href=&#34;https://github.com/LuisaGroup/LuisaRender&#34;&gt;LuisaRender&lt;/a&gt;, atop the framework, which is faster than the state-of-the-art rendering frameworks on modern GPUs.&lt;/p&gt; &#xA;&lt;h3&gt;Embedded Domain-Specific Language&lt;/h3&gt; &#xA;&lt;p&gt;The DSL in our system provides a unified approach to authoring kernels, i.e., programmable computation tasks on the device. Distinct from typical graphics APIs that use standalone shading languages for device code, our system unifies the authoring of both the host-side logic and device-side kernels into the same language, i.e., modern C++.&lt;/p&gt; &#xA;&lt;p&gt;The implementation purely relies on the C++ language itself, without any custom preprocessing pass or compiler extension. We exploit meta-programming techniques to simulate the syntax, and function/operator overloading to dynamically trace the user-defined kernels. ASTs are constructed during the tracing as an intermediate representation and later handed over to the backends for generating concrete, platform-dependent shader source code.&lt;/p&gt; &#xA;&lt;p&gt;Example program in the embedded DSL:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Callable to_srgb = [](Float3 x) {&#xA;    $if (x &amp;lt;= 0.00031308f) {&#xA;        x = 12.92f * x;&#xA;    } $else {&#xA;        x = 1.055f * pow(x, 1.f / 2.4f) - .055f;&#xA;    };&#xA;    return x;&#xA;};&#xA;Kernel2D fill = [&amp;amp;](ImageFloat image) {&#xA;    auto coord = dispatch_id().xy();&#xA;    auto size = make_float2(dispatch_size().xy());&#xA;    auto rg = make_float2(coord) / size;&#xA;    // invoke the callable&#xA;    auto srgb = to_srgb(make_float3(rg, 1.f));&#xA;    image.write(coord, make_float4(srgb, 1.f));&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unified Runtime with Resource Wrappers&lt;/h3&gt; &#xA;&lt;p&gt;Like the RHIs in game engines, we introduce an abstract runtime layer to re-unify the fragmented graphics APIs across platforms. It extracts the common concepts and constructs shared by the backend APIs and plays the bridging role between the high-level frontend interfaces and the low-level backend implementations.&lt;/p&gt; &#xA;&lt;p&gt;On the programming interfaces for users, we provide high-level resource wrappers to ease programming and eliminate boilerplate code. They are strongly and statically typed modern C++ objects, which not only simplify the generation of commands via convenient member methods but also support close interaction with the DSL. Moreover, with the resource usage information in kernels and commands, the runtime automatically probes the dependencies between commands and re-schedules them to improve hardware utilization.&lt;/p&gt; &#xA;&lt;h3&gt;Multiple Backends&lt;/h3&gt; &#xA;&lt;p&gt;The backends are the final realizers of computation. They generate concrete shader sources from the ASTs and compile them into native shaders. They implement the virtual device interfaces with low-level platform-dependent API calls and translate the intermediate command representations into native kernel launches and command dispatches.&lt;/p&gt; &#xA;&lt;p&gt;Currently, we have 3 working GPU backends for the C++ and Python frontends, based on CUDA, Metal, and DirectX, respectively, and a CPU backend (re-)implemented in Rust for debugging purpose and fallback.&lt;/p&gt; &#xA;&lt;h3&gt;Python Frontend&lt;/h3&gt; &#xA;&lt;p&gt;Besides the native C++ DSL and runtime interfaces, we are also working on a Python frontend and have published early-access packages to PyPI. You may install the pre-built wheels with pip (Python &amp;gt;= 3.10 required):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python -m pip install luisa-python&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also build your own wheels with pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python -m pip wheel &amp;lt;path-to-project&amp;gt; -w &amp;lt;output-dir&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Examples using the Python frontend can be found under &lt;code&gt;src/tests/python&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Due to the different syntax and idioms between Python and C++, the Python frontend does not 1:1 reflects the C++ DSL and APIs. For instance, Python does not have a dedicated reference type qualifier, so we follow the Python idiom that structures and arrays are passed as references to &lt;code&gt;@luisa.func&lt;/code&gt; and built-in types (scalar, vector, matrix, etc.) as values by default.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;C API and Frontends in Other Languages&lt;/h3&gt; &#xA;&lt;p&gt;We are also making a C API for creating other language bindings and frontends (e.g., in &lt;a href=&#34;https://github.com/LuisaGroup/luisa-compute-rs&#34;&gt;Rust&lt;/a&gt; and C#).&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: LuisaCompute is a &lt;em&gt;rendering framework&lt;/em&gt; rather than a &lt;em&gt;renderer&lt;/em&gt; itself. It is designed to provide general computation functionalities on modern stream-processing hardware, on which high-performance, cross-platform graphics applications can be easily built. If you would like to just try a Monte Carlo renderer out of the box rather than building one from scratch, please see &lt;a href=&#34;https://github.com/LuisaGroup/LuisaRender&#34;&gt;LuisaRender&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Preparation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Check your hardware and platform. Currently, we support CUDA on Linux and Windows; DirectX on Windows; Metal on macOS; and CPU on all the major platforms. For CUDA, an RTX-enabled graphics card, e.g., NVIDIA RTX 20 and 30 series, is required. For DirectX, a DirectX-12.1 &amp;amp; Shader Model 6.5 compatible graphics card is required.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Prepare the environment and dependencies. We recommend using the latest IDEs, Compilers, XMake/CMake, CUDA drivers, etc. Since we aggressively use new technologies like C++20 and OptiX 8, you may need to, for example, upgrade your VS to 2019 or 2022 and install CUDA 11.7+ and NVIDIA driver R535+.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone the repo with the &lt;code&gt;--recursive&lt;/code&gt; option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone -b next https://github.com/LuisaGroup/LuisaCompute.git/ --recursive&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Since we use Git submodules to manage third-party dependencies, a &lt;code&gt;--recursive&lt;/code&gt; clone is required.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Detailed requirements for each platform are listed in &lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/BUILD.md&#34;&gt;BUILD.md&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build via the Bootstrap Script&lt;/h3&gt; &#xA;&lt;p&gt;The easiest way to build LuisaCompute is to use the bootstrap script. It can even download and install the required dependencies and build the project.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python bootstrap.py cmake -f cuda -b # build with CUDA backend using CMake&#xA;python bootstrap.py cmake -f cuda -b -- -DCMAKE_BUILD_TYPE=RelWithDebInfo # everything after -- will be passed to CMake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may specify &lt;code&gt;-f all&lt;/code&gt; to enable all available features on your platform.&lt;/p&gt; &#xA;&lt;p&gt;To install certain dependencies, you can use the &lt;code&gt;--install&lt;/code&gt; or &lt;code&gt;-i&lt;/code&gt; option. For example, to install Rust, you can use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python bootstrap.py -i rust&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, the bootstrap script can output a configuration file for build system without actually building the project. This is useful when you want to use the project inside IDE.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python bootstrap.py cmake -f cuda -c -o cmake-build-release # generate CMake configuration in ./cmake-build-release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please use &lt;code&gt;python bootstrap.py --help&lt;/code&gt; for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Build from Source with XMake/CMake&lt;/h3&gt; &#xA;&lt;p&gt;LuisaCompute follows the standard &lt;a href=&#34;https://xmake.io/&#34;&gt;XMake&lt;/a&gt; and &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; build process. Please see also &lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/BUILD.md&#34;&gt;BUILD.md&lt;/a&gt; for details on platform requirements, configuration options, and other precautions.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;A Minimal Example&lt;/h3&gt; &#xA;&lt;p&gt;Currently, we suggest using LuisaCompute as a submodule. For quick start with CMake, you can find the project template &lt;a href=&#34;https://github.com/LuisaGroup/CMakeStarterTemplate&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Generally, using LuisaCompute to construct a graphics application basically involves the following steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a &lt;code&gt;Context&lt;/code&gt; and loading a &lt;code&gt;Device&lt;/code&gt; plug-in;&lt;/li&gt; &#xA; &lt;li&gt;Create a &lt;code&gt;Stream&lt;/code&gt; for command submission and other device resources (e.g., &lt;code&gt;Buffer&amp;lt;T&amp;gt;&lt;/code&gt;s for linear storage, &lt;code&gt;Image&amp;lt;T&amp;gt;&lt;/code&gt;s for 2D readable/writable textures, and &lt;code&gt;Mesh&lt;/code&gt;es and &lt;code&gt;Accel&lt;/code&gt;s for ray-scene intersection testing structures) via &lt;code&gt;Device&lt;/code&gt;&#39;s &lt;code&gt;create_*&lt;/code&gt; interfaces;&lt;/li&gt; &#xA; &lt;li&gt;Author &lt;code&gt;Kernel&lt;/code&gt;s to describe the on-device computation tasks, and compile them into &lt;code&gt;Shader&lt;/code&gt;s via &lt;code&gt;Device&lt;/code&gt;&#39;s &lt;code&gt;compile&lt;/code&gt; interface;&lt;/li&gt; &#xA; &lt;li&gt;Generate &lt;code&gt;Command&lt;/code&gt;s via each resource&#39;s interface (e.g., &lt;code&gt;Buffer&amp;lt;T&amp;gt;::copy_to&lt;/code&gt;), or &lt;code&gt;Shader&lt;/code&gt;&#39;s &lt;code&gt;operator()&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt;, and submit them to the stream;&lt;/li&gt; &#xA; &lt;li&gt;Wait for the results by inserting a &lt;code&gt;synchronize&lt;/code&gt; phoney command to the &lt;code&gt;Stream&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Putting the above together, a minimal example program that write gradient color to an image would look like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;&#xA;#include &amp;lt;luisa/luisa-compute.h&amp;gt;&#xA;&#xA;// For the DSL sugar macros like $if.&#xA;// We exclude this header from &amp;lt;luisa-compute.h&amp;gt; to avoid pollution.&#xA;// So you have to include it explicitly to use the sugar macros.&#xA;#include &amp;lt;luisa/dsl/sugar.h&amp;gt;&#xA;&#xA;using namespace luisa;&#xA;using namespace luisa::compute;&#xA;&#xA;int main(int argc, char *argv[]) {&#xA;&#xA;    // Step 1.1: Create a context&#xA;    Context context{argv[0]};&#xA;    &#xA;    // Step 1.2: Load the CUDA backend plug-in and create a device&#xA;    Device device = context.create_device(&#34;cuda&#34;);&#xA;    &#xA;    // Step 2.1: Create a stream for command submission&#xA;    Stream stream = device.create_stream();&#xA;    &#xA;    // Step 2.2: Create an 1024x1024 image with 4-channel 8-bit storage for each pixel; the template &#xA;    //           argument `float` indicates that pixel values reading from or writing to the image&#xA;    //           are converted from `byte4` to `float4` or `float4` to `byte4` automatically&#xA;    Image&amp;lt;float&amp;gt; device_image = device.create_image&amp;lt;float&amp;gt;(PixelStorage::BYTE4, 1024u, 1024u, 0u);&#xA;    &#xA;    // Step 3.1: Define kernels to describe the device-side computation&#xA;    // &#xA;    //           A `Callable` is a function *entity* (not directly inlined during &#xA;    //           the AST recording) that is invocable from kernels or other callables&#xA;    Callable linear_to_srgb = [](Float4 /* alias for Var&amp;lt;float4&amp;gt; */ linear) noexcept {&#xA;        // The DSL syntax is much like the original C++&#xA;        auto x = linear.xyz();&#xA;        return make_float4(&#xA;            select(1.055f * pow(x, 1.0f / 2.4f) - 0.055f,&#xA;                   12.92f * x,&#xA;                   x &amp;lt;= 0.00031308f),&#xA;            linear.w);&#xA;    };&#xA;    //           A `Kernel` is an *entry* function to the device workload &#xA;    Kernel2D fill_image_kernel = [&amp;amp;linear_to_srgb](ImageFloat /* alias for Var&amp;lt;Image&amp;lt;float&amp;gt;&amp;gt; */ image) noexcept {&#xA;        Var coord = dispatch_id().xy();&#xA;        Var rg = make_float2(coord) / make_float2(dispatch_size().xy());&#xA;        image-&amp;gt;write(coord, linear_to_srgb(make_float4(rg, 1.0f, 1.0f)));&#xA;    };&#xA;    &#xA;    // Step 3.2: Compile the kernel into a shader (i.e., a runnable object on the device)&#xA;    auto fill_image = device.compile(fill_image_kernel);&#xA;    &#xA;    // Prepare the host memory for holding the image&#xA;    std::vector&amp;lt;std::byte&amp;gt; download_image(1024u * 1024u * 4u);&#xA;    &#xA;    // Step 4: Generate commands from resources and shaders, and&#xA;    //         submit them to the stream to execute on the device&#xA;    stream &amp;lt;&amp;lt; fill_image(device_image.view(0)).dispatch(1024u, 1024u)&#xA;           &amp;lt;&amp;lt; device_image.copy_to(download_image.data())&#xA;           &amp;lt;&amp;lt; synchronize();// Step 5: Synchronize the stream&#xA;   &#xA;   // Now, you have the device-computed pixels in the host memory!&#xA;   your_image_save_function(&#34;color.png&#34;, download_image, 1024u, 1024u, 4u);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Basic Types&lt;/h3&gt; &#xA;&lt;p&gt;In addition to standard C++ scalar types (e.g., &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt; --- alias of &lt;code&gt;uint32_t&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;bool&lt;/code&gt;), LuisaCompute provides vector/matrix types for 3D graphics, including the following types:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// boolean vectors&#xA;using bool2 = Vector&amp;lt;bool, 2&amp;gt;;   // alignment: 2B&#xA;using bool3 = Vector&amp;lt;bool, 3&amp;gt;;   // alignment: 4B&#xA;using bool4 = Vector&amp;lt;bool, 4&amp;gt;;   // alignment: 4B&#xA;// signed and unsigned integer vectors&#xA;using int2 = Vector&amp;lt;int, 2&amp;gt;;     // alignment: 8B&#xA;using int3 = Vector&amp;lt;int, 3&amp;gt;;     // alignment: 16B&#xA;using int4 = Vector&amp;lt;int, 4&amp;gt;;     // alignment: 16B&#xA;using uint2 = Vector&amp;lt;uint, 2&amp;gt;;   // alignment: 8B&#xA;using uint3 = Vector&amp;lt;uint, 3&amp;gt;;   // alignment: 16B&#xA;using uint4 = Vector&amp;lt;uint, 4&amp;gt;;   // alignment: 16B&#xA;// floating-point vectors and matrices&#xA;using float2 = Vector&amp;lt;float, 2&amp;gt;; // alignment: 8B&#xA;using float3 = Vector&amp;lt;float, 3&amp;gt;; // alignment: 16B&#xA;using float4 = Vector&amp;lt;float, 4&amp;gt;; // alignment: 16B&#xA;using float2x2 = Matrix&amp;lt;2&amp;gt;;      // column-major, alignment: 8B&#xA;using float3x3 = Matrix&amp;lt;3&amp;gt;;      // column-major, alignment: 16B&#xA;using float4x4 = Matrix&amp;lt;4&amp;gt;;      // column-major, alignment: 16B&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Please pay attention to the alignment of 3D vectors and matrices --- they are aligned like 4D ones rather than packed. Also, we do not provide 64-bit integer or floating-point vector/matrix types, as they are less useful and typically unsupported on GPUs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To make vectors/matrices, we provide &lt;code&gt;make_*&lt;/code&gt; and read-only swizzle interfaces, e.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto a = make_float2();       // (0.f, 0.f)&#xA;auto b = make_int3(1);        // (1,   1,   1)&#xA;auto c = make_uint3(b);       // (1u,  1u,  1u): converts from a same-dimentional but (possibly) differently typed vector&#xA;auto d = make_float3(a, 1.f); // (0.f, 0.f, 1.f): construct float3 from float2 and a float scalar&#xA;auto e = d.zzxy();            // (1.f, 1.f, 0.f, 0.f): swizzle&#xA;auto m = make_float2x2(1.f);  // ((1.f, 0.f,), (0.f, 1.f)): diagonal matrix from a scalar&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Operators are also overloaded for scalar-vector, vector-vector, scalar-matrix, vector-matrix, and matrix-matrix calculations, e.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto one = make_float2(1.f); // (1.f, 1.f)&#xA;auto two = 2.f;&#xA;auto three = one + two;      // (3.f, 3.f), scalar broadcast to vector&#xA;auto m2 = make_float2(2.f);  // ((2.f, 0.f), (0.f, 2.f))&#xA;auto m3 = 1.5f * m2;         // ((3.f, 0.f), (0.f, 3.f)), scalar-matrix multiplication&#xA;auto v = m3 * one;           // (3.f, 3.f), matrix-vector multiplication, the vector should always&#xA;                             // appear at the right-hand side and is interpreted as a column vector&#xA;auto m6 = m2 * m3;           // ((6.f, 0.f), (0.f, 6.f)), matrix-matrix multiplication&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The scalar, vector, matrix, and array types are also supported in the DSL, together with &lt;code&gt;make_*&lt;/code&gt;, swizzles, and operators. Just wrap them in the &lt;code&gt;Var&amp;lt;T&amp;gt;&lt;/code&gt; template or use the pre-defined aliases:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// scalar types; note that 64-bit ones are not supported&#xA;using Int = Var&amp;lt;int&amp;gt;;&#xA;using UInt = Var&amp;lt;uint&amp;gt;;&#xA;using Float = Var&amp;lt;float&amp;gt;;&#xA;using Bool = Var&amp;lt;bool&amp;gt;;&#xA;&#xA;// vector types&#xA;using Int2 = Var&amp;lt;int2&amp;gt;; // = Var&amp;lt;Vector&amp;lt;int, 2&amp;gt;&amp;gt;&#xA;using Int3 = Var&amp;lt;int3&amp;gt;; // = Var&amp;lt;Vector&amp;lt;int, 3&amp;gt;&amp;gt;&#xA;/* ... */&#xA;&#xA;// matrix types&#xA;using Float2x2 = Var&amp;lt;float2x2&amp;gt;; // = Var&amp;lt;Matrix&amp;lt;2&amp;gt;&amp;gt;&#xA;using Float3x3 = Var&amp;lt;float3x3&amp;gt;; // = Var&amp;lt;Matrix&amp;lt;3&amp;gt;&amp;gt;&#xA;using Float4x4 = Var&amp;lt;float4x4&amp;gt;; // = Var&amp;lt;Matrix&amp;lt;4&amp;gt;&amp;gt;&#xA;&#xA;// array types&#xA;template&amp;lt;typename T, size_t N&amp;gt;&#xA;using ArrayVar = Var&amp;lt;std::array&amp;lt;T, N&amp;gt;&amp;gt;;&#xA;&#xA;// make_*&#xA;auto a = make_float2(one);    // Float2(1.f, 1.f), suppose one = Float(1.f)&#xA;auto m = make_float2x2(a, a); // Float2x2((1.f, 1.f), (1.f, 1.f))&#xA;auto c = make_int2(a);        // Int2(1, 1)&#xA;auto d = c.xxx();             // Int3(1, 1, 1)&#xA;auto e = d[0];                // 1&#xA;/* ... */&#xA;&#xA;// operators&#xA;auto v2 = a * 2.f;  // Float2(2.f, 2.f)&#xA;auto eq = v2 == v2; // Bool2(true, true)&#xA;/* ... */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ The only exception is that we disable &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt; in the DSL for scalars. This is because the DSL does not support the &lt;em&gt;short-circuit&lt;/em&gt; semantics. We disable them to avoid ambiguity. Please use &lt;code&gt;operator&amp;amp;&lt;/code&gt; and &lt;code&gt;operator|&lt;/code&gt; instead, which have the consistent non-short-circuit semantics on both the host and device sides.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Besides the &lt;code&gt;Var&amp;lt;T&amp;gt;&lt;/code&gt; template, there&#39;s also an &lt;code&gt;Expr&amp;lt;T&amp;gt;&lt;/code&gt;, which is to &lt;code&gt;Var&amp;lt;T&amp;gt;&lt;/code&gt; what &lt;code&gt;const T &amp;amp;&lt;/code&gt; is to &lt;code&gt;T&lt;/code&gt; on the host side. In other words, &lt;code&gt;Expr&amp;lt;T&amp;gt;&lt;/code&gt; stands for a const DSL variable reference, which does not create variables copies when passed around. However, note that the parameters of &lt;code&gt;Callable&lt;/code&gt;/&lt;code&gt;Kernel&lt;/code&gt; definition functions may only be &lt;code&gt;Var&amp;lt;T&amp;gt;&lt;/code&gt;. This restriction might be removed in the future.&lt;/p&gt; &#xA;&lt;p&gt;To conveniently convert a C++ variable to the DSL, we provide a helper template function &lt;code&gt;def&amp;lt;T&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto a = def(1.f);              // equivalent to auto a = def&amp;lt;float&amp;gt;(1.f);&#xA;auto b_host = make_float2(1.f); // host C++ variable float2(1.f, 1.f)&#xA;auto b_device = def(b_host);    // device DSL variable Float2(1.f, 1.f)&#xA;/* ... */&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Structures&lt;/h3&gt; &#xA;&lt;p&gt;To export a C++ data struct to the DSL, we provide a helper macro &lt;code&gt;LUISA_STRUCT&lt;/code&gt;, which (semi-)automatically reflects the member layouts of the input structure:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// A C++ data structure&#xA;namespace foo {&#xA;struct alignas(8) S {&#xA;    float a;&#xA;    int   b;&#xA;};&#xA;}&#xA;&#xA;// A reflected DSL structure&#xA;LUISA_STRUCT(foo::S, a, b) {&#xA;/* device-side member functions, e.g., */&#xA;    [[nodiscard]] auto twice_a() const noexcept { return 2.f * a; }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ The &lt;code&gt;LUISA_STRUCT&lt;/code&gt; may only be used in the global namespace. The C++ structure to be exported may only contain scalar, vector, matrix, array, and other already exported structure types. The alignment of the &lt;em&gt;whole&lt;/em&gt; structure specified with &lt;code&gt;alignas&lt;/code&gt; will be reflected but must be under 16B; member alignments specified with &lt;code&gt;alignas&lt;/code&gt; are not supported.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Built-in Functions&lt;/h3&gt; &#xA;&lt;p&gt;For the DSL, we provide a rich set of built-in functions, in the following categories&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thread coordinate and launch configuration queries, including &lt;code&gt;block_id&lt;/code&gt;, &lt;code&gt;thread_id&lt;/code&gt;, &lt;code&gt;dispatch_size&lt;/code&gt;, and &lt;code&gt;dispatch_id&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;Mathematical routines, such as &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt;;&lt;/li&gt; &#xA; &lt;li&gt;Resource accessing and modification methods, such as texture sampling, buffer read/write, and ray intersection;&lt;/li&gt; &#xA; &lt;li&gt;Variable construction and type conversion, e.g., the aforementioned &lt;code&gt;make_*&lt;/code&gt;, &lt;code&gt;cast&amp;lt;T&amp;gt;&lt;/code&gt; for static type casting, and &lt;code&gt;as&amp;lt;T&amp;gt;&lt;/code&gt; for bitwise type casting; and&lt;/li&gt; &#xA; &lt;li&gt;Optimization hints for backend compilers, which currently consist of &lt;code&gt;assume&lt;/code&gt; and &lt;code&gt;unreachable&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The mathematical functions basically mirrors &lt;a href=&#34;https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)&#34;&gt;GLSL&lt;/a&gt;. We are working on the documentations that will provide more descriptions on them.&lt;/p&gt; &#xA;&lt;h3&gt;Control Flows&lt;/h3&gt; &#xA;&lt;p&gt;The DSL in LuisaCompute supports device-side control flows. They are provided as special macros prefixed with &lt;code&gt;$&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;$if (cond) { /*...*/ };&#xA;$if (cond) { /*...*/ } $else { /*...*/ };&#xA;$if (cond) { /*...*/ } $elif (cond2) { /*...*/ };&#xA;$if (cond) { /*...*/ } $elif (cond2) { /*...*/ } $else { /*...*/ };&#xA;&#xA;$while (cond) { /*...*/ };&#xA;$for (variable, n) { /*...*/ };&#xA;$for (variable, begin, end) { /*...*/ };&#xA;$for (variable, begin, end, step) { /*...*/ };&#xA;$loop { /*...*/ }; // infinite loop, unless $break&#39;ed&#xA;&#xA;$switch (variable) {&#xA;    $case (value) { /*...*/ }; // no $break needed inside, as we automatically add one&#xA;    $default { /*...*/ };      // no $break needed inside, as we automatically add one&#xA;};&#xA;&#xA;$break;&#xA;$continue;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that users are still able to use the &lt;em&gt;native&lt;/em&gt; C++ control flows, i.e., &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. &lt;em&gt;without&lt;/em&gt; the &lt;code&gt;$&lt;/code&gt; prefix. In that case the &lt;em&gt;native&lt;/em&gt; control flows acts like a &lt;em&gt;meta-stage&lt;/em&gt; to the DSL that directly controls the generation of the callables/kernels. This can be a powerful means to achieve &lt;em&gt;multi-stage programming&lt;/em&gt; patterns. Such usages can be found throughout &lt;a href=&#34;https://github.com/LuisaGroup/LuisaRender&#34;&gt;LuisaRender&lt;/a&gt;. We will cover such usage in the tutorials in the future.&lt;/p&gt; &#xA;&lt;h3&gt;Callable and Kernels&lt;/h3&gt; &#xA;&lt;p&gt;LuisaCompute supports two categories of device functions: &lt;code&gt;Kernel&lt;/code&gt;s (&lt;code&gt;Kernel1D&lt;/code&gt;, &lt;code&gt;Kernel2D&lt;/code&gt;, or &lt;code&gt;Kernel3D&lt;/code&gt;) and &lt;code&gt;Callable&lt;/code&gt;s. Kernels are entries to the parallelized computation tasks on the device (equivalent to CUDA&#39;s &lt;code&gt;__global__&lt;/code&gt; functions). Callables are function objects invocable from kernels or other callables (i.e., like CUDA&#39;s &lt;code&gt;__device__&lt;/code&gt; functions). Both kinds are template classes that are constructible from C++ functions or function objects including lambda expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Define a callable from a lambda expression&#xA;Callable add_one = [](Float x) { return x + 1.f; };&#xA;&#xA;// A callable may invoke another callable&#xA;Callable add_two = [&amp;amp;add_one](Float x) {&#xA;    add_one(add_one(x));&#xA;};&#xA;&#xA;// A callable may use captured device resources or resources in the argument list&#xA;auto buffer = device.create_buffer&amp;lt;float&amp;gt;(...);&#xA;Callable copy = [&amp;amp;buffer](BufferFloat buffer2, UInt index) {&#xA;    auto x = buffer.read(index); // use captured resource&#xA;    buffer2.write(index, x);     // use declared resource in the argument list&#xA;};&#xA;&#xA;// Define a 1D kernel from a lambda expression&#xA;Kernel1D add_one_and_some = [&amp;amp;buffer, &amp;amp;add_one](Float some, BufferFloat out) {&#xA;    auto index = dispatch_id().x;    // query thread index in the whole grid with built-in dispatch_id()&#xA;    auto x = buffer.read(index);     // use resource through capturing&#xA;    auto result = add_one(x) + some; // invoke a callable&#xA;    out.write(index, result);        // use resource in the argument list&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Note that parameters of the definition functions for callables and kernels must be &lt;code&gt;Var&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Var&amp;lt;T&amp;gt; &amp;amp;&lt;/code&gt; (or their aliases).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Kernels can be compiled into shaders by the device:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto some_shader = device.compile(some_kernel);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Note that the compilation blocks the calling thread. For large kernels this might take a considerably long time. You may accelerate the process by compiling multiple kernels concurrently, e.g., with thread pools.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Most backends support caching the compiled shaders to accelerate future compilations of the same shader. The cache files are at &lt;code&gt;&amp;lt;build-folder&amp;gt;/bin/.cache&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Backends, Context, Devices and Resources&lt;a name=&#34;devices-and-resources&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;LuisaCompute currently supports these backends:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CUDA&lt;/li&gt; &#xA; &lt;li&gt;DirectX&lt;/li&gt; &#xA; &lt;li&gt;Metal&lt;/li&gt; &#xA; &lt;li&gt;CPU (Clang + LLVM)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More backends might be added in the future. A device backend is implemented as a plug-in, which follows the &lt;code&gt;lc-backend-&amp;lt;name&amp;gt;&lt;/code&gt; naming convention and is placed under &lt;code&gt;&amp;lt;build-folder&amp;gt;/bin&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Context&lt;/code&gt; object is responsible for loading and managing these plug-ins and creating/destroying devices. Users have to pass the executable path (typically, &lt;code&gt;argv[0]&lt;/code&gt;) or the runtime directory to a context&#39;s constructor (so that it&#39;s able to locate the plug-ins), and pass the backend name to create the corresponding device object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv[]) {&#xA;    Context context{argv[0]};&#xA;    Device device = context.create_device(&#34;cuda&#34;);&#xA;    /* ... */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Creating multiple devices inside the same application is allowed. However, the resources are not shared across devices. Visiting one device&#39;s resources from another device&#39;s commands/shaders would lead to undefined behaviors.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The device object provides methods for backend-specific operations, typicall, creating resources. LuisaCompute supports the following rousource types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Buffer&amp;lt;T&amp;gt;&lt;/code&gt;s, which are linear memory ranges on the device for structured data storage;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Image&amp;lt;T&amp;gt;&lt;/code&gt;s and &lt;code&gt;Volume&amp;lt;T&amp;gt;&lt;/code&gt;s, which are 2D/3D textures of scalars or vectors readable and writable from the shader, possibly with hardware-accelerated caching and format conversion;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;BindlessArray&lt;/code&gt;s, which provide slots for references to buffers and textures (&lt;code&gt;Image&lt;/code&gt;s or &lt;code&gt;Volume&lt;/code&gt;s bound with texture samplers, read-only in the shader), helpful for reducing the overhead and bypassing the limitations of binding shader parameters;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Mesh&lt;/code&gt;es and &lt;code&gt;Accel&lt;/code&gt;s (short for acceleration structures) for high-performance ray intersection tests, with hardware acceleration if available (e.g., on graphics cards that feature RT-Cores);&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img alt=&#34;hardware_resources&#34; src=&#34;https://user-images.githubusercontent.com/7614925/196001295-a5407f09-77a0-461a-ab23-ab768ddc08e9.jpg&#34; align=&#34;center&#34; width=&#34;65%&#34;&gt; &#xA;&lt;p&gt;Devices are also responsible for&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Creating &lt;code&gt;Stream&lt;/code&gt;s and &lt;code&gt;Event&lt;/code&gt;s (the former are for command submission and the latter are for host-stream and stream-stream synchronization); and&lt;/li&gt; &#xA; &lt;li&gt;Compiling kernels into shaders, as introduced before.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All resources, shaders, streams, and events are C++ objects with &lt;em&gt;move&lt;/em&gt; contrutors/assignments and following the &lt;em&gt;RAII&lt;/em&gt; idiom, i.e., automatically calling the &lt;code&gt;Device::destroy_*&lt;/code&gt; interfaces when destructed.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Users may need to pay attention not to dangle a resource, e.g., accidentally releases it before the dependent commands finish.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Command Submission and Synchronization&lt;/h3&gt; &#xA;&lt;p&gt;LuisaCompute adopts the explicit command-based execution model. Conceptually, commands are description units of atomic computation tasks, such as transferring data between the device and host, or from one resource to another; building meshes and acceleration structures; populating or updating bindless arrays; and most importantly, launching shaders.&lt;/p&gt; &#xA;&lt;p&gt;Commands are organized into command buffers and then submitted to streams which are essentially queues forwarding commands to the backend devices in a logically first-in-first-out (FIFO) manner.&lt;/p&gt; &#xA;&lt;p&gt;The resource wrappers provide convenient methods for creating commands, e.g.,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto buffer_upload_command   = buffer.copy_from(host_data)&#xA;auto accel_build_command     = accel.build();&#xA;auto shader_dispatch_command = shader(args...).dispatch(n);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Command buffers are group commands that are submitted together:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto command_buffer = stream.command_buffer();&#xA;command_buffer&#xA;    &amp;lt;&amp;lt; raytrace_shader(framebuffer, accel, resolution)&#xA;        .dispatch(resolution)&#xA;    &amp;lt;&amp;lt; accumulate_shader(accum_image, framebuffer)&#xA;        .dispatch(resolution)&#xA;    &amp;lt;&amp;lt; hdr2ldr_shader(accum_image, ldr_image)&#xA;        .dispatch(resolution)&#xA;    &amp;lt;&amp;lt; ldr_image.copy_to(host_image.data())&#xA;    &amp;lt;&amp;lt; commit(); // the commands are submitted to the stream together on commit()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For convenience, a stream implicitly creates a proxy object, which submit commands in the internal command buffer at the end of statements:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;stream &amp;lt;&amp;lt; buffer.copy_from(host_data) // a stream proxy is created on Stream::operator&amp;lt;&amp;lt;()&#xA;       &amp;lt;&amp;lt; accel.build()               // consecutive commands are stored in the implicit commad buffer in the proxy object&#xA;       &amp;lt;&amp;lt; raytracing(image, accel, i)&#xA;           .dispatch(width, height);  // the proxy object automatically submits the commands at the end of the statement&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ Since commands are asynchronously executed, users should pay attention to resource and host data lifetimes.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The backends in LuisaCompute can automatically determine the dependencies between the commands in a command buffer, and re-schedule them into an optimized order to improve hardware ultilization. Therefore, larger command buffers might be preferred for better computation throughput.&lt;/p&gt; &#xA;&lt;img alt=&#34;command scheduling&#34; src=&#34;https://user-images.githubusercontent.com/7614925/196001465-2dace78b-5e3b-4b4b-b2c3-f2cd61adc6ff.jpg&#34; align=&#34;center&#34; width=&#34;60%&#34;&gt; &#xA;&lt;p&gt;Multiple streams run concurrently. Therefore, users may require synchronizations between them or with respect to the host via &lt;code&gt;Event&lt;/code&gt;s, similar to condition variables that ensure ordering across threads:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto event = device.create_event();&#xA;stream_a &amp;lt;&amp;lt; command_a&#xA;         &amp;lt;&amp;lt; event.signal(); // signals an event&#xA;stream_b &amp;lt;&amp;lt; event.wait()    // waits until the event signals&#xA;         &amp;lt;&amp;lt; command_b;      // will be executed after the event signals&#xA;         &amp;lt;&amp;lt; event.signal(); // signals again&#xA;event.synchronize();        // blocks until the event signals&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Automatic Differentiation&lt;/h3&gt; &#xA;&lt;p&gt;We implemented reverse mode autodiff using source-to-source transformation. The autodiff supports control flows such as if-else and switch, as well as callables. The following example shows how to use the autodiff to compute the gradient of a function &lt;code&gt;f(t, x, y) = t &amp;lt; 1 ? x * y : x + y&lt;/code&gt; with respect to &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Var&amp;lt;float&amp;gt; x = ...;&#xA;Var&amp;lt;float&amp;gt; y = ...;&#xA;Var&amp;lt;float&amp;gt; t = ...;&#xA;$autodiff {&#xA;    requires_grad(x, y);&#xA;    Var&amp;lt;float&amp;gt; z;&#xA;    $if(t &amp;lt; 1.0) {&#xA;        auto no_grad = some_non_differentiable_function(x, y);&#xA;        z = x * y;&#xA;    }$else {&#xA;        z = callable(x, y);&#xA;    };&#xA;    backward(z);&#xA;    dx-&amp;gt;write(tid, grad(x));&#xA;    dy-&amp;gt;write(tid, grad(y));&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Limitation (might be removed in the future):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;we don&#39;t support loop with dynamic iteration count. To differentiate a loop, users have to unroll it by using &lt;code&gt;for(auto i = 0;i &amp;lt;count;i++) { dsl_body(i); }&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Applications&lt;/h2&gt; &#xA;&lt;p&gt;We implement several proof-of-concept examples in tree under &lt;code&gt;src/tests&lt;/code&gt; (sorry for the misleading naming; they are also test programs we used during the development). Besides, you may also found the following applications interesting:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LuisaGroup/LuisaRender.git&#34;&gt;LuisaRender&lt;/a&gt;, a high-performance cross-platform Monte Carlo renderer.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/LuisaGroup/LuisaShaderToy.git&#34;&gt;LuisaShaderToy&lt;/a&gt;, a collection of amazing shaders ported from &lt;a href=&#34;https://www.shadertoy.com&#34;&gt;Shadertoy&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation and Tutorials&lt;/h2&gt; &#xA;&lt;p&gt;Sorry that we are still working on them. Currently, we would recommand reading the original &lt;a href=&#34;https://luisa-render.com&#34;&gt;paper&lt;/a&gt; and learning through the examples and applications.&lt;/p&gt; &#xA;&lt;p&gt;If you have any problem or suggestion, please just feel free to open an &lt;a href=&#34;https://github.com/LuisaGroup/LuisaCompute/issues&#34;&gt;issue&lt;/a&gt; or start a &lt;a href=&#34;https://github.com/LuisaGroup/LuisaCompute/discussions&#34;&gt;discussion&lt;/a&gt;. We are very happy to hear from you!&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/LuisaGroup/LuisaCompute/stable/ROADMAP.md&#34;&gt;ROADMAP.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@article{Zheng2022LuisaRender,&#xA;    author = {Zheng, Shaokun and Zhou, Zhiqian and Chen, Xin and Yan, Difei and Zhang, Chuyan and Geng, Yuefeng and Gu, Yan and Xu, Kun},&#xA;    title = {LuisaRender: A High-Performance Rendering Framework with Layered and Unified Interfaces on Stream Architectures},&#xA;    year = {2022},&#xA;    issue_date = {December 2022},&#xA;    publisher = {Association for Computing Machinery},&#xA;    address = {New York, NY, USA},&#xA;    volume = {41},&#xA;    number = {6},&#xA;    issn = {0730-0301},&#xA;    url = {https://doi.org/10.1145/3550454.3555463},&#xA;    doi = {10.1145/3550454.3555463},&#xA;    journal = {ACM Trans. Graph.},&#xA;    month = {nov},&#xA;    articleno = {232},&#xA;    numpages = {19},&#xA;    keywords = {stream architecture, rendering framework, cross-platform renderer}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://doi.org/10.1145/3550454.3555463&#34;&gt;publisher&lt;/a&gt; version of the paper is open-access. You may download it for free.&lt;/p&gt;</summary>
  </entry>
</feed>