<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-12T01:32:21Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cyrusbehr/YOLOv8-TensorRT-CPP</title>
    <updated>2023-07-12T01:32:21Z</updated>
    <id>tag:github.com,2023-07-12:/cyrusbehr/YOLOv8-TensorRT-CPP</id>
    <link href="https://github.com/cyrusbehr/YOLOv8-TensorRT-CPP" rel="alternate"></link>
    <summary type="html">&lt;p&gt;YOLOv8 TensorRT C++ Implementation&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/cyrusbehr/YOLOv8-TensorRT-CPP/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/cyrusbehr/YOLOv8-TensorRT-CPP.svg?style=flat-square&#34; alt=&#34;Stargazers&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/cyrusbehr/YOLOv8-TensorRT-CPP/issues&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/issues/cyrusbehr/YOLOv8-TensorRT-CPP.svg?style=flat-square&#34; alt=&#34;Issues&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://linkedin.com/in/cyrus-behroozi/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/-LinkedIn-black.svg?style=flat-square&amp;amp;logo=linkedin&amp;amp;colorB=555&#34; alt=&#34;LinkedIn&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- PROJECT LOGO --&gt; &#xA;&lt;br&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt;YoloV8 TensorRT CPP&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt; A C++ Implementation of YoloV8 using TensorRT &lt;/b&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/cyrusbehr/YOLOv8-TensorRT-CPP&#34;&gt; &lt;img width=&#34;70%&#34; src=&#34;https://raw.githubusercontent.com/cyrusbehr/YOLOv8-TensorRT-CPP/main/assets/yolov8.gif&#34; alt=&#34;logo&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/cyrusbehr/YOLOv8-TensorRT-CPP&#34;&gt; &lt;img width=&#34;70%&#34; src=&#34;https://raw.githubusercontent.com/cyrusbehr/YOLOv8-TensorRT-CPP/main/assets/yolov8-seg.gif&#34; alt=&#34;logo&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;This project demonstrates how to use the TensorRT C++ API to run GPU inference for YoloV8. It makes use of my other project &lt;a href=&#34;https://github.com/cyrusbehr/tensorrt-cpp-api&#34;&gt;tensorrt-cpp-api&lt;/a&gt; to run inference behind the scene, so make sure you are familiar with that project.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;New&lt;/strong&gt;: Now supports YoloV8 Semantic Segmentation models.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tested and working on Ubuntu 20.04&lt;/li&gt; &#xA; &lt;li&gt;Install CUDA, instructions &lt;a href=&#34;https://developer.nvidia.com/cuda-11-8-0-download-archive&#34;&gt;here&lt;/a&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Recommended &amp;gt;= 11.8&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Install cudnn, instructions &lt;a href=&#34;https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#download&#34;&gt;here&lt;/a&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Recommended &amp;gt;= 8&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sudo apt install build-essential&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sudo apt install python3-pip&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pip3 install cmake&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install OpenCV with cuda support. To compile OpenCV from source, run the &lt;code&gt;build_opencv.sh&lt;/code&gt; script provided in &lt;code&gt;./scripts/&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Recommended &amp;gt;= 4.8&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Download TensorRT 8 from &lt;a href=&#34;https://developer.nvidia.com/nvidia-tensorrt-8x-download&#34;&gt;here&lt;/a&gt;. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Recommended &amp;gt;= 8.6&lt;/li&gt; &#xA;   &lt;li&gt;Required &amp;gt;= 8.0&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Extract, and then navigate to the &lt;code&gt;CMakeLists.txt&lt;/code&gt; file and replace the &lt;code&gt;TODO&lt;/code&gt; with the path to your TensorRT installation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;git clone https://github.com/cyrusbehr/YOLOv8-TensorRT-CPP --recursive&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Note:&lt;/strong&gt; Be sure to use the &lt;code&gt;--recursive&lt;/code&gt; flag as this repo makes use of git submodules.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Converting Model from PyTorch to ONNX&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Navigate to the &lt;a href=&#34;https://github.com/ultralytics/ultralytics&#34;&gt;official YoloV8 repository&lt;/a&gt; and download your desired version of the model (ex. YOLOv8m). &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The code also supports semantic segmentation models out of the box (ex. YOLOv8x-seg)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pip3 install ultralytics&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Navigate to the &lt;code&gt;scripts/&lt;/code&gt; directory and modify this line so that it points to your downloaded model: &lt;code&gt;model = YOLO(&#34;../models/yolov8m.pt&#34;)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;python3 pytorch2onnx.py&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;After running this command, you should successfully have converted from PyTorch to ONNX.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building the Project&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;mkdir build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cd build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cmake ..&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make -j&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running the Executables&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Note&lt;/em&gt;: the first time you run any of the scripts, it may take quite a long time (5 mins+) as TensorRT must generate an optimized TensorRT engine file from the onnx model. This is then saved to disk and loaded on subsequent runs.&lt;/li&gt; &#xA; &lt;li&gt;To run the benchmarking script, run: &lt;code&gt;./benchmark /path/to/your/onnx/model.onnx&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;To run inference on an image and save the annotated image to disk run: &lt;code&gt;./detect_object_image /path/to/your/onnx/model.onnx /path/to/your/image.jpg&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You can use the images in the &lt;code&gt;images/&lt;/code&gt; directory for testing&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;To run inference using your webcam and display the results in real time, run: &lt;code&gt;./detect_object_video /path/to/your/onnx/model.onnx&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;To change the video source, navigate to &lt;code&gt;src/object_detection_video_streaming.cpp&lt;/code&gt; and change this line to your specific video source: &lt;code&gt; cap.open(0);&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;The video source can be an int or a string (ex. &#34;/dev/video4&#34; or an RTSP url).&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;How to debug&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you have issues creating the TensorRT engine file from the onnx model, navigate to &lt;code&gt;libs/tensorrt-cpp-api/src/engine.cpp&lt;/code&gt; and change the log level by changing the severity level to &lt;code&gt;kVERBOSE&lt;/code&gt; and rebuild and rerun. This should give you more information on where exactly the build process is failing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Show your appreciation&lt;/h3&gt; &#xA;&lt;p&gt;If this project was helpful to you, I would appreicate if you could give it a star. That will encourage me to ensure it&#39;s up to date and solve issues quickly.&lt;/p&gt; &#xA;&lt;!-- MARKDOWN LINKS &amp; IMAGES --&gt; &#xA;&lt;!-- https://www.markdownguide.org/basic-syntax/#reference-style-links --&gt;</summary>
  </entry>
  <entry>
    <title>pentilm/StellarSolver</title>
    <updated>2023-07-12T01:32:21Z</updated>
    <id>tag:github.com,2023-07-12:/pentilm/StellarSolver</id>
    <link href="https://github.com/pentilm/StellarSolver" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üåå High-Performance N-Body Simulation with CUDA and Barnes-Hut Algorithm. ‰∏Ä‰∏™Âä™ÂäõÁöÑÔºå‰∏Ä‰∏™Âª∂Áª≠‰∫ÜËøë‰∫åÁôæ‰∏™ÊñáÊòéÁöÑÂä™ÂäõÔºå‰∏∫Ëß£ÂÜ≥‰∏â‰ΩìÈóÆÈ¢òÁöÑÂä™ÂäõÔºåÂØªÊâæÂ§™Èò≥ËøêË°åËßÑÂæãÁöÑÂä™Âäõ„ÄÇ&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;StellarSolver: High-Performance N-Body Simulation with CUDA and Barnes-Hut Algorithm&lt;/h1&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;StellarSolver is a comprehensive tool designed for simulating the n-body problem, utilizing the Barnes-Hut algorithm powered by CUDA. The project provides visualization through OpenGL, following Nvidia&#39;s CUDA toolkit examples. Currently, the visualization process is executed by the host, transferring data back at each time-step without utilizing CUDA-OpenGL interoperability due to system restrictions during development.&lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;StellarSolver necessitates the installation of Nvidia&#39;s CUDA toolkit on a system with a CUDA-capable device and a GCC compiler. The visualization component uses OpenGL, SFML, GLEW (OpenGL Extension Wrangler Library), and GLM (OpenGL Mathematics).&lt;/p&gt; &#xA;&lt;p&gt;For CUDA installation, refer to the &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;Nvidia CUDA download page&lt;/a&gt; and the CUDA Quick Start Guide. On Ubuntu, install SFML and GLEW by executing the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install libsfml-dev&#xA;sudo apt-get install libglew-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;GLM, a collection of header files, can be acquired &lt;a href=&#34;http://glm.g-truc.net/0.9.8/index.html&#34;&gt;here&lt;/a&gt;. Ensure to update the makefile INCLUDE variable to set the path to the GLM directory.&lt;/p&gt; &#xA;&lt;h2&gt;Compilation&lt;/h2&gt; &#xA;&lt;p&gt;To compile the code, execute the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make clean&#xA;make build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Execution&lt;/h2&gt; &#xA;&lt;p&gt;StellarSolver offers multiple command-line arguments for customization.&lt;/p&gt; &#xA;&lt;p&gt;The standard execution of the Barnes-Hut algorithm with OpenGL visualization:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./app -barnes-hut -opengl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Execution with benchmark statistics for 500 iterations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./app -barnes-hut -benchmark -iterations=500&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additional command-line options are detailed below:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;-disk&lt;/code&gt; : Use a simple disk model (default).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-plummer&lt;/code&gt; : Use a Plummer model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-colliding-disks&lt;/code&gt; : Use two colliding disks.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-opengl&lt;/code&gt; : Enable OpenGL visualization.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-benchmark&lt;/code&gt; : Output time statistics.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-debug&lt;/code&gt; : Run debug tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-iterations=&amp;lt;n&amp;gt;&lt;/code&gt; : Define the number of iterations (defaults to 50).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-gravity=&amp;lt;n&amp;gt;&lt;/code&gt; : Adjust the gravity parameter (defaults to 1.0).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;-dampening=&amp;lt;n&amp;gt;&lt;/code&gt; : Adjust the velocity dampening parameter (defaults to 1.0).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Additional Notes&lt;/h2&gt; &#xA;&lt;p&gt;Ensure to manually match the &#39;numbodies&#39; variable in main.cpp and the &#39;blockSize&#39; variables in kernels.cu and particle_cuda.cu. For instance, if you set &lt;code&gt;numbodies = 64*64&lt;/code&gt; in main.cpp, also set &lt;code&gt;blockSize = 64&lt;/code&gt; in kernels.cu, and &lt;code&gt;blockSize = 64, gridSize = 64&lt;/code&gt; in particle_cuda.cu.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>wheremyfoodat/Panda3DS</title>
    <updated>2023-07-12T01:32:21Z</updated>
    <id>tag:github.com,2023-07-12:/wheremyfoodat/Panda3DS</id>
    <link href="https://github.com/wheremyfoodat/Panda3DS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;HLE 3DS emulator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Panda3DS&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wheremyfoodat/Panda3DS/actions/workflows/Windows_Build.yml&#34;&gt;&lt;img src=&#34;https://github.com/wheremyfoodat/Panda3DS/actions/workflows/Windows_Build.yml/badge.svg?branch=master&#34; alt=&#34;Windows Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/wheremyfoodat/Panda3DS/actions/workflows/MacOS_Build.yml&#34;&gt;&lt;img src=&#34;https://github.com/wheremyfoodat/Panda3DS/actions/workflows/MacOS_Build.yml/badge.svg?branch=master&#34; alt=&#34;MacOS Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/wheremyfoodat/Panda3DS/actions/workflows/Linux_Build.yml&#34;&gt;&lt;img src=&#34;https://github.com/wheremyfoodat/Panda3DS/actions/workflows/Linux_Build.yml/badge.svg?branch=master&#34; alt=&#34;Linux Build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Panda3DS is an HLE, red-panda-themed Nintendo 3DS emulator written in C++ which started out as a fun project out of curiosity, but evolved into something that can sort of play games!&lt;/p&gt; &#xA;&lt;h1&gt;Discussion&lt;/h1&gt; &#xA;&lt;p&gt;Join our Discord server by pressing on the banner below!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/ZYbugsEmsw&#34;&gt;&lt;img src=&#34;https://discord.com/api/guilds/1118695732958994532/widget.png?style=banner2&#34; alt=&#34;Discord Banner 2&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wheremyfoodat/Panda3DS/master/docs/img/MK7.png&#34; alt=&#34;screenshot1&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wheremyfoodat/Panda3DS/master/docs/img/OoT_Title.png&#34; alt=&#34;screenshot2&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wheremyfoodat/Panda3DS/master/docs/img/pokegang.png&#34; alt=&#34;screenshot3&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;Panda3DS is still in the early stages of development. Many games boot, many don&#39;t. Most games have at least some hilariously broken graphics, audio is not supported, performance leaves a bit to be desired mainly thanks to lack of shader acceleration, and most QoL features (including a GUI) are missing.&lt;/p&gt; &#xA;&lt;p&gt;In addition, some games don&#39;t quiiite work with the upstream code. A lot of them might need some panics in the source code to be commented out before they work, etc. However, just the fact things can work as well as they do now is promising in itself.&lt;/p&gt; &#xA;&lt;h1&gt;Why?&lt;/h1&gt; &#xA;&lt;p&gt;The 3DS emulation scene is already pretty mature, with offerings such as &lt;a href=&#34;https://github.com/citra-emu/citra&#34;&gt;Citra&lt;/a&gt; which can offer a great playing experience for most games in the library, &lt;a href=&#34;https://github.com/PSI-Rockin/Corgi3DS&#34;&gt;Corgi3DS&lt;/a&gt;, an innovative LLE emulator, or &lt;a href=&#34;https://mikage.app/&#34;&gt;Mikage&lt;/a&gt;. However, there&#39;s always room for more emulators! While Panda3DS was initially a mere curiosity, there&#39;s many different concepts I would like to explore with it in the future, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Virtualization. What motivated the creation of this emulator was actually a discussion on whether it is possible to get fast 3DS emulation on low-end hardware such as the Raspberry Pi 4, using the KVM API. At the moment, Panda3DS is powered by dynarmic rather than using virtualization, but this is definitely a concept I want to explore in the future.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Debugging, reverse engineering and modding tools. While contributing to &lt;a href=&#34;https://github.com/grumpycoders/pcsx-redux&#34;&gt;PCSX-Redux&lt;/a&gt; and collaborating with the other developers, I had the chance to find out how useful tools like these can be. They can serve as indispensable tools for the homebrew devs, modders, reverse engineers, as well as emulator developers themselves. Some tools can even become fun toys the casual user can mess around with. As such, I think they can really improve the experience in a project like this. Of course, I&#39;d like to thank @nicolasnoble and the entire Redux team for helping me learn the value of these tools, as well as making me improve as a programmer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Trying out various other unique features, such as different graphics or audio enhancements, or supporting other niche things such as amiibo.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Fun. Writing code is fun and I strongly encourage anyone to do it.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Keep in mind, these are all long-term plans. Until then, the main focus is just improving compatibility&lt;/p&gt; &#xA;&lt;h1&gt;How to build&lt;/h1&gt; &#xA;&lt;p&gt;Panda3DS compiles on Windows, Linux and MacOS, without needing to download any system dependencies.&lt;/p&gt; &#xA;&lt;p&gt;All you need is CMake and a generator of your choice (Make, Visual Studio, Ninja, etc). Simply clone the repo recursively and build it like your average CMake project.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone https://github.com/wheremyfoodat/Panda3DS --recursive&#xA;&#xA;cd Panda3DS &amp;amp;&amp;amp; mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_USER_BUILD=ON  # Set up compilers etc here if you&#39;d like&#xA;&#xA;&amp;lt;Invoke Make, Visual Studio, or whatever you would like to use&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;*If you want to contribute to the project, you may not want to enable the ENABLE_USER_BUILD option and instead familiarize yourself with the various CMake options provided in the root CMakeLists.txt&lt;/p&gt; &#xA;&lt;h1&gt;How to use&lt;/h1&gt; &#xA;&lt;p&gt;Simply drag and drop a ROM to the executable if supported, or invoke the executable from the command line with the path to the ROM as the first argument like: &lt;code&gt;Alber.exe MyGame.3ds&lt;/code&gt; &lt;br&gt; Panda3DS can load ROMs in the following formats:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;.3ds&lt;/li&gt; &#xA; &lt;li&gt;.cxi/.app&lt;/li&gt; &#xA; &lt;li&gt;.elf/.axf&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both decrypted and encrypted dumps are supported. However for encrypted dumps you must provide your AES keys file by adding a &lt;code&gt;sysdata&lt;/code&gt; folder to the emulator&#39;s app data directory with a file called &lt;code&gt;aes_keys.txt&lt;/code&gt; including your keys. Currently .cia files are not supported yet (support is planned for the future), however if you want you can usually use Citra to extract the .app/.cxi file out of your .cia and run that.&lt;/p&gt; &#xA;&lt;h2&gt;Controls&lt;/h2&gt; &#xA;&lt;p&gt;Keyboard &amp;amp; Mouse&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Up button W&lt;/li&gt; &#xA; &lt;li&gt;Down button S&lt;/li&gt; &#xA; &lt;li&gt;Left button A&lt;/li&gt; &#xA; &lt;li&gt;Right button D&lt;/li&gt; &#xA; &lt;li&gt;A button L&lt;/li&gt; &#xA; &lt;li&gt;B button K&lt;/li&gt; &#xA; &lt;li&gt;X button O&lt;/li&gt; &#xA; &lt;li&gt;Y button I&lt;/li&gt; &#xA; &lt;li&gt;L button Q&lt;/li&gt; &#xA; &lt;li&gt;R button P&lt;/li&gt; &#xA; &lt;li&gt;Start button Enter&lt;/li&gt; &#xA; &lt;li&gt;Select button Backspace&lt;/li&gt; &#xA; &lt;li&gt;Touch Screen Left click&lt;/li&gt; &#xA; &lt;li&gt;Gyroscope Hold right click and swipe your mouse left and right (support is kind of shaky atm, but games that require gyro here and there like Kirby should work)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Panda3DS also supports controller input using the SDL2 GameController API.&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.3dbrew.org/wiki/Main_Page&#34;&gt;3DBrew&lt;/a&gt;, a wiki full of 3DS information and the main source of documentation used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.problemkaputt.de/gbatek.htm#3dsreference&#34;&gt;GBATek&lt;/a&gt;, a GBA, DS and 3DS reference which provided insights on some pieces of hardware as well as neatly documenting things like certain file formats used in games.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/devkitPro/libctru&#34;&gt;Libctru&lt;/a&gt;, the most well-known 3DS homebrew SDK. Used for developing test ROMs, as well as a source of documentation thanks to its doxygen wiki.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/citra-emu/citra&#34;&gt;Citra&lt;/a&gt;, an HLE 3DS emulator. Very useful as a reference, with some code snippets inspired or adapted from it.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/plutooo/3dmoo&#34;&gt;3dmoo&lt;/a&gt;, an HLE 3DS emulator which helped similarly to Citra&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/PSI-Rockin/Corgi3DS&#34;&gt;Corgi3DS&lt;/a&gt;, an LLE 3DS emulator which both served as an inspiration, as well as a nice source of documentation for some PICA200-related things&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Sister Projects&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/grumpycoders/pcsx-redux&#34;&gt;PCSX-Redux&lt;/a&gt;: A PlayStation 1 emulator targetting developers, reverse engineers and regular PS1 fans alike&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/skylersaleh/SkyEmu&#34;&gt;SkyEmu&lt;/a&gt;: A seagull-themed low-level GameBoy, GameBoy Color, GameBoy Advance and Nintendo DS emulator that is designed to be easy to use, cross platform and accurate.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nba-emu/NanoBoyAdvance&#34;&gt;NanoBoyAdvance&lt;/a&gt;: A Game Boy Advance emulator focusing on hardware research and cycle-accurate emulation&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/kelpsyberry/dust&#34;&gt;Dust&lt;/a&gt;: Nintendo DS emulator for desktop devices and the web&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/melonDS-emu/melonDS&#34;&gt;MelonDS&lt;/a&gt;: &#34;DS emulator, sorta&#34; - Arisotura&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SimoneN64/Kaizen&#34;&gt;Kaizen&lt;/a&gt;: Experimental work-in-progress low-level N64 emulator&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/liuk7071/ChonkyStation&#34;&gt;ChonkyStation&lt;/a&gt;: Work-in-progress PlayStation emulator&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Support&lt;/h1&gt; &#xA;&lt;p&gt;If you find this project exciting and want to support the founder, check out &lt;a href=&#34;https://www.patreon.com/wheremyfoodat&#34;&gt;his Patreon page&lt;/a&gt; &lt;br&gt; Keep in mind, funding is only aimed to cover various life costs and support development. Panda3DS is a free product and on no occasion will official builds ever be made private or limited to sponsors! Any donation is much appreciated!&lt;/p&gt; &#xA;&lt;p&gt;Nintendo 3DS is a registered trademark of Nintendo Co., Ltd.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wheremyfoodat/Panda3DS/master/docs/img/panda.jpg&#34; alt=&#34;pamda&#34;&gt; Here&#39;s a panda it go blep&lt;/p&gt;</summary>
  </entry>
</feed>