<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-01T01:29:32Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sherlockchou86/VideoPipe</title>
    <updated>2024-05-01T01:29:32Z</updated>
    <id>tag:github.com,2024-05-01:/sherlockchou86/VideoPipe</id>
    <link href="https://github.com/sherlockchou86/VideoPipe" rel="alternate"></link>
    <summary type="html">&lt;p&gt;跨平台的视频结构化（视频分析）框架，觉得有帮助的请给个星星：）。&lt;/p&gt;&lt;hr&gt;&lt;p style=&#34;&#34; align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/logo.png&#34; alt=&#34;Logo&#34; width=&#34;350&#34; height=&#34;200&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;一、介绍&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;VideoPipe&lt;/code&gt; 是一个用于视频分析和结构化的框架，采用 C++ 编写、依赖少、易上手。它像管道一样，其中每个节点相互独立并可自行搭配，&lt;code&gt;VideoPipe&lt;/code&gt; 可用来构建不同类型的视频分析应用，适用于视频结构化、图片搜索、人脸识别、交通/安防领域的行为分析（如交通事件检测）等场景。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/g1.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;二、优势和特点&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;VideoPipe&lt;/code&gt; 类似于英伟达的 DeepStream 和华为的 mxVision 框架，但它更易于使用、更具备可移植性。&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;名称&lt;/th&gt; &#xA;   &lt;th&gt;是否开源&lt;/th&gt; &#xA;   &lt;th&gt;学习门槛&lt;/th&gt; &#xA;   &lt;th&gt;适用平台&lt;/th&gt; &#xA;   &lt;th&gt;性能&lt;/th&gt; &#xA;   &lt;th&gt;三方依赖&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DeepStream&lt;/td&gt; &#xA;   &lt;td&gt;否&lt;/td&gt; &#xA;   &lt;td&gt;高&lt;/td&gt; &#xA;   &lt;td&gt;仅限英伟达&lt;/td&gt; &#xA;   &lt;td&gt;高&lt;/td&gt; &#xA;   &lt;td&gt;多&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;mxVision&lt;/td&gt; &#xA;   &lt;td&gt;否&lt;/td&gt; &#xA;   &lt;td&gt;高&lt;/td&gt; &#xA;   &lt;td&gt;仅限华为&lt;/td&gt; &#xA;   &lt;td&gt;高&lt;/td&gt; &#xA;   &lt;td&gt;多&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VideoPipe&lt;/td&gt; &#xA;   &lt;td&gt;是&lt;/td&gt; &#xA;   &lt;td&gt;低&lt;/td&gt; &#xA;   &lt;td&gt;不限平台&lt;/td&gt; &#xA;   &lt;td&gt;中&lt;/td&gt; &#xA;   &lt;td&gt;少&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;code&gt;VideoPipe&lt;/code&gt; 采用面向插件的编码风格，可以根据不同的需求按需搭配，我们可以使用独立的插件（即框架中的 &lt;code&gt;Node&lt;/code&gt; 类型），来构建不同类型的视频分析应用。你只需准备好模型并了解如何解析其输出即可，推理可以基于不同的后端实现，如 OpenCV::DNN（默认）、TensorRT、PaddleInference、ONNXRuntime 等，任何你喜欢的都可以。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/p1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;三、演示&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/sherlockchou86/video_pipe_c/assets/13251045/b1289faa-e2c7-4d38-871e-879ae36f6d50&#34;&gt;https://github.com/sherlockchou86/video_pipe_c/assets/13251045/b1289faa-e2c7-4d38-871e-879ae36f6d50&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;播放器右下角全屏观看，&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/SAMPLES.md&#34;&gt;更多视频演示&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;四、功能&lt;/h2&gt; &#xA;&lt;p&gt;VideoPipe 是一个让计算机视觉算法模型集成更加简单的框架，注意它不是像 TensorFlow、TensorRT 类似的深度学习框架。VideoPipe主要功能如下：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;流读取：⽀持主流的视频流协议，如 udp、rtsp、rtmp、file、application。同时支持图片读取。&lt;/li&gt; &#xA; &lt;li&gt;视频解码：⽀持基于 OpenCV/GStreamer 的视频和图片解码（⽀持硬件加速）。&lt;/li&gt; &#xA; &lt;li&gt;算法推理：⽀持基于深度学习算法的多级推理，例如⽬标检测、图像分类、特征提取、图像生成等相关网络集成。同时支持传统图像算法集成。&lt;/li&gt; &#xA; &lt;li&gt;⽬标跟踪：⽀持⽬标追踪，例如 IOU、SORT 跟踪算法等。&lt;/li&gt; &#xA; &lt;li&gt;⾏为分析（BA）：⽀持基于跟踪的⾏为分析，例如越线、停⻋、违章等交通行为判断。&lt;/li&gt; &#xA; &lt;li&gt;业务逻辑：支持任意自定义业务逻辑的集成，可以与业务强相关。&lt;/li&gt; &#xA; &lt;li&gt;数据代理：⽀持将结构化数据（json/xml/⾃定义格式）以 kafka/Sokcet 等⽅式推送到云端、文件或其他第三⽅平台。&lt;/li&gt; &#xA; &lt;li&gt;录制：⽀持特定时间段的视频录制，特定帧的截图，并存文件。&lt;/li&gt; &#xA; &lt;li&gt;屏幕显⽰（OSD）：支持将结构化数据、业务逻辑处理结果绘制到帧上。&lt;/li&gt; &#xA; &lt;li&gt;视频编码：⽀持基于 OpenCV/GStreamer 的视频和图片编码（⽀持硬件加速）。&lt;/li&gt; &#xA; &lt;li&gt;流推送：⽀持主流的视频流协议，如 udp、rtsp、rtmp、file、application。同时支持图片推送。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;五、快速上手&lt;/h2&gt; &#xA;&lt;h3&gt;5.1 依赖&lt;/h3&gt; &#xA;&lt;p&gt;平台&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ubuntu 18.04 x86_64 NVIDIA rtx/tesla GPUs&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu 18.04 aarch64 NVIDIA jetson serials device，tx2 tested&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu 18.04 x86_64 Cambrian MLU serials device, MLU 370 tested (code not provided)&lt;/li&gt; &#xA; &lt;li&gt;Ubuntu 18.04 aarch64 Rockchip RK35** serials device, RK3588 tested (code not provided)&lt;/li&gt; &#xA; &lt;li&gt;Wait for your test&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;基础&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C++ 17&lt;/li&gt; &#xA; &lt;li&gt;OpenCV &amp;gt;= 4.6&lt;/li&gt; &#xA; &lt;li&gt;GStreamer 1.14.5 (Required by OpenCV)&lt;/li&gt; &#xA; &lt;li&gt;GCC &amp;gt;= 7.5&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;可选，如果你需要实现自己的推理后端，或者使用除 &lt;code&gt;opencv::dnn&lt;/code&gt; 之外的其他推理后端.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CUDA&lt;/li&gt; &#xA; &lt;li&gt;TensorRT&lt;/li&gt; &#xA; &lt;li&gt;Paddle Inference&lt;/li&gt; &#xA; &lt;li&gt;ONNX Runtime&lt;/li&gt; &#xA; &lt;li&gt;Anything you like&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/third_party/trt_vehicle/README.md&#34;&gt;如何安装CUDA和TensorRT&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/third_party/paddle_ocr/README.md&#34;&gt;如何安装Paddle_Inference&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;5.2 编译和调试&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;运行 &lt;code&gt;git clone https://github.com/sherlockchou86/VideoPipe.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;运行 &lt;code&gt;cd VideoPipe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;运行 &lt;code&gt;mkdir build &amp;amp;&amp;amp; cd build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;运行 &lt;code&gt;cmake ..&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;运行 &lt;code&gt;make -j8&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;编译完成后，所有的库文件存放在 &lt;code&gt;build/libs&lt;/code&gt; 中，所有的 Sample 运行文件存放在 &lt;code&gt;build/bin&lt;/code&gt; 中。在执行第 4 步的时候，可以添加一些编译选项：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;-DVP_WITH_CUDA=ON （编译 CUDA 相关功能，默认为 OFF）&lt;/li&gt; &#xA; &lt;li&gt;-DVP_WITH_TRT=ON （编译 TensorRT 相关功能和 Samples，默认为 OFF）&lt;/li&gt; &#xA; &lt;li&gt;-DVP_WITH_PADDLE=ON （编译 PaddlePaddle 相关功能和 Samples，默认为 OFF）&lt;/li&gt; &#xA; &lt;li&gt;-DVP_WITH_KAFKA=ON （编译 Kafka 相关功能和 Samples，默认为 OFF）&lt;/li&gt; &#xA; &lt;li&gt;-DVP_BUILD_COMPLEX_SAMPLES=ON （编译高级 Samples，默认为 OFF）&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;比如需要开启CUDA和TensorRT相关的模块，可以运行 &lt;code&gt;cmake -DVP_WITH_CUDA=ON -DVP_WITH_TRT=ON ..&lt;/code&gt;。如果只运行 &lt;code&gt;cmake ..&lt;/code&gt;，那么所有代码运行在 CPU 上。&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 开启全部&#xA;cmake -DVP_WITH_CUDA=ON \&#xA;-DVP_WITH_TRT=ON \&#xA;-DVP_WITH_PADDLE=ON \&#xA;-DVP_WITH_KAFKA=ON \&#xA;-DVP_BUILD_COMPLEX_SAMPLES=ON ..&#xA;&#xA;# 关闭全部（默认）&#xA;cmake ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果要运行编译生成的 Samples，先下载模型文件和测试数据：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://drive.google.com/drive/folders/1v9dVcR6xttUTB-WPsH3mZ_ZZMzD4wG-v?usp=sharing&#34;&gt;谷歌网盘下载测试文件和模型&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1jr2nBnEDmuNaM5DiMjbC0g?pwd=nf53&#34;&gt;百度网盘下载测试文件和模型&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;将下载好的目录（名称为 vp_data）放在任何位置（比如放在 &lt;code&gt;/root/abc&lt;/code&gt; 下面），然后在 &lt;code&gt;同一目录&lt;/code&gt; 下运行 Sample，比如在 &lt;code&gt;/root/abc&lt;/code&gt; 下面执行命令：&lt;code&gt;[path to VideoPipe]/build/bin/1-1-1_sample&lt;/code&gt; 即可运行 1-1-1_sample。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;./third_party/&lt;/code&gt; 下面都是独立的项目，有的是 header-only 库，被 VideoPipe 直接引用；有的包含有 cpp 文件，可以独立编译或运行，VideoPipe 依赖这些库，在编译 VideoPipe 的过程中会自动编译这些库。这些库也包含自己的 Samples，具体使用方法可参见对应子目录下的 README 文件.&lt;/p&gt; &#xA;&lt;h3&gt;5.3 如何使用&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;先将 VideoPipe 编译成库，然后引用它.&lt;/li&gt; &#xA; &lt;li&gt;或者直接引用源代码，然后编译整个Application.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;下面是一个如何构建 Pipeline 然后运行的 Sample(请先修改代码中的相关文件路径)：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &#34;../nodes/vp_file_src_node.h&#34;&#xA;#include &#34;../nodes/infers/vp_yunet_face_detector_node.h&#34;&#xA;#include &#34;../nodes/infers/vp_sface_feature_encoder_node.h&#34;&#xA;#include &#34;../nodes/osd/vp_face_osd_node_v2.h&#34;&#xA;#include &#34;../nodes/vp_screen_des_node.h&#34;&#xA;#include &#34;../nodes/vp_rtmp_des_node.h&#34;&#xA;#include &#34;../utils/analysis_board/vp_analysis_board.h&#34;&#xA;&#xA;/*&#xA;* 名称：1-1-N sample&#xA;* 完整代码位于：samples/1-1-N_sample.cpp&#xA;* 功能说明：1个视频输入，1个视频分析任务（人脸检测和识别），2个输出（屏幕输出/RTMP推流输出）&#xA;*/&#xA;&#xA;int main() {&#xA;    VP_SET_LOG_INCLUDE_CODE_LOCATION(false);&#xA;    VP_SET_LOG_INCLUDE_THREAD_ID(false);&#xA;    VP_LOGGER_INIT();&#xA;&#xA;    // 1、创建节点&#xA;    // 视频获取 Node&#xA;    auto file_src_0 = std::make_shared&amp;lt;vp_nodes::vp_file_src_node&amp;gt;(&#34;file_src_0&#34;, 0, &#34;./test_video/10.mp4&#34;, 0.6);&#xA;    // 2、模型推理 Node&#xA;    // 一级推理：人脸检测&#xA;    auto yunet_face_detector_0 = std::make_shared&amp;lt;vp_nodes::vp_yunet_face_detector_node&amp;gt;(&#34;yunet_face_detector_0&#34;, &#34;./models/face/face_detection_yunet_2022mar.onnx&#34;);&#xA;    // 二级推理：人脸识别&#xA;    auto sface_face_encoder_0 = std::make_shared&amp;lt;vp_nodes::vp_sface_feature_encoder_node&amp;gt;(&#34;sface_face_encoder_0&#34;, &#34;./models/face/face_recognition_sface_2021dec.onnx&#34;);&#xA;    // 3、OSD Node&#xA;    // 处理结果绘制到帧上&#xA;    auto osd_0 = std::make_shared&amp;lt;vp_nodes::vp_face_osd_node_v2&amp;gt;(&#34;osd_0&#34;);&#xA;    // 屏幕展示&#xA;    auto screen_des_0 = std::make_shared&amp;lt;vp_nodes::vp_screen_des_node&amp;gt;(&#34;screen_des_0&#34;, 0);&#xA;    // 推流展示&#xA;    auto rtmp_des_0 = std::make_shared&amp;lt;vp_nodes::vp_rtmp_des_node&amp;gt;(&#34;rtmp_des_0&#34;, 0, &#34;rtmp://192.168.77.60/live/10000&#34;);&#xA;&#xA;    // 构建管道，将节点的处理结果关联起来&#xA;    yunet_face_detector_0-&amp;gt;attach_to({file_src_0});&#xA;    sface_face_encoder_0-&amp;gt;attach_to({yunet_face_detector_0});&#xA;    osd_0-&amp;gt;attach_to({sface_face_encoder_0});&#xA;&#xA;    // 管道自动拆分，通过屏幕/推流输出结果&#xA;    screen_des_0-&amp;gt;attach_to({osd_0});&#xA;    rtmp_des_0-&amp;gt;attach_to({osd_0});&#xA;&#xA;    // 启动管道&#xA;    file_src_0-&amp;gt;start();&#xA;&#xA;    // 可视化管道&#xA;    vp_utils::vp_analysis_board board({file_src_0});&#xA;    board.display();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;上面代码运行后，会出现 3 个画面:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;管道的运行状态图，状态自动刷新&lt;/li&gt; &#xA; &lt;li&gt;屏幕显示结果（GUI）&lt;/li&gt; &#xA; &lt;li&gt;播放器显示结果（RTMP）&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/g3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;5.4 案例原型&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ID&lt;/th&gt; &#xA;   &lt;th&gt;Sample&lt;/th&gt; &#xA;   &lt;th&gt;截图&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;face_tracking_sample&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/p18.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;vehicle_tracking_sample&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/p22.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;mask_rcnn_sample&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/p30.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;4&lt;/td&gt; &#xA;   &lt;td&gt;openpose_sample&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/p31.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;5&lt;/td&gt; &#xA;   &lt;td&gt;face_swap_sample&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/p57.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;共计 40 多个原型案例，&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/SAMPLES.md&#34;&gt;点击&lt;/a&gt;查看更多。&lt;/p&gt; &#xA;&lt;h2&gt;六、更多资料&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/samples&#34;&gt;Sample Code&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/nodes/README.md&#34;&gt;Node Table&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/about.md&#34;&gt;How VideoPipe Works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/env.md&#34;&gt;Development Environment For Reference&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;扫码入群交流&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sherlockchou86/VideoPipe/master/doc/vx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;鸣谢&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://hellogithub.com/repository/4284d29e778642a4a51a471ab1eae6f0&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://api.hellogithub.com/v1/widgets/recommend.svg?rid=4284d29e778642a4a51a471ab1eae6f0&#34; alt=&#34;Featured｜HelloGitHub&#34; style=&#34;width: 250px; height: 54px;&#34; width=&#34;250&#34; height=&#34;54&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>tstack/lnav</title>
    <updated>2024-05-01T01:29:32Z</updated>
    <id>tag:github.com,2024-05-01:/tstack/lnav</id>
    <link href="https://github.com/tstack/lnav" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Log file navigator&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/tstack/lnav/actions?query=workflow%3Aci-build&#34;&gt;&lt;img src=&#34;https://github.com/tstack/lnav/workflows/ci-build/badge.svg?sanitize=true&#34; alt=&#34;Build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.lnav.org&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/lnav/badge/?version=latest&amp;amp;style=plastic&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://coveralls.io/github/tstack/lnav?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/tstack/lnav/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://snapcraft.io/lnav&#34;&gt;&lt;img src=&#34;https://snapcraft.io/lnav/badge.svg?sanitize=true&#34; alt=&#34;lnav&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/erBPnKwz7R&#34;&gt;&lt;img src=&#34;https://assets-global.website-files.com/6257adef93867e50d84d30e2/62594fddd654fc29fcc07359_cb48d2a8d4991281d7a6a95d2f58195e.svg?sanitize=true&#34; height=&#34;20&#34; alt=&#34;Discord Logo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;This is the source repository for &lt;strong&gt;lnav&lt;/strong&gt;, visit &lt;a href=&#34;https://lnav.org&#34;&gt;https://lnav.org&lt;/a&gt; for a high level overview.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h1&gt;LNAV -- The Logfile Navigator&lt;/h1&gt; &#xA;&lt;p&gt;The Logfile Navigator is a log file viewer for the terminal. Given a set of files/directories, &lt;strong&gt;lnav&lt;/strong&gt; will:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;decompress as needed;&lt;/li&gt; &#xA; &lt;li&gt;detect their format;&lt;/li&gt; &#xA; &lt;li&gt;merge the files together by time into a single view;&lt;/li&gt; &#xA; &lt;li&gt;tail the files, follow renames, find new files in directories;&lt;/li&gt; &#xA; &lt;li&gt;build an index of errors and warnings;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.lnav.org/en/latest/formats.html#json-lines&#34;&gt;pretty-print JSON-lines&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then, in the &lt;strong&gt;lnav&lt;/strong&gt; TUI, you can:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;jump quickly to the previous/next error (&lt;a href=&#34;https://docs.lnav.org/en/latest/hotkeys.html#spatial-navigation&#34;&gt;press &lt;code&gt;e&lt;/code&gt;/&lt;code&gt;E&lt;/code&gt;&lt;/a&gt;);&lt;/li&gt; &#xA; &lt;li&gt;search using regular expressions (&lt;a href=&#34;https://docs.lnav.org/en/latest/hotkeys.html#spatial-navigation&#34;&gt;press &lt;code&gt;/&lt;/code&gt;&lt;/a&gt;);&lt;/li&gt; &#xA; &lt;li&gt;highlight text with a regular expression (&lt;a href=&#34;https://docs.lnav.org/en/latest/commands.html#highlight-pattern&#34;&gt;&lt;code&gt;:highlight&lt;/code&gt;&lt;/a&gt; command);&lt;/li&gt; &#xA; &lt;li&gt;filter messages using &lt;a href=&#34;https://docs.lnav.org/en/latest/usage.html#regular-expression-match&#34;&gt;regular expressions&lt;/a&gt; or &lt;a href=&#34;https://docs.lnav.org/en/latest/usage.html#sqlite-expression&#34;&gt;SQLite expressions&lt;/a&gt;;&lt;/li&gt; &#xA; &lt;li&gt;pretty-print structured text (&lt;a href=&#34;https://docs.lnav.org/en/latest/ui.html#pretty&#34;&gt;press &lt;code&gt;P&lt;/code&gt;&lt;/a&gt;);&lt;/li&gt; &#xA; &lt;li&gt;view a histogram of messages over time (&lt;a href=&#34;https://docs.lnav.org/en/latest/ui.html#hist&#34;&gt;press &lt;code&gt;i&lt;/code&gt;&lt;/a&gt;);&lt;/li&gt; &#xA; &lt;li&gt;query messages using SQLite (&lt;a href=&#34;https://docs.lnav.org/en/latest/sqlext.html&#34;&gt;press &lt;code&gt;;&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;p&gt;The following screenshot shows a mix of syslog and web access log files. Failed requests are shown in red. Identifiers, like IP address and PIDs are semantically highlighted.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tstack/lnav/master/docs/assets/images/lnav-front-page.png&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tstack/lnav/master/docs/assets/images/lnav-front-page.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why not &lt;strong&gt;just&lt;/strong&gt; use &lt;code&gt;tail&lt;/code&gt;/&lt;code&gt;grep&lt;/code&gt;/&lt;code&gt;less&lt;/code&gt;?&lt;/h2&gt; &#xA;&lt;p&gt;The standard Unix utilities are great for processing raw text lines, however, they do not understand log messages. Tail can watch multiple files at a time, but it won&#39;t display messages in order by time and you can&#39;t scroll backwards. Grep will only find matching lines, but won&#39;t return a full multi-line log message. Less can only display a single file at a time. Also, none of these basic tools handle compressed files.&lt;/p&gt; &#xA;&lt;h2&gt;Try online before installing&lt;/h2&gt; &#xA;&lt;p&gt;You can SSH into a demo node to play with lnav before installing.&lt;/p&gt; &#xA;&lt;p&gt;The &#34;playground&#34; account starts lnav with a couple of log files as an example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;ssh://playground@demo.lnav.org&#34;&gt;&lt;code&gt;$ ssh playground@demo.lnav.org&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &#34;tutorial 1&#34; account is an interactive tutorial that can teach you the basics of operation:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;ssh://tutorial1@demo.lnav.org&#34;&gt;&lt;code&gt;$ ssh tutorial1@demo.lnav.org&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tstack/lnav/releases/latest#release-artifacts&#34;&gt;Download a statically-linked binary for Linux/MacOS from the release page&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Brew on MacOS&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ brew install lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Simply point &lt;strong&gt;lnav&lt;/strong&gt; at the files or directories you want to monitor, it will figure out the rest:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ lnav /path/to/file1 /path/to/dir ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;strong&gt;lnav&lt;/strong&gt; TUI will pop up right away and begin indexing the files. Progress is displayed in the &#34;Files&#34; panel at the bottom. Once the indexing has finished, the LOG view will display the log messages that were recognized[^1]. You can then use the usual hotkeys to move around the view (arrow keys or &lt;code&gt;j&lt;/code&gt;/&lt;code&gt;k&lt;/code&gt;/&lt;code&gt;h&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt; to move down/up/left/right).&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://docs.lnav.org/en/latest/usage.html&#34;&gt;Usage section&lt;/a&gt; of the online documentation for more information.&lt;/p&gt; &#xA;&lt;p&gt;[^1]: Files that do not contain log messages can be seen in the TEXT view (reachable by pressing &lt;code&gt;t&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Usage with &lt;code&gt;systemd-journald&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;On systems running &lt;code&gt;systemd-journald&lt;/code&gt;, you can use &lt;code&gt;lnav&lt;/code&gt; as the pager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ journalctl | lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or in follow mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ journalctl -f | lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since &lt;code&gt;journalctl&lt;/code&gt;&#39;s default output format omits the year, if you are viewing logs which span multiple years you will need to change the output format to include the year, otherwise &lt;code&gt;lnav&lt;/code&gt; gets confused:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ journalctl -o short-iso | lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to use &lt;code&gt;journalctl&lt;/code&gt;&#39;s json output format and &lt;code&gt;lnav&lt;/code&gt; will make use of additional fields such as PRIORITY and _SYSTEMD_UNIT:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ journalctl -o json | lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In case some MESSAGE fields contain special characters such as ANSI color codes which are considered as unprintable by journalctl, specifying &lt;code&gt;journalctl&lt;/code&gt;&#39;s &lt;code&gt;-a&lt;/code&gt; option might be preferable in order to output those messages still in a non-binary representation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ journalctl -a -o json | lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If using systemd v236 or newer, the output fields can be limited to the ones actually recognized by &lt;code&gt;lnav&lt;/code&gt; for increased efficiency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ journalctl -o json --output-fields=MESSAGE,PRIORITY,_PID,SYSLOG_IDENTIFIER,_SYSTEMD_UNIT | lnav&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If your system has been running for a long time, for increased efficiency you may want to limit the number of log lines fed into &lt;code&gt;lnav&lt;/code&gt;, e.g. via &lt;code&gt;journalctl&lt;/code&gt;&#39;s &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--since=...&lt;/code&gt; options.&lt;/p&gt; &#xA;&lt;p&gt;In case of a persistent journal, you may want to limit the number of log lines fed into &lt;code&gt;lnav&lt;/code&gt; via &lt;code&gt;journalctl&lt;/code&gt;&#39;s &lt;code&gt;-b&lt;/code&gt; option.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;Please file issues on this repository or use the discussions section. The following alternatives are also available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;mailto:support@lnav.org&#34;&gt;support@lnav.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/erBPnKwz7R&#34;&gt;Discord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://groups.google.com/g/lnav&#34;&gt;Google Groups&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://lnav.org&#34;&gt;Main Site&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.lnav.org&#34;&gt;&lt;strong&gt;Documentation&lt;/strong&gt;&lt;/a&gt; on Read the Docs&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/tstack/lnav/master/ARCHITECTURE.md&#34;&gt;Internal Architecture&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sponsors/tstack&#34;&gt;Become a Sponsor on GitHub&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Building From Source&lt;/h3&gt; &#xA;&lt;h4&gt;Prerequisites&lt;/h4&gt; &#xA;&lt;p&gt;The following software packages are required to build lnav:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;gcc/clang - A C++14-compatible compiler.&lt;/li&gt; &#xA; &lt;li&gt;libpcre2 - The Perl Compatible Regular Expression v2 (PCRE2) library.&lt;/li&gt; &#xA; &lt;li&gt;sqlite - The SQLite database engine. Version 3.9.0 or higher is required.&lt;/li&gt; &#xA; &lt;li&gt;ncurses - The ncurses text UI library.&lt;/li&gt; &#xA; &lt;li&gt;readline - The readline line editing library.&lt;/li&gt; &#xA; &lt;li&gt;zlib - The zlib compression library.&lt;/li&gt; &#xA; &lt;li&gt;bz2 - The bzip2 compression library.&lt;/li&gt; &#xA; &lt;li&gt;libcurl - The cURL library for downloading files from URLs. Version 7.23.0 or higher is required.&lt;/li&gt; &#xA; &lt;li&gt;libarchive - The libarchive library for opening archive files, like zip/tgz.&lt;/li&gt; &#xA; &lt;li&gt;wireshark - The &#39;tshark&#39; program is used to interpret pcap files.&lt;/li&gt; &#xA; &lt;li&gt;cargo/rust - The Rust language is used to build the PRQL compiler.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Build&lt;/h4&gt; &#xA;&lt;p&gt;Lnav follows the usual GNU style for configuring and installing software:&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;./autogen.sh&lt;/code&gt; if compiling from a cloned repository.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ./configure&#xA;$ make&#xA;$ sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;See Also&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rcoh/angle-grinder&#34;&gt;Angle-grinder&lt;/a&gt; is a tool to slice and dice log files on the command-line. If you&#39;re familiar with the SumoLogic query language, you might find this tool more comfortable to work with.&lt;/p&gt;</summary>
  </entry>
</feed>