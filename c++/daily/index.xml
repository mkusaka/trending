<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-16T01:29:44Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>stephenberry/glaze</title>
    <updated>2024-12-16T01:29:44Z</updated>
    <id>tag:github.com,2024-12-16:/stephenberry/glaze</id>
    <link href="https://github.com/stephenberry/glaze" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Extremely fast, in memory, JSON and interface library for modern C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Glaze&lt;/h1&gt; &#xA;&lt;p&gt;One of the fastest JSON libraries in the world. Glaze reads and writes from object memory, simplifying interfaces and offering incredible performance.&lt;/p&gt; &#xA;&lt;p&gt;Glaze also supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/beve-org/beve&#34;&gt;BEVE&lt;/a&gt; (binary efficient versatile encoding)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/csv.md&#34;&gt;CSV&lt;/a&gt; (comma separated value)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;With compile time reflection for MSVC, Clang, and GCC!&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Read/write aggregate initializable structs without writing any metadata or macros!&lt;/li&gt; &#xA; &lt;li&gt;See &lt;a href=&#34;https://gcc.godbolt.org/z/T4To5fKfz&#34;&gt;example on Compiler Explorer&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Highlights&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Pure, compile time reflection for structs&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Powerful meta specialization system for custom names and behavior&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;JSON &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc8259&#34;&gt;RFC 8259&lt;/a&gt; compliance with UTF-8 validation&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Standard C++ library support&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Header only&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Direct to memory serialization/deserialization&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compile time maps with constant time lookups and perfect hashing&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Powerful wrappers to modify read/write behavior (&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/wrappers.md&#34;&gt;Wrappers&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use your own custom read/write functions (&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/#custom-readwrite&#34;&gt;Custom Read/Write&lt;/a&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/unknown-keys.md&#34;&gt;Handle unknown keys&lt;/a&gt; in a fast and flexible manner&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Direct memory access through &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/json-pointer-syntax.md&#34;&gt;JSON pointer syntax&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/binary.md&#34;&gt;Binary data&lt;/a&gt; through the same API for maximum performance&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No exceptions (compiles with &lt;code&gt;-fno-exceptions&lt;/code&gt;)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you desire helpers that throw for cleaner syntax see &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/exceptions.md&#34;&gt;Glaze Exceptions&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;No runtime type information necessary (compiles with &lt;code&gt;-fno-rtti&lt;/code&gt;)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Rapid error handling with short circuiting&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/rpc/json-rpc.md&#34;&gt;JSON-RPC 2.0 support&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/json-schema.md&#34;&gt;JSON Schema generation&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Extremely portable, uses carefully optimized SWAR (SIMD Within A Register) for broad compatibility&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/partial-read.md&#34;&gt;Partial Read&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/partial-write.md&#34;&gt;Partial Write&lt;/a&gt; support&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/csv.md&#34;&gt;CSV Reading/Writing&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/#more-features&#34;&gt;Much more!&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/stephenberry/glaze/tree/main/docs&#34;&gt;DOCS&lt;/a&gt; for more documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;Roundtrip Time (s)&lt;/th&gt; &#xA;   &lt;th&gt;Write (MB/s)&lt;/th&gt; &#xA;   &lt;th&gt;Read (MB/s)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/stephenberry/glaze&#34;&gt;&lt;strong&gt;Glaze&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1.04&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1366&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1224&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/simdjson/simdjson&#34;&gt;&lt;strong&gt;simdjson (on demand)&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;N/A&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;N/A&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1198&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ibireme/yyjson&#34;&gt;&lt;strong&gt;yyjson&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1.23&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1005&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1107&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/beached/daw_json_link&#34;&gt;&lt;strong&gt;daw_json_link&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;2.93&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;365&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;553&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson&#34;&gt;&lt;strong&gt;RapidJSON&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;3.65&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;290&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;450&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://boost.org/libs/json&#34;&gt;&lt;strong&gt;Boost.JSON (direct)&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;4.76&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;199&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;447&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/jorgen/json_struct&#34;&gt;&lt;strong&gt;json_struct&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;5.50&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;182&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;326&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/nlohmann/json&#34;&gt;&lt;strong&gt;nlohmann&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;15.71&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;84&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;80&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stephenberry/json_performance&#34;&gt;Performance test code available here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Performance caveats: &lt;a href=&#34;https://github.com/simdjson/simdjson&#34;&gt;simdjson&lt;/a&gt; and &lt;a href=&#34;https://github.com/ibireme/yyjson&#34;&gt;yyjson&lt;/a&gt; are great, but they experience major performance losses when the data is not in the expected sequence or any keys are missing (the problem grows as the file size increases, as they must re-iterate through the document).&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Also, &lt;a href=&#34;https://github.com/simdjson/simdjson&#34;&gt;simdjson&lt;/a&gt; and &lt;a href=&#34;https://github.com/ibireme/yyjson&#34;&gt;yyjson&lt;/a&gt; do not support automatic escaped string handling, so if any of the currently non-escaped strings in this benchmark were to contain an escape, the escapes would not be handled.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stephenberry/json_performance&#34;&gt;ABC Test&lt;/a&gt; shows how simdjson has poor performance when keys are not in the expected sequence:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Library&lt;/th&gt; &#xA;   &lt;th&gt;Read (MB/s)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/stephenberry/glaze&#34;&gt;&lt;strong&gt;Glaze&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;678&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/simdjson/simdjson&#34;&gt;&lt;strong&gt;simdjson (on demand)&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;93&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Binary Performance&lt;/h2&gt; &#xA;&lt;p&gt;Tagged binary specification: &lt;a href=&#34;https://github.com/stephenberry/beve&#34;&gt;BEVE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Metric&lt;/th&gt; &#xA;   &lt;th&gt;Roundtrip Time (s)&lt;/th&gt; &#xA;   &lt;th&gt;Write (MB/s)&lt;/th&gt; &#xA;   &lt;th&gt;Read (MB/s)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Raw performance&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;0.42&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;3235&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;2468&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Equivalent JSON data*&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;0.42&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;3547&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;2706&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;JSON size: 670 bytes&lt;/p&gt; &#xA;&lt;p&gt;BEVE size: 611 bytes&lt;/p&gt; &#xA;&lt;p&gt;*BEVE packs more efficiently than JSON, so transporting the same data is even faster.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!TIP]&lt;/p&gt; &#xA; &lt;p&gt;See the &lt;a href=&#34;https://github.com/stephenberry/glaze/raw/main/tests/example_json/example_json.cpp&#34;&gt;example_json&lt;/a&gt; unit test for basic examples of how to use Glaze. See &lt;a href=&#34;https://github.com/stephenberry/glaze/raw/main/tests/json_test/json_test.cpp&#34;&gt;json_test&lt;/a&gt; for an extensive test of features.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Your struct will automatically get reflected! No metadata is required by the user.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct my_struct&#xA;{&#xA;  int i = 287;&#xA;  double d = 3.14;&#xA;  std::string hello = &#34;Hello World&#34;;&#xA;  std::array&amp;lt;uint64_t, 3&amp;gt; arr = { 1, 2, 3 };&#xA;  std::map&amp;lt;std::string, int&amp;gt; map{{&#34;one&#34;, 1}, {&#34;two&#34;, 2}};&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON&lt;/strong&gt; (prettified)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;   &#34;i&#34;: 287,&#xA;   &#34;d&#34;: 3.14,&#xA;   &#34;hello&#34;: &#34;Hello World&#34;,&#xA;   &#34;arr&#34;: [&#xA;      1,&#xA;      2,&#xA;      3&#xA;   ],&#xA;   &#34;map&#34;: {&#xA;      &#34;one&#34;: 1,&#xA;      &#34;two&#34;: 2&#xA;   }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Write JSON&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;my_struct s{};&#xA;std::string buffer = glz::write_json(s).value_or(&#34;error&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;my_struct s{};&#xA;std::string buffer{};&#xA;auto ec = glz::write_json(s, buffer);&#xA;if (ec) {&#xA;  // handle error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Read JSON&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string buffer = R&#34;({&#34;i&#34;:287,&#34;d&#34;:3.14,&#34;hello&#34;:&#34;Hello World&#34;,&#34;arr&#34;:[1,2,3],&#34;map&#34;:{&#34;one&#34;:1,&#34;two&#34;:2}})&#34;;&#xA;auto s = glz::read_json&amp;lt;my_struct&amp;gt;(buffer);&#xA;if (s) // check std::expected&#xA;{&#xA;  s.value(); // s.value() is a my_struct populated from buffer&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string buffer = R&#34;({&#34;i&#34;:287,&#34;d&#34;:3.14,&#34;hello&#34;:&#34;Hello World&#34;,&#34;arr&#34;:[1,2,3],&#34;map&#34;:{&#34;one&#34;:1,&#34;two&#34;:2}})&#34;;&#xA;my_struct s{};&#xA;auto ec = glz::read_json(s, buffer); // populates s from buffer&#xA;if (ec) {&#xA;  // handle error&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Read/Write From File&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto ec = glz::read_file_json(obj, &#34;./obj.json&#34;, std::string{});&#xA;auto ec = glz::write_file_json(obj, &#34;./obj.json&#34;, std::string{});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;/p&gt; &#xA; &lt;p&gt;The file name (2nd argument), must be null terminated.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Compiler/System Support&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Requires C++23&lt;/li&gt; &#xA; &lt;li&gt;Tested for both 64bit and 32bit&lt;/li&gt; &#xA; &lt;li&gt;Only supports little-endian systems&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/stephenberry/glaze/actions&#34;&gt;Actions&lt;/a&gt; build and test with &lt;a href=&#34;https://clang.llvm.org&#34;&gt;Clang&lt;/a&gt; (17+), &lt;a href=&#34;https://visualstudio.microsoft.com/vs/features/cplusplus/&#34;&gt;MSVC&lt;/a&gt; (2022), and &lt;a href=&#34;https://gcc.gnu.org&#34;&gt;GCC&lt;/a&gt; (12+) on apple, windows, and linux.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/stephenberry/glaze/actions/workflows/clang.yml/badge.svg?sanitize=true&#34; alt=&#34;clang build&#34;&gt; &lt;img src=&#34;https://github.com/stephenberry/glaze/actions/workflows/gcc.yml/badge.svg?sanitize=true&#34; alt=&#34;gcc build&#34;&gt; &lt;img src=&#34;https://github.com/stephenberry/glaze/actions/workflows/msvc.yml/badge.svg?sanitize=true&#34; alt=&#34;msvc build&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Glaze seeks to maintain compatibility with the latest three versions of GCC and Clang, as well as the latest version of MSVC and Apple Clang.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;MSVC Compiler Flags&lt;/h3&gt; &#xA;&lt;p&gt;Glaze requires a C++ standard conformant pre-processor, which requires the &lt;code&gt;/Zc:preprocessor&lt;/code&gt; flag when building with MSVC.&lt;/p&gt; &#xA;&lt;h3&gt;SIMD CMake Options&lt;/h3&gt; &#xA;&lt;p&gt;The CMake has the option &lt;code&gt;glaze_ENABLE_AVX2&lt;/code&gt;. This will attempt to use &lt;code&gt;AVX2&lt;/code&gt; SIMD instructions in some cases to improve performance, as long as the system you are configuring on supports it. Set this option to &lt;code&gt;OFF&lt;/code&gt; to disable the AVX2 instruction set, such as if you are cross-compiling for Arm. If you aren&#39;t using CMake the macro &lt;code&gt;GLZ_USE_AVX2&lt;/code&gt; enables the feature if defined.&lt;/p&gt; &#xA;&lt;h2&gt;How To Use Glaze&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://cmake.org/cmake/help/latest/module/FetchContent.html&#34;&gt;FetchContent&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;include(FetchContent)&#xA;&#xA;FetchContent_Declare(&#xA;  glaze&#xA;  GIT_REPOSITORY https://github.com/stephenberry/glaze.git&#xA;  GIT_TAG main&#xA;  GIT_SHALLOW TRUE&#xA;)&#xA;&#xA;FetchContent_MakeAvailable(glaze)&#xA;&#xA;target_link_libraries(${PROJECT_NAME} PRIVATE glaze::glaze)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://conan.io&#34;&gt;Conan&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Included in &lt;a href=&#34;https://conan.io/center/&#34;&gt;Conan Center&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/conan/v/glaze&#34; alt=&#34;Conan Center&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;find_package(glaze REQUIRED)&#xA;&#xA;target_link_libraries(main PRIVATE glaze::glaze)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://build2.org&#34;&gt;build2&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Available on &lt;a href=&#34;https://cppget.org/libglaze&#34;&gt;cppget&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;import libs = libglaze%lib{glaze}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arch Linux&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AUR packages: &lt;a href=&#34;https://aur.archlinux.org/packages/glaze&#34;&gt;glaze&lt;/a&gt; and &lt;a href=&#34;https://aur.archlinux.org/packages/glaze-git&#34;&gt;glaze-git&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;See this &lt;a href=&#34;https://github.com/stephenberry/glaze_example&#34;&gt;Example Repository&lt;/a&gt; for how to use Glaze in a new project&lt;/h3&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/FAQ.md&#34;&gt;FAQ&lt;/a&gt; for Frequently Asked Questions&lt;/h2&gt; &#xA;&lt;h1&gt;Explicit Metadata&lt;/h1&gt; &#xA;&lt;p&gt;If you want to specialize your reflection then you can &lt;strong&gt;optionally&lt;/strong&gt; write the code below:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This metadata is also necessary for non-aggregate initializable structs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;my_struct&amp;gt; {&#xA;   using T = my_struct;&#xA;   static constexpr auto value = object(&#xA;      &amp;amp;T::i,&#xA;      &amp;amp;T::d,&#xA;      &amp;amp;T::hello,&#xA;      &amp;amp;T::arr,&#xA;      &amp;amp;T::map&#xA;   );&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Local Glaze Meta&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Glaze also supports metadata within its associated class:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct my_struct&#xA;{&#xA;  int i = 287;&#xA;  double d = 3.14;&#xA;  std::string hello = &#34;Hello World&#34;;&#xA;  std::array&amp;lt;uint64_t, 3&amp;gt; arr = { 1, 2, 3 };&#xA;  std::map&amp;lt;std::string, int&amp;gt; map{{&#34;one&#34;, 1}, {&#34;two&#34;, 2}};&#xA;  &#xA;  struct glaze {&#xA;     using T = my_struct;&#xA;     static constexpr auto value = glz::object(&#xA;        &amp;amp;T::i,&#xA;        &amp;amp;T::d,&#xA;        &amp;amp;T::hello,&#xA;        &amp;amp;T::arr,&#xA;        &amp;amp;T::map&#xA;     );&#xA;  };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Custom Key Names or Unnamed Types&lt;/h2&gt; &#xA;&lt;p&gt;When you define Glaze metadata, objects will automatically reflect the non-static names of your member object pointers. However, if you want custom names or you register lambda functions or wrappers that do not provide names for your fields, you can optionally add field names in your metadata.&lt;/p&gt; &#xA;&lt;p&gt;Example of custom names:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;my_struct&amp;gt; {&#xA;   using T = my_struct;&#xA;   static constexpr auto value = object(&#xA;      &#34;integer&#34;, &amp;amp;T::i,&#xA;      &#34;double&#34;, &amp;amp;T::d,&#xA;      &#34;string&#34;, &amp;amp;T::hello,&#xA;      &#34;array&#34;, &amp;amp;T::arr,&#xA;      &#34;my map&#34;, &amp;amp;T::map&#xA;   );&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Each of these strings is optional and can be removed for individual fields if you want the name to be reflected.&lt;/p&gt; &#xA; &lt;p&gt;Names are required for:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;static constexpr member variables&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/wrappers.md&#34;&gt;Wrappers&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;Lambda functions&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Reflection API&lt;/h1&gt; &#xA;&lt;p&gt;Glaze provides a compile time reflection API that can be modified via &lt;code&gt;glz::meta&lt;/code&gt; specializations. This reflection API uses pure reflection unless a &lt;code&gt;glz::meta&lt;/code&gt; specialization is provided, in which case the default behavior is overridden by the developer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static_assert(glz::reflect&amp;lt;my_struct&amp;gt;::size == 5); // Number of fields&#xA;static_assert(glz::reflect&amp;lt;my_struct&amp;gt;::keys[0] == &#34;i&#34;); // Access keys&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING]&lt;/p&gt; &#xA; &lt;p&gt;The &lt;code&gt;glz::reflect&lt;/code&gt; fields described above have been formalized and are unlikely to change. Other fields may evolve as we continue to formalize the spec.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;glz::for_each_field&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct test_type {&#xA;   int32_t int1{};&#xA;   int64_t int2{};&#xA;};&#xA;&#xA;test_type var{42, 43};&#xA;&#xA;glz::for_each_field(var, [](auto&amp;amp; field) {&#xA;    field += 1;&#xA;});&#xA;&#xA;expect(var.int1 == 43);&#xA;expect(var.int2 == 44);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Custom Read/Write&lt;/h1&gt; &#xA;&lt;p&gt;Custom reading and writing can be achieved through the powerful &lt;code&gt;to&lt;/code&gt;/&lt;code&gt;from&lt;/code&gt; specialization approach, which is described here: &lt;a href=&#34;https://github.com/stephenberry/glaze/raw/main/docs/custom-serialization.md&#34;&gt;custom-serialization.md&lt;/a&gt;. However, this only works for user defined types.&lt;/p&gt; &#xA;&lt;p&gt;For common use cases or cases where a specific member variable should have special reading and writing, you can use &lt;a href=&#34;https://github.com/stephenberry/glaze/raw/main/docs/wrappers.md#custom&#34;&gt;glz::custom&lt;/a&gt; to register read/write member functions, std::functions, or lambda functions.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;See example:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct custom_encoding&#xA;{&#xA;   uint64_t x{};&#xA;   std::string y{};&#xA;   std::array&amp;lt;uint32_t, 3&amp;gt; z{};&#xA;   &#xA;   void read_x(const std::string&amp;amp; s) {&#xA;      x = std::stoi(s);&#xA;   }&#xA;   &#xA;   uint64_t write_x() {&#xA;      return x;&#xA;   }&#xA;   &#xA;   void read_y(const std::string&amp;amp; s) {&#xA;      y = &#34;hello&#34; + s;&#xA;   }&#xA;   &#xA;   auto&amp;amp; write_z() {&#xA;      z[0] = 5;&#xA;      return z;&#xA;   }&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;custom_encoding&amp;gt;&#xA;{&#xA;   using T = custom_encoding;&#xA;   static constexpr auto value = object(&#34;x&#34;, custom&amp;lt;&amp;amp;T::read_x, &amp;amp;T::write_x&amp;gt;, //&#xA;                                        &#34;y&#34;, custom&amp;lt;&amp;amp;T::read_y, &amp;amp;T::y&amp;gt;, //&#xA;                                        &#34;z&#34;, custom&amp;lt;&amp;amp;T::z, &amp;amp;T::write_z&amp;gt;);&#xA;};&#xA;&#xA;suite custom_encoding_test = [] {&#xA;   &#34;custom_reading&#34;_test = [] {&#xA;      custom_encoding obj{};&#xA;      std::string s = R&#34;({&#34;x&#34;:&#34;3&#34;,&#34;y&#34;:&#34;world&#34;,&#34;z&#34;:[1,2,3]})&#34;;&#xA;      expect(!glz::read_json(obj, s));&#xA;      expect(obj.x == 3);&#xA;      expect(obj.y == &#34;helloworld&#34;);&#xA;      expect(obj.z == std::array&amp;lt;uint32_t, 3&amp;gt;{1, 2, 3});&#xA;   };&#xA;   &#xA;   &#34;custom_writing&#34;_test = [] {&#xA;      custom_encoding obj{};&#xA;      std::string s = R&#34;({&#34;x&#34;:&#34;3&#34;,&#34;y&#34;:&#34;world&#34;,&#34;z&#34;:[1,2,3]})&#34;;&#xA;      expect(!glz::read_json(obj, s));&#xA;      std::string out{};&#xA;      expect(not glz::write_json(obj, out));&#xA;      expect(out == R&#34;({&#34;x&#34;:3,&#34;y&#34;:&#34;helloworld&#34;,&#34;z&#34;:[5,2,3]})&#34;);&#xA;   };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Another example with constexpr lambdas:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct custom_buffer_input&#xA;{&#xA;   std::string str{};&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;custom_buffer_input&amp;gt;&#xA;{&#xA;   static constexpr auto read_x = [](custom_buffer_input&amp;amp; s, const std::string&amp;amp; input) { s.str = input; };&#xA;   static constexpr auto write_x = [](auto&amp;amp; s) -&amp;gt; auto&amp;amp; { return s.str; };&#xA;   static constexpr auto value = glz::object(&#34;str&#34;, glz::custom&amp;lt;read_x, write_x&amp;gt;);&#xA;};&#xA;&#xA;suite custom_lambdas_test = [] {&#xA;   &#34;custom_buffer_input&#34;_test = [] {&#xA;      std::string s = R&#34;({&#34;str&#34;:&#34;Hello!&#34;})&#34;;&#xA;      custom_buffer_input obj{};&#xA;      expect(!glz::read_json(obj, s));&#xA;      expect(obj.str == &#34;Hello!&#34;);&#xA;      s.clear();&#xA;      expect(!glz::write_json(obj, s));&#xA;      expect(s == R&#34;({&#34;str&#34;:&#34;Hello!&#34;})&#34;);&#xA;      expect(obj.str == &#34;Hello!&#34;);&#xA;   };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Object Mapping&lt;/h1&gt; &#xA;&lt;p&gt;When using member pointers (e.g. &lt;code&gt;&amp;amp;T::a&lt;/code&gt;) the C++ class structures must match the JSON interface. It may be desirable to map C++ classes with differing layouts to the same object interface. This is accomplished through registering lambda functions instead of member pointers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;Thing&amp;gt; {&#xA;   static constexpr auto value = object(&#xA;      &#34;i&#34;, [](auto&amp;amp;&amp;amp; self) -&amp;gt; auto&amp;amp; { return self.subclass.i; }&#xA;   );&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The value &lt;code&gt;self&lt;/code&gt; passed to the lambda function will be a &lt;code&gt;Thing&lt;/code&gt; object, and the lambda function allows us to make the subclass invisible to the object interface.&lt;/p&gt; &#xA;&lt;p&gt;Lambda functions by default copy returns, therefore the &lt;code&gt;auto&amp;amp;&lt;/code&gt; return type is typically required in order for glaze to write to memory.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note that remapping can also be achieved through pointers/references, as glaze treats values, pointers, and references in the same manner when writing/reading.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Value Types&lt;/h1&gt; &#xA;&lt;p&gt;A class can be treated as an underlying value as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct S {&#xA;  int x{};&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;S&amp;gt; {&#xA;  static constexpr auto value{ &amp;amp;S::x };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or using a lambda:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;S&amp;gt; {&#xA;  static constexpr auto value = [](auto&amp;amp; self) -&amp;gt; auto&amp;amp; { return self.x; };&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Error Handling&lt;/h1&gt; &#xA;&lt;p&gt;Glaze is safe to use with untrusted messages. Errors are returned as error codes, typically within a &lt;code&gt;glz::expected&lt;/code&gt;, which behaves just like a &lt;code&gt;std::expected&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Glaze works to short circuit error handling, which means the parsing exits very rapidly if an error is encountered.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;To generate more helpful error messages, call &lt;code&gt;format_error&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto pe = glz::read_json(obj, buffer);&#xA;if (pe) {&#xA;  std::string descriptive_error = glz::format_error(pe, buffer);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This test case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#34;Hello&#34;:&#34;World&#34;x, &#34;color&#34;: &#34;red&#34;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Produces this error:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;1:17: expected_comma&#xA;   {&#34;Hello&#34;:&#34;World&#34;x, &#34;color&#34;: &#34;red&#34;}&#xA;                   ^&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Denoting that x is invalid here.&lt;/p&gt; &#xA;&lt;h1&gt;Input Buffer (Null) Termination&lt;/h1&gt; &#xA;&lt;p&gt;A non-const &lt;code&gt;std::string&lt;/code&gt; is recommended for input buffers, as this allows Glaze to improve performance with temporary padding and the buffer will be null terminated.&lt;/p&gt; &#xA;&lt;h2&gt;JSON&lt;/h2&gt; &#xA;&lt;p&gt;By default the option &lt;code&gt;null_terminated&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; and null-terminated buffers must be used when parsing JSON. The option can be turned off with a small loss in performance, which allows non-null terminated buffers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr glz::opts options{.null_terminated = false};&#xA;auto ec = glz::read&amp;lt;options&amp;gt;(value, buffer); // read in a non-null terminated buffer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;BEVE&lt;/h2&gt; &#xA;&lt;p&gt;Null-termination is not required when parsing BEVE (binary). It makes no difference in performance.&lt;/p&gt; &#xA;&lt;h2&gt;CSV&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING]&lt;/p&gt; &#xA; &lt;p&gt;Currently, &lt;code&gt;null_terminated = false&lt;/code&gt; is not valid for CSV parsing and buffers must be null terminated.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Type Support&lt;/h1&gt; &#xA;&lt;h2&gt;Array Types&lt;/h2&gt; &#xA;&lt;p&gt;Array types logically convert to JSON array values. Concepts are used to allow various containers and even user containers if they match standard library interfaces.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;glz::array&lt;/code&gt; (compile time mixed types)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::tuple&lt;/code&gt; (compile time mixed types)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::array&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::vector&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::deque&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::list&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::forward_list&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::span&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::set&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unordered_set&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Object Types&lt;/h2&gt; &#xA;&lt;p&gt;Object types logically convert to JSON object values, such as maps. Like JSON, Glaze treats object definitions as unordered maps. Therefore the order of an object layout does not have to match the same binary sequence in C++.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;glz::object&lt;/code&gt; (compile time mixed types)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unordered_map&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::pair&lt;/code&gt; (enables dynamic keys in stack storage)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;std::pair&lt;/code&gt; is handled as an object with a single key and value, but when &lt;code&gt;std::pair&lt;/code&gt; is used in an array, Glaze concatenates the pairs into a single object. &lt;code&gt;std::vector&amp;lt;std::pair&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; will serialize as a single object. If you don&#39;t want this behavior set the compile time option &lt;code&gt;.concatenate = false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Variants&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;std::variant&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/variant-handling.md&#34;&gt;Variant Handling&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Nullable Types&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;std::optional&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Nullable types may be allocated by valid input or nullified by the &lt;code&gt;null&lt;/code&gt; keyword.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::unique_ptr&amp;lt;int&amp;gt; ptr{};&#xA;std::string buffer{};&#xA;expect(not glz::write_json(ptr, buffer));&#xA;expect(buffer == &#34;null&#34;);&#xA;&#xA;expect(not glz::read_json(ptr, &#34;5&#34;));&#xA;expect(*ptr == 5);&#xA;buffer.clear();&#xA;expect(not glz::write_json(ptr, buffer));&#xA;expect(buffer == &#34;5&#34;);&#xA;&#xA;expect(not glz::read_json(ptr, &#34;null&#34;));&#xA;expect(!bool(ptr));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Enums&lt;/h2&gt; &#xA;&lt;p&gt;By default enums will be written and read in integer form. No &lt;code&gt;glz::meta&lt;/code&gt; is necessary if this is the desired behavior.&lt;/p&gt; &#xA;&lt;p&gt;However, if you prefer to use enums as strings in JSON, they can be registered in the &lt;code&gt;glz::meta&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum class Color { Red, Green, Blue };&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;Color&amp;gt; {&#xA;   using enum Color;&#xA;   static constexpr auto value = enumerate(Red,&#xA;                                           Green,&#xA;                                           Blue&#xA;   );&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Color color = Color::Red;&#xA;std::string buffer{};&#xA;glz::write_json(color, buffer);&#xA;expect(buffer == &#34;\&#34;Red\&#34;&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;JSON With Comments (JSONC)&lt;/h1&gt; &#xA;&lt;p&gt;Comments are supported with the specification defined here: &lt;a href=&#34;https://github.com/stephenberry/JSONC&#34;&gt;JSONC&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Read support for comments is provided with &lt;code&gt;glz::read_jsonc&lt;/code&gt; or &lt;code&gt;glz::read&amp;lt;glz::opts{.comments = true}&amp;gt;(...)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Prettify JSON&lt;/h1&gt; &#xA;&lt;p&gt;Formatted JSON can be written out directly via a compile time option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto ec = glz::write&amp;lt;glz::opts{.prettify = true}&amp;gt;(obj, buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, JSON text can be formatted with the &lt;code&gt;glz::prettify_json&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string buffer = R&#34;({&#34;i&#34;:287,&#34;d&#34;:3.14,&#34;hello&#34;:&#34;Hello World&#34;,&#34;arr&#34;:[1,2,3]})&#34;);&#xA;auto beautiful = glz::prettify_json(buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;beautiful&lt;/code&gt; is now:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;   &#34;i&#34;: 287,&#xA;   &#34;d&#34;: 3.14,&#xA;   &#34;hello&#34;: &#34;Hello World&#34;,&#xA;   &#34;arr&#34;: [&#xA;      1,&#xA;      2,&#xA;      3&#xA;   ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Minify JSON&lt;/h1&gt; &#xA;&lt;p&gt;To write minified JSON:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto ec = glz::write_json(obj, buffer); // default is minified&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To minify JSON text call:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string minified = glz::minify_json(buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Minified JSON Reading&lt;/h2&gt; &#xA;&lt;p&gt;If you wish require minified JSON or know your input will always be minified, then you can gain a little more performance by using the compile time option &lt;code&gt;.minified = true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto ec = glz::read&amp;lt;glz::opts{.minified = true}&amp;gt;(obj, buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Boolean Flags&lt;/h2&gt; &#xA;&lt;p&gt;Glaze supports registering a set of boolean flags that behave as an array of string options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct flags_t {&#xA;   bool x{ true };&#xA;   bool y{};&#xA;   bool z{ true };&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;flags_t&amp;gt; {&#xA;   using T = flags_t;&#xA;   static constexpr auto value = flags(&#34;x&#34;, &amp;amp;T::x, &#34;y&#34;, &amp;amp;T::y, &#34;z&#34;, &amp;amp;T::z);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;flags_t s{};&#xA;expect(glz::write_json(s) == R&#34;([&#34;x&#34;,&#34;z&#34;])&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Only &lt;code&gt;&#34;x&#34;&lt;/code&gt; and &lt;code&gt;&#34;z&#34;&lt;/code&gt; are written out, because they are true. Reading in the buffer will set the appropriate booleans.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;When writing BEVE, &lt;code&gt;flags&lt;/code&gt; only use one bit per boolean (byte aligned).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Logging JSON&lt;/h2&gt; &#xA;&lt;p&gt;Sometimes you just want to write out JSON structures on the fly as efficiently as possible. Glaze provides tuple-like structures that allow you to stack allocate structures to write out JSON with high speed. These structures are named &lt;code&gt;glz::obj&lt;/code&gt; for objects and &lt;code&gt;glz::arr&lt;/code&gt; for arrays.&lt;/p&gt; &#xA;&lt;p&gt;Below is an example of building an object, which also contains an array, and writing it out.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto obj = glz::obj{&#34;pi&#34;, 3.14, &#34;happy&#34;, true, &#34;name&#34;, &#34;Stephen&#34;, &#34;arr&#34;, glz::arr{&#34;Hello&#34;, &#34;World&#34;, 2}};&#xA;&#xA;std::string s{};&#xA;expect(not glz::write_json(obj, s));&#xA;expect(s == R&#34;({&#34;pi&#34;:3.14,&#34;happy&#34;:true,&#34;name&#34;:&#34;Stephen&#34;,&#34;arr&#34;:[&#34;Hello&#34;,&#34;World&#34;,2]})&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;This approach is significantly faster than &lt;code&gt;glz::json_t&lt;/code&gt; for generic JSON. But, may not be suitable for all contexts.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Merge&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;glz::merge&lt;/code&gt; allows the user to merge multiple JSON object types into a single object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glz::obj o{&#34;pi&#34;, 3.141};&#xA;std::map&amp;lt;std::string_view, int&amp;gt; map = {{&#34;a&#34;, 1}, {&#34;b&#34;, 2}, {&#34;c&#34;, 3}};&#xA;auto merged = glz::merge{o, map};&#xA;std::string s{};&#xA;glz::write_json(merged, s); // will write out a single, merged object&#xA;// s is now: {&#34;pi&#34;:3.141,&#34;a&#34;:0,&#34;b&#34;:2,&#34;c&#34;:3}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;glz::merge&lt;/code&gt; stores references to lvalues to avoid copies&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Generic JSON&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/generic-json.md&#34;&gt;Generic JSON&lt;/a&gt; for &lt;code&gt;glz::json_t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;glz::json_t json{};&#xA;std::string buffer = R&#34;([5,&#34;Hello World&#34;,{&#34;pi&#34;:3.14}])&#34;;&#xA;glz::read_json(json, buffer);&#xA;assert(json[2][&#34;pi&#34;].get&amp;lt;double&amp;gt;() == 3.14);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Raw Buffer Performance&lt;/h2&gt; &#xA;&lt;p&gt;Glaze is just about as fast writing to a &lt;code&gt;std::string&lt;/code&gt; as it is writing to a raw char buffer. If you have sufficiently allocated space in your buffer you can write to the raw buffer, as shown below, but it is not recommended.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;glz::read_json(obj, buffer);&#xA;const auto n = glz::write_json(obj, buffer.data()).value_or(0);&#xA;buffer.resize(n);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compile Time Options&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;glz::opts&lt;/code&gt; struct defines compile time optional settings for reading/writing.&lt;/p&gt; &#xA;&lt;p&gt;Instead of calling &lt;code&gt;glz::read_json(...)&lt;/code&gt;, you can call &lt;code&gt;glz::read&amp;lt;glz::opts{}&amp;gt;(...)&lt;/code&gt; and customize the options.&lt;/p&gt; &#xA;&lt;p&gt;For example: &lt;code&gt;glz::read&amp;lt;glz::opts{.error_on_unknown_keys = false}&amp;gt;(...)&lt;/code&gt; will turn off erroring on unknown keys and simple skip the items.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;glz::opts&lt;/code&gt; can also switch between formats:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;glz::read&amp;lt;glz::opts{.format = glz::BEVE}&amp;gt;(...)&lt;/code&gt; -&amp;gt; &lt;code&gt;glz::read_beve(...)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;glz::read&amp;lt;glz::opts{.format = glz::JSON}&amp;gt;(...)&lt;/code&gt; -&amp;gt; &lt;code&gt;glz::read_json(...)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Available Compile Time Options&lt;/h2&gt; &#xA;&lt;p&gt;The struct below shows the available options and the default behavior.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct opts {&#xA;  uint32_t format = json;&#xA;  bool comments = false; // Support reading in JSONC style comments&#xA;  bool error_on_unknown_keys = true; // Error when an unknown key is encountered&#xA;  bool skip_null_members = true; // Skip writing out params in an object if the value is null&#xA;  bool use_hash_comparison = true; // Will replace some string equality checks with hash checks&#xA;  bool prettify = false; // Write out prettified JSON&#xA;  bool minified = false; // Require minified input for JSON, which results in faster read performance&#xA;  char indentation_char = &#39; &#39;; // Prettified JSON indentation char&#xA;  uint8_t indentation_width = 3; // Prettified JSON indentation size&#xA;  bool new_lines_in_arrays = true; // Whether prettified arrays should have new lines for each element&#xA;  bool shrink_to_fit = false; // Shrinks dynamic containers to new size to save memory&#xA;  bool write_type_info = true; // Write type info for meta objects in variants&#xA;  bool error_on_missing_keys = false; // Require all non nullable keys to be present in the object. Use&#xA;                                        // skip_null_members = false to require nullable members&#xA;  bool error_on_const_read =&#xA;     false; // Error if attempt is made to read into a const value, by default the value is skipped without error&#xA;  bool validate_skipped = false; // If full validation should be performed on skipped values&#xA;  bool validate_trailing_whitespace =&#xA;     false; // If, after parsing a value, we want to validate the trailing whitespace&#xA;&#xA;  uint8_t layout = rowwise; // CSV row wise output/input&#xA;&#xA;  // The maximum precision type used for writing floats, higher precision floats will be cast down to this precision&#xA;  float_precision float_max_write_precision{};&#xA;&#xA;  bool bools_as_numbers = false; // Read and write booleans with 1&#39;s and 0&#39;s&#xA;&#xA;  bool quoted_num = false; // treat numbers as quoted or array-like types as having quoted numbers&#xA;  bool number = false; // read numbers as strings and write these string as numbers&#xA;  bool raw = false; // write out string like values without quotes&#xA;  bool raw_string =&#xA;     false; // do not decode/encode escaped characters for strings (improves read/write performance)&#xA;  bool structs_as_arrays = false; // Handle structs (reading/writing) without keys, which applies&#xA;  bool allow_conversions = true; // Whether conversions between convertible types are&#xA;  // allowed in binary, e.g. double -&amp;gt; float&#xA;&#xA;  bool partial_read =&#xA;     false; // Reads into only existing fields and elements and then exits without parsing the rest of the input&#xA;&#xA;  // glaze_object_t concepts&#xA;  bool partial_read_nested = false; // Advance the partially read struct to the end of the struct&#xA;  bool concatenate = true; // Concatenates ranges of std::pair into single objects when writing&#xA;&#xA;  bool hide_non_invocable =&#xA;     true; // Hides non-invocable members from the cli_menu (may be applied elsewhere in the future)&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Many of these compile time options have wrappers to apply the option to only a single field. See &lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/wrappers.md&#34;&gt;Wrappers&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;JSON Conformance&lt;/h2&gt; &#xA;&lt;p&gt;By default Glaze is strictly conformant with the latest JSON standard except in two cases with associated options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;validate_skipped&lt;/code&gt; This option does full JSON validation for skipped values when parsing. This is not set by default because values are typically skipped when the user is unconcerned with them, and Glaze still validates for major issues. But, this makes skipping faster by not caring if the skipped values are exactly JSON conformant. For example, by default Glaze will ensure skipped numbers have all valid numerical characters, but it will not validate for issues like leading zeros in skipped numbers unless &lt;code&gt;validate_skipped&lt;/code&gt; is on. Wherever Glaze parses a value to be used it is fully validated.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;validate_trailing_whitespace&lt;/code&gt; This option validates the trailing whitespace in a parsed document. Because Glaze parses C++ structs, there is typically no need to continue parsing after the object of interest has been read. Turn on this option if you want to ensure that the rest of the document has valid whitespace, otherwise Glaze will just ignore the content after the content of interest has been parsed.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;/p&gt; &#xA; &lt;p&gt;Glaze does not automatically unicode escape control characters (e.g. &lt;code&gt;&#34;\x1f&#34;&lt;/code&gt; to &lt;code&gt;&#34;\u001f&#34;&lt;/code&gt;), as this poses a risk of embedding null characters and other invisible characters in strings. A compile time option will be added to enable these conversions (open issue: &lt;a href=&#34;https://github.com/stephenberry/glaze/issues/812&#34;&gt;unicode escaped write&lt;/a&gt;), but it will not be the default behavior.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Skip&lt;/h2&gt; &#xA;&lt;p&gt;It can be useful to acknowledge a keys existence in an object to prevent errors, and yet the value may not be needed or exist in C++. These cases are handled by registering a &lt;code&gt;glz::skip&lt;/code&gt; type with the meta data.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;See example:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct S {&#xA;  int i{};&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;S&amp;gt; {&#xA;  static constexpr auto value = object(&#34;key_to_skip&#34;, skip{}, &amp;amp;S::i);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string buffer = R&#34;({&#34;key_to_skip&#34;: [1,2,3], &#34;i&#34;: 7})&#34;;&#xA;S s{};&#xA;glz::read_json(s, buffer);&#xA;// The value [1,2,3] will be skipped&#xA;expect(s.i == 7); // only the value i will be read into&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Hide&lt;/h2&gt; &#xA;&lt;p&gt;Glaze is designed to help with building generic APIs. Sometimes a value needs to be exposed to the API, but it is not desirable to read in or write out the value in JSON. This is the use case for &lt;code&gt;glz::hide&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;glz::hide&lt;/code&gt; hides the value from JSON output while still allowing API (and JSON pointer) access.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;See example:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct hide_struct {&#xA;  int i = 287;&#xA;  double d = 3.14;&#xA;  std::string hello = &#34;Hello World&#34;;&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;hide_struct&amp;gt; {&#xA;   using T = hide_struct;&#xA;   static constexpr auto value = object(&amp;amp;T::i,  //&#xA;                                        &amp;amp;T::d, //&#xA;                                        &#34;hello&#34;, hide{&amp;amp;T::hello});&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;hide_struct s{};&#xA;auto b = glz::write_json(s);&#xA;expect(b == R&#34;({&#34;i&#34;:287,&#34;d&#34;:3.14})&#34;); // notice that &#34;hello&#34; is hidden from the output&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Quoted Numbers&lt;/h2&gt; &#xA;&lt;p&gt;You can parse quoted JSON numbers directly to types like &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, etc. by utilizing the &lt;code&gt;glz::quoted&lt;/code&gt; wrapper.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct A {&#xA;   double x;&#xA;   std::vector&amp;lt;uint32_t&amp;gt; y;&#xA;};&#xA;&#xA;template &amp;lt;&amp;gt;&#xA;struct glz::meta&amp;lt;A&amp;gt; {&#xA;   static constexpr auto value = object(&#34;x&#34;, glz::quoted_num&amp;lt;&amp;amp;A::x&amp;gt;, &#34;y&#34;, glz::quoted_num&amp;lt;&amp;amp;A::y&amp;gt;;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;x&#34;: &#34;3.14&#34;,&#xA;  &#34;y&#34;: [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The quoted JSON numbers will be parsed directly into the &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;std::vector&amp;lt;uint32_t&amp;gt;&lt;/code&gt;. The &lt;code&gt;glz::quoted&lt;/code&gt; function works for nested objects and arrays as well.&lt;/p&gt; &#xA;&lt;h2&gt;JSON Lines (NDJSON) Support&lt;/h2&gt; &#xA;&lt;p&gt;Glaze supports &lt;a href=&#34;https://jsonlines.org&#34;&gt;JSON Lines&lt;/a&gt; (or Newline Delimited JSON) for array-like types (e.g. &lt;code&gt;std::vector&lt;/code&gt; and &lt;code&gt;std::tuple&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;std::string&amp;gt; x = { &#34;Hello&#34;, &#34;World&#34;, &#34;Ice&#34;, &#34;Cream&#34; };&#xA;std::string s = glz::write_ndjson(x).value_or(&#34;error&#34;);&#xA;auto ec = glz::read_ndjson(x, s);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;More Features&lt;/h1&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/recorder.md&#34;&gt;Data Recorder&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/cli-menu.md&#34;&gt;Command Line Interface Menu&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/json-include.md&#34;&gt;JSON Include System&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/json-pointer-syntax.md&#34;&gt;JSON Pointer Syntax&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/rpc/json-rpc.md&#34;&gt;JSON-RPC 2.0&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/json-schema.md&#34;&gt;JSON Schema&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/glaze-interfaces.md&#34;&gt;Shared Library API&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/binary.md&#34;&gt;Tagged Binary Messages&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/thread-pool.md&#34;&gt;Thread Pool&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/time-trace.md&#34;&gt;Time Trace Profiling&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Output performance profiles to JSON and visualize using &lt;a href=&#34;https://ui.perfetto.dev&#34;&gt;Perfetto&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/wrappers.md&#34;&gt;Wrappers&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;h1&gt;Extensions&lt;/h1&gt; &#xA;&lt;p&gt;See the &lt;code&gt;ext&lt;/code&gt; directory for extensions.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gitlab.com/libeigen/eigen&#34;&gt;Eigen&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/rpc/json-rpc.md&#34;&gt;JSON-RPC 2.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/stephenberry/glaze/main/docs/cli-menu.md&#34;&gt;Command Line Interface Menu (cli_menu)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Glaze is distributed under the MIT license with an exception for embedded forms:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;--- Optional exception to the license ---&lt;/p&gt; &#xA; &lt;p&gt;As an exception, if, as a result of your compiling your source code, portions of this Software are embedded into a machine-executable object form of such source code, you may redistribute such embedded portions in such object form without including the copyright and permission notices.&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
</feed>