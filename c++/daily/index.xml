<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-08-16T01:32:35Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OneLoneCoder/olcPixelGameEngine</title>
    <updated>2022-08-16T01:32:35Z</updated>
    <id>tag:github.com,2022-08-16:/OneLoneCoder/olcPixelGameEngine</id>
    <link href="https://github.com/OneLoneCoder/olcPixelGameEngine" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The official distribution of olcPixelGameEngine, a tool used in javidx9&#39;s YouTube videos and projects&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://discord.gg/WhwHUMV&#34;&gt; &lt;img src=&#34;https://img.shields.io/discord/380484403458998276?logo=discord&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h1&gt;olcPixelGameEngine&lt;/h1&gt; &#xA;&lt;p&gt;The official distribution of olcPixelGameEngine, a tool used in javidx9&#39;s YouTube videos and projects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;You only need the one file - olcPixelGameEngine.h - included in your project!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Provides a fast, richly featured, cross platform pixel drawing and user interface framework for&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The development of games&lt;/li&gt; &#xA; &lt;li&gt;Visualisation of algorithms&lt;/li&gt; &#xA; &lt;li&gt;Prototyping and experimentation&lt;/li&gt; &#xA; &lt;li&gt;Education&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;olcPixelGameEngine is easily extended! for example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2D Affine transforms&lt;/li&gt; &#xA; &lt;li&gt;3D Software renderer&lt;/li&gt; &#xA; &lt;li&gt;Controller input&lt;/li&gt; &#xA; &lt;li&gt;Sound&lt;/li&gt; &#xA; &lt;li&gt;Hardware interfaces&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;olcPixelGameEngine is easy to port! Runs on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Windows (all)&lt;/li&gt; &#xA; &lt;li&gt;Linux / Raspberry Pi / ChromeOS&lt;/li&gt; &#xA; &lt;li&gt;MacOS (coming soon to official, but already available in &#34;Contributors&#34;)&lt;/li&gt; &#xA; &lt;li&gt;PSP &amp;amp; Switch (Not supported by OneLoneCoder)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;olcPixelGameEngine has been reimplemented in other languages!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;C#&lt;/li&gt; &#xA; &lt;li&gt;Rust&lt;/li&gt; &#xA; &lt;li&gt;Lua&lt;/li&gt; &#xA; &lt;li&gt;Java&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;olcPixelGameEngine is actively maintained and developed!&lt;/p&gt; &#xA;&lt;p&gt;olcPixelGameEngine is used by 100s, if not 1000s of programmers at all levels of ability!&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/OneLoneCoder/olcPixelGameEngine/wiki&#34;&gt;https://github.com/OneLoneCoder/olcPixelGameEngine/wiki&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;License (OLC-3)&lt;/h1&gt; &#xA;&lt;p&gt;Copyright 2018, 2019, 2020, 2021 OneLoneCoder.com&lt;/p&gt; &#xA;&lt;p&gt;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Redistributions or derivations of source code must retain the above copyright notice, this list of conditions and the following disclaimer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Redistributions or derivative works in binary form must reproduce the above copyright notice. This list of conditions and the following disclaimer must be reproduced in the documentation and/or other materials provided with the distribution.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kimci86/bkcrack</title>
    <updated>2022-08-16T01:32:35Z</updated>
    <id>tag:github.com,2022-08-16:/kimci86/bkcrack</id>
    <link href="https://github.com/kimci86/bkcrack" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Crack legacy zip encryption with Biham and Kocher&#39;s known plaintext attack.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;bkcrack&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kimci86/bkcrack/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/kimci86/bkcrack/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/kimci86/bkcrack/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/kimci86/bkcrack&#34; alt=&#34;release badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/kimci86/bkcrack/master/license.txt&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/kimci86/bkcrack?color=informational&#34; alt=&#34;license badge&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Crack legacy zip encryption with Biham and Kocher&#39;s known plaintext attack.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;A ZIP archive may contain many entries whose content can be compressed and/or encrypted. In particular, entries can be encrypted with a password-based symmetric encryption algorithm referred to as traditional PKWARE encryption, legacy encryption or ZipCrypto. This algorithm generates a pseudo-random stream of bytes (keystream) which is XORed to the entry&#39;s content (plaintext) to produce encrypted data (ciphertext). The generator&#39;s state, made of three 32-bits integers, is initialized using the password and then continuously updated with plaintext as encryption goes on. This encryption algorithm is vulnerable to known plaintext attacks as shown by Eli Biham and Paul C. Kocher in the research paper &lt;a href=&#34;https://doi.org/10.1007/3-540-60590-8_12&#34;&gt;A known plaintext attack on the PKZIP stream cipher&lt;/a&gt;. Given ciphertext and 12 or more bytes of the corresponding plaintext, the internal state of the keystream generator can be recovered. This internal state is enough to decipher ciphertext entirely as well as other entries which were encrypted with the same password. It can also be used to bruteforce the password with a complexity of &lt;em&gt;n&lt;sup&gt;l-6&lt;/sup&gt;&lt;/em&gt; where &lt;em&gt;n&lt;/em&gt; is the size of the character set and &lt;em&gt;l&lt;/em&gt; is the length of the password.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;bkcrack&lt;/strong&gt; is a command-line tool which implements this known plaintext attack. The main features are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Recover internal state from ciphertext and plaintext.&lt;/li&gt; &#xA; &lt;li&gt;Change a ZIP archive&#39;s password using the internal state.&lt;/li&gt; &#xA; &lt;li&gt;Recover the original password from the internal state.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;h3&gt;Precompiled packages&lt;/h3&gt; &#xA;&lt;p&gt;You can get the latest official release on &lt;a href=&#34;https://github.com/kimci86/bkcrack/releases&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Precompiled packages for Ubuntu, MacOS and Windows are available for download. Extract the downloaded archive wherever you like.&lt;/p&gt; &#xA;&lt;p&gt;On Windows, Microsoft runtime libraries are needed for bkcrack to run. If they are not already installed on your system, download and install the latest Microsoft Visual C++ Redistributable package.&lt;/p&gt; &#xA;&lt;h3&gt;Compile from source&lt;/h3&gt; &#xA;&lt;p&gt;Alternatively, you can compile the project with &lt;a href=&#34;https://cmake.org&#34;&gt;CMake&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;First, download the source files or clone the git repository. Then, running the following commands in the source tree will create an installation in the &lt;code&gt;install&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install&#xA;cmake --build build --config Release&#xA;cmake --build build --config Release --target install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Thrid-party packages&lt;/h3&gt; &#xA;&lt;a href=&#34;https://repology.org/project/bkcrack/versions&#34;&gt; &lt;img src=&#34;https://repology.org/badge/vertical-allrepos/bkcrack.svg?sanitize=true&#34; alt=&#34;Packaging status&#34; align=&#34;right&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;bkcrack is available in the package repositories listed on the right. Those packages are provided by external maintainers.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;List entries&lt;/h3&gt; &#xA;&lt;p&gt;You can see a list of entry names and metadata in an archive named &lt;code&gt;archive.zip&lt;/code&gt; like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -L archive.zip&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Entries using ZipCrypto encryption are vulnerable to a known-plaintext attack.&lt;/p&gt; &#xA;&lt;h3&gt;Recover internal keys&lt;/h3&gt; &#xA;&lt;p&gt;The attack requires at least 12 bytes of known plaintext. At least 8 of them must be contiguous. The larger the contiguous known plaintext, the faster the attack.&lt;/p&gt; &#xA;&lt;h4&gt;Load data from zip archives&lt;/h4&gt; &#xA;&lt;p&gt;Having a zip archive &lt;code&gt;encrypted.zip&lt;/code&gt; with the entry &lt;code&gt;cipher&lt;/code&gt; being the ciphertext and &lt;code&gt;plain.zip&lt;/code&gt; with the entry &lt;code&gt;plain&lt;/code&gt; as the known plaintext, bkcrack can be run like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -C encrypted.zip -c cipher -P plain.zip -p plain&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Load data from files&lt;/h4&gt; &#xA;&lt;p&gt;Having a file &lt;code&gt;cipherfile&lt;/code&gt; with the ciphertext (starting with the 12 bytes corresponding to the encryption header) and &lt;code&gt;plainfile&lt;/code&gt; with the known plaintext, bkcrack can be run like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -c cipherfile -p plainfile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Offset&lt;/h4&gt; &#xA;&lt;p&gt;If the plaintext corresponds to a part other than the beginning of the ciphertext, you can specify an offset. It can be negative if the plaintext includes a part of the encryption header.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -c cipherfile -p plainfile -o offset&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Sparse plaintext&lt;/h4&gt; &#xA;&lt;p&gt;If you know little contiguous plaintext (between 8 and 11 bytes), but know some bytes at some other known offsets, you can provide this information to reach the requirement of a total of 12 known bytes. To do so, use the &lt;code&gt;-x&lt;/code&gt; flag followed by an offset and bytes in hexadecimal.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -c cipherfile -p plainfile -x 25 4b4f -x 30 21&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Number of threads&lt;/h4&gt; &#xA;&lt;p&gt;If bkcrack was built with parallel mode enabled, the number of threads used can be set through the environment variable &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Decipher&lt;/h3&gt; &#xA;&lt;p&gt;If the attack is successful, the deciphered data associated to the ciphertext used for the attack can be saved:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -c cipherfile -p plainfile -d decipheredfile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the keys are known from a previous attack, it is possible to use bkcrack to decipher data:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -c cipherfile -k 12345678 23456789 34567890 -d decipheredfile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Decompress&lt;/h4&gt; &#xA;&lt;p&gt;The deciphered data might be compressed depending on whether compression was used or not when the zip file was created. If deflate compression was used, a Python 3 script provided in the &lt;code&gt;tools&lt;/code&gt; folder may be used to decompress data.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 tools/inflate.py &amp;lt; decipheredfile &amp;gt; decompressedfile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unlock encrypted archive&lt;/h3&gt; &#xA;&lt;p&gt;It is also possible to generate a new encrypted archive with the password of your choice:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -C encrypted.zip -k 12345678 23456789 34567890 -U unlocked.zip password&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The archive generated this way can be extracted using any zip file utility with the new password. It assumes that every entry was originally encrypted with the same password.&lt;/p&gt; &#xA;&lt;h3&gt;Recover password&lt;/h3&gt; &#xA;&lt;p&gt;Given the internal keys, bkcrack can try to find the original password up to a given length:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bkcrack -k 1ded830c 24454157 7213b8c5 -r 10 ?p&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Learn&lt;/h2&gt; &#xA;&lt;p&gt;A tutorial is provided in the &lt;code&gt;example&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;p&gt;For more information, have a look at the documentation and read the source.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Do not hesitate to suggest improvements or submit pull requests on &lt;a href=&#34;https://github.com/kimci86/bkcrack&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is provided under the terms of the &lt;a href=&#34;http://opensource.org/licenses/Zlib&#34;&gt;zlib/png license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>NVIDIA/cutlass</title>
    <updated>2022-08-16T01:32:35Z</updated>
    <id>tag:github.com,2022-08-16:/NVIDIA/cutlass</id>
    <link href="https://github.com/NVIDIA/cutlass" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CUDA Templates for Linear Algebra Subroutines&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/images/gemm-hierarchy-with-epilogue-no-labels.png&#34; alt=&#34;ALT&#34; title=&#34;Complete CUDA GEMM decomposition&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;CUTLASS 2.9&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;CUTLASS 2.9 - April 2022&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS is a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA. It incorporates strategies for hierarchical decomposition and data movement similar to those used to implement cuBLAS and cuDNN. CUTLASS decomposes these &#34;moving parts&#34; into reusable, modular software components abstracted by C++ template classes. These thread-wide, warp-wide, block-wide, and device-wide primitives can be specialized and tuned via custom tiling sizes, data types, and other algorithmic policy. The resulting flexibility simplifies their use as building blocks within custom kernels and applications.&lt;/p&gt; &#xA;&lt;p&gt;To support a wide variety of applications, CUTLASS provides extensive support for mixed-precision computations, providing specialized data-movement and multiply-accumulate abstractions for half-precision floating point (FP16), BFloat16 (BF16), Tensor Float 32 (TF32), single-precision floating point (FP32), double-precision floating point (FP64) types, integer data types (4b and 8b), and binary data types (1b). CUTLASS demonstrates warp-synchronous matrix multiply operations targeting the programmable, high-throughput &lt;em&gt;Tensor Cores&lt;/em&gt; implemented by NVIDIA&#39;s Volta, Turing, and Ampere architectures.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS implements high-performance Convolution via the implicit GEMM algorithm. Implicit GEMM is the formulation of a convolution operation as a GEMM thereby taking advantage of CUTLASS&#39;s modular GEMM pipeline. This allows CUTLASS to build convolutions by reusing highly optimized warp-wide GEMM components and below.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/quickstart.md&#34;&gt;Quick Start Guide&lt;/a&gt; to get started quickly.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/functionality.md&#34;&gt;functionality listing&lt;/a&gt; for the list of operations supported at each level of the execution model hierarchy.&lt;/p&gt; &#xA;&lt;h1&gt;What&#39;s New in CUTLASS 2.9&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS 2.9 is an update to CUTLASS adding:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/conv/device/conv2d_fprop_fixed_channels_f16nhwc_f16nhwc_f16nhwc_tensor_op_f32_sm80.cu&#34;&gt;First layer Convolution kernels&lt;/a&gt; specialized for small channel counts and reduced alignment&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.nvidia.com/cuda/cublas/index.html#cublas-level-3-function-reference&#34;&gt;BLAS3&lt;/a&gt; operators accelerated by Tensor Cores &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/syrk_f32n_f32t_tensor_op_fast_f32_sm80.cu&#34;&gt;SYRK&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/herk_cf32h_cf32n_tensor_op_fast_f32_sm80.cu&#34;&gt;HERK&lt;/a&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/syr2k_f32n_f32n_tensor_op_fast_f32_sm80.cu&#34;&gt;SYR2K&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/her2k_cf32h_cf32n_tensor_op_fast_f32_sm80.cu&#34;&gt;HER2K&lt;/a&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/trmm_f32n_f32t_f32t_tensor_op_fast_f32_ls_sm80.cu&#34;&gt;Out-of-place TRMM&lt;/a&gt;, and&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/symm_f32n_f32n_tensor_op_fast_f32_ls_sm80.cu&#34;&gt;SYMM&lt;/a&gt;, &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/test/unit/gemm/device/hemm_cf32h_cf32n_tensor_op_fast_f32_ls_sm80.cu&#34;&gt;HEMM&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples/40_cutlass_py&#34;&gt;CUTLASS Python&lt;/a&gt; demonstrating JIT compilation of CUTLASS kernels and a Python-based runtime using &lt;a href=&#34;https://developer.nvidia.com/cuda-python&#34;&gt;CUDA Python&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples/35_gemm_softmax&#34;&gt;GEMM + Softmax example&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples/36_gather_scatter_fusion&#34;&gt;Gather and Scatter Fusion with GEMM&lt;/a&gt; can gather inputs and scatters outputs based on indices vectors in the same GEMM kernel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples/13_two_tensor_op_fusion&#34;&gt;Back-to-back GEMM/CONV&lt;/a&gt; fully supports buffering the first GEMM/CONV results in the shared memory for the latter one to use. Bias Vector add is also supported in the first GEMM/CONV.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples/34_transposed_conv2d&#34;&gt;Transposed Convolution&lt;/a&gt; (a.k.a Deconvolution) support which reuses Dgrad implementation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/tools/util/include/cutlass/util&#34;&gt;Utility functions&lt;/a&gt; that can pad NHWC and convert between NCHW and NHWC.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/NVIDIA/cutlass/issues/242&#34;&gt;Small alignment implicit gemm&lt;/a&gt; support for Fprop/Dgrad/Wgrad so that padding is no longer mandated to use tensor cores.&lt;/li&gt; &#xA; &lt;li&gt;Epilogue enhancement with performance improvement, more activation functions, and more fusion patterns.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples/24_gemm_grouped&#34;&gt;Group GEMM&lt;/a&gt; thread block number calculation fix.&lt;/li&gt; &#xA; &lt;li&gt;Optimal performance using &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 11.7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/NVIDIA/cutlass/pull/277&#34;&gt;Parallel GEMM splitk&lt;/a&gt; support in the CUTLASS profiler.&lt;/li&gt; &#xA; &lt;li&gt;Updates and bugfixes from the community (thanks!)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Deprecation announcement:&lt;/strong&gt; CUTLASS plans to deprecate the following: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Maxwell and Pascal GPU architectures&lt;/li&gt; &#xA;   &lt;li&gt;Ubuntu 16.04&lt;/li&gt; &#xA;   &lt;li&gt;CUDA 10.2&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt; for a detailed listing of releases and updates.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/images/cutlass-2.8-gemm-performance.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS primitives are very efficient. When used to construct device-wide GEMM kernels, they exhibit performance comparable to cuBLAS for scalar GEMM computations. The above figure shows CUTLASS performance relative to cuBLAS for large matrix dimensions on an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/a100/&#34;&gt;NVIDIA A100&lt;/a&gt;, an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/products/a2/&#34;&gt;NVIDIA A2&lt;/a&gt;, an &lt;a href=&#34;https://www.nvidia.com/en-us/titan/titan-v/&#34;&gt;NVIDIA TitanV&lt;/a&gt;, and an &lt;a href=&#34;https://www.nvidia.com/en-us/geforce/graphics-cards/rtx-2080-ti/&#34;&gt;NVIDIA GeForce 2080 Ti&lt;/a&gt; compiled with the &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 11.5 Toolkit&lt;/a&gt;. Tensor Core operations are implemented using CUDA&#39;s &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma&#34;&gt;mma instruction&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/images/cutlass-2.9-implicit-gemm-performance.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;When using CUTLASS building blocks to construct device-wide implicit gemm (Fprop, Dgrad, and Wgrad) kernels, CUTLASS performance is also comparable to cuDNN when running Resnet-50 layers on an &lt;a href=&#34;https://www.nvidia.com/en-us/data-center/a100/&#34;&gt;NVIDIA A100&lt;/a&gt; as shown in the above figure. Tensor Core operations are still implemented using CUDA&#39;s &lt;a href=&#34;https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma&#34;&gt;mma instruction&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS requires a C++11 host compiler and performs best when built with the &lt;a href=&#34;https://developer.nvidia.com/cuda-toolkit&#34;&gt;&lt;strong&gt;CUDA 11.6u2 Toolkit&lt;/strong&gt;&lt;/a&gt;. It is also compatible with CUDA 11.0, CUDA 11.1, CUDA 11.2, CUDA 11.3, CUDA 11.4, and CUDA 11.5.&lt;/p&gt; &#xA;&lt;p&gt;We have tested the following environments.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Operating System&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Compiler&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Windows 10&lt;/td&gt; &#xA;   &lt;td&gt;Microsoft Visual Studio 2015&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Microsoft Visual Studio 2017&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Microsoft Visual Studio 2019&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 18.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 7.5.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 20.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 10.3.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Ubuntu 21.04&lt;/td&gt; &#xA;   &lt;td&gt;GCC 11.2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Additionally, CUTLASS may be built with clang. See &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/quickstart.md#clang&#34;&gt;these instructions&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS runs successfully on the following NVIDIA GPUs, and it is expected to be efficient on any Volta-, Turing-, or NVIDIA Ampere- architecture NVIDIA GPU.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;GPU&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;CUDA Compute Capability&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Minimum CUDA Toolkit&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Minimum CUDA Toolkit Enabling Native Tensor Cores&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA Tesla V100&lt;/td&gt; &#xA;   &lt;td&gt;7.0&lt;/td&gt; &#xA;   &lt;td&gt;9.2&lt;/td&gt; &#xA;   &lt;td&gt;10.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA TitanV&lt;/td&gt; &#xA;   &lt;td&gt;7.0&lt;/td&gt; &#xA;   &lt;td&gt;9.2&lt;/td&gt; &#xA;   &lt;td&gt;10.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce RTX 2080 TI, 2080, 2070&lt;/td&gt; &#xA;   &lt;td&gt;7.5&lt;/td&gt; &#xA;   &lt;td&gt;10.0&lt;/td&gt; &#xA;   &lt;td&gt;10.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA Tesla T4&lt;/td&gt; &#xA;   &lt;td&gt;7.5&lt;/td&gt; &#xA;   &lt;td&gt;10.0&lt;/td&gt; &#xA;   &lt;td&gt;10.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA A100&lt;/td&gt; &#xA;   &lt;td&gt;8.0&lt;/td&gt; &#xA;   &lt;td&gt;11.0&lt;/td&gt; &#xA;   &lt;td&gt;11.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA A10&lt;/td&gt; &#xA;   &lt;td&gt;8.6&lt;/td&gt; &#xA;   &lt;td&gt;11.1&lt;/td&gt; &#xA;   &lt;td&gt;11.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;NVIDIA GeForce 3090&lt;/td&gt; &#xA;   &lt;td&gt;8.6&lt;/td&gt; &#xA;   &lt;td&gt;11.1&lt;/td&gt; &#xA;   &lt;td&gt;11.1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For all GPUs, we recommend compiling with the &lt;a href=&#34;https://developer.nvidia.com/cuda-toolkit&#34;&gt;CUDA 11.6u2 Toolkit&lt;/a&gt; for best performance.&lt;/p&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is described in the following documents and the accompanying &lt;a href=&#34;https://nvidia.github.io/cutlass&#34;&gt;Doxygen documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/quickstart.md&#34;&gt;Quick Start Guide&lt;/a&gt; - build and run CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/functionality.md&#34;&gt;Functionality&lt;/a&gt; - summarizes functionality available in CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/efficient_gemm.md&#34;&gt;Efficient GEMM in CUDA&lt;/a&gt; - describes how GEMM kernels may be implemented efficiently in CUDA&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/gemm_api.md&#34;&gt;GEMM API&lt;/a&gt; - describes the CUTLASS GEMM model and C++ template concepts&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/implicit_gemm_convolution.md&#34;&gt;Implicit GEMM Convolution&lt;/a&gt; - describes 2-D and 3-D convolution in CUTLASS&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/code_organization.md&#34;&gt;Code Organization&lt;/a&gt; - describes the organization and contents of the CUTLASS project&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/terminology.md&#34;&gt;Terminology&lt;/a&gt; - describes terms used in the code&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/programming_guidelines.md&#34;&gt;Programming Guidelines&lt;/a&gt; - guidelines for writing efficient modern CUDA C++&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/fundamental_types.md&#34;&gt;Fundamental types&lt;/a&gt; - describes basic C++ classes used in CUTLASS to represent numeric quantities and arrays&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/layout.md&#34;&gt;Layouts&lt;/a&gt; - describes layouts of matrices and tensors in memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/tile_iterator_concept.md&#34;&gt;Tile Iterators&lt;/a&gt; - describes C++ concepts for iterating over tiles of matrices in memory&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/profiler.md&#34;&gt;CUTLASS Profiler&lt;/a&gt; - command-line driven profiling application&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/utilities.md&#34;&gt;CUTLASS Utilities&lt;/a&gt; - additional templates used to facilate rapid development&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have also described the structure of an efficient GEMM in our talk at the &lt;a href=&#34;http://on-demand.gputechconf.com/gtc/2018/presentation/s8854-cutlass-software-primitives-for-dense-linear-algebra-at-all-levels-and-scales-within-cuda.pdf&#34;&gt;GPU Technology Conference 2018&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Building CUTLASS&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is a header-only template library and does not need to be built to be used by other projects. Client applications should target CUTLASS&#39;s &lt;code&gt;include/&lt;/code&gt; directory in their include paths.&lt;/p&gt; &#xA;&lt;p&gt;CUTLASS unit tests, examples, and utilities can be build with CMake starting version 3.12. Make sure the &lt;code&gt;CUDACXX&lt;/code&gt; environment variable points to NVCC in the CUDA Toolkit installed on your system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export CUDACXX=${CUDA_INSTALL_PATH}/bin/nvcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a build directory within the CUTLASS project, then run CMake. By default CUTLASS will build kernels for CUDA architecture versions 5.0, 6.0, 6.1, 7.0, 7.5, 8.0, and 8.6. To reduce compile time you can specify the architectures to build CUTLASS for by changing the CMake configuration setting &lt;code&gt;CUTLASS_NVCC_ARCHS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir build &amp;amp;&amp;amp; cd build&#xA;&#xA;$ cmake .. -DCUTLASS_NVCC_ARCHS=80               # compiles for NVIDIA&#39;s Ampere Architecture&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From the &lt;code&gt;build/&lt;/code&gt; directory, compile and run the CUTLASS unit tests by building the target &lt;code&gt;test_unit&lt;/code&gt; with make.&lt;/p&gt; &#xA;&lt;p&gt;The unit tests are organized as several binaries mirroring the top-level namespaces of CUTLASS, and they may be executed in parallel via make&#39;s &lt;code&gt;-j&lt;/code&gt; command line argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make test_unit -j&#xA;...&#xA;...&#xA;...&#xA;[----------] Global test environment tear-down&#xA;[==========] 946 tests from 57 test cases ran. (10812 ms total)&#xA;[  PASSED  ] 946 tests.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All tests should pass on supported platforms, though the exact number of tests may vary over time.&lt;/p&gt; &#xA;&lt;h1&gt;Project Structure&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is arranged as a header-only library along with Utilities, Tools, Examples, and unit tests. &lt;a href=&#34;https://nvidia.github.io/cutlass&#34;&gt;Doxygen documentation&lt;/a&gt; provides a complete list of files, classes, and template concepts defined in the CUTLASS project.&lt;/p&gt; &#xA;&lt;p&gt;A detailed explanation of the source code organization may be found in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/code_organization.md&#34;&gt;CUTLASS documentation&lt;/a&gt;, but several main components are summarized below.&lt;/p&gt; &#xA;&lt;h2&gt;CUTLASS Template Library&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;include/                     # client applications should target this directory in their build&#39;s include paths&#xA;&#xA;  cutlass/                   # CUDA Templates for Linear Algebra Subroutines and Solvers - headers only&#xA;&#xA;    arch/                    # direct exposure of architecture features (including instruction-level GEMMs)&#xA;&#xA;    conv/                    # code specialized for convolution&#xA;&#xA;    gemm/                    # code specialized for general matrix product computations&#xA;&#xA;    layout/                  # layout definitions for matrices, tensors, and other mathematical objects in memory&#xA;&#xA;    platform/                # CUDA-capable Standard Library components&#xA;&#xA;    reduction/               # bandwidth-limited reduction kernels that do not fit the &#34;gemm&#34; model&#xA;    &#xA;    transform/               # code specialized for layout, type, and domain transformations&#xA;&#xA;    *                        # core vocabulary types, containers, and basic numeric operations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CUTLASS SDK Examples&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/examples&#34;&gt;CUTLASS SDK examples&lt;/a&gt; apply CUTLASS templates to implement basic computations.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;examples/&#xA;  00_basic_gemm/                   # launches a basic GEMM with single precision inputs and outputs&#xA;&#xA;  01_cutlass_utilities/            # demonstrates CUTLASS Utilities for allocating and initializing tensors&#xA;  &#xA;  02_dump_reg_smem/                # debugging utilities for printing register and shared memory contents&#xA;  &#xA;  03_visualize_layout/             # utility for visualizing all layout functions in CUTLASS&#xA;&#xA;  04_tile_iterator/                # example demonstrating an iterator over tiles in memory&#xA;&#xA;  05_batched_gemm/                 # example demonstrating CUTLASS&#39;s batched strided GEMM operation&#xA;&#xA;  06_splitK_gemm/                  # exmaple demonstrating CUTLASS&#39;s Split-K parallel reduction kernel&#xA;&#xA;  07_volta_tensorop_gemm/          # example demonstrating mixed precision GEMM using Volta Tensor Cores&#xA;&#xA;  08_turing_tensorop_gemm/         # example demonstrating integer GEMM using Turing Tensor Cores&#xA;&#xA;  09_turing_tensorop_conv2dfprop/  # example demonstrating integer implicit GEMM convolution (forward propagation) using Turing Tensor Cores&#xA;&#xA;  10_planar_complex/               # example demonstrating planar complex GEMM kernels&#xA;&#xA;  11_planar_complex_array/         # example demonstrating planar complex kernels with batch-specific problem sizes&#xA;&#xA;  12_gemm_bias_relu/               # example demonstrating GEMM fused with bias and relu&#xA;&#xA;  13_fused_two_gemms/              # example demonstrating two GEMms fused in one kernel&#xA;&#xA;  22_ampere_tensorop_conv2dfprop/  # example demonstrating integer implicit GEMM convolution (forward propagation) using Ampere Tensor Cores&#xA;&#xA;  31_basic_syrk                    # example demonstrating Symetric rank-K update&#xA;&#xA;  32_basic_trmm                    #&#xA;&#xA;  33_ampere_3xtf32_tensorop_symm   #&#xA;&#xA;  35_gemm_softmax                  # example demonstrating GEMM fused with Softmax in mixed precision using Ampere Tensor Cores&#xA;&#xA;  40_cutlass_py                    # example demonstrating CUTLASS with CUDA Python&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Tools&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;tools/&#xA;  library/                   # CUTLASS Instance Library - contains instantiations of all supported CUTLASS templates&#xA;    include/&#xA;      cutlass/&#xA;        library/&#xA;&#xA;  profiler/                  # CUTLASS Profiler         - command-line utility for executing operations in the&#xA;                             #                            CUTLASS Library&#xA;  &#xA;  util/                      # CUTLASS Utilities        - contains numerous helper classes for&#xA;    include/                 #                            manging tensors in device memory, reference&#xA;      cutlass/               #                            implementations for GEMM, random initialization&#xA;        util/                #                            of tensors, and I/O.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;test/unit/&lt;/code&gt; directory consist of unit tests implemented with Google Test that demonstrate basic usage of Core API components and complete tests of the CUTLASS GEMM computations.&lt;/p&gt; &#xA;&lt;p&gt;Instructions for building and running the Unit tests are described in the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/quickstart.md&#34;&gt;Quickstart guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Performance Profiling&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;code&gt;tools/profiler/&lt;/code&gt; directory contains a command-line utility for launching each of the GEMM kernels. It can be built as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building all GEMM and Convolution kernels (&lt;em&gt;long&lt;/em&gt; build times)&lt;/h2&gt; &#xA;&lt;p&gt;By default, only one tile size is instantiated for each data type, math instruction, and layout. To instantiate all, set the following environment variable when running CMake from an empty &lt;code&gt;build/&lt;/code&gt; directory. Beware, this results in &lt;em&gt;thousands&lt;/em&gt; of kernels and long build times.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=75 -DCUTLASS_LIBRARY_KERNELS=all&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building a subset of GEMM and Convolution kernels (&lt;em&gt;reduced&lt;/em&gt; build times)&lt;/h2&gt; &#xA;&lt;p&gt;To compile strictly one kernel or a small set of kernels, a comma-delimited list of kernel names with wildcard characters may be used to reduce the set of kernels. The following examples show building exactly one or a subset of kernels for NVIDIA Ampere and Turing architecture:&lt;/p&gt; &#xA;&lt;h3&gt;Building a subset Tensor Core GEMM kernels&lt;/h3&gt; &#xA;&lt;p&gt;To compile a subset of Tensor Core GEMM kernels with FP32 accumulation and FP16 input targetting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_tensorop_s*gemm_f16_*_nt_align8&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling a subset of Tensor Core GEMM kernels is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./tools/profiler/cutlass_profiler --kernels=cutlass_tensorop_s*gemm_f16_*_nt_align8 --m=3456 --n=4096 --k=4096&#xA;&#xA;...&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: gemm&#xA;       Operation: cutlass_tensorop_s1688gemm_f16_256x128_32x2_nt_align8&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;          cuBLAS: Passed&#xA;&#xA;       Arguments: --gemm_kind=universal --m=3456 --n=4096 --k=4096 --A=f16:column --B=f16:row --C=f32:column --alpha=1  \&#xA;                  --beta=0 --split_k_slices=1 --batch_count=1 --op_class=tensorop --accum=f32 --cta_m=256 --cta_n=128  \&#xA;                  --cta_k=32 --stages=2 --warps_m=4 --warps_n=2 --warps_k=1 --inst_m=16 --inst_n=8 --inst_k=8 --min_cc=75  \&#xA;                  --max_cc=1024&#xA;&#xA;           Bytes: 118489088  bytes&#xA;           FLOPs: 115992428544  flops&#xA;&#xA;         Runtime: 1.55948  ms&#xA;          Memory: 70.7616 GiB/s&#xA;&#xA;            Math: 74378.8 GFLOP/s&#xA;&#xA;&#xA;&#xA;=============================&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building one CUDA Core GEMM kernel&lt;/h3&gt; &#xA;&lt;p&gt;To compile one SGEMM kernel targetting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_simt_sgemm_128x128_8x2_nn_align1&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling single SGEMM CUDA kernel is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=sgemm --m=3456 --n=4096 --k=4096&#xA;&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: gemm&#xA;       Operation: cutlass_simt_sgemm_128x128_8x2_nn_align1&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;          cuBLAS: Passed&#xA;&#xA;       Arguments: --m=3456 --n=4096 --k=4096 --A=f32:column --B=f32:column --C=f32:column --alpha=1 --beta=0 --split_k_slices=1  \&#xA;                  --batch_count=1 --op_class=simt --accum=f32 --cta_m=128 --cta_n=128 --cta_k=8 --stages=2 --warps_m=4  \&#xA;                  --warps_n=2 --warps_k=1 --inst_m=1 --inst_n=1 --inst_k=1 --min_cc=50 --max_cc=1024&#xA;&#xA;           Bytes: 180355072  bytes&#xA;           FLOPs: 115992428544  flops&#xA;&#xA;         Runtime: 6.73655  ms&#xA;          Memory: 24.934 GiB/s&#xA;&#xA;            Math: 17218.4 GFLOP/s&#xA;&#xA;=============================&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building a subset of Tensor Core Convolution kernels&lt;/h3&gt; &#xA;&lt;p&gt;To compile a subset of Tensor core convolution kernels implementing forward propagation (fprop) with FP32 accumulation and FP16 input targetting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_tensorop_s*fprop_optimized_f16&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling a subset of Tensor Core convolution kernels is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=cutlass_tensorop_s*fprop_optimized_f16 --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3&#xA;&#xA;...&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: conv2d&#xA;       Operation: cutlass_tensorop_s16816fprop_optimized_f16_128x128_32x5_nhwc&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;&#xA;       Arguments: --conv_kind=fprop --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3 --p=224 --q=224 --pad_h=1 --pad_w=1  \&#xA;                  --stride_h=1 --stride_w=1 --dilation_h=1 --dilation_w=1 --Activation=f16:nhwc --Filter=f16:nhwc --Output=f32:nhwc  \&#xA;                  --conv_mode=cross --iterator_algorithm=optimized --alpha=1 --beta=0 --split_k_mode=serial --split_k_slices=1  \&#xA;                  --eq_gemm_provider=none --op_class=tensorop --accum=f32 --cta_m=128 --cta_n=128 --cta_k=32 --stages=5  \&#xA;                  --warps_m=2 --warps_n=2 --warps_k=1 --inst_m=16 --inst_n=8 --inst_k=16 --min_cc=80 --max_cc=1024&#xA;&#xA;           Bytes: 1130659840  bytes&#xA;           FLOPs: 118482796544  flops&#xA;&#xA;         Runtime: 0.711496  ms&#xA;          Memory: 1479.99 GiB/s&#xA;&#xA;            Math: 166526 GFLOP/s&#xA;&#xA;=============================&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building one Convolution CUDA kernel&lt;/h3&gt; &#xA;&lt;p&gt;To compile and run one CUDA Core convolution kernel implementing forward propagation (fprop) with F32 accumulation and FP32 input targetting NVIDIA Ampere and Turing architecture, use the below cmake command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cmake .. -DCUTLASS_NVCC_ARCHS=&#39;75;80&#39; -DCUTLASS_LIBRARY_KERNELS=cutlass_simt_sfprop_optimized_128x128_8x2_nhwc&#xA;...&#xA;$ make cutlass_profiler -j16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example command line for profiling one CUDA Core convolution kernel:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./tools/profiler/cutlass_profiler --kernels=cutlass_simt_sfprop_optimized_128x128_8x2_nhwc --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3&#xA;&#xA;&#xA;=============================&#xA;  Problem ID: 1&#xA;&#xA;        Provider: CUTLASS&#xA;   OperationKind: conv2d&#xA;       Operation: cutlass_simt_sfprop_optimized_128x128_8x2_nhwc&#xA;&#xA;          Status: Success&#xA;    Verification: ON&#xA;     Disposition: Passed&#xA;&#xA;reference_device: Passed&#xA;&#xA;       Arguments: --conv_kind=fprop --n=8 --h=224 --w=224 --c=128 --k=128 --r=3 --s=3 --p=224 --q=224 --pad_h=1 --pad_w=1  \&#xA;                  --stride_h=1 --stride_w=1 --dilation_h=1 --dilation_w=1 --Activation=f32:nhwc --Filter=f32:nhwc --Output=f32:nhwc  \&#xA;                  --conv_mode=cross --iterator_algorithm=optimized --alpha=1 --beta=0 --split_k_mode=serial --split_k_slices=1  \&#xA;                  --eq_gemm_provider=none --op_class=simt --accum=f32 --cta_m=128 --cta_n=128 --cta_k=8 --stages=2 --warps_m=4  \&#xA;                  --warps_n=2 --warps_k=1 --inst_m=1 --inst_n=1 --inst_k=1 --min_cc=50 --max_cc=1024&#xA;&#xA;           Bytes: 2055798784  bytes&#xA;           FLOPs: 118482796544  flops&#xA;&#xA;         Runtime: 7.34266  ms&#xA;          Memory: 260.752 GiB/s&#xA;&#xA;            Math: 16136.2 GFLOP/s&#xA;&#xA;&#xA;=============================&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;More Details on Compiling CUTLASS Kernels and CUTLASS Profiler&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Please follow the links for more CMake examples on selectively compiling CUTLASS kernels: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/quickstart.md#gemm-cmake-examples&#34;&gt;GEMM CMake Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/quickstart.md#convolution-cmake-examples&#34;&gt;Implicit GEMM conovlution CMake Examples&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/media/docs/profiler.md&#34;&gt;Further details about the CUTLASS Profiler are described here.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;About&lt;/h1&gt; &#xA;&lt;p&gt;CUTLASS is released by NVIDIA Corporation as Open Source software under the &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/LICENSE.txt&#34;&gt;3-clause &#34;New&#34; BSD license&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Contributors&lt;/h1&gt; &#xA;&lt;p&gt;The official list of CUTLASS developers and contributors is available here: &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA/cutlass/master/CONTRIBUTORS.md&#34;&gt;CONTRIBUTORS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Copyright&lt;/h1&gt; &#xA;&lt;p&gt;Copyright (c) 2017 - 2022 NVIDIA CORPORATION &amp;amp; AFFILIATES. All rights reserved. SPDX-License-Identifier: BSD-3-Clause&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  Redistribution and use in source and binary forms, with or without&#xA;  modification, are permitted provided that the following conditions are met:&#xA;&#xA;  1. Redistributions of source code must retain the above copyright notice, this&#xA;  list of conditions and the following disclaimer.&#xA;&#xA;  2. Redistributions in binary form must reproduce the above copyright notice,&#xA;  this list of conditions and the following disclaimer in the documentation&#xA;  and/or other materials provided with the distribution.&#xA;&#xA;  3. Neither the name of the copyright holder nor the names of its&#xA;  contributors may be used to endorse or promote products derived from&#xA;  this software without specific prior written permission.&#xA;&#xA;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34;&#xA;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&#xA;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&#xA;  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE&#xA;  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&#xA;  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&#xA;  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER&#xA;  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,&#xA;  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&#xA;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>