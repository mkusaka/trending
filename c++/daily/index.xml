<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-11T01:31:32Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>TheD1rkMtr/FilelessPELoader</title>
    <updated>2023-02-11T01:31:32Z</updated>
    <id>tag:github.com,2023-02-11:/TheD1rkMtr/FilelessPELoader</id>
    <link href="https://github.com/TheD1rkMtr/FilelessPELoader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Loading Remote AES Encrypted PE in memory , Decrypted it and run it&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FilelessPELoader&lt;/h1&gt; &#xA;&lt;p&gt;Loading Remote AES Encrypted PE in memory , Decrypted it and run it&lt;/p&gt; &#xA;&lt;h3&gt;Usage :&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/123980007/217600259-d3b8d08a-5d80-4329-9e14-057226e2f3bc.png&#34; alt=&#34;CipherKey&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/123980007/217600375-ed3f0f48-f9a5-4bf9-839c-8561c4679479.png&#34; alt=&#34;filelessremotepe&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;References :&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/aplyc1a/PEMemoryLoader?fbclid=IwAR2-VAQo8pJU-tdbSENjhDBdDGi5tyzrnW1S3D9BPAYR6C6-RK4hsEDjDGk&#34;&gt;https://github.com/aplyc1a/PEMemoryLoader?fbclid=IwAR2-VAQo8pJU-tdbSENjhDBdDGi5tyzrnW1S3D9BPAYR6C6-RK4hsEDjDGk&lt;/a&gt;&lt;br&gt; &lt;a href=&#34;https://github.com/Octoberfest7/Inline-Execute-PE&#34;&gt;https://github.com/Octoberfest7/Inline-Execute-PE&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sewenew/redis-plus-plus</title>
    <updated>2023-02-11T01:31:32Z</updated>
    <id>tag:github.com,2023-02-11:/sewenew/redis-plus-plus</id>
    <link href="https://github.com/sewenew/redis-plus-plus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Redis client written in C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;redis-plus-plus&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/sewenew/redis-plus-plus&#34;&gt;&lt;img src=&#34;https://travis-ci.org/sewenew/redis-plus-plus.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://github.com/sewenew/redis-plus-plus/blob/master/Chinese.md&#34;&gt;中文交流群&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#overview&#34;&gt;Overview&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#branches&#34;&gt;Branches&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#install-hiredis&#34;&gt;Install hiredis&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#install-redis-plus-plus&#34;&gt;Install redis-plus-plus&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#run-tests-optional&#34;&gt;Run Tests (Optional)&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#use-redis-plus-plus-in-your-project&#34;&gt;Use redis-plus-plus In Your Project&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#getting-started&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#api-reference&#34;&gt;API Reference&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#connection&#34;&gt;Connection&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#send-command-to-redis-server&#34;&gt;Send Command to Redis Server&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#exception&#34;&gt;Exception&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#generic-command-interface&#34;&gt;Generic Command Interface&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#publishsubscribe&#34;&gt;Publish/Subscribe&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#pipeline&#34;&gt;Pipeline&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#transaction&#34;&gt;Transaction&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-cluster&#34;&gt;Redis Cluster&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-sentinel&#34;&gt;Redis Sentinel&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-stream&#34;&gt;Redis Stream&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-modules&#34;&gt;Redis Modules&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#async-interface&#34;&gt;Async Interface&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#coroutine-interface&#34;&gt;Coroutine Interface&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-patterns&#34;&gt;Redis Patterns&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redlock&#34;&gt;Redlock&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#author&#34;&gt;Author&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This is a C++ client library for Redis. It&#39;s based on &lt;a href=&#34;https://github.com/redis/hiredis&#34;&gt;hiredis&lt;/a&gt;, and is compatible with C++ 17, C++ 14, and C++ 11.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: I&#39;m not a native speaker. So if the documentation is unclear, please feel free to open an issue or pull request. I&#39;ll response ASAP.&lt;/p&gt; &#xA;&lt;h3&gt;Features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Most commands for Redis.&lt;/li&gt; &#xA; &lt;li&gt;Connection pool.&lt;/li&gt; &#xA; &lt;li&gt;Redis scripting.&lt;/li&gt; &#xA; &lt;li&gt;Thread safe unless otherwise stated.&lt;/li&gt; &#xA; &lt;li&gt;Redis publish/subscribe.&lt;/li&gt; &#xA; &lt;li&gt;Redis pipeline.&lt;/li&gt; &#xA; &lt;li&gt;Redis transaction.&lt;/li&gt; &#xA; &lt;li&gt;Redis Cluster.&lt;/li&gt; &#xA; &lt;li&gt;Redis Sentinel.&lt;/li&gt; &#xA; &lt;li&gt;STL-like interfaces.&lt;/li&gt; &#xA; &lt;li&gt;Generic command interface.&lt;/li&gt; &#xA; &lt;li&gt;Redis Stream.&lt;/li&gt; &#xA; &lt;li&gt;Redlock.&lt;/li&gt; &#xA; &lt;li&gt;Redis ACL.&lt;/li&gt; &#xA; &lt;li&gt;TLS/SSL support.&lt;/li&gt; &#xA; &lt;li&gt;Sync and Async interface.&lt;/li&gt; &#xA; &lt;li&gt;Coroutine support.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Branches&lt;/h3&gt; &#xA;&lt;p&gt;The master branch is the stable branch, which passes all tests. The dev branch is unstable. If you want to contribute, please create pull request on dev branch.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Install hiredis&lt;/h3&gt; &#xA;&lt;p&gt;Since &lt;em&gt;redis-plus-plus&lt;/em&gt; is based on &lt;em&gt;hiredis&lt;/em&gt;, you should install &lt;em&gt;hiredis&lt;/em&gt; first. The minimum version requirement for &lt;em&gt;hiredis&lt;/em&gt; is &lt;strong&gt;v0.12.1&lt;/strong&gt;. However, &lt;a href=&#34;https://github.com/redis/hiredis/releases&#34;&gt;the latest stable release&lt;/a&gt; of &lt;em&gt;hiredis&lt;/em&gt; is always recommended.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: You must ensure that there&#39;s only 1 version of hiredis is installed. Otherwise, you might get some wired problems. Check the following issues for example: &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/135&#34;&gt;issue 135&lt;/a&gt;, &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/140&#34;&gt;issue 140&lt;/a&gt; and &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/158&#34;&gt;issue 158&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Normally, you can install &lt;em&gt;hiredis&lt;/em&gt; with a C++ package manager, and that&#39;s the easiest way to do it, e.g. &lt;code&gt;sudo apt-get install libhiredis-dev&lt;/code&gt;. However, if you want to install the latest code of hiredis, or a specified version (e.g. async support needs hiredis v1.0.0 or later), you can install it from source.&lt;/p&gt; &#xA;&lt;p&gt;Note again: DO NOT INSTALL MULTIPLE VERSIONS OF HIREDIS.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/redis/hiredis.git&#xA;&#xA;cd hiredis&#xA;&#xA;make&#xA;&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;em&gt;hiredis&lt;/em&gt; is installed at &lt;em&gt;/usr/local&lt;/em&gt;. If you want to install &lt;em&gt;hiredis&lt;/em&gt; at non-default location, use the following commands to specify the installation path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make PREFIX=/non/default/path&#xA;&#xA;make PREFIX=/non/default/path install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Install redis-plus-plus&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; is built with &lt;a href=&#34;https://cmake.org&#34;&gt;CMAKE&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/sewenew/redis-plus-plus.git&#xA;&#xA;cd redis-plus-plus&#xA;&#xA;mkdir build&#xA;&#xA;cd build&#xA;&#xA;cmake ..&#xA;&#xA;make&#xA;&#xA;make install&#xA;&#xA;cd ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;em&gt;hiredis&lt;/em&gt; is installed at non-default location, you should use &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; to specify the installation path of &lt;em&gt;hiredis&lt;/em&gt;. By default, &lt;em&gt;redis-plus-plus&lt;/em&gt; is installed at &lt;em&gt;/usr/local&lt;/em&gt;. However, you can use &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; to install &lt;em&gt;redis-plus-plus&lt;/em&gt; at non-default location.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DCMAKE_PREFIX_PATH=/path/to/hiredis -DCMAKE_INSTALL_PREFIX=/path/to/install/redis-plus-plus ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since version 1.3.0, by default, &lt;em&gt;redis-plus-plus&lt;/em&gt; is built with the &lt;code&gt;-std=c++17&lt;/code&gt; standard. So that we can use the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#stringview&#34;&gt;std::string_view&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#optional&#34;&gt;std::optional&lt;/a&gt; features. However, it can also be built with the &lt;code&gt;-std=c++11&lt;/code&gt; or &lt;code&gt;-std=c++14&lt;/code&gt; standard, and in that case, we have our own simple implementation of &lt;code&gt;std::string_view&lt;/code&gt; and &lt;code&gt;std::optional&lt;/code&gt;. In order to explicitly specify c++ standard, you can use the following cmake flag: &lt;code&gt;-DREDIS_PLUS_PLUS_CXX_STANDARD=11&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DCMAKE_PREFIX_PATH=/path/to/hiredis -DCMAKE_INSTALL_PREFIX=/path/to/install/redis-plus-plus -DREDIS_PLUS_PLUS_CXX_STANDARD=11 ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: You should build &lt;em&gt;redis-plus-plus&lt;/em&gt; and your application with the same standard, e.g. if you build &lt;em&gt;redis-plus-plus&lt;/em&gt; with C++17 standard, you MUST also build your application code with C++17 standard.&lt;/p&gt; &#xA;&lt;p&gt;When compiling &lt;em&gt;redis-plus-plus&lt;/em&gt;, it also compiles a test program, which might take a while. However, you can disable building test with the following cmake option: &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_TEST=OFF&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DCMAKE_PREFIX_PATH=/path/to/hiredis -DCMAKE_INSTALL_PREFIX=/path/to/install/redis-plus-plus -DREDIS_PLUS_PLUS_BUILD_TEST=OFF ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;em&gt;redis-plus-plus&lt;/em&gt; builds both a static library and a shared library. If you only want to build one of them, you can disable the other with &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_STATIC=OFF&lt;/code&gt; or &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_SHARED=OFF&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; builds static library with &lt;code&gt;-fPIC&lt;/code&gt; option, i.e. Position Independent Code, by default. However, you can disable it with &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_STATIC_WITH_PIC=OFF&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Windows Support&lt;/h4&gt; &#xA;&lt;p&gt;Now &lt;em&gt;hiredis&lt;/em&gt; has Windows support, and since Visual Studio 2017, Visual Studio has built-in support for CMake. So &lt;em&gt;redis-plus-plus&lt;/em&gt; also supports Windows platform now. It has been fully tested with Visual Studio 2017 and later on Win 10. I&#39;m not familiar with Visual Studio environment, and the following doc might not be accurate. If you&#39;re familiar with the Windows platform, feel free to update this doc on how to install &lt;em&gt;redis-plus-plus&lt;/em&gt; on Windows.&lt;/p&gt; &#xA;&lt;h5&gt;CMake Support On Visual Studio&lt;/h5&gt; &#xA;&lt;p&gt;The following are some links on how to build CMake project with Visual Studio 2017 or later. If you&#39;re not familiar with it, you&#39;d better read these instructions first:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/&#34;&gt;CMake support in Visual Studio&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=vs-2017&#34;&gt;CMake projects in Visual Studio&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/build/cmakesettings-reference?view=vs-2017&#34;&gt;CMakeSettings.json schema reference&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/visualstudio/get-started/tutorial-open-project-from-repo?view=vs-2019#open-a-project-from-a-github-repo&#34;&gt;Open a project from a GitHub repo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: IMHO, Visual Studio 2017&#39;s support for CMake project is not very mature, and I recommend you to build &lt;em&gt;hiredis&lt;/em&gt; and *redis-plus-plus with Visual Studio 2019.&lt;/p&gt; &#xA;&lt;h5&gt;Build hiredis&lt;/h5&gt; &#xA;&lt;p&gt;First of all, you need to get the latest code of &lt;em&gt;hiredis&lt;/em&gt; on master branch. Older version might not support Windows platform. &lt;em&gt;hiredis&lt;/em&gt;&#39; CMakeLists.txt uses &lt;code&gt;add_compile_definitions&lt;/code&gt; method, which is only supported by cmake 3.12 or later. However, Visual Studio 2017&#39;s cmake version is older than that. So if you&#39;re using Visual Studio 2017, you need to comment the following line in the CMakeLists.txt file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;#IF(WIN32)&#xA;#    ADD_COMPILE_DEFINITIONS(_CRT_SECURE_NO_WARNINGS WIN32_LEAN_AND_MEAN)&#xA;#ENDIF()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can use the &lt;strong&gt;Open Folder&lt;/strong&gt; feature to open &lt;em&gt;hiredis&lt;/em&gt; project, and build it with the instructions (links) mentioned above.&lt;/p&gt; &#xA;&lt;h5&gt;Build redis-plus-plus&lt;/h5&gt; &#xA;&lt;p&gt;Since &lt;em&gt;redis-plus-plus&lt;/em&gt; depends on &lt;em&gt;hiredis&lt;/em&gt;, we need to specify the installation paths of &lt;em&gt;hiredis&lt;/em&gt; before building it. You can use the &lt;strong&gt;Open Folder&lt;/strong&gt; feature to open &lt;em&gt;redis-plus-plus&lt;/em&gt; project. You need to edit the &lt;em&gt;CMakeSetting.json&lt;/em&gt; file (automatically generated by Visual Studio) to set &lt;em&gt;HIREDIS_HEADER&lt;/em&gt;, &lt;em&gt;HIREDIS_LIB&lt;/em&gt; and &lt;em&gt;TEST_HIREDIS_LIB&lt;/em&gt; variables to specify the installation path of hiredis headers, installation path of hiredis dynamic library and installation path of hiredis static library. The following is an example of &lt;em&gt;CMakeSetting.json&lt;/em&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;configurations&#34;: [&#xA;      {&#xA;        &#34;name&#34;: &#34;x64-Release&#34;,&#xA;        &#34;generator&#34;: &#34;Visual Studio 15 2017 Win64&#34;,&#xA;        &#34;configurationType&#34;: &#34;Release&#34;,&#xA;        &#34;buildRoot&#34;: &#34;${env.LOCALAPPDATA}\\CMakeBuild\\${workspaceHash}\\build\\${name}&#34;,&#xA;        &#34;cmakeCommandArgs&#34;: &#34;&#34;,&#xA;        &#34;buildCommandArgs&#34;: &#34;-m -v:minimal&#34;,&#xA;        &#34;variables&#34;: [&#xA;          {&#xA;            &#34;name&#34;: &#34;HIREDIS_HEADER&#34;,&#xA;            &#34;value&#34;: &#34;installation path of hiredis header files&#34;,&#xA;            &#34;type&#34;: &#34;PATH&#34;&#xA;          },&#xA;          {&#xA;            &#34;name&#34;: &#34;HIREDIS_LIB&#34;,&#xA;            &#34;value&#34;: &#34;installation path of dynamic library of hiredis&#34;,&#xA;            &#34;type&#34;: &#34;FILEPATH&#34;&#xA;          },&#xA;          {&#xA;            &#34;name&#34;: &#34;TEST_HIREDIS_LIB&#34;,&#xA;            &#34;value&#34;: &#34;installation path of static library of hiredis&#34;,&#xA;            &#34;type&#34;: &#34;FILEPATH&#34;&#xA;          }&#xA;        ]&#xA;      }&#xA;    ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can build it the instructions (links) mentioned above. If you&#39;re building with Visual Studio 2017 in debug mode, you might get &lt;a href=&#34;https://docs.microsoft.com/en-us/cpp/build/reference/bigobj-increase-number-of-sections-in-dot-obj-file?view=vs-2017&#34;&gt;/bigobj error&lt;/a&gt; when building the test. In this case, you can disable building test by setting &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_TEST=OFF&lt;/code&gt; or build it in Release mode.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Since 1.3.0, &lt;em&gt;redis-puls-plus&lt;/em&gt; is built with C++17 by default, and you should also set your application code to be built with C++17. If you still want to build the &lt;em&gt;redis-plus-plus&lt;/em&gt; with C++11, you can set the &lt;code&gt;REDIS_PLUS_PLUS_CXX_STANDARD&lt;/code&gt; cmake option to 11.&lt;/li&gt; &#xA; &lt;li&gt;TLS/SSL support has not been tested on Windows yet.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;The Order of Header Files&lt;/h5&gt; &#xA;&lt;p&gt;On Windows platform, if your application code also needs to include &lt;em&gt;windows.h&lt;/em&gt;. You must ensure that &lt;em&gt;sw/redis++/redis++.h&lt;/em&gt; is included before &lt;em&gt;windows.h&lt;/em&gt;. Check &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/194&#34;&gt;this issue&lt;/a&gt; for detail.&lt;/p&gt; &#xA;&lt;h4&gt;Building a redis-plus-plus Debian Package (Optional)&lt;/h4&gt; &#xA;&lt;p&gt;Basic support for building a GNU/Debian package is supplied with the use of cmake. The following example shows how to build the Debian package:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir build; cd build&#xA;cmake ..&#xA;cpack -G DEB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The install prefix may be modified as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir build; cd build&#xA;cmake -DCMAKE_INSTALL_PREFIX=/usr ..&#xA;cpack -G DEB&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Run Tests (Optional)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; has been fully tested with the following compilers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)&#xA;gcc version 5.5.0 20171010 (Ubuntu 5.5.0-12ubuntu1)&#xA;gcc version 6.5.0 20181026 (Ubuntu 6.5.0-2ubuntu1~18.04)&#xA;gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)&#xA;gcc version 8.3.0 (Ubuntu 8.3.0-6ubuntu1~18.04.1)&#xA;gcc version 9.2.1 20191008 (Ubuntu 9.2.1-9ubuntu2)&#xA;gcc version 10.2.1 20210110 (Debian 10.2.1-6)&#xA;clang version 3.9.1-19ubuntu1 (tags/RELEASE_391/rc2)&#xA;clang version 4.0.1-10 (tags/RELEASE_401/final)&#xA;clang version 5.0.1-4 (tags/RELEASE_501/final)&#xA;clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)&#xA;clang version 7.0.0-3~ubuntu0.18.04.1 (tags/RELEASE_700/final)&#xA;clang version 8.0.1-3build1 (tags/RELEASE_801/final)&#xA;Apple clang version 11.0.0 (clang-1100.0.33.12)&#xA;Visual Studio 2017 (Win 10)&#xA;Visual Studio 2019 (Win 10)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you build &lt;em&gt;redis-plus-plus&lt;/em&gt; with &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_TEST=ON&lt;/code&gt; (the default behavior, and you can disable building test with &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_TEST=OFF&lt;/code&gt;), you&#39;ll get a test program in &lt;em&gt;build/test&lt;/em&gt; directory: &lt;em&gt;build/test/test_redis++&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In order to run the tests, you need to set up a Redis instance, and a Redis Cluster. Since the test program will send most of Redis commands to the server and cluster, you need to set up Redis of the latest version (by now, it&#39;s 5.0). Otherwise, the tests might fail. For example, if you set up Redis 4.0 for testing, the test program will fail when it tries to send the &lt;code&gt;ZPOPMAX&lt;/code&gt; command (a Redis 5.0 command) to the server. If you want to run the tests with other Redis versions, you have to comment out commands that haven&#39;t been supported by your Redis, from test source files in &lt;em&gt;redis-plus-plus/test/src/sw/redis++/&lt;/em&gt; directory. Sorry for the inconvenience, and I&#39;ll fix this problem to make the test program work with any version of Redis in the future.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The latest version of Redis is only a requirement for running the tests. In fact, you can use &lt;em&gt;redis-plus-plus&lt;/em&gt; with Redis of any version, e.g. Redis 2.0, Redis 3.0, Redis 4.0, Redis 5.0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NEVER&lt;/strong&gt; run the test program in production envronment, since the keys, which the test program reads or writes, might conflict with your application.&lt;/p&gt; &#xA;&lt;p&gt;In order to run tests with both Redis and Redis Cluster, you can run the test program with the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/test/test_redis++ -h host -p port -a auth -n cluster_node -c cluster_port&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;host&lt;/em&gt; and &lt;em&gt;port&lt;/em&gt; are the host and port number of the Redis instance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;cluster_node&lt;/em&gt; and &lt;em&gt;cluster_port&lt;/em&gt; are the host and port number of Redis Cluster. You only need to set the host and port number of a single node in the cluster, &lt;em&gt;redis-plus-plus&lt;/em&gt; will find other nodes automatically.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;auth&lt;/em&gt; is the password of the Redis instance and Redis Cluster. The Redis instance and Redis Cluster must be configured with the same password. If there&#39;s no password configured, don&#39;t set this option.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you only want to run tests with Redis, you only need to specify &lt;em&gt;host&lt;/em&gt;, &lt;em&gt;port&lt;/em&gt; and &lt;em&gt;auth&lt;/em&gt; options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/test/test_redis++ -h host -p port -a auth&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, if you only want to run tests with Redis Cluster, just specify &lt;em&gt;cluster_node&lt;/em&gt;, &lt;em&gt;cluster_port&lt;/em&gt; and &lt;em&gt;auth&lt;/em&gt; options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/test/test_redis++ -a auth -n cluster_node -c cluster_port&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the test program will not test running &lt;em&gt;redis-plus-plus&lt;/em&gt; in multi-threads environment. If you want to do multi-threads test, which might cost a long time, you can specify the &lt;em&gt;-m&lt;/em&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/test/test_redis++ -h host -p port -a auth -n cluster_node -c cluster_port -m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If all tests have been passed, the test program will print the following message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Pass all tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, it prints the error message.&lt;/p&gt; &#xA;&lt;h4&gt;Performance&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; runs as fast as &lt;em&gt;hiredis&lt;/em&gt;, since it&#39;s a wrapper of &lt;em&gt;hiredis&lt;/em&gt;. You can run &lt;em&gt;test_redis++&lt;/em&gt; in benchmark mode to check the performance in your environment.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./build/test/test_redis++ -h host -p port -a auth -n cluster_node -c cluster_port -b -t thread_num -s connection_pool_size -r request_num -k key_len -v val_len&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;-b&lt;/em&gt; option turns the test program into benchmark mode.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;thread_num&lt;/em&gt; specifies the number of worker threads. &lt;code&gt;10&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;connection_pool_size&lt;/em&gt; specifies the size of the connection pool. &lt;code&gt;5&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;request_num&lt;/em&gt; specifies the total number of requests sent to server for each test. &lt;code&gt;100000&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;key_len&lt;/em&gt; specifies the length of the key for each operation. &lt;code&gt;10&lt;/code&gt; by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;val_len&lt;/em&gt; specifies the length of the value. &lt;code&gt;10&lt;/code&gt; by default.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The bechmark will generate &lt;code&gt;100&lt;/code&gt; random binary keys for testing, and the size of these keys is specified by &lt;em&gt;key_len&lt;/em&gt;. When the benchmark runs, it will read/write with these keys. So &lt;strong&gt;NEVER&lt;/strong&gt; run the test program in your production environment, otherwise, it might inaccidently delete your data.&lt;/p&gt; &#xA;&lt;h3&gt;Use redis-plus-plus In Your Project&lt;/h3&gt; &#xA;&lt;p&gt;After compiling the code, you&#39;ll get both shared library and static library. Since &lt;em&gt;redis-plus-plus&lt;/em&gt; depends on &lt;em&gt;hiredis&lt;/em&gt;, you need to link both libraries to your Application. Also don&#39;t forget to specify the c++ standard, &lt;code&gt;-std=c++17&lt;/code&gt;, &lt;code&gt;-std=c++14&lt;/code&gt; or &lt;code&gt;-std=c++11&lt;/code&gt;, as well as the thread-related option.&lt;/p&gt; &#xA;&lt;h4&gt;Use Static Libraries&lt;/h4&gt; &#xA;&lt;p&gt;Take gcc as an example.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;g++ -std=c++17 -o app app.cpp /path/to/libredis++.a /path/to/libhiredis.a -pthread&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt; are installed at non-default location, you should use &lt;code&gt;-I&lt;/code&gt; option to specify the header path.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;g++ -std=c++17 -I/non-default/install/include/path -o app app.cpp /path/to/libredis++.a /path/to/libhiredis.a -pthread&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Use Shared Libraries&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;g++ -std=c++17 -o app app.cpp -lredis++ -lhiredis -pthread&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt; are installed at non-default location, you should use &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; options to specify the header and library paths.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;g++ -std=c++17 -I/non-default/install/include/path -L/non-default/install/lib/path -o app app.cpp -lredis++ -lhiredis -pthread&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When linking with shared libraries, and running your application, you might get the following error message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;error while loading shared libraries: xxx: cannot open shared object file: No such file or directory.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s because the linker cannot find the shared libraries. In order to solve the problem, you can add the path where you installed &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt; libraries, to &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check &lt;a href=&#34;https://stackoverflow.com/questions/480764&#34;&gt;this StackOverflow question&lt;/a&gt; for details on how to solve the problem.&lt;/p&gt; &#xA;&lt;h4&gt;Build With Cmake&lt;/h4&gt; &#xA;&lt;p&gt;If you&#39;re using cmake to build your application, you need to add &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt; dependencies in your &lt;em&gt;CMakeLists.txt&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-CMake&#34;&gt;# &amp;lt;---------- set c++ standard -------------&amp;gt;&#xA;# NOTE: you must build redis-plus-plus and your application code with the same standard.&#xA;set(CMAKE_CXX_STANDARD 17)&#xA;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#xA;&#xA;# &amp;lt;------------ add hiredis dependency ---------------&amp;gt;&#xA;find_path(HIREDIS_HEADER hiredis)&#xA;target_include_directories(target PUBLIC ${HIREDIS_HEADER})&#xA;&#xA;find_library(HIREDIS_LIB hiredis)&#xA;target_link_libraries(target ${HIREDIS_LIB})&#xA;&#xA;# &amp;lt;------------ add redis-plus-plus dependency --------------&amp;gt;&#xA;# NOTE: this should be *sw* NOT *redis++*&#xA;find_path(REDIS_PLUS_PLUS_HEADER sw)&#xA;target_include_directories(target PUBLIC ${REDIS_PLUS_PLUS_HEADER})&#xA;&#xA;find_library(REDIS_PLUS_PLUS_LIB redis++)&#xA;target_link_libraries(target ${REDIS_PLUS_PLUS_LIB})&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/5&#34;&gt;this issue&lt;/a&gt; for a complete example of &lt;em&gt;CMakeLists.txt&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Also, if you installed &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt; at non-default location, you need to run cmake with &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; option to specify the installation path of these two libraries.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -DCMAKE_PREFIX_PATH=/installation/path/to/the/two/libs ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;sw/redis++/redis++.h&amp;gt;&#xA;&#xA;using namespace sw::redis;&#xA;&#xA;try {&#xA;    // Create an Redis object, which is movable but NOT copyable.&#xA;    auto redis = Redis(&#34;tcp://127.0.0.1:6379&#34;);&#xA;&#xA;    // ***** STRING commands *****&#xA;&#xA;    redis.set(&#34;key&#34;, &#34;val&#34;);&#xA;    auto val = redis.get(&#34;key&#34;);    // val is of type OptionalString. See &#39;API Reference&#39; section for details.&#xA;    if (val) {&#xA;        // Dereference val to get the returned value of std::string type.&#xA;        std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;    }   // else key doesn&#39;t exist.&#xA;&#xA;    // ***** LIST commands *****&#xA;&#xA;    // std::vector&amp;lt;std::string&amp;gt; to Redis LIST.&#xA;    std::vector&amp;lt;std::string&amp;gt; vec = {&#34;a&#34;, &#34;b&#34;, &#34;c&#34;};&#xA;    redis.rpush(&#34;list&#34;, vec.begin(), vec.end());&#xA;&#xA;    // std::initializer_list to Redis LIST.&#xA;    redis.rpush(&#34;list&#34;, {&#34;a&#34;, &#34;b&#34;, &#34;c&#34;});&#xA;&#xA;    // Redis LIST to std::vector&amp;lt;std::string&amp;gt;.&#xA;    vec.clear();&#xA;    redis.lrange(&#34;list&#34;, 0, -1, std::back_inserter(vec));&#xA;&#xA;    // ***** HASH commands *****&#xA;&#xA;    redis.hset(&#34;hash&#34;, &#34;field&#34;, &#34;val&#34;);&#xA;&#xA;    // Another way to do the same job.&#xA;    redis.hset(&#34;hash&#34;, std::make_pair(&#34;field&#34;, &#34;val&#34;));&#xA;&#xA;    // std::unordered_map&amp;lt;std::string, std::string&amp;gt; to Redis HASH.&#xA;    std::unordered_map&amp;lt;std::string, std::string&amp;gt; m = {&#xA;        {&#34;field1&#34;, &#34;val1&#34;},&#xA;        {&#34;field2&#34;, &#34;val2&#34;}&#xA;    };&#xA;    redis.hmset(&#34;hash&#34;, m.begin(), m.end());&#xA;&#xA;    // Redis HASH to std::unordered_map&amp;lt;std::string, std::string&amp;gt;.&#xA;    m.clear();&#xA;    redis.hgetall(&#34;hash&#34;, std::inserter(m, m.begin()));&#xA;&#xA;    // Get value only.&#xA;    // NOTE: since field might NOT exist, so we need to parse it to OptionalString.&#xA;    std::vector&amp;lt;OptionalString&amp;gt; vals;&#xA;    redis.hmget(&#34;hash&#34;, {&#34;field1&#34;, &#34;field2&#34;}, std::back_inserter(vals));&#xA;&#xA;    // ***** SET commands *****&#xA;&#xA;    redis.sadd(&#34;set&#34;, &#34;m1&#34;);&#xA;&#xA;    // std::unordered_set&amp;lt;std::string&amp;gt; to Redis SET.&#xA;    std::unordered_set&amp;lt;std::string&amp;gt; set = {&#34;m2&#34;, &#34;m3&#34;};&#xA;    redis.sadd(&#34;set&#34;, set.begin(), set.end());&#xA;&#xA;    // std::initializer_list to Redis SET.&#xA;    redis.sadd(&#34;set&#34;, {&#34;m2&#34;, &#34;m3&#34;});&#xA;&#xA;    // Redis SET to std::unordered_set&amp;lt;std::string&amp;gt;.&#xA;    set.clear();&#xA;    redis.smembers(&#34;set&#34;, std::inserter(set, set.begin()));&#xA;&#xA;    if (redis.sismember(&#34;set&#34;, &#34;m1&#34;)) {&#xA;        std::cout &amp;lt;&amp;lt; &#34;m1 exists&#34; &amp;lt;&amp;lt; std::endl;&#xA;    }   // else NOT exist.&#xA;&#xA;    // ***** SORTED SET commands *****&#xA;&#xA;    redis.zadd(&#34;sorted_set&#34;, &#34;m1&#34;, 1.3);&#xA;&#xA;    // std::unordered_map&amp;lt;std::string, double&amp;gt; to Redis SORTED SET.&#xA;    std::unordered_map&amp;lt;std::string, double&amp;gt; scores = {&#xA;        {&#34;m2&#34;, 2.3},&#xA;        {&#34;m3&#34;, 4.5}&#xA;    };&#xA;    redis.zadd(&#34;sorted_set&#34;, scores.begin(), scores.end());&#xA;&#xA;    // Redis SORTED SET to std::vector&amp;lt;std::pair&amp;lt;std::string, double&amp;gt;&amp;gt;.&#xA;    // NOTE: The return results of zrangebyscore are ordered, if you save the results&#xA;    // in to `std::unordered_map&amp;lt;std::string, double&amp;gt;`, you&#39;ll lose the order.&#xA;    std::vector&amp;lt;std::pair&amp;lt;std::string, double&amp;gt;&amp;gt; zset_result;&#xA;    redis.zrangebyscore(&#34;sorted_set&#34;,&#xA;            UnboundedInterval&amp;lt;double&amp;gt;{},            // (-inf, +inf)&#xA;            std::back_inserter(zset_result));&#xA;&#xA;    // Only get member names:&#xA;    // pass an inserter of std::vector&amp;lt;std::string&amp;gt; type as output parameter.&#xA;    std::vector&amp;lt;std::string&amp;gt; without_score;&#xA;    redis.zrangebyscore(&#34;sorted_set&#34;,&#xA;            BoundedInterval&amp;lt;double&amp;gt;(1.5, 3.4, BoundType::CLOSED),   // [1.5, 3.4]&#xA;            std::back_inserter(without_score));&#xA;&#xA;    // Get both member names and scores:&#xA;    // pass an back_inserter of std::vector&amp;lt;std::pair&amp;lt;std::string, double&amp;gt;&amp;gt; as output parameter.&#xA;    std::vector&amp;lt;std::pair&amp;lt;std::string, double&amp;gt;&amp;gt; with_score;&#xA;    redis.zrangebyscore(&#34;sorted_set&#34;,&#xA;            BoundedInterval&amp;lt;double&amp;gt;(1.5, 3.4, BoundType::LEFT_OPEN),    // (1.5, 3.4]&#xA;            std::back_inserter(with_score));&#xA;&#xA;    // ***** SCRIPTING commands *****&#xA;&#xA;    // Script returns a single element.&#xA;    auto num = redis.eval&amp;lt;long long&amp;gt;(&#34;return 1&#34;, {}, {});&#xA;&#xA;    // Script returns an array of elements.&#xA;    std::vector&amp;lt;std::string&amp;gt; nums;&#xA;    redis.eval(&#34;return {ARGV[1], ARGV[2]}&#34;, {}, {&#34;1&#34;, &#34;2&#34;}, std::back_inserter(nums));&#xA;&#xA;    // mset with TTL&#xA;    auto mset_with_ttl_script = R&#34;(&#xA;        local len = #KEYS&#xA;        if (len == 0 or len + 1 ~= #ARGV) then return 0 end&#xA;        local ttl = tonumber(ARGV[len + 1])&#xA;        if (not ttl or ttl &amp;lt;= 0) then return 0 end&#xA;        for i = 1, len do redis.call(&#34;SET&#34;, KEYS[i], ARGV[i], &#34;EX&#34;, ttl) end&#xA;        return 1&#xA;    )&#34;;&#xA;&#xA;    // Set multiple key-value pairs with TTL of 60 seconds.&#xA;    auto keys = {&#34;key1&#34;, &#34;key2&#34;, &#34;key3&#34;};&#xA;    std::vector&amp;lt;std::string&amp;gt; args = {&#34;val1&#34;, &#34;val2&#34;, &#34;val3&#34;, &#34;60&#34;};&#xA;    redis.eval&amp;lt;long long&amp;gt;(mset_with_ttl_script, keys.begin(), keys.end(), args.begin(), args.end());&#xA;&#xA;    // ***** Pipeline *****&#xA;&#xA;    // Create a pipeline.&#xA;    auto pipe = redis.pipeline();&#xA;&#xA;    // Send mulitple commands and get all replies.&#xA;    auto pipe_replies = pipe.set(&#34;key&#34;, &#34;value&#34;)&#xA;                            .get(&#34;key&#34;)&#xA;                            .rename(&#34;key&#34;, &#34;new-key&#34;)&#xA;                            .rpush(&#34;list&#34;, {&#34;a&#34;, &#34;b&#34;, &#34;c&#34;})&#xA;                            .lrange(&#34;list&#34;, 0, -1)&#xA;                            .exec();&#xA;&#xA;    // Parse reply with reply type and index.&#xA;    auto set_cmd_result = pipe_replies.get&amp;lt;bool&amp;gt;(0);&#xA;&#xA;    auto get_cmd_result = pipe_replies.get&amp;lt;OptionalString&amp;gt;(1);&#xA;&#xA;    // rename command result&#xA;    pipe_replies.get&amp;lt;void&amp;gt;(2);&#xA;&#xA;    auto rpush_cmd_result = pipe_replies.get&amp;lt;long long&amp;gt;(3);&#xA;&#xA;    std::vector&amp;lt;std::string&amp;gt; lrange_cmd_result;&#xA;    pipe_replies.get(4, back_inserter(lrange_cmd_result));&#xA;&#xA;    // ***** Transaction *****&#xA;&#xA;    // Create a transaction.&#xA;    auto tx = redis.transaction();&#xA;&#xA;    // Run multiple commands in a transaction, and get all replies.&#xA;    auto tx_replies = tx.incr(&#34;num0&#34;)&#xA;                        .incr(&#34;num1&#34;)&#xA;                        .mget({&#34;num0&#34;, &#34;num1&#34;})&#xA;                        .exec();&#xA;&#xA;    // Parse reply with reply type and index.&#xA;    auto incr_result0 = tx_replies.get&amp;lt;long long&amp;gt;(0);&#xA;&#xA;    auto incr_result1 = tx_replies.get&amp;lt;long long&amp;gt;(1);&#xA;&#xA;    std::vector&amp;lt;OptionalString&amp;gt; mget_cmd_result;&#xA;    tx_replies.get(2, back_inserter(mget_cmd_result));&#xA;&#xA;    // ***** Generic Command Interface *****&#xA;&#xA;    // There&#39;s no *Redis::client_getname* interface.&#xA;    // But you can use *Redis::command* to get the client name.&#xA;    val = redis.command&amp;lt;OptionalString&amp;gt;(&#34;client&#34;, &#34;getname&#34;);&#xA;    if (val) {&#xA;        std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;    }&#xA;&#xA;    // Same as above.&#xA;    auto getname_cmd_str = {&#34;client&#34;, &#34;getname&#34;};&#xA;    val = redis.command&amp;lt;OptionalString&amp;gt;(getname_cmd_str.begin(), getname_cmd_str.end());&#xA;&#xA;    // There&#39;s no *Redis::sort* interface.&#xA;    // But you can use *Redis::command* to send sort the list.&#xA;    std::vector&amp;lt;std::string&amp;gt; sorted_list;&#xA;    redis.command(&#34;sort&#34;, &#34;list&#34;, &#34;ALPHA&#34;, std::back_inserter(sorted_list));&#xA;&#xA;    // Another *Redis::command* to do the same work.&#xA;    auto sort_cmd_str = {&#34;sort&#34;, &#34;list&#34;, &#34;ALPHA&#34;};&#xA;    redis.command(sort_cmd_str.begin(), sort_cmd_str.end(), std::back_inserter(sorted_list));&#xA;&#xA;    // ***** Redis Cluster *****&#xA;&#xA;    // Create a RedisCluster object, which is movable but NOT copyable.&#xA;    auto redis_cluster = RedisCluster(&#34;tcp://127.0.0.1:7000&#34;);&#xA;&#xA;    // RedisCluster has similar interfaces as Redis.&#xA;    redis_cluster.set(&#34;key&#34;, &#34;value&#34;);&#xA;    val = redis_cluster.get(&#34;key&#34;);&#xA;    if (val) {&#xA;        std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;    }   // else key doesn&#39;t exist.&#xA;&#xA;    // Keys with hash-tag.&#xA;    redis_cluster.set(&#34;key{tag}1&#34;, &#34;val1&#34;);&#xA;    redis_cluster.set(&#34;key{tag}2&#34;, &#34;val2&#34;);&#xA;    redis_cluster.set(&#34;key{tag}3&#34;, &#34;val3&#34;);&#xA;&#xA;    std::vector&amp;lt;OptionalString&amp;gt; hash_tag_res;&#xA;    redis_cluster.mget({&#34;key{tag}1&#34;, &#34;key{tag}2&#34;, &#34;key{tag}3&#34;},&#xA;            std::back_inserter(hash_tag_res));&#xA;&#xA;} catch (const Error &amp;amp;e) {&#xA;    // Error handling.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API Reference&lt;/h2&gt; &#xA;&lt;p&gt;You can also see &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/redis.h&#34;&gt;redis.h&lt;/a&gt; for doxygen style documentation.&lt;/p&gt; &#xA;&lt;h3&gt;Connection&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; class maintains a connection pool to Redis server. If the connection is broken, &lt;code&gt;Redis&lt;/code&gt; reconnects to Redis server automatically.&lt;/p&gt; &#xA;&lt;p&gt;You can initialize a &lt;code&gt;Redis&lt;/code&gt; instance with &lt;code&gt;ConnectionOptions&lt;/code&gt; and &lt;code&gt;ConnectionPoolOptions&lt;/code&gt;. &lt;code&gt;ConnectionOptions&lt;/code&gt; specifies options for connection to Redis server, and &lt;code&gt;ConnectionPoolOptions&lt;/code&gt; specifies options for conneciton pool. &lt;code&gt;ConnectionPoolOptions&lt;/code&gt; is optional. If not specified, &lt;code&gt;Redis&lt;/code&gt; maintains a single connection to Redis server.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;ConnectionOptions connection_options;&#xA;connection_options.host = &#34;127.0.0.1&#34;;  // Required.&#xA;connection_options.port = 6666; // Optional. The default port is 6379.&#xA;connection_options.password = &#34;auth&#34;;   // Optional. No password by default.&#xA;connection_options.db = 1;  // Optional. Use the 0th database by default.&#xA;&#xA;// Optional. Timeout before we successfully send request to or receive response from redis.&#xA;// By default, the timeout is 0ms, i.e. never timeout and block until we send or receive successfuly.&#xA;// NOTE: if any command is timed out, we throw a TimeoutError exception.&#xA;connection_options.socket_timeout = std::chrono::milliseconds(200);&#xA;&#xA;// Connect to Redis server with a single connection.&#xA;Redis redis1(connection_options);&#xA;&#xA;ConnectionPoolOptions pool_options;&#xA;pool_options.size = 3;  // Pool size, i.e. max number of connections.&#xA;&#xA;// Optional. Max time to wait for a connection. 0ms by default, which means wait forever.&#xA;// Say, the pool size is 3, while 4 threds try to fetch the connection, one of them will be blocked.&#xA;pool_options.wait_timeout = std::chrono::milliseconds(100);&#xA;&#xA;// Optional. Max lifetime of a connection. 0ms by default, which means never expire the connection.&#xA;// If the connection has been created for a long time, i.e. more than `connection_lifetime`,&#xA;// it will be expired and reconnected.&#xA;pool_options.connection_lifetime = std::chrono::minutes(10);&#xA;&#xA;// Connect to Redis server with a connection pool.&#xA;Redis redis2(connection_options, pool_options);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: if you set &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt;, and try to call blocking commands, e.g. &lt;code&gt;Redis::brpop&lt;/code&gt;, &lt;code&gt;Redis::blpop&lt;/code&gt;, &lt;code&gt;Redis::bzpopmax&lt;/code&gt;, &lt;code&gt;Redis::bzpopmin&lt;/code&gt;, you must ensure that &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt; is larger than the timeout specified with these blocking commands. Otherwise, you might get &lt;code&gt;TimeoutError&lt;/code&gt;, and lose messages.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/connection.h#L40&#34;&gt;ConnectionOptions&lt;/a&gt; and &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/connection_pool.h#L30&#34;&gt;ConnectionPoolOptions&lt;/a&gt; for more options. Also see &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/80&#34;&gt;issue 80&lt;/a&gt; for discussion on connection pool.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;Redis&lt;/code&gt; class is movable but NOT copyable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// auto redis3 = redis1;    // this won&#39;t compile.&#xA;&#xA;// But it&#39;s movable.&#xA;auto redis3 = std::move(redis1);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; also supports connecting to Redis server with Unix Domain Socket.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;ConnectionOptions options;&#xA;options.type = ConnectionType::UNIX;&#xA;options.path = &#34;/path/to/socket&#34;;&#xA;Redis redis(options);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also connect to Redis server with a URI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tcp://[[username:]password@]host[:port][/db]&#xA;&#xA;redis://[[username:]password@]host[:port][/db]&#xA;&#xA;unix://[[username:]password@]path-to-unix-domain-socket[/db]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;em&gt;scheme&lt;/em&gt; and &lt;em&gt;host&lt;/em&gt; parts are required, and others are optional. If you&#39;re connecting to Redis with Unix Domain Socket, you should use the &lt;em&gt;unix&lt;/em&gt; scheme, otherwise, you should use &lt;em&gt;tcp&lt;/em&gt; or &lt;em&gt;redis&lt;/em&gt; scheme. The following is a list of default values for those optional parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;username: &lt;em&gt;default&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;password: empty string, i.e. no password&lt;/li&gt; &#xA; &lt;li&gt;port: 6379&lt;/li&gt; &#xA; &lt;li&gt;db: 0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: If your password or username contains &#39;@&#39;, or your username contains &#39;:&#39;, you cannot construct &lt;code&gt;Redis&lt;/code&gt; object with URI. Because &lt;em&gt;redis-plus-plus&lt;/em&gt; will incorrectly parse the URI. In this case, you need to use &lt;code&gt;ConnectionOptions&lt;/code&gt; to construct &lt;code&gt;Redis&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;a href=&#34;https://redis.io/topics/acl&#34;&gt;Redis 6.0 supports ACL&lt;/a&gt;, and you can specify a username for the connection. However, before Redis 6.0, you cannot do that.&lt;/p&gt; &#xA;&lt;p&gt;Also, the following connection options and connection pool options can be specified with the query string of URI, e.g. &lt;em&gt;tcp://127.0.0.1?keep_alive=true&amp;amp;socket_timeout=100ms&amp;amp;connect_timeout=100ms&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Option&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Parameter&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Default&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::user&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;user&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;default&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::password&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;password&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;empty string, i.e. no password&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::db&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;db&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::keep_alive&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;keep_alive&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;false&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::connect_timeout&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;connect_timeout&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;socket_timeout&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionOptions::resp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;resp&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionPoolOptions::size&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;pool_size&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionPoolOptions::wait_timeout&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;pool_wait_timeout&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionPoolOptions::connection_lifetime&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;pool_connection_lifetime&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;ConnectionPoolOptions::connection_idle_time&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;em&gt;pool_connection_idle_time&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;0ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Options specified in query string are case-sensitive, i.e. all key-value pairs must be in lowercase.&lt;/li&gt; &#xA; &lt;li&gt;Options specified in query string, e.g. &lt;em&gt;user&lt;/em&gt;, &lt;em&gt;password&lt;/em&gt;, &lt;em&gt;db&lt;/em&gt;, overwrites the one specified in URI. For example, &lt;em&gt;redis://127.0.0.1/1?db=3&lt;/em&gt; means that all reads/writes run on the 3rd database, instead of the 1st one.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Single connection to the given host and port.&#xA;Redis redis1(&#34;tcp://127.0.0.1:6666&#34;);&#xA;&#xA;// Use default port, i.e. 6379.&#xA;Redis redis2(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;// Connect to Redis with password, and default port.&#xA;Redis redis3(&#34;tcp://pass@127.0.0.1&#34;);&#xA;&#xA;// Connect to Redis and select the 2nd (db number starts from 0) database.&#xA;Redis redis4(&#34;tcp://127.0.0.1:6379/2&#34;);&#xA;&#xA;// Set keep_alive option to true with query string.&#xA;Redis redis5(&#34;tcp://127.0.0.1:6379/2?keep_alive=true&#34;);&#xA;&#xA;// Set socket_timeout to 50 milliseconds, and connect_timeout to 1 second with query string.&#xA;Redis redis6(&#34;tcp://127.0.0.1?socket_timeout=50ms&amp;amp;connect_timeout=1s&#34;);&#xA;&#xA;// Connect to Unix Domain Socket.&#xA;Redis redis7(&#34;unix://path/to/socket&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;RESP3&lt;/h4&gt; &#xA;&lt;p&gt;Since Redis 6.0, it supports a new version of Redis protocol, i.e. RESP3. In order to use this new protocol, you need to set &lt;code&gt;ConnectionOptions::resp&lt;/code&gt; to be 3.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ConnectionOptions opts;&#xA;opts.resp = 3;&#xA;// Set other options...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;ConnectionOptions::resp&lt;/code&gt; is 2, i.e. use RESP version 2. So far, only version 2 and 3 are supported, and the behavior is undefined, if you set &lt;code&gt;ConnectionOptions::resp&lt;/code&gt; to other numbers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: In order to use this new protocol, you need to install the latest hiredis (even hiredis-v1.0.2 has bugs on RESP3 support).&lt;/p&gt; &#xA;&lt;h4&gt;Lazily Create Connection&lt;/h4&gt; &#xA;&lt;p&gt;Connections in the pool are lazily created. When the connection pool is initialized, i.e. the constructor of &lt;code&gt;Redis&lt;/code&gt;, &lt;code&gt;Redis&lt;/code&gt; does NOT connect to the server. Instead, it connects to the server only when you try to send command. In this way, we can avoid unnecessary connections. So if the pool size is 5, but the number of max concurrent connections is 3, there will be only 3 connections in the pool.&lt;/p&gt; &#xA;&lt;h4&gt;Connection Failure&lt;/h4&gt; &#xA;&lt;p&gt;You don&#39;t need to check whether &lt;code&gt;Redis&lt;/code&gt; object connects to server successfully. If &lt;code&gt;Redis&lt;/code&gt; fails to create a connection to Redis server, or the connection is broken at some time, it throws an exception of type &lt;code&gt;Error&lt;/code&gt; when you try to send command with &lt;code&gt;Redis&lt;/code&gt;. Even when you get an exception, i.e. the connection is broken, you don&#39;t need to create a new &lt;code&gt;Redis&lt;/code&gt; object. You can reuse the &lt;code&gt;Redis&lt;/code&gt; object to send commands, and the &lt;code&gt;Redis&lt;/code&gt; object will try to reconnect to server automatically. If it reconnects successfully, it sends command to server. Otherwise, it throws an exception again.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#exception&#34;&gt;Exception section&lt;/a&gt; for details on exceptions.&lt;/p&gt; &#xA;&lt;h4&gt;Reuse Redis object As Much As Possible&lt;/h4&gt; &#xA;&lt;p&gt;It&#39;s NOT cheap to create a &lt;code&gt;Redis&lt;/code&gt; object, since it will create new connections to Redis server. So you&#39;d better reuse &lt;code&gt;Redis&lt;/code&gt; object as much as possible. Also, it&#39;s safe to call &lt;code&gt;Redis&lt;/code&gt;&#39; member functions in multi-thread environment, and you can share &lt;code&gt;Redis&lt;/code&gt; object in multiple threads.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// This is GOOD practice.&#xA;auto redis = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;for (auto idx = 0; idx &amp;lt; 100; ++idx) {&#xA;    // Reuse the Redis object in the loop.&#xA;    redis.set(&#34;key&#34;, &#34;val&#34;);&#xA;}&#xA;&#xA;// This is VERY BAD! It&#39;s very inefficient.&#xA;// NEVER DO IT!!!&#xA;for (auto idx = 0; idx &amp;lt; 100; ++idx) {&#xA;    // Create a new Redis object for each iteration.&#xA;    auto redis = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;    redis.set(&#34;key&#34;, &#34;val&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;TLS/SSL Support&lt;/h4&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; also has TLS support. However, in order to use this feature, you need to enable it when building &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: So far, TLS feature has not been tested on Windows platform. I&#39;ll fix it in the future.&lt;/p&gt; &#xA;&lt;h5&gt;Enable TLS/SSL support&lt;/h5&gt; &#xA;&lt;p&gt;When building &lt;em&gt;hiredis&lt;/em&gt; with TLS support, you need to download &lt;em&gt;hiredis&lt;/em&gt; of version &lt;em&gt;v1.0.0&lt;/em&gt; or latter, and specify &lt;code&gt;USE_SSL=1&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make PREFIX=/non/default/path USE_SSL=1&#xA;&#xA;make PREFIX=/non/default/path USE_SSL=1 install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can build &lt;em&gt;redis-plus-plus&lt;/em&gt; to enable TLS support by specifying the &lt;code&gt;-DREDIS_PLUS_PLUS_USE_TLS=ON&lt;/code&gt; option:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DREDIS_PLUS_PLUS_USE_TLS=ON ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Connection Options&lt;/h5&gt; &#xA;&lt;p&gt;In order to connect to Redis with TLS support, you need to specify the following connection options:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ConnectionOptions opts;&#xA;opts.host = &#34;127.0.0.1&#34;;&#xA;opts.port = 6379;&#xA;&#xA;opts.tls.enabled = true;    // Required. `false` by default.&#xA;opts.tls.cert = &#34;/path/to/client/certificate&#34;;  // Optional&#xA;opts.tls.key = &#34;/path/to/private/key/file&#34;; // Optional&#xA;opts.tls.cacert = &#34;/path/to/CA/certificate/file&#34;;   // You can also set `opts.tls.cacertdir` instead.&#xA;opts.tls.sni = &#34;server-name-indication&#34;;    // Optional&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Although &lt;code&gt;tls.cert&lt;/code&gt; and &lt;code&gt;tls.key&lt;/code&gt; are optional, if you specify one of them, you must also specify the other. Instead of specifying &lt;code&gt;tls.cacert&lt;/code&gt;, you can also specify &lt;code&gt;tls.cacertdir&lt;/code&gt; to the directory where certificates are stored.&lt;/p&gt; &#xA;&lt;p&gt;These options are the same as &lt;code&gt;redis-cli&lt;/code&gt;&#39;s TLS related command line arguments, so you can also run &lt;code&gt;redis-cli --help&lt;/code&gt; to get the detailed explanation of these options.&lt;/p&gt; &#xA;&lt;p&gt;Then you can use this &lt;code&gt;ConnectionOptions&lt;/code&gt; to create a &lt;code&gt;Redis&lt;/code&gt; object to connect to Redis server with TLS support.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: When building your application code, you also need to link it with &lt;code&gt;libhiredis.a&lt;/code&gt;, &lt;code&gt;libhiredis_ssl.a&lt;/code&gt;, &lt;code&gt;libredis++.a&lt;/code&gt; (or the corresponding shared libraries), &lt;code&gt;-lssl&lt;/code&gt; and &lt;code&gt;-lcrypto&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;Automatically Initialize OpenSSL Library&lt;/h5&gt; &#xA;&lt;p&gt;By default, &lt;em&gt;redis-plus-plus&lt;/em&gt; automatically initializes OpenSSL library, i.e. calls &lt;code&gt;SSL_library_init&lt;/code&gt; and initializes locks if needed. However, your application code might already initialize OpenSSL library. In this case, you can call &lt;code&gt;tls::disable_auto_init()&lt;/code&gt; to disable the initialization. You should call this function only once and call it before any other &lt;em&gt;redis-plus-plus&lt;/em&gt; operation. Otherwise, the behavior is undefined.&lt;/p&gt; &#xA;&lt;h3&gt;Send Command to Redis Server&lt;/h3&gt; &#xA;&lt;p&gt;You can send &lt;a href=&#34;https://redis.io/commands&#34;&gt;Redis commands&lt;/a&gt; through &lt;code&gt;Redis&lt;/code&gt; object. &lt;code&gt;Redis&lt;/code&gt; has one or more (overloaded) methods for each Redis command. The method has the same (lowercased) name as the corresponding command. For example, we have 3 overload methods for the &lt;code&gt;DEL key [key ...]&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Delete a single key.&#xA;long long Redis::del(const StringView &amp;amp;key);&#xA;&#xA;// Delete a batch of keys: [first, last).&#xA;template &amp;lt;typename Input&amp;gt;&#xA;long long Redis::del(Input first, Input last);&#xA;&#xA;// Delete keys in the initializer_list.&#xA;template &amp;lt;typename T&amp;gt;&#xA;long long Redis::del(std::initializer_list&amp;lt;T&amp;gt; il);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With input parameters, these methods build a Redis command based on &lt;a href=&#34;https://redis.io/topics/protocol&#34;&gt;Redis protocol&lt;/a&gt;, and send the command to Redis server. Then synchronously receive the reply, parse it, and return to the caller.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take a closer look at these methods&#39; parameters and return values.&lt;/p&gt; &#xA;&lt;h4&gt;Parameter Type&lt;/h4&gt; &#xA;&lt;p&gt;Most of these methods have the same parameters as the corresponding commands. The following is a list of parameter types:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Parameter Type&lt;/th&gt; &#xA;   &lt;th&gt;Explaination&lt;/th&gt; &#xA;   &lt;th&gt;Example&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;StringView&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parameters of string type. Normally used for key, value, member name, field name and so on&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;bool Redis::hset(const StringView &amp;amp;key, const StringView &amp;amp;field, const StringView &amp;amp;val)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#stringview&#34;&gt;StringView section&lt;/a&gt; for details on &lt;code&gt;StringView&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;long long&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parameters of integer type. Normally used for index (e.g. list commands) or integer&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;void ltrim(const StringView &amp;amp;key, long long start, long long stop)&lt;/strong&gt;&lt;/em&gt; &lt;br&gt; &lt;em&gt;&lt;strong&gt;long long decrby(const StringView &amp;amp;key, long long decrement)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;double&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Parameters of floating-point type. Normally used for score (e.g. sorted set commands) or number of floating-point type&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;double incrbyfloat(const StringView &amp;amp;key, double increment)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::chrono::duration&lt;/strong&gt; &lt;br&gt; &lt;strong&gt;std::chrono::time_point&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Time-related parameters&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;bool expire(const StringView &amp;amp;key, const std::chrono::seconds &amp;amp;timeout)&lt;/strong&gt;&lt;/em&gt; &lt;br&gt; &lt;em&gt;&lt;strong&gt;bool expireat(const StringView &amp;amp;key, const std::chrono::time_point&amp;lt;std::chrono::system_clock, std::chrono::seconds&amp;gt; &amp;amp;tp)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::pair&amp;lt;StringView, StringView&amp;gt;&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Used for Redis hash&#39;s (field, value) pair&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;bool hset(const StringView &amp;amp;key, const std::pair&amp;lt;StringView, StringView&amp;gt; &amp;amp;item)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::pair&amp;lt;double, double&amp;gt;&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Used for Redis geo&#39;s (longitude, latitude) pair&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;OptionalLongLong georadius(const StringView &amp;amp;key, const std::pair&amp;lt;double, double&amp;gt; &amp;amp;location, double radius, GeoUnit unit, const StringView &amp;amp;destination, bool store_dist, long long count)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;pair of iterators&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use a pair of iterators to specify a range of input, so that we can pass the data in a STL container to these methods&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;template &amp;lt; typename Input &amp;gt;&lt;/strong&gt;&lt;/em&gt; &lt;br&gt; &lt;em&gt;&lt;strong&gt;long long del(Input first, Input last)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Throw an exception, if it&#39;s an empty range, i.e. &lt;em&gt;first == last&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::initializer_list&amp;lt; T &amp;gt;&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use an initializer list to specify a batch of input&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;template &amp;lt; typename T &amp;gt;&lt;/strong&gt;&lt;/em&gt; &lt;br&gt; &lt;em&gt;&lt;strong&gt;long long del(std::initializer_list&amp;lt; T &amp;gt; il)&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;some options&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Options for some commands&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;&lt;strong&gt;UpdateType&lt;/strong&gt;&lt;/em&gt;, &lt;em&gt;&lt;strong&gt;template &amp;lt; typename T &amp;gt; class BoundedInterval&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;See &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/command_options.h&#34;&gt;command_options.h&lt;/a&gt; for details&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h5&gt;StringView&lt;/h5&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/string/basic_string_view&#34;&gt;std::string_view&lt;/a&gt; is a good choice for read-only string parameter types. &lt;code&gt;std::string_view&lt;/code&gt; was however only introduced in the C++ 17 standard, so if you build &lt;em&gt;redis-plus-plus&lt;/em&gt; with the &lt;code&gt;-std=c++11&lt;/code&gt; (i.e. by specifying &lt;code&gt;-DREDIS_PLUS_PLUS_CXX_STANDARD=11&lt;/code&gt; with cmake command) or the &lt;code&gt;-std=c++14&lt;/code&gt; standard, a &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/cxx11/cxx_utils.h&#34;&gt;simple implementation&lt;/a&gt; of &lt;code&gt;std::string_view&lt;/code&gt;, called &lt;code&gt;StringView&lt;/code&gt;, is available. You could build &lt;em&gt;redis-plus-plus&lt;/em&gt; with the &lt;code&gt;-std=c++17&lt;/code&gt; standard (i.e. the default behavior), which will supply &lt;code&gt;std::string_view&lt;/code&gt; natively. The &lt;code&gt;StringView&lt;/code&gt; implementation will then be disregarded by aliasing it to &lt;code&gt;std::string_view&lt;/code&gt;. This is done inside the &lt;em&gt;redis-plus-plus&lt;/em&gt; library with: &lt;code&gt;using StringView = std::string_view&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Since there are conversions from &lt;code&gt;std::string&lt;/code&gt; and c-style string to &lt;code&gt;StringView&lt;/code&gt;, you can just pass &lt;code&gt;std::string&lt;/code&gt; or c-style string to methods that need a &lt;code&gt;StringView&lt;/code&gt; parameter.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// bool Redis::hset(const StringView &amp;amp;key, const StringView &amp;amp;field, const StringView &amp;amp;val)&#xA;&#xA;// Pass c-style string to StringView.&#xA;redis.hset(&#34;key&#34;, &#34;field&#34;, &#34;value&#34;);&#xA;&#xA;// Pass std::string to StringView.&#xA;std::string key = &#34;key&#34;;&#xA;std::string field = &#34;field&#34;;&#xA;std::string val = &#34;val&#34;;&#xA;redis.hset(key, field, val);&#xA;&#xA;// Mix std::string and c-style string.&#xA;redis.hset(key, field, &#34;value&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Return Type&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/protocol&#34;&gt;Redis protocol&lt;/a&gt; defines 5 kinds of replies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Status Reply&lt;/em&gt;: Also known as &lt;em&gt;Simple String Reply&lt;/em&gt;. It&#39;s a non-binary string reply.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Bulk String Reply&lt;/em&gt;: Binary safe string reply.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Integer Reply&lt;/em&gt;: Signed integer reply. Large enough to hold &lt;code&gt;long long&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Array Reply&lt;/em&gt;: (Nested) Array reply.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Error Reply&lt;/em&gt;: Non-binary string reply that gives error info.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also these replies might be &lt;em&gt;NULL&lt;/em&gt;. For instance, when you try to &lt;code&gt;GET&lt;/code&gt; the value of a nonexistent key, Redis returns a &lt;em&gt;NULL Bulk String Reply&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As we mentioned above, replies are parsed into return values of these methods. The following is a list of return types:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Return Type&lt;/th&gt; &#xA;   &lt;th&gt;Explaination&lt;/th&gt; &#xA;   &lt;th&gt;Example&lt;/th&gt; &#xA;   &lt;th&gt;Note&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Status Reply&lt;/em&gt; that should always return a string of &#34;OK&#34;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;RENAME&lt;/em&gt;, &lt;em&gt;SETEX&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::string&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Status Reply&lt;/em&gt; that NOT always return &#34;OK&#34;, and &lt;em&gt;Bulk String Reply&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;PING&lt;/em&gt;, &lt;em&gt;INFO&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;bool&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Integer Reply&lt;/em&gt; that always returns 0 or 1&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;EXPIRE&lt;/em&gt;, &lt;em&gt;HSET&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#boolean-return-value&#34;&gt;Boolean Return Value section&lt;/a&gt; for the meaning of a boolean return value&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;long long&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Integer Reply&lt;/em&gt; that not always return 0 or 1&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;DEL&lt;/em&gt;, &lt;em&gt;APPEND&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;double&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Bulk String Reply&lt;/em&gt; that represents a double&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;INCRBYFLOAT&lt;/em&gt;, &lt;em&gt;ZINCRBY&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::pair&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Array Reply&lt;/em&gt; with exactly 2 elements. Since the return value is always an array of 2 elements, we return the 2 elements as a &lt;code&gt;std::pair&lt;/code&gt;&#39;s first and second elements&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;BLPOP&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;std::tuple&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;Array Reply&lt;/em&gt; with fixed length and has more than 2 elements. Since length of the returned array is fixed, we return the array as a &lt;code&gt;std::tuple&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;BZPOPMAX&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;output iterator&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;General &lt;em&gt;Array Reply&lt;/em&gt; with non-fixed/dynamic length. We use STL-like interface to return this kind of array replies, so that you can insert the return value into a STL container easily&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;MGET&lt;/em&gt;, &lt;em&gt;LRANGE&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Also, sometimes the type of output iterator decides which options to send with the command. See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#command-overloads&#34;&gt;Examples section&lt;/a&gt; for details&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Optional&amp;lt; T &amp;gt;&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;For any reply of type &lt;code&gt;T&lt;/code&gt; that might be &lt;em&gt;NULL&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;GET&lt;/em&gt;, &lt;em&gt;LPOP&lt;/em&gt;, &lt;em&gt;BLPOP&lt;/em&gt;, &lt;em&gt;BZPOPMAX&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#optional&#34;&gt;Optional section&lt;/a&gt; for details on &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Variant&amp;lt; Args... &amp;gt;&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;For reply that might be of serval different types&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;MEMORY STATS&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;NOTE: so far, this type is only supported when compiling redis-plus-plus with C++ 17 standard. This is normally used with &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus#generic-command-interface&#34;&gt;generic command interface&lt;/a&gt;. See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#variant&#34;&gt;Variant section&lt;/a&gt; for details on &lt;code&gt;Variant&amp;lt;Args...&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;strong&gt;STL container&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;General &lt;em&gt;Array Reply&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;CONFIG GET&lt;/em&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Both &lt;em&gt;output iterator&lt;/em&gt; and &lt;em&gt;STL container&lt;/em&gt; are used for array reply. The difference is that &lt;em&gt;STL container&lt;/em&gt; is normally used with &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus#generic-command-interface&#34;&gt;generic command interface&lt;/a&gt;. See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#stl-container&#34;&gt;STL container section&lt;/a&gt; for example&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h5&gt;Boolean Return Value&lt;/h5&gt; &#xA;&lt;p&gt;The return type of some methods, e.g. &lt;code&gt;EXPIRE&lt;/code&gt;, &lt;code&gt;HSET&lt;/code&gt;, is &lt;code&gt;bool&lt;/code&gt;. If the method returns &lt;code&gt;false&lt;/code&gt;, it DOES NOT mean that &lt;code&gt;Redis&lt;/code&gt; failed to send the command to Redis server. Instead, it means that Redis server returns an &lt;em&gt;Integer Reply&lt;/em&gt;, and the value of the reply is &lt;code&gt;0&lt;/code&gt;. Accordingly, if the method returns &lt;code&gt;true&lt;/code&gt;, it means that Redis server returns an &lt;em&gt;Integer Reply&lt;/em&gt;, and the value of the reply is &lt;code&gt;1&lt;/code&gt;. You can check &lt;a href=&#34;http://redis.io/commands&#34;&gt;Redis commands manual&lt;/a&gt; for what do &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; stand for.&lt;/p&gt; &#xA;&lt;p&gt;For example, when we send &lt;code&gt;EXPIRE&lt;/code&gt; command to Redis server, it returns &lt;code&gt;1&lt;/code&gt; if the timeout was set, and it returns &lt;code&gt;0&lt;/code&gt; if the key doesn&#39;t exist. Accordingly, if the timeout was set, &lt;code&gt;Redis::expire&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, and if the key doesn&#39;t exist, &lt;code&gt;Redis::expire&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So, never use the return value to check if the command has been successfully sent to Redis server. Instead, if &lt;code&gt;Redis&lt;/code&gt; failed to send command to server, it throws an exception of type &lt;code&gt;Error&lt;/code&gt;. See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#exception&#34;&gt;Exception section&lt;/a&gt; for details on exceptions.&lt;/p&gt; &#xA;&lt;h5&gt;Optional&lt;/h5&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/optional&#34;&gt;std::optional&lt;/a&gt; is a good option for return type, if Redis might return &lt;em&gt;NULL REPLY&lt;/em&gt;. However, &lt;code&gt;std::optional&lt;/code&gt; is introduced in C++ 17 standard, and if you build &lt;em&gt;redis-plus-plus&lt;/em&gt; with &lt;code&gt;-std=c++11&lt;/code&gt; standard (i.e. by specifying &lt;code&gt;-DREDIS_PLUS_PLUS_CXX_STANDARD=11&lt;/code&gt; with cmake command), we implement our own &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/cxx11/cxx_utils.h&#34;&gt;simple version&lt;/a&gt;, i.e. &lt;code&gt;template Optional&amp;lt;T&amp;gt;&lt;/code&gt;. Instead, if you build &lt;em&gt;redis-plus-plus&lt;/em&gt; with &lt;code&gt;-std=c++17&lt;/code&gt; standard (i.e. the default behavior), you can use &lt;code&gt;std::optional&lt;/code&gt;, and we have an alias for it: &lt;code&gt;template &amp;lt;typename T&amp;gt; using Optional = std::optional&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Take the &lt;a href=&#34;https://redis.io/commands/get&#34;&gt;GET&lt;/a&gt; and &lt;a href=&#34;https://redis.io/commands/mget&#34;&gt;MGET&lt;/a&gt; commands for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Or just: auto val = redis.get(&#34;key&#34;);&#xA;Optional&amp;lt;std::string&amp;gt; val = redis.get(&#34;key&#34;);&#xA;&#xA;// Optional&amp;lt;T&amp;gt; has a conversion to bool.&#xA;// If it&#39;s NOT a null Optional&amp;lt;T&amp;gt; object, it&#39;s converted to true.&#xA;// Otherwise, it&#39;s converted to false.&#xA;if (val) {&#xA;    // Key exists. Dereference val to get the string result.&#xA;    std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;} else {&#xA;    // Redis server returns a NULL Bulk String Reply.&#xA;    // It&#39;s invalid to dereference a null Optional&amp;lt;T&amp;gt; object.&#xA;    std::cout &amp;lt;&amp;lt; &#34;key doesn&#39;t exist.&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;std::vector&amp;lt;Optional&amp;lt;std::string&amp;gt;&amp;gt; values;&#xA;redis.mget({&#34;key1&#34;, &#34;key2&#34;, &#34;key3&#34;}, std::back_inserter(values));&#xA;for (const auto &amp;amp;val : values) {&#xA;    if (val) {&#xA;        // Key exist, process the value.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We also have some typedefs for some commonly used &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;using OptionalString = Optional&amp;lt;std::string&amp;gt;;&#xA;&#xA;using OptionalLongLong = Optional&amp;lt;long long&amp;gt;;&#xA;&#xA;using OptionalDouble = Optional&amp;lt;double&amp;gt;;&#xA;&#xA;using OptionalStringPair = Optional&amp;lt;std::pair&amp;lt;std::string, std::string&amp;gt;&amp;gt;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Variant&lt;/h5&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/utility/variant&#34;&gt;std::variant&lt;/a&gt; is a good option for return type, if the reply might be of different types. For example, the &lt;code&gt;MEMORY STATS&lt;/code&gt; command returns an array reply, which is, in fact, a map of key-value pairs of configurations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;127.0.0.1:6379&amp;gt; memory stats&#xA; 1) &#34;peak.allocated&#34;&#xA; 2) (integer) 4471104&#xA; ...&#xA;17) &#34;db.0&#34;&#xA;18) 1) &#34;overhead.hashtable.main&#34;&#xA;    2) (integer) 104&#xA;    3) &#34;overhead.hashtable.expires&#34;&#xA;    4) (integer) 32&#xA;...&#xA;27) &#34;dataset.percentage&#34;&#xA;28) &#34;9.70208740234375&#34;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, as you can see, the value part of the result might be of type long long (key: &lt;em&gt;peak.allocated&lt;/em&gt;), double (key: &lt;em&gt;dataset.percentage&lt;/em&gt;) or even a map (key: &lt;em&gt;db.0&lt;/em&gt;). So you cannot simply parse the result into a &lt;code&gt;std::unordered_map&amp;lt;std::string, long long&amp;gt;&lt;/code&gt; or &lt;code&gt;std::unordered_map&amp;lt;std::string, double&amp;gt;&lt;/code&gt;. A workaround is to parse the result into a &lt;code&gt;tuple&lt;/code&gt;, however, this tuple solution is ugly and error-prone. Check &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/138&#34;&gt;this issue&lt;/a&gt; for detail.&lt;/p&gt; &#xA;&lt;p&gt;In this case, &lt;code&gt;Variant&lt;/code&gt;, which is a typedef of &lt;code&gt;std::variant&lt;/code&gt; if you build redis-plus-plus with C++17 standard, is very helpful. You can parse the result into a &lt;code&gt;std::unordered_map&amp;lt;std::string, Variant&amp;lt;double, long long, std::unordered_map&amp;lt;std::string, long long&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;using Var = Variant&amp;lt;double, long long, std::unordered_map&amp;lt;std::string, long long&amp;gt;&amp;gt;;&#xA;auto r = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;auto v = r.command&amp;lt;std::unordered_map&amp;lt;std::string, Var&amp;gt;&amp;gt;(&#34;memory&#34;, &#34;stats&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There&#39;re some limitations on &lt;code&gt;Variant&lt;/code&gt; support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The type arguments of &lt;code&gt;Variant&lt;/code&gt;, cannot have duplicate items, e.g. &lt;code&gt;Variant&amp;lt;double, long long, double&amp;gt;&lt;/code&gt; won&#39;t work.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;double&lt;/code&gt; must be placed before &lt;code&gt;std::string&lt;/code&gt;. Because &lt;code&gt;double&lt;/code&gt; reply is, in fact, string reply, and when parsing variant, we try to parse the reply into the first matched type, specified with the type arguments from left to right. So if &lt;code&gt;double&lt;/code&gt; is placed after &lt;code&gt;std::string&lt;/code&gt;, i.e. on the right side of &lt;code&gt;std::string&lt;/code&gt;, the reply will always be parsed into &lt;code&gt;std::string&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also check the &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus#generic-command-interface&#34;&gt;generic command section&lt;/a&gt; for more examples on generic command interface.&lt;/p&gt; &#xA;&lt;h5&gt;STL container&lt;/h5&gt; &#xA;&lt;p&gt;When using generic command interface, instead of parsing the reply to output iterator, you can also parse it into a STL container.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto r = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;auto v = r.command&amp;lt;std::unordered_map&amp;lt;std::string, std::string&amp;gt;&amp;gt;(&#34;config&#34;, &#34;get&#34;, &#34;*&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also check the &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus#generic-command-interface&#34;&gt;generic command section&lt;/a&gt; for more examples on generic command interface.&lt;/p&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;p&gt;Let&#39;s see some examples on how to send commands to Redis server.&lt;/p&gt; &#xA;&lt;h5&gt;Various Parameter Types&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// ***** Parameters of StringView type *****&#xA;&#xA;// Implicitly construct StringView with c-style string.&#xA;redis.set(&#34;key&#34;, &#34;value&#34;);&#xA;&#xA;// Implicitly construct StringView with std::string.&#xA;std::string key(&#34;key&#34;);&#xA;std::string val(&#34;value&#34;);&#xA;redis.set(key, val);&#xA;&#xA;// Explicitly pass StringView as parameter.&#xA;std::vector&amp;lt;char&amp;gt; large_data;&#xA;// Avoid copying.&#xA;redis.set(&#34;key&#34;, StringView(large_data.data(), large_data.size()));&#xA;&#xA;// ***** Parameters of long long type *****&#xA;&#xA;// For index.&#xA;redis.bitcount(key, 1, 3);&#xA;&#xA;// For number.&#xA;redis.incrby(&#34;num&#34;, 100);&#xA;&#xA;// ***** Parameters of double type *****&#xA;&#xA;// For score.&#xA;redis.zadd(&#34;zset&#34;, &#34;m1&#34;, 2.5);&#xA;redis.zadd(&#34;zset&#34;, &#34;m2&#34;, 3.5);&#xA;redis.zadd(&#34;zset&#34;, &#34;m3&#34;, 5);&#xA;&#xA;// For (longitude, latitude).&#xA;redis.geoadd(&#34;geo&#34;, std::make_tuple(&#34;member&#34;, 13.5, 15.6));&#xA;&#xA;// ***** Time-related parameters *****&#xA;&#xA;using namespace std::chrono;&#xA;&#xA;redis.expire(key, seconds(1000));&#xA;&#xA;auto tp = time_point_cast&amp;lt;seconds&amp;gt;(system_clock::now() + seconds(100));&#xA;redis.expireat(key, tp);&#xA;&#xA;// ***** Some options for commands *****&#xA;&#xA;if (redis.set(key, &#34;value&#34;, milliseconds(100), UpdateType::NOT_EXIST)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;set OK&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;redis.linsert(&#34;list&#34;, InsertPosition::BEFORE, &#34;pivot&#34;, &#34;val&#34;);&#xA;&#xA;std::vector&amp;lt;std::string&amp;gt; res;&#xA;&#xA;// (-inf, inf)&#xA;redis.zrangebyscore(&#34;zset&#34;, UnboundedInterval&amp;lt;double&amp;gt;{}, std::back_inserter(res));&#xA;&#xA;// [3, 6]&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    BoundedInterval&amp;lt;double&amp;gt;(3, 6, BoundType::CLOSED),&#xA;    std::back_inserter(res));&#xA;&#xA;// (3, 6]&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    BoundedInterval&amp;lt;double&amp;gt;(3, 6, BoundType::LEFT_OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// (3, 6)&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    BoundedInterval&amp;lt;double&amp;gt;(3, 6, BoundType::OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// [3, 6)&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    BoundedInterval&amp;lt;double&amp;gt;(3, 6, BoundType::RIGHT_OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// [3, +inf)&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    LeftBoundedInterval&amp;lt;double&amp;gt;(3, BoundType::RIGHT_OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// (3, +inf)&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    LeftBoundedInterval&amp;lt;double&amp;gt;(3, BoundType::OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// (-inf, 6]&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    RightBoundedInterval&amp;lt;double&amp;gt;(6, BoundType::LEFT_OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// (-inf, 6)&#xA;redis.zrangebyscore(&#34;zset&#34;,&#xA;    RightBoundedInterval&amp;lt;double&amp;gt;(6, BoundType::OPEN),&#xA;    std::back_inserter(res));&#xA;&#xA;// ***** Pair of iterators *****&#xA;&#xA;std::vector&amp;lt;std::pair&amp;lt;std::string, std::string&amp;gt;&amp;gt; kvs = {{&#34;k1&#34;, &#34;v1&#34;}, {&#34;k2&#34;, &#34;v2&#34;}, {&#34;k3&#34;, &#34;v3&#34;}};&#xA;redis.mset(kvs.begin(), kvs.end());&#xA;&#xA;std::unordered_map&amp;lt;std::string, std::string&amp;gt; kv_map = {{&#34;k1&#34;, &#34;v1&#34;}, {&#34;k2&#34;, &#34;v2&#34;}, {&#34;k3&#34;, &#34;v3&#34;}};&#xA;redis.mset(kv_map.begin(), kv_map.end());&#xA;&#xA;std::unordered_map&amp;lt;std::string, std::string&amp;gt; str_map = {{&#34;f1&#34;, &#34;v1&#34;}, {&#34;f2&#34;, &#34;v2&#34;}, {&#34;f3&#34;, &#34;v3&#34;}};&#xA;redis.hmset(&#34;hash&#34;, str_map.begin(), str_map.end());&#xA;&#xA;std::unordered_map&amp;lt;std::string, double&amp;gt; score_map = {{&#34;m1&#34;, 20}, {&#34;m2&#34;, 12.5}, {&#34;m3&#34;, 3.14}};&#xA;redis.zadd(&#34;zset&#34;, score_map.begin(), score_map.end());&#xA;&#xA;std::vector&amp;lt;std::string&amp;gt; keys = {&#34;k1&#34;, &#34;k2&#34;, &#34;k3&#34;};&#xA;redis.del(keys.begin(), keys.end());&#xA;&#xA;// ***** Parameters of initializer_list type *****&#xA;&#xA;redis.mset({&#xA;    std::make_pair(&#34;k1&#34;, &#34;v1&#34;),&#xA;    std::make_pair(&#34;k2&#34;, &#34;v2&#34;),&#xA;    std::make_pair(&#34;k3&#34;, &#34;v3&#34;)&#xA;});&#xA;&#xA;redis.hmset(&#34;hash&#34;,&#xA;    {&#xA;        std::make_pair(&#34;f1&#34;, &#34;v1&#34;),&#xA;        std::make_pair(&#34;f2&#34;, &#34;v2&#34;),&#xA;        std::make_pair(&#34;f3&#34;, &#34;v3&#34;)&#xA;    });&#xA;&#xA;redis.zadd(&#34;zset&#34;,&#xA;    {&#xA;        std::make_pair(&#34;m1&#34;, 20.0),&#xA;        std::make_pair(&#34;m2&#34;, 34.5),&#xA;        std::make_pair(&#34;m3&#34;, 23.4)&#xA;    });&#xA;&#xA;redis.del({&#34;k1&#34;, &#34;k2&#34;, &#34;k3&#34;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Various Return Types&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// ***** Return void *****&#xA;&#xA;redis.save();&#xA;&#xA;// ***** Return std::string *****&#xA;&#xA;auto info = redis.info();&#xA;&#xA;// ***** Return bool *****&#xA;&#xA;if (!redis.expire(&#34;nonexistent&#34;, std::chrono::seconds(100))) {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;key doesn&#39;t exist&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;if (redis.setnx(&#34;key&#34;, &#34;val&#34;)) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;set OK&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// ***** Return long long *****&#xA;&#xA;auto len = redis.strlen(&#34;key&#34;);&#xA;auto num = redis.del({&#34;a&#34;, &#34;b&#34;, &#34;c&#34;});&#xA;num = redis.incr(&#34;a&#34;);&#xA;&#xA;// ***** Return double *****&#xA;&#xA;auto real = redis.incrbyfloat(&#34;b&#34;, 23.4);&#xA;real = redis.hincrbyfloat(&#34;c&#34;, &#34;f&#34;, 34.5);&#xA;&#xA;// ***** Return Optional&amp;lt;std::string&amp;gt;, i.e. OptionalString *****&#xA;&#xA;auto os = redis.get(&#34;kk&#34;);&#xA;if (os) {&#xA;    std::cout &amp;lt;&amp;lt; *os &amp;lt;&amp;lt; std::endl;&#xA;} else {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;key doesn&#39;t exist&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;os = redis.spop(&#34;set&#34;);&#xA;if (os) {&#xA;    std::cout &amp;lt;&amp;lt; *os &amp;lt;&amp;lt; std::endl;&#xA;} else {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;set is empty&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// ***** Return Optional&amp;lt;long long&amp;gt;, i.e. OptionalLongLong *****&#xA;&#xA;auto oll = redis.zrank(&#34;zset&#34;, &#34;mem&#34;);&#xA;if (oll) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;rank is &#34; &amp;lt;&amp;lt; *oll &amp;lt;&amp;lt; std::endl;&#xA;} else {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;member doesn&#39;t exist&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// ***** Return Optional&amp;lt;double&amp;gt;, i.e. OptionalDouble *****&#xA;&#xA;auto ob = redis.zscore(&#34;zset&#34;, &#34;m1&#34;);&#xA;if (ob) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;score is &#34; &amp;lt;&amp;lt; *ob &amp;lt;&amp;lt; std::endl;&#xA;} else {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;member doesn&#39;t exist&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// ***** Return Optional&amp;lt;pair&amp;lt;string, string&amp;gt;&amp;gt; *****&#xA;&#xA;auto op = redis.blpop({&#34;list1&#34;, &#34;list2&#34;}, std::chrono::seconds(2));&#xA;if (op) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;key is &#34; &amp;lt;&amp;lt; op-&amp;gt;first &amp;lt;&amp;lt; &#34;, value is &#34; &amp;lt;&amp;lt; op-&amp;gt;second &amp;lt;&amp;lt; std::endl;&#xA;} else {&#xA;    std::cerr &amp;lt;&amp;lt; &#34;timeout&#34; &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// ***** Output iterators *****&#xA;&#xA;std::vector&amp;lt;OptionalString&amp;gt; os_vec;&#xA;redis.mget({&#34;k1&#34;, &#34;k2&#34;, &#34;k3&#34;}, std::back_inserter(os_vec));&#xA;&#xA;std::vector&amp;lt;std::string&amp;gt; s_vec;&#xA;redis.lrange(&#34;list&#34;, 0, -1, std::back_inserter(s_vec));&#xA;&#xA;std::unordered_map&amp;lt;std::string, std::string&amp;gt; hash;&#xA;redis.hgetall(&#34;hash&#34;, std::inserter(hash, hash.end()));&#xA;// You can also save the result in a vecotr of string pair.&#xA;std::vector&amp;lt;std::pair&amp;lt;std::string, std::string&amp;gt;&amp;gt; hash_vec;&#xA;redis.hgetall(&#34;hash&#34;, std::back_inserter(hash_vec));&#xA;&#xA;std::unordered_set&amp;lt;std::string&amp;gt; str_set;&#xA;redis.smembers(&#34;s1&#34;, std::inserter(str_set, str_set.end()));&#xA;// You can also save the result in a vecotr of string.&#xA;s_vec.clear();&#xA;redis.smembers(&#34;s1&#34;, std::back_inserter(s_vec));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;SCAN Commands&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto cursor = 0LL;&#xA;auto pattern = &#34;*pattern*&#34;;&#xA;auto count = 5;&#xA;std::unordered_set&amp;lt;std::string&amp;gt; keys;&#xA;while (true) {&#xA;    cursor = redis.scan(cursor, pattern, count, std::inserter(keys, keys.begin()));&#xA;    // Default pattern is &#34;*&#34;, and default count is 10&#xA;    // cursor = redis.scan(cursor, std::inserter(keys, keys.begin()));&#xA;&#xA;    if (cursor == 0) {&#xA;        break;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Command Overloads&lt;/h5&gt; &#xA;&lt;p&gt;Sometimes the type of output iterator decides which options to send with the command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// If the output iterator is an iterator of a container of string,&#xA;// we send *ZRANGE* command without the *WITHSCORES* option.&#xA;std::vector&amp;lt;std::string&amp;gt; members;&#xA;redis.zrange(&#34;list&#34;, 0, -1, std::back_inserter(members));&#xA;&#xA;// If it&#39;s an iterator of a container of a &amp;lt;string, double&amp;gt; pair,&#xA;// we send *ZRANGE* command with *WITHSCORES* option.&#xA;std::vector&amp;lt;std::pair&amp;lt;std::string, double&amp;gt;&amp;gt; res_with_score;&#xA;redis.zrange(&#34;list&#34;, 0, -1, std::back_inserter(res_with_score));&#xA;&#xA;// The above examples also apply to other command with the *WITHSCORES* options,&#xA;// e.g. *ZRANGEBYSCORE*, *ZREVRANGE*, *ZREVRANGEBYSCORE*.&#xA;&#xA;// Another example is the *GEORADIUS* command.&#xA;&#xA;// Only get members.&#xA;members.clear();&#xA;redis.georadius(&#34;geo&#34;,&#xA;            std::make_pair(10.1, 11.1),&#xA;            100,&#xA;            GeoUnit::KM,&#xA;            10,&#xA;            true,&#xA;            std::back_inserter(members));&#xA;&#xA;// If the iterator is an iterator of a container of tuple&amp;lt;string, double&amp;gt;,&#xA;// we send the *GEORADIUS* command with *WITHDIST* option.&#xA;std::vector&amp;lt;std::tuple&amp;lt;std::string, double&amp;gt;&amp;gt; mem_with_dist;&#xA;redis.georadius(&#34;geo&#34;,&#xA;            std::make_pair(10.1, 11.1),&#xA;            100,&#xA;            GeoUnit::KM,&#xA;            10,&#xA;            true,&#xA;            std::back_inserter(mem_with_dist));&#xA;&#xA;// If the iterator is an iterator of a container of tuple&amp;lt;string, double, string&amp;gt;,&#xA;// we send the *GEORADIUS* command with *WITHDIST* and *WITHHASH* options.&#xA;std::vector&amp;lt;std::tuple&amp;lt;std::string, double, std::string&amp;gt;&amp;gt; mem_with_dist_hash;&#xA;redis.georadius(&#34;geo&#34;,&#xA;            std::make_pair(10.1, 11.1),&#xA;            100,&#xA;            GeoUnit::KM,&#xA;            10,&#xA;            true,&#xA;            std::back_inserter(mem_with_dist_hash));&#xA;&#xA;// If the iterator is an iterator of a container of&#xA;// tuple&amp;lt;string, string, pair&amp;lt;double, double&amp;gt;, double&amp;gt;,&#xA;// we send the *GEORADIUS* command with *WITHHASH*, *WITHCOORD* and *WITHDIST* options.&#xA;std::vector&amp;lt;std::tuple&amp;lt;std::string, double, std::string&amp;gt;&amp;gt; mem_with_hash_coord_dist;&#xA;redis.georadius(&#34;geo&#34;,&#xA;            std::make_pair(10.1, 11.1),&#xA;            100,&#xA;            GeoUnit::KM,&#xA;            10,&#xA;            true,&#xA;            std::back_inserter(mem_with_hash_coord_dist));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/redis.h&#34;&gt;redis.h&lt;/a&gt; for doxygen style API references and examples, and see the &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/tree/master/test/src/sw/redis%2B%2B&#34;&gt;tests&lt;/a&gt; for other examples.&lt;/p&gt; &#xA;&lt;h3&gt;Exception&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; throws exceptions if it receives an &lt;em&gt;Error Reply&lt;/em&gt; or something bad happens, e.g. failed to create a connection to server, or connection to server is broken. All exceptions derived from &lt;code&gt;Error&lt;/code&gt; class. See &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/errors.h&#34;&gt;errors.h&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Error&lt;/code&gt;: Generic error. It&#39;s derived from &lt;code&gt;std::exception&lt;/code&gt;, and it&#39;s also the base class of other exceptions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IoError&lt;/code&gt;: There&#39;s some IO error with the connection.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;TimeoutError&lt;/code&gt;: Read or write operation was timed out. It&#39;s a derived class of &lt;code&gt;IoError&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ClosedError&lt;/code&gt;: Redis server closed the connection.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ProtoError&lt;/code&gt;: The command or reply is invalid, and we cannot process it with Redis protocol.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;OomError&lt;/code&gt;: &lt;em&gt;hiredis&lt;/em&gt; library got an out-of-memory error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ReplyError&lt;/code&gt;: Redis server returned an error reply, e.g. we try to call &lt;code&gt;redis::lrange&lt;/code&gt; on a Redis hash.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;WatchError&lt;/code&gt;: Watched key has been modified. See &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#watch&#34;&gt;Watch section&lt;/a&gt; for details.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;em&gt;NULL REPLY&lt;/em&gt; is not taken as an exception. For example, if we try to &lt;code&gt;GET&lt;/code&gt; a non-existent key, we&#39;ll get a &lt;em&gt;NULL Bulk String Reply&lt;/em&gt;. Instead of throwing an exception, we return the &lt;em&gt;NULL REPLY&lt;/em&gt; as a null &lt;code&gt;Optional&amp;lt;T&amp;gt;&lt;/code&gt; object. Also see &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#optional&#34;&gt;Optional section&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Normally, when exception happens, you don&#39;t need to create a &lt;code&gt;Redis&lt;/code&gt; object. It&#39;s exception safe, and you can reuse the &lt;code&gt;Redis&lt;/code&gt; object. Even if the connection to Redis server is broken, and it throws some exception, say, &lt;code&gt;IoError&lt;/code&gt;. The next time when you send command with the &lt;code&gt;Redis&lt;/code&gt; object, it will try to reconnect to Redis server automatically. This rule also applies to &lt;code&gt;RedisCluster&lt;/code&gt;. However, if &lt;code&gt;Pipeline&lt;/code&gt;, &lt;code&gt;Transcation&lt;/code&gt; and &lt;code&gt;Subscriber&lt;/code&gt; throws exception, you need to destroy the object, and create a new one. See the corresponding documentation for details.&lt;/p&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;p&gt;The following is an example on how to catch these exceptions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;try {&#xA;    redis.set(&#34;key&#34;, &#34;value&#34;);&#xA;&#xA;    // Wrong type error&#xA;    redis.lpush(&#34;key&#34;, {&#34;a&#34;, &#34;b&#34;, &#34;c&#34;});&#xA;} catch (const ReplyError &amp;amp;err) {&#xA;    // WRONGTYPE Operation against a key holding the wrong kind of value&#xA;    cout &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; endl;&#xA;} catch (const TimeoutError &amp;amp;err) {&#xA;    // reading or writing timeout&#xA;} catch (const ClosedError &amp;amp;err) {&#xA;    // the connection has been closed.&#xA;} catch (const IoError &amp;amp;err) {&#xA;    // there&#39;s an IO error on the connection.&#xA;} catch (const Error &amp;amp;err) {&#xA;   // other errors&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generic Command Interface&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;re too many Redis commands, we haven&#39;t implemented all of them. However, you can use the generic &lt;code&gt;Redis::command&lt;/code&gt; methods to send any commands to Redis. Unlike other client libraries, &lt;code&gt;Redis::command&lt;/code&gt; doesn&#39;t use format string to combine command arguments into a command string. Instead, you can directly pass command arguments of &lt;code&gt;StringView&lt;/code&gt; type or arithmetic type as parameters of &lt;code&gt;Redis::command&lt;/code&gt;. For the reason why we don&#39;t use format string, please see &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/pull/2&#34;&gt;this discussion&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto redis = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;// Redis class doesn&#39;t have built-in *CLIENT SETNAME* method.&#xA;// However, you can use Redis::command to send the command manually.&#xA;redis.command&amp;lt;void&amp;gt;(&#34;client&#34;, &#34;setname&#34;, &#34;name&#34;);&#xA;auto val = redis.command&amp;lt;OptionalString&amp;gt;(&#34;client&#34;, &#34;getname&#34;);&#xA;if (val) {&#xA;    std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// NOTE: the following code is for example only. In fact, Redis has built-in&#xA;// methods for the following commands.&#xA;&#xA;// Arguments of the command can be strings.&#xA;// NOTE: for SET command, the return value is NOT always void, I&#39;ll explain latter.&#xA;redis.command&amp;lt;void&amp;gt;(&#34;set&#34;, &#34;key&#34;, &#34;100&#34;);&#xA;&#xA;// Arguments of the command can be a combination of strings and integers.&#xA;auto num = redis.command&amp;lt;long long&amp;gt;(&#34;incrby&#34;, &#34;key&#34;, 1);&#xA;&#xA;// Argument can also be double.&#xA;auto real = redis.command&amp;lt;double&amp;gt;(&#34;incrbyfloat&#34;, &#34;key&#34;, 2.3);&#xA;&#xA;// Even the key of the command can be of arithmetic type.&#xA;redis.command&amp;lt;void&amp;gt;(&#34;set&#34;, 100, &#34;value&#34;);&#xA;&#xA;val = redis.command&amp;lt;OptionalString&amp;gt;(&#34;get&#34;, 100);&#xA;&#xA;// If the command returns an array of elements.&#xA;std::vector&amp;lt;OptionalString&amp;gt; result;&#xA;redis.command(&#34;mget&#34;, &#34;k1&#34;, &#34;k2&#34;, &#34;k3&#34;, std::back_inserter(result));&#xA;&#xA;// Or just parse it into a vector.&#xA;result = redis.command&amp;lt;std::vector&amp;lt;OptionalString&amp;gt;&amp;gt;(&#34;mget&#34;, &#34;k1&#34;, &#34;k2&#34;, &#34;k3&#34;);&#xA;&#xA;// Arguments of the command can be a range of strings.&#xA;auto set_cmd_strs = {&#34;set&#34;, &#34;key&#34;, &#34;value&#34;};&#xA;redis.command&amp;lt;void&amp;gt;(set_cmd_strs.begin(), set_cmd_strs.end());&#xA;&#xA;auto get_cmd_strs = {&#34;get&#34;, &#34;key&#34;};&#xA;val = redis.command&amp;lt;OptionalString&amp;gt;(get_cmd_strs.begin(), get_cmd_strs.end());&#xA;&#xA;// If it returns an array of elements.&#xA;result.clear();&#xA;auto mget_cmd_strs = {&#34;mget&#34;, &#34;key1&#34;, &#34;key2&#34;};&#xA;redis.command(mget_cmd_strs.begin(), mget_cmd_strs.end(), std::back_inserter(result));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The name of some Redis commands is composed with two strings, e.g. &lt;em&gt;CLIENT SETNAME&lt;/em&gt;. In this case, you need to pass these two strings as two arguments for &lt;code&gt;Redis::command&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// This is GOOD.&#xA;redis.command&amp;lt;void&amp;gt;(&#34;client&#34;, &#34;setname&#34;, &#34;name&#34;);&#xA;&#xA;// This is BAD, and will fail to send command to Redis server.&#xA;// redis.command&amp;lt;void&amp;gt;(&#34;client setname&#34;, &#34;name&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As I mentioned in the comments, the &lt;code&gt;SET&lt;/code&gt; command not always returns &lt;code&gt;void&lt;/code&gt;. Because if you try to set a (key, value) pair with &lt;em&gt;NX&lt;/em&gt; or &lt;em&gt;XX&lt;/em&gt; option, you might fail, and Redis will return a &lt;em&gt;NULL REPLY&lt;/em&gt;. Besides the &lt;code&gt;SET&lt;/code&gt; command, there&#39;re other commands whose return value is NOT a fixed type, you need to parse it by yourself. For example, &lt;code&gt;Redis::set&lt;/code&gt; method rewrite the reply of &lt;code&gt;SET&lt;/code&gt; command, and make it return &lt;code&gt;bool&lt;/code&gt; type, i.e. if no &lt;em&gt;NX&lt;/em&gt; or &lt;em&gt;XX&lt;/em&gt; option specified, Redis server will always return an &#34;OK&#34; string, and &lt;code&gt;Redis::set&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;; if &lt;em&gt;NX&lt;/em&gt; or &lt;em&gt;XX&lt;/em&gt; specified, and Redis server returns a &lt;em&gt;NULL REPLY&lt;/em&gt;, &lt;code&gt;Redis::set&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;So &lt;code&gt;Redis&lt;/code&gt; class also has other overloaded &lt;code&gt;command&lt;/code&gt; methods, these methods return a &lt;code&gt;ReplyUPtr&lt;/code&gt;, i.e. &lt;code&gt;std::unique_ptr&amp;lt;redisReply, ReplyDeleter&amp;gt;&lt;/code&gt;, object. Normally you don&#39;t need to parse it manually. Instead, you only need to pass the reply to &lt;code&gt;template &amp;lt;typename T&amp;gt; T reply::parse(redisReply &amp;amp;)&lt;/code&gt; to get a value of type &lt;code&gt;T&lt;/code&gt;. Check the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#return-type&#34;&gt;Return Type section&lt;/a&gt; for valid &lt;code&gt;T&lt;/code&gt; types. If the command returns an array of elements, besides calling &lt;code&gt;reply::parse&lt;/code&gt; to parse the reply to an STL container, you can also call &lt;code&gt;template &amp;lt;typename Output&amp;gt; reply::to_array(redisReply &amp;amp;reply, Output output)&lt;/code&gt; to parse the result into an array or STL container with an output iterator.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s rewrite the above examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto redis = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;redis.command(&#34;client&#34;, &#34;setname&#34;, &#34;name&#34;);&#xA;auto r = redis.command(&#34;client&#34;, &#34;getname&#34;);&#xA;assert(r);&#xA;&#xA;// If the command returns a single element,&#xA;// use `reply::parse&amp;lt;T&amp;gt;(redisReply&amp;amp;)` to parse it.&#xA;auto val = reply::parse&amp;lt;OptionalString&amp;gt;(*r);&#xA;if (val) {&#xA;    std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// Arguments of the command can be strings.&#xA;redis.command(&#34;set&#34;, &#34;key&#34;, &#34;100&#34;);&#xA;&#xA;// Arguments of the command can be a combination of strings and integers.&#xA;r = redis.command(&#34;incrby&#34;, &#34;key&#34;, 1);&#xA;auto num = reply::parse&amp;lt;long long&amp;gt;(*r);&#xA;&#xA;// Argument can also be double.&#xA;r = redis.command(&#34;incrbyfloat&#34;, &#34;key&#34;, 2.3);&#xA;auto real = reply::parse&amp;lt;double&amp;gt;(*r);&#xA;&#xA;// Even the key of the command can be of arithmetic type.&#xA;redis.command(&#34;set&#34;, 100, &#34;value&#34;);&#xA;&#xA;r = redis.command(&#34;get&#34;, 100);&#xA;val = reply::parse&amp;lt;OptionalString&amp;gt;(*r);&#xA;&#xA;// If the command returns an array of elements.&#xA;r = redis.command(&#34;mget&#34;, &#34;k1&#34;, &#34;k2&#34;, &#34;k3&#34;);&#xA;// Use `reply::to_array(redisReply&amp;amp;, OutputIterator)` to parse the result into an STL container.&#xA;std::vector&amp;lt;OptionalString&amp;gt; result;&#xA;reply::to_array(*r, std::back_inserter(result));&#xA;&#xA;// Or just call `reply::parse` to parse it into vector.&#xA;result = reply::parse&amp;lt;std::vector&amp;lt;OptionalString&amp;gt;&amp;gt;(*r);&#xA;&#xA;// Arguments of the command can be a range of strings.&#xA;auto get_cmd_strs = {&#34;get&#34;, &#34;key&#34;};&#xA;r = redis.command(get_cmd_strs.begin(), get_cmd_strs.end());&#xA;val = reply::parse&amp;lt;OptionalString&amp;gt;(*r);&#xA;&#xA;// If it returns an array of elements.&#xA;result.clear();&#xA;auto mget_cmd_strs = {&#34;mget&#34;, &#34;key1&#34;, &#34;key2&#34;};&#xA;r = redis.command(mget_cmd_strs.begin(), mget_cmd_strs.end());&#xA;reply::to_array(*r, std::back_inserter(result));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In fact, there&#39;s one more &lt;code&gt;Redis::command&lt;/code&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;template &amp;lt;typename Cmd, typename ...Args&amp;gt;&#xA;auto command(Cmd cmd, Args &amp;amp;&amp;amp;...args)&#xA;    -&amp;gt; typename std::enable_if&amp;lt;!std::is_convertible&amp;lt;Cmd, StringView&amp;gt;::value, ReplyUPtr&amp;gt;::type;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, this method exposes some implementation details, and is only for internal use. You should NOT use this method.&lt;/p&gt; &#xA;&lt;h3&gt;Publish/Subscribe&lt;/h3&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;Redis::publish&lt;/code&gt; to publish messages to channels. &lt;code&gt;Redis&lt;/code&gt; randomly picks a connection from the underlying connection pool, and publishes message with that connection. So you might publish two messages with two different connections.&lt;/p&gt; &#xA;&lt;p&gt;When you subscribe to a channel with a connection, all messages published to the channel are sent back to that connection. So there&#39;s NO &lt;code&gt;Redis::subscribe&lt;/code&gt; method. Instead, you can call &lt;code&gt;Redis::subscriber&lt;/code&gt; to create a &lt;code&gt;Subscriber&lt;/code&gt; and the &lt;code&gt;Subscriber&lt;/code&gt; maintains a connection to Redis. The underlying connection is a new connection, NOT picked from the connection pool. This new connection has the same &lt;code&gt;ConnectionOptions&lt;/code&gt; as the &lt;code&gt;Redis&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;If you want to have different connection options, e.g. &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt;, for different channels, you should create &lt;code&gt;Redis&lt;/code&gt; objects with different connection options, then you can create &lt;code&gt;Subscriber&lt;/code&gt; objects with these &lt;code&gt;Redis&lt;/code&gt; objects. Check &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/307#issuecomment-1002015671&#34;&gt;this issue&lt;/a&gt; for a use case.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ConnectionOptions opts1;&#xA;opts1.host = &#34;127.0.0.1&#34;;&#xA;opts1.port = 6379;&#xA;opts1.socket_timeout = std::chrono::milliseconds(100);&#xA;&#xA;auto redis1 = Redis(opts1);&#xA;&#xA;// sub1&#39;s socket_timeout is 100ms.&#xA;auto sub1 = redis1.subscriber();&#xA;&#xA;ConnectionOptions opts2;&#xA;opts2.host = &#34;127.0.0.1&#34;;&#xA;opts2.port = 6379;&#xA;opts2.socket_timeout = std::chrono::milliseconds(300);&#xA;&#xA;auto redis2 = Redis(opts2);&#xA;&#xA;// sub2&#39;s socket_timeout is 300ms.&#xA;auto sub2 = redis2.subscriber();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Although the above code creates two &lt;code&gt;Redis&lt;/code&gt; objects, it has no performance penalty. Because &lt;code&gt;Redis&lt;/code&gt; object creates connections lazily, i.e. no connection will be created until we send some command with &lt;code&gt;Redis&lt;/code&gt; object, and the connection is created only when we call &lt;code&gt;Redis::subscriber&lt;/code&gt; to create &lt;code&gt;Subscriber&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;With &lt;code&gt;Subscriber&lt;/code&gt;, you can call &lt;code&gt;Subscriber::subscribe&lt;/code&gt;, &lt;code&gt;Subscriber::unsubscribe&lt;/code&gt;, &lt;code&gt;Subscriber::psubscribe&lt;/code&gt; and &lt;code&gt;Subscriber::punsubscribe&lt;/code&gt; to send &lt;em&gt;SUBSCRIBE&lt;/em&gt;, &lt;em&gt;UNSUBSCRIBE&lt;/em&gt;, &lt;em&gt;PSUBSCRIBE&lt;/em&gt; and &lt;em&gt;PUNSUBSCRIBE&lt;/em&gt; commands to Redis.&lt;/p&gt; &#xA;&lt;h4&gt;Thread Safety&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Subscriber&lt;/code&gt; is NOT thread-safe. If you want to call its member functions in multi-thread environment, you need to synchronize between threads manually.&lt;/p&gt; &#xA;&lt;h4&gt;Exception&lt;/h4&gt; &#xA;&lt;p&gt;If any of the &lt;code&gt;Subscriber&lt;/code&gt;&#39;s method throws an exception other than &lt;code&gt;ReplyError&lt;/code&gt; or &lt;code&gt;TimeoutError&lt;/code&gt;, you CANNOT use it any more. Instead, you have to destroy the &lt;code&gt;Subscriber&lt;/code&gt; object, and create a new one.&lt;/p&gt; &#xA;&lt;h4&gt;Subscriber Callbacks&lt;/h4&gt; &#xA;&lt;p&gt;There are 6 kinds of messages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;MESSAGE&lt;/em&gt;: message sent to a channel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;PMESSAGE&lt;/em&gt;: message sent to channels of a given pattern.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;SUBSCRIBE&lt;/em&gt;: message sent when we successfully subscribe to a channel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;UNSUBSCRIBE&lt;/em&gt;: message sent when we successfully unsubscribe to a channel.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;PSUBSCRIBE&lt;/em&gt;: message sent when we successfully subscribe to a channel pattern.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;PUNSUBSCRIBE&lt;/em&gt;: message sent when we successfully unsubscribe to a channel pattern.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We call messages of &lt;em&gt;SUBSCRIBE&lt;/em&gt;, &lt;em&gt;UNSUBSCRIBE&lt;/em&gt;, &lt;em&gt;PSUBSCRIBE&lt;/em&gt; and &lt;em&gt;PUNSUBSCRIBE&lt;/em&gt; types as &lt;em&gt;META MESSAGE&lt;/em&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;In order to process these messages, you can set callback functions on &lt;code&gt;Subscriber&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Subscriber::on_message(MsgCallback)&lt;/code&gt;: set callback function for messages of &lt;em&gt;MESSAGE&lt;/em&gt; type, and the callback interface is: &lt;code&gt;void (std::string channel, std::string msg)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Subscriber::on_pmessage(PatternMsgCallback)&lt;/code&gt;: set the callback function for messages of &lt;em&gt;PMESSAGE&lt;/em&gt; type, and the callback interface is: &lt;code&gt;void (std::string pattern, std::string channel, std::string msg)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Subscriber::on_meta(MetaCallback)&lt;/code&gt;: set callback function for messages of &lt;em&gt;META MESSAGE&lt;/em&gt; type, and the callback interface is: &lt;code&gt;void (Subscriber::MsgType type, OptionalString channel, long long num)&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; is an enum, it can be one of the following enum: &lt;code&gt;Subscriber::MsgType::SUBSCRIBE&lt;/code&gt;, &lt;code&gt;Subscriber::MsgType::UNSUBSCRIBE&lt;/code&gt;, &lt;code&gt;Subscriber::MsgType::PSUBSCRIBE&lt;/code&gt;, &lt;code&gt;Subscriber::MsgType::PUNSUBSCRIBE&lt;/code&gt;, &lt;code&gt;Subscriber::MsgType::MESSAGE&lt;/code&gt;, and &lt;code&gt;Subscriber::MsgType::PMESSAGE&lt;/code&gt;. If you haven&#39;t subscribe/psubscribe to any channel/pattern, and try to unsubscribe/punsubscribe without any parameter, i.e. unsubscribe/punsubscribe all channels/patterns, &lt;em&gt;channel&lt;/em&gt; will be null. So the second parameter of meta callback is of type &lt;code&gt;OptionalString&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All these callback interfaces pass &lt;code&gt;std::string&lt;/code&gt; by value, and you can take their ownership (i.e. &lt;code&gt;std::move&lt;/code&gt;) safely.&lt;/p&gt; &#xA;&lt;h4&gt;Consume Messages&lt;/h4&gt; &#xA;&lt;p&gt;You can call &lt;code&gt;Subscriber::consume&lt;/code&gt; to consume messages published to channels/patterns that the &lt;code&gt;Subscriber&lt;/code&gt; has been subscribed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Subscriber::consume&lt;/code&gt; waits for message from the underlying connection. If the &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt; is reached, and there&#39;s no message sent to this connection, &lt;code&gt;Subscriber::consume&lt;/code&gt; throws a &lt;code&gt;TimeoutError&lt;/code&gt; exception. If &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt; is &lt;code&gt;0ms&lt;/code&gt;, &lt;code&gt;Subscriber::consume&lt;/code&gt; blocks until it receives a message.&lt;/p&gt; &#xA;&lt;p&gt;After receiving the message, &lt;code&gt;Subscriber::consume&lt;/code&gt; calls the callback function to process the message based on message type. However, if you don&#39;t set callback for a specific kind of message, &lt;code&gt;Subscriber::consume&lt;/code&gt; will consume the received message and discard it, i.e. &lt;code&gt;Subscriber::consume&lt;/code&gt; returns without running the callback.&lt;/p&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;p&gt;The following example is a common pattern for using &lt;code&gt;Subscriber&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Create a Subscriber.&#xA;auto sub = redis.subscriber();&#xA;&#xA;// Set callback functions.&#xA;sub.on_message([](std::string channel, std::string msg) {&#xA;            // Process message of MESSAGE type.&#xA;        });&#xA;&#xA;sub.on_pmessage([](std::string pattern, std::string channel, std::string msg) {&#xA;            // Process message of PMESSAGE type.&#xA;        });&#xA;&#xA;sub.on_meta([](Subscriber::MsgType type, OptionalString channel, long long num) {&#xA;            // Process message of META type.&#xA;        });&#xA;&#xA;// Subscribe to channels and patterns.&#xA;sub.subscribe(&#34;channel1&#34;);&#xA;sub.subscribe({&#34;channel2&#34;, &#34;channel3&#34;});&#xA;&#xA;sub.psubscribe(&#34;pattern1*&#34;);&#xA;&#xA;// Consume messages in a loop.&#xA;while (true) {&#xA;    try {&#xA;        sub.consume();&#xA;    } catch (const Error &amp;amp;err) {&#xA;        // Handle exceptions.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt; is set, you might get &lt;code&gt;TimeoutError&lt;/code&gt; exception before receiving a message:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;while (true) {&#xA;    try {&#xA;        sub.consume();&#xA;    } catch (const TimeoutError &amp;amp;e) {&#xA;        // Try again.&#xA;        continue;&#xA;    } catch (const Error &amp;amp;err) {&#xA;        // Handle other exceptions.&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above examples use lambda as callback. If you&#39;re not familiar with lambda, you can also set a free function as callback. Check &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/16&#34;&gt;this issue&lt;/a&gt; for detail.&lt;/p&gt; &#xA;&lt;h3&gt;Pipeline&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/pipelining&#34;&gt;Pipeline&lt;/a&gt; is used to reduce &lt;em&gt;RTT&lt;/em&gt; (Round Trip Time), and speed up Redis queries. &lt;em&gt;redis-plus-plus&lt;/em&gt; supports pipeline with the &lt;code&gt;Pipeline&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;h4&gt;Create Pipeline&lt;/h4&gt; &#xA;&lt;p&gt;You can create a pipeline with &lt;code&gt;Redis::pipeline&lt;/code&gt; method, which returns a &lt;code&gt;Pipeline&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;ConnectionOptions connection_options;&#xA;ConnectionPoolOptions pool_options;&#xA;&#xA;Redis redis(connection_options, pool_options);&#xA;&#xA;auto pipe = redis.pipeline();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When creating a &lt;code&gt;Pipeline&lt;/code&gt; object, by default, &lt;code&gt;Redis::pipeline&lt;/code&gt; method creates a new connection to Redis server. This connection is NOT picked from the connection pool, but a newly created connection. This connection has the same &lt;code&gt;ConnectionOptions&lt;/code&gt; as other connections in the connection pool. &lt;code&gt;Pipeline&lt;/code&gt; object maintains the new connection, and all piped commands are sent through this connection.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: By default, creating a &lt;code&gt;Pipeline&lt;/code&gt; object is NOT cheap, since it creates a new connection. So you&#39;d better reuse the &lt;code&gt;Pipeline&lt;/code&gt; object as much as possible. Check &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#create-pipeline-without-creating-new-connection&#34;&gt;this&lt;/a&gt; to see how to create a &lt;code&gt;Pipeline&lt;/code&gt; object without creating a new connection.&lt;/p&gt; &#xA;&lt;h4&gt;Send Commands&lt;/h4&gt; &#xA;&lt;p&gt;You can send Redis commands through the &lt;code&gt;Pipeline&lt;/code&gt; object. Just like the &lt;code&gt;Redis&lt;/code&gt; class, &lt;code&gt;Pipeline&lt;/code&gt; has one or more (overloaded) methods for each Redis command. However, you CANNOT get the replies until you call &lt;code&gt;Pipeline::exec&lt;/code&gt;. So these methods do NOT return the reply, instead they return the &lt;code&gt;Pipeline&lt;/code&gt; object itself. And you can chain these methods calls.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;pipe.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;).rpush(&#34;list&#34;, {0, 1, 2}).command(&#34;hset&#34;, &#34;key&#34;, &#34;field&#34;, &#34;value&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Get Replies&lt;/h4&gt; &#xA;&lt;p&gt;Once you finish sending commands to Redis, you can call &lt;code&gt;Pipeline::exec&lt;/code&gt; to get replies of these commands. You can also chain &lt;code&gt;Pipeline::exec&lt;/code&gt; with other commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;pipe.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;);&#xA;auto replies = pipe.exec();&#xA;&#xA;// The same as:&#xA;replies = pipe.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num).exec();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In fact, these commands won&#39;t be sent to Redis, until you call &lt;code&gt;Pipeline::exec&lt;/code&gt;. So &lt;code&gt;Pipeline::exec&lt;/code&gt; does 2 work in order: send all piped commands, then get all replies from Redis.&lt;/p&gt; &#xA;&lt;p&gt;Also you can call &lt;code&gt;Pipeline::discard&lt;/code&gt; to discard those piped commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;pipe.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;);&#xA;&#xA;pipe.discard();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parse Replies&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Pipeline::exec&lt;/code&gt; returns a &lt;code&gt;QueuedReplies&lt;/code&gt; object, which contains replies of all commands that have been sent to Redis. You can use &lt;code&gt;QueuedReplies::get&lt;/code&gt; method to get and parse the &lt;code&gt;ith&lt;/code&gt; reply. It has 3 overloads:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;template &amp;lt;typename Result&amp;gt; Result get(std::size_t idx)&lt;/code&gt;: Return the &lt;code&gt;ith&lt;/code&gt; reply as a return value, and you need to specify the return type as tempalte parameter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;template &amp;lt;typename Output&amp;gt; void get(std::size_t idx, Output output)&lt;/code&gt;: If the reply is of type &lt;em&gt;Array Reply&lt;/em&gt;, you can call this method to write the &lt;code&gt;ith&lt;/code&gt; reply to an output iterator. Normally, compiler will deduce the type of the output iterator, and you don&#39;t need to specify the type parameter explicitly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;redisReply&amp;amp; get(std::size_t idx)&lt;/code&gt;: If the reply is NOT a fixed type, call this method to get a reference to &lt;code&gt;redisReply&lt;/code&gt; object. In this case, you need to call &lt;code&gt;template &amp;lt;typename T&amp;gt; T reply::parse(redisReply &amp;amp;)&lt;/code&gt; to parse the reply manually.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Check the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#return-type&#34;&gt;Return Type section&lt;/a&gt; for details on the return types of the result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto replies = pipe.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;).lrange(&#34;list&#34;, 0, -1).exec();&#xA;&#xA;auto set_cmd_result = replies.get&amp;lt;bool&amp;gt;(0);&#xA;&#xA;auto incr_cmd_result = replies.get&amp;lt;long long&amp;gt;(1);&#xA;&#xA;std::vector&amp;lt;std::string&amp;gt; list_cmd_result;&#xA;replies.get(2, std::back_inserter(list_cmd_result));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Exception&lt;/h4&gt; &#xA;&lt;p&gt;If any of &lt;code&gt;Pipeline&lt;/code&gt;&#39;s method throws an exception other than &lt;code&gt;ReplyError&lt;/code&gt;, the &lt;code&gt;Pipeline&lt;/code&gt; object enters an invalid state. You CANNOT use it any more, but only destroy the object, and create a new one.&lt;/p&gt; &#xA;&lt;h4&gt;Thread Safety&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Pipeline&lt;/code&gt; is NOT thread-safe. If you want to call its member functions in multi-thread environment, you need to synchronize between threads manually.&lt;/p&gt; &#xA;&lt;h4&gt;Create Pipeline Without Creating New Connection&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;YOU MUST CAREFULLY READ ALL WORDS IN THIS SECTION AND THE VERY IMPORTANT NOTES BEFORE USING THIS FEATURE!!!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;In fact, you can also create a &lt;code&gt;Pipeline&lt;/code&gt; object with a connection from the underlying connection pool, so that calling &lt;code&gt;Redis::pipeline&lt;/code&gt; method can be much cheaper (since it doesn&#39;t need to create a new connection).&lt;/p&gt; &#xA;&lt;p&gt;The prototype of &lt;code&gt;Redis::pipeline&lt;/code&gt; is as follows: &lt;code&gt;Pipeline pipeline(bool new_connection = true);&lt;/code&gt;. If &lt;code&gt;new_connection&lt;/code&gt; is false, the &lt;code&gt;Pipeline&lt;/code&gt; object will be created with a connection from the underlying pool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ConnectionOptions connection_options;&#xA;ConnectionPoolOptions pool_options;&#xA;&#xA;Redis redis(connection_options, pool_options);&#xA;&#xA;// Create a Pipeline without creating a new connection.&#xA;auto pipe = redis.pipeline(false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;VERY IMPORTANT NOTES&lt;/h5&gt; &#xA;&lt;p&gt;However, in this case, you MUST be very careful, otherwise, you might get bad performance or even dead lock. Because when you run command with &lt;code&gt;Pipeline&lt;/code&gt; object, it will hold the connection until &lt;code&gt;Pipeline::exec&lt;/code&gt;, &lt;code&gt;Pipeline::discard&lt;/code&gt; or &lt;code&gt;Pipeline&lt;/code&gt;&#39;s destructor is called (the connection will also be released if any method of &lt;code&gt;Pipeline&lt;/code&gt; throws &lt;code&gt;Exception&lt;/code&gt;). If the &lt;code&gt;Pipeline&lt;/code&gt; object holds the connection for a long time, other &lt;code&gt;Redis&lt;/code&gt; methods might not be able to get a connection from the underlying pool.&lt;/p&gt; &#xA;&lt;p&gt;Check the following dead lock example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// By defaul, create a `Redis` object with only ONE connection in pool.&#xA;// Also by default, the `ConnectionPoolOptions::wait_timeout` is 0ms,&#xA;// which means if the pool is empty, `Redis` method will be blocked until&#xA;// the pool is not empty.&#xA;Redis redis(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;// Create a `Pipeline` with a connection in the underlying pool.&#xA;// In fact, the connection hasn&#39;t been fetched from the pool&#xA;// until some method of `Pipeline` has been called.&#xA;auto pipe = redis.pipeline(false);&#xA;&#xA;// Now the `Pipeline` object fetches a connection from the pool.&#xA;pipe.set(&#34;key1&#34;, &#34;val&#34;);&#xA;&#xA;// `Pipeline` object still holds the connection until `Pipeline::exec`,&#xA;// `Pipeline::discard` or the destructor is called.&#xA;pipe.set(&#34;key2&#34;, &#34;val&#34;);&#xA;&#xA;// Try to send a command with `Redis` object.&#xA;// However, the pool is empty, since the `Pipeline` object still holds&#xA;// the connection, and this call will be blocked forever.&#xA;// DEAD LOCK!!!&#xA;redis.get(&#34;key&#34;);&#xA;&#xA;// NEVER goes here.&#xA;pipe.exec();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;BEST PRACTICE&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;p&gt;When creating &lt;code&gt;Pipeline&lt;/code&gt; without creating a new connection:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Always set &lt;code&gt;ConnectionPoolOptions::wait_timeout&lt;/code&gt; larger than 0ms (i.e. when pool is empty, never block forever).&lt;/li&gt; &#xA; &lt;li&gt;Avoid doing slow operation between &lt;code&gt;Pipeline&lt;/code&gt;&#39;s methods.&lt;/li&gt; &#xA; &lt;li&gt;Better chain &lt;code&gt;Pipeline&lt;/code&gt; methods and the &lt;code&gt;Pipeline::exec&lt;/code&gt; in one statements.&lt;/li&gt; &#xA; &lt;li&gt;Better leave &lt;code&gt;Pipeline&lt;/code&gt; related code in a block scope.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ConnectionOptions opts;&#xA;opts.host = &#34;127.0.0.1&#34;;&#xA;opts.port = 6379;&#xA;opts.socket_timeout = std::chrono::milliseconds(50);&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3;&#xA;&#xA;// Always set `wait_timeout` larger than 0ms.&#xA;pool_opts.wait_timeout = std::chrono::milliseconds(50);&#xA;&#xA;auto redis = Redis(opts, pool_opts);&#xA;&#xA;{&#xA;    // Better put `Pipeline` related code in a block scope.&#xA;    auto pipe = redis.pipeline(false);&#xA;&#xA;    pipe.set(&#34;key1&#34;, &#34;val&#34;);&#xA;&#xA;    // DON&#39;T run slow operations here, since `Pipeline` object still holds&#xA;    // the connection, other threads using this `Redis` object, might be blocked.&#xA;&#xA;    pipe.set(&#34;key2&#34;, &#34;val&#34;);&#xA;&#xA;    // When `Pipeline::exec` finishes, `Pipeline` releases the connection, and returns it to pool.&#xA;    auto replies = pipe.exec();&#xA;&#xA;    // This is even better, i.e. chain `Pipeline` methods with `Pipeline::exec`.&#xA;    replies = pipe.set(&#34;key1&#34;, &#34;val&#34;).set(&#34;key2&#34;, &#34;val&#34;).exec();&#xA;}&#xA;&#xA;for (auto i = 0; i &amp;lt; 10; ++i) {&#xA;    // This operation, i.e. creating a `Pipeline` object with connection in pool, is cheap&#xA;    auto pipe = redis.pipeline(false);&#xA;&#xA;    // Fetch a connection from the underlying pool, and hold it.&#xA;    pipe.set(&#34;key1&#34;, &#34;val&#34;).set(&#34;key2&#34;, &#34;val&#34;);&#xA;&#xA;    // Although `Pipeline::exec` and `Pipeline::discard` haven&#39;t been called,&#xA;    // when `Pipeline`&#39;s destructor is called, the connection will also be&#xA;    // returned to the pool.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Transaction&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/transactions&#34;&gt;Transaction&lt;/a&gt; is used to make multiple commands runs atomically.&lt;/p&gt; &#xA;&lt;h4&gt;Create Transaction&lt;/h4&gt; &#xA;&lt;p&gt;You can create a transaction with &lt;code&gt;Redis::transaction&lt;/code&gt; method, which returns a &lt;code&gt;Transaction&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;ConnectionOptions connection_options;&#xA;ConnectionPoolOptions pool_options;&#xA;&#xA;Redis redis(connection_options, pool_options);&#xA;&#xA;auto tx = redis.transaction();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As the &lt;code&gt;Pipeline&lt;/code&gt; class, &lt;code&gt;Transaction&lt;/code&gt; maintains a newly created connection to Redis. This connection has the same &lt;code&gt;ConnectionOptions&lt;/code&gt; as the &lt;code&gt;Redis&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Creating a &lt;code&gt;Transaction&lt;/code&gt; object is NOT cheap, since it creates a new connection. So you&#39;d better reuse the &lt;code&gt;Transaction&lt;/code&gt; as much as possible. Check &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#create-transaction-without-creating-new-connection&#34;&gt;this&lt;/a&gt; to see how to create a &lt;code&gt;Transaction&lt;/code&gt; object without creating a new connection.&lt;/p&gt; &#xA;&lt;p&gt;Also you don&#39;t need to send &lt;a href=&#34;https://redis.io/commands/multi&#34;&gt;MULTI&lt;/a&gt; command to Redis. &lt;code&gt;Transaction&lt;/code&gt; will do that for you automatically.&lt;/p&gt; &#xA;&lt;h4&gt;Send Commands&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Transaction&lt;/code&gt; shares most of implementation with &lt;code&gt;Pipeline&lt;/code&gt;. It has the same interfaces as &lt;code&gt;Pipeline&lt;/code&gt;. You can send commands as what you do with &lt;code&gt;Pipeline&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;tx.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;).lpush(&#34;list&#34;, {0, 1, 2}).command(&#34;hset&#34;, &#34;key&#34;, &#34;field&#34;, &#34;val&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Execute Transaction&lt;/h4&gt; &#xA;&lt;p&gt;When you call &lt;code&gt;Transaction::exec&lt;/code&gt;, you explicitly ask Redis to execute those queued commands, and return the replies. Otherwise, these commands won&#39;t be executed. Also, you can call &lt;code&gt;Transaction::discard&lt;/code&gt; to discard the execution, i.e. no command will be executed. Both &lt;code&gt;Transaction::exec&lt;/code&gt; and &lt;code&gt;Transaction::discard&lt;/code&gt; can be chained with other commands.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto replies = tx.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;).exec();&#xA;&#xA;tx.set(&#34;key&#34;, &#34;val&#34;).incr(&#34;num&#34;);&#xA;&#xA;// Discard the transaction.&#xA;tx.discard();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Parse Replies&lt;/h4&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#parse-replies&#34;&gt;Pipeline&#39;s Parse Replies section&lt;/a&gt; for how to parse the replies.&lt;/p&gt; &#xA;&lt;h4&gt;Piped Transaction&lt;/h4&gt; &#xA;&lt;p&gt;Normally, we always send multiple commnds in a transaction. In order to improve the performance, you can send these commands in a pipeline. You can create a piped transaction by passing &lt;code&gt;true&lt;/code&gt; as parameter of &lt;code&gt;Redis::transaction&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Create a piped transaction&#xA;auto tx = redis.transaction(true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this piped transaction, all commands are sent to Redis in a pipeline.&lt;/p&gt; &#xA;&lt;h4&gt;Exception&lt;/h4&gt; &#xA;&lt;p&gt;If any of &lt;code&gt;Transaction&lt;/code&gt;&#39;s method throws an exception other than &lt;code&gt;WatchError&lt;/code&gt; or &lt;code&gt;ReplyError&lt;/code&gt;, the &lt;code&gt;Transaction&lt;/code&gt; object enters an invalid state. You CANNOT use it any more, but only destroy the object and create a new one.&lt;/p&gt; &#xA;&lt;h4&gt;Thread Safety&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;Transacation&lt;/code&gt; is NOT thread-safe. If you want to call its member functions in multi-thread environment, you need to synchronize between threads manually.&lt;/p&gt; &#xA;&lt;h4&gt;Watch&lt;/h4&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/transactions#optimistic-locking-using-check-and-set&#34;&gt;WATCH is used to provide a check-and-set(CAS) behavior to Redis transactions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;WATCH&lt;/code&gt; command must be sent in the same connection as the transaction. And normally after the &lt;code&gt;WATCH&lt;/code&gt; command, we also need to send some other commands to get data from Redis before executing the transaction. Take the following check-and-set case as an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;WATCH key           // watch a key&#xA;val = GET key       // get value of the key&#xA;new_val = val + 1   // incr the value&#xA;MULTI               // begin the transaction&#xA;SET key new_val     // set value only if the value is NOT modified by others&#xA;EXEC                // try to execute the transaction.&#xA;                    // if val has been modified, the transaction won&#39;t be executed.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, with &lt;code&gt;Transaction&lt;/code&gt; object, you CANNOT get the result of commands until the whole transaction has been finished. Instead, you need to create a &lt;code&gt;Redis&lt;/code&gt; object from the &lt;code&gt;Transaction&lt;/code&gt; object. The created &lt;code&gt;Redis&lt;/code&gt; object shares the connection with &lt;code&gt;Transaction&lt;/code&gt; object. With this created &lt;code&gt;Redis&lt;/code&gt; object, you can send &lt;code&gt;WATCH&lt;/code&gt; command and any other Redis commands to Redis server, and get the result immediately.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s see how to implement the above example with &lt;em&gt;redis-plus-plus&lt;/em&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto redis = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;// Create a transaction.&#xA;auto tx = redis.transaction();&#xA;&#xA;// Create a Redis object from the Transaction object. Both objects share the same connection.&#xA;auto r = tx.redis();&#xA;&#xA;// If the watched key has been modified by other clients, the transaction might fail.&#xA;// So we need to retry the transaction in a loop.&#xA;while (true) {&#xA;    try {&#xA;        // Watch a key.&#xA;        r.watch(&#34;key&#34;);&#xA;&#xA;        // Get the old value.&#xA;        auto val = r.get(&#34;key&#34;);&#xA;        auto num = 0;&#xA;        if (val) {&#xA;            num = std::stoi(*val);&#xA;        } // else use default value, i.e. 0.&#xA;&#xA;        // Incr value.&#xA;        ++num;&#xA;&#xA;        // Execute the transaction.&#xA;        auto replies = tx.set(&#34;key&#34;, std::to_string(num)).exec();&#xA;&#xA;        // Transaction has been executed successfully. Check the result and break.&#xA;&#xA;        assert(replies.size() == 1 &amp;amp;&amp;amp; replies.get&amp;lt;bool&amp;gt;(0) == true);&#xA;&#xA;        break;&#xA;    } catch (const WatchError &amp;amp;err) {&#xA;        // Key has been modified by other clients, retry.&#xA;        continue;&#xA;    } catch (const Error &amp;amp;err) {&#xA;        // Something bad happens, and the Transaction object is no longer valid.&#xA;        throw;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: in the example above, we create &lt;code&gt;Transaction&lt;/code&gt; object outside the while loop, in order to avoid creating new connection again and again.&lt;/p&gt; &#xA;&lt;h4&gt;Create Transaction Without Creating New Connection&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: YOU MUST CAREFULLY READ ALL WORDS AND THE VERY IMPORTANT NOTES LINK IN THIS SECTION BEFORE USING THIS FEATURE!!!&lt;/p&gt; &#xA;&lt;p&gt;In fact, you can also create a &lt;code&gt;transaction&lt;/code&gt; object with a connection from the underlying connection pool, so that calling &lt;code&gt;Redis::transaction&lt;/code&gt; method can be much cheaper (since it doesn&#39;t need to create a new connection).&lt;/p&gt; &#xA;&lt;p&gt;The prototype of &lt;code&gt;Redis::transaction&lt;/code&gt; is as follows: &lt;code&gt;Transaction transaction(bool piped = false, bool new_connection = true);&lt;/code&gt;. If &lt;code&gt;new_connection&lt;/code&gt; is false, the &lt;code&gt;Transaction&lt;/code&gt; object will be created with a connection from the underlying pool.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ConnectionOptions connection_options;&#xA;ConnectionPoolOptions pool_options;&#xA;&#xA;Redis redis(connection_options, pool_options);&#xA;&#xA;// Create a Transaction without creating a new connection.&#xA;auto tx = redis.transaction(false, false);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, in this case, you MUST be very careful, otherwise, you might get bad performance or even dead lock. Please carefully check the similar pipeline&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#very-important-notes&#34;&gt;VERY IMPORTANT NOTES section&lt;/a&gt;, before you use it!&lt;/p&gt; &#xA;&lt;p&gt;Besides those very important notes, there&#39;s another important note for &lt;code&gt;Transaction&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Limit the scope of &lt;code&gt;Redis&lt;/code&gt; object created by &lt;code&gt;Transaction::Redis&lt;/code&gt;, i.e. destroy it ASAP.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Check the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto redis = Redis(opts, pool_opts);&#xA;&#xA;// Create a `Transaction` object without creating a new connection.&#xA;auto tx = redis.Transaction(false, false);&#xA;&#xA;// Create a `Redis`, and this `Redis` object shares the same connection with the `Transaction` object.&#xA;auto r = tx.redis();&#xA;&#xA;// Other code here...&#xA;&#xA;// Execute the transaction.&#xA;auto replies = tx.set(&#34;key&#34;, &#34;val&#34;).exec();&#xA;&#xA;// Although `Transaction::exec` has been called, the connection has not been returned to pool.&#xA;// Because the `Redis` object, i.e. `r`, still holds the connection.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So the above watch example should be modified as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto redis = Redis(opts, pool_opts);&#xA;&#xA;// If the watched key has been modified by other clients, the transaction might fail.&#xA;// So we need to retry the transaction in a loop.&#xA;while (true) {&#xA;    try {&#xA;        // Create a transaction without creating a new connection.&#xA;        auto tx = redis.transaction(false, false);&#xA;&#xA;        // Create a Redis object from the Transaction object. Both objects share the same connection.&#xA;        auto r = tx.redis();&#xA;&#xA;        // Watch a key.&#xA;        r.watch(&#34;key&#34;);&#xA;&#xA;        // Get the old value.&#xA;        auto val = r.get(&#34;key&#34;);&#xA;        auto num = 0;&#xA;        if (val) {&#xA;            num = std::stoi(*val);&#xA;        } // else use default value, i.e. 0.&#xA;&#xA;        // Incr value.&#xA;        ++num;&#xA;&#xA;        // Execute the transaction.&#xA;        auto replies = tx.set(&#34;key&#34;, std::to_string(num)).exec();&#xA;&#xA;        // Transaction has been executed successfully. Check the result and break.&#xA;&#xA;        assert(replies.size() == 1 &amp;amp;&amp;amp; replies.get&amp;lt;bool&amp;gt;(0) == true);&#xA;&#xA;        break;&#xA;    } catch (const WatchError &amp;amp;err) {&#xA;        // Key has been modified by other clients, retry.&#xA;        continue;&#xA;    } catch (const Error &amp;amp;err) {&#xA;        // Something bad happens, and the Transaction object is no longer valid.&#xA;        throw;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The difference is that we create the &lt;code&gt;Transaction&lt;/code&gt; object in the while loop (it&#39;s cheap, since it doesn&#39;t need to create a new connection). When the &lt;code&gt;Transaction&lt;/code&gt; object and the &lt;code&gt;Redis&lt;/code&gt; object created by &lt;code&gt;Transaction::redis&lt;/code&gt; have been destroyed, the connection will be return to pool.&lt;/p&gt; &#xA;&lt;h3&gt;Redis Cluster&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; supports &lt;a href=&#34;https://redis.io/topics/cluster-tutorial&#34;&gt;Redis Cluster&lt;/a&gt;. You can use &lt;code&gt;RedisCluster&lt;/code&gt; class to send commands to Redis Cluster. It has similar interfaces as &lt;code&gt;Redis&lt;/code&gt; class.&lt;/p&gt; &#xA;&lt;h4&gt;Connection&lt;/h4&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;RedisCluster&lt;/code&gt; connects to all master nodes in the cluster. For each master node, it maintains a connection pool. If you want to read from slave nodes, you need to explicitly set an option (see &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#read-from-replica&#34;&gt;below&lt;/a&gt; for reference).&lt;/p&gt; &#xA;&lt;p&gt;You can initialize a &lt;code&gt;RedisCluster&lt;/code&gt; instance with &lt;code&gt;ConnectionOptions&lt;/code&gt; and &lt;code&gt;ConnectionPoolOptions&lt;/code&gt;. You only need to set one master node&#39;s host &amp;amp; port in &lt;code&gt;ConnectionOptions&lt;/code&gt;, and &lt;code&gt;RedisCluster&lt;/code&gt; will get other nodes&#39; info automatically (with the &lt;em&gt;CLUSTER SLOTS&lt;/em&gt; command). For each master node, it creates a connection pool with the specified &lt;code&gt;ConnectionPoolOptions&lt;/code&gt;. If &lt;code&gt;ConnectionPoolOptions&lt;/code&gt; is not specified, &lt;code&gt;RedisCluster&lt;/code&gt; maintains a single connection to every master node.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Set a master node&#39;s host &amp;amp; port.&#xA;ConnectionOptions connection_options;&#xA;connection_options.host = &#34;127.0.0.1&#34;;  // Required.&#xA;connection_options.port = 7000; // Optional. The default port is 6379.&#xA;connection_options.password = &#34;auth&#34;; // Optional. No password by default.&#xA;&#xA;// Automatically get other nodes&#39; info,&#xA;// and connect to every master node with a single connection.&#xA;RedisCluster cluster1(connection_options);&#xA;&#xA;ConnectionPoolOptions pool_options;&#xA;pool_options.size = 3;&#xA;&#xA;// For each master node, maintains a connection pool of size 3.&#xA;RedisCluster cluster2(connection_options, pool_options);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also specify connection option with an URI. However, in this way, you can only use default &lt;code&gt;ConnectionPoolOptions&lt;/code&gt;, i.e. pool of size 1, and CANNOT specify password.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// Specify a master node&#39;s host &amp;amp; port.&#xA;RedisCluster cluster3(&#34;tcp://127.0.0.1:7000&#34;);&#xA;&#xA;// Use default port, i.e. 6379.&#xA;RedisCluster cluster4(&#34;tcp://127.0.0.1&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Read From Replica&lt;/h5&gt; &#xA;&lt;p&gt;If you want to scale read by reading (possible stale) data from slave nodes, you can specifiy &lt;code&gt;Role::SLAVE&lt;/code&gt; as the third parameter of &lt;code&gt;RedisCluster&lt;/code&gt;&#39;s constructor. In this case, &lt;em&gt;redis-plus-plus&lt;/em&gt; will randomly pick a replica node for each master node of the cluster, and create a connection pool for the replica node.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;RedisCluster cluster(connection_options, pool_options, Role::SLAVE);&#xA;&#xA;auto val = cluster.get(&#34;key&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, you can only send readonly commands to Redis Cluster. If you try to send a write command, e.g. &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;hset&lt;/code&gt;, &lt;em&gt;redis-plus-plus&lt;/em&gt; will throw an exception. Currently, &lt;em&gt;redis-plus-plus&lt;/em&gt; doesn&#39;t handle this case, i.e. sending write command in &lt;code&gt;Role::SLAVE&lt;/code&gt; mode, elegantly, and you might get some performance problem. So, NEVER send write command in &lt;code&gt;Role::SLAVE&lt;/code&gt; mode. I&#39;ll fix this issue in the future.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: In &lt;code&gt;Role::SLAVE&lt;/code&gt; mode, you don&#39;t need to manually send &lt;a href=&#34;https://redis.io/commands/readonly&#34;&gt;READONLY&lt;/a&gt; command to slave nodes. Instead, &lt;em&gt;redis-plus-plus&lt;/em&gt; will send &lt;em&gt;READONLY&lt;/em&gt; command to slave nodes automatically.&lt;/p&gt; &#xA;&lt;h5&gt;Note&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;RedisCluster&lt;/code&gt; only works with tcp connection. It CANNOT connect to Unix Domain Socket. If you specify Unix Domain Socket in &lt;code&gt;ConnectionOptions&lt;/code&gt;, it throws an exception.&lt;/li&gt; &#xA; &lt;li&gt;All nodes in the cluster should have the same password.&lt;/li&gt; &#xA; &lt;li&gt;Since &lt;a href=&#34;https://redis.io/topics/cluster-spec#implemented-subset&#34;&gt;Redis Cluster does NOT support multiple databses&lt;/a&gt;, &lt;code&gt;ConnectionOptions::db&lt;/code&gt; is ignored.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Interfaces&lt;/h4&gt; &#xA;&lt;p&gt;As we mentioned above, &lt;code&gt;RedisCluster&lt;/code&gt;&#39;s interfaces are similar to &lt;code&gt;Redis&lt;/code&gt;. It supports most of &lt;code&gt;Redis&lt;/code&gt;&#39; interfaces, including the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#generic-command-interface&#34;&gt;generic command interface&lt;/a&gt; (see &lt;code&gt;Redis&lt;/code&gt;&#39; &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#api-reference&#34;&gt;API Reference section&lt;/a&gt; for details), except the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Not support commands without key as argument, e.g. &lt;code&gt;PING&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Not support Lua script without key parameters.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since there&#39;s no key parameter, &lt;code&gt;RedisCluster&lt;/code&gt; has no idea on to which node these commands should be sent. However there&#39;re 2 workarounds for this problem:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you want to send these commands to a specific node, you can create a &lt;code&gt;Redis&lt;/code&gt; object with that node&#39;s host and port, and use the &lt;code&gt;Redis&lt;/code&gt; object to do the work.&lt;/li&gt; &#xA; &lt;li&gt;Instead of host and port, you can also call &lt;code&gt;Redis RedisCluster::redis(const StringView &amp;amp;hash_tag)&lt;/code&gt; to create a &lt;code&gt;Redis&lt;/code&gt; object with a hash-tag specifying the node. In this case, the returned &lt;code&gt;Redis&lt;/code&gt; object creates a new connection to Redis server. &lt;strong&gt;NOTE&lt;/strong&gt;: the returned &lt;code&gt;Redis&lt;/code&gt; object, &lt;strong&gt;IS NOT THREAD SAFE!&lt;/strong&gt;. Also, when using the returned &lt;code&gt;Redis&lt;/code&gt; object, if it throws exception, you need to destroy it, and create a new one with the &lt;code&gt;RedisCluster::redis&lt;/code&gt; method.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also you can use the &lt;a href=&#34;https://redis.io/topics/cluster-spec#keys-hash-tags&#34;&gt;hash tags&lt;/a&gt; to send multiple-key commands.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#examples-2&#34;&gt;example section&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h5&gt;Publish/Subscribe&lt;/h5&gt; &#xA;&lt;p&gt;You can publish and subscribe messages with &lt;code&gt;RedisCluster&lt;/code&gt;. The interfaces are exactly the same as &lt;code&gt;Redis&lt;/code&gt;, i.e. use &lt;code&gt;RedisCluster::publish&lt;/code&gt; to publish messages, and use &lt;code&gt;RedisCluster::subscriber&lt;/code&gt; to create a subscriber to consume messages. See &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#publishsubscribe&#34;&gt;Publish/Subscribe section&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h5&gt;Pipeline and Transaction&lt;/h5&gt; &#xA;&lt;p&gt;You can also create &lt;code&gt;Pipeline&lt;/code&gt; and &lt;code&gt;Transaction&lt;/code&gt; objects with &lt;code&gt;RedisCluster&lt;/code&gt;, but the interfaces are different from &lt;code&gt;Redis&lt;/code&gt;. Since all commands in the pipeline and transaction should be sent to a single node in a single connection, we need to tell &lt;code&gt;RedisCluster&lt;/code&gt; with which node the pipeline or transaction should be created.&lt;/p&gt; &#xA;&lt;p&gt;Instead of specifying the node&#39;s IP and port, &lt;code&gt;RedisCluster&lt;/code&gt;&#39;s pipeline and transaction interfaces allow you to specify the node with a &lt;em&gt;hash tag&lt;/em&gt;. &lt;code&gt;RedisCluster&lt;/code&gt; will calculate the slot number with the given &lt;em&gt;hash tag&lt;/em&gt;, and create a pipeline or transaction with the node holding the slot.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Pipeline RedisCluster::pipeline(const StringView &amp;amp;hash_tag, bool new_connection = true);&#xA;&#xA;Transaction RedisCluster::transaction(const StringView &amp;amp;hash_tag, bool piped = false, bool new_connection = true);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the created &lt;code&gt;Pipeline&lt;/code&gt; or &lt;code&gt;Transaction&lt;/code&gt; object, you can send commands with keys located on the same node as the given &lt;em&gt;hash_tag&lt;/em&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#examples-2&#34;&gt;Examples section&lt;/a&gt; for an example.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: By default, &lt;code&gt;Pipeline&lt;/code&gt; and &lt;code&gt;Transaction&lt;/code&gt; will be created with a new connection. In order to avoid creating new connection, you can pass &lt;code&gt;false&lt;/code&gt; as the last parameter. However, in this case, you MUST be very careful, otherwise, you might get bad performance or even dead lock. Please carefully check the related &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#very-important-notes&#34;&gt;pipeline section&lt;/a&gt; before using this feature.&lt;/p&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;sw/redis++/redis++.h&amp;gt;&#xA;&#xA;using namespace sw::redis;&#xA;&#xA;auto redis_cluster = RedisCluster(&#34;tcp://127.0.0.1:7000&#34;);&#xA;&#xA;redis_cluster.set(&#34;key&#34;, &#34;value&#34;);&#xA;auto val = redis_cluster.get(&#34;key&#34;);&#xA;if (val) {&#xA;    std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;// With hash-tag.&#xA;redis_cluster.set(&#34;key{tag}1&#34;, &#34;val1&#34;);&#xA;redis_cluster.set(&#34;key{tag}2&#34;, &#34;val2&#34;);&#xA;redis_cluster.set(&#34;key{tag}3&#34;, &#34;val3&#34;);&#xA;std::vector&amp;lt;OptionalString&amp;gt; hash_tag_res;&#xA;redis_cluster.mget({&#34;key{tag}1&#34;, &#34;key{tag}2&#34;, &#34;key{tag}3&#34;},&#xA;        std::back_inserter(hash_tag_res));&#xA;&#xA;redis_cluster.lpush(&#34;list&#34;, {&#34;1&#34;, &#34;2&#34;, &#34;3&#34;});&#xA;std::vector&amp;lt;std::string&amp;gt; list;&#xA;redis_cluster.lrange(&#34;list&#34;, 0, -1, std::back_inserter(list));&#xA;&#xA;// Pipeline.&#xA;auto pipe = redis_cluster.pipeline(&#34;counter&#34;);&#xA;auto replies = pipe.incr(&#34;{counter}:1&#34;).incr(&#34;{counter}:2&#34;).exec();&#xA;&#xA;// Transaction.&#xA;auto tx = redis_cluster.transaction(&#34;key&#34;);&#xA;replies = tx.incr(&#34;key&#34;).get(&#34;key&#34;).exec();&#xA;&#xA;// Create a Redis object with hash-tag.&#xA;// It connects to the Redis instance that holds the given key, i.e. hash-tag.&#xA;auto r = redis_cluster.redis(&#34;hash-tag&#34;);&#xA;&#xA;// And send command without key parameter to the server.&#xA;r.command(&#34;client&#34;, &#34;setname&#34;, &#34;connection-name&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: By default, when you use &lt;code&gt;RedisCluster::redis(const StringView &amp;amp;hash_tag, bool new_connection = true)&lt;/code&gt; to create a &lt;code&gt;Redis&lt;/code&gt; object, instead of picking a connection from the underlying connection pool, it creates a new connection to the corresponding Redis server. So this is NOT a cheap operation, and you should try to reuse this newly created &lt;code&gt;Redis&lt;/code&gt; object as much as possible. If you pass &lt;code&gt;false&lt;/code&gt; as the second parameter, you can create a &lt;code&gt;Redis&lt;/code&gt; object without creating a new connection. However, in this case, you should be very careful, otherwise, you might get bad performance or even dead lock. Please carefully check the related &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#very-important-notes&#34;&gt;pipeline section&lt;/a&gt; before using this feature.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// This is BAD! It&#39;s very inefficient.&#xA;// NEVER DO IT!!!&#xA;// After sending PING command, the newly created Redis object will be destroied.&#xA;cluster.redis(&#34;key&#34;).ping();&#xA;&#xA;// Then it creates a connection to Redis, and closes the connection after sending the command.&#xA;cluster.redis(&#34;key&#34;).command(&#34;client&#34;, &#34;setname&#34;, &#34;hello&#34;);&#xA;&#xA;// Instead you should reuse the Redis object.&#xA;// This is GOOD!&#xA;auto redis = cluster.redis(&#34;key&#34;);&#xA;&#xA;redis.ping();&#xA;redis.command(&#34;client&#34;, &#34;setname&#34;, &#34;hello&#34;);&#xA;&#xA;// This is GOOD! Create `Redis` object without creating a new connection. Use it, and destroy it ASAP.&#xA;cluster.redis(&#34;key&#34;, false).ping();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Details&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;RedisCluster&lt;/code&gt; maintains the newest slot-node mapping, and sends command directly to the right node. Normally it works as fast as &lt;code&gt;Redis&lt;/code&gt;. If the cluster reshards, &lt;code&gt;RedisCluster&lt;/code&gt; will follow the redirection, and it will finally update the slot-node mapping. It can correctly handle the following resharding cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Data migration between exist nodes.&lt;/li&gt; &#xA; &lt;li&gt;Add new node to the cluster.&lt;/li&gt; &#xA; &lt;li&gt;Remove node from the cluster.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;redis-plus-plus&lt;/code&gt; is able to handle both &lt;a href=&#34;https://redis.io/topics/cluster-spec#moved-redirection&#34;&gt;MOVED&lt;/a&gt; and &lt;a href=&#34;https://redis.io/topics/cluster-spec#ask-redirection&#34;&gt;ASK&lt;/a&gt; redirections, so it&#39;s a complete Redis Cluster client.&lt;/p&gt; &#xA;&lt;p&gt;If master is down, the cluster will promote one of its replicas to be the new master. &lt;em&gt;redis-plus-plus&lt;/em&gt; can also handle this case:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When the master is down, &lt;em&gt;redis-plus-plus&lt;/em&gt; losts connection to it. In this case, if you try to send commands to this master, &lt;em&gt;redis-plus-plus&lt;/em&gt; will try to update slot-node mapping from other nodes. If the mapping remains unchanged, i.e. new master hasn&#39;t been elected yet, it fails to send command to Redis Cluster and throws exception.&lt;/li&gt; &#xA; &lt;li&gt;When the new master has been elected, the slot-node mapping will be updated by the cluster. In this case, if you send commands to the cluster, &lt;em&gt;redis-plus-plus&lt;/em&gt; can get an update-to-date mapping, and sends commands to the new master.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Redis Sentinel&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/sentinel&#34;&gt;Redis Sentinel provides high availability for Redis&lt;/a&gt;. If Redis master is down, Redis Sentinels will elect a new master from slaves, i.e. failover. Besides, Redis Sentinel can also act like a configuration provider for clients, and clients can query master or slave address from Redis Sentinel. So that if a failover occurs, clients can ask the new master address from Redis Sentinel.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; supports getting Redis master or slave&#39;s IP and port from Redis Sentinel. In order to use this feature, you only need to initialize &lt;code&gt;Redis&lt;/code&gt; object with Redis Sentinel info, which is composed with 3 parts: &lt;code&gt;std::shared_ptr&amp;lt;Sentinel&amp;gt;&lt;/code&gt;, master name and role (master or slave).&lt;/p&gt; &#xA;&lt;p&gt;Before using Redis Sentinel with &lt;em&gt;redis-plus-plus&lt;/em&gt;, ensure that you have read Redis Sentinel&#39;s &lt;a href=&#34;https://redis.io/topics/sentinel&#34;&gt;doc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Sentinel&lt;/h4&gt; &#xA;&lt;p&gt;You can create a &lt;code&gt;std::shared_ptr&amp;lt;Sentinel&amp;gt;&lt;/code&gt; object with &lt;code&gt;SentinelOptions&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;SentinelOptions sentinel_opts;&#xA;sentinel_opts.nodes = {{&#34;127.0.0.1&#34;, 9000},&#xA;                        {&#34;127.0.0.1&#34;, 9001},&#xA;                        {&#34;127.0.0.1&#34;, 9002}};   // Required. List of Redis Sentinel nodes.&#xA;&#xA;// Optional. Timeout before we successfully connect to Redis Sentinel.&#xA;// By default, the timeout is 100ms.&#xA;sentinel_opts.connect_timeout = std::chrono::milliseconds(200);&#xA;&#xA;// Optional. Timeout before we successfully send request to or receive response from Redis Sentinel.&#xA;// By default, the timeout is 100ms.&#xA;sentinel_opts.socket_timeout = std::chrono::milliseconds(200);&#xA;&#xA;auto sentinel = std::make_shared&amp;lt;Sentinel&amp;gt;(sentinel_opts);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;SentinelOptions::connect_timeout&lt;/code&gt; and &lt;code&gt;SentinelOptions::socket_timeout&lt;/code&gt; CANNOT be 0ms, i.e. no timeout and block forever. Otherwise, &lt;em&gt;redis-plus-plus&lt;/em&gt; will throw an exception.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/raw/master/src/sw/redis%2B%2B/sentinel.h#L33&#34;&gt;SentinelOptions&lt;/a&gt; for more options.&lt;/p&gt; &#xA;&lt;h4&gt;Role&lt;/h4&gt; &#xA;&lt;p&gt;Besides &lt;code&gt;std::shared_ptr&amp;lt;Sentinel&amp;gt;&lt;/code&gt; and master name, you also need to specify a role. There are two roles: &lt;code&gt;Role::MASTER&lt;/code&gt;, and &lt;code&gt;Role::SLAVE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With &lt;code&gt;Role::MASTER&lt;/code&gt;, &lt;em&gt;redis-plus-plus&lt;/em&gt; will always connect to current master instance, even if a failover occurs. Each time when &lt;em&gt;redis-plus-plus&lt;/em&gt; needs to create a new connection to master, or a connection is broken, and it needs to reconnect to master, &lt;em&gt;redis-plus-plus&lt;/em&gt; will ask master address from Redis Sentinel, and connects to current master. If a failover occurs, &lt;em&gt;redis-plus-plus&lt;/em&gt; can automatically get the address of the new master, and refresh all connections in the underlying connection pool.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, with &lt;code&gt;Role::SLAVE&lt;/code&gt;, &lt;em&gt;redis-plus-plus&lt;/em&gt; will always connect to a slave instance. A master might have several slaves, &lt;em&gt;redis-plus-plus&lt;/em&gt; will randomly pick one, and connect to it, i.e. all connections in the underlying connection pool, connect to the same slave instance (check &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/99&#34;&gt;this discussion&lt;/a&gt; on why &lt;em&gt;redis-plus-plus&lt;/em&gt; not connect to all slaves). If the connection is broken, while this slave instance is still an alive slave, &lt;em&gt;redis-plus-plus&lt;/em&gt; will reconnect to this slave. However, if this slave instance is down, or it has been promoted to be the master, &lt;em&gt;redis-plus-plus&lt;/em&gt; will randomly connect to another slave. If there&#39;s no slave alive, it throws an exception.&lt;/p&gt; &#xA;&lt;h4&gt;Create Redis With Sentinel&lt;/h4&gt; &#xA;&lt;p&gt;When creating a &lt;code&gt;Redis&lt;/code&gt; object with sentinel, besides the sentinel info, you should also provide &lt;code&gt;ConnectionOptions&lt;/code&gt; and &lt;code&gt;ConnectionPoolOptions&lt;/code&gt;. These two options are used to connect to Redis instance. &lt;code&gt;ConnectionPoolOptions&lt;/code&gt; is optional, if not specified, it creates a single connection the instance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;ConnectionOptions connection_opts;&#xA;connection_opts.password = &#34;auth&#34;;  // Optional. No password by default.&#xA;connection_opts.connect_timeout = std::chrono::milliseconds(100);   // Required.&#xA;connection_opts.socket_timeout = std::chrono::milliseconds(100);    // Required.&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3; // Optional. The default size is 1.&#xA;&#xA;auto redis = Redis(sentinel, &#34;master_name&#34;, Role::MASTER, connection_opts, pool_opts);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You might have noticed that we didn&#39;t specify the &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; fields for &lt;code&gt;ConnectionOptions&lt;/code&gt;. Because, &lt;code&gt;Redis&lt;/code&gt; will get these info from Redis Sentinel. Also, in this case, &lt;code&gt;ConnectionOptions::connect_timeout&lt;/code&gt; and &lt;code&gt;ConnectionOptions::socket_timeout&lt;/code&gt; CANNOT be 0ms, otherwise, it throws an exception. So you always need to specify these two timeouts manually.&lt;/p&gt; &#xA;&lt;p&gt;After creating the &lt;code&gt;Redis&lt;/code&gt; object with sentinel, you can send commands with it, just like an ordinary &lt;code&gt;Redis&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;If you want to write to master, and scale read with slaves. You can use the following pattern:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto sentinel = std::make_shared&amp;lt;Sentinel&amp;gt;(sentinel_opts);&#xA;&#xA;auto master = Redis(sentinel, &#34;master_name&#34;, Role::MASTER, connection_opts, pool_opts);&#xA;&#xA;auto slave = Redis(sentinel, &#34;master_name&#34;, Role::SLAVE, connection_opts, pool_opts);&#xA;&#xA;// Write to master.&#xA;master.set(&#34;key&#34;, &#34;value&#34;);&#xA;&#xA;// Read from slave.&#xA;slave.get(&#34;key&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Redis Stream&lt;/h3&gt; &#xA;&lt;p&gt;Since Redis 5.0, it introduces a new data type: &lt;em&gt;Redis Stream&lt;/em&gt;. &lt;em&gt;redis-plus-plus&lt;/em&gt; has built-in methods for all stream commands except the &lt;em&gt;XINFO&lt;/em&gt; command (of course, you can use the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#generic-command-interface&#34;&gt;Generic Command Interface&lt;/a&gt; to send &lt;em&gt;XINFO&lt;/em&gt; command).&lt;/p&gt; &#xA;&lt;p&gt;However, the replies of some streams commands, i.e. &lt;em&gt;XPENDING&lt;/em&gt;, &lt;em&gt;XREAD&lt;/em&gt;, are complex. So I&#39;ll give some examples to show you how to work with these built-in methods.&lt;/p&gt; &#xA;&lt;h4&gt;Examples&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;auto redis = Redis(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;using Attrs = std::vector&amp;lt;std::pair&amp;lt;std::string, std::string&amp;gt;&amp;gt;;&#xA;&#xA;// You can also use std::unordered_map, if you don&#39;t care the order of attributes:&#xA;// using Attrs = std::unordered_map&amp;lt;std::string, std::string&amp;gt;;&#xA;&#xA;Attrs attrs = { {&#34;f1&#34;, &#34;v1&#34;}, {&#34;f2&#34;, &#34;v2&#34;} };&#xA;&#xA;// Add an item into the stream. This method returns the auto generated id.&#xA;auto id = redis.xadd(&#34;key&#34;, &#34;*&#34;, attrs.begin(), attrs.end());&#xA;&#xA;// Each item is assigned with an id: pair&amp;lt;id, Optional&amp;lt;attributes&amp;gt;&amp;gt;.&#xA;// NOTE: the attribute part might be nil reply, check [this issue](https://github.com/sewenew/redis-plus-plus/issues/283) for detail.&#xA;using Item = std::pair&amp;lt;std::string, Optional&amp;lt;Attrs&amp;gt;&amp;gt;;&#xA;using ItemStream = std::vector&amp;lt;Item&amp;gt;;&#xA;&#xA;// If you don&#39;t care the order of items in the stream, you can also use unordered_map:&#xA;// using ItemStream = std::unordered_map&amp;lt;std::string, Attrs&amp;gt;;&#xA;&#xA;// Read items from a stream, and return at most 10 items.&#xA;// You need to specify a key and an id (timestamp + offset).&#xA;std::unordered_map&amp;lt;std::string, ItemStream&amp;gt; result;&#xA;redis.xread(&#34;key&#34;, id, 10, std::inserter(result, result.end()));&#xA;&#xA;// Read from multiple streams. For each stream, you need to specify a key and an id.&#xA;std::unordered_map&amp;lt;std::string, std::string&amp;gt; keys = { {&#34;key&#34;, id}, {&#34;another-key&#34;, &#34;0-0&#34;} };&#xA;redis.xread(keys.begin(), keys.end(), 10, std::inserter(result, result.end()));&#xA;&#xA;// Block for at most 1 second if currently there&#39;s no data in the stream.&#xA;redis.xread(&#34;key&#34;, id, std::chrono::seconds(1), 10, std::inserter(result, result.end()));&#xA;&#xA;// Block for multiple streams.&#xA;redis.xread(keys.begin(), keys.end(), std::chrono::seconds(1), 10, std::inserter(result, result.end()));&#xA;&#xA;// Read items in a range:&#xA;ItemStream item_stream;&#xA;redis.xrange(&#34;key&#34;, &#34;-&#34;, &#34;+&#34;, std::back_inserter(item_stream));&#xA;&#xA;// Trim the stream to a given number of items. After the operation, the stream length is NOT exactly&#xA;// 10. Instead, it might be much larger than 10.&#xA;// `XTRIM key MAXLEN 10`&#xA;redis.xtrim(&#34;key&#34;, 10);&#xA;&#xA;// In order to trim the stream to exactly 10 items, specify the third argument, i.e. approx, as false.&#xA;// `XTRIM key MAXLEN ~ 10`&#xA;redis.xtrim(&#34;key&#34;, 10, false);&#xA;&#xA;// Delete an item from the stream.&#xA;redis.xdel(&#34;key&#34;, id);&#xA;&#xA;// Create a consumer group.&#xA;redis.xgroup_create(&#34;key&#34;, &#34;group&#34;, &#34;$&#34;);&#xA;&#xA;// If the stream doesn&#39;t exist, you can set the fourth argument, i.e. MKSTREAM, to be true.&#xA;// redis.xgroup_create(&#34;key&#34;, &#34;group&#34;, &#34;$&#34;, true);&#xA;&#xA;id = redis.xadd(&#34;key&#34;, &#34;*&#34;, attrs.begin(), attrs.end());&#xA;&#xA;// Read item by a consumer of a consumer group.&#xA;redis.xreadgroup(&#34;group&#34;, &#34;consumer&#34;, &#34;key&#34;, &#34;&amp;gt;&#34;, 1, std::inserter(result, result.end()));&#xA;&#xA;using PendingItem = std::tuple&amp;lt;std::string, std::string, long long, long long&amp;gt;;&#xA;std::vector&amp;lt;PendingItem&amp;gt; pending_items;&#xA;&#xA;// Get pending items of a speicified consumer.&#xA;redis.xpending(&#34;key&#34;, &#34;group&#34;, &#34;-&#34;, &#34;+&#34;, 1, &#34;consumer&#34;, std::back_inserter(pending_items));&#xA;&#xA;redis.xack(&#34;key&#34;, &#34;group&#34;, id);&#xA;&#xA;redis.xgroup_delconsumer(&#34;key&#34;, &#34;group&#34;, &#34;consumer&#34;);&#xA;redis.xgroup_destroy(&#34;key&#34;, &#34;group&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have any problem on sending stream commands to Redis, please feel free to let me know.&lt;/p&gt; &#xA;&lt;h3&gt;Redis Modules&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/modules&#34;&gt;Redis Modules&lt;/a&gt; enrich Redis. However, &lt;em&gt;redis-plus-plus&lt;/em&gt; does not have built-in support/method for these modules, although you can use the &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#generic-command-interface&#34;&gt;generic interface&lt;/a&gt; to send commands related to these modules.&lt;/p&gt; &#xA;&lt;p&gt;Fortunately, &lt;a href=&#34;https://github.com/wingunder&#34;&gt;@wingunder&lt;/a&gt; did a great job to make the work easier. He wrote &lt;a href=&#34;https://github.com/wingunder/redis-plus-plus-modules&#34;&gt;redis-plus-plus-modules&lt;/a&gt;, which is a header only project that has built-in support for some popular modules. If you need to work with Redis Modules, you should have a try.&lt;/p&gt; &#xA;&lt;p&gt;@wingunder also contributes a lot to &lt;em&gt;redis-plus-plus&lt;/em&gt;. Many thanks to @wingunder!&lt;/p&gt; &#xA;&lt;h3&gt;Async Interface&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; also supports async interface, however, async support for Transaction is still on the way.&lt;/p&gt; &#xA;&lt;p&gt;The async interface depends on third-party event library, and so far, only libuv is supported.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;p&gt;You must install &lt;em&gt;libuv&lt;/em&gt;(e.g. &lt;em&gt;apt-get install libuv1-dev&lt;/em&gt;) before install &lt;em&gt;hiredis&lt;/em&gt; and &lt;em&gt;redis-plus-plus&lt;/em&gt;. The required libuv version is &lt;em&gt;1.x&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;hiredis&lt;/em&gt; v1.0.0&#39;s async interface is different from older version, and &lt;em&gt;redis-plus-plus&lt;/em&gt; only supports &lt;em&gt;hiredis&lt;/em&gt; v1.0.0 or later. So you need to ensure you&#39;ve installed the right version of hiredis before installing &lt;em&gt;redis-plus-plus&lt;/em&gt;. Also, you should NEVER install multiple versions of &lt;em&gt;hiredis&lt;/em&gt;, otherwise, you&#39;ll get some wired problems. If you already installed an older version, remove it, and install a newer version.&lt;/p&gt; &#xA;&lt;p&gt;When installing &lt;em&gt;redis-plus-plus&lt;/em&gt;, you should specify the following command line option: &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_ASYNC=libuv&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DCMAKE_PREFIX_PATH=/installation/path/to/libuv/and/hiredis -DREDIS_PLUS_PLUS_BUILD_ASYNC=libuv ..&#xA;&#xA;make&#xA;&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Getting Started&lt;/h4&gt; &#xA;&lt;p&gt;The async interface is similar to sync interface, except that you should include &lt;em&gt;sw/redis++/async_redis++.h&lt;/em&gt;, and define an object of &lt;code&gt;sw::redis::AsyncRedis&lt;/code&gt;, and the related methods return &lt;code&gt;Future&lt;/code&gt; object (so far, only &lt;code&gt;std::future&lt;/code&gt; and &lt;code&gt;boost::future&lt;/code&gt; are supported, support for other implementations of &lt;em&gt;future&lt;/em&gt; is on the way).&lt;/p&gt; &#xA;&lt;p&gt;However, C++&#39;s support for continuation and executor is not done yet, so the async interface also supports the old callback way. The following is the callback interface:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;template &amp;lt;typename ReplyType&amp;gt;&#xA;void (sw::redis::Future&amp;lt;ReplyType&amp;gt; &amp;amp;&amp;amp;fut);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the callback, in order to get the reply, you need to call &lt;code&gt;sw::redis::Future&amp;lt;ReplyType&amp;gt;::get()&lt;/code&gt;. If something bad happened, &lt;code&gt;get&lt;/code&gt; throws exception. So you need to catch possible exception in the callback. The callback runs in the underlying event loop thread, so DO NOT do slow operations in the callback, otherwise, it blocks the event loop and hurts performance.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When building your application code, don&#39;t forget to link libuv.&lt;/li&gt; &#xA; &lt;li&gt;So far, the callback interface only implements few built-in commands. For other commands, you need to use the generic interface to send command to Redis (see below for example). You&#39;re always welcome to contribute more built-in commands.&lt;/li&gt; &#xA; &lt;li&gt;You must ensure &lt;code&gt;AsyncRedis&lt;/code&gt; alive before all callbacks have been executed (with some synchronization work). Because, once &lt;code&gt;AsyncRedis&lt;/code&gt; is destroyed, it will stop the underlying event loop. And any commands that haven&#39;t sent to Redis yet, might fail.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These notes also work with &lt;code&gt;AsyncRedisCluster&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;sw/redis++/async_redis++.h&amp;gt;&#xA;&#xA;ConnectionOptions opts;&#xA;opts.host = &#34;127.0.0.1&#34;;&#xA;opts.port = 6379;&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3;&#xA;&#xA;auto async_redis = AsyncRedis(opts, pool_opts);&#xA;&#xA;Future&amp;lt;string&amp;gt; ping_res = async_redis.ping();&#xA;&#xA;// Async interface returning Future object.&#xA;Future&amp;lt;bool&amp;gt; set_res = async_redis.set(&#34;key&#34;, &#34;val&#34;);&#xA;&#xA;// Async interface with callback.&#xA;async_redis.set(&#34;key&#34;, &#34;val&#34;,&#xA;        [](Future&amp;lt;bool&amp;gt; &amp;amp;&amp;amp;fut) {&#xA;            try {&#xA;                auto set_res = fut.get();&#xA;            } catch (const Error &amp;amp;err) {&#xA;                // handle error&#xA;            }&#xA;        });&#xA;&#xA;Future&amp;lt;Optional&amp;lt;string&amp;gt;&amp;gt; get_res = async_redis.get(&#34;key&#34;);&#xA;&#xA;async_redis.get(&#34;key&#34;, [](Future&amp;lt;OptionalString&amp;gt; &amp;amp;&amp;amp;fut) {&#xA;            try {&#xA;                auto val = fut.get();&#xA;                if (val)&#xA;                    cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; endl;&#xA;                else&#xA;                    cout &amp;lt;&amp;lt; &#34;not exist&#34; &amp;lt;&amp;lt; endl;&#xA;            } catch (const Error &amp;amp;err) {&#xA;                // handle error&#xA;            }&#xA;        });&#xA;&#xA;unordered_map&amp;lt;string, string&amp;gt; m = {{&#34;a&#34;, &#34;b&#34;}, {&#34;c&#34;, &#34;d&#34;}};&#xA;Future&amp;lt;void&amp;gt; hmset_res = async_redis.hmset(&#34;hash&#34;, m.begin(), m.end());&#xA;&#xA;auto hgetall_res = async_redis.hgetall&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;(&#34;hash&#34;);&#xA;&#xA;cout &amp;lt;&amp;lt; ping_res.get() &amp;lt;&amp;lt; endl;&#xA;cout &amp;lt;&amp;lt; set_res.get() &amp;lt;&amp;lt; endl;&#xA;auto val = get_res.get();&#xA;if (val)&#xA;    cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; endl;&#xA;else&#xA;    cout &amp;lt;&amp;lt; &#34;not exist&#34; &amp;lt;&amp;lt; endl;&#xA;&#xA;hmset_res.get();&#xA;&#xA;for (const auto &amp;amp;ele : hgetall_res.get())&#xA;    cout &amp;lt;&amp;lt; ele &amp;lt;&amp;lt; endl;&#xA;&#xA;// Generic interface.&#xA;&#xA;// There&#39;s no *AsyncRedis::client_getname* interface.&#xA;// But you can use *Redis::command* to get the client name.&#xA;auto getname_res = async_redis.command&amp;lt;OptionalString&amp;gt;(&#34;client&#34;, &#34;getname&#34;);&#xA;val = getname_res.get();&#xA;if (val) {&#xA;    std::cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; std::endl;&#xA;}&#xA;&#xA;async_redis.command&amp;lt;OptionalString&amp;gt;(&#34;client&#34;, &#34;getname&#34;,&#xA;        [](Future&amp;lt;OptionalString&amp;gt; &amp;amp;&amp;amp;fut) {&#xA;            try {&#xA;                auto val = fut.get();&#xA;            } catch (const Error &amp;amp;e) {&#xA;                // handle error&#xA;            }&#xA;        });&#xA;&#xA;async_redis.command&amp;lt;long long&amp;gt;(&#34;incr&#34;, &#34;number&#34;,&#xA;        [](Future&amp;lt;long long&amp;gt; &amp;amp;&amp;amp;fut) {&#xA;            try {&#xA;                cout &amp;lt;&amp;lt; fut.get() &amp;lt;&amp;lt; endl;&#xA;            } catch (const Error &amp;amp;e) {&#xA;                // handle error&#xA;            }&#xA;        });&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Redis Sentinel&lt;/h4&gt; &#xA;&lt;p&gt;Aysnc interface also supports Redis Sentinel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;sw/redis++/async_redis++.h&amp;gt;&#xA;&#xA;SentinelOptions sentinel_opts;&#xA;sentinel_opts.nodes = {&#xA;    {&#34;127.0.0.1&#34;, 8000},&#xA;    {&#34;127.0.0.1&#34;, 8001},&#xA;    {&#34;127.0.0.1&#34;, 8002}&#xA;};&#xA;&#xA;sentinel_opts.connect_timeout = std::chrono::milliseconds(100);&#xA;sentinel_opts.socket_timeout = std::chrono::milliseconds(100);&#xA;&#xA;auto sentinel = std::make_shared&amp;lt;AsyncSentinel&amp;gt;(sentinel_opts);&#xA;&#xA;onnectionOptions connection_opts;&#xA;connection_opts.connect_timeout = std::chrono::milliseconds(100);   // Required.&#xA;connection_opts.socket_timeout = std::chrono::milliseconds(100);   // Required.&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3; // Optional. The default size is 1.&#xA;&#xA;// Connect to master node.&#xA;AsyncRedis redis(sentinel, &#34;mymaster&#34;, Role::MASTER, connection_opts, pool_opts);&#xA;&#xA;// The following code randomly connects to one of the slave nodes.&#xA;// AsyncRedis redis(sentinel, &#34;mymaster&#34;, Role::SLAVE, connection_opts, pool_opts);&#xA;&#xA;redis.set(&#34;key&#34;, &#34;value&#34;);&#xA;&#xA;auto value = redis.get(&#34;key&#34;).get();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The async support for sentinel is similar with the sync one, except that you need to create an &lt;code&gt;AsyncSentinel&lt;/code&gt; object instead of a &lt;code&gt;Sentinel&lt;/code&gt; object. Check &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-sentinel&#34;&gt;Redis Sentinel&lt;/a&gt; for more details on &lt;code&gt;SentinelOptions&lt;/code&gt;, &lt;code&gt;ConnectionOptions&lt;/code&gt; and &lt;code&gt;Role&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Redis Cluster&lt;/h4&gt; &#xA;&lt;p&gt;Aysnc interface also supports Redis Cluster. Instead of &lt;code&gt;AsyncRedis&lt;/code&gt;, you need to create an &lt;code&gt;AsyncRedisCluster&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ConnectionOptions opts;&#xA;opts.host = &#34;127.0.0.1&#34;;&#xA;opts.port = 6379;&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3;&#xA;&#xA;auto async_cluster = AsyncRedisCluster(opts, pool_opts);&#xA;&#xA;Future&amp;lt;bool&amp;gt; set_res = async_cluster.set(&#34;key&#34;, &#34;val&#34;);&#xA;&#xA;Future&amp;lt;Optional&amp;lt;string&amp;gt;&amp;gt; get_res = async_cluster.get(&#34;key&#34;);&#xA;&#xA;auto mget_res = async_cluster.mget&amp;lt;std::vector&amp;lt;OptionalString&amp;gt;&amp;gt;({&#34;{hashtag}key1&#34;, &#34;{hashhag}key2&#34;, &#34;{hashtag}key3&#34;});&#xA;&#xA;unordered_map&amp;lt;string, string&amp;gt; m = {{&#34;a&#34;, &#34;b&#34;}, {&#34;c&#34;, &#34;d&#34;}};&#xA;Future&amp;lt;void&amp;gt; hmset_res = async_redis.hmset(&#34;hash&#34;, m.begin(), m.end());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Async Subscriber&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: I&#39;m not quite satisfied with the interface of &lt;code&gt;AsyncSubscriber&lt;/code&gt;. If you have a better idea, feel free to open an issue for discussion.&lt;/p&gt; &#xA;&lt;p&gt;You can use &lt;code&gt;AsyncSubscriber&lt;/code&gt; to subscribe to channels or patterns asynchronously. The interface is similar to &lt;code&gt;Subscriber&lt;/code&gt;, except a few differences (please read &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#publishsubscribe&#34;&gt;Publish/Subscribe section&lt;/a&gt; first):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There&#39;s no &lt;code&gt;consume&lt;/code&gt; method for &lt;code&gt;AsyncSubscriber&lt;/code&gt;. Once you setup callbacks, and subscribe to some channel, redis-plus-plus will run callbacks with received messages in the underlying event loop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncSubscriber::subscribe&lt;/code&gt;, &lt;code&gt;AsyncSubscriber::psubscriber&lt;/code&gt; and other related methods return &lt;code&gt;Future&amp;lt;void&amp;gt;&lt;/code&gt;. You can use it to check if the subscription has been sent.&lt;/li&gt; &#xA; &lt;li&gt;You need to setup a error callback with &lt;code&gt;AsyncSubscriber::on_error(ErrCallback &amp;amp;&amp;amp;)&lt;/code&gt; to handle possible errors. The error callback interface is: &lt;code&gt;void (std::exception_ptr err)&lt;/code&gt;, and you can get the exception with given exception pointer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Tips&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Since redis-plus-plus runs callbacks in the event loop, you MUST NOT run slow operations, e.g. IO operation, in callbacks. Otherwise, you might get performance problem.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;AsyncSubscriber&lt;/code&gt; is NOT thread-safe. If you want to call its member functions in multi-thread environment, you need to synchronize between threads manually.&lt;/li&gt; &#xA; &lt;li&gt;You MUST setup callbacks before subscribing to some channel. Once the subscription begins, you cannot change the callback, otherwise, the behavior is undefined.&lt;/li&gt; &#xA; &lt;li&gt;If you subscribe to multiple channels or patterns, error callback might called multiple times. Say, if you subscribe to 2 channels, and somehow, the server closes the connection, the error callback will be called twice. So you MUST ensure that the error callback can be run multiple times.&lt;/li&gt; &#xA; &lt;li&gt;When &lt;code&gt;AsyncSubscriber&lt;/code&gt; is destroyed, the underlying connection will be closed. If there&#39;re still channels or patterns not unsubscribed, the error callback will be called. In order to avoid it, you need to call &lt;code&gt;AsyncSubscriber::unsubscribe()&lt;/code&gt; or &lt;code&gt;AsyncSubscriber::punsubscribe()&lt;/code&gt; to unsubscribe all channels or patterns before destroying &lt;code&gt;AsyncSubscriber&lt;/code&gt;. NOTE: this behavior might be changed in the future, i.e. we&#39;ll unsubscribe channels and patterns in the destructor of &lt;code&gt;AsyncSubscriber&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Examples&lt;/h5&gt; &#xA;&lt;p&gt;The following example is a common pattern to use &lt;code&gt;AsyncSubscriber&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Create an `AsyncSubscriber`. You can create it with either an `AsyncRedis` or `AsyncRedisCluster` object.&#xA;auto sub = async_redis.subscriber();&#xA;&#xA;// Set callbacks.&#xA;sub.on_message([](std::string channel, std::string msg) {&#xA;            // Process message of MESSAGE type.&#xA;        });&#xA;&#xA;sub.on_pmessage([](std::string pattern, std::string channel, std::string msg) {&#xA;            // Process message of PMESSAGE type.&#xA;        });&#xA;&#xA;sub.on_meta([](Subscriber::MsgType type, OptionalString channel, long long num) {&#xA;            // Process message of META type.&#xA;        });&#xA;&#xA;// You need to set error callback to handle error.&#xA;sub.on_error([](std::exception_ptr e) {&#xA;            try {&#xA;                std::rethrow_exception(e);&#xA;            } catch (const std::exception &amp;amp;err) {&#xA;                std::cerr &amp;lt;&amp;lt; &#34;err: &#34; &amp;lt;&amp;lt; err.what() &amp;lt;&amp;lt; std::endl;&#xA;            }&#xA;        });&#xA;&#xA;// Subscribe to channels and patterns.&#xA;Future&amp;lt;void&amp;gt; fut1 = sub.subscribe(&#34;channel&#34;);&#xA;Future&amp;lt;void&amp;gt; fut2 = sub.psubscribe(&#34;pattern1*&#34;);&#xA;&#xA;// Once you call `subscribe` or `psubscribe`, callbacks will be run in the underlying&#xA;// event loop automatically.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Event Loop&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The following is an experimental feature, and might be modified or abandaned in the future.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;AsyncRedis&lt;/code&gt; and &lt;code&gt;AsyncRedisCluster&lt;/code&gt; create a default event loop, and runs the loop in a dedicated thread to handle read and write operations. However, you can also share the underlying event loop with multiple &lt;code&gt;AsyncRedis&lt;/code&gt; and &lt;code&gt;AsyncRedisCluster&lt;/code&gt; objects. In order to do that, you need to create a &lt;code&gt;std::shared_ptr&amp;lt;EventLoop&amp;gt;&lt;/code&gt;, and pass it to the constructors of &lt;code&gt;AsyncRedis&lt;/code&gt; and &lt;code&gt;AsyncRedisCluster&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto event_loop = std::make_shared&amp;lt;EventLoop&amp;gt;();&#xA;&#xA;auto redis = AsyncRedis(connection_opts, pool_opts, loop);&#xA;&#xA;auto cluster = AsyncRedisCluster(connection_opts, pool_opts, Role::MASTER, loop);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: You must ensure &lt;code&gt;event_loop&lt;/code&gt; lives longer than &lt;code&gt;AsyncRedis&lt;/code&gt; and &lt;code&gt;AsyncRedisCluster&lt;/code&gt; objects.&lt;/p&gt; &#xA;&lt;h4&gt;Future with Continuation&lt;/h4&gt; &#xA;&lt;p&gt;Unfortunately, &lt;code&gt;std::future&lt;/code&gt; doesn&#39;t support &lt;a href=&#34;https://en.cppreference.com/w/cpp/experimental/future/then&#34;&gt;continuation&lt;/a&gt; so far, which is inconvenient. However, some other libraries, e.g. boost and folly, have continuation support.&lt;/p&gt; &#xA;&lt;p&gt;By default, &lt;em&gt;redis-plus-plus&lt;/em&gt; returns &lt;code&gt;std::future&lt;/code&gt; for async interface. However, you can also make it return &lt;code&gt;boost::future&lt;/code&gt; by specifying &lt;code&gt;-DREDIS_PLUS_PLUS_ASYNC_FUTURE=boost&lt;/code&gt; when running cmake (&lt;code&gt;folly&lt;/code&gt; and other libraries might be supported in the future). Of course, in this case, you need to install Boost first (the minimum version requirement for Boost is &lt;strong&gt;1.55.0&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DREDIS_PLUS_PLUS_BUILD_ASYNC=libuv -DREDIS_PLUS_PLUS_ASYNC_FUTURE=boost ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: When building your application code, don&#39;t forget to link boost related libs, e.g. -lboost_thread, -lboost_system.&lt;/p&gt; &#xA;&lt;p&gt;Then you can take advantage of &lt;code&gt;boost::future&lt;/code&gt;&#39;s continuation support:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;sw/redis++/async_redis++.h&amp;gt;&#xA;&#xA;ConnectionOptions opts;&#xA;opts.host = &#34;127.0.0.1&#34;;&#xA;opts.port = 6379;&#xA;auto redis = AsyncRedis(opts);&#xA;auto fut = redis.get(&#34;key&#34;).then([](sw::redis::Future&amp;lt;sw::redis::Optional&amp;lt;std::string&amp;gt;&amp;gt; fut) {&#xA;                                    auto val = fut.get();&#xA;                                    if (val) cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; endl;&#xA;                                });&#xA;// Do other things&#xA;&#xA;// Wait for the continuation finishes.&#xA;fut.get();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also use a thread pool to run the continuation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define BOOST_THREAD_PROVIDES_EXECUTORS&#xA;&#xA;// You might also need to `#define BOOST_THREAD_USES_MOVE` with some version of Boost.&#xA;// See [this issue](https://github.com/sewenew/redis-plus-plus/issues/272) for detail.&#xA;&#xA;#include &amp;lt;sw/redis++/async_redis++.h&amp;gt;&#xA;#include &amp;lt;boost/thread/executors/basic_thread_pool.hpp&amp;gt;&#xA;&#xA;boost::executors::basic_thread_pool pool(3);&#xA;auto fut = redis.get(&#34;key&#34;).then(pool,&#xA;        [](sw::redis::Future&amp;lt;sw::redis::Optional&amp;lt;std::string&amp;gt;&amp;gt; fut) {&#xA;            auto val = fut.get();&#xA;            if (val) cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; endl;&#xA;        });&#xA;&#xA;// Do other things&#xA;&#xA;fut.get();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Coroutine Interface&lt;/h3&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; also supports coroutine interface, however, coroutine support for Subscriber and Transaction is still on the way.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Coroutine support is still experimental, and the interface might be changed in the future.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;p&gt;The coroutine interface depends on async interface, which depends on third-party event library. So you need to install &lt;em&gt;libuv&lt;/em&gt; first, and &lt;em&gt;hiredis&lt;/em&gt; v1.0.0 or later. Check &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#async-interface&#34;&gt;async interface&lt;/a&gt; for detail.&lt;/p&gt; &#xA;&lt;p&gt;When installing &lt;em&gt;redis-plus-plus&lt;/em&gt;, you should specify the following command line options: &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_ASYNC=libuv&lt;/code&gt;, &lt;code&gt;-DREDIS_PLUS_PLUS_BUILD_CORO=ON&lt;/code&gt; and &lt;code&gt;-DREDIS_PLUS_PLUS_CXX_STANDARD=20&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmake -DCMAKE_PREFIX_PATH=/installation/path/to/libuv/and/hiredis -DREDIS_PLUS_PLUS_CXX_STANDARD=20 -DREDIS_PLUS_PLUS_BUILD_ASYNC=libuv -DREDIS_PLUS_PLUS_BUILD_CORO=ON ..&#xA;&#xA;make&#xA;&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Getting Started&lt;/h4&gt; &#xA;&lt;p&gt;The coroutine interface is similar to sync interface, except that you should include &lt;em&gt;sw/redis++/co_redis++.h&lt;/em&gt;, and define an object of &lt;code&gt;sw::redis::CoRedis&lt;/code&gt; or &lt;code&gt;sw::redis::CoRedisCluster&lt;/code&gt;, and the related methods return &lt;code&gt;sw::redis::CoRedis::Awaiter&amp;lt;Result&amp;gt;&lt;/code&gt; or &lt;code&gt;sw::redis::CoRedisCluster::Awaiter&amp;lt;Result&amp;gt;&lt;/code&gt; object.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;So far, the coroutine interface only implements a few built-in commands. For other commands, you need to use the generic interface to send command to Redis (see below for example). You&#39;re always welcome to contribute more built-in commands.&lt;/li&gt; &#xA; &lt;li&gt;Unfortunately, the C++ coroutine support is limited. In order to make it easier to use coroutine, you&#39;d better take advantages of some third-party libs, e.g. &lt;a href=&#34;https://github.com/andreasbuhr/cppcoro&#34;&gt;cppcoro&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;sw/redis++/co_redis++.h&amp;gt;&#xA;#include &amp;lt;cppcoro/task.hpp&amp;gt;&#xA;#include &amp;lt;cppcoro/sync_wait.hpp&amp;gt;&#xA;&#xA;ConnectionOptions opts;&#xA;opts.host = &#34;127.0.0.1&#34;;&#xA;opts.port = 6379;&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3;&#xA;&#xA;// `CoRedisCluster` has similar inteface as `CoRedis`.&#xA;// auto co_redis_cluster = CoRedisCluster(opts, pool_opts);&#xA;auto co_redis = CoRedis(opts, pool_opts);&#xA;cppcoro::sync_wait([&amp;amp;co_redis]() -&amp;gt; cppcoro::task&amp;lt;&amp;gt; {&#xA;        try {&#xA;            co_await co_redis.set(&#34;key&#34;, &#34;val&#34;);&#xA;            auto val = co_await co_redis.get(&#34;key&#34;);&#xA;            if (val)&#xA;                cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; endl;&#xA;            else&#xA;                cout &amp;lt;&amp;lt; &#34;not exist&#34; &amp;lt;&amp;lt; endl;&#xA;&#xA;            co_await co_redis.command&amp;lt;long long&amp;gt;(&#34;incr&#34;, &#34;num&#34;);&#xA;            val = co_await co_redis.command&amp;lt;OptionalString&amp;gt;(&#34;get&#34;, &#34;num&#34;);&#xA;        } catch (const Error &amp;amp;e) {&#xA;            cout &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; endl;&#xA;        }&#xA;    }());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Redis Sentinel&lt;/h4&gt; &#xA;&lt;p&gt;Coroutine interface also supports Redis Sentinel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;sw/redis++/co_redis++.h&amp;gt;&#xA;&#xA;SentinelOptions sentinel_opts;&#xA;sentinel_opts.nodes = {&#xA;    {&#34;127.0.0.1&#34;, 8000},&#xA;    {&#34;127.0.0.1&#34;, 8001},&#xA;    {&#34;127.0.0.1&#34;, 8002}&#xA;};&#xA;&#xA;sentinel_opts.connect_timeout = std::chrono::milliseconds(100);&#xA;sentinel_opts.socket_timeout = std::chrono::milliseconds(100);&#xA;&#xA;auto sentinel = std::make_shared&amp;lt;CoSentinel&amp;gt;(sentinel_opts);&#xA;&#xA;onnectionOptions connection_opts;&#xA;connection_opts.connect_timeout = std::chrono::milliseconds(100);   // Required.&#xA;connection_opts.socket_timeout = std::chrono::milliseconds(100);   // Required.&#xA;&#xA;ConnectionPoolOptions pool_opts;&#xA;pool_opts.size = 3; // Optional. The default size is 1.&#xA;&#xA;// Connect to master node.&#xA;CoRedis co_redis(sentinel, &#34;mymaster&#34;, Role::MASTER, connection_opts, pool_opts);&#xA;&#xA;// The following code randomly connects to one of the slave nodes.&#xA;// CoRedis co_redis(sentinel, &#34;mymaster&#34;, Role::SLAVE, connection_opts, pool_opts);&#xA;&#xA;cppcoro::sync_wait([&amp;amp;co_redis]() -&amp;gt; cppcoro::task&amp;lt;&amp;gt; {&#xA;        try {&#xA;            auto val = co_await co_redis.get(&#34;key&#34;);&#xA;            if (val)&#xA;                cout &amp;lt;&amp;lt; *val &amp;lt;&amp;lt; endl;&#xA;            else&#xA;                cout &amp;lt;&amp;lt; &#34;not exist&#34; &amp;lt;&amp;lt; endl;&#xA;        } catch (const Error &amp;amp;e) {&#xA;            cout &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; endl;&#xA;        }&#xA;    }());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The coroutine support for sentinel is similar with the sync one, except that you need to create an &lt;code&gt;CoSentinel&lt;/code&gt; object instead of a &lt;code&gt;Sentinel&lt;/code&gt; object. Check &lt;a href=&#34;https://raw.githubusercontent.com/sewenew/redis-plus-plus/master/#redis-sentinel&#34;&gt;Redis Sentinel&lt;/a&gt; for more details on &lt;code&gt;SentinelOptions&lt;/code&gt;, &lt;code&gt;ConnectionOptions&lt;/code&gt; and &lt;code&gt;Role&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Redis Patterns&lt;/h2&gt; &#xA;&lt;p&gt;We can create many interesting data structures and algorithms based on Redis, such as &lt;a href=&#34;https://redis.io/topics/distlock&#34;&gt;Redlock&lt;/a&gt;. We call these data structures and algorithms as &lt;strong&gt;Redis Patterns&lt;/strong&gt;. &lt;em&gt;redis-plus-plus&lt;/em&gt; will support some of these patterns.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: These patterns will be first implemented on the &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/tree/patterns&#34;&gt;patterns branch&lt;/a&gt;. I&#39;d like to hear your feedback on the API of these patterns, and when these APIs become stable, I&#39;ll merge the code into the master branch. So APIs on the &lt;em&gt;patterns&lt;/em&gt; branch are NOT stable, and might be changed in the future.&lt;/p&gt; &#xA;&lt;h3&gt;Redlock&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/distlock&#34;&gt;Redlock&lt;/a&gt; is a distributed lock based on Redis. Thanks to @wingunder&#39;s &lt;a href=&#34;https://github.com/sewenew/redis-plus-plus/issues/24&#34;&gt;suggestion&lt;/a&gt;, &lt;em&gt;redis-plus-plus&lt;/em&gt; supports Redlock now. @wingunder and I made two different implementation of Redlock: one based on Lua script, and the other based on transaction. The Lua script version should be faster, and also it has many other parameters to control the behavior. However, if you are not allowed to, or don&#39;t want to run Lua scripts inside Redis, you could try using the transaction version.&lt;/p&gt; &#xA;&lt;p&gt;Also there&#39;s a high level API, which works like &lt;code&gt;std::mutex&lt;/code&gt;. With this high level API, you don&#39;t need to manually extend the lock, instead, the lock will be automatically extened by redis-plus-plus.&lt;/p&gt; &#xA;&lt;h4&gt;Redlock 101&lt;/h4&gt; &#xA;&lt;p&gt;The basic idea of acquiring a Redlock is setting a key in Redis if the key does not exist. Since Redis operation is atomic, when mutiple clients acquire the same lock, i.e. setting the same key if it does not exist, only one client wins, and others will find the key has already been set. So only one client can acquire the lock, and others have to wait and try again.&lt;/p&gt; &#xA;&lt;p&gt;When setting the key, we also need to set a TTL/expireation for the key. Otherwise, if the winning client crashes, the lock cannot be acquired by others forever. However, it also brings a new problem. Since the key has a TTL, once you acquire the lock, you must ensure all code in critical section must be finished before the key expires. Otherwise, other clients might acquire the lock successfully when you are still running critical section code (i.e. more than one clients acquire the lock successfully). So when you run critical section code, you have to check if the key is going to be expired and extend the lock (i.e. extending the TTL) before key expires, from time to time.&lt;/p&gt; &#xA;&lt;p&gt;Also, in order to make the algorithm more robust, normally we need to set key on multiple independent stand-alone Redis (not Redis Cluster).&lt;/p&gt; &#xA;&lt;p&gt;There&#39;re still more details on the mechanism of Redlock. Please read &lt;a href=&#34;https://redis.io/topics/distlock&#34;&gt;Redlock&#39;s doc&lt;/a&gt; for more info, before using it.&lt;/p&gt; &#xA;&lt;h4&gt;High Level API&lt;/h4&gt; &#xA;&lt;p&gt;The high level API is quite simple. It works like a &lt;code&gt;std::mutex&lt;/code&gt;, and can be used with &lt;code&gt;std::lock_guard&lt;/code&gt; and &lt;code&gt;std::unique_lock&lt;/code&gt;. Also it can automatically extend the lock before the key expires. So that user code doesn&#39;t need to extend the lock manually. In order to use Redlock, you can create a &lt;code&gt;RedMutex&lt;/code&gt; object with the following parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;One or more &lt;code&gt;Redis&lt;/code&gt; instances: There&#39;re two versions of Redlock, i.e. single instance version and multiple instances version. The multiple instances version is more robust.&lt;/li&gt; &#xA; &lt;li&gt;Resource id: Redlock key in Redis. In order to make it work, two or more &lt;code&gt;RedMutex&lt;/code&gt; should be created with the same resource id.&lt;/li&gt; &#xA; &lt;li&gt;Auto extention error callback (optional): If failing to automatically extend the lock, this error callback will be called. Check below for more detail.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RedMutexOptions&lt;/code&gt; (optional): Some options to control the behavior of &lt;code&gt;RedMutex&lt;/code&gt;. If not specified, default options will be used. Check below for more detail.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;LockWatcher&lt;/code&gt; (optional): A watcher which will automatically extend the lock before it expires. So that you don&#39;t need to manually check if the lock has been expired. If no watcher is specified (the default behavior), &lt;em&gt;redis-plus-plus&lt;/em&gt; will create a one for this Redlock. Check below for more detail.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;class RedMutex {&#xA;public:&#xA;    RedMutex(std::initializer_list&amp;lt;std::shared_ptr&amp;lt;Redis&amp;gt;&amp;gt; masters,&#xA;            const std::string &amp;amp;resource,&#xA;            std::function&amp;lt;void (std::exception_ptr)&amp;gt; auto_extend_err_callback = nullptr,&#xA;            const RedMutexOptions &amp;amp;opts = {},&#xA;            const std::shared_ptr&amp;lt;LockWatcher&amp;gt; &amp;amp;watcher = nullptr);&#xA;&#xA;    void lock();&#xA;&#xA;    bool try_lock();&#xA;&#xA;    void unlock();&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Atuo Extention Error Callback&lt;/h5&gt; &#xA;&lt;p&gt;As we mentioned the high level API can automatically extend the lock. However, we might fail to extend the lock, e.g. connection to Redis is broken. In that case, the &lt;code&gt;auto_extend_err_callback&lt;/code&gt; will be called, so that the application can be notified that the lock might no longer be locked, and stop running code in critical section.&lt;/p&gt; &#xA;&lt;p&gt;The following is the prototype of error callback.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void (std::exception_ptr err);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If error callback is not set (the default behavior), the error will be ignored. And you&#39;re on risk of running critical section code with multiple clients.&lt;/p&gt; &#xA;&lt;h5&gt;RedMutexOptions&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct RedMutexOptions {&#xA;    std::chrono::milliseconds ttl;&#xA;    std::chrono::milliseconds retry_delay;&#xA;    bool scripting = true;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;ttl&lt;/em&gt;: Expiration of the key. 3 seconds by default. If you set this value too large, and the client crashes, other clients need to wait a long time before they can acquire the lock. However, if your network performance is poor, you need a larger &lt;code&gt;ttl&lt;/code&gt;, otherwise, you might fail to lock or fail to extend the lock., otherwise, you might fail to lock or fail to extend the lock., otherwise, you might fail to lock or fail to extend the lock., otherwise, you might fail to lock or fail to extend the lock.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;retry_delay&lt;/em&gt;: &lt;code&gt;RedMutex::lock&lt;/code&gt; repeat trying to lock until it acquires the lock. If it fails, it wait &lt;code&gt;retry_delay&lt;/code&gt; before the next retrying. 100 milliseconds by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;scripting&lt;/em&gt;: True (default behavior), if using Lua scripting to implement Redlock algorithm. otherwise, use Redis transaction to implement it. It&#39;s recommended to use Lua scripting version, which should be much faster than transaction version.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;LockWatcher&lt;/h5&gt; &#xA;&lt;p&gt;&lt;code&gt;LockWatcher&lt;/code&gt; &lt;em&gt;watches&lt;/em&gt; &lt;code&gt;RedMutex&lt;/code&gt;, and try to extend the lock from time to time. You can construct &lt;code&gt;RedMutex&lt;/code&gt; with a &lt;code&gt;std::shared_ptr&amp;lt;LockWatcher&amp;gt;&lt;/code&gt;, so that it will watch the corresponding Redlock. &lt;code&gt;LockWatcher&lt;/code&gt; does the work in a background thread. So creating a &lt;code&gt;LockWatcher&lt;/code&gt; object also creates a &lt;code&gt;std::thread&lt;/code&gt;. If you want to avoid creating multiple threads, you can construct multiple &lt;code&gt;RedMutex&lt;/code&gt; with the same &lt;code&gt;std::shared_ptr&amp;lt;LockWatcher&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you don&#39;t specify &lt;code&gt;LockWatcher&lt;/code&gt;, &lt;code&gt;RedMutex&lt;/code&gt; will create one (the default behavior), and start a thread. Although it&#39;s expensive to create thread, it&#39;s still quite cheap compared to acquiring a distributed lock.&lt;/p&gt; &#xA;&lt;h5&gt;Examples&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;memory&amp;gt;&#xA;#include &amp;lt;sw/redis++/redis++.h&amp;gt;&#xA;#include &amp;lt;sw/redis++/patterns/redlock.h&amp;gt;&#xA;&#xA;auto redis = std::make_shared&amp;lt;Redis&amp;gt;(&#34;tcp://127.0.0.1&#34;);&#xA;&#xA;auto redis1 = std::make_shared&amp;lt;Redis&amp;gt;(&#34;tcp://127.0.0.1:7000&#34;);&#xA;auto redis2 = std::make_shared&amp;lt;Redis&amp;gt;(&#34;tcp://127.0.0.1:7001&#34;);&#xA;auto redis3 = std::make_shared&amp;lt;Redis&amp;gt;(&#34;tcp://127.0.0.1:7002&#34;);&#xA;&#xA;try {&#xA;    {&#xA;        // Create a `RedMutex` with a single stand-alone Redis and default settings.&#xA;        RedMutex mtx(redis, &#34;resource&#34;);&#xA;        std::lock_guard&amp;lt;RedMutex&amp;gt; lock(mtx);&#xA;    }&#xA;&#xA;    {&#xA;        // Create a `RedMutex` with multiple stand-alone Redis and default settings.&#xA;        RedMutex mtx({redis1, redis2, redis3}, &#34;resource&#34;);&#xA;        std::lock_guard&amp;lt;RedMutex&amp;gt; lock(mtx);&#xA;    }&#xA;&#xA;    {&#xA;        RedMutexOptions opts;&#xA;        opts.ttl = std::chrono::seconds(5);&#xA;&#xA;        auto watcher = std::make_shared&amp;lt;LockWatcher&amp;gt;();&#xA;&#xA;        // Create a `RedMutex` with auto_extend_err_callback and other options.&#xA;        RedMutex mtx({redis1, redis2, redis3}, &#34;resource&#34;,&#xA;                [](std::exception_ptr err) {&#xA;                    try {&#xA;                        std::rethrow_exception(err);&#xA;                    } catch (const Error &amp;amp;e) {&#xA;                        // Notify application code that the lock might no longer be locked.&#xA;                    }&#xA;                },&#xA;                opts, watcher);&#xA;&#xA;        std::unique_lock&amp;lt;RedMutex&amp;gt; lock(mtx);&#xA;&#xA;        lock.lock();&#xA;&#xA;        lock.unlock();&#xA;&#xA;        lock.try_lock();&#xA;    }&#xA;} catch (const Error &amp;amp;err) {&#xA;    // handle error.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Low Level API&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Lua script version:&#xA;{&#xA;    RedLockMutex mtx({redis1, redis2, redis3}, &#34;resource&#34;);&#xA;&#xA;    // Not locked.&#xA;    RedLock&amp;lt;RedLockMutex&amp;gt; lock(mtx, std::defer_lock);&#xA;&#xA;    // Try to get the lock, and keep 30 seconds.&#xA;    // It returns the validity time of the lock, i.e. the lock is only&#xA;    // valid in *validity_time*, after that the lock might be acquired by others.&#xA;    // If failed to acquire the lock, throw an exception of Error type.&#xA;    auto validity_time = lock.try_lock(std::chrono::seconds(30));&#xA;&#xA;    // Extend the lock before the lock expired.&#xA;    validity_time = lock.extend_lock(std::chrono::seconds(10));&#xA;&#xA;    // You can unlock explicitly.&#xA;    lock.unlock();&#xA;} // If unlock() is not called, the lock will be unlocked automatically when it&#39;s destroied.&#xA;&#xA;// Transaction version:&#xA;{&#xA;    RedMutex mtx({redis1, redis2, redis3}, &#34;resource&#34;);&#xA;&#xA;    RedLock&amp;lt;RedMutex&amp;gt; lock(mtx, std::defer_lock);&#xA;    auto validity_time = lock.try_lock(std::chrono::seconds(30));&#xA;    validity_time = lock.extend_lock(std::chrono::seconds(30));&#xA;&#xA;    // You can unlock explicitly.&#xA;    lock.unlock();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Author&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;redis-plus-plus&lt;/em&gt; is written by sewenew, who is also active on &lt;a href=&#34;https://stackoverflow.com/users/5384363/for-stack&#34;&gt;StackOverflow&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Many thanks to all contributors of &lt;em&gt;redis-plus-plus&lt;/em&gt;, especially @wingunder.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>embree/embree</title>
    <updated>2023-02-11T01:31:32Z</updated>
    <id>tag:github.com,2023-02-11:/embree/embree</id>
    <link href="https://github.com/embree/embree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Embree ray tracing kernels repository.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;% Embree: High Performance Ray Tracing Kernels 4.0.0 % Intel Corporation&lt;/p&gt; &#xA;&lt;h1&gt;Intel® Embree Overview&lt;/h1&gt; &#xA;&lt;p&gt;Intel® Embree is a high-performance ray tracing library developed at Intel, which is released as open source under the &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache 2.0 license&lt;/a&gt;. Intel® Embree supports x86 CPUs under Linux, macOS, and Windows; ARM CPUs on macOS; as well as Intel® GPUs under Linux and Windows.&lt;/p&gt; &#xA;&lt;p&gt;Intel® Embree targets graphics application developers to improve the performance of photo-realistic rendering applications. Embree is optimized towards production rendering, by putting focus on incoherent ray performance, high quality acceleration structure construction, a rich feature set, accurate primitive intersection, and low memory consumption.&lt;/p&gt; &#xA;&lt;p&gt;Embree&#39;s feature set includes various primitive types such as triangles (as well quad and grids for lower memory consumption); Catmull-Clark subdivision surfaces; various types of curve primitives, such as flat curves (for distant views), round curves (for closeup views), and normal oriented curves, all supported with different basis functions (linear, Bézier, B-spline, Hermite, and Catmull Rom); point-like primitives, such as ray oriented discs, normal oriented discs, and spheres; user defined geometries with a procedural intersection function; multi-level instancing; filter callbacks invoked for any hit encountered; motion blur including multi-segment motion blur, deformation blur, and quaternion motion blur; and ray masking.&lt;/p&gt; &#xA;&lt;p&gt;Intel® Embree contains ray tracing kernels optimized for the latest x86 processors with support for SSE, AVX, AVX2, and AVX-512 instructions, and uses runtime code selection to choose between these kernels. Intel® Embree contains algorithms optimized for incoherent workloads (e.g. Monte Carlo ray tracing algorithms) and coherent workloads (e.g. primary visibility and hard shadow rays) as well as supports for dynamic scenes by implementing high-performance two-level spatial index structure construction algorithms.&lt;/p&gt; &#xA;&lt;p&gt;Intel® Embree supports applications written with the Intel® Implicit SPMD Program Compiler (Intel® ISPC, &lt;a href=&#34;https://ispc.github.io/&#34;&gt;https://ispc.github.io/&lt;/a&gt;) by providing an ISPC interface to the core ray tracing algorithms. This makes it possible to write a renderer that automatically vectorizes and leverages SSE, AVX, AVX2, and AVX-512 instructions.&lt;/p&gt; &#xA;&lt;p&gt;Intel® Embree supports Intel GPUs through the &lt;a href=&#34;https://www.khronos.org/sycl/&#34;&gt;SYCL&lt;/a&gt; open standard programming language. SYCL allows to write C++ code that can be run on various devices, such as CPUs and GPUs. Using Intel® Embree application developers can write a single source renderer that executes efficiently on CPUs and GPUs. Maintaining just one code base this way can significantly improve productivity and eliminate inconsistencies between a CPU and GPU version of the renderer. Embree supports GPUs based on the Xe HPG and Xe HPC microarchitecture, which support hardware accelerated ray tracing do deliver excellent levels of ray tracing performance.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Platforms&lt;/h2&gt; &#xA;&lt;p&gt;Embree supports Windows (32-bit and 64-bit), Linux (64-bit), and macOS (64-bit). Under Windows, Linux and macOS x86 based CPUs are supported, while ARM CPUs are currently only supported under macOS (e.g. Apple M1). ARM support for Windows and Linux is experimental.&lt;/p&gt; &#xA;&lt;p&gt;Embree supports Intel GPUs based on the Xe HPG microarchitecture (Intel® Arc™ GPU) under Linux and Windows and Xe HPC microarchitecture (Intel® Data Center GPU Flex Series and Intel® Data Center GPU Max Series) under Linux.&lt;/p&gt; &#xA;&lt;p&gt;Currently the following products are supported and further products will get enabled soon:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel® Arc™ A770 Graphics&lt;/li&gt; &#xA; &lt;li&gt;Intel® Arc™ A750 Graphics&lt;/li&gt; &#xA; &lt;li&gt;Intel® Arc™ A770M Graphics&lt;/li&gt; &#xA; &lt;li&gt;Intel® Arc™ A730M Graphics&lt;/li&gt; &#xA; &lt;li&gt;Intel® Arc™ A550M Graphics&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The code compiles with the Intel® Compiler, Intel® oneAPI DPC++ Compiler, GCC, Clang, and the Microsoft Compiler. To use Embree on the GPU the Intel® oneAPI DPC++ Compiler must be used. Please see section [Compiling Embree] for details on tested compiler versions.&lt;/p&gt; &#xA;&lt;p&gt;Embree requires at least an x86 CPU with support for SSE2 or an Apple M1 CPU.&lt;/p&gt; &#xA;&lt;h2&gt;Embree Support and Contact&lt;/h2&gt; &#xA;&lt;p&gt;If you encounter bugs please report them via &lt;a href=&#34;https://github.com/embree/embree/issues&#34;&gt;Embree&#39;s GitHub Issue Tracker&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For questions and feature requests please write us at &lt;a href=&#34;mailto:embree_support@intel.com&#34;&gt;embree_support@intel.com&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To receive notifications of updates and new features of Embree please subscribe to the &lt;a href=&#34;https://groups.google.com/d/forum/embree/&#34;&gt;Embree mailing list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Installation of Embree&lt;/h1&gt; &#xA;&lt;h2&gt;Windows Installation&lt;/h2&gt; &#xA;&lt;p&gt;Embree linked against Visual Studio 2015 are provided as a ZIP file &lt;a href=&#34;https://github.com/embree/embree/releases/download/v4.0.0/embree-4.0.0.x64.vc14.windows.zip&#34;&gt;embree-4.0.0.x64.vc14.windows.zip&lt;/a&gt;. After unpacking this ZIP file, you should set the path to the &lt;code&gt;lib&lt;/code&gt; folder manually to your &lt;code&gt;PATH&lt;/code&gt; environment variable for applications to find Embree.&lt;/p&gt; &#xA;&lt;h2&gt;Linux Installation&lt;/h2&gt; &#xA;&lt;p&gt;The Linux version of Embree is also delivered as a &lt;code&gt;tar.gz&lt;/code&gt; file: &lt;a href=&#34;https://github.com/embree/embree/releases/download/v4.0.0/embree-4.0.0.x86_64.linux.tar.gz&#34;&gt;embree-4.0.0.x86_64.linux.tar.gz&lt;/a&gt;. Unpack this file using &lt;code&gt;tar&lt;/code&gt; and source the provided &lt;code&gt;embree-vars.sh&lt;/code&gt; (if you are using the bash shell) or &lt;code&gt;embree-vars.csh&lt;/code&gt; (if you are using the C shell) to set up the environment properly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;tar xzf embree-4.0.0.x86_64.linux.tar.gz&#xA;source embree-4.0.0.x86_64.linux/embree-vars.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We recommend adding a relative &lt;code&gt;RPATH&lt;/code&gt; to your application that points to the location where Embree (and TBB) can be found, e.g. &lt;code&gt;$ORIGIN/../lib&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;macOS Installation&lt;/h2&gt; &#xA;&lt;p&gt;The macOS version of Embree is also delivered as a ZIP file: &lt;a href=&#34;https://github.com/embree/embree/releases/download/v4.0.0/embree-4.0.0.x86_64.macosx.zip&#34;&gt;embree-4.0.0.x86_64.macosx.zip&lt;/a&gt;. Unpack this file using &lt;code&gt;tar&lt;/code&gt; and source the provided &lt;code&gt;embree-vars.sh&lt;/code&gt; (if you are using the bash shell) or &lt;code&gt;embree-vars.csh&lt;/code&gt; (if you are using the C shell) to set up the environment properly:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;unzip embree-4.0.0.x64.macosx.zip    source embree-4.0.0.x64.macosx/embree-vars.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to ship Embree with your application, please use the Embree library of the provided ZIP file. The library name of that Embree library is of the form &lt;code&gt;@rpath/libembree.4.dylib&lt;/code&gt; (and similar also for the included TBB library). This ensures that you can add a relative &lt;code&gt;RPATH&lt;/code&gt; to your application that points to the location where Embree (and TBB) can be found, e.g. &lt;code&gt;@loader_path/../lib&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building Embree Applications&lt;/h2&gt; &#xA;&lt;p&gt;The most convenient way to build an Embree application is through CMake. Just let CMake find your unpacked Embree package using the &lt;code&gt;FIND_PACKAGE&lt;/code&gt; function inside your &lt;code&gt;CMakeLists.txt&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; FIND_PACKAGE(embree 4 REQUIRED)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For CMake to properly find Embree you need to set the &lt;code&gt;embree_DIR&lt;/code&gt; variable to the folder containing the &lt;code&gt;embree_config.cmake&lt;/code&gt; file. You might also have to set the &lt;code&gt;TBB_DIR&lt;/code&gt; variable to the path containing &lt;code&gt;TBB-config.cmake&lt;/code&gt; of a local TBB install, in case you do not have TBB installed globally on your system, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -D embree_DIR=path_to_embree_package/lib/cmake/embree-4.0.0/ \&#xA;      -D TBB_DIR=path_to_tbb_package/lib/cmake/tbb/ \&#xA;      ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;FIND_PACKAGE&lt;/code&gt; function will create an &lt;code&gt;embree&lt;/code&gt; target that you can add to your target link libraries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TARGET_LINK_LIBRARIES(application embree)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a full example on how to build an Embree application please have a look at the &lt;code&gt;minimal&lt;/code&gt; tutorial provided in the &lt;code&gt;src&lt;/code&gt; folder of the Embree package and also the contained &lt;code&gt;README.txt&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Building Embree SYCL Applications&lt;/h2&gt; &#xA;&lt;p&gt;Building Embree SYCL applications is also best done using CMake. Please first get some compatible SYCL compiler and setup the environment as decribed in sections [Linux SYCL Compilation] and [Windows SYCL Compilation].&lt;/p&gt; &#xA;&lt;p&gt;Also perform the setup steps from the previous [Building Embree Applications] section.&lt;/p&gt; &#xA;&lt;p&gt;Please also have a look at the [Minimal] tutorial that is provided with the Embree release, for an example how to build a simple SYCL application using CMake and Embree.&lt;/p&gt; &#xA;&lt;p&gt;To properly compile your SYCL application you have to add additional SYCL compile flags for each C++ file that contains SYCL device side code or kernels as described next.&lt;/p&gt; &#xA;&lt;h3&gt;JIT Compilation&lt;/h3&gt; &#xA;&lt;p&gt;We recommend using just in time compilation (JIT compilation) together with [SYCL JIT caching] to compile Embree SYCL applications. For JIT compilation add these options to the compilation phase of all C++ files that contain SYCL code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-fsycl -Xclang -fsycl-allow-func-ptr -fsycl-targets=spir64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These options enable SYCL two phase compilation (&lt;code&gt;-fsycl&lt;/code&gt; option), enable function pointer support (&lt;code&gt;-Xclang -fsycl-allow-func-ptr&lt;/code&gt; option), and just in time (JIT) compilation only (&lt;code&gt;-fsycl-targets=spir64&lt;/code&gt; option).&lt;/p&gt; &#xA;&lt;p&gt;The following link options have to get added to the linking stage of your application when using just in time compilation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-fsycl -fsycl-targets=spir64&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a full example on how to build an Embree SYCL application please have a look at the SYCL version of the &lt;code&gt;minimal&lt;/code&gt; tutorial provided in the &lt;code&gt;src&lt;/code&gt; folder of the Embree package and also the contained &lt;code&gt;README.txt&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;p&gt;Please have a look at the [Compiling Embree] section on how to create an Embree package from sources if required.&lt;/p&gt; &#xA;&lt;h3&gt;AOT Compilation&lt;/h3&gt; &#xA;&lt;p&gt;Ahead of time compilation (AOT compilation) allows to speed up first application start up time as device binaries are precompiled. We do not recommend using AOT compilation as it does not allow the usage of specialization constants to reduce code complexity.&lt;/p&gt; &#xA;&lt;p&gt;For ahead of time compilation add these compile options to the compilation phase of all C++ files that contain SYCL code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-fsycl -Xclang -fsycl-allow-func-ptr -fsycl-targets=spir64_gen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These options enable SYCL two phase compilation (&lt;code&gt;-fsycl&lt;/code&gt; option), enable function pointer support (&lt;code&gt;-Xclang -fsycl-allow-func-ptr&lt;/code&gt; option), and ahead of time (AOT) compilation (&lt;code&gt;-fsycl-targets=spir64_gen&lt;/code&gt; option).&lt;/p&gt; &#xA;&lt;p&gt;The following link options have to get added to the linking stage of your application when compiling ahead of time for Xe HPG devices:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;-fsycl -fsycl-targets=spir64_gen&#xA;-Xsycl-target-backend=spir64_gen &#34;-device XE_HPG_CORE&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This in particular configures the devices for AOT compilation to &lt;code&gt;XE_HPG_CORE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To get a list of all device supported by AOT compilation look at the help of the device option in ocloc tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ocloc compile --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Compiling Embree&lt;/h1&gt; &#xA;&lt;p&gt;We recommend using the prebuild Embree packages from &lt;a href=&#34;https://github.com/embree/embree/releases&#34;&gt;https://github.com/embree/embree/releases&lt;/a&gt;. If you need to compile Embree yourself you need to use CMake as described in the following.&lt;/p&gt; &#xA;&lt;p&gt;Do not enable fast-math optimizations in your compiler as this mode is not supported by Embree.&lt;/p&gt; &#xA;&lt;h2&gt;Linux and macOS&lt;/h2&gt; &#xA;&lt;p&gt;To compile Embree you need a modern C++ compiler that supports C++11. Embree is tested with the following compilers:&lt;/p&gt; &#xA;&lt;p&gt;Linux&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel® oneAPI DPC++/C++ Compiler 2023.0.0&lt;/li&gt; &#xA; &lt;li&gt;oneAPI DPC++/C++ Compiler 2022-12-14&lt;/li&gt; &#xA; &lt;li&gt;Clang 5.0.0&lt;/li&gt; &#xA; &lt;li&gt;Clang 4.0.0&lt;/li&gt; &#xA; &lt;li&gt;GCC 10.0.1 (Fedora 32) AVX512 support&lt;/li&gt; &#xA; &lt;li&gt;GCC 8.3.1 (Fedora 28) AVX512 support&lt;/li&gt; &#xA; &lt;li&gt;GCC 7.3.1 (Fedora 27) AVX2 support&lt;/li&gt; &#xA; &lt;li&gt;GCC 7.3.1 (Fedora 26) AVX2 support&lt;/li&gt; &#xA; &lt;li&gt;GCC 6.4.1 (Fedora 25) AVX2 support&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.18.1&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.17.0&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.16.1&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.15.0&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.14.1&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.13.0&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.12.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;macOS x86&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel® C++ Classic Compiler 2023.0.0&lt;/li&gt; &#xA; &lt;li&gt;Apple Clang 12.0.5 (macOS 11.7.1)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;macOS M1&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apple Clang 12.0.5 (macOS 11.7.1)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Embree supports using the Intel® Threading Building Blocks (TBB) as the tasking system. For performance and flexibility reasons we recommend using Embree with the Intel® Threading Building Blocks (TBB) and best also use TBB inside your application. Optionally you can disable TBB in Embree through the &lt;code&gt;EMBREE_TASKING_SYSTEM&lt;/code&gt; CMake variable.&lt;/p&gt; &#xA;&lt;p&gt;Embree supports the Intel® Implicit SPMD Program Compiler (Intel® ISPC), which allows straightforward parallelization of an entire renderer. If you want to use Intel® ISPC then you can enable &lt;code&gt;EMBREE_ISPC_SUPPORT&lt;/code&gt; in CMake. Download and install the Intel® ISPC binaries from &lt;a href=&#34;https://ispc.github.io/downloads.html&#34;&gt;ispc.github.io&lt;/a&gt;. After installation, put the path to &lt;code&gt;ispc&lt;/code&gt; permanently into your &lt;code&gt;PATH&lt;/code&gt; environment variable or you set the &lt;code&gt;EMBREE_ISPC_EXECUTABLE&lt;/code&gt; variable to point at the ISPC executable during CMake configuration.&lt;/p&gt; &#xA;&lt;p&gt;You additionally have to install CMake 3.1.0 or higher and the developer version of &lt;a href=&#34;https://www.glfw.org/&#34;&gt;GLFW&lt;/a&gt; version 3.&lt;/p&gt; &#xA;&lt;p&gt;Under macOS, all these dependencies can be installed using &lt;a href=&#34;http://www.macports.org/&#34;&gt;MacPorts&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo port install cmake tbb-devel glfw-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Depending on your Linux distribution you can install these dependencies using &lt;code&gt;yum&lt;/code&gt; or &lt;code&gt;apt-get&lt;/code&gt;. Some of these packages might already be installed or might have slightly different names.&lt;/p&gt; &#xA;&lt;p&gt;Type the following to install the dependencies using &lt;code&gt;yum&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo yum install cmake&#xA;sudo yum install tbb-devel&#xA;sudo yum install glfw-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Type the following to install the dependencies using &lt;code&gt;apt-get&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install cmake-curses-gui&#xA;sudo apt-get install libtbb-dev&#xA;sudo apt-get install libglfw3-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you can compile Embree using CMake. Create a build directory inside the Embree root directory and execute &lt;code&gt;ccmake ..&lt;/code&gt; inside this build directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir build&#xA;cd build&#xA;ccmake ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Per default, CMake will use the compilers specified with the &lt;code&gt;CC&lt;/code&gt; and &lt;code&gt;CXX&lt;/code&gt; environment variables. Should you want to use a different compiler, run &lt;code&gt;cmake&lt;/code&gt; first and set the &lt;code&gt;CMAKE_CXX_COMPILER&lt;/code&gt; and &lt;code&gt;CMAKE_C_COMPILER&lt;/code&gt; variables to the desired compiler. For example, to use the Clang compiler instead of the default GCC on most Linux machines (&lt;code&gt;g++&lt;/code&gt; and &lt;code&gt;gcc&lt;/code&gt;), execute&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running &lt;code&gt;ccmake&lt;/code&gt; will open a dialog where you can perform various configurations as described below in [CMake Configuration]. After having configured Embree, press &lt;code&gt;c&lt;/code&gt; (for configure) and &lt;code&gt;g&lt;/code&gt; (for generate) to generate a Makefile and leave the configuration. The code can be compiled by executing make.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make -j 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The executables will be generated inside the build folder. We recommend installing the Embree library and header files on your system. Therefore set the &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; to &lt;code&gt;/usr&lt;/code&gt; in cmake and type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you keep the default &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; of &lt;code&gt;/usr/local&lt;/code&gt; then you have to make sure the path &lt;code&gt;/usr/local/lib&lt;/code&gt; is in your &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also uninstall Embree again by executing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo make uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also create an Embree package using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;make package&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see the [Building Embree Applications] section on how to build your application with such an Embree package.&lt;/p&gt; &#xA;&lt;h2&gt;Linux SYCL Compilation&lt;/h2&gt; &#xA;&lt;p&gt;There are two options to compile Embree with SYCL support: The open source &lt;a href=&#34;https://github.com/intel/llvm/&#34;&gt;&#34;oneAPI DPC++ Compiler&#34;&lt;/a&gt; or the &lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp&#34;&gt;&#34;Intel(R) oneAPI DPC++/C++ Compiler&#34;&lt;/a&gt;. Other SYCL compilers are not supported.&lt;/p&gt; &#xA;&lt;p&gt;The &#34;oneAPI DPC++ Compiler&#34; is more up-to-date than the &#34;Intel(R) oneAPI DPC++/C++ Compiler&#34; but less stable. The current tested version of the &#34;oneAPI DPC++ compiler is&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/intel/llvm/releases/download/sycl-nightly%2F20221214/dpcpp-compiler.tar.gz&#34;&gt;oneAPI DPC++ Compiler 2022-12-14&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The compiler can be downloaded and simply extracted. The oneAPI DPC++ compiler 2022-12-14 can be set up executing the following command in a Linux (bash) shell:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wget https://github.com/intel/llvm/releases/download/sycl-nightly%2F20221214/dpcpp-compiler.tar.gz&#xA;tar xzf dpcpp-compiler.tar.gz&#xA;source ./dpcpp_compiler/startup.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;startup.sh&lt;/code&gt; script will put &lt;code&gt;clang++&lt;/code&gt; and &lt;code&gt;clang&lt;/code&gt; from the oneAPI DPC++ Compiler into your path.&lt;/p&gt; &#xA;&lt;p&gt;Please also install all Linux packages described in the previous section.&lt;/p&gt; &#xA;&lt;p&gt;Now, you can configure Embree using CMake by executing the following command in the Embree root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -B build \&#xA;      -DCMAKE_CXX_COMPILER=clang++ \&#xA;      -DCMAKE_C_COMPILER=clang \&#xA;      -DEMBREE_SYCL_SUPPORT=ON&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a directory &lt;code&gt;build&lt;/code&gt; to use as the CMake build directory, configure the usage of the oneAPI DPC++ Compiler, and turn on SYCL support through &lt;code&gt;EMBREE_SYCL_SUPPORT=ON&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can download and run the installer of the&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp&#34;&gt;Intel(R) oneAPI DPC++/C++ Compiler 2023.0.0&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After installation, you can set up the compiler by sourcing the &lt;code&gt;vars.sh&lt;/code&gt; script in the &lt;code&gt;env&lt;/code&gt; directory of the compiler install directory, for example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;source /opt/intel/oneAPI/compiler/2023.0.0/env/vars.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This script will put the &lt;code&gt;icpx&lt;/code&gt; and &lt;code&gt;icx&lt;/code&gt; compiler executables from the Intel(R) oneAPI DPC++/C++ Compiler in your path.&lt;/p&gt; &#xA;&lt;p&gt;Now, you can configure Embree using CMake by executing the following command in the Embree root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -B build \&#xA;      -DCMAKE_CXX_COMPILER=icpx \&#xA;      -DCMAKE_C_COMPILER=icx \&#xA;      -DEMBREE_SYCL_SUPPORT=ON&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More information about setting up the Intel(R) oneAPI DPC++/C++ compiler can be found in the &lt;a href=&#34;https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup.html&#34;&gt;Development Reference Guide&lt;/a&gt;. Please note, that the Intel(R) oneAPI DPC++/C++ compiler requires &lt;a href=&#34;https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup/use-the-command-line/use-cmake-with-the-compiler.html&#34;&gt;at least CMake version 3.20.5 on Linux&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Independent of the DPC++ compiler choice, you can now build Embree using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build build -j 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The executables will be generated inside the build folder. The executable names of the SYCL versions of the tutorials end with &lt;code&gt;_sycl&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Linux Graphics Driver Installation&lt;/h3&gt; &#xA;&lt;p&gt;To run the SYCL code you need to install the latest GPGPU drivers for your Intel Xe HPG/HPC GPUs from here &lt;a href=&#34;https://dgpu-docs.intel.com/&#34;&gt;https://dgpu-docs.intel.com/&lt;/a&gt;. Follow the driver installation instructions for your graphics card and operating system.&lt;/p&gt; &#xA;&lt;p&gt;We tested Embree with the latest GPGPU driver Devel Release from 20220809. The Intel(R) Graphics Compute Runtime for oneAPI Level Zero and OpenCL(TM) Driver from that release is too old for Embree to work properly. Thus if no newer version of the GPGPU driver is available, you need to additionally install the latest compute runtime from here &lt;a href=&#34;https://github.com/intel/compute-runtime/releases/tag/22.43.24595.30&#34;&gt;22.43.24595&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Unfortunately, these compute runtime packages are only available for Ubuntu 22.04. You can also install a newer version of the compute runtime if available.&lt;/p&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;Embree is tested using the following compilers under Windows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel® oneAPI DPC++/C++ Compiler 2023.0.0&lt;/li&gt; &#xA; &lt;li&gt;oneAPI DPC++/C++ Compiler 2022-12-14&lt;/li&gt; &#xA; &lt;li&gt;Visual Studio 2019&lt;/li&gt; &#xA; &lt;li&gt;Visual Studio 2017&lt;/li&gt; &#xA; &lt;li&gt;Visual Studio 2015 (Update&amp;nbsp;1)&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.18.1&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.17.0&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.16.1&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.15.0&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.14.1&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.13.0&lt;/li&gt; &#xA; &lt;li&gt;Intel® Implicit SPMD Program Compiler 1.12.0&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To compile Embree for AVX-512 you have to use the Intel® Compiler.&lt;/p&gt; &#xA;&lt;p&gt;Embree supports using the Intel® Threading Building Blocks (TBB) as the tasking system. For performance and flexibility reasons we recommend using use Embree with the Intel® Threading Building Blocks (TBB) and best also use TBB inside your application. Optionally you can disable TBB in Embree through the &lt;code&gt;EMBREE_TASKING_SYSTEM&lt;/code&gt; CMake variable.&lt;/p&gt; &#xA;&lt;p&gt;Embree will either find the Intel® Threading Building Blocks (TBB) installation that comes with the Intel® Compiler, or you can install the binary distribution of TBB directly from &lt;a href=&#34;https://github.com/oneapi-src/oneTBB/releases&#34;&gt;https://github.com/oneapi-src/oneTBB/releases&lt;/a&gt; into a folder named &lt;code&gt;tbb&lt;/code&gt; into your Embree root directory. You also have to make sure that the libraries &lt;code&gt;tbb.dll&lt;/code&gt; and &lt;code&gt;tbb_malloc.dll&lt;/code&gt; can be found when executing your Embree applications, e.g. by putting the path to these libraries into your &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;p&gt;Embree supports the Intel® Implicit SPMD Program Compiler (Intel® ISPC), which allows straightforward parallelization of an entire renderer. When installing Intel® ISPC, make sure to download an Intel® ISPC version from &lt;a href=&#34;https://ispc.github.io/downloads.html&#34;&gt;ispc.github.io&lt;/a&gt; that is compatible with your Visual Studio version. After installation, put the path to &lt;code&gt;ispc.exe&lt;/code&gt; permanently into your &lt;code&gt;PATH&lt;/code&gt; environment variable or you need to correctly set the &lt;code&gt;EMBREE_ISPC_EXECUTABLE&lt;/code&gt; variable during CMake configuration to point to the ISPC executable. If you want to use Intel® ISPC, you have to enable &lt;code&gt;EMBREE_ISPC_SUPPORT&lt;/code&gt; in CMake.&lt;/p&gt; &#xA;&lt;p&gt;You additionally have to install &lt;a href=&#34;http://www.cmake.org/download/&#34;&gt;CMake&lt;/a&gt; (version 3.1 or higher). Note that you need a native Windows CMake installation because CMake under Cygwin cannot generate solution files for Visual Studio.&lt;/p&gt; &#xA;&lt;h3&gt;Using the IDE&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;cmake-gui&lt;/code&gt;, browse to the Embree sources, set the build directory and click Configure. Now you can select the Generator, e.g. &#34;Visual Studio 12 2013&#34; for a 32-bit build or &#34;Visual Studio 12 2013 Win64&#34; for a 64-bit build.&lt;/p&gt; &#xA;&lt;p&gt;To use a different compiler than the Microsoft Visual C++ compiler, you additionally need to specify the proper compiler toolset through the option &#34;Optional toolset to use (-T parameter)&#34;. E.g. to use Clang for compilation set the toolset to &#34;LLVM_v142&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Do not change the toolset manually in a solution file (neither through the project properties dialog nor through the &#34;Use Intel Compiler&#34; project context menu), because then some compiler-specific command line options cannot be set by CMake.&lt;/p&gt; &#xA;&lt;p&gt;Most configuration parameters described in the [CMake Configuration] can be set under Windows as well. Finally, click &#34;Generate&#34; to create the Visual Studio solution files.&lt;/p&gt; &#xA;&lt;p&gt;The following CMake options are only available under Windows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CMAKE_CONFIGURATION_TYPE&lt;/code&gt;: List of generated configurations. The default value is Debug;Release;RelWithDebInfo.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;USE_STATIC_RUNTIME&lt;/code&gt;: Use the static version of the C/C++ runtime library. This option is turned OFF by default.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Use the generated Visual Studio solution file &lt;code&gt;embree4.sln&lt;/code&gt; to compile the project.&lt;/p&gt; &#xA;&lt;p&gt;We recommend enabling syntax highlighting for the &lt;code&gt;.ispc&lt;/code&gt; source and &lt;code&gt;.isph&lt;/code&gt; header files. To do so open Visual Studio, go to Tools ⇒ Options ⇒ Text Editor ⇒ File Extension and add the &lt;code&gt;isph&lt;/code&gt; and &lt;code&gt;ispc&lt;/code&gt; extensions for the &#34;Microsoft Visual C++&#34; editor.&lt;/p&gt; &#xA;&lt;h3&gt;Using the Command Line&lt;/h3&gt; &#xA;&lt;p&gt;Embree can also be configured and built without the IDE using the Visual Studio command prompt:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd path\to\embree&#xA;mkdir build&#xA;cd build&#xA;cmake -G &#34;Visual Studio 16 2019&#34; ..&#xA;cmake --build . --config Release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also build only some projects with the &lt;code&gt;--target&lt;/code&gt; switch. Additional parameters after &#34;&lt;code&gt;--&lt;/code&gt;&#34; will be passed to &lt;code&gt;msbuild&lt;/code&gt;. For example, to build the Embree library in parallel use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build . --config Release --target embree -- /m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building Embree - Using vcpkg&lt;/h3&gt; &#xA;&lt;p&gt;You can download and install Embree using the &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt; dependency manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;./vcpkg install embree3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The Embree port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;create an issue or pull request&lt;/a&gt; on the vcpkg repository.&lt;/p&gt; &#xA;&lt;h2&gt;Windows SYCL Compilation&lt;/h2&gt; &#xA;&lt;p&gt;There are two options to compile Embree with SYCL support: The open source &lt;a href=&#34;https://github.com/intel/llvm/&#34;&gt;&#34;oneAPI DPC++ Compiler&#34;&lt;/a&gt; or the &lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp&#34;&gt;&#34;Intel(R) oneAPI DPC++/C++ Compiler&#34;&lt;/a&gt;. Other SYCL compilers are not supported. You will also need an installed version of Visual Studio that supports the C++17 standard, e.g. Visual Studio 2019.&lt;/p&gt; &#xA;&lt;p&gt;The &#34;oneAPI DPC++ Compiler&#34; is more up-to-date than the &#34;Intel(R) oneAPI DPC++/C++ Compiler&#34; but less stable. The current tested version of the oneAPI DPC++ compiler is&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/intel/llvm/releases/download/sycl-nightly%2F20221214/dpcpp-compiler-win.tar.gz&#34;&gt;oneAPI DPC++ Compiler 2022-12-14&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Download and unpack the archive and open the &#34;x64 Native Tools Command Prompt&#34; of Visual Studio and execute the following lines to properly configure the environment to use the oneAPI DPC++ compiler:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;set &#34;DPCPP_DIR=path_to_dpcpp_compiler&#34;&#xA;set &#34;PATH=%DPCPP_DIR%\bin;%PATH%&#34;&#xA;set &#34;PATH=%DPCPP_DIR%\lib;%PATH%&#34;&#xA;set &#34;CPATH=%DPCPP_DIR%\include;%CPATH%&#34;&#xA;set &#34;INCLUDE=%DPCPP_DIR%\include;%INCLUDE%&#34;&#xA;set &#34;LIB=%DPCPP_DIR%\lib;%LIB%&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;path_to_dpcpp_compiler&lt;/code&gt; should point to the unpacked oneAPI DPC++ compiler.&lt;/p&gt; &#xA;&lt;p&gt;Now, you can configure Embree using CMake by executing the following command in the Embree root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -B build&#xA;      -G Ninja&#xA;      -D CMAKE_BUILD_TYPE=Release&#xA;      -D CMAKE_CXX_COMPILER=clang++&#xA;      -D CMAKE_C_COMPILER=clang&#xA;      -D EMBREE_SYCL_SUPPORT=ON&#xA;      -D TBB_ROOT=path_to_tbb\lib\cmake\tbb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a directory &lt;code&gt;build&lt;/code&gt; to use as the CMake build directory, and configure a release build that uses &lt;code&gt;clang++&lt;/code&gt; and &lt;code&gt;clang&lt;/code&gt; from the oneAPI DPC++ compiler.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://ninja-build.org/&#34;&gt;Ninja&lt;/a&gt; generator is currently the easiest way to use the oneAPI DPC++ compiler.&lt;/p&gt; &#xA;&lt;p&gt;We also enable SYCL support in Embree using the &lt;code&gt;EMBREE_SYCL_SUPPORT&lt;/code&gt; CMake option.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can download and run the installer of the&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp&#34;&gt;Intel(R) oneAPI DPC++/C++ Compiler 2023.0.0&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After installation, you can either open a regular &lt;code&gt;Command Prompt&lt;/code&gt; and execute the &lt;code&gt;vars.bat&lt;/code&gt; script in the &lt;code&gt;env&lt;/code&gt; directory of the compiler install directory, for example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\Program Files (x86)\Intel\oneAPI\compiler\2023.0.0\env\vars.bat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or simply open the installed &#34;Intel oneAPI command prompt for Intel 64 for Visual Studio&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Both ways will put the &lt;code&gt;icx&lt;/code&gt; compiler executable from the Intel(R) oneAPI DPC++/C++ compiler in your path.&lt;/p&gt; &#xA;&lt;p&gt;Now, you can configure Embree using CMake by executing the following command in the Embree root directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -B build&#xA;      -G Ninja&#xA;      -D CMAKE_BUILD_TYPE=Release&#xA;      -D CMAKE_CXX_COMPILER=icx&#xA;      -D CMAKE_C_COMPILER=icx&#xA;      -D EMBREE_SYCL_SUPPORT=ON&#xA;      -D TBB_ROOT=path_to_tbb\lib\cmake\tbb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;More information about setting up the Intel(R) oneAPI DPC++/C++ compiler can be found in the &lt;a href=&#34;https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup.html&#34;&gt;Development Reference Guide&lt;/a&gt;. Please note, that the Intel(R) oneAPI DPC++/C++ compiler requires &lt;a href=&#34;https://www.intel.com/content/www/us/en/develop/documentation/oneapi-dpcpp-cpp-compiler-dev-guide-and-reference/top/compiler-setup/use-the-command-line/use-cmake-with-the-compiler.html&#34;&gt;at least CMake version 3.23 on Windows&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Independent of the DPC++ compiler choice, you can now build Embree using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have problems with Ninja re-running CMake in an infinite loop, then first remove the &#34;Re-run CMake if any of its inputs changed.&#34; section from the &lt;code&gt;build.ninja&lt;/code&gt; file and run the above command again.&lt;/p&gt; &#xA;&lt;p&gt;You can also create an Embree package using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake --build build --target package&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please see the [Building Embree SYCL Applications] section on how to build your application with such an Embree package.&lt;/p&gt; &#xA;&lt;h3&gt;Windows Graphics Driver Installation&lt;/h3&gt; &#xA;&lt;p&gt;In order to run the SYCL tutorials on HPG hardware, you first need to install the proper graphics drivers for your graphics card from &lt;a href=&#34;https://www.intel.com&#34;&gt;https://www.intel.com&lt;/a&gt;. Embree will work with graphics driver version 101.4027 or later.&lt;/p&gt; &#xA;&lt;h2&gt;CMake Configuration&lt;/h2&gt; &#xA;&lt;p&gt;The default CMake configuration in the configuration dialog should be appropriate for most usages. The following list describes all parameters that can be configured in CMake:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;CMAKE_BUILD_TYPE&lt;/code&gt;: Can be used to switch between Debug mode (Debug), Release mode (Release) (default), and Release mode with enabled assertions and debug symbols (RelWithDebInfo).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_STACK_PROTECTOR&lt;/code&gt;: Enables protection of return address from buffer overwrites. This option is OFF by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_ISPC_SUPPORT&lt;/code&gt;: Enables Intel® ISPC support of Embree. This option is OFF by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_SYCL_SUPPORT&lt;/code&gt;: Enables GPU support using SYCL. When this option is enabled you have to use some DPC++ compiler. Please see the sections [Linux SYCL Compilation] and [Windows SYCL Compilation] on supported DPC++ compilers. This option is OFF by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_SYCL_AOT_DEVICES&lt;/code&gt;: Selects a list of GPU devices for ahead-of-time (AOT) compilation of device code. Possible values are either, &#34;none&#34; which enables only just in time (JIT) compilation, or a list of the Embree-supported Xe GPUs for AOT compilation:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;XE_HPG_CORE : Xe HPG devices&lt;/li&gt; &#xA;   &lt;li&gt;XE_HPC_CORE : Xe HPC devices&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;One can also specify multiple devices separated by comma to compile ahead of time for multiple devices, e.g. &#34;XE_HPG_CORE,XE_HP_CORE&#34;. When enabling AOT compilation for one or multiple devices, JIT compilation will always additionally be enabled in case the code is executed on a device no code is precompiled for.&lt;/p&gt; &lt;p&gt;Execute &#34;ocloc compile --help&#34; for more details of possible devices to pass. Embree is only supported on Xe HPG/HPC and newer devices.&lt;/p&gt; &lt;p&gt;Per default, this option is set to &#34;none&#34; to enable JIT compilation. We recommend using JIT compilation as this enables the use of specialization constants to reduce code complexity.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_STATIC_LIB&lt;/code&gt;: Builds Embree as a static library (OFF by default). Further multiple static libraries are generated for the different ISAs selected (e.g. &lt;code&gt;embree4.a&lt;/code&gt;, &lt;code&gt;embree4_sse42.a&lt;/code&gt;, &lt;code&gt;embree4_avx.a&lt;/code&gt;, &lt;code&gt;embree4_avx2.a&lt;/code&gt;, &lt;code&gt;embree4_avx512.a&lt;/code&gt;). You have to link these libraries in exactly this order of increasing ISA.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_API_NAMESPACE&lt;/code&gt;: Specifies a namespace name to put all Embree API symbols inside. By default, no namespace is used and plain C symbols are exported.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_LIBRARY_NAME&lt;/code&gt;: Specifies the name of the Embree library file created. By default, the name embree4 is used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_IGNORE_CMAKE_CXX_FLAGS&lt;/code&gt;: When enabled, Embree ignores default CMAKE_CXX_FLAGS. This option is turned ON by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TUTORIALS&lt;/code&gt;: Enables build of Embree tutorials (default ON).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_BACKFACE_CULLING&lt;/code&gt;: Enables backface culling, i.e. only surfaces facing a ray can be hit. This option is turned OFF by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_COMPACT_POLYS&lt;/code&gt;: Enables compact tris/quads, i.e. only geomIDs and primIDs are stored inside the leaf nodes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_FILTER_FUNCTION&lt;/code&gt;: Enables the intersection filter function feature (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_RAY_MASK&lt;/code&gt;: Enables the ray masking feature (OFF by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_RAY_PACKETS&lt;/code&gt;: Enables ray packet traversal kernels. This feature is turned ON by default. When turned on packet traversal is used internally and packets passed to rtcIntersect4/8/16 are kept intact in callbacks (when the ISA of appropriate width is enabled).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_IGNORE_INVALID_RAYS&lt;/code&gt;: Makes code robust against the risk of full-tree traversals caused by invalid rays (e.g. rays containing INF/NaN as origins). This option is turned OFF by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TASKING_SYSTEM&lt;/code&gt;: Chooses between Intel® Threading TBB Building Blocks (TBB), Parallel Patterns Library (PPL) (Windows only), or an internal tasking system (INTERNAL). By default, TBB is used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TBB_ROOT&lt;/code&gt;: If Intel® Threading Building Blocks (TBB) is used as a tasking system, search the library in this directory tree.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TBB_COMPONENT&lt;/code&gt;: The component/library name of Intel® Threading Building Blocks (TBB). Embree searches for this library name (default: tbb) when TBB is used as the tasking system.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TBB_POSTFIX&lt;/code&gt;: If Intel® Threading Building Blocks (TBB) is used as a tasking system, link to tbb&amp;lt;EMBREE_TBB_POSTFIX&amp;gt;.(so,dll,lib). Defaults to the empty string.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TBB_DEBUG_ROOT&lt;/code&gt;: If Intel® Threading Building Blocks (TBB) is used as a tasking system, search the library in this directory tree in Debug mode. Defaults to &lt;code&gt;EMBREE_TBB_ROOT&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_TBB_DEBUG_POSTFIX&lt;/code&gt;: If Intel® Threading Building Blocks (TBB) is used as a tasking system, link to tbb&amp;lt;EMBREE_TBB_DEBUG_POSTFIX&amp;gt;.(so,dll,lib) in Debug mode. Defaults to &#34;_debug&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_MAX_ISA&lt;/code&gt;: Select highest supported ISA (SSE2, SSE4.2, AVX, AVX2, AVX512, or NONE). When set to NONE the EMBREE_ISA_* variables can be used to enable ISAs individually. By default, the option is set to AVX2.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_ISA_SSE2&lt;/code&gt;: Enables SSE2 when EMBREE_MAX_ISA is set to NONE. By default, this option is turned OFF.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_ISA_SSE42&lt;/code&gt;: Enables SSE4.2 when EMBREE_MAX_ISA is set to NONE. By default, this option is turned OFF.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_ISA_AVX&lt;/code&gt;: Enables AVX when EMBREE_MAX_ISA is set to NONE. By default, this option is turned OFF.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_ISA_AVX2&lt;/code&gt;: Enables AVX2 when EMBREE_MAX_ISA is set to NONE. By default, this option is turned OFF.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_ISA_AVX512&lt;/code&gt;: Enables AVX-512 for Skylake when EMBREE_MAX_ISA is set to NONE. By default, this option is turned OFF.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_TRIANGLE&lt;/code&gt;: Enables support for triangle geometries (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_QUAD&lt;/code&gt;: Enables support for quad geometries (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_CURVE&lt;/code&gt;: Enables support for curve geometries (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_SUBDIVISION&lt;/code&gt;: Enables support for subdivision geometries (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_INSTANCE&lt;/code&gt;: Enables support for instances (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_USER&lt;/code&gt;: Enables support for user-defined geometries (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_GEOMETRY_POINT&lt;/code&gt;: Enables support for point geometries (ON by default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_CURVE_SELF_INTERSECTION_AVOIDANCE_FACTOR&lt;/code&gt;: Specifies a factor that controls the self-intersection avoidance feature for flat curves. Flat curve intersections which are closer than curve_radius*&lt;code&gt;EMBREE_CURVE_SELF_INTERSECTION_AVOIDANCE_FACTOR&lt;/code&gt; to the ray origin are ignored. A value of 0.0f disables self-intersection avoidance while 2.0f is the default value.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_DISC_POINT_SELF_INTERSECTION_AVOIDANCE&lt;/code&gt;: Enables self-intersection avoidance for RTC_GEOMETRY_TYPE_DISC_POINT geometry type (ON by default). When enabled intersections are skipped if the ray origin lies inside the sphere defined by the point primitive.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_MIN_WIDTH&lt;/code&gt;: Enabled the min-width feature, which allows increasing the radius of curves and points to match some amount of pixels. See [rtcSetGeometryMaxRadiusScale] for more details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;EMBREE_MAX_INSTANCE_LEVEL_COUNT&lt;/code&gt;: Specifies the maximum number of nested instance levels. Should be greater than 0; the default value is 1. Instances nested any deeper than this value will silently disappear in release mode, and cause assertions in debug mode.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Embree API&lt;/h1&gt; &#xA;&lt;p&gt;The Embree API is a low-level C99 ray tracing API which can be used to build spatial index structures for 3D scenes and perform ray queries of different types.&lt;/p&gt; &#xA;&lt;p&gt;The API can get used on the CPU using standard C, C++, and ISPC code and Intel GPUs by using SYCL code.&lt;/p&gt; &#xA;&lt;p&gt;The Intel® Implicit SPMD Program Compiler (Intel® ISPC) version of the API, is almost identical to the standard C99 version, but contains additional functions that operate on ray packets with a size of the native SIMD width used by Intel® ISPC.&lt;/p&gt; &#xA;&lt;p&gt;The SYCL version of the API is also mostly identical to the C99 version of the API, with some exceptions listed in section [Embree SYCL API].&lt;/p&gt; &#xA;&lt;p&gt;For simplicity this document refers to the C99 version of the API functions. For changes when upgrading from the Embree 3 to the current Embree 4 API see Section [Upgrading from Embree 3 to Embree 4].&lt;/p&gt; &#xA;&lt;p&gt;All API calls carry the prefix &lt;code&gt;rtc&lt;/code&gt; (or &lt;code&gt;RTC&lt;/code&gt; for types) which stands for &lt;strong&gt;r&lt;/strong&gt;ay &lt;strong&gt;t&lt;/strong&gt;racing &lt;strong&gt;c&lt;/strong&gt;ore. The API supports scenes consisting of different geometry types such as triangle meshes, quad meshes (triangle pairs), grid meshes, flat curves, round curves, oriented curves, subdivision meshes, instances, and user-defined geometries. See Section &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#scene-object&#34;&gt;Scene Object&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;Finding the closest hit of a ray segment with the scene (&lt;code&gt;rtcIntersect&lt;/code&gt;-type functions), and determining whether any hit between a ray segment and the scene exists (&lt;code&gt;rtcOccluded&lt;/code&gt;-type functions) are both supported. The API supports queries for single rays and ray packets. See Section &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#ray-queries&#34;&gt;Ray Queries&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;The API is designed in an object-oriented manner, e.g.&amp;nbsp;it contains device objects (&lt;code&gt;RTCDevice&lt;/code&gt; type), scene objects (&lt;code&gt;RTCScene&lt;/code&gt; type), geometry objects (&lt;code&gt;RTCGeometry&lt;/code&gt; type), buffer objects (&lt;code&gt;RTCBuffer&lt;/code&gt; type), and BVH objects (&lt;code&gt;RTCBVH&lt;/code&gt; type). All objects are reference counted, and handles can be released by calling the appropriate release function (e.g.&amp;nbsp;&lt;code&gt;rtcReleaseDevice&lt;/code&gt;) or retained by incrementing the reference count (e.g.&amp;nbsp;&lt;code&gt;rtcRetainDevice&lt;/code&gt;). In general, API calls that access the same object are not thread-safe, unless specified otherwise. However, attaching geometries to the same scene and performing ray queries in a scene is thread-safe.&lt;/p&gt; &#xA;&lt;h2&gt;Device Object&lt;/h2&gt; &#xA;&lt;p&gt;Embree supports a device concept, which allows different components of the application to use the Embree API without interfering with each other. An application typically first creates a device using the [rtcNewDevice] function (or [rtcNewSYCLDevice] when using SYCL for the GPU). This device can then be used to construct further objects, such as scenes and geometries. Before the application exits, it should release all devices by invoking [rtcReleaseDevice]. An application typically creates only a single device. If required differently, it should only use a small number of devices at any given time.&lt;/p&gt; &#xA;&lt;p&gt;Each user thread has its own error flag per device. If an error occurs when invoking an API function, this flag is set to an error code (if it isn&#39;t already set by a previous error). See Section [rtcGetDeviceError] for information on how to read the error code and Section [rtcSetDeviceErrorFunction] on how to register a callback that is invoked for each error encountered. It is recommended to always set a error callback function, to detect all errors.&lt;/p&gt; &#xA;&lt;h2&gt;Scene Object&lt;/h2&gt; &#xA;&lt;p&gt;A scene is a container for a set of geometries, and contains a spatial acceleration structure which can be used to perform different types of ray queries.&lt;/p&gt; &#xA;&lt;p&gt;A scene is created using the &lt;code&gt;rtcNewScene&lt;/code&gt; function call, and released using the &lt;code&gt;rtcReleaseScene&lt;/code&gt; function call. To populate a scene with geometries use the &lt;code&gt;rtcAttachGeometry&lt;/code&gt; call, and to detach them use the &lt;code&gt;rtcDetachGeometry&lt;/code&gt; call. Once all scene geometries are attached, an &lt;code&gt;rtcCommitScene&lt;/code&gt; call (or &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; call) will finish the scene description and trigger building of internal data structures. After the scene got committed, it is safe to perform ray queries (see Section &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#ray-queries&#34;&gt;Ray Queries&lt;/a&gt;) or to query the scene bounding box (see [rtcGetSceneBounds] and [rtcGetSceneLinearBounds]).&lt;/p&gt; &#xA;&lt;p&gt;If scene geometries get modified or attached or detached, the &lt;code&gt;rtcCommitScene&lt;/code&gt; call must be invoked before performing any further ray queries for the scene; otherwise the effect of the ray query is undefined. The modification of a geometry, committing the scene, and tracing of rays must always happen sequentially, and never at the same time. Any API call that sets a property of the scene or geometries contained in the scene count as scene modification, e.g.&amp;nbsp;including setting of intersection filter functions.&lt;/p&gt; &#xA;&lt;p&gt;Scene flags can be used to configure a scene to use less memory (&lt;code&gt;RTC_SCENE_FLAG_COMPACT&lt;/code&gt;), use more robust traversal algorithms (&lt;code&gt;RTC_SCENE_FLAG_ROBUST&lt;/code&gt;), and to optimize for dynamic content. See Section [rtcSetSceneFlags] for more details.&lt;/p&gt; &#xA;&lt;p&gt;A build quality can be specified for a scene to balance between acceleration structure build performance and ray query performance. See Section [rtcSetSceneBuildQuality] for more details on build quality.&lt;/p&gt; &#xA;&lt;h2&gt;Geometry Object&lt;/h2&gt; &#xA;&lt;p&gt;A new geometry is created using the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function. Depending on the geometry type, different buffers must be bound (e.g. using &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt;) to set up the geometry data. In most cases, binding of a vertex and index buffer is required. The number of primitives and vertices of that geometry is typically inferred from the size of these bound buffers.&lt;/p&gt; &#xA;&lt;p&gt;Changes to the geometry always must be committed using the &lt;code&gt;rtcCommitGeometry&lt;/code&gt; call before using the geometry. After committing, a geometry is not included in any scene. A geometry can be added to a scene by using the &lt;code&gt;rtcAttachGeometry&lt;/code&gt; function (to automatically assign a geometry ID) or using the &lt;code&gt;rtcAttachGeometryById&lt;/code&gt; function (to specify the geometry ID manually). A geometry can get attached to multiple scenes.&lt;/p&gt; &#xA;&lt;p&gt;All geometry types support multi-segment motion blur with an arbitrary number of equidistant time steps (in the range of 2 to 129) inside a user specified time range. Each geometry can have a different number of time steps and a different time range. The motion blur geometry is defined by linearly interpolating the geometries of neighboring time steps. To construct a motion blur geometry, first the number of time steps of the geometry must be specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; function, and then a vertex buffer for each time step must be bound, e.g.&amp;nbsp;using the &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; function. Optionally, a time range defining the start (and end time) of the first (and last) time step can be set using the &lt;code&gt;rtcSetGeometryTimeRange&lt;/code&gt; function. This feature will also allow geometries to appear and disappear during the camera shutter time if the time range is a sub range of [0,1].&lt;/p&gt; &#xA;&lt;h2&gt;Ray Queries&lt;/h2&gt; &#xA;&lt;p&gt;The API supports finding the closest hit of a ray segment with the scene (&lt;code&gt;rtcIntersect&lt;/code&gt;-type functions), and determining whether any hit between a ray segment and the scene exists (&lt;code&gt;rtcOccluded&lt;/code&gt;-type functions).&lt;/p&gt; &#xA;&lt;p&gt;Supported are single ray queries (&lt;code&gt;rtcIntersect1&lt;/code&gt; and &lt;code&gt;rtcOccluded1&lt;/code&gt;) as well as ray packet queries for ray packets of size 4 (&lt;code&gt;rtcIntersect4&lt;/code&gt; and &lt;code&gt;rtcOccluded4&lt;/code&gt;), ray packets of size 8 (&lt;code&gt;rtcIntersect8&lt;/code&gt; and &lt;code&gt;rtcOccluded8&lt;/code&gt;), and ray packets of size 16 (&lt;code&gt;rtcIntersect16&lt;/code&gt; and &lt;code&gt;rtcOccluded16&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;See Sections [rtcIntersect1] and [rtcOccluded1] for a detailed description of how to set up and trace a ray.&lt;/p&gt; &#xA;&lt;p&gt;See tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#triangle-geometry&#34;&gt;Triangle Geometry&lt;/a&gt; for a complete example of how to trace single rays and ray packets.&lt;/p&gt; &#xA;&lt;h2&gt;Point Queries&lt;/h2&gt; &#xA;&lt;p&gt;The API supports traversal of the BVH using a point query object that specifies a location and a query radius. For all primitives intersecting the according domain, a user defined callback function is called which allows queries such as finding the closest point on the surface geometries of the scene (see Tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#closest-point&#34;&gt;Closest Point&lt;/a&gt;) or nearest neighbour queries (see Tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#voronoi&#34;&gt;Voronoi&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;See Section [rtcPointQuery] for a detailed description of how to set up point queries.&lt;/p&gt; &#xA;&lt;h2&gt;Collision Detection&lt;/h2&gt; &#xA;&lt;p&gt;The Embree API also supports collision detection queries between two scenes consisting only of user geometries. Embree only performs broadphase collision detection, the narrow phase detection can be performed through a callback function.&lt;/p&gt; &#xA;&lt;p&gt;See Section [rtcCollide] for a detailed description of how to set up collision detection.&lt;/p&gt; &#xA;&lt;p&gt;Seen tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#collision-detection&#34;&gt;Collision Detection&lt;/a&gt; for a complete example of collision detection being used on a simple cloth solver.&lt;/p&gt; &#xA;&lt;h2&gt;Filter Functions&lt;/h2&gt; &#xA;&lt;p&gt;The API supports filter functions that are invoked for each intersection found during the &lt;code&gt;rtcIntersect&lt;/code&gt;-type or &lt;code&gt;rtcOccluded&lt;/code&gt;-type calls.&lt;/p&gt; &#xA;&lt;p&gt;The filter functions can be set per-geometry using the &lt;code&gt;rtcSetGeometryIntersectFilterFunction&lt;/code&gt; and &lt;code&gt;rtcSetGeometryOccludedFilterFunction&lt;/code&gt; calls. The former ones are called geometry intersection filter functions, the latter ones geometry occlusion filter functions. These filter functions are designed to be used to ignore intersections outside of a user-defined silhouette of a primitive, e.g.&amp;nbsp;to model tree leaves using transparency textures.&lt;/p&gt; &#xA;&lt;p&gt;The filter function can also get passed as arguments directly to the traversal functions, see section [rtcInitIntersectArguments] and [rtcInitOccludedArguments] for more details. These argument filter functions are designed to change the semantics of the ray query, e.g.&amp;nbsp;to accumulate opacity for transparent shadows, count the number of surfaces along a ray, collect all hits along a ray, etc. The argument filter function must be enabled to be used for a scene using the &lt;code&gt;RTC_SCENE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS&lt;/code&gt; scene flag. The callback is only invoked for geometries that enable the callback using the &lt;code&gt;rtcSetGeometryEnableFilterFunctionFromArguments&lt;/code&gt; call, or enabled for all geometries when the &lt;code&gt;RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&lt;/code&gt; ray query flag is set.&lt;/p&gt; &#xA;&lt;h2&gt;BVH Build API&lt;/h2&gt; &#xA;&lt;p&gt;The internal algorithms to build a BVH are exposed through the &lt;code&gt;RTCBVH&lt;/code&gt; object and &lt;code&gt;rtcBuildBVH&lt;/code&gt; call. This call makes it possible to build a BVH in a user-specified format over user-specified primitives. See the documentation of the &lt;code&gt;rtcBuildBVH&lt;/code&gt; call for more details.&lt;/p&gt; &#xA;&lt;h1&gt;Embree SYCL API&lt;/h1&gt; &#xA;&lt;p&gt;Embree supports ray tracing on Intel GPUs by using the SYCL programming language. SYCL is a Khronos standardized C++ based language for single source heterogenous programming for acceleration offload, see the &lt;a href=&#34;https://www.khronos.org/sycl/&#34;&gt;SYCL webpage&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;The Embree SYCL API is designed for photorealistic rendering use cases, where scene setup is performed on the host, and rendering on the device. The Embree SYCL API is very similar to the standard Embree C99 API, and supports most of its features, such as all triangle-type geometries, all curve types and basis functions, point geometry types, user geometries, filter callbacks, multi-level instancing, and motion blur.&lt;/p&gt; &#xA;&lt;p&gt;To enable SYCL support you have to include the &lt;code&gt;sycl.hpp&lt;/code&gt; file before the Embree API headers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;sycl/sycl.hpp&amp;gt;&#xA;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next you need to initializes an Embree SYCL device using the &lt;code&gt;rtcNewSYCLDevice&lt;/code&gt; API function by providing a SYCL context.&lt;/p&gt; &#xA;&lt;p&gt;Embree provides the &lt;code&gt;rtcIsSYCLDeviceSupported&lt;/code&gt; API function to check if some SYCL device is supported by Embree. You can also use the &lt;code&gt;rtcSYCLDeviceSelector&lt;/code&gt; to conveniently select the first SYCL device that is supported by Embree, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sycl::device device(rtcSYCLDeviceSelector);&#xA;sycl::queue queue(device, exception_handler);&#xA;sycl::context context(device);&#xA;RTCDevice device = rtcNewSYCLDevice(context,&#34;&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Scenes created with an Embree SYCL device can only get used to trace rays using SYCL on the GPU, it is not possible to trace rays on the CPU with such a device. To render on the CPU and GPU in parallel, the user has to create a second Embree device and create a second scene to be used on the CPU.&lt;/p&gt; &#xA;&lt;p&gt;Files containing SYCL code, have to get compiled with the Intel® oneAPI DPC++ compiler. Please see section [Linux SYCL Compilation] and [Windows SYCL Compilation] for supported compilers. The DPC++ compiler performs a two-phase compilation, where host code is compiled in a first phase, and device code compiled in a second compilation phase.&lt;/p&gt; &#xA;&lt;p&gt;Standard Embree API functions for scene construction can get used on the host but not the device. Data buffers that are shared with Embree (e.g.&amp;nbsp;for vertex of index buffers) have to get allocated as SYCL unified shared memory (USM memory), using the &lt;code&gt;sycl::malloc&lt;/code&gt; or &lt;code&gt;sycl::aligned_alloc&lt;/code&gt; calls with &lt;code&gt;sycl::usm::alloc::shared&lt;/code&gt; property, or the sycl::aligned_alloc_shared call, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;void* ptr = sycl::aligned_alloc(16, bytes, queue, sycl::usm::alloc::shared);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These shared allocations have to be valid during rendering, as Embree may access contained data when tracing rays. Embree does not support device-only memory allocations, as the BVH builder implemented on the CPU relies on reading the data buffers.&lt;/p&gt; &#xA;&lt;p&gt;Device side rendering can get invoked by submitting a SYCL &lt;code&gt;parallel_for&lt;/code&gt; to the SYCL queue:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;const sycl::specialization_id&amp;lt;RTCFeatureFlags&amp;gt; feature_mask;&#xA;&#xA;RTCFeatureFlags required_features = RTC_FEATURE_FLAG_TRIANGLE;&#xA;&#xA;queue.submit([=](sycl::handler&amp;amp; cgh)&#xA;{&#xA;  cgh.set_specialization_constant&amp;lt;feature_mask&amp;gt;(required_features);&#xA;  &#xA;  cgh.parallel_for(sycl::range&amp;lt;1&amp;gt;(1),[=](sycl::id&amp;lt;1&amp;gt; item, sycl::kernel_handler kh)&#xA;  {&#xA;    RTCIntersectArguments args;&#xA;    rtcInitIntersectArguments(&amp;amp;args);&#xA;&#xA;    const RTCFeatureFlags features = kh.get_specialization_constant&amp;lt;feature_mask&amp;gt;();&#xA;    args.feature_mask = features;&#xA;&#xA;    struct RTCRayHit rayhit;&#xA;    rayhit.ray.org_x = ox;&#xA;    rayhit.ray.org_y = oy;&#xA;    rayhit.ray.org_z = oz;&#xA;    rayhit.ray.dir_x = dx;&#xA;    rayhit.ray.dir_y = dy;&#xA;    rayhit.ray.dir_z = dz;&#xA;    rayhit.ray.tnear = 0;&#xA;    rayhit.ray.tfar = std::numeric_limits&amp;lt;float&amp;gt;::infinity();&#xA;    rayhit.ray.mask = -1;&#xA;    rayhit.ray.flags = 0;&#xA;    rayhit.hit.geomID = RTC_INVALID_GEOMETRY_ID;&#xA;    rayhit.hit.instID[0] = RTC_INVALID_GEOMETRY_ID;&#xA;&#xA;    rtcIntersect1(scene, &amp;amp;rayhit, &amp;amp;args);&#xA;&#xA;    result-&amp;gt;geomID = rayhit.hit.geomID;&#xA;    result-&amp;gt;primID = rayhit.hit.primID;&#xA;    result-&amp;gt;tfar = rayhit.ray.tfar;&#xA;  });&#xA;});&#xA;queue.wait_and_throw();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This example passes a feature mask using a specialization contant to the &lt;code&gt;rtcIntersect1&lt;/code&gt; function, which is recommended for GPU rendering. For best performance, this feature mask should get used to enable only features required by the application to render the scene, e.g.&amp;nbsp;just triangles in this example.&lt;/p&gt; &#xA;&lt;p&gt;Inside the SYCL &lt;code&gt;parallel_for&lt;/code&gt; loop you can use rendering related functions, such as the &lt;code&gt;rtcIntersect1&lt;/code&gt; and &lt;code&gt;rtcOccluded1&lt;/code&gt; functions to trace rays, &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; and &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; to continue object traversal from inside a user geometry callback, and &lt;code&gt;rtcGetGeometryUserDataFromScene&lt;/code&gt; to get the user data pointer of some geometry.&lt;/p&gt; &#xA;&lt;p&gt;Have a look at the [Minimal] tutorial for a minimal SYCL example.&lt;/p&gt; &#xA;&lt;h2&gt;SYCL JIT caching&lt;/h2&gt; &#xA;&lt;p&gt;Compile times for just in time compilation (JIT compilation) can be large. To resolve this issue we recommend enabling persistent JIT compilation caching inside your application, by setting the &lt;code&gt;SYCL_CACHE_PERSISTENT&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;, and the &lt;code&gt;SYCL_CACHE_DIR&lt;/code&gt; environment variable to some proper directory where the JIT cache should get stored. These environment variables have to get set before the SYCL device is created, e.g:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;setenv(&#34;SYCL_CACHE_PERSISTENT&#34;,&#34;1&#34;,1);&#xA;setenv(&#34;SYCL_CACHE_DIR&#34;,&#34;cache_dir&#34;,1);&#xA;&#xA;sycl::device device(rtcSYCLDeviceSelector);&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;SYCL Memory Pooling&lt;/h2&gt; &#xA;&lt;p&gt;Memory Pooling is a mechanism where small USM memory allocations are packed into larger allocation blocks. This mode is required when your application performs many small USM allocations, as otherwise only a small fraction of GPU memory is usable and data transfer performance will be low.&lt;/p&gt; &#xA;&lt;p&gt;Memory pooling is supported for USM allocations that are read-only by the device. The following example allocated device read-only memory with memory pooling support:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sycl::aligned_alloc_shared(align, bytes, queue,&#xA;  sycl::ext::oneapi::property::usm::device_read_only());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Embree SYCL Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Embree only supports Xe HPC and HPG GPUs as SYCL devices, thus in particular the CPU and other GPUs cannot get used as a SYCL device. To render on the CPU just use the standard C99 API without relying on SYCL.&lt;/p&gt; &#xA;&lt;p&gt;The SYCL language spec puts some restrictions to device functions, such as disallowing: global variable access, malloc, invokation of virtual functions, function pointers, runtime type information, exceptions, recursion, etc. See Section &lt;code&gt;5.4. Language Restrictions for device functions&lt;/code&gt; of the &lt;a href=&#34;https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:language.restrictions.kernels&#34;&gt;SYCL specification&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;Using Intel&#39;s oneAPI DPC++ compiler invoking an indirectly called function is allowed, but we do not recommend this for performance reasons.&lt;/p&gt; &#xA;&lt;p&gt;Some features are not supported by the Embree SYCL API thus cannot get used on the GPU:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The packet tracing functions &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; and &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt; are not supported in SYCL device side code. Using these functions makes no sense for SYCL, as the programming model is implicitely executed in SIMT mode on the GPU anyway.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Filter and user geometry callbacks stored inside the geometry objects are not supported on SYCL. Please use the alternative approach of passing the function pointer through the &lt;code&gt;RTCIntersectArguments&lt;/code&gt; (or &lt;code&gt;RTCOccludedArguments&lt;/code&gt;) structures to the tracing function, which enables inlining on the GPU.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;rtcInterpolate&lt;/code&gt; function cannot get used on the the device. For most primitive types the vertex data interpolation is anyway a trivial operation, and an API call just introduces overheads. On the CPU that overhead is acceptable, but on the GPU it is not. The &lt;code&gt;rtcInterpolate&lt;/code&gt; function does not know the geometry type it is interpolating over, thus its implementation on the GPU would contain a large switch statement for all potential geometry types.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Tracing rays using &lt;code&gt;rtcIntersect1&lt;/code&gt; and &lt;code&gt;rtcOccluded1&lt;/code&gt; functions from user geometry callbacks is not supported in SYCL. Please use the tail recursive &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; and &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; calls instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Subdivision surfaces are not supported for Embree SYCL devices.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Collision detection (&lt;code&gt;rtcCollide&lt;/code&gt; API call) is not supported in SYCL device side code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Point queries (&lt;code&gt;rtcPointQuery&lt;/code&gt; API call) are not supported in SYCL device side code.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Embree SYCL Known Issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The SYCL support of Embree is in beta phase. Current functionality, quality, and GPU performance may not reflect that of the final product.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Currently only the following Intel® Arc™ GPUs are support:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Intel® Arc™ A770 Graphics&lt;/li&gt; &#xA;   &lt;li&gt;Intel® Arc™ A750 Graphics&lt;/li&gt; &#xA;   &lt;li&gt;Intel® Arc™ A770M Graphics&lt;/li&gt; &#xA;   &lt;li&gt;Intel® Arc™ A730M Graphics&lt;/li&gt; &#xA;   &lt;li&gt;Intel® Arc™ A550M Graphics&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Intel® Data Center GPU Flex Series and Intel® Data Center GPU Max Series are currently not supported.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Ahead of time compilation is currently not working properly and you will get this error during compilation:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;llvm-foreach: Floating point exception (core dumped)&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Compilation with build configuration &#34;debug&#34; is currently not working on Windows.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Upgrading from Embree 3 to Embree 4&lt;/h1&gt; &#xA;&lt;p&gt;This section summarizes API changes between Embree 3 and Embree4. Most of these changes are motivated by GPU performance and having a consistent API that works properly for the CPU and GPU.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The API include folder got renamed from embree3 to embree4, to be able to install Embree 3 and Embree 4 side by side, without having conflicts in API folder.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;RTCIntersectContext&lt;/code&gt; is renamed to &lt;code&gt;RTCRayQueryContext&lt;/code&gt; and the &lt;code&gt;RTCIntersectContextFlags&lt;/code&gt; got renamed to &lt;code&gt;RTCRayQueryFlags&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There are some changes to the &lt;code&gt;rtcIntersect&lt;/code&gt; and &lt;code&gt;rtcOccluded&lt;/code&gt; functions. Most members of the old intersect context have been moved to some optional &lt;code&gt;RTCIntersectArguments&lt;/code&gt; (and &lt;code&gt;RTCOccludedArguments&lt;/code&gt;) structures, which also contains a pointer to the new ray query context. The argument structs fulfill the task of providing additional advanced arguments to the traversal functions. The ray query context can get used to pass additional data to callbacks, and to maintain an instID stack in case instancing is done manually inside user geometry callbacks. The arguments struct is not available inside callbacks. This change was in particular necessary for SYCL to allow inlining of function pointers provided to the traversal functions, and to reduce the amount of state passed to callbacks, which both improves GPU performance. Most applications can just drop passing the ray query context to port to Embree 4.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;rtcFilterIntersection&lt;/code&gt; and &lt;code&gt;rtcFilterOcclusion&lt;/code&gt; API calls that invoke both, the geometry and argument version of the filter callback, from a user geometry callback are no longer supported. Instead applications should use the &lt;code&gt;rtcInvokeIntersectFilterFromGeometry&lt;/code&gt; and &lt;code&gt;rtcInvokeOccludedFilterFromGeometry&lt;/code&gt; API calls that invoke just the geometry version of the filter function, and invoke the argument filter function manually if required.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The filter function passed as arguments to &lt;code&gt;rtcIntersect&lt;/code&gt; and &lt;code&gt;rtcOccluded&lt;/code&gt; functions is only invoked for some geometry if enabled through &lt;code&gt;rtcSetGeometryEnableFilterFunctionFromArguments&lt;/code&gt; for that geometry. Alternatively, argument filter functions can get enabled for all geometries using the &lt;code&gt;RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&lt;/code&gt; ray query flag.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;User geometry callbacks get a valid vector as input to identify valid and invalid rays. In Embree 3 the user geometry callback just had to update the ray hit members when an intersection was found and perform no operation otherwise. In Embree 4 the callback additionally has to return valid=-1 when a hit was found, and valid=0 when no hit was found. This allows Embree to properly pass the new hit distance to the ray tracing hardware only in the case a hit was found.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Further ray masking is enabled by default now as required by most applications and the default ray mask for geometries got changed from 0xFFFFFFFF to 0x1.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The stream tracing functions &lt;code&gt;rtcIntersect1M&lt;/code&gt;, &lt;code&gt;rtcIntersect1Mp&lt;/code&gt;, &lt;code&gt;rtcIntersectNM&lt;/code&gt;, &lt;code&gt;rtcIntersectNp&lt;/code&gt;, &lt;code&gt;rtcOccluded1M&lt;/code&gt;, &lt;code&gt;rtcOccluded1Mp&lt;/code&gt;, &lt;code&gt;rtcOccludedNM&lt;/code&gt;, and &lt;code&gt;rtcOccludedNp&lt;/code&gt; got removed as they were rarely used and did not provide relevant performance benefits. As alternative the application can just iterate over &lt;code&gt;rtcIntersect1&lt;/code&gt; and potentially &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; to get similar performance.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To use Embree through SYCL on the CPU and GPU additional changes are required:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Embree 3 allows to use &lt;code&gt;rtcIntersect&lt;/code&gt; recursively from a user geometry or intersection filter callback to continue a ray inside an instantiated object. In Embree 4 using &lt;code&gt;rtcIntersect&lt;/code&gt; recursively is disallowed on the GPU but still supported on the CPU. To properly continue a ray inside an instantiated object use the new &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; and &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; functions.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The geometry object of Embree 4 is a host side only object, thus accessing it during rendering from the GPU is not allowed. Thus all API functions that take an RTCGeometry object as argument cannot get used during rendering. Thus in particular the &lt;code&gt;rtcGetGeometryUserData(RTCGeometry)&lt;/code&gt; call cannot get used, but there is an alternative function &lt;code&gt;rtcGetGeometryUserDataFromScene(RTCScene scene,uint geomID)&lt;/code&gt; that should get used instead.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The user geometry callback and filter callback functions should get passed through the intersection and occlusion argument structures to the &lt;code&gt;rtcIntersect1&lt;/code&gt; and &lt;code&gt;rtcOccluded1&lt;/code&gt; functions directly to allow inlining. The experimental geometry version of the callbacks is disabled in SYCL and should not get used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The feature flags should get used in SYCL to minimal GPU code for optimal performance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;code&gt;rtcInterpolate&lt;/code&gt; function cannot get used on the device, and vertex data interpolation should get implemented by the application.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Indirectly called functions must be declared with &lt;code&gt;RTC_SYCL_INDIRECTLY_CALLABLE&lt;/code&gt; when used as filter or user geometry callbacks.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Embree API Reference&lt;/h1&gt; &#xA;&lt;h2&gt;rtcNewDevice&lt;/h2&gt; &#xA;&lt;h4&gt;NAME&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewDevice - creates a new device&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCDevice rtcNewDevice(const char* config);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION&lt;/h4&gt; &#xA;&lt;p&gt;This function creates a new device to be used for CPU ray tracing and returns a handle to this device. The device object is reference counted with an initial reference count of 1. The handle can be released using the &lt;code&gt;rtcReleaseDevice&lt;/code&gt; API call.&lt;/p&gt; &#xA;&lt;p&gt;The device object acts as a class factory for all other object types. All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not be destroyed unless these objects are destroyed first.&lt;/p&gt; &#xA;&lt;p&gt;Objects are only compatible if they belong to the same device, e.g it is not allowed to create a geometry in one device and attach it to a scene created with a different device.&lt;/p&gt; &#xA;&lt;p&gt;A configuration string (&lt;code&gt;config&lt;/code&gt; argument) can be passed to the device construction. This configuration string can be &lt;code&gt;NULL&lt;/code&gt; to use the default configuration.&lt;/p&gt; &#xA;&lt;p&gt;The following configuration is supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;threads=[int]&lt;/code&gt;: Specifies a number of build threads to use. A value of 0 enables all detected hardware threads. By default all hardware threads are used.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;user_threads=[int]&lt;/code&gt;: Sets the number of user threads that can be used to join and participate in a scene commit using &lt;code&gt;rtcJoinCommitScene&lt;/code&gt;. The tasking system will only use threads-user_threads many worker threads, thus if the app wants to solely use its threads to commit scenes, just set threads equal to user_threads. This option only has effect with the Intel(R) Threading Building Blocks (TBB) tasking system.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;set_affinity=[0/1]&lt;/code&gt;: When enabled, build threads are affinitized to hardware threads. This option is disabled by default on standard CPUs, and enabled by default on Xeon Phi Processors.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;start_threads=[0/1]&lt;/code&gt;: When enabled, the build threads are started upfront. This can be useful for benchmarking to exclude thread creation time. This option is disabled by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;isa=[sse2,sse4.2,avx,avx2,avx512]&lt;/code&gt;: Use specified ISA. By default the ISA is selected automatically.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;max_isa=[sse2,sse4.2,avx,avx2,avx512]&lt;/code&gt;: Configures the automated ISA selection to use maximally the specified ISA.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;hugepages=[0/1]&lt;/code&gt;: Enables or disables usage of huge pages. Under Linux huge pages are used by default but under Windows and macOS they are disabled by default.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;enable_selockmemoryprivilege=[0/1]&lt;/code&gt;: When set to 1, this enables the &lt;code&gt;SeLockMemoryPrivilege&lt;/code&gt; privilege with is required to use huge pages on Windows. This option has an effect only under Windows and is ignored on other platforms. See Section [Huge Page Support] for more details.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;verbose=[0,1,2,3]&lt;/code&gt;: Sets the verbosity of the output. When set to 0, no output is printed by Embree, when set to a higher level more output is printed. By default Embree does not print anything on the console.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;frequency_level=[simd128,simd256,simd512]&lt;/code&gt;: Specifies the frequency level the application want to run on, which can be either: a) simd128 to run at highest frequency b) simd256 to run at AVX2-heavy frequency level c) simd512 to run at heavy AVX512 frequency level. When some frequency level is specified, Embree will avoid doing optimizations that may reduce the frequency level below the level specified. E.g. if your app does not use AVX instructions setting &#34;frequency_level=simd128&#34; will cause some CPUs to run at highest frequency, which may result in higher application performance if you do much shading. If you application heavily uses AVX code, you should best set the frequency level to simd256. Per default Embree tries to avoid reducing the frequency of the CPU by setting the simd256 level only when the CPU has no significant down clocking.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Different configuration options should be separated by commas, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewDevice(&#34;threads=1,isa=avx&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;EXIT STATUS&lt;/h4&gt; &#xA;&lt;p&gt;On success returns a handle of the created device. On failure returns &lt;code&gt;NULL&lt;/code&gt; as device and sets a per-thread error code that can be queried using &lt;code&gt;rtcGetDeviceError(NULL)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO&lt;/h4&gt; &#xA;&lt;p&gt;[rtcRetainDevice], [rtcReleaseDevice], [rtcNewSYCLDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcNewSYCLDevice&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewSYCLDevice - creates a new device to be used with SYCL&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCDevice rtcNewSYCLDevice(sycl::context context, const char* config);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function creates a new device to be used with SYCL for GPU rendering and returns a handle to this device. The device object is reference counted with an initial reference count of 1. The handle can get released using the &lt;code&gt;rtcReleaseDevice&lt;/code&gt; API call.&lt;/p&gt; &#xA;&lt;p&gt;The passed SYCL context (&lt;code&gt;context&lt;/code&gt; argument) is used to allocate GPU data, thus only devices contained inside this context can be used for rendering. By default the GPU data is allocated on the first GPU device of the context, but this behavior can get changed with the [rtcSetDeviceSYCLDevice] function.&lt;/p&gt; &#xA;&lt;p&gt;The device object acts as a class factory for all other object types. All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not be destroyed unless these objects are destroyed first.&lt;/p&gt; &#xA;&lt;p&gt;Objects are only compatible if they belong to the same device, e.g it is not allowed to create a geometry in one device and attach it to a scene created with a different device.&lt;/p&gt; &#xA;&lt;p&gt;For an overview of configurations that can get passed (&lt;code&gt;config&lt;/code&gt; argument) please see the [rtcNewDevice] function description.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On success returns a handle of the created device. On failure returns &lt;code&gt;NULL&lt;/code&gt; as device and sets a per-thread error code that can be queried using &lt;code&gt;rtcGetDeviceError(NULL)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcRetainDevice], [rtcReleaseDevice], [rtcNewDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcIsSYCLDeviceSupported&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcIsSYCLDeviceSupported - checks if some SYCL device is supported by Embree&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;bool rtcIsSYCLDeviceSupported(const sycl::device sycl_device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function can be used to check if some SYCL device (&lt;code&gt;sycl_device&lt;/code&gt; argument) is supported by Embree.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;The function returns true if the SYCL device is supported by Embree and false otherwise. On failure an error code is set that can get queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSYCLDeviceSelector]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSYCLDeviceSelector&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSYCLDeviceSelector - SYCL device selector function to select&#xA;  devices supported by Embree&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;int rtcSYCLDeviceSelector(const sycl::device sycl_device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function checks if the passed SYCL device (&lt;code&gt;sycl_device&lt;/code&gt; arguments) is supported by Embree or not. This function can be used directly to select some supported SYCL device by using it as SYCL device selector function. For instance, the following code sequence selects an Embree supported SYCL device and creates an Embree device from it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sycl::device sycl_device(rtcSYCLDeviceSelector);&#xA;sycl::queue sycl_queue(sycl_device);&#xA;sycl::context(sycl_device);&#xA;RTCDevice device = rtcNewSYCLDevice(sycl_context,nullptr);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;The function returns -1 if the SYCL device is supported by Embree and 1 otherwise. On failure an error code is set that can get queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIsSYCLDeviceSupported]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetDeviceSYCLDevice&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetDeviceSYCLDevice - sets the SYCL device to be used for memory allocations&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetDeviceSYCLDevice(RTCDevice device, const sycl::device sycl_device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function sets the SYCL device (&lt;code&gt;sycl_device&lt;/code&gt; argument) to be used to allocate GPU memory when using the specified Embree device (&lt;code&gt;device&lt;/code&gt; argument). This SYCL device must be one of the SYCL devices contained inside the SYCL context used to create the Embree device.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can get queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewSYCLDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcRetainDevice&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcRetainDevice - increments the device reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcRetainDevice(RTCDevice device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Device objects are reference counted. The &lt;code&gt;rtcRetainDevice&lt;/code&gt; function increments the reference count of the passed device object (&lt;code&gt;device&lt;/code&gt; argument). This function together with &lt;code&gt;rtcReleaseDevice&lt;/code&gt; allows to use the internal reference counting in a C++ wrapper class to manage the ownership of the object.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewDevice], [rtcReleaseDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcReleaseDevice&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcReleaseDevice - decrements the device reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcReleaseDevice(RTCDevice device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Device objects are reference counted. The &lt;code&gt;rtcReleaseDevice&lt;/code&gt; function decrements the reference count of the passed device object (&lt;code&gt;device&lt;/code&gt; argument). When the reference count falls to 0, the device gets destroyed.&lt;/p&gt; &#xA;&lt;p&gt;All objects created from the device (like scenes, geometries, etc.) hold a reference to the device, thus the device will not get destroyed unless these objects are destroyed first.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewDevice], [rtcRetainDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetDeviceProperty&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetDeviceProperty - queries properties of the device&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;ssize_t rtcGetDeviceProperty(&#xA;  RTCDevice device,&#xA;  enum RTCDeviceProperty prop&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt; function can be used to query properties (&lt;code&gt;prop&lt;/code&gt; argument) of a device object (&lt;code&gt;device&lt;/code&gt; argument). The returned property is an integer of type &lt;code&gt;ssize_t&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Possible properties to query are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_VERSION&lt;/code&gt;: Queries the combined version number (MAJOR.MINOR.PATCH) with two decimal digits per component. E.g. for Embree 2.8.3 the integer 208003 is returned.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_VERSION_MAJOR&lt;/code&gt;: Queries the major version number of Embree.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_VERSION_MINOR&lt;/code&gt;: Queries the minor version number of Embree.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_VERSION_PATCH&lt;/code&gt;: Queries the patch version number of Embree.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED&lt;/code&gt;: Queries whether the &lt;code&gt;rtcIntersect4&lt;/code&gt; and &lt;code&gt;rtcOccluded4&lt;/code&gt; functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with &lt;code&gt;EMBREE_RAY_PACKETS&lt;/code&gt; and &lt;code&gt;SSE2&lt;/code&gt; (or &lt;code&gt;SSE4.2&lt;/code&gt;) enabled, and if the machine it is running on supports &lt;code&gt;SSE2&lt;/code&gt; (or &lt;code&gt;SSE4.2&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED&lt;/code&gt;: Queries whether the &lt;code&gt;rtcIntersect8&lt;/code&gt; and &lt;code&gt;rtcOccluded8&lt;/code&gt; functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with &lt;code&gt;EMBREE_RAY_PACKETS&lt;/code&gt; and &lt;code&gt;AVX&lt;/code&gt; (or &lt;code&gt;AVX2&lt;/code&gt;) enabled, and if the machine it is running on supports &lt;code&gt;AVX&lt;/code&gt; (or &lt;code&gt;AVX2&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED&lt;/code&gt;: Queries whether the &lt;code&gt;rtcIntersect16&lt;/code&gt; and &lt;code&gt;rtcOccluded16&lt;/code&gt; functions preserve packet size and ray order when invoking callback functions. This is only the case if Embree is compiled with &lt;code&gt;EMBREE_RAY_PACKETS&lt;/code&gt; and &lt;code&gt;AVX512&lt;/code&gt; enabled, and if the machine it is running on supports &lt;code&gt;AVX512&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_RAY_MASK_SUPPORTED&lt;/code&gt;: Queries whether ray masks are supported. This is only the case if Embree is compiled with &lt;code&gt;EMBREE_RAY_MASK&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_BACKFACE_CULLING_ENABLED&lt;/code&gt;: Queries whether back face culling is enabled. This is only the case if Embree is compiled with &lt;code&gt;EMBREE_BACKFACE_CULLING&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_COMPACT_POLYS_ENABLED&lt;/code&gt;: Queries whether compact polys is enabled. This is only the case if Embree is compiled with &lt;code&gt;EMBREE_COMPACT_POLYS&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_FILTER_FUNCTION_SUPPORTED&lt;/code&gt;: Queries whether filter functions are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_FILTER_FUNCTION&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_IGNORE_INVALID_RAYS_ENABLED&lt;/code&gt;: Queries whether invalid rays are ignored, which is the case if Embree is compiled with &lt;code&gt;EMBREE_IGNORE_INVALID_RAYS&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_TRIANGLE_GEOMETRY_SUPPORTED&lt;/code&gt;: Queries whether triangles are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_GEOMETRY_TRIANGLE&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_QUAD_GEOMETRY_SUPPORTED&lt;/code&gt;: Queries whether quads are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_GEOMETRY_QUAD&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_SUBDIVISION_GEOMETRY_SUPPORTED&lt;/code&gt;: Queries whether subdivision meshes are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_GEOMETRY_SUBDIVISION&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_CURVE_GEOMETRY_SUPPORTED&lt;/code&gt;: Queries whether curves are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_GEOMETRY_CURVE&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_POINT_GEOMETRY_SUPPORTED&lt;/code&gt;: Queries whether points are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_GEOMETRY_POINT&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_USER_GEOMETRY_SUPPORTED&lt;/code&gt;: Queries whether user geometries are supported, which is the case if Embree is compiled with &lt;code&gt;EMBREE_GEOMETRY_USER&lt;/code&gt; enabled.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_TASKING_SYSTEM&lt;/code&gt;: Queries the tasking system Embree is compiled with. Possible return values are:&lt;/p&gt; &#xA;  &lt;ol start=&#34;0&#34;&gt; &#xA;   &lt;li&gt;internal tasking system&lt;/li&gt; &#xA;   &lt;li&gt;Intel Threading Building Blocks (TBB)&lt;/li&gt; &#xA;   &lt;li&gt;Parallel Patterns Library (PPL)&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_JOIN_COMMIT_SUPPORTED&lt;/code&gt;: Queries whether &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; is supported. This is not the case when Embree is compiled with PPL or older versions of TBB.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_DEVICE_PROPERTY_PARALLEL_COMMIT_SUPPORTED&lt;/code&gt;: Queries whether &lt;code&gt;rtcCommitScene&lt;/code&gt; can get invoked from multiple TBB worker threads concurrently. This feature is only supported starting with TBB 2019 Update 9.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On success returns the value of the queried property. For properties returning a boolean value, the return value 0 denotes &lt;code&gt;false&lt;/code&gt; and 1 denotes &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On failure zero is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetDeviceError&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetDeviceError - returns the error code of the device&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCError rtcGetDeviceError(RTCDevice device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Each thread has its own error code per device. If an error occurs when calling an API function, this error code is set to the occurred error if it stores no previous error. The &lt;code&gt;rtcGetDeviceError&lt;/code&gt; function reads and returns the currently stored error and clears the error code. This assures that the returned error code is always the first error occurred since the last invocation of &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Possible error codes returned by &lt;code&gt;rtcGetDeviceError&lt;/code&gt; are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_NONE&lt;/code&gt;: No error occurred.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_UNKNOWN&lt;/code&gt;: An unknown error has occurred.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_INVALID_ARGUMENT&lt;/code&gt;: An invalid argument was specified.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_INVALID_OPERATION&lt;/code&gt;: The operation is not allowed for the specified object.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_OUT_OF_MEMORY&lt;/code&gt;: There is not enough memory left to complete the operation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_UNSUPPORTED_CPU&lt;/code&gt;: The CPU is not supported as it does not support the lowest ISA Embree is compiled for.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_ERROR_CANCELLED&lt;/code&gt;: The operation got canceled by a memory monitor callback or progress monitor callback function.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When the device construction fails, &lt;code&gt;rtcNewDevice&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt; as device. To detect the error code of a such a failed device construction, pass &lt;code&gt;NULL&lt;/code&gt; as device to the &lt;code&gt;rtcGetDeviceError&lt;/code&gt; function. For all other invocations of &lt;code&gt;rtcGetDeviceError&lt;/code&gt;, a proper device pointer must be specified.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;Returns the error code for the device.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetDeviceErrorFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetDeviceErrorFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetDeviceErrorFunction - sets an error callback function for the device&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;typedef void (*RTCErrorFunction)(&#xA;  void* userPtr,&#xA;  RTCError code,&#xA;  const char* str&#xA;);&#xA;&#xA;void rtcSetDeviceErrorFunction(&#xA;  RTCDevice device,&#xA;  RTCErrorFunction error,&#xA;  void* userPtr&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;rtcSetDeviceErrorFunction&lt;/code&gt; call, it is possible to set a callback function (&lt;code&gt;error&lt;/code&gt; argument) with payload (&lt;code&gt;userPtr&lt;/code&gt; argument), which is called whenever an error occurs for the specified device (&lt;code&gt;device&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per device, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;When the registered callback function is invoked, it gets passed the user-defined payload (&lt;code&gt;userPtr&lt;/code&gt; argument as specified at registration time), the error code (&lt;code&gt;code&lt;/code&gt; argument) of the occurred error, as well as a string (&lt;code&gt;str&lt;/code&gt; argument) that further describes the error.&lt;/p&gt; &#xA;&lt;p&gt;The error code is also set if an error callback function is registered.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetDeviceError]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetDeviceMemoryMonitorFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetDeviceMemoryMonitorFunction - registers a callback function&#xA;  to track memory consumption&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;typedef bool (*RTCMemoryMonitorFunction)(&#xA;  void* userPtr,&#xA;  ssize_t bytes,&#xA;  bool post&#xA;);&#xA;&#xA;void rtcSetDeviceMemoryMonitorFunction(&#xA;  RTCDevice device,&#xA;  RTCMemoryMonitorFunction memoryMonitor,&#xA;  void* userPtr&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;rtcSetDeviceMemoryMonitorFunction&lt;/code&gt; call, it is possible to register a callback function (&lt;code&gt;memoryMonitor&lt;/code&gt; argument) with payload (&lt;code&gt;userPtr&lt;/code&gt; argument) for a device (&lt;code&gt;device&lt;/code&gt; argument), which is called whenever internal memory is allocated or deallocated by objects of that device. Using this memory monitor callback mechanism, the application can track the memory consumption of an Embree device, and optionally terminate API calls that consume too much memory.&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per device, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;Once registered, the Embree device will invoke the memory monitor callback function before or after it allocates or frees important memory blocks. The callback function gets passed the payload as specified at registration time (&lt;code&gt;userPtr&lt;/code&gt; argument), the number of bytes allocated or deallocated (&lt;code&gt;bytes&lt;/code&gt; argument), and whether the callback is invoked after the allocation or deallocation took place (&lt;code&gt;post&lt;/code&gt; argument). The callback function might get called from multiple threads concurrently.&lt;/p&gt; &#xA;&lt;p&gt;The application can track the current memory usage of the Embree device by atomically accumulating the &lt;code&gt;bytes&lt;/code&gt; input parameter provided to the callback function. This parameter will be &amp;gt;0 for allocations and &amp;lt;0 for deallocations.&lt;/p&gt; &#xA;&lt;p&gt;Embree will continue its operation normally when returning &lt;code&gt;true&lt;/code&gt; from the callback function. If &lt;code&gt;false&lt;/code&gt; is returned, Embree will cancel the current operation with the &lt;code&gt;RTC_ERROR_OUT_OF_MEMORY&lt;/code&gt; error code. Issuing multiple cancel requests from different threads is allowed. Canceling will only happen when the callback was called for allocations (bytes &amp;gt; 0), otherwise the cancel request will be ignored.&lt;/p&gt; &#xA;&lt;p&gt;If a callback to cancel was invoked before the allocation happens (&lt;code&gt;post == false&lt;/code&gt;), then the &lt;code&gt;bytes&lt;/code&gt; parameter should not be accumulated, as the allocation will never happen. If the callback to cancel was invoked after the allocation happened (&lt;code&gt;post == true&lt;/code&gt;), then the &lt;code&gt;bytes&lt;/code&gt; parameter should be accumulated, as the allocation properly happened and a deallocation will later free that data block.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcNewScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewScene - creates a new scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCScene rtcNewScene(RTCDevice device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function creates a new scene bound to the specified device (&lt;code&gt;device&lt;/code&gt; argument), and returns a handle to this scene. The scene object is reference counted with an initial reference count of 1. The scene handle can be released using the &lt;code&gt;rtcReleaseScene&lt;/code&gt; API call.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On success a scene handle is returned. On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcRetainScene], [rtcReleaseScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetSceneDevice&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetSceneDevice - returns the device the scene got created in&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCDevice rtcGetSceneDevice(RTCScene scene);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function returns the device object the scene got created in. The returned handle own one additional reference to the device object, thus you should need to call &lt;code&gt;rtcReleaseDevice&lt;/code&gt; when the returned handle is no longer required.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcReleaseDevice]&lt;/p&gt; &#xA;&lt;h2&gt;rtcRetainScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcRetainScene - increments the scene reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcRetainScene(RTCScene scene);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Scene objects are reference counted. The &lt;code&gt;rtcRetainScene&lt;/code&gt; function increments the reference count of the passed scene object (&lt;code&gt;scene&lt;/code&gt; argument). This function together with &lt;code&gt;rtcReleaseScene&lt;/code&gt; allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewScene], [rtcReleaseScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcReleaseScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcReleaseScene - decrements the scene reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcReleaseScene(RTCScene scene);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Scene objects are reference counted. The &lt;code&gt;rtcReleaseScene&lt;/code&gt; function decrements the reference count of the passed scene object (&lt;code&gt;scene&lt;/code&gt; argument). When the reference count falls to 0, the scene gets destroyed.&lt;/p&gt; &#xA;&lt;p&gt;The scene holds a reference to all attached geometries, thus if the scene gets destroyed, all geometries get detached and their reference count decremented.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewScene], [rtcRetainScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcAttachGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcAttachGeometry - attaches a geometry to the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;unsigned int rtcAttachGeometry(&#xA;  RTCScene scene,&#xA;  RTCGeometry geometry&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcAttachGeometry&lt;/code&gt; function attaches a geometry (&lt;code&gt;geometry&lt;/code&gt; argument) to a scene (&lt;code&gt;scene&lt;/code&gt; argument) and assigns a geometry ID to that geometry. All geometries attached to a scene are defined to be included inside the scene. A geometry can get attached to multiple scenes. The geometry ID is unique for the scene, and is used to identify the geometry when hit by a ray during ray queries.&lt;/p&gt; &#xA;&lt;p&gt;This function is thread-safe, thus multiple threads can attach geometries to a scene in parallel.&lt;/p&gt; &#xA;&lt;p&gt;The geometry IDs are assigned sequentially, starting from 0, as long as no geometry got detached. If geometries got detached, the implementation will reuse IDs in an implementation dependent way. Consequently sequential assignment is no longer guaranteed, but a compact range of IDs.&lt;/p&gt; &#xA;&lt;p&gt;These rules allow the application to manage a dynamic array to efficiently map from geometry IDs to its own geometry representation. Alternatively, the application can also use per-geometry user data to map to its geometry representation. See &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; and &lt;code&gt;rtcGetGeometryUserData&lt;/code&gt; for more information.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryUserData], [rtcGetGeometryUserData]&lt;/p&gt; &#xA;&lt;h2&gt;rtcAttachGeometryByID&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcAttachGeometryByID - attaches a geometry to the scene&#xA;  using a specified geometry ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcAttachGeometryByID(&#xA;  RTCScene scene,&#xA;  RTCGeometry geometry,&#xA;  unsigned int geomID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcAttachGeometryByID&lt;/code&gt; function attaches a geometry (&lt;code&gt;geometry&lt;/code&gt; argument) to a scene (&lt;code&gt;scene&lt;/code&gt; argument) and assigns a user provided geometry ID (&lt;code&gt;geomID&lt;/code&gt; argument) to that geometry. All geometries attached to a scene are defined to be included inside the scene. A geometry can get attached to multiple scenes. The passed user-defined geometry ID is used to identify the geometry when hit by a ray during ray queries. Using this function, it is possible to share the same IDs to refer to geometries inside the application and Embree.&lt;/p&gt; &#xA;&lt;p&gt;This function is thread-safe, thus multiple threads can attach geometries to a scene in parallel.&lt;/p&gt; &#xA;&lt;p&gt;The user-provided geometry ID must be unused in the scene, otherwise the creation of the geometry will fail. Further, the user-provided geometry IDs should be compact, as Embree internally creates a vector which size is equal to the largest geometry ID used. Creating very large geometry IDs for small scenes would thus cause a memory consumption and performance overhead.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcAttachGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;rtcDetachGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcDetachGeometry - detaches a geometry from the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcDetachGeometry(RTCScene scene, unsigned int geomID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function detaches a geometry identified by its geometry ID (&lt;code&gt;geomID&lt;/code&gt; argument) from a scene (&lt;code&gt;scene&lt;/code&gt; argument). When detached, the geometry is no longer contained in the scene.&lt;/p&gt; &#xA;&lt;p&gt;This function is thread-safe, thus multiple threads can detach geometries from a scene at the same time.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcAttachGeometry], [rtcAttachGeometryByID]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometry - returns the geometry bound to&#xA;  the specified geometry ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry rtcGetGeometry(RTCScene scene, unsigned int geomID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometry&lt;/code&gt; function returns the geometry that is bound to the specified geometry ID (&lt;code&gt;geomID&lt;/code&gt; argument) for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument). This function just looks up the handle and does &lt;em&gt;not&lt;/em&gt; increment the reference count. If you want to get ownership of the handle, you need to additionally call &lt;code&gt;rtcRetainGeometry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function is not thread safe and thus can be used during rendering. However, it is generally recommended to store the geometry handle inside the application&#39;s geometry representation and look up the geometry handle from that representation directly.&lt;/p&gt; &#xA;&lt;p&gt;If you need a thread safe version of this function please use [rtcGetGeometryThreadSafe].&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcAttachGeometry], [rtcAttachGeometryByID], [rtcGetGeometryThreadSafe]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryThreadSafe&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryThreadSafe - returns the geometry bound to&#xA;  the specified geometry ID&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry rtcGetGeometryThreadSafe(RTCScene scene, unsigned int geomID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryThreadSafe&lt;/code&gt; function returns the geometry that is bound to the specified geometry ID (&lt;code&gt;geomID&lt;/code&gt; argument) for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument). This function just looks up the handle and does &lt;em&gt;not&lt;/em&gt; increment the reference count. If you want to get ownership of the handle, you need to additionally call &lt;code&gt;rtcRetainGeometry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This function is thread safe and should NOT get used during rendering. If you need a fast non-thread safe version during rendering please use the [rtcGetGeometry] function.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcAttachGeometry], [rtcAttachGeometryByID], [rtcGetGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;rtcCommitScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcCommitScene - commits scene changes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcCommitScene(RTCScene scene);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcCommitScene&lt;/code&gt; function commits all changes for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument). This internally triggers building of a spatial acceleration structure for the scene using all available worker threads. Ray queries can be performed only after committing all scene changes.&lt;/p&gt; &#xA;&lt;p&gt;If the application uses TBB 2019 Update 9 or later for parallelization of rendering, lazy scene construction during rendering is supported by &lt;code&gt;rtcCommitScene&lt;/code&gt;. Therefore &lt;code&gt;rtcCommitScene&lt;/code&gt; can get called from multiple TBB worker threads concurrently for the same scene. The &lt;code&gt;rtcCommitScene&lt;/code&gt; function will then internally isolate the scene construction using a tbb::isolated_task_group. The alternative approach of using &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; which uses an tbb:task_arena internally, is not recommended due to it&#39;s high runtime overhead.&lt;/p&gt; &#xA;&lt;p&gt;If scene geometries get modified or attached or detached, the &lt;code&gt;rtcCommitScene&lt;/code&gt; call must be invoked before performing any further ray queries for the scene; otherwise the effect of the ray query is undefined. The modification of a geometry, committing the scene, and tracing of rays must always happen sequentially, and never at the same time. Any API call that sets a property of the scene or geometries contained in the scene count as scene modification, e.g.&amp;nbsp;including setting of intersection filter functions.&lt;/p&gt; &#xA;&lt;p&gt;The kind of acceleration structure built can be influenced using scene flags (see &lt;code&gt;rtcSetSceneFlags&lt;/code&gt;), and the quality can be specified using the &lt;code&gt;rtcSetSceneBuildQuality&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Embree silently ignores primitives during spatial acceleration structure construction that would cause numerical issues, e.g.&amp;nbsp;primitives containing NaNs, INFs, or values greater than 1.844E18f (as no reasonable calculations can be performed with such values without causing overflows).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcJoinCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcJoinCommitScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcJoinCommitScene - commits the scene from multiple threads&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcJoinCommitScene(RTCScene scene);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; function commits all changes for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument). The scene commit internally triggers building of a spatial acceleration structure for the scene. Ray queries can be performed after scene changes got properly committed.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; function can get called from multiple user threads which will all cooperate in the build operation. All threads calling into this function will return from &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; after the scene commit is finished. All threads must consistently call &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; and not &lt;code&gt;rtcCommitScene&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In contrast to the &lt;code&gt;rtcCommitScene&lt;/code&gt; function, the &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; function can be called from multiple user threads, while the &lt;code&gt;rtcCommitScene&lt;/code&gt; can only get called from multiple TBB worker threads when used concurrently. For optimal performance we strongly recommend using TBB inside the application together with the &lt;code&gt;rtcCommitScene&lt;/code&gt; function and to avoid using the &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; feature allows a flexible way to lazily create hierarchies during rendering. A thread reaching a not-yet-constructed sub-scene of a two-level scene can generate the sub-scene geometry and call &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; on that just generated scene. During construction, further threads reaching the not-yet-built scene can join the build operation by also invoking &lt;code&gt;rtcJoinCommitScene&lt;/code&gt;. A thread that calls &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; after the build finishes will directly return from the &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;Multiple scene commit operations on different scenes can be running at the same time, hence it is possible to commit many small scenes in parallel, distributing the commits to many threads.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree with the Intel® Threading Building Blocks (which is the default), threads that call &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; will join the build operation, but other TBB worker threads might also participate in the build. To avoid thread oversubscription, we recommend using TBB also inside the application. Further, the join mode only works properly starting with TBB v4.4 Update 1. For earlier TBB versions, threads that call &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; to join a running build will just trigger the build and wait for the build to finish. Further, old TBB versions with &lt;code&gt;TBB_INTERFACE_VERSION_MAJOR &amp;lt; 8&lt;/code&gt; do not support &lt;code&gt;rtcJoinCommitScene&lt;/code&gt;, and invoking this function will result in an error.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree with the internal tasking system, only threads that call &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; will perform the build operation, and no additional worker threads will be scheduled.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree with the Parallel Patterns Library (PPL), &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; is not supported and calling that function will result in an error.&lt;/p&gt; &#xA;&lt;p&gt;To detect whether &lt;code&gt;rtcJoinCommitScene&lt;/code&gt; is supported, use the &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcCommitScene], [rtcGetDeviceProperty]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetSceneProgressMonitorFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetSceneProgressMonitorFunction - registers a callback&#xA;  to track build progress&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;typedef bool (*RTCProgressMonitorFunction)(&#xA;  void* ptr,&#xA;  double n&#xA;);&#xA;&#xA;void rtcSetSceneProgressMonitorFunction(&#xA;  RTCScene scene,&#xA;  RTCProgressMonitorFunction progress,&#xA;  void* userPtr&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Embree supports a progress monitor callback mechanism that can be used to report progress of hierarchy build operations and to cancel build operations.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetSceneProgressMonitorFunction&lt;/code&gt; registers a progress monitor callback function (&lt;code&gt;progress&lt;/code&gt; argument) with payload (&lt;code&gt;userPtr&lt;/code&gt; argument) for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per scene, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;Once registered, Embree will invoke the callback function multiple times during hierarchy build operations of the scene, by passing the payload as set at registration time (&lt;code&gt;userPtr&lt;/code&gt; argument), and a double in the range $[0, 1]$ which estimates the progress of the operation (&lt;code&gt;n&lt;/code&gt; argument). The callback function might be called from multiple threads concurrently.&lt;/p&gt; &#xA;&lt;p&gt;When returning &lt;code&gt;true&lt;/code&gt; from the callback function, Embree will continue the build operation normally. When returning &lt;code&gt;false&lt;/code&gt;, Embree will cancel the build operation with the &lt;code&gt;RTC_ERROR_CANCELLED&lt;/code&gt; error code. Issuing multiple cancel requests for the same build operation is allowed.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetSceneBuildQuality&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetSceneBuildQuality - sets the build quality for&#xA;  the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetSceneBuildQuality(&#xA;  RTCScene scene,&#xA;  enum RTCBuildQuality quality&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetSceneBuildQuality&lt;/code&gt; function sets the build quality (&lt;code&gt;quality&lt;/code&gt; argument) for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument). Possible values for the build quality are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_LOW&lt;/code&gt;: Create lower quality data structures, e.g.&amp;nbsp;for dynamic scenes. A two-level spatial index structure is built when enabling this mode, which supports fast partial scene updates, and allows for setting a per-geometry build quality through the &lt;code&gt;rtcSetGeometryBuildQuality&lt;/code&gt; function.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_MEDIUM&lt;/code&gt;: Default build quality for most usages. Gives a good compromise between build and render performance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_HIGH&lt;/code&gt;: Create higher quality data structures for final-frame rendering. For certain geometry types this enables a spatial split BVH. When high quality mode is enabled, filter callbacks may be invoked multiple times for the same geometry.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Selecting a higher build quality results in better rendering performance but slower scene commit times. The default build quality for a scene is &lt;code&gt;RTC_BUILD_QUALITY_MEDIUM&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryBuildQuality]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetSceneFlags&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetSceneFlags - sets the flags for the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;enum RTCSceneFlags&#xA;{&#xA;  RTC_SCENE_FLAG_NONE                    = 0,&#xA;  RTC_SCENE_FLAG_DYNAMIC                 = (1 &amp;lt;&amp;lt; 0),&#xA;  RTC_SCENE_FLAG_COMPACT                 = (1 &amp;lt;&amp;lt; 1),&#xA;  RTC_SCENE_FLAG_ROBUST                  = (1 &amp;lt;&amp;lt; 2),&#xA;  RTC_SCENE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS = (1 &amp;lt;&amp;lt; 3)&#xA;};&#xA;&#xA;void rtcSetSceneFlags(RTCScene scene, enum RTCSceneFlags flags);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetSceneFlags&lt;/code&gt; function sets the scene flags (&lt;code&gt;flags&lt;/code&gt; argument) for the specified scene (&lt;code&gt;scene&lt;/code&gt; argument). Possible scene flags are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SCENE_FLAG_NONE&lt;/code&gt;: No flags set.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SCENE_FLAG_DYNAMIC&lt;/code&gt;: Provides better build performance for dynamic scenes (but also higher memory consumption).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SCENE_FLAG_COMPACT&lt;/code&gt;: Uses compact acceleration structures and avoids algorithms that consume much memory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SCENE_FLAG_ROBUST&lt;/code&gt;: Uses acceleration structures that allow for robust traversal, and avoids optimizations that reduce arithmetic accuracy. This mode is typically used for avoiding artifacts caused by rays shooting through edges of neighboring primitives.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SCENE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS&lt;/code&gt;: Enables scene support for filter functions passed as argument to the traversal functions. See Section [rtcInitIntersectArguments] and [rtcInitOccludedArguments] for more details.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Multiple flags can be enabled using an &lt;code&gt;or&lt;/code&gt; operation, e.g.&amp;nbsp;&lt;code&gt;RTC_SCENE_FLAG_COMPACT | RTC_SCENE_FLAG_ROBUST&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetSceneFlags]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetSceneFlags&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetSceneFlags - returns the flags of the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;enum RTCSceneFlags rtcGetSceneFlags(RTCScene scene);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Queries the flags of a scene. This function can be useful when setting individual flags, e.g.&amp;nbsp;to just set the robust mode without changing other flags the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCSceneFlags flags = rtcGetSceneFlags(scene);&#xA;rtcSetSceneFlags(scene, RTC_SCENE_FLAG_ROBUST | flags);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;RTC_SCENE_FLAG_NONE&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetSceneFlags]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetSceneBounds&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetSceneBounds - returns the axis-aligned bounding box of the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCORE_ALIGN(16) RTCBounds&#xA;{&#xA;  float lower_x, lower_y, lower_z, align0;&#xA;  float upper_x, upper_y, upper_z, align1;&#xA;};&#xA;&#xA;void rtcGetSceneBounds(&#xA;  RTCScene scene,&#xA;  struct RTCBounds* bounds_o&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetSceneBounds&lt;/code&gt; function queries the axis-aligned bounding box of the specified scene (&lt;code&gt;scene&lt;/code&gt; argument) and stores that bounding box to the provided destination pointer (&lt;code&gt;bounds_o&lt;/code&gt; argument). The stored bounding box consists of lower and upper bounds for the x, y, and z dimensions as specified by the &lt;code&gt;RTCBounds&lt;/code&gt; structure.&lt;/p&gt; &#xA;&lt;p&gt;The provided destination pointer must be aligned to 16 bytes. The function may be invoked only after committing the scene; otherwise the result is undefined.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetSceneLinearBounds], [rtcCommitScene], [rtcJoinCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetSceneLinearBounds&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetSceneLinearBounds - returns the linear bounds of the scene&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCORE_ALIGN(16) RTCLinearBounds&#xA;{&#xA;  RTCBounds bounds0;&#xA;  RTCBounds bounds1;&#xA;};&#xA;&#xA;void rtcGetSceneLinearBounds(&#xA;  RTCScene scene,&#xA;  struct RTCLinearBounds* bounds_o&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetSceneLinearBounds&lt;/code&gt; function queries the linear bounds of the specified scene (&lt;code&gt;scene&lt;/code&gt; argument) and stores them to the provided destination pointer (&lt;code&gt;bounds_o&lt;/code&gt; argument). The stored linear bounds consist of bounding boxes for time 0 (&lt;code&gt;bounds0&lt;/code&gt; member) and time 1 (&lt;code&gt;bounds1&lt;/code&gt; member) as specified by the &lt;code&gt;RTCLinearBounds&lt;/code&gt; structure. Linearly interpolating these bounds to a specific time &lt;code&gt;t&lt;/code&gt; yields bounds for the geometry at that time.&lt;/p&gt; &#xA;&lt;p&gt;The provided destination pointer must be aligned to 16 bytes. The function may be called only after committing the scene, otherwise the result is undefined.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetSceneBounds], [rtcCommitScene], [rtcJoinCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcNewGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewGeometry - creates a new geometry object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;enum RTCGeometryType&#xA;{&#xA; RTC_GEOMETRY_TYPE_TRIANGLE,&#xA; RTC_GEOMETRY_TYPE_QUAD,&#xA; RTC_GEOMETRY_TYPE_SUBDIVISION,&#xA; RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE,&#xA; RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE,&#xA; RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE,&#xA; RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE,&#xA; RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE,&#xA; RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE,&#xA; RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE,&#xA; RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE,&#xA; RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE,&#xA; RTC_GEOMETRY_TYPE_CONE_LINEAR_CURVE,&#xA; RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE,&#xA; RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE,&#xA; RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE,&#xA; RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE,&#xA; RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE,&#xA; RTC_GEOMETRY_TYPE_GRID,&#xA; RTC_GEOMETRY_TYPE_SPHERE_POINT,&#xA; RTC_GEOMETRY_TYPE_DISC_POINT,&#xA; RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT,&#xA; RTC_GEOMETRY_TYPE_USER,&#xA; RTC_GEOMETRY_TYPE_INSTANCE&#xA;};&#xA;&#xA;RTCGeometry rtcNewGeometry(&#xA;  RTCDevice device,&#xA;  enum RTCGeometryType type&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Geometries are objects that represent an array of primitives of the same type. The &lt;code&gt;rtcNewGeometry&lt;/code&gt; function creates a new geometry of specified type (&lt;code&gt;type&lt;/code&gt; argument) bound to the specified device (&lt;code&gt;device&lt;/code&gt; argument) and returns a handle to this geometry. The geometry object is reference counted with an initial reference count of 1. The geometry handle can be released using the &lt;code&gt;rtcReleaseGeometry&lt;/code&gt; API call.&lt;/p&gt; &#xA;&lt;p&gt;Supported geometry types are triangle meshes (&lt;code&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/code&gt; type), quad meshes (triangle pairs) (&lt;code&gt;RTC_GEOMETRY_TYPE_QUAD&lt;/code&gt; type), Catmull-Clark subdivision surfaces (&lt;code&gt;RTC_GEOMETRY_TYPE_SUBDIVISION&lt;/code&gt; type), curve geometries with different bases (&lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE&lt;/code&gt;,&lt;br&gt; &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE&lt;/code&gt;,&lt;br&gt; &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_CONE_LINEAR_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE&lt;/code&gt; types) grid meshes (&lt;code&gt;RTC_GEOMETRY_TYPE_GRID&lt;/code&gt;), point geometries (&lt;code&gt;RTC_GEOMETRY_TYPE_SPHERE_POINT&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_DISC_POINT&lt;/code&gt;, &lt;code&gt;RTC_TYPE_ORIENTED_DISC_POINT&lt;/code&gt;), user-defined geometries (&lt;code&gt;RTC_GEOMETRY_TYPE_USER&lt;/code&gt;), and instances (&lt;code&gt;RTC_GEOMETRY_TYPE_INSTANCE&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The types &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE&lt;/code&gt;, and &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE&lt;/code&gt; will treat the curve as a sweep surface of a varying-radius circle swept tangentially along the curve. The types &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE&lt;/code&gt;, and &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE&lt;/code&gt; use ray-facing ribbons as a faster-to-intersect approximation.&lt;/p&gt; &#xA;&lt;p&gt;After construction, geometries are enabled by default and not attached to any scene. Geometries can be disabled (&lt;code&gt;rtcDisableGeometry&lt;/code&gt; call), and enabled again (&lt;code&gt;rtcEnableGeometry&lt;/code&gt; call). A geometry can be attached to multiple scenes using the &lt;code&gt;rtcAttachGeometry&lt;/code&gt; call (or &lt;code&gt;rtcAttachGeometryByID&lt;/code&gt; call), and detached using the &lt;code&gt;rtcDetachGeometry&lt;/code&gt; call. During attachment, a geometry ID is assigned to the geometry (or assigned by the user when using the &lt;code&gt;rtcAttachGeometryByID&lt;/code&gt; call), which uniquely identifies the geometry inside that scene. This identifier is returned when primitives of the geometry are hit in later ray queries for the scene.&lt;/p&gt; &#xA;&lt;p&gt;Geometries can also be modified, including their vertex and index buffers. After modifying a buffer, &lt;code&gt;rtcUpdateGeometryBuffer&lt;/code&gt; must be called to notify that the buffer got modified.&lt;/p&gt; &#xA;&lt;p&gt;The application can use the &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; function to set a user data pointer to its own geometry representation, and later read out this pointer using the &lt;code&gt;rtcGetGeometryUserData&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;After setting up the geometry or modifying it, &lt;code&gt;rtcCommitGeometry&lt;/code&gt; must be called to finish the geometry setup. After committing the geometry, vertex data interpolation can be performed using the &lt;code&gt;rtcInterpolate&lt;/code&gt; and &lt;code&gt;rtcInterpolateN&lt;/code&gt; functions.&lt;/p&gt; &#xA;&lt;p&gt;A build quality can be specified for a geometry using the &lt;code&gt;rtcSetGeometryBuildQuality&lt;/code&gt; function, to balance between acceleration structure build performance and ray query performance. The build quality per geometry will be used if a two-level acceleration structure is built internally, which is the case if the &lt;code&gt;RTC_BUILD_QUALITY_LOW&lt;/code&gt; is set as the scene build quality. See Section [rtcSetSceneBuildQuality] for more details.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcEnableGeometry], [rtcDisableGeometry], [rtcAttachGeometry], [rtcAttachGeometryByID], [rtcUpdateGeometryBuffer], [rtcSetGeometryUserData], [rtcGetGeometryUserData], [rtcCommitGeometry], [rtcInterpolate], [rtcInterpolateN], [rtcSetGeometryBuildQuality], [rtcSetSceneBuildQuality], [RTC_GEOMETRY_TYPE_TRIANGLE], [RTC_GEOMETRY_TYPE_QUAD], [RTC_GEOMETRY_TYPE_SUBDIVISION], [RTC_GEOMETRY_TYPE_CURVE], [RTC_GEOMETRY_TYPE_GRID], [RTC_GEOMETRY_TYPE_POINT], [RTC_GEOMETRY_TYPE_USER], [RTC_GEOMETRY_TYPE_INSTANCE]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_TRIANGLE - triangle geometry type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry geometry =&#xA;  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_TRIANGLE);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Triangle meshes are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function call. The triangle indices can be specified by setting an index buffer (&lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt; type) and the triangle vertices by setting a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; type). See &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; and &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; for more details on how to set buffers. The index buffer must contain an array of three 32-bit indices per triangle (&lt;code&gt;RTC_FORMAT_UINT3&lt;/code&gt; format) and the number of primitives is inferred from the size of that buffer. The vertex buffer must contain an array of single precision &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; floating point coordinates (&lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; format), and the number of vertices are inferred from the size of that buffer. The vertex buffer can be at most 16 GB large.&lt;/p&gt; &#xA;&lt;p&gt;The parametrization of a triangle uses the first vertex &lt;code&gt;p0&lt;/code&gt; as base point, the vector &lt;code&gt;p1 - p0&lt;/code&gt; as u-direction and the vector &lt;code&gt;p2 - p0&lt;/code&gt; as v-direction. Thus vertex attributes &lt;code&gt;t0,t1,t2&lt;/code&gt; can be linearly interpolated over the triangle the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t_uv = (1-u-v)*t0 + u*t1 + v*t2&#xA;     = t0 + u*(t1-t0) + v*(t2-t0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A triangle whose vertices are laid out counter-clockwise has its geometry normal pointing upwards outside the front face, like illustrated in the following picture:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/triangle_uv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers have to have the same stride and size.&lt;/p&gt; &#xA;&lt;p&gt;Also see tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#triangle-geometry&#34;&gt;Triangle Geometry&lt;/a&gt; for an example of how to create triangle meshes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that be get queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_QUAD&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_QUAD - quad geometry type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry geometry =&#xA;  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_QUAD);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Quad meshes are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_QUAD&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function call. The quad indices can be specified by setting an index buffer (&lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt; type) and the quad vertices by setting a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; type). See &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; and &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; for more details on how to set buffers. The index buffer contains an array of four 32-bit indices per quad (&lt;code&gt;RTC_FORMAT_UINT4&lt;/code&gt; format), and the number of primitives is inferred from the size of that buffer. The vertex buffer contains an array of single precision &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; floating point coordinates (&lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; format), and the number of vertices is inferred from the size of that buffer. The vertex buffer can be at most 16 GB large.&lt;/p&gt; &#xA;&lt;p&gt;A quad is internally handled as a pair of two triangles &lt;code&gt;v0,v1,v3&lt;/code&gt; and &lt;code&gt;v2,v3,v1&lt;/code&gt;, with the &lt;code&gt;u&#39;&lt;/code&gt;/&lt;code&gt;v&#39;&lt;/code&gt; coordinates of the second triangle corrected by &lt;code&gt;u = 1-u&#39;&lt;/code&gt; and &lt;code&gt;v = 1-v&#39;&lt;/code&gt; to produce a quad parametrization where &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are in the range 0 to 1. Thus the parametrization of a quad uses the first vertex &lt;code&gt;p0&lt;/code&gt; as base point, and the vector &lt;code&gt;p1 - p0&lt;/code&gt; as &lt;code&gt;u&lt;/code&gt;-direction, and &lt;code&gt;p3 - p0&lt;/code&gt; as v-direction. Thus vertex attributes &lt;code&gt;t0,t1,t2,t3&lt;/code&gt; can be bilinearly interpolated over the quadrilateral the following way:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;t_uv = (1-v)((1-u)*t0 + u*t1) + v*((1-u)*t3 + u*t2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Mixed triangle/quad meshes are supported by encoding a triangle as a quad, which can be achieved by replicating the last triangle vertex (&lt;code&gt;v0,v1,v2&lt;/code&gt; -&amp;gt; &lt;code&gt;v0,v1,v2,v2&lt;/code&gt;). This way the second triangle is a line (which can never get hit), and the parametrization of the first triangle is compatible with the standard triangle parametrization.&lt;/p&gt; &#xA;&lt;p&gt;A quad whose vertices are laid out counter-clockwise has its geometry normal pointing upwards outside the front face, like illustrated in the following picture.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/quad_uv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_GRID&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_GRID - grid geometry type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry geometry =&#xA;  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_GRID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Grid meshes are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_GRID&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function call, and contain an array of grid primitives. This array of grids can be specified by setting up a grid buffer (with &lt;code&gt;RTC_BUFFER_TYPE_GRID&lt;/code&gt; type and &lt;code&gt;RTC_FORMAT_GRID&lt;/code&gt; format) and the grid mesh vertices by setting a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; type). See &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; and &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; for more details on how to set buffers. The number of grid primitives in the grid mesh is inferred from the size of the grid buffer.&lt;/p&gt; &#xA;&lt;p&gt;The vertex buffer contains an array of single precision &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; floating point coordinates (&lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; format), and the number of vertices is inferred from the size of that buffer.&lt;/p&gt; &#xA;&lt;p&gt;Each grid in the grid buffer is of the type &lt;code&gt;RTCGrid&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct RTCGrid&#xA;{&#xA;  unsigned int startVertexID;&#xA;  unsigned int stride;&#xA;  unsigned short width,height; &#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCGrid&lt;/code&gt; structure describes a 2D grid of vertices (with respect to the vertex buffer of the grid mesh). The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; members specify the number of vertices in u and v direction, e.g.&amp;nbsp;setting both &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; to 3 sets up a 3×3 vertex grid. The maximum allowed &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is 32767. The &lt;code&gt;startVertexID&lt;/code&gt; specifies the ID of the top-left vertex in the vertex grid, while the &lt;code&gt;stride&lt;/code&gt; parameter specifies a stride (in number of vertices) used to step to the next row.&lt;/p&gt; &#xA;&lt;p&gt;A vertex grid of dimensions &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is treated as a &lt;code&gt;(width-1)&lt;/code&gt; x &lt;code&gt;(height-1)&lt;/code&gt; grid of &lt;code&gt;quads&lt;/code&gt; (triangle-pairs), with the same shared edge handling as for regular quad meshes. However, the &lt;code&gt;u&lt;/code&gt;/&lt;code&gt;v&lt;/code&gt; coordinates have the uniform range &lt;code&gt;[0..1]&lt;/code&gt; for an entire vertex grid. The &lt;code&gt;u&lt;/code&gt; direction follows the &lt;code&gt;width&lt;/code&gt; of the grid while the &lt;code&gt;v&lt;/code&gt; direction the &lt;code&gt;height&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_SUBDIVISION&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_SUBDIVISION - subdivision geometry type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry geometry =&#xA;  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_SUBDIVISION);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Catmull-Clark subdivision meshes are supported, including support for edge creases, vertex creases, holes, non-manifold geometry, and face-varying interpolation. The number of vertices per face can be in the range of 3 to 15 vertices (triangles, quadrilateral, pentagons, etc).&lt;/p&gt; &#xA;&lt;p&gt;Subdivision meshes are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_SUBDIVISION&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function. Various buffers need to be set by the application to set up the subdivision mesh. See &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; and &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; for more details on how to set buffers. The face buffer (&lt;code&gt;RTC_BUFFER_TYPE_FACE&lt;/code&gt; type and &lt;code&gt;RTC_FORMAT_UINT&lt;/code&gt; format) contains the number of edges/indices of each face (3 to 15), and the number of faces is inferred from the size of this buffer. The index buffer (&lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt; type) contains multiple (3 to 15) 32-bit vertex indices (&lt;code&gt;RTC_FORMAT_UINT&lt;/code&gt; format) for each face, and the number of edges is inferred from the size of this buffer. The vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; type) stores an array of single precision &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; floating point coordinates (&lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; format), and the number of vertices is inferred from the size of this buffer.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, the application may set additional index buffers using different buffer slots if multiple topologies are required for face-varying interpolation. The standard vertex buffers (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt;) are always bound to the geometry topology (topology 0) thus use &lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt; with buffer slot 0. User vertex data interpolation may use different topologies as described later.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, the application can set up the hole buffer (&lt;code&gt;RTC_BUFFER_TYPE_HOLE&lt;/code&gt;) which contains an array of 32-bit indices (&lt;code&gt;RTC_FORMAT_UINT&lt;/code&gt; format) of faces that should be considered non-existing in all topologies. The number of holes is inferred from the size of this buffer.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, the application can fill the level buffer (&lt;code&gt;RTC_BUFFER_TYPE_LEVEL&lt;/code&gt;) with a tessellation rate for each of the edges of each face. This buffer must have the same size as the index buffer. The tessellation level is a positive floating point value (&lt;code&gt;RTC_FORMAT_FLOAT&lt;/code&gt; format) that specifies how many quads along the edge should be generated during tessellation. If no level buffer is specified, a level of 1 is used. The maximally supported edge level is 4096, and larger levels are clamped to that value. Note that edges may be shared between (typically 2) faces. To guarantee a watertight tessellation, the level of these shared edges should be identical. A uniform tessellation rate for an entire subdivision mesh can be set by using the &lt;code&gt;rtcSetGeometryTessellationRate&lt;/code&gt; function. The existence of a level buffer has precedence over the uniform tessellation rate.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, the application can fill the sparse edge crease buffers to make edges appear sharper. The edge crease index buffer (&lt;code&gt;RTC_BUFFER_TYPE_EDGE_CREASE_INDEX&lt;/code&gt;) contains an array of pairs of 32-bit vertex indices (&lt;code&gt;RTC_FORMAT_UINT2&lt;/code&gt; format) that specify unoriented edges in the geometry topology. The edge crease weight buffer (&lt;code&gt;RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT&lt;/code&gt;) stores for each of these crease edges a positive floating point weight (&lt;code&gt;RTC_FORMAT_FLOAT&lt;/code&gt; format). The number of edge creases is inferred from the size of these buffers, which has to be identical. The larger a weight, the sharper the edge. Specifying a weight of infinity is supported and marks an edge as infinitely sharp. Storing an edge multiple times with the same crease weight is allowed, but has lower performance. Storing an edge multiple times with different crease weights results in undefined behavior. For a stored edge (i,j), the reverse direction edges (j,i) do not have to be stored, as both are considered the same unoriented edge. Edge crease features are shared between all topologies.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, the application can fill the sparse vertex crease buffers to make vertices appear sharper. The vertex crease index buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX&lt;/code&gt;), contains an array of 32-bit vertex indices (&lt;code&gt;RTC_FORMAT_UINT&lt;/code&gt; format) to specify a set of vertices from the geometry topology. The vertex crease weight buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT&lt;/code&gt;) specifies for each of these vertices a positive floating point weight (&lt;code&gt;RTC_FORMAT_FLOAT&lt;/code&gt; format). The number of vertex creases is inferred from the size of these buffers, and has to be identical. The larger a weight, the sharper the vertex. Specifying a weight of infinity is supported and makes the vertex infinitely sharp. Storing a vertex multiple times with the same crease weight is allowed, but has lower performance. Storing a vertex multiple times with different crease weights results in undefined behavior. Vertex crease features are shared between all topologies.&lt;/p&gt; &#xA;&lt;p&gt;Subdivision modes can be used to force linear interpolation for parts of the subdivision mesh; see &lt;code&gt;rtcSetGeometrySubdivisionMode&lt;/code&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers have to have the same stride and size.&lt;/p&gt; &#xA;&lt;p&gt;Also see tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#subdivision-geometry&#34;&gt;Subdivision Geometry&lt;/a&gt; for an example of how to create subdivision surfaces.&lt;/p&gt; &#xA;&lt;h4&gt;Parametrization&lt;/h4&gt; &#xA;&lt;p&gt;The parametrization for subdivision faces is different for quadrilaterals and non-quadrilateral faces.&lt;/p&gt; &#xA;&lt;p&gt;The parametrization of a quadrilateral face uses the first vertex &lt;code&gt;p0&lt;/code&gt; as base point, and the vector &lt;code&gt;p1 - p0&lt;/code&gt; as u-direction and &lt;code&gt;p3 - p0&lt;/code&gt; as v-direction.&lt;/p&gt; &#xA;&lt;p&gt;The parametrization for all other face types (with number of vertices not equal 4), have a special parametrization where the subpatch ID &lt;code&gt;n&lt;/code&gt; (of the &lt;code&gt;n&lt;/code&gt;-th quadrilateral that would be obtained by a single subdivision step) and the local hit location inside this quadrilateral are encoded in the UV coordinates. The following code extracts the sub-patch ID &lt;code&gt;i&lt;/code&gt; and local UVs of this subpatch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;unsigned int l = floorf(0.5f*U);&#xA;unsigned int h = floorf(0.5f*V);&#xA;unsigned int i = 4*h+l;&#xA;float u = 2.0f*fracf(0.5f*U)-0.5f;&#xA;float v = 2.0f*fracf(0.5f*V)-0.5f;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This encoding allows local subpatch UVs to be in the range &lt;code&gt;[-0.5,1.5[&lt;/code&gt; thus negative subpatch UVs can be passed to &lt;code&gt;rtcInterpolate&lt;/code&gt; to sample subpatches slightly out of bounds. This can be useful to calculate derivatives using finite differences if required. The encoding further has the property that one can just move the value &lt;code&gt;u&lt;/code&gt; (or &lt;code&gt;v&lt;/code&gt;) on a subpatch by adding &lt;code&gt;du&lt;/code&gt; (or &lt;code&gt;dv&lt;/code&gt;) to the special UV encoding as long as it does not fall out of the &lt;code&gt;[-0.5,1.5[&lt;/code&gt; range.&lt;/p&gt; &#xA;&lt;p&gt;To smoothly interpolate vertex attributes over the subdivision surface we recommend using the &lt;code&gt;rtcInterpolate&lt;/code&gt; function, which will apply the standard subdivision rules for interpolation and automatically takes care of the special UV encoding for non-quadrilaterals.&lt;/p&gt; &#xA;&lt;h4&gt;Face-Varying Data&lt;/h4&gt; &#xA;&lt;p&gt;Face-varying interpolation is supported through multiple topologies per subdivision mesh and binding such topologies to vertex attribute buffers to interpolate. This way, texture coordinates may use a different topology with additional boundaries to construct separate UV regions inside one subdivision mesh.&lt;/p&gt; &#xA;&lt;p&gt;Each such topology &lt;code&gt;i&lt;/code&gt; has a separate index buffer (specified using &lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt; with buffer slot &lt;code&gt;i&lt;/code&gt;) and separate subdivision mode that can be set using &lt;code&gt;rtcSetGeometrySubdivisionMode&lt;/code&gt;. A vertex attribute buffer &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt; bound to a buffer slot &lt;code&gt;j&lt;/code&gt; can be assigned to use a topology for interpolation using the &lt;code&gt;rtcSetGeometryVertexAttributeTopology&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;The face buffer (&lt;code&gt;RTC_BUFFER_TYPE_FACE&lt;/code&gt; type) is shared between all topologies, which means that the &lt;code&gt;n&lt;/code&gt;-th primitive always has the same number of vertices (e.g.&amp;nbsp;being a triangle or a quad) for each topology. However, the indices of the topologies themselves may be different.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_CURVE&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE -&#xA;  flat curve geometry with linear basis&#xA;&#xA;RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE -&#xA;  flat curve geometry with cubic Bézier basis&#xA;&#xA;RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE - &#xA;  flat curve geometry with cubic B-spline basis&#xA;&#xA;RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE - &#xA;  flat curve geometry with cubic Hermite basis&#xA;&#xA;RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE - &#xA;  flat curve geometry with Catmull-Rom basis&#xA;&#xA;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE -&#xA;  flat normal oriented curve geometry with cubic Bézier basis&#xA;&#xA;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE - &#xA;  flat normal oriented curve geometry with cubic B-spline basis&#xA;&#xA;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE - &#xA;  flat normal oriented curve geometry with cubic Hermite basis&#xA;&#xA;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE - &#xA;  flat normal oriented curve geometry with Catmull-Rom basis&#xA;&#xA;RTC_GEOMETRY_TYPE_CONE_LINEAR_CURVE -&#xA;  capped cone curve geometry with linear basis - discontinuous at edge boundaries&#xA;&#xA;RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE -&#xA;  capped cone curve geometry with linear basis and spherical ending&#xA;&#xA;RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE -&#xA;  swept surface curve geometry with cubic Bézier basis&#xA;&#xA;RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE -&#xA;  swept surface curve geometry with cubic B-spline basis&#xA;&#xA;RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE -&#xA;  swept surface curve geometry with cubic Hermite basis&#xA;&#xA;RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE -&#xA;  swept surface curve geometry with Catmull-Rom basis&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_CONE_LINEAR_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Curves with per vertex radii are supported with linear, cubic Bézier, cubic B-spline, and cubic Hermite bases. Such curve geometries are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_BSPLINE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_HERMITE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_FLAT_CATMULL_ROM_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_CONE_LINEAR_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE&lt;/code&gt;, or &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function. The curve indices can be specified through an index buffer (&lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt;) and the curve vertices through a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt;). For the Hermite basis a tangent buffer (&lt;code&gt;RTC_BUFFER_TYPE_TANGENT&lt;/code&gt;), normal oriented curves a normal buffer (&lt;code&gt;RTC_BUFFER_TYPE_NORMAL&lt;/code&gt;), and for normal oriented Hermite curves a normal derivative buffer (&lt;code&gt;RTC_BUFFER_TYPE_NORMAL_DERIVATIVE&lt;/code&gt;) has to get specified additionally. See &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; and &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; for more details on how to set buffers.&lt;/p&gt; &#xA;&lt;p&gt;The index buffer contains an array of 32-bit indices (&lt;code&gt;RTC_FORMAT_UINT&lt;/code&gt; format), each pointing to the first control vertex in the vertex buffer, but also to the first tangent in the tangent buffer, and first normal in the normal buffer if these buffers are present.&lt;/p&gt; &#xA;&lt;p&gt;The vertex buffer stores each control vertex in the form of a single precision position and radius stored in (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;) order in memory (&lt;code&gt;RTC_FORMAT_FLOAT4&lt;/code&gt; format). The number of vertices is inferred from the size of this buffer. The radii may be smaller than zero but the interpolated radii should always be greater or equal to zero. Similarly, the tangent buffer stores the derivative of each control vertex (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt; order and &lt;code&gt;RTC_FORMAT_FLOAT4&lt;/code&gt; format) and the normal buffer stores a single precision normal per control vertex (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; order and &lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; format).&lt;/p&gt; &#xA;&lt;h5&gt;Linear Basis&lt;/h5&gt; &#xA;&lt;p&gt;For the linear basis the indices point to the first of 2 consecutive control points in the vertex buffer. The first control point is the start and the second control point the end of the line segment. When constructing hair strands in this basis, the end-point can be shared with the start of the next line segment.&lt;/p&gt; &#xA;&lt;p&gt;For the linear basis the user optionally can provide a flags buffer of type &lt;code&gt;RTC_BUFFER_TYPE_FLAGS&lt;/code&gt; which contains bytes that encode if the left neighbor segment (&lt;code&gt;RTC_CURVE_FLAG_NEIGHBOR_LEFT&lt;/code&gt; flag) and/or right neighbor segment (&lt;code&gt;RTC_CURVE_FLAG_NEIGHBOR_RIGHT&lt;/code&gt; flags) exist (see [RTCCurveFlags]). If this buffer is not set, than the left/right neighbor bits are automatically calculated base on the index buffer (left segment exists if segment(id-1)+1 == segment(id) and right segment exists if segment(id+1)-1 == segment(id)).&lt;/p&gt; &#xA;&lt;p&gt;A left neighbor segment is assumed to end at the start vertex of the current segment, and to start at the previous vertex in the vertex buffer. Similarly, the right neighbor segment is assumed to start at the end vertex of the current segment, and to end at the next vertex in the vertex buffer.&lt;/p&gt; &#xA;&lt;p&gt;Only when the left and right bits are properly specified the current segment can properly attach to the left and/or right neighbor, otherwise the touching area may not get rendered properly.&lt;/p&gt; &#xA;&lt;h5&gt;Bézier Basis&lt;/h5&gt; &#xA;&lt;p&gt;For the cubic Bézier basis the indices point to the first of 4 consecutive control points in the vertex buffer. These control points use the cubic Bézier basis, where the first control point represents the start point of the curve, and the 4th control point the end point of the curve. The Bézier basis is interpolating, thus the curve does go exactly through the first and fourth control vertex.&lt;/p&gt; &#xA;&lt;h5&gt;B-spline Basis&lt;/h5&gt; &#xA;&lt;p&gt;For the cubic B-spline basis the indices point to the first of 4 consecutive control points in the vertex buffer. These control points make up a cardinal cubic B-spline (implicit equidistant knot vector). This basis is not interpolating, thus the curve does in general not go through any of the control points directly. A big advantage of this basis is that 3 control points can be shared for two continuous neighboring curve segments, e.g.&amp;nbsp;the curves (p0,p1,p2,p3) and (p1,p2,p3,p4) are C1 continuous. This feature makes this basis a good choice to construct continuous multi-segment curves, as memory consumption can be kept minimal.&lt;/p&gt; &#xA;&lt;h5&gt;Hermite Basis&lt;/h5&gt; &#xA;&lt;p&gt;For the cubic Hermite basis the indices point to the first of 2 consecutive points in the vertex buffer, and the first of 2 consecutive tangents in the tangent buffer. These two points and two tangents make up a cubic Hermite curve. This basis is interpolating, thus does exactly go through the first and second control point, and the first order derivative at the begin and end matches exactly the value specified in the tangent buffer. When connecting two segments continuously, the end point and tangent of the previous segment can be shared. Different versions of Catmull-Rom splines can be easily constructed using the Hermite basis, by calculating a proper tangent buffer from the control points.&lt;/p&gt; &#xA;&lt;h5&gt;Catmull-Rom Basis&lt;/h5&gt; &#xA;&lt;p&gt;For the Catmull-Rom basis the indices point to the first of 4 consecutive control points in the vertex buffer. This basis goes through p1 and p2, with tangents (p2-p0)/2 and (p3-p1)/2.&lt;/p&gt; &#xA;&lt;h5&gt;Flat Curves&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_GEOMETRY_TYPE_FLAT_*&lt;/code&gt; flat mode is a fast mode designed to render distant hair. In this mode the curve is rendered as a connected sequence of ray facing quads. Individual quads are considered to have subpixel size, and zooming onto the curve might show geometric artifacts. The number of quads to subdivide into can be specified through the &lt;code&gt;rtcSetGeometryTessellationRate&lt;/code&gt; function. By default the tessellation rate is 4.&lt;/p&gt; &#xA;&lt;h5&gt;Normal Oriented Curves&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_*&lt;/code&gt; mode is a mode designed to render blades of grass. In this mode a vertex spline has to get specified as for the previous modes, but additionally a normal spline is required. If the Hermite basis is used, the &lt;code&gt;RTC_BUFFER_TYPE_NORMAL&lt;/code&gt; and &lt;code&gt;RTC_BUFFER_TYPE_NORMAL_DERIVATIVE&lt;/code&gt; buffers have both to be set.&lt;/p&gt; &#xA;&lt;p&gt;The curve is rendered as a flat band whose center approximately follows the provided vertex spline, whose half width approximately follows the provided radius spline, and whose normal orientation approximately follows the provided normal spline.&lt;/p&gt; &#xA;&lt;p&gt;To intersect the normal oriented curve, we perform a newton-raphson style intersection of a ray with a tensor product surface of a linear basis (perpendicular to the curve) and cubic Bézier basis (along the curve). We use a guide curve and its derivatives to construct the control points of that surface. The guide curve is defined by a sweep surface defined by sweeping a line centered at the vertex spline location along the curve. At each parameter value the half width of the line matches the radius spline, and the direction matches the cross product of the normal from the normal spline and tangent of the vertex spline. Note that this construction does not work when the provided normals are parallel to the curve direction. For this reason the provided normals should best be kept as perpendicular to the curve direction as possible. We further assume second order derivatives of the center curve to be zero for this construction, as otherwise very large curvatures occurring in corner cases, can thicken the constructed curve significantly.&lt;/p&gt; &#xA;&lt;h5&gt;Round Curves&lt;/h5&gt; &#xA;&lt;p&gt;In the &lt;code&gt;RTC_GEOMETRY_TYPE_ROUND_*&lt;/code&gt; round mode, a real geometric surface is rendered for the curve, which is more expensive but allows closeup views.&lt;/p&gt; &#xA;&lt;p&gt;For the linear basis the round mode renders a cone that tangentially touches a start-sphere and end-sphere. The start sphere is rendered when no previous segments is indicated by the neighbor bits. The end sphere is always rendered but parts that lie inside the next segment are clipped away (if that next segment exists). This way a curve is closed on both ends and the interior will render properly as long as only neighboring segments penetrate into a segment. For this to work properly it is important that the flags buffer is properly populated with neighbor information.&lt;/p&gt; &#xA;&lt;p&gt;For the cubic polynomial bases, the round mode renders a sweep surface by sweeping a varying radius circle tangential along the curve. As a limitation, the radius of the curve has to be smaller than the curvature radius of the curve at each location on the curve.&lt;/p&gt; &#xA;&lt;p&gt;The intersection with the curve segment stores the parametric hit location along the curve segment as u-coordinate (range 0 to +1).&lt;/p&gt; &#xA;&lt;p&gt;For flat curves, the v-coordinate is set to the normalized distance in the range -1 to +1. For normal oriented curves the v-coordinate is in the range 0 to 1. For the linear basis and in round mode the v-coordinate is set to zero.&lt;/p&gt; &#xA;&lt;p&gt;In flat mode, the geometry normal &lt;code&gt;Ng&lt;/code&gt; is set to the tangent of the curve at the hit location. In round mode and for normal oriented curves, the geometry normal &lt;code&gt;Ng&lt;/code&gt; is set to the non-normalized geometric normal of the surface.&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size. For the Hermite basis also a tangent buffer has to be set for each time step and for normal oriented curves a normal buffer has to get specified for each time step.&lt;/p&gt; &#xA;&lt;p&gt;Also see tutorials &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#hair&#34;&gt;Hair&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#b%C3%A9zier-curves&#34;&gt;Curves&lt;/a&gt; for examples of how to create and use curve geometries.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [RTCCurveFlags]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_POINT&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_SPHERE_POINT -&#xA;  point geometry spheres&#xA;&#xA;RTC_GEOMETRY_TYPE_DISC_POINT -&#xA;  point geometry with ray-oriented discs&#xA;&#xA;RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT -&#xA;  point geometry with normal-oriented discs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_SPHERE_POINT);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_DISC_POINT);&#xA;rtcNewGeometry(device, RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Points with per vertex radii are supported with sphere, ray-oriented discs, and normal-oriented discs geometric representations. Such point geometries are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_SPHERE_POINT&lt;/code&gt;, &lt;code&gt;RTC_GEOMETRY_TYPE_DISC_POINT&lt;/code&gt;, or &lt;code&gt;RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function. The point vertices can be specified t through a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt;). For the normal oriented discs a normal buffer (&lt;code&gt;RTC_BUFFER_TYPE_NORMAL&lt;/code&gt;) has to get specified additionally. See &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; and &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; for more details on how to set buffers.&lt;/p&gt; &#xA;&lt;p&gt;The vertex buffer stores each control vertex in the form of a single precision position and radius stored in (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;) order in memory (&lt;code&gt;RTC_FORMAT_FLOAT4&lt;/code&gt; format). The number of vertices is inferred from the size of this buffer. Similarly, the normal buffer stores a single precision normal per control vertex (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; order and &lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; format).&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;code&gt;RTC_GEOMETRY_TYPE_SPHERE_POINT&lt;/code&gt; mode, a real geometric surface is rendered for the curve, which is more expensive but allows closeup views.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_GEOMETRY_TYPE_DISC_POINT&lt;/code&gt; flat mode is a fast mode designed to render distant points. In this mode the point is rendered as a ray facing disc.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT&lt;/code&gt; mode is a mode designed as a midpoint geometrically between ray facing discs and spheres. In this mode the point is rendered as a normal oriented disc.&lt;/p&gt; &#xA;&lt;p&gt;For all point types, only the hit distance and geometry normal is returned as hit information, u and v are set to zero.&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; call. Then a vertex buffer for each time step can be set using different buffer slots, and all these buffers must have the same stride and size.&lt;/p&gt; &#xA;&lt;p&gt;Also see tutorial [Points] for an example of how to create and use point geometries.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_USER&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_USER - user geometry type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry geometry =&#xA;  rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;User-defined geometries contain a number of user-defined primitives, just like triangle meshes contain multiple triangles. The shape of the user-defined primitives is specified through registered callback functions, which enable extending Embree with arbitrary types of primitives.&lt;/p&gt; &#xA;&lt;p&gt;User-defined geometries are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_USER&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function call. One has to set the number of primitives (see &lt;code&gt;rtcSetGeometryUserPrimitiveCount&lt;/code&gt;), a user data pointer (see &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt;), a bounding function closure (see &lt;code&gt;rtcSetGeometryBoundsFunction&lt;/code&gt;), as well as user-defined intersect (see &lt;code&gt;rtcSetGeometryIntersectFunction&lt;/code&gt;) and occluded (see &lt;code&gt;rtcSetGeometryOccludedFunction&lt;/code&gt;) callback functions. The bounding function is used to query the bounds of all time steps of a user primitive, while the intersect and occluded callback functions are called to intersect the primitive with a ray. The user data pointer is passed to each callback invocation and can be used to point to the application&#39;s representation of the user geometry.&lt;/p&gt; &#xA;&lt;p&gt;The creation of a user geometry typically looks the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCGeometry geometry = rtcNewGeometry(device, RTC_GEOMETRY_TYPE_USER);&#xA;rtcSetGeometryUserPrimitiveCount(geometry, numPrimitives);&#xA;rtcSetGeometryUserData(geometry, userGeometryRepresentation);&#xA;rtcSetGeometryBoundsFunction(geometry, boundsFunction);&#xA;rtcSetGeometryIntersectFunction(geometry, intersectFunction);&#xA;rtcSetGeometryOccludedFunction(geometry, occludedFunction);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please have a look at the &lt;code&gt;rtcSetGeometryBoundsFunction&lt;/code&gt;, &lt;code&gt;rtcSetGeometryIntersectFunction&lt;/code&gt;, and &lt;code&gt;rtcSetGeometryOccludedFunction&lt;/code&gt; functions on the implementation of the callback functions.&lt;/p&gt; &#xA;&lt;p&gt;Primitives of a user geometry are ignored during rendering when their bounds are empty, thus bounds have lower&amp;gt;upper in at least one dimension.&lt;/p&gt; &#xA;&lt;p&gt;See tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#user-geometry&#34;&gt;User Geometry&lt;/a&gt; for an example of how to use the user-defined geometries.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcSetGeometryUserPrimitiveCount], [rtcSetGeometryUserData], [rtcSetGeometryBoundsFunction], [rtcSetGeometryIntersectFunction], [rtcSetGeometryOccludedFunction]&lt;/p&gt; &#xA;&lt;h2&gt;RTC_GEOMETRY_TYPE_INSTANCE&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_GEOMETRY_TYPE_INSTANCE - instance geometry type&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCGeometry geometry =&#xA;   rtcNewGeometry(device, RTC_GEOMETRY_TYPE_INSTANCE);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Embree supports instancing of scenes using affine transformations (3×3 matrix plus translation). As the instanced scene is stored only a single time, even if instanced to multiple locations, this feature can be used to create very complex scenes with small memory footprint.&lt;/p&gt; &#xA;&lt;p&gt;Embree supports both single-level instancing and multi-level instancing. The maximum instance nesting depth is &lt;code&gt;RTC_MAX_INSTANCE_LEVEL_COUNT&lt;/code&gt;; it can be configured at compile-time using the constant &lt;code&gt;EMBREE_MAX_INSTANCE_LEVEL_COUNT&lt;/code&gt;. Users should adapt this constant to their needs: instances nested any deeper are silently ignored in release mode, and cause assertions in debug mode.&lt;/p&gt; &#xA;&lt;p&gt;Instances are created by passing &lt;code&gt;RTC_GEOMETRY_TYPE_INSTANCE&lt;/code&gt; to the &lt;code&gt;rtcNewGeometry&lt;/code&gt; function call. The instanced scene can be set using the &lt;code&gt;rtcSetGeometryInstancedScene&lt;/code&gt; call, and the affine transformation can be set using the &lt;code&gt;rtcSetGeometryTransform&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Please note that &lt;code&gt;rtcCommitScene&lt;/code&gt; on the instanced scene should be called first, followed by &lt;code&gt;rtcCommitGeometry&lt;/code&gt; on the instance, followed by &lt;code&gt;rtcCommitScene&lt;/code&gt; for the top-level scene containing the instance.&lt;/p&gt; &#xA;&lt;p&gt;If a ray hits the instance, the &lt;code&gt;geomID&lt;/code&gt; and &lt;code&gt;primID&lt;/code&gt; members of the hit are set to the geometry ID and primitive ID of the hit primitive in the instanced scene, and the &lt;code&gt;instID&lt;/code&gt; member of the hit is set to the geometry ID of the instance in the top-level scene.&lt;/p&gt; &#xA;&lt;p&gt;The instancing scheme can also be implemented using user geometries. To achieve this, the user geometry code should set the &lt;code&gt;instID&lt;/code&gt; member of the ray query context to the geometry ID of the instance, then trace the transformed ray, and finally set the &lt;code&gt;instID&lt;/code&gt; field of the ray query context again to -1. The &lt;code&gt;instID&lt;/code&gt; field is copied automatically by each primitive intersector into the &lt;code&gt;instID&lt;/code&gt; field of the hit structure when the primitive is hit. See the &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#user-geometry&#34;&gt;User Geometry&lt;/a&gt; tutorial for an example.&lt;/p&gt; &#xA;&lt;p&gt;For multi-segment motion blur, the number of time steps must be first specified using the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; function. Then a transformation for each time step can be specified using the &lt;code&gt;rtcSetGeometryTransform&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;See tutorials &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#instanced-geometry&#34;&gt;Instanced Geometry&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#multi-level-instancing&#34;&gt;Multi Level Instancing&lt;/a&gt; for examples of how to use instances.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcSetGeometryInstancedScene], [rtcSetGeometryTransform]&lt;/p&gt; &#xA;&lt;h2&gt;RTCCurveFlags&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCCurveFlags - per segment flags for curve geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;enum RTCCurveFlags&#xA;{&#xA;  RTC_CURVE_FLAG_NEIGHBOR_LEFT  = (1 &amp;lt;&amp;lt; 0), &#xA;  RTC_CURVE_FLAG_NEIGHBOR_RIGHT = (1 &amp;lt;&amp;lt; 1) &#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The RTCCurveFlags type is used for linear curves to determine if the left and/or right neighbor segment exist. Therefore one attaches a buffer of type RTC_BUFFER_TYPE_FLAGS to the curve geometry which stores an individual byte per curve segment.&lt;/p&gt; &#xA;&lt;p&gt;If the RTC_CURVE_FLAG_NEIGHBOR_LEFT flag in that byte is enabled for a curve segment, then the left segment exists (which starts one vertex before the start vertex of the current curve) and the current segment is rendered to properly attach to that segment.&lt;/p&gt; &#xA;&lt;p&gt;If the RTC_CURVE_FLAG_NEIGHBOR_RIGHT flag in that byte is enabled for a curve segment, then the right segment exists (which ends one vertex after the end vertex of the current curve) and the current segment is rendered to properly attach to that segment.&lt;/p&gt; &#xA;&lt;p&gt;When not properly specifying left and right flags for linear curves, the rendering at the ending of these curves may not look correct, in particular when round linear curves are viewed from the inside.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_CURVE]&lt;/p&gt; &#xA;&lt;h2&gt;rtcRetainGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcRetainGeometry - increments the geometry reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcRetainGeometry(RTCGeometry geometry);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Geometry objects are reference counted. The &lt;code&gt;rtcRetainGeometry&lt;/code&gt; function increments the reference count of the passed geometry object (&lt;code&gt;geometry&lt;/code&gt; argument). This function together with &lt;code&gt;rtcReleaseGeometry&lt;/code&gt; allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcReleaseGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;rtcReleaseGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcReleaseGeometry - decrements the geometry reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcReleaseGeometry(RTCGeometry geometry);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Geometry objects are reference counted. The &lt;code&gt;rtcReleaseGeometry&lt;/code&gt; function decrements the reference count of the passed geometry object (&lt;code&gt;geometry&lt;/code&gt; argument). When the reference count falls to 0, the geometry gets destroyed.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcRetainGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;rtcCommitGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcCommitGeometry - commits geometry changes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcCommitGeometry(RTCGeometry geometry);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcCommitGeometry&lt;/code&gt; function is used to commit all geometry changes performed to a geometry (&lt;code&gt;geometry&lt;/code&gt; parameter). After a geometry gets modified, this function must be called to properly update the internal state of the geometry to perform interpolations using &lt;code&gt;rtcInterpolate&lt;/code&gt; or to commit a scene containing the geometry using &lt;code&gt;rtcCommitScene&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInterpolate], [rtcCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcEnableGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcEnableGeometry - enables the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcEnableGeometry(RTCGeometry geometry);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcEnableGeometry&lt;/code&gt; function enables the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument). Only enabled geometries are rendered. Each geometry is enabled by default at construction time.&lt;/p&gt; &#xA;&lt;p&gt;After enabling a geometry, the scene containing that geometry must be committed using &lt;code&gt;rtcCommitScene&lt;/code&gt; for the change to have effect.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcDisableGeometry], [rtcCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcDisableGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcDisableGeometry - disables the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcDisableGeometry(RTCGeometry geometry);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcDisableGeometry&lt;/code&gt; function disables the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument). A disabled geometry is not rendered. Each geometry is enabled by default at construction time.&lt;/p&gt; &#xA;&lt;p&gt;After disabling a geometry, the scene containing that geometry must be committed using &lt;code&gt;rtcCommitScene&lt;/code&gt; for the change to have effect.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcEnableGeometry], [rtcCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryTimeStepCount&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryTimeStepCount - sets the number of time steps of the&#xA;  geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryTimeStepCount(&#xA;  RTCGeometry geometry,&#xA;  unsigned int timeStepCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; function sets the number of time steps for multi-segment motion blur (&lt;code&gt;timeStepCount&lt;/code&gt; parameter) of the specified geometry (&lt;code&gt;geometry&lt;/code&gt; parameter).&lt;/p&gt; &#xA;&lt;p&gt;For triangle meshes (&lt;code&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/code&gt;), quad meshes (&lt;code&gt;RTC_GEOMETRY_TYPE_QUAD&lt;/code&gt;), curves (&lt;code&gt;RTC_GEOMETRY_TYPE_CURVE&lt;/code&gt;), points (&lt;code&gt;RTC_GEOMETRY_TYPE_POINT&lt;/code&gt;), and subdivision geometries (&lt;code&gt;RTC_GEOMETRY_TYPE_SUBDIVISION&lt;/code&gt;), the number of time steps directly corresponds to the number of vertex buffer slots available (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; buffer type). For these geometries, one vertex buffer per time step must be specified when creating multi-segment motion blur geometries.&lt;/p&gt; &#xA;&lt;p&gt;For instance geometries (&lt;code&gt;RTC_GEOMETRY_TYPE_INSTANCE&lt;/code&gt;), a transformation must be specified for each time step (see &lt;code&gt;rtcSetGeometryTransform&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;For user geometries, the registered bounding callback function must provide a bounding box per primitive and time step, and the intersection and occlusion callback functions should properly intersect the motion-blurred geometry at the ray time.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcSetGeometryTimeRange]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryTimeRange&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryTimeRange - sets the time range for a motion blur geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryTimeRange(&#xA;  RTCGeometry geometry,&#xA;  float startTime,&#xA;  float endTime&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryTimeRange&lt;/code&gt; function sets a time range which defines the start (and end time) of the first (and last) time step of a motion blur geometry. The time range is defined relative to the camera shutter interval [0,1] but it can be arbitrary. Thus the startTime can be smaller, equal, or larger 0, indicating a geometry whose animation definition start before, at, or after the camera shutter opens. Similar the endTime can be smaller, equal, or larger than 1, indicating a geometry whose animation definition ends after, at, or before the camera shutter closes. The startTime has to be smaller or equal to the endTime.&lt;/p&gt; &#xA;&lt;p&gt;The default time range when this function is not called is the entire camera shutter [0,1]. For best performance at most one time segment of the piece wise linear definition of the motion should fall outside the shutter window to the left and to the right. Thus do not set the startTime or endTime too far outside the [0,1] interval for best performance.&lt;/p&gt; &#xA;&lt;p&gt;This time range feature will also allow geometries to appear and disappear during the camera shutter time if the specified time range is a sub range of [0,1].&lt;/p&gt; &#xA;&lt;p&gt;Please also have a look at the &lt;code&gt;rtcSetGeometryTimeStepCount&lt;/code&gt; function to see how to define the time steps for the specified time range.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryTimeStepCount]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryVertexAttributeCount&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryVertexAttributeCount - sets the number of vertex&#xA;  attributes of the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryVertexAttributeCount(&#xA;  RTCGeometry geometry,&#xA;  unsigned int vertexAttributeCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryVertexAttributeCount&lt;/code&gt; function sets the number of slots (&lt;code&gt;vertexAttributeCount&lt;/code&gt; parameter) for vertex attribute buffers (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt;) that can be used for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; parameter).&lt;/p&gt; &#xA;&lt;p&gt;This function is supported only for triangle meshes (&lt;code&gt;RTC_GEOMETRY_TYPE_TRIANGLE&lt;/code&gt;), quad meshes (&lt;code&gt;RTC_GEOMETRY_TYPE_QUAD&lt;/code&gt;), curves (&lt;code&gt;RTC_GEOMETRY_TYPE_CURVE&lt;/code&gt;), points (&lt;code&gt;RTC_GEOMETRY_TYPE_POINT&lt;/code&gt;), and subdivision geometries (&lt;code&gt;RTC_GEOMETRY_TYPE_SUBDIVISION&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [RTCBufferType]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryMask&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryMask - sets the geometry mask&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryMask(&#xA;  RTCGeometry geometry,&#xA;  unsigned int mask&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryMask&lt;/code&gt; function sets a 32-bit geometry mask (&lt;code&gt;mask&lt;/code&gt; argument) for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;This geometry mask is used together with the ray mask stored inside the &lt;code&gt;mask&lt;/code&gt; field of the ray. The primitives of the geometry are hit by the ray only if the bitwise &lt;code&gt;and&lt;/code&gt; operation of the geometry mask with the ray mask is not 0. This feature can be used to disable selected geometries for specifically tagged rays, e.g.&amp;nbsp;to disable shadow casting for certain geometries.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCRay], [rtcGetDeviceProperty]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryBuildQuality&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryBuildQuality - sets the build quality for the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryBuildQuality(&#xA;  RTCGeometry geometry,&#xA;  enum RTCBuildQuality quality&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryBuildQuality&lt;/code&gt; function sets the build quality (&lt;code&gt;quality&lt;/code&gt; argument) for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument). The per-geometry build quality is only a hint and may be ignored. Embree currently uses the per-geometry build quality when the scene build quality is set to &lt;code&gt;RTC_BUILD_QUALITY_LOW&lt;/code&gt;. In this mode a two-level acceleration structure is build, and geometries build a separate acceleration structure using the geometry build quality. The per-geometry build quality can be one of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_LOW&lt;/code&gt;: Creates lower quality data structures, e.g.&amp;nbsp;for dynamic scenes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_MEDIUM&lt;/code&gt;: Default build quality for most usages. Gives a good compromise between build and render performance.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_HIGH&lt;/code&gt;: Creates higher quality data structures for final-frame rendering. Enables a spatial split builder for certain primitive types.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_BUILD_QUALITY_REFIT&lt;/code&gt;: Uses a BVH refitting approach when changing only the vertex buffer.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetSceneBuildQuality]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryMaxRadiusScale&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryMaxRadiusScale - assigns a maximal curve radius scale factor for min-width feature&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryMaxRadiusScale(RTCGeometry geometry, float maxRadiusScale);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetMaxGeometryScale&lt;/code&gt; function specifies a maximal scaling factor for curve radii used by the min-width feature.&lt;/p&gt; &#xA;&lt;p&gt;The min-width feature can increase the radius of curves and points, in order to reduce aliasing and improve render times. The feature is disabled by default and has to get enabled using the EMBREE_MIN_WIDTH cmake option.&lt;/p&gt; &#xA;&lt;p&gt;To use the feature, one has to specify a maximal curve radius scaling factor using the [rtcSetGeometryMaxRadiusScale] function. This factor should be a small number (e.g.&amp;nbsp;4) as the constructed BVH bounds get increased in order to bound the curve in the worst case of maximal radii.&lt;/p&gt; &#xA;&lt;p&gt;One also has to set the minWidthDistanceFactor in the RTCRayQueryContext when tracing a ray. This factor controls the target radius size of a curve or point at some distance away of the ray origin.&lt;/p&gt; &#xA;&lt;p&gt;For each control point p with radius r of a curve or point primitive, the primitive intersectors first calculate a target radius r&#39; as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;r&#39; = length(p-ray_org) * minWidthDistanceFactor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Typically the minWidthDistanceFactor is set by the application such that the target radius projects to the width of half a pixel (thus primitive diameter is pixel sized).&lt;/p&gt; &#xA;&lt;p&gt;The target radius r&#39; is then clamped against the minimal bound r and maximal bound maxRadiusScale*r to obtain the final radius r&#39;&#39;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;r&#39;&#39; = max(r, min(r&#39;, maxRadiusScale*r))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Thus curves or points close to the camera are rendered with a normal radii r, and curves or points far from the camera are not enlarged too much, as this would be very expensive to render.&lt;/p&gt; &#xA;&lt;p&gt;When &lt;code&gt;rtcSetGeometryMaxRadiusScale&lt;/code&gt; function is not invoked for a curve or point geometry (or if the maximal scaling factor is set to 1.0), then the curve or point geometry renders normally, with radii not modified by the min-width feature.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInitRayQueryContext]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryBuffer - assigns a view of a buffer to the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryBuffer(&#xA;  RTCGeometry geometry,&#xA;  enum RTCBufferType type,&#xA;  unsigned int slot,&#xA;  enum RTCFormat format,&#xA;  RTCBuffer buffer,&#xA;  size_t byteOffset,&#xA;  size_t byteStride,&#xA;  size_t itemCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; function binds a view of a buffer object (&lt;code&gt;buffer&lt;/code&gt; argument) to a geometry buffer type and slot (&lt;code&gt;type&lt;/code&gt; and &lt;code&gt;slot&lt;/code&gt; argument) of the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;One can specify the start of the first buffer element in bytes (&lt;code&gt;byteOffset&lt;/code&gt; argument), the byte stride between individual buffer elements (&lt;code&gt;byteStride&lt;/code&gt; argument), the format of the buffer elements (&lt;code&gt;format&lt;/code&gt; argument), and the number of elements to bind (&lt;code&gt;itemCount&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The start address (&lt;code&gt;byteOffset&lt;/code&gt; argument) and stride (&lt;code&gt;byteStride&lt;/code&gt; argument) must be both aligned to 4 bytes, otherwise the &lt;code&gt;rtcSetGeometryBuffer&lt;/code&gt; function will fail.&lt;/p&gt; &#xA;&lt;p&gt;After successful completion of this function, the geometry will hold a reference to the buffer object.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetSharedGeometryBuffer], [rtcSetNewGeometryBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetSharedGeometryBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetSharedGeometryBuffer - assigns a view of a shared data buffer&#xA;  to a geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetSharedGeometryBuffer(&#xA;  RTCGeometry geometry,&#xA;  enum RTCBufferType type,&#xA;  unsigned int slot,&#xA;  enum RTCFormat format,&#xA;  const void* ptr,&#xA;  size_t byteOffset,&#xA;  size_t byteStride,&#xA;  size_t itemCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; function binds a view of a shared user-managed data buffer (&lt;code&gt;ptr&lt;/code&gt; argument) to a geometry buffer type and slot (&lt;code&gt;type&lt;/code&gt; and &lt;code&gt;slot&lt;/code&gt; argument) of the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;One can specify the start of the first buffer element in bytes (&lt;code&gt;byteOffset&lt;/code&gt; argument), the byte stride between individual buffer elements (&lt;code&gt;byteStride&lt;/code&gt; argument), the format of the buffer elements (&lt;code&gt;format&lt;/code&gt; argument), and the number of elements to bind (&lt;code&gt;itemCount&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The start address (&lt;code&gt;byteOffset&lt;/code&gt; argument) and stride (&lt;code&gt;byteStride&lt;/code&gt; argument) must be both aligned to 4 bytes; otherwise the &lt;code&gt;rtcSetSharedGeometryBuffer&lt;/code&gt; function will fail.&lt;/p&gt; &#xA;&lt;p&gt;When the buffer will be used as a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; and &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt;), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard &lt;code&gt;float3&lt;/code&gt; vertex buffer layout should add storage for at least one more float to the end of the buffer.&lt;/p&gt; &#xA;&lt;p&gt;The buffer data must remain valid for as long as the buffer may be used, and the user is responsible for freeing the buffer data when no longer required.&lt;/p&gt; &#xA;&lt;p&gt;Sharing buffers can significantly reduce the memory required by the application, thus we recommend using this feature. When enabling the &lt;code&gt;RTC_SCENE_FLAG_COMPACT&lt;/code&gt; scene flag, the spatial index structures index into the vertex buffer, resulting in even higher memory savings.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryBuffer], [rtcSetNewGeometryBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetNewGeometryBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetNewGeometryBuffer - creates and assigns a new data buffer to&#xA;  the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void* rtcSetNewGeometryBuffer(&#xA;  RTCGeometry geometry,&#xA;  enum RTCBufferType type,&#xA;  unsigned int slot,&#xA;  enum RTCFormat format,&#xA;  size_t byteStride,&#xA;  size_t itemCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetNewGeometryBuffer&lt;/code&gt; function creates a new data buffer of specified format (&lt;code&gt;format&lt;/code&gt; argument), byte stride (&lt;code&gt;byteStride&lt;/code&gt; argument), and number of items (&lt;code&gt;itemCount&lt;/code&gt; argument), and assigns it to a geometry buffer slot (&lt;code&gt;type&lt;/code&gt; and &lt;code&gt;slot&lt;/code&gt; argument) of the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument). The buffer data is managed internally and automatically freed when the geometry is destroyed.&lt;/p&gt; &#xA;&lt;p&gt;The byte stride (&lt;code&gt;byteStride&lt;/code&gt; argument) must be aligned to 4 bytes; otherwise the &lt;code&gt;rtcSetNewGeometryBuffer&lt;/code&gt; function will fail.&lt;/p&gt; &#xA;&lt;p&gt;The allocated buffer will be automatically over-allocated slightly when used as a vertex buffer, where a requirement is that each buffer element should be readable using 16-byte SSE load instructions.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryBuffer], [rtcSetSharedGeometryBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;RTCFormat&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCFormat - specifies format of data in buffers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;enum RTCFormat&#xA;{&#xA;  RTC_FORMAT_UINT,&#xA;  RTC_FORMAT_UINT2,&#xA;  RTC_FORMAT_UINT3,&#xA;  RTC_FORMAT_UINT4,&#xA;&#xA;  RTC_FORMAT_FLOAT,&#xA;  RTC_FORMAT_FLOAT2,&#xA;  RTC_FORMAT_FLOAT3,&#xA;  RTC_FORMAT_FLOAT4,&#xA;  RTC_FORMAT_FLOAT5,&#xA;  RTC_FORMAT_FLOAT6,&#xA;  RTC_FORMAT_FLOAT7,&#xA;  RTC_FORMAT_FLOAT8,&#xA;  RTC_FORMAT_FLOAT9,&#xA;  RTC_FORMAT_FLOAT10,&#xA;  RTC_FORMAT_FLOAT11,&#xA;  RTC_FORMAT_FLOAT12,&#xA;  RTC_FORMAT_FLOAT13,&#xA;  RTC_FORMAT_FLOAT14,&#xA;  RTC_FORMAT_FLOAT15,&#xA;  RTC_FORMAT_FLOAT16,&#xA;&#xA;  RTC_FORMAT_FLOAT3X4_ROW_MAJOR,&#xA;  RTC_FORMAT_FLOAT4X4_ROW_MAJOR,&#xA;&#xA;  RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR,&#xA;  RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR,&#xA;&#xA;  RTC_FORMAT_GRID,&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTFormat&lt;/code&gt; structure defines the data format stored in data buffers provided to Embree using the [rtcSetGeometryBuffer], [rtcSetSharedGeometryBuffer], and [rtcSetNewGeometryBuffer] API calls.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_FORMAT_UINT/2/3/4&lt;/code&gt; format are used to specify that data buffers store unsigned integers, or unsigned integer vectors of size 2,3 or 4. This format has typically to get used when specifying index buffers, e.g.&amp;nbsp;&lt;code&gt;RTC_FORMAT_UINT3&lt;/code&gt; for triangle meshes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_FORMAT_FLOAT/2/3/4...&lt;/code&gt; format are used to specify that data buffers store single precision floating point values, or vectors there of (size 2,3,4, etc.). This format is typcally used to specify to format of vertex buffers, e.g.&amp;nbsp;the &lt;code&gt;RTC_FORMAT_FLOAT3&lt;/code&gt; type for vertex buffers of triangle meshes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_FORMAT_FLOAT3X4_ROW_MAJOR&lt;/code&gt; and &lt;code&gt;RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR&lt;/code&gt; formats, specify a 3x4 floating point matrix layed out either row major or column major. The &lt;code&gt;RTC_FORMAT_FLOAT4X4_ROW_MAJOR&lt;/code&gt; and &lt;code&gt;RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR&lt;/code&gt; formats, specify a 4x4 floating point matrix layed out either row major or column major. These matrix formats are used in the [rtcSetGeometryTransform] function in order to set a transformation matrix for geometries.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_FORMAT_GRID&lt;/code&gt; is a special data format used to specify grid primitives of layout RTCGrid when creating grid geometries (see [RTC_GEOMETRY_TYPE_GRID]).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryBuffer], [rtcSetSharedGeometryBuffer], [rtcSetNewGeometryBuffer], [rtcSetGeometryTransform]&lt;/p&gt; &#xA;&lt;h2&gt;RTCBufferType&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCFormat - specifies format of data in buffers&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;enum RTCBufferType&#xA;{&#xA;  RTC_BUFFER_TYPE_INDEX            = 0,&#xA;  RTC_BUFFER_TYPE_VERTEX           = 1,&#xA;  RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE = 2,&#xA;  RTC_BUFFER_TYPE_NORMAL           = 3,&#xA;  RTC_BUFFER_TYPE_TANGENT          = 4,&#xA;  RTC_BUFFER_TYPE_NORMAL_DERIVATIVE = 5,&#xA;&#xA;  RTC_BUFFER_TYPE_GRID                 = 8,&#xA;&#xA;  RTC_BUFFER_TYPE_FACE                 = 16,&#xA;  RTC_BUFFER_TYPE_LEVEL                = 17,&#xA;  RTC_BUFFER_TYPE_EDGE_CREASE_INDEX    = 18,&#xA;  RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT   = 19,&#xA;  RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX  = 20,&#xA;  RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT = 21,&#xA;  RTC_BUFFER_TYPE_HOLE                 = 22,&#xA;&#xA;  RTC_BUFFER_TYPE_FLAGS = 32&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTBufferType&lt;/code&gt; structure defines slots to assign data buffers to using the [rtcSetGeometryBuffer], [rtcSetSharedGeometryBuffer], and [rtcSetNewGeometryBuffer] API calls.&lt;/p&gt; &#xA;&lt;p&gt;For most geometry types the &lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt; slot is used to assign an index buffer, while the &lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; is used to assign the corresponding vertex buffer.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt; slot can get used to assign arbitrary additional vertex data which can get interpolated using the [rtcInterpolate] API call.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_BUFFER_TYPE_NORMAL&lt;/code&gt;, &lt;code&gt;RTC_BUFFER_TYPE_TANGENT&lt;/code&gt;, and &lt;code&gt;RTC_BUFFER_TYPE_NORMAL_DERIVATIVE&lt;/code&gt; are special buffers required to assign per vertex normals, tangents, and normal derivatives for some curve types.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_BUFFER_TYPE_GRID&lt;/code&gt; buffer is used to assign the grid primitive buffer for grid geometries (see [RTC_GEOMETRY_TYPE_GRID]).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_BUFFER_TYPE_FACE&lt;/code&gt;, &lt;code&gt;RTC_BUFFER_TYPE_LEVEL&lt;/code&gt;, &lt;code&gt;RTC_BUFFER_TYPE_EDGE_CREASE_INDEX&lt;/code&gt;, &lt;code&gt;RTC_BUFFER_TYPE_EDGE_CREASE_WEIGHT&lt;/code&gt;, &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_CREASE_INDEX&lt;/code&gt;, &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_CREASE_WEIGHT&lt;/code&gt;, and &lt;code&gt;RTC_BUFFER_TYPE_HOLE&lt;/code&gt; are special buffers required to create subdivision meshes (see [RTC_GEOMETRY_TYPE_SUBDIVISION]).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTC_BUFFER_TYPE_FLAGS&lt;/code&gt; can get used to add additional flag per primitive of a geometry, and is currently only used for linear curves.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryBuffer], [rtcSetSharedGeometryBuffer], [rtcSetNewGeometryBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryBufferData&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryBufferData - gets pointer to&#xA;  the first buffer view element&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void* rtcGetGeometryBufferData(&#xA;  RTCGeometry geometry,&#xA;  enum RTCBufferType type,&#xA;  unsigned int slot&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryBufferData&lt;/code&gt; function returns a pointer to the first element of the buffer view attached to the specified buffer type and slot (&lt;code&gt;type&lt;/code&gt; and &lt;code&gt;slot&lt;/code&gt; argument) of the geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryBuffer], [rtcSetSharedGeometryBuffer], [rtcSetNewGeometryBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcUpdateGeometryBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcUpdateGeometryBuffer - marks a buffer view bound to the geometry&#xA;  as modified&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcUpdateGeometryBuffer(&#xA;  RTCGeometry geometry,&#xA;  enum RTCBufferType type,&#xA;  unsigned int slot&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcUpdateGeometryBuffer&lt;/code&gt; function marks the buffer view bound to the specified buffer type and slot (&lt;code&gt;type&lt;/code&gt; and &lt;code&gt;slot&lt;/code&gt; argument) of a geometry (&lt;code&gt;geometry&lt;/code&gt; argument) as modified.&lt;/p&gt; &#xA;&lt;p&gt;If a data buffer is changed by the application, the &lt;code&gt;rtcUpdateGeometryBuffer&lt;/code&gt; call must be invoked for that buffer. Each buffer view assigned to a buffer slot is initially marked as modified, thus this function needs to be called only when doing buffer modifications after the first &lt;code&gt;rtcCommitScene&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewGeometry], [rtcCommitScene]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryIntersectFilterFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryIntersectFilterFunction - sets the intersection filter&#xA;  for the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCFilterFunctionNArguments&#xA;{&#xA;  int* valid;&#xA;  void* geometryUserPtr;&#xA;  const struct RTCRayQueryContext* context;&#xA;  struct RTCRayN* ray;&#xA;  struct RTCHitN* hit;&#xA;  unsigned int N;&#xA;};&#xA;&#xA;typedef void (*RTCFilterFunctionN)(&#xA;  const struct RTCFilterFunctionNArguments* args&#xA;);&#xA;&#xA;void rtcSetGeometryIntersectFilterFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCFilterFunctionN filter&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryIntersectFilterFunction&lt;/code&gt; function registers an intersection filter callback function (&lt;code&gt;filter&lt;/code&gt; argument) for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;The registered intersection filter function is invoked for every hit encountered during the &lt;code&gt;rtcIntersect&lt;/code&gt;-type ray queries and can accept or reject that hit. The feature can be used to define a silhouette for a primitive and reject hits that are outside the silhouette. E.g. a tree leaf could be modeled with an alpha texture that decides whether hit points lie inside or outside the leaf.&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;RTC_BUILD_QUALITY_HIGH&lt;/code&gt; mode is set, the filter functions may be called multiple times for the same primitive hit. Further, rays hitting exactly the edge might also report two hits for the same surface. For certain use cases, the application may have to work around this limitation by collecting already reported hits (&lt;code&gt;geomID&lt;/code&gt;/&lt;code&gt;primID&lt;/code&gt; pairs) and ignoring duplicates.&lt;/p&gt; &#xA;&lt;p&gt;The filter function callback of type &lt;code&gt;RTCFilterFunctionN&lt;/code&gt; gets passed a number of arguments through the &lt;code&gt;RTCFilterFunctionNArguments&lt;/code&gt; structure. The &lt;code&gt;valid&lt;/code&gt; parameter of that structure points to an integer valid mask (0 means invalid and -1 means valid). The &lt;code&gt;geometryUserPtr&lt;/code&gt; member is a user pointer optionally set per geometry through the &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; function. The &lt;code&gt;context&lt;/code&gt; member points to the ray query context passed to the ray query function. The &lt;code&gt;ray&lt;/code&gt; parameter points to &lt;code&gt;N&lt;/code&gt; rays in SOA layout. The &lt;code&gt;hit&lt;/code&gt; parameter points to &lt;code&gt;N&lt;/code&gt; hits in SOA layout to test. The &lt;code&gt;N&lt;/code&gt; parameter is the number of rays and hits in &lt;code&gt;ray&lt;/code&gt; and &lt;code&gt;hit&lt;/code&gt;. The hit distance is provided as the &lt;code&gt;tfar&lt;/code&gt; value of the ray. If the hit geometry is instanced, the &lt;code&gt;instID&lt;/code&gt; member of the ray is valid, and the ray and the potential hit are in object space.&lt;/p&gt; &#xA;&lt;p&gt;The filter callback function has the task to check for each valid ray whether it wants to accept or reject the corresponding hit. To reject a hit, the filter callback function just has to write &lt;code&gt;0&lt;/code&gt; to the integer valid mask of the corresponding ray. To accept the hit, it just has to leave the valid mask set to &lt;code&gt;-1&lt;/code&gt;. The filter function is further allowed to change the hit and decrease the &lt;code&gt;tfar&lt;/code&gt; value of the ray but it should not modify other ray data nor any inactive components of the ray or hit.&lt;/p&gt; &#xA;&lt;p&gt;When performing ray queries using &lt;code&gt;rtcIntersect1&lt;/code&gt;, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the &lt;code&gt;rayID&lt;/code&gt; component of the ray to identify the original ray to access the per-ray data.&lt;/p&gt; &#xA;&lt;p&gt;The implementation of the filter function can choose to implement a single code path that uses the ray access helper functions &lt;code&gt;RTCRay_XXX&lt;/code&gt; and hit access helper functions &lt;code&gt;RTCHit_XXX&lt;/code&gt; to access ray and hit data. Alternatively the code can branch to optimized implementations for specific sizes of &lt;code&gt;N&lt;/code&gt; and cast the &lt;code&gt;ray&lt;/code&gt; and &lt;code&gt;hit&lt;/code&gt; inputs to the proper packet types.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryOccludedFilterFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryOccludedFilterFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryOccludedFilterFunction - sets the occlusion filter&#xA;  for the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryOccludedFilterFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCFilterFunctionN filter&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryOccludedFilterFunction&lt;/code&gt; function registers an occlusion filter callback function (&lt;code&gt;filter&lt;/code&gt; argument) for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;The registered intersection filter function is invoked for every hit encountered during the &lt;code&gt;rtcOccluded&lt;/code&gt;-type ray queries and can accept or reject that hit. The feature can be used to define a silhouette for a primitive and reject hits that are outside the silhouette. E.g. a tree leaf could be modeled with an alpha texture that decides whether hit points lie inside or outside the leaf.&lt;/p&gt; &#xA;&lt;p&gt;Please see the description of the &lt;code&gt;rtcSetGeometryIntersectFilterFunction&lt;/code&gt; for a description of the filter callback function.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryIntersectFilterFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryEnableFilterFunctionFromArguments&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryEnableFilterFunctionFromArguments - enables&#xA;  argument filter functions for the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryEnableFilterFunctionFromArguments(&#xA;   RTCGeometry geometry, bool enable);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function enables invokation the filter function passed through &lt;code&gt;RTCIntersectArguments&lt;/code&gt; or &lt;code&gt;RTCOccludedArguments&lt;/code&gt; to the intersect and occluded queries. If enable is true the argument filter function invokation is enabled for the geometry or disabled otherwise. By default the invokation of the argument filter function is disabled for some geometry.&lt;/p&gt; &#xA;&lt;p&gt;The argument filter function invokation can also get enforced for each geometry by using the &lt;code&gt;RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&lt;/code&gt; ray query flag that can get passed to &lt;code&gt;rtcIntersect&lt;/code&gt; and &lt;code&gt;rtcOccluded&lt;/code&gt; functions. See Section [rtcInitIntersectArguments] and [rtcInitOccludedArguments] for more details.&lt;/p&gt; &#xA;&lt;p&gt;In order to use the argument filter function for some scene, that feature additionally has to get enabled using the &lt;code&gt;RTC_SCENE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS&lt;/code&gt; scene flag. See Section [rtcSetSceneFlags] for more details.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can get queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInitIntersectArguments], [rtcInitOccludedArguments], [rtcSetSceneFlags]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInvokeIntersectFilterFromGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInvokeIntersectFilterFromGeometry - invokes the&#xA;  intersection filter function from the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcInvokeIntersectFilterFromGeometry(&#xA;  const struct RTCIntersectFunctionNArguments* args,&#xA;  const struct RTCFilterFunctionNArguments* filterArgs&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInvokeIntersectFilterFromGeometry&lt;/code&gt; function can be called inside an &lt;code&gt;RTCIntersectFunctionN&lt;/code&gt; user geometry callback function to invoke the intersection filter registered to the geometry. For this an &lt;code&gt;RTCFilterFunctionNArguments&lt;/code&gt; structure must be created (see &lt;code&gt;rtcSetGeometryIntersectFilterFunction&lt;/code&gt;) which basically consists of a valid mask, a hit packet to filter, the corresponding ray packet, and the packet size. After the invocation of &lt;code&gt;rtcInvokeIntersectFilterFromGeometry&lt;/code&gt;, only rays that are still valid (valid mask set to -1) should update a hit.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInvokeOccludedFilterFromGeometry], [rtcSetGeometryIntersectFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInvokeOccludedFilterFromGeometry&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInvokeOccludedFilterFromGeometry - invokes the occlusion&#xA;  filter function from the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcInvokeOccludedFilterFromGeometry(&#xA;  const struct RTCOccludedFunctionNArguments* args,&#xA;  const struct RTCFilterFunctionNArguments* filterArgs&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInvokeOccludedFilterFromGeometry&lt;/code&gt; function can be called inside an &lt;code&gt;RTCOccludedFunctionN&lt;/code&gt; user geometry callback function to invoke the occlusion filter registered to the geometry. For this an &lt;code&gt;RTCFilterFunctionNArguments&lt;/code&gt; structure must be created (see &lt;code&gt;rtcSetGeometryIntersectFilterFunction&lt;/code&gt;) which basically consists of a valid mask, a hit packet to filter, the corresponding ray packet, and the packet size. After the invocation of &lt;code&gt;rtcInvokeOccludedFilterFromGeometry&lt;/code&gt; only rays that are still valid (valid mask set to -1) should signal an occlusion.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInvokeIntersectFilterFromGeometry], [rtcSetGeometryOccludedFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryUserData&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryUserData - sets the user-defined data pointer of the&#xA;  geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryUserData(RTCGeometry geometry, void* userPtr);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; function sets the user-defined data pointer (&lt;code&gt;userPtr&lt;/code&gt; argument) for a geometry (&lt;code&gt;geometry&lt;/code&gt; argument). This user data pointer is intended to be pointing to the application&#39;s representation of the geometry, and is passed to various callback functions. The application can use this pointer inside the callback functions to access its geometry representation.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryUserData&lt;/code&gt; function can be used to query an already set user data pointer of a geometry.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetGeometryUserData]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryUserData&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryUserData - returns the user data pointer&#xA;  of the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void* rtcGetGeometryUserData(RTCGeometry geometry);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryUserData&lt;/code&gt; function queries the user data pointer previously set with &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt;. When &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; was not called yet, &lt;code&gt;NULL&lt;/code&gt; is returned.&lt;/p&gt; &#xA;&lt;p&gt;This function is supposed to be used during rendering, but only supported on the CPU and in SYCL on the GPU.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryUserData]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryUserDataFromScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryUserDataFromScene - returns the user data pointer&#xA;  of the geometry through the scene object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void* rtcGetGeometryUserDataFromScene(RTCScene scene, unsigned int geomID);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryUserDataFromScene&lt;/code&gt; function queries the user data pointer previously set with &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; from the geometry with index &lt;code&gt;geomID&lt;/code&gt; from the specified scene &lt;code&gt;scene&lt;/code&gt;. When &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt; was not called yet, &lt;code&gt;NULL&lt;/code&gt; is returned.&lt;/p&gt; &#xA;&lt;p&gt;This function is supposed to be used during rendering.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryUserData], [rtcGetGeometryUserData]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryUserPrimitiveCount&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryUserPrimitiveCount - sets the number of primitives&#xA;  of a user-defined geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryUserPrimitiveCount(&#xA;  RTCGeometry geometry,&#xA;  unsigned int userPrimitiveCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryUserPrimitiveCount&lt;/code&gt; function sets the number of user-defined primitives (&lt;code&gt;userPrimitiveCount&lt;/code&gt; parameter) of the specified user-defined geometry (&lt;code&gt;geometry&lt;/code&gt; parameter).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_USER]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryBoundsFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryBoundsFunction - sets a callback to query the&#xA;  bounding box of user-defined primitives&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCBoundsFunctionArguments&#xA;{&#xA;  void* geometryUserPtr;&#xA;  unsigned int primID;&#xA;  unsigned int timeStep;&#xA;  struct RTCBounds* bounds_o;&#xA;};&#xA;&#xA;typedef void (*RTCBoundsFunction)(&#xA;  const struct RTCBoundsFunctionArguments* args&#xA;);&#xA;&#xA;void rtcSetGeometryBoundsFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCBoundsFunction bounds,&#xA;  void* userPtr&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryBoundsFunction&lt;/code&gt; function registers a bounding box callback function (&lt;code&gt;bounds&lt;/code&gt; argument) with payload (&lt;code&gt;userPtr&lt;/code&gt; argument) for the specified user geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;In SYCL mode the BVH construction is done on the host and the passed function pointer must be a host-side function pointer.&lt;/p&gt; &#xA;&lt;p&gt;The registered bounding box callback function is invoked to calculate axis-aligned bounding boxes of the primitives of the user-defined geometry during spatial acceleration structure construction. The bounding box callback of &lt;code&gt;RTCBoundsFunction&lt;/code&gt; type is invoked with a pointer to a structure of type &lt;code&gt;RTCBoundsFunctionArguments&lt;/code&gt; which contains various arguments, such as: the user data of the geometry (&lt;code&gt;geometryUserPtr&lt;/code&gt; member), the ID of the primitive to calculate the bounds for (&lt;code&gt;primID&lt;/code&gt; member), the time step at which to calculate the bounds (&lt;code&gt;timeStep&lt;/code&gt; member), and a memory location to write the calculated bound to (&lt;code&gt;bounds_o&lt;/code&gt; member).&lt;/p&gt; &#xA;&lt;p&gt;In a typical usage scenario one would store a pointer to the internal representation of the user geometry object using &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt;. The callback function can then read that pointer from the &lt;code&gt;geometryUserPtr&lt;/code&gt; field and calculate the proper bounding box for the requested primitive and time, and store that bounding box to the destination structure (&lt;code&gt;bounds_o&lt;/code&gt; member).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_USER]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryIntersectFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryIntersectFunction - sets the callback function to&#xA;  intersect a user geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCIntersectFunctionNArguments&#xA;{&#xA;  int* valid;&#xA;  void* geometryUserPtr;&#xA;  unsigned int primID;&#xA;  struct RTCRayQueryContext* context;&#xA;  struct RTCRayHitN* rayhit;&#xA;  unsigned int N;&#xA;  unsigned int geomID;&#xA;};&#xA;&#xA;typedef void (*RTCIntersectFunctionN)(&#xA;  const struct RTCIntersectFunctionNArguments* args&#xA;);&#xA;&#xA;void rtcSetGeometryIntersectFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCIntersectFunctionN intersect&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryIntersectFunction&lt;/code&gt; function registers a ray/primitive intersection callback function (&lt;code&gt;intersect&lt;/code&gt; argument) for the specified user geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;The registered callback function is invoked by &lt;code&gt;rtcIntersect&lt;/code&gt;-type ray queries to calculate the intersection of a ray packet of variable size with one user-defined primitive. The callback function of type &lt;code&gt;RTCIntersectFunctionN&lt;/code&gt; gets passed a number of arguments through the &lt;code&gt;RTCIntersectFunctionNArguments&lt;/code&gt; structure. The value &lt;code&gt;N&lt;/code&gt; specifies the ray packet size, &lt;code&gt;valid&lt;/code&gt; points to an array of integers that specify whether the corresponding ray is valid (-1) or invalid (0), the &lt;code&gt;geometryUserPtr&lt;/code&gt; member points to the geometry user data previously set through &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt;, the &lt;code&gt;context&lt;/code&gt; member points to the ray query context passed to the ray query, the &lt;code&gt;rayhit&lt;/code&gt; member points to a ray and hit packet of variable size &lt;code&gt;N&lt;/code&gt;, and the &lt;code&gt;geomID&lt;/code&gt; and &lt;code&gt;primID&lt;/code&gt; member identifies the geometry ID and primitive ID of the primitive to intersect.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ray&lt;/code&gt; component of the &lt;code&gt;rayhit&lt;/code&gt; structure contains valid data, in particular the &lt;code&gt;tfar&lt;/code&gt; value is the current closest hit distance found. All data inside the &lt;code&gt;hit&lt;/code&gt; component of the &lt;code&gt;rayhit&lt;/code&gt; structure are undefined and should not be read by the function.&lt;/p&gt; &#xA;&lt;p&gt;The task of the callback function is to intersect each active ray from the ray packet with the specified user primitive. If the user-defined primitive is missed by a ray of the ray packet, the function should return without modifying the ray or hit. If an intersection of the user-defined primitive with the ray was found in the valid range (from &lt;code&gt;tnear&lt;/code&gt; to &lt;code&gt;tfar&lt;/code&gt;), it should update the hit distance of the ray (&lt;code&gt;tfar&lt;/code&gt; member) and the hit (&lt;code&gt;u&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;Ng&lt;/code&gt;, &lt;code&gt;instID&lt;/code&gt;, &lt;code&gt;geomID&lt;/code&gt;, &lt;code&gt;primID&lt;/code&gt; members). In particular, the currently intersected instance is stored in the &lt;code&gt;instID&lt;/code&gt; field of the ray query context, which must be deep copied into the &lt;code&gt;instID&lt;/code&gt; member of the hit.&lt;/p&gt; &#xA;&lt;p&gt;As a primitive might have multiple intersections with a ray, the intersection filter function needs to be invoked by the user geometry intersection callback for each encountered intersection, if filtering of intersections is desired. This can be achieved through the &lt;code&gt;rtcInvokeIntersectFilterFromGeometry&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;Within the user geometry intersect function, it is safe to trace new rays and create new scenes and geometries.&lt;/p&gt; &#xA;&lt;p&gt;When performing ray queries using &lt;code&gt;rtcIntersect1&lt;/code&gt;, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the &lt;code&gt;rayID&lt;/code&gt; component of the ray to identify the original ray to access the per-ray data.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryOccludedFunction], [rtcSetGeometryUserData], [rtcInvokeIntersectFilterFromGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryOccludedFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryOccludedFunction - sets the callback function to&#xA;  test a user geometry for occlusion&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCOccludedFunctionNArguments&#xA;{&#xA;  int* valid;&#xA;  void* geometryUserPtr;&#xA;  unsigned int primID;&#xA;  struct RTCRayQueryContext* context;&#xA;  struct RTCRayN* ray;&#xA;  unsigned int N;&#xA;  unsigned int geomID;&#xA;};&#xA;&#xA;typedef void (*RTCOccludedFunctionN)(&#xA;  const struct RTCOccludedFunctionNArguments* args&#xA;);&#xA;&#xA;void rtcSetGeometryOccludedFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCOccludedFunctionN filter&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryOccludedFunction&lt;/code&gt; function registers a ray/primitive occlusion callback function (&lt;code&gt;filter&lt;/code&gt; argument) for the specified user geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;The registered callback function is invoked by &lt;code&gt;rtcOccluded&lt;/code&gt;-type ray queries to test whether the rays of a packet of variable size are occluded by a user-defined primitive. The callback function of type &lt;code&gt;RTCOccludedFunctionN&lt;/code&gt; gets passed a number of arguments through the &lt;code&gt;RTCOccludedFunctionNArguments&lt;/code&gt; structure. The value &lt;code&gt;N&lt;/code&gt; specifies the ray packet size, &lt;code&gt;valid&lt;/code&gt; points to an array of integers which specify whether the corresponding ray is valid (-1) or invalid (0), the &lt;code&gt;geometryUserPtr&lt;/code&gt; member points to the geometry user data previously set through &lt;code&gt;rtcSetGeometryUserData&lt;/code&gt;, the &lt;code&gt;context&lt;/code&gt; member points to the ray query context passed to the ray query, the &lt;code&gt;ray&lt;/code&gt; member points to a ray packet of variable size &lt;code&gt;N&lt;/code&gt;, and the &lt;code&gt;geomID&lt;/code&gt; and &lt;code&gt;primID&lt;/code&gt; member identifies the geometry ID and primitive ID of the primitive to intersect.&lt;/p&gt; &#xA;&lt;p&gt;The task of the callback function is to intersect each active ray from the ray packet with the specified user primitive. If the user-defined primitive is missed by a ray of the ray packet, the function should return without modifying the ray. If an intersection of the user-defined primitive with the ray was found in the valid range (from &lt;code&gt;tnear&lt;/code&gt; to &lt;code&gt;tfar&lt;/code&gt;), it should set the &lt;code&gt;tfar&lt;/code&gt; member of the ray to &lt;code&gt;-inf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;As a primitive might have multiple intersections with a ray, the occlusion filter function needs to be invoked by the user geometry occlusion callback for each encountered intersection, if filtering of intersections is desired. This can be achieved through the &lt;code&gt;rtcInvokeOccludedFilterFromGeometry&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;Within the user geometry occlusion function, it is safe to trace new rays and create new scenes and geometries.&lt;/p&gt; &#xA;&lt;p&gt;When performing ray queries using &lt;code&gt;rtcOccluded1&lt;/code&gt;, it is guaranteed that the packet size is 1 when the callback is invoked. When performing ray queries using the &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt; functions, it is not generally guaranteed that the ray packet size (and order of rays inside the packet) passed to the callback matches the initial ray packet. However, under some circumstances these properties are guaranteed, and whether this is the case can be queried using &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For many usage scenarios, repacking and re-ordering of rays does not cause difficulties in implementing the callback function. However, algorithms that need to extend the ray with additional data must use the &lt;code&gt;rayID&lt;/code&gt; component of the ray to identify the original ray to access the per-ray data.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryIntersectFunction], [rtcSetGeometryUserData], [rtcInvokeOccludedFilterFromGeometry]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryPointQueryFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryPointQueryFunction - sets the point query callback function&#xA;  for a geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCPointQueryFunctionArguments&#xA;{&#xA;  // the (world space) query object that was passed as an argument of rtcPointQuery.&#xA;  struct RTCPointQuery* query;&#xA;&#xA;  // used for user input/output data. Will not be read or modified internally.&#xA;  void* userPtr;&#xA;&#xA;  // primitive and geometry ID of primitive&#xA;  unsigned int  primID;        &#xA;  unsigned int  geomID;    &#xA;&#xA;  // the context with transformation and instance ID stack&#xA;  struct RTCPointQueryContext* context;&#xA;&#xA;  // scaling factor indicating whether the current instance transformation&#xA;  // is a similarity transformation.&#xA;  float similarityScale;&#xA;};&#xA;&#xA;typedef bool (*RTCPointQueryFunction)(&#xA;  struct RTCPointQueryFunctionArguments* args&#xA;);&#xA;&#xA;void rtcSetGeometryPointQueryFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCPointQueryFunction queryFunc&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryPointQueryFunction&lt;/code&gt; function registers a point query callback function (&lt;code&gt;queryFunc&lt;/code&gt; argument) for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;The registered callback function is invoked by [rtcPointQuery] for every primitive of the geometry that intersects the corresponding point query domain. The callback function of type &lt;code&gt;RTCPointQueryFunction&lt;/code&gt; gets passed a number of arguments through the &lt;code&gt;RTCPointQueryFunctionArguments&lt;/code&gt; structure. The &lt;code&gt;query&lt;/code&gt; object is the original point query object passed into [rtcPointQuery], &lt;code&gt;usrPtr&lt;/code&gt; is an arbitrary pointer to pass input into and store results of the callback function. The &lt;code&gt;primID&lt;/code&gt;, &lt;code&gt;geomID&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt; (see [rtcInitPointQueryContext] for details) can be used to identify the geometry data of the primitive.&lt;/p&gt; &#xA;&lt;p&gt;A &lt;code&gt;RTCPointQueryFunction&lt;/code&gt; can also be passed directly as an argument to [rtcPointQuery]. In this case the callback is invoked for all primitives in the scene that intersect the query domain. If a callback function is passed as an argument to [rtcPointQuery] and (a potentially different) callback function is set for a geometry with [rtcSetGeometryPointQueryFunction] both callback functions are invoked and the callback function passed to [rtcPointQuery] will be called before the geometry specific callback function.&lt;/p&gt; &#xA;&lt;p&gt;If instancing is used, the parameter &lt;code&gt;simliarityScale&lt;/code&gt; indicates whether the current instance transform (top element of the stack in &lt;code&gt;context&lt;/code&gt;) is a similarity transformation or not. Similarity transformations are composed of translation, rotation and uniform scaling and if a matrix M defines a similarity transformation, there is a scaling factor D such that for all x,y: dist(Mx, My) = D * dist(x, y). In this case the parameter &lt;code&gt;scalingFactor&lt;/code&gt; is this scaling factor D and otherwise it is 0. A valid similarity scale (&lt;code&gt;similarityScale&lt;/code&gt; &amp;gt; 0) allows to compute distance information in instance space and scale the distances into world space (for example, to update the query radius, see below) by dividing the instance space distance with the similarity scale. If the current instance transform is not a similarity transform (&lt;code&gt;similarityScale&lt;/code&gt; is 0), the distance computation has to be performed in world space to ensure correctness. In this case the instance to world transformations given with the &lt;code&gt;context&lt;/code&gt; should be used to transform the primitive data into world space. Otherwise, the query location can be transformed into instance space which can be more efficient. If there is no instance transform, the similarity scale is 1.&lt;/p&gt; &#xA;&lt;p&gt;The callback function will potentially be called for primitives outside the query domain for two reasons: First, the callback is invoked for all primitives inside a BVH leaf node since no geometry data of primitives is determined internally and therefore individual primitives are not culled (only their (aggregated) bounding boxes). Second, in case non similarity transformations are used, the resulting ellipsoidal query domain (in instance space) is approximated by its axis aligned bounding box internally and therefore inner nodes that do not intersect the original domain might intersect the approximative bounding box which results in unnecessary callbacks. In any case, the callbacks are conservative, i.e.&amp;nbsp;if a primitive is inside the query domain a callback will be invoked but the reverse is not necessarily true.&lt;/p&gt; &#xA;&lt;p&gt;For efficiency, the radius of the &lt;code&gt;query&lt;/code&gt; object can be decreased (in world space) inside the callback function to improve culling of geometry during BVH traversal. If the query radius was updated, the callback function should return &lt;code&gt;true&lt;/code&gt; to issue an update of internal traversal information. Increasing the radius or modifying the time or position of the query results in undefined behaviour.&lt;/p&gt; &#xA;&lt;p&gt;Within the callback function, it is safe to call [rtcPointQuery] again, for example when implementing instancing manually. In this case the instance transformation should be pushed onto the stack in &lt;code&gt;context&lt;/code&gt;. Embree will internally compute the point query information in instance space using the top element of the stack in &lt;code&gt;context&lt;/code&gt; when [rtcPointQuery] is called.&lt;/p&gt; &#xA;&lt;p&gt;For a reference implementation of a closest point traversal of triangle meshes using instancing and user defined instancing see the tutorial [ClosestPoint].&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcPointQuery], [rtcInitPointQueryContext]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetSYCLDeviceFunctionPointer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetSYCLDeviceFunctionPointer - obtains a device side&#xA;  function pointer for some SYCL function&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;template&amp;lt;auto F&amp;gt;&#xA;inline decltype(F) rtcGetSYCLDeviceFunctionPointer(sycl::queue&amp;amp; queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function returns a device side function pointer for some function F. This function F must be defined using the &lt;code&gt;RTC_SYCL_INDIRECTLY_CALLABLE&lt;/code&gt; attribute, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_SYCL_INDIRECTLY_CALLABLE void filter(&#xA;  const RTCFilterFunctionNArguments* args) { ... }&#xA;&#xA;RTCFilterFunctionN fptr = rtcGetSYCLDeviceFunctionPointer&amp;lt;filter&amp;gt;(queue);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Such a device side function pointers of some filter callbacks can get assigned to a geometry using the &lt;code&gt;rtcSetGeometryIntersectFilterFunction&lt;/code&gt; and &lt;code&gt;rtcSetGeometryOccludedFilterFunction&lt;/code&gt; API functions.&lt;/p&gt; &#xA;&lt;p&gt;Further, device side function pointers for user geometry callbacks can be assigned to geometries using the &lt;code&gt;rtcSetGeometryIntersectFunction&lt;/code&gt; and &lt;code&gt;rtcSetGeometryOccludedFunction&lt;/code&gt; API calls.&lt;/p&gt; &#xA;&lt;p&gt;These geometry versions of the callback functions are disabled in SYCL by default, and we recommend not using them for performance reasons.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryIntersectFunction], [rtcSetGeometryOccludedFunction], [rtcSetGeometryIntersectFilterFunction], [rtcSetGeometryOccludedFilterFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryInstancedScene&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryInstancedScene - sets the instanced scene of&#xA;  an instance geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryInstancedScene(&#xA;  RTCGeometry geometry,&#xA;  RTCScene scene&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryInstancedScene&lt;/code&gt; function sets the instanced scene (&lt;code&gt;scene&lt;/code&gt; argument) of the specified instance geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_INSTANCE], [rtcSetGeometryTransform]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryTransform&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryTransform - sets the transformation for a particular&#xA;  time step of an instance geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryTransform(&#xA;  RTCGeometry geometry,&#xA;  unsigned int timeStep,&#xA;  enum RTCFormat format,&#xA;  const float* xfm&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryTransform&lt;/code&gt; function sets the local-to-world affine transformation (&lt;code&gt;xfm&lt;/code&gt; parameter) of an instance geometry (&lt;code&gt;geometry&lt;/code&gt; parameter) for a particular time step (&lt;code&gt;timeStep&lt;/code&gt; parameter). The transformation is specified as a 3×4 matrix (3×3 linear transformation plus translation), for which the following formats (&lt;code&gt;format&lt;/code&gt; parameter) are supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_FORMAT_FLOAT3X4_ROW_MAJOR&lt;/code&gt;: The 3×4 float matrix is laid out in row-major form.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR&lt;/code&gt;: The 3×4 float matrix is laid out in column-major form.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR&lt;/code&gt;: The 3×4 float matrix is laid out in column-major form as a 4×4 homogeneous matrix with the last row being equal to (0, 0, 0, 1).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_INSTANCE]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryTransformQuaternion&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryTransformQuaternion - sets the transformation for a particular&#xA;  time step of an instance geometry as a decomposition of the&#xA;  transformation matrix using quaternions to represent the rotation.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryTransformQuaternion(&#xA;  RTCGeometry geometry,&#xA;  unsigned int timeStep,&#xA;  const struct RTCQuaternionDecomposition* qd&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryTransformQuaternion&lt;/code&gt; function sets the local-to-world affine transformation (&lt;code&gt;qd&lt;/code&gt; parameter) of an instance geometry (&lt;code&gt;geometry&lt;/code&gt; parameter) for a particular time step (&lt;code&gt;timeStep&lt;/code&gt; parameter). The transformation is specified as a [RTCQuaternionDecomposition], which is a decomposition of an affine transformation that represents the rotational component of an affine transformation as a quaternion. This allows interpolating rotational transformations exactly using spherical linear interpolation (such as a turning wheel).&lt;/p&gt; &#xA;&lt;p&gt;For more information about the decomposition see [RTCQuaternionDecomposition]. The quaternion given in the &lt;code&gt;RTCQuaternionDecomposition&lt;/code&gt; struct will be normalized internally.&lt;/p&gt; &#xA;&lt;p&gt;For correct results, the transformation matrices for all time steps must be set either using &lt;code&gt;rtcSetGeometryTransform&lt;/code&gt; or &lt;code&gt;rtcSetGeometryTransformQuaternion&lt;/code&gt;. Mixing both representations is not allowed. Spherical linear interpolation will be used, iff the transformation matizes are set with &lt;code&gt;rtcSetGeometryTransformQuaternion&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For an example of this feature see the tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#quaternion-motion-blur&#34;&gt;Quaternion Motion Blur&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInitQuaternionDecomposition], [rtcSetGeometryTransform]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryTransform&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryTransform - returns the interpolated instance&#xA;  transformation for the specified time&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcGetGeometryTransform(&#xA;  RTCGeometry geometry,&#xA;  float time,&#xA;  enum RTCFormat format,&#xA;  void* xfm&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryTransform&lt;/code&gt; function returns the interpolated local to world transformation (&lt;code&gt;xfm&lt;/code&gt; parameter) of an instance geometry (&lt;code&gt;geometry&lt;/code&gt; parameter) for a particular time (&lt;code&gt;time&lt;/code&gt; parameter in range $[0,1]$) in the specified format (&lt;code&gt;format&lt;/code&gt; parameter).&lt;/p&gt; &#xA;&lt;p&gt;Possible formats for the returned matrix are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_FORMAT_FLOAT3X4_ROW_MAJOR&lt;/code&gt;: The 3×4 float matrix is laid out in row-major form.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_FORMAT_FLOAT3X4_COLUMN_MAJOR&lt;/code&gt;: The 3×4 float matrix is laid out in column-major form.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_FORMAT_FLOAT4X4_COLUMN_MAJOR&lt;/code&gt;: The 3×4 float matrix is laid out in column-major form as a 4×4 homogeneous matrix with last row equal to (0, 0, 0, 1).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_INSTANCE], [rtcSetGeometryTransform]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryTessellationRate&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryTessellationRate - sets the tessellation rate of the&#xA;  geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryTessellationRate(&#xA;  RTCGeometry geometry,&#xA;  float tessellationRate&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryTessellationRate&lt;/code&gt; function sets the tessellation rate (&lt;code&gt;tessellationRate&lt;/code&gt; argument) for the specified geometry (&lt;code&gt;geometry&lt;/code&gt; argument). The tessellation rate can only be set for flat curves and subdivision geometries. For curves, the tessellation rate specifies the number of ray-facing quads per curve segment. For subdivision surfaces, the tessellation rate specifies the number of quads along each edge.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_CURVE], [RTC_GEOMETRY_TYPE_SUBDIVISION]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryTopologyCount&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryTopologyCount - sets the number of topologies of&#xA;  a subdivision geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryTopologyCount(&#xA;  RTCGeometry geometry,&#xA;  unsigned int topologyCount&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryTopologyCount&lt;/code&gt; function sets the number of topologies (&lt;code&gt;topologyCount&lt;/code&gt; parameter) for the specified subdivision geometry (&lt;code&gt;geometry&lt;/code&gt; parameter). The number of topologies of a subdivision geometry must be greater or equal to 1.&lt;/p&gt; &#xA;&lt;p&gt;To use multiple topologies, first the number of topologies must be specified, then the individual topologies can be configured using &lt;code&gt;rtcSetGeometrySubdivisionMode&lt;/code&gt; and by setting an index buffer (&lt;code&gt;RTC_BUFFER_TYPE_INDEX&lt;/code&gt;) using the topology ID as the buffer slot.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_SUBDIVISION], [rtcSetGeometrySubdivisionMode]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometrySubdivisionMode&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometrySubdivisionMode - sets the subdivision mode&#xA;  of a subdivision geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometrySubdivisionMode(&#xA;  RTCGeometry geometry,&#xA;  unsigned int topologyID,&#xA;  enum RTCSubdivisionMode mode&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometrySubdivisionMode&lt;/code&gt; function sets the subdivision mode (&lt;code&gt;mode&lt;/code&gt; parameter) for the topology (&lt;code&gt;topologyID&lt;/code&gt; parameter) of the specified subdivision geometry (&lt;code&gt;geometry&lt;/code&gt; parameter).&lt;/p&gt; &#xA;&lt;p&gt;The subdivision modes can be used to force linear interpolation for certain parts of the subdivision mesh:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SUBDIVISION_MODE_NO_BOUNDARY&lt;/code&gt;: Boundary patches are ignored. This way each rendered patch has a full set of control vertices.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SUBDIVISION_MODE_SMOOTH_BOUNDARY&lt;/code&gt;: The sequence of boundary control points are used to generate a smooth B-spline boundary curve (default mode).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SUBDIVISION_MODE_PIN_CORNERS&lt;/code&gt;: Corner vertices are pinned to their location during subdivision.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SUBDIVISION_MODE_PIN_BOUNDARY&lt;/code&gt;: All vertices at the border are pinned to their location during subdivision. This way the boundary is interpolated linearly. This mode is typically used for texturing to also map texels at the border of the texture to the mesh.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;RTC_SUBDIVISION_MODE_PIN_ALL&lt;/code&gt;: All vertices at the border are pinned to their location during subdivision. This way all patches are linearly interpolated.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_SUBDIVISION]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryVertexAttributeTopology&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryVertexAttributeTopology - binds a vertex&#xA;  attribute to a topology of the geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcSetGeometryVertexAttributeTopology(&#xA;  RTCGeometry geometry,&#xA;  unsigned int vertexAttributeID,&#xA;  unsigned int topologyID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryVertexAttributeTopology&lt;/code&gt; function binds a vertex attribute buffer slot (&lt;code&gt;vertexAttributeID&lt;/code&gt; argument) to a topology (&lt;code&gt;topologyID&lt;/code&gt; argument) for the specified subdivision geometry (&lt;code&gt;geometry&lt;/code&gt; argument). Standard vertex buffers are always bound to the default topology (topology 0) and cannot be bound differently. A vertex attribute buffer always uses the topology it is bound to when used in the &lt;code&gt;rtcInterpolate&lt;/code&gt; and &lt;code&gt;rtcInterpolateN&lt;/code&gt; calls.&lt;/p&gt; &#xA;&lt;p&gt;A topology with ID &lt;code&gt;i&lt;/code&gt; consists of a subdivision mode set through &lt;code&gt;rtcSetGeometrySubdivisionMode&lt;/code&gt; and the index buffer bound to the index buffer slot &lt;code&gt;i&lt;/code&gt;. This index buffer can assign indices for each face of the subdivision geometry that are different to the indices of the default topology. These new indices can for example be used to introduce additional borders into the subdivision mesh to map multiple textures onto one subdivision geometry.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometrySubdivisionMode], [rtcInterpolate], [rtcInterpolateN]&lt;/p&gt; &#xA;&lt;h2&gt;rtcSetGeometryDisplacementFunction&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcSetGeometryDisplacementFunction - sets the displacement function&#xA;  for a subdivision geometry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCDisplacementFunctionNArguments&#xA;{&#xA;  void* geometryUserPtr;&#xA;  RTCGeometry geometry;&#xA;  unsigned int primID;&#xA;  unsigned int timeStep;&#xA;  const float* u;&#xA;  const float* v;&#xA;  const float* Ng_x;&#xA;  const float* Ng_y;&#xA;  const float* Ng_z;&#xA;  float* P_x;&#xA;  float* P_y;&#xA;  float* P_z;&#xA;  unsigned int N;&#xA;};&#xA;&#xA;typedef void (*RTCDisplacementFunctionN)(&#xA;   const struct RTCDisplacementFunctionNArguments* args&#xA;);&#xA;&#xA;void rtcSetGeometryDisplacementFunction(&#xA;  RTCGeometry geometry,&#xA;  RTCDisplacementFunctionN displacement&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcSetGeometryDisplacementFunction&lt;/code&gt; function registers a displacement callback function (&lt;code&gt;displacement&lt;/code&gt; argument) for the specified subdivision geometry (&lt;code&gt;geometry&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;Only a single callback function can be registered per geometry, and further invocations overwrite the previously set callback function. Passing &lt;code&gt;NULL&lt;/code&gt; as function pointer disables the registered callback function.&lt;/p&gt; &#xA;&lt;p&gt;The registered displacement callback function is invoked to displace points on the subdivision geometry during spatial acceleration structure construction, during the &lt;code&gt;rtcCommitScene&lt;/code&gt; call.&lt;/p&gt; &#xA;&lt;p&gt;The callback function of type &lt;code&gt;RTCDisplacementFunctionN&lt;/code&gt; is invoked with a number of arguments stored inside the &lt;code&gt;RTCDisplacementFunctionNArguments&lt;/code&gt; structure. The provided user data pointer of the geometry (&lt;code&gt;geometryUserPtr&lt;/code&gt; member) can be used to point to the application&#39;s representation of the subdivision mesh. A number &lt;code&gt;N&lt;/code&gt; of points to displace are specified in a structure of array layout. For each point to displace, the local patch UV coordinates (&lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; arrays), the normalized geometry normal (&lt;code&gt;Ng_x&lt;/code&gt;, &lt;code&gt;Ng_y&lt;/code&gt;, and &lt;code&gt;Ng_z&lt;/code&gt; arrays), and the position (&lt;code&gt;P_x&lt;/code&gt;, &lt;code&gt;P_y&lt;/code&gt;, and &lt;code&gt;P_z&lt;/code&gt; arrays) are provided. The task of the displacement function is to use this information and change the position data.&lt;/p&gt; &#xA;&lt;p&gt;The geometry handle (&lt;code&gt;geometry&lt;/code&gt; member) and primitive ID (&lt;code&gt;primID&lt;/code&gt; member) of the patch to displace are additionally provided as well as the time step &lt;code&gt;timeStep&lt;/code&gt;, which can be important if the displacement is time-dependent and motion blur is used.&lt;/p&gt; &#xA;&lt;p&gt;All passed arrays must be aligned to 64 bytes and properly padded to make wide vector processing inside the displacement function easily possible.&lt;/p&gt; &#xA;&lt;p&gt;Also see tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#displacement-geometry&#34;&gt;Displacement Geometry&lt;/a&gt; for an example of how to use the displacement mapping functions.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTC_GEOMETRY_TYPE_SUBDIVISION]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryFirstHalfEdge&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryFirstHalfEdge - returns the first half edge of a face&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;unsigned int rtcGetGeometryFirstHalfEdge(&#xA;  RTCGeometry geometry,&#xA;  unsigned int faceID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryFirstHalfEdge&lt;/code&gt; function returns the ID of the first half edge belonging to the specified face (&lt;code&gt;faceID&lt;/code&gt; argument). For instance in the following example the first half edge of face &lt;code&gt;f1&lt;/code&gt; is &lt;code&gt;e4&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/half_edges.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.&lt;/p&gt; &#xA;&lt;p&gt;Here f0 to f7 are 8 quadrilateral faces with 4 vertices each. The edges e0 to e23 of these faces are shown with their orientation. For each face the ID of the edges corresponds to the slots the face occupies in the index array of the geometry. E.g. as the indices of face f1 start at location 4 of the index array, the first edge is edge e4, the next edge e5, etc.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetGeometryFirstHalfEdge], [rtcGetGeometryFace], [rtcGetGeometryOppositeHalfEdge], [rtcGetGeometryNextHalfEdge], [rtcGetGeometryPreviousHalfEdge]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryFace&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryFace - returns the face of some half edge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;unsigned int rtcGetGeometryFace(&#xA;  RTCGeometry geometry,&#xA;  unsigned int edgeID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryFace&lt;/code&gt; function returns the ID of the face the specified half edge (&lt;code&gt;edgeID&lt;/code&gt; argument) belongs to. For instance in the following example the face &lt;code&gt;f1&lt;/code&gt; is returned for edges &lt;code&gt;e4&lt;/code&gt;, &lt;code&gt;e5&lt;/code&gt;, &lt;code&gt;e6&lt;/code&gt;, and &lt;code&gt;e7&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/half_edges.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetGeometryFirstHalfEdge], [rtcGetGeometryFace], [rtcGetGeometryOppositeHalfEdge], [rtcGetGeometryNextHalfEdge], [rtcGetGeometryPreviousHalfEdge]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryNextHalfEdge&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryNextHalfEdge - returns the next half edge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;unsigned int rtcGetGeometryNextHalfEdge(&#xA;  RTCGeometry geometry,&#xA;  unsigned int edgeID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryNextHalfEdge&lt;/code&gt; function returns the ID of the next half edge of the specified half edge (&lt;code&gt;edgeID&lt;/code&gt; argument). For instance in the following example the next half edge of &lt;code&gt;e10&lt;/code&gt; is &lt;code&gt;e11&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/half_edges.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetGeometryFirstHalfEdge], [rtcGetGeometryFace], [rtcGetGeometryOppositeHalfEdge], [rtcGetGeometryNextHalfEdge], [rtcGetGeometryPreviousHalfEdge]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryPreviousHalfEdge&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryPreviousHalfEdge - returns the previous half edge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;unsigned int rtcGetGeometryPreviousHalfEdge(&#xA;  RTCGeometry geometry,&#xA;  unsigned int edgeID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryPreviousHalfEdge&lt;/code&gt; function returns the ID of the previous half edge of the specified half edge (&lt;code&gt;edgeID&lt;/code&gt; argument). For instance in the following example the previous half edge of &lt;code&gt;e6&lt;/code&gt; is &lt;code&gt;e5&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/half_edges.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This function can only be used for subdivision geometries. As all topologies of a subdivision geometry share the same face buffer the function does not depend on the topology ID.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetGeometryFirstHalfEdge], [rtcGetGeometryFace], [rtcGetGeometryOppositeHalfEdge], [rtcGetGeometryNextHalfEdge], [rtcGetGeometryPreviousHalfEdge]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetGeometryOppositeHalfEdge&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetGeometryOppositeHalfEdge - returns the opposite half edge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;unsigned int rtcGetGeometryOppositeHalfEdge(&#xA;  RTCGeometry geometry,&#xA;  unsigned int topologyID,&#xA;  unsigned int edgeID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetGeometryOppositeHalfEdge&lt;/code&gt; function returns the ID of the opposite half edge of the specified half edge (&lt;code&gt;edgeID&lt;/code&gt; argument) in the specified topology (&lt;code&gt;topologyID&lt;/code&gt; argument). For instance in the following example the opposite half edge of &lt;code&gt;e6&lt;/code&gt; is &lt;code&gt;e16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://embree.github.io/images/half_edges.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;An opposite half edge does not exist if the specified half edge has either no neighboring face, or more than 2 neighboring faces. In these cases the function just returns the same edge &lt;code&gt;edgeID&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;p&gt;This function can only be used for subdivision geometries. The function depends on the topology as the topologies of a subdivision geometry have different index buffers assigned.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcGetGeometryFirstHalfEdge], [rtcGetGeometryFace], [rtcGetGeometryOppositeHalfEdge], [rtcGetGeometryNextHalfEdge], [rtcGetGeometryPreviousHalfEdge]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInterpolate&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInterpolate - interpolates vertex attributes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCInterpolateArguments&#xA;{&#xA;  RTCGeometry geometry;&#xA;  unsigned int primID;&#xA;  float u;&#xA;  float v;&#xA;  enum RTCBufferType bufferType;&#xA;  unsigned int bufferSlot;&#xA;  float* P;&#xA;  float* dPdu;&#xA;  float* dPdv;&#xA;  float* ddPdudu;&#xA;  float* ddPdvdv;&#xA;  float* ddPdudv;&#xA;  unsigned int valueCount;&#xA;};&#xA;&#xA;void rtcInterpolate(&#xA;  const struct RTCInterpolateArguments* args&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInterpolate&lt;/code&gt; function smoothly interpolates per-vertex data over the geometry. This interpolation is supported for triangle meshes, quad meshes, curve geometries, and subdivision geometries. Apart from interpolating the vertex attribute itself, it is also possible to get the first and second order derivatives of that value. This interpolation ignores displacements of subdivision surfaces and always interpolates the underlying base surface.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInterpolate&lt;/code&gt; call gets passed a number of arguments inside a structure of type &lt;code&gt;RTCInterpolateArguments&lt;/code&gt;. For some geometry (&lt;code&gt;geometry&lt;/code&gt; parameter) this function smoothly interpolates the per-vertex data stored inside the specified geometry buffer (&lt;code&gt;bufferType&lt;/code&gt; and &lt;code&gt;bufferSlot&lt;/code&gt; parameters) to the u/v location (&lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; parameters) of the primitive (&lt;code&gt;primID&lt;/code&gt; parameter). The number of floating point values to interpolate and store to the destination arrays can be specified using the &lt;code&gt;valueCount&lt;/code&gt; parameter. As interpolation buffer, one can specify vertex buffers (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt;) and vertex attribute buffers (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt;) as well.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInterpolate&lt;/code&gt; call stores &lt;code&gt;valueCount&lt;/code&gt; number of interpolated floating point values to the memory location pointed to by &lt;code&gt;P&lt;/code&gt;. One can avoid storing the interpolated value by setting &lt;code&gt;P&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The first order derivative of the interpolation by u and v are stored at the &lt;code&gt;dPdu&lt;/code&gt; and &lt;code&gt;dPdv&lt;/code&gt; memory locations. One can avoid storing first order derivatives by setting both &lt;code&gt;dPdu&lt;/code&gt; and &lt;code&gt;dPdv&lt;/code&gt; to &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The second order derivatives are stored at the &lt;code&gt;ddPdudu&lt;/code&gt;, &lt;code&gt;ddPdvdv&lt;/code&gt;, and &lt;code&gt;ddPdudv&lt;/code&gt; memory locations. One can avoid storing second order derivatives by setting these three pointers to &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To use &lt;code&gt;rtcInterpolate&lt;/code&gt; for a geometry, all changes to that geometry must be properly committed using &lt;code&gt;rtcCommitGeometry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;All input buffers and output arrays must be padded to 16 bytes, as the implementation uses 16-byte SSE instructions to read and write into these buffers.&lt;/p&gt; &#xA;&lt;p&gt;See tutorial &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#interpolation&#34;&gt;Interpolation&lt;/a&gt; for an example of using the &lt;code&gt;rtcInterpolate&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInterpolateN]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInterpolateN&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInterpolateN - performs N interpolations of vertex attribute data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCInterpolateNArguments&#xA;{&#xA;  RTCGeometry geometry;&#xA;  const void* valid;&#xA;  const unsigned int* primIDs;&#xA;  const float* u;&#xA;  const float* v;&#xA;  unsigned int N;&#xA;  enum RTCBufferType bufferType;&#xA;  unsigned int bufferSlot;&#xA;  float* P;&#xA;  float* dPdu;&#xA;  float* dPdv;&#xA;  float* ddPdudu;&#xA;  float* ddPdvdv;&#xA;  float* ddPdudv;&#xA;  unsigned int valueCount;&#xA;};&#xA;&#xA;void rtcInterpolateN(&#xA;  const struct RTCInterpolateNArguments* args&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInterpolateN&lt;/code&gt; is similar to &lt;code&gt;rtcInterpolate&lt;/code&gt;, but performs &lt;code&gt;N&lt;/code&gt; many interpolations at once. It additionally gets an array of u/v coordinates and a valid mask (&lt;code&gt;valid&lt;/code&gt; parameter) that specifies which of these coordinates are valid. The valid mask points to &lt;code&gt;N&lt;/code&gt; integers, and a value of -1 denotes valid and 0 invalid. If the valid pointer is &lt;code&gt;NULL&lt;/code&gt; all elements are considers valid. The destination arrays are filled in structure of array (SOA) layout. The value &lt;code&gt;N&lt;/code&gt; must be divisible by 4.&lt;/p&gt; &#xA;&lt;p&gt;To use &lt;code&gt;rtcInterpolateN&lt;/code&gt; for a geometry, all changes to that geometry must be properly committed using &lt;code&gt;rtcCommitGeometry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcInterpolate]&lt;/p&gt; &#xA;&lt;h2&gt;rtcNewBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewBuffer - creates a new data buffer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCBuffer rtcNewBuffer(&#xA;  RTCDevice device,&#xA;  size_t byteSize&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcNewBuffer&lt;/code&gt; function creates a new data buffer object of specified size in bytes (&lt;code&gt;byteSize&lt;/code&gt; argument) that is bound to the specified device (&lt;code&gt;device&lt;/code&gt; argument). The buffer object is reference counted with an initial reference count of 1. The returned buffer object can be released using the &lt;code&gt;rtcReleaseBuffer&lt;/code&gt; API call. The specified number of bytes are allocated at buffer construction time and deallocated when the buffer is destroyed.&lt;/p&gt; &#xA;&lt;p&gt;When the buffer will be used as a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; and &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt;), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard &lt;code&gt;float3&lt;/code&gt; vertex buffer layout should add storage for at least one more float to the end of the buffer.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcRetainBuffer], [rtcReleaseBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcNewSharedBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewSharedBuffer - creates a new shared data buffer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCBuffer rtcNewSharedBuffer(&#xA;  RTCDevice device,&#xA;  void* ptr,&#xA;  size_t byteSize&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcNewSharedBuffer&lt;/code&gt; function creates a new shared data buffer object bound to the specified device (&lt;code&gt;device&lt;/code&gt; argument). The buffer object is reference counted with an initial reference count of 1. The buffer can be released using the &lt;code&gt;rtcReleaseBuffer&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;At construction time, the pointer to the user-managed buffer data (&lt;code&gt;ptr&lt;/code&gt; argument) including its size in bytes (&lt;code&gt;byteSize&lt;/code&gt; argument) is provided to create the buffer. At buffer construction time no buffer data is allocated, but the buffer data provided by the application is used. The buffer data must remain valid for as long as the buffer may be used, and the user is responsible to free the buffer data when no longer required.&lt;/p&gt; &#xA;&lt;p&gt;When the buffer will be used as a vertex buffer (&lt;code&gt;RTC_BUFFER_TYPE_VERTEX&lt;/code&gt; and &lt;code&gt;RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE&lt;/code&gt;), the last buffer element must be readable using 16-byte SSE load instructions, thus padding the last element is required for certain layouts. E.g. a standard &lt;code&gt;float3&lt;/code&gt; vertex buffer layout should add storage for at least one more float to the end of the buffer.&lt;/p&gt; &#xA;&lt;p&gt;The data pointer (&lt;code&gt;ptr&lt;/code&gt; argument) must be aligned to 4 bytes; otherwise the &lt;code&gt;rtcNewSharedBuffer&lt;/code&gt; function will fail.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure &lt;code&gt;NULL&lt;/code&gt; is returned and an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcRetainBuffer], [rtcReleaseBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcRetainBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcRetainBuffer - increments the buffer reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcRetainBuffer(RTCBuffer buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Buffer objects are reference counted. The &lt;code&gt;rtcRetainBuffer&lt;/code&gt; function increments the reference count of the passed buffer object (&lt;code&gt;buffer&lt;/code&gt; argument). This function together with &lt;code&gt;rtcReleaseBuffer&lt;/code&gt; allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewBuffer], [rtcReleaseBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcReleaseBuffer&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcReleaseBuffer - decrements the buffer reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcReleaseBuffer(RTCBuffer buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;Buffer objects are reference counted. The &lt;code&gt;rtcReleaseBuffer&lt;/code&gt; function decrements the reference count of the passed buffer object (&lt;code&gt;buffer&lt;/code&gt; argument). When the reference count falls to 0, the buffer gets destroyed.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewBuffer], [rtcRetainBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;rtcGetBufferData&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcGetBufferData - gets a pointer to the buffer data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void* rtcGetBufferData(RTCBuffer buffer);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcGetBufferData&lt;/code&gt; function returns a pointer to the buffer data of the specified buffer object (&lt;code&gt;buffer&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewBuffer]&lt;/p&gt; &#xA;&lt;h2&gt;RTCRay&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCRay - single ray structure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;struct RTC_ALIGN(16) RTCRay&#xA;{&#xA;  float org_x;        // x coordinate of ray origin&#xA;  float org_y;        // y coordinate of ray origin&#xA;  float org_z;        // z coordinate of ray origin&#xA;  float tnear;        // start of ray segment&#xA;&#xA;  float dir_x;        // x coordinate of ray direction&#xA;  float dir_y;        // y coordinate of ray direction&#xA;  float dir_z;        // z coordinate of ray direction&#xA;  float time;         // time of this ray for motion blur&#xA;&#xA;  float tfar;         // end of ray segment (set to hit distance)&#xA;  unsigned int mask;  // ray mask&#xA;  unsigned int id;    // ray ID&#xA;  unsigned int flags; // ray flags&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCRay&lt;/code&gt; structure defines the ray layout for a single ray. The ray contains the origin (&lt;code&gt;org_x&lt;/code&gt;, &lt;code&gt;org_y&lt;/code&gt;, &lt;code&gt;org_z&lt;/code&gt; members), direction vector (&lt;code&gt;dir_x&lt;/code&gt;, &lt;code&gt;dir_y&lt;/code&gt;, &lt;code&gt;dir_z&lt;/code&gt; members), and ray segment (&lt;code&gt;tnear&lt;/code&gt; and &lt;code&gt;tfar&lt;/code&gt; members). The ray direction does not have to be normalized, and only the parameter range specified by the &lt;code&gt;tnear&lt;/code&gt;/&lt;code&gt;tfar&lt;/code&gt; interval is considered valid.&lt;/p&gt; &#xA;&lt;p&gt;The ray segment must be in the range $[0, \infty]$, thus ranges that start behind the ray origin are not allowed, but ranges can reach to infinity.&lt;/p&gt; &#xA;&lt;p&gt;The ray further contains a motion blur time in the range $[0, 1]$ (&lt;code&gt;time&lt;/code&gt; member), a ray mask (&lt;code&gt;mask&lt;/code&gt; member), a ray ID (&lt;code&gt;id&lt;/code&gt; member), and ray flags (&lt;code&gt;flags&lt;/code&gt; member). The ray mask can be used to mask out some geometries for some rays (see &lt;code&gt;rtcSetGeometryMask&lt;/code&gt; for more details). The ray ID can be used to identify a ray inside a callback function, even if the order of rays inside a ray packet has changed.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;embree4/rtcore_ray.h&lt;/code&gt; header additionally defines the same ray structure in structure of array (SOA) layout for API functions accepting ray packets of size 4 (&lt;code&gt;RTCRay4&lt;/code&gt; type), size 8 (&lt;code&gt;RTCRay8&lt;/code&gt; type), and size 16 (&lt;code&gt;RTCRay16&lt;/code&gt; type). The header additionally defines an &lt;code&gt;RTCRayNt&lt;/code&gt; template for ray packets of an arbitrary compile-time size.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCHit]&lt;/p&gt; &#xA;&lt;h2&gt;RTCHit&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCHit - single hit structure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCHit&#xA;{&#xA;  float Ng_x;                                        // x coordinate of geometry normal&#xA;  float Ng_y;                                        // y coordinate of geometry normal&#xA;  float Ng_z;                                        // z coordinate of geometry normal&#xA;&#xA;  float u;                                           // barycentric u coordinate of hit&#xA;  float v;                                           // barycentric v coordinate of hit&#xA;&#xA;  unsigned int primID;                               // geometry ID&#xA;  unsigned int geomID;                               // primitive ID&#xA;  unsigned int instID[RTC_MAX_INSTANCE_LEVEL_COUNT]; // instance ID&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCHit&lt;/code&gt; type defines the type of a ray/primitive intersection result. The hit contains the unnormalized geometric normal in object space at the hit location (&lt;code&gt;Ng_x&lt;/code&gt;, &lt;code&gt;Ng_y&lt;/code&gt;, &lt;code&gt;Ng_z&lt;/code&gt; members), the barycentric u/v coordinates of the hit (&lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; members), as well as the primitive ID (&lt;code&gt;primID&lt;/code&gt; member), geometry ID (&lt;code&gt;geomID&lt;/code&gt; member), and instance ID stack (&lt;code&gt;instID&lt;/code&gt; member) of the hit. The parametric intersection distance is not stored inside the hit, but stored inside the &lt;code&gt;tfar&lt;/code&gt; member of the ray.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;embree4/rtcore_ray.h&lt;/code&gt; header additionally defines the same hit structure in structure of array (SOA) layout for hit packets of size 4 (&lt;code&gt;RTCHit4&lt;/code&gt; type), size 8 (&lt;code&gt;RTCHit8&lt;/code&gt; type), and size 16 (&lt;code&gt;RTCHit16&lt;/code&gt; type). The header additionally defines an &lt;code&gt;RTCHitNt&lt;/code&gt; template for hit packets of an arbitrary compile-time size.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCRay], [Multi-Level Instancing]&lt;/p&gt; &#xA;&lt;h2&gt;RTCRayHit&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCRayHit - combined single ray/hit structure&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;struct RTCORE_ALIGN(16) RTCRayHit&#xA;{&#xA;  struct RTCRay ray;&#xA;  struct RTCHit hit;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCRayHit&lt;/code&gt; structure is used as input for the &lt;code&gt;rtcIntersect&lt;/code&gt;-type functions and stores the ray to intersect and some hit fields that hold the intersection result afterwards.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;embree4/rtcore_ray.h&lt;/code&gt; header additionally defines the same ray/hit structure in structure of array (SOA) layout for API functions accepting ray packets of size 4 (&lt;code&gt;RTCRayHit4&lt;/code&gt; type), size 8 (&lt;code&gt;RTCRayHit8&lt;/code&gt; type), and size 16 (&lt;code&gt;RTCRayHit16&lt;/code&gt; type). The header additionally defines an &lt;code&gt;RTCRayHitNt&lt;/code&gt; template to generate ray/hit packets of an arbitrary compile-time size.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCRay], [RTCHit]&lt;/p&gt; &#xA;&lt;h2&gt;RTCRayN&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCRayN - ray packet of runtime size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;struct RTCRayN;&#xA;&#xA;float&amp;amp; RTCRayN_org_x(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCRayN_org_y(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCRayN_org_z(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCRayN_tnear(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;&#xA;float&amp;amp; RTCRayN_dir_x(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCRayN_dir_y(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCRayN_dir_z(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCRayN_time (RTCRayN* ray, unsigned int N, unsigned int i);&#xA;&#xA;float&amp;amp;        RTCRayN_tfar (RTCRayN* ray, unsigned int N, unsigned int i);&#xA;unsigned int&amp;amp; RTCRayN_mask (RTCRayN* ray, unsigned int N, unsigned int i);&#xA;unsigned int&amp;amp; RTCRayN_id   (RTCRayN* ray, unsigned int N, unsigned int i);&#xA;unsigned int&amp;amp; RTCRayN_flags(RTCRayN* ray, unsigned int N, unsigned int i);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;When the ray packet size is not known at compile time (e.g.&amp;nbsp;when Embree returns a ray packet in the &lt;code&gt;RTCFilterFuncN&lt;/code&gt; callback function), Embree uses the &lt;code&gt;RTCRayN&lt;/code&gt; type for ray packets. These ray packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.&lt;/p&gt; &#xA;&lt;p&gt;You can either implement different special code paths for each of these possible packet sizes and cast the ray to the appropriate ray packet type, or implement one general code path that uses the &lt;code&gt;RTCRayN_XXX&lt;/code&gt; helper functions to access the ray packet components.&lt;/p&gt; &#xA;&lt;p&gt;These helper functions get a pointer to the ray packet (&lt;code&gt;ray&lt;/code&gt; argument), the packet size (&lt;code&gt;N&lt;/code&gt; argument), and returns a reference to a component (e.g.&amp;nbsp;x-component of origin) of the the i-th ray of the packet (&lt;code&gt;i&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCHitN]&lt;/p&gt; &#xA;&lt;h2&gt;RTCHitN&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCHitN - hit packet of runtime size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct HitN;&#xA;&#xA;float&amp;amp; RTCHitN_Ng_x(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCHitN_Ng_y(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCHitN_Ng_z(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;&#xA;float&amp;amp; RTCHitN_u(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;float&amp;amp; RTCHitN_v(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;&#xA;unsigned&amp;amp; RTCHitN_primID(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;unsigned&amp;amp; RTCHitN_geomID(RTCHitN* hit, unsigned int N, unsigned int i);&#xA;unsigned&amp;amp; RTCHitN_instID(RTCHitN* hit, unsigned int N, unsigned int i, unsigned int level);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;When the hit packet size is not known at compile time (e.g.&amp;nbsp;when Embree returns a hit packet in the &lt;code&gt;RTCFilterFuncN&lt;/code&gt; callback function), Embree uses the &lt;code&gt;RTCHitN&lt;/code&gt; type for hit packets. These hit packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.&lt;/p&gt; &#xA;&lt;p&gt;You can either implement different special code paths for each of these possible packet sizes and cast the hit to the appropriate hit packet type, or implement one general code path that uses the &lt;code&gt;RTCHitN_XXX&lt;/code&gt; helper functions to access hit packet components.&lt;/p&gt; &#xA;&lt;p&gt;These helper functions get a pointer to the hit packet (&lt;code&gt;hit&lt;/code&gt; argument), the packet size (&lt;code&gt;N&lt;/code&gt; argument), and returns a reference to a component (e.g.&amp;nbsp;x component of &lt;code&gt;Ng&lt;/code&gt;) of the the i-th hit of the packet (&lt;code&gt;i&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCRayN]&lt;/p&gt; &#xA;&lt;h2&gt;RTCRayHitN&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCRayHitN - combined ray/hit packet of runtime size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;struct RTCRayHitN;&#xA;&#xA;struct RTCRayN* RTCRayHitN_RayN(struct RTCRayHitN* rayhit, unsigned int N);&#xA;struct RTCHitN* RTCRayHitN_HitN(struct RTCRayHitN* rayhit, unsigned int N);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;When the packet size of a ray/hit structure is not known at compile time (e.g.&amp;nbsp;when Embree returns a ray/hit packet in the &lt;code&gt;RTCIntersectFunctionN&lt;/code&gt; callback function), Embree uses the &lt;code&gt;RTCRayHitN&lt;/code&gt; type for ray packets. These ray/hit packets can only have sizes of 1, 4, 8, or 16. No other packet size will be used.&lt;/p&gt; &#xA;&lt;p&gt;You can either implement different special code paths for each of these possible packet sizes and cast the ray/hit to the appropriate ray/hit packet type, or extract the &lt;code&gt;RTCRayN&lt;/code&gt; and &lt;code&gt;RTCHitN&lt;/code&gt; components using the &lt;code&gt;rtcGetRayN&lt;/code&gt; and &lt;code&gt;rtcGetHitN&lt;/code&gt; helper functions and use the &lt;code&gt;RTCRayN_XXX&lt;/code&gt; and &lt;code&gt;RTCHitN_XXX&lt;/code&gt; functions to access the ray and hit parts of the structure.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[RTCHitN]&lt;/p&gt; &#xA;&lt;h2&gt;RTCFeatureFlags&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCFeatureFlags - specifies features to enable&#xA;  for ray queries&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore_ray.h&amp;gt;&#xA;&#xA;enum RTCFeatureFlags&#xA;{&#xA;  RTC_FEATURE_FLAG_NONE = 0,&#xA;  &#xA;  RTC_FEATURE_FLAG_MOTION_BLUR = 1 &amp;lt;&amp;lt; 0,&#xA;&#xA;  RTC_FEATURE_FLAG_TRIANGLE = 1 &amp;lt;&amp;lt; 1,&#xA;  RTC_FEATURE_FLAG_QUAD = 1 &amp;lt;&amp;lt; 2,&#xA;  RTC_FEATURE_FLAG_GRID = 1 &amp;lt;&amp;lt; 3,&#xA;  RTC_FEATURE_FLAG_SUBDIVISION = 1 &amp;lt;&amp;lt; 4,&#xA;  RTC_FEATURE_FLAG_POINT = ... ,&#xA;  RTC_FEATURE_FLAG_CURVES = ... ,&#xA; &#xA;  RTC_FEATURE_FLAG_CONE_LINEAR_CURVE = 1 &amp;lt;&amp;lt; 5,&#xA;  RTC_FEATURE_FLAG_ROUND_LINEAR_CURVE  = 1 &amp;lt;&amp;lt; 6,&#xA;  RTC_FEATURE_FLAG_FLAT_LINEAR_CURVE = 1 &amp;lt;&amp;lt; 7,&#xA;&#xA;  RTC_FEATURE_FLAG_ROUND_BEZIER_CURVE = 1 &amp;lt;&amp;lt; 8,&#xA;  RTC_FEATURE_FLAG_FLAT_BEZIER_CURVE = 1 &amp;lt;&amp;lt; 9,&#xA;  RTC_FEATURE_FLAG_NORMAL_ORIENTED_BEZIER_CURVE = 1 &amp;lt;&amp;lt; 10,&#xA;&#xA;  RTC_FEATURE_FLAG_ROUND_BSPLINE_CURVE = 1 &amp;lt;&amp;lt; 11,&#xA;  RTC_FEATURE_FLAG_FLAT_BSPLINE_CURVE = 1 &amp;lt;&amp;lt; 12,&#xA;  RTC_FEATURE_FLAG_NORMAL_ORIENTED_BSPLINE_CURVE = 1 &amp;lt;&amp;lt; 13,&#xA;&#xA;  RTC_FEATURE_FLAG_ROUND_HERMITE_CURVE = 1 &amp;lt;&amp;lt; 14,&#xA;  RTC_FEATURE_FLAG_FLAT_HERMITE_CURVE = 1 &amp;lt;&amp;lt; 15,&#xA;  RTC_FEATURE_FLAG_NORMAL_ORIENTED_HERMITE_CURVE = 1 &amp;lt;&amp;lt; 16,&#xA;&#xA;  RTC_FEATURE_FLAG_ROUND_CATMULL_ROM_CURVE = 1 &amp;lt;&amp;lt; 17,&#xA;  RTC_FEATURE_FLAG_FLAT_CATMULL_ROM_CURVE = 1 &amp;lt;&amp;lt; 18,&#xA;  RTC_FEATURE_FLAG_NORMAL_ORIENTED_CATMULL_ROM_CURVE = 1 &amp;lt;&amp;lt; 19,&#xA;&#xA;  RTC_FEATURE_FLAG_SPHERE_POINT = 1 &amp;lt;&amp;lt; 20,&#xA;  RTC_FEATURE_FLAG_DISC_POINT = 1 &amp;lt;&amp;lt; 21,&#xA;  RTC_FEATURE_FLAG_ORIENTED_DISC_POINT = 1 &amp;lt;&amp;lt; 22,&#xA;&#xA;  RTC_FEATURE_FLAG_ROUND_CURVES = ... ,&#xA;  RTC_FEATURE_FLAG_FLAT_CURVES = ... ,&#xA;  RTC_FEATURE_FLAG_NORMAL_ORIENTED_CURVES = ... ,&#xA;  &#xA;  RTC_FEATURE_FLAG_LINEAR_CURVES = ... ,&#xA;  RTC_FEATURE_FLAG_BEZIER_CURVES = ... ,&#xA;  RTC_FEATURE_FLAG_BSPLINE_CURVES = ... ,&#xA;  RTC_FEATURE_FLAG_HERMITE_CURVES = ... ,&#xA;  &#xA;  RTC_FEATURE_FLAG_INSTANCE = 1 &amp;lt;&amp;lt; 23,&#xA;&#xA;  RTC_FEATURE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS = 1 &amp;lt;&amp;lt; 24,&#xA;  RTC_FEATURE_FLAG_FILTER_FUNCTION_IN_GEOMETRY = 1 &amp;lt;&amp;lt; 25,&#xA;  RTC_FEATURE_FLAG_FILTER_FUNCTION = ... ,&#xA;&#xA;  RTC_FEATURE_FLAG_USER_GEOMETRY_CALLBACK_IN_ARGUMENTS = 1 &amp;lt;&amp;lt; 26,&#xA;  RTC_FEATURE_FLAG_USER_GEOMETRY_CALLBACK_IN_GEOMETRY = 1 &amp;lt;&amp;lt; 27,&#xA;  RTC_FEATURE_FLAG_USER_GEOMETRY = ... ,&#xA;&#xA;  RTC_FEATURE_FLAG_32_BIT_RAY_MASK = 1 &amp;lt;&amp;lt; 28,&#xA;&#xA;  RTC_FEATURE_FLAG_ALL = 0xffffffff&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCFeatureFlags&lt;/code&gt; enum specify a bit mask to enable specific ray tracing features for ray query operations. The feature flags are passed to the &lt;code&gt;rtcIntersect1/4/8/16&lt;/code&gt; and &lt;code&gt;rtcOccluded1/4/8/16&lt;/code&gt; functions through the &lt;code&gt;RTCIntersectArguments&lt;/code&gt; and &lt;code&gt;RTCOccludedArguments&lt;/code&gt; structures. Only a ray tracing feature whose bit is enabled in the feature mask can get used. If a feature bit is not set, the behaviour is undefined, thus the feature may work or not. To enable multiple features the respective features have to get combined using a bitwise &lt;code&gt;OR&lt;/code&gt; operation.&lt;/p&gt; &#xA;&lt;p&gt;The purpose of feature flags is to reduce code size on the GPU by enabling just the features required to render the scene. On the CPU there is no need to use feature flags, and the default of all features enabled (&lt;code&gt;RTC_FEATURE_FLAG_ALL&lt;/code&gt;) can just be kept.&lt;/p&gt; &#xA;&lt;p&gt;The following features can get enabled using feature flags:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_MOTION_BLUR: Enables motion blur for all geometry types.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_TRIANGLE: Enables triangle geometries (RTC_GEOMETRY_TYPE_TRIANGLE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_QUAD: Enables quad geometries (RTC_GEOMETRY_TYPE_QUAD).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_GRID: Enables grid geometries (RTC_GEOMETRY_TYPE_GRID).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_SUBDIVISION: Enables subdivision geometries (RTC_GEOMETRY_TYPE_SUBDIVISION).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_POINT: Enables all point geometry types (RTC_GEOMETRY_TYPE_XXX_POINT)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_CURVES: Enables all curve geometry types (RTC_GEOMETRY_TYPE_XXX_YYY_CURVE)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ROUND_CURVES: Enables all round curves (RTC_GEOMETRY_TYPE_ROUND_XXX_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FLAT_CURVES: Enables all flat curves (RTC_GEOMETRY_TYPE_FLAT_XXX_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_NORMAL_ORIENTED_CURVES: Enables all normal oriented curves (RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_XXX_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_LINEAR_CURVES: Enables all linear curves (RTC_GEOMETRY_TYPE_XXX_LINEAR_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_BEZIER_CURVES: Enables all Bézier curves (RTC_GEOMETRY_TYPE_XXX_BEZIER_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_BSPLINE_CURVES: Enables all B-spline curves (RTC_GEOMETRY_TYPE_XXX_BSPLINE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_HERMITE_CURVES: Enables all Hermite curves (RTC_GEOMETRY_TYPE_XXX_HERMITE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_CONE_LINEAR_CURVE: Enables cone geometry type (RTC_GEOMETRY_TYPE_CONE_LINEAR_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ROUND_LINEAR_CURVE: Enables round linear curves (RTC_GEOMETRY_TYPE_ROUND_LINEAR_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FLAT_LINEAR_CURVE: Enables flat linear curves (RTC_GEOMETRY_TYPE_FLAT_LINEAR_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ROUND_BEZIER_CURVE: Enables round Bézier curves (RTC_GEOMETRY_TYPE_ROUND_BEZIER_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FLAT_BEZIER_CURVE: Enables flat Bézier curves (RTC_GEOMETRY_TYPE_FLAT_BEZIER_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_NORMAL_ORIENTED_BEZIER_CURVE: Enables normal oriented Bézier curves (RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BEZIER_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ROUND_BSPLINE_CURVE: Enables round B-spline curves (RTC_GEOMETRY_TYPE_ROUND_BSPLINE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FLAT_BSPLINE_CURVE: Enables flat B-spline curves (RTC_GEOMETRY_TYPE_FLAT_BSPLINE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_NORMAL_ORIENTED_BSPLINE_CURVE: Enables normal oriented B-spline curves (RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_BSPLINE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ROUND_HERMITE_CURVE: Enables round Hermite curves (RTC_GEOMETRY_TYPE_ROUND_HERMITE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FLAT_HERMITE_CURVE: Enables flat Hermite curves (RTC_GEOMETRY_TYPE_FLAT_HERMITE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_NORMAL_ORIENTED_HERMITE_CURVE: Enables normal oriented Hermite curves (RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_HERMITE_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ROUND_CATMULL_ROM_CURVE: Enables round Catmull Rom curves (RTC_GEOMETRY_TYPE_ROUND_CATMULL_ROM_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FLAT_CATMULL_ROM_CURVE: Enables flat Catmull Rom curves (RTC_GEOMETRY_TYPE_FLAT_CATMULL_ROM_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_NORMAL_ORIENTED_CATMULL_ROM_CURVE: Enables normal oriented Catmull Rom curves (RTC_GEOMETRY_TYPE_NORMAL_ORIENTED_CATMULL_ROM_CURVE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_SPHERE_POINT: Enables sphere geometry type (RTC_GEOMETRY_TYPE_SPHERE_POINT).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_DISC_POINT: Enables disc geometry type (RTC_GEOMETRY_TYPE_DISC_POINT).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ORIENTED_DISC_POINT: Enables oriented disc geometry types (RTC_GEOMETRY_TYPE_ORIENTED_DISC_POINT).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_INSTANCE: Enables instance geometries (RTC_GEOMETRY_TYPE_INSTANCE).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS: Enables filter functions passed through intersect arguments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FILTER_FUNCTION_IN_GEOMETRY: Enable filter functions passed through geometry.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_FILTER_FUNCTION: Enables filter functions (argument and geometry version).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_USER_GEOMETRY_CALLBACK_IN_ARGUMENTS: Enables RTC_GEOMETRY_TYPE_USER with function pointer passed through intersect arguments.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_USER_GEOMETRY_CALLBACK_IN_GEOMETRY: Enables RTC_GEOMETRY_TYPE_USER with function pointer passed through geometry object.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_USER_GEOMETRY: Enables RTC_GEOMETRY_TYPE_USER geometries (both argument and geometry callback versions).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_32_BIT_RAY_MASK: Enables full 32 bit ray masks. If not used, only the lower 7 bits in the ray mask are handled correctly.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;RTC_FEATURE_FLAG_ALL: Enables all features (default).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect1], [rtcIntersect4/8/16], [rtcOccluded1], [rtcOccluded4/8/16],&lt;/p&gt; &#xA;&lt;h2&gt;rtcInitIntersectArguments&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInitIntersectArguments - initializes the intersect arguments struct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;enum RTCRayQueryFlags&#xA;{&#xA;  RTC_RAY_QUERY_FLAG_NONE,&#xA;  RTC_RAY_QUERY_FLAG_INCOHERENT,&#xA;  RTC_RAY_QUERY_FLAG_COHERENT,&#xA;  RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&#xA;};&#xA;&#xA;struct RTCIntersectArguments&#xA;{&#xA;  enum RTCRayQueryFlags flags;&#xA;  enum RTCFeatureFlags feature_mask;&#xA;  struct RTCRayQueryContext* context;&#xA;  RTCFilterFunctionN filter;&#xA;  RTCIntersectFunctionN intersect;&#xA;#if RTC_MIN_WIDTH&#xA;  float minWidthDistanceFactor;&#xA;#endif&#xA;};&#xA;&#xA;void rtcInitIntersectArguments(&#xA;  struct RTCIntersectArguments* args&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInitIntersectArguments&lt;/code&gt; function initializes the optional argument struct that can get passed to the &lt;code&gt;rtcIntersect1/4/8/16&lt;/code&gt; functions to default values. The arguments struct needs to get used for more advanced Embree features as described here.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;flags&lt;/code&gt; member can get used to enable special traversal mode. Using the &lt;code&gt;RTC_RAY_QUERY_FLAG_INCOHERENT&lt;/code&gt; flag uses an optimized traversal algorithm for incoherent rays (default), while &lt;code&gt;RTC_RAY_QUERY_FLAG_COHERENT&lt;/code&gt; uses an optimized traversal algorithm for coherent rays (e.g.&amp;nbsp;primary camera rays).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;feature_mask&lt;/code&gt; member should get used in SYCL to just enable ray tracing features required to render a given scene. Please see section [RTCFeatureFlags] for a more detailed description.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;context&lt;/code&gt; member can get used to pass an optional intersection context. It is guaranteed that the pointer to the context passed to a ray query is directly passed to all callback functions. This way it is possible to attach arbitrary data to the end of the context, such as a per-ray payload. Please note that the ray pointer is not guaranteed to be passed to the callback functions, thus reading additional data from the ray pointer passed to callbacks is not possible. See section [rtcInitRayQueryContext] for more details.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;filter&lt;/code&gt; member specifies a filter function to invoke for each encountered hit. The support for the argument filter function must be enabled for a scene by using the &lt;code&gt;RTC_SCENE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS&lt;/code&gt; scene flag. In case of instancing this feature has to get enabled also for each instantiated scene.&lt;/p&gt; &#xA;&lt;p&gt;The argument filter function is invoked for each geometry for which it got explicitely enabled using the &lt;code&gt;rtcSetGeometryEnableFilterFunctionFromArguments&lt;/code&gt; function. The invokation of the argument filter function can also get enfored for each geometry using the &lt;code&gt;RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&lt;/code&gt; ray query flag. This argument filter function is invoked as a second filter stage after the per-geometry filter function is invoked. Only rays that passed the first filter stage are valid in this second filter stage. Having such a per ray-query filter function can be useful to implement modifications of the behavior of the query, such as collecting all hits or accumulating transparencies.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;intersect&lt;/code&gt; member specifies the user geometry callback to get invoked for each user geometry encountered during traversal. The user geometry callback specified this way has preference over the one specified inside the geometry.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;minWidthDistanceFactor&lt;/code&gt; value controls the target size of the curve radii when the min-width feature is enabled. Please see the [rtcSetGeometryMaxRadiusScale] function for more details on the min-width feature.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;No error code is set by this function.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect1], [rtcIntersect4/8/16], [RTCFeatureFlags], [rtcInitRayQueryContext], [RTC_GEOMETRY_TYPE_USER], [rtcSetGeometryMaxRadiusScale]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInitOccludedArguments&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInitOccludedArguments - initializes the occluded arguments struct&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;enum RTCRayQueryFlags&#xA;{&#xA;  RTC_RAY_QUERY_FLAG_NONE,&#xA;  RTC_RAY_QUERY_FLAG_INCOHERENT,&#xA;  RTC_RAY_QUERY_FLAG_COHERENT,&#xA;  RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&#xA;};&#xA;&#xA;struct RTCOccludedArguments&#xA;{&#xA;  enum RTCRayQueryFlags flags;&#xA;  enum RTCFeatureFlags feature_mask;&#xA;  struct RTCRayQueryContext* context;&#xA;  RTCFilterFunctionN filter;&#xA;  RTCOccludedFunctionN intersect;&#xA;#if RTC_MIN_WIDTH&#xA;  float minWidthDistanceFactor;&#xA;#endif&#xA;};&#xA;&#xA;void rtcInitOccludedArguments(&#xA;  struct RTCOccludedArguments* args&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInitOccludedArguments&lt;/code&gt; function initializes the optional argument struct that can get passed to the &lt;code&gt;rtcOccluded1/4/8/16&lt;/code&gt; functions to default values. The arguments struct needs to get used for more advanced Embree features as described here.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;flags&lt;/code&gt; member can get used to enable special traversal mode. Using the &lt;code&gt;RTC_RAY_QUERY_FLAG_INCOHERENT&lt;/code&gt; flag uses an optimized traversal algorithm for incoherent rays (default), while &lt;code&gt;RTC_RAY_QUERY_FLAG_COHERENT&lt;/code&gt; uses an optimized traversal algorithm for coherent rays (e.g.&amp;nbsp;primary camera rays).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;feature_mask&lt;/code&gt; member should get used in SYCL to just enable ray tracing features required to render a given scene. Please see section [RTCFeatureFlags] for a more detailed description.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;context&lt;/code&gt; member can get used to pass an optional intersection context. It is guaranteed that the pointer to the context passed to a ray query is directly passed to all callback functions. This way it is possible to attach arbitrary data to the end of the context, such as a per-ray payload. Please note that the ray pointer is not guaranteed to be passed to the callback functions, thus reading additional data from the ray pointer passed to callbacks is not possible. See section [rtcInitRayQueryContext] for more details.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;filter&lt;/code&gt; member specifies a filter function to invoked for each encountered hit. The support for the argument filter function must be enabled for a scene by using the &lt;code&gt;RTC_SCENE_FLAG_FILTER_FUNCTION_IN_ARGUMENTS&lt;/code&gt; scene flag. In case of instancing this feature has to get enabled also for each instantiated scene.&lt;/p&gt; &#xA;&lt;p&gt;The argument filter function is invoked for each geometry for which it got explicitely enabled using the &lt;code&gt;rtcSetGeometryEnableFilterFunctionFromArguments&lt;/code&gt; function. The invokation of the argument filter function can also get enfored for each geometry using the &lt;code&gt;RTC_RAY_QUERY_FLAG_INVOKE_ARGUMENT_FILTER&lt;/code&gt; ray query flag. This argument filter function is invoked as a second filter stage after the per-geometry filter function is invoked. Only rays that passed the first filter stage are valid in this second filter stage. Having such a per ray-query filter function can be useful to implement modifications of the behavior of the query, such as collecting all hits or accumulating transparencies.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;intersect&lt;/code&gt; member specifies the user geometry callback to get invoked for each user geometry encountered during traversal. The user geometry callback specified this way has preference over the one specified inside the geometry.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;minWidthDistanceFactor&lt;/code&gt; value controls the target size of the curve radii when the min-width feature is enabled. Please see the [rtcSetGeometryMaxRadiusScale] function for more details on the min-width feature.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;No error code is set by this function.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcOccluded1], [rtcOccluded4/8/16], [RTCFeatureFlags], [rtcInitRayQueryContext], [RTC_GEOMETRY_TYPE_USER], [rtcSetGeometryMaxRadiusScale]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInitRayQueryContext&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInitRayQueryContext - initializes the ray query context&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCRayQueryContext&#xA;{&#xA;  #if RTC_MAX_INSTANCE_LEVEL_COUNT &amp;gt; 1&#xA;    unsigned int instStackSize;&#xA;  #endif&#xA;  &#xA;  unsigned int instID[RTC_MAX_INSTANCE_LEVEL_COUNT];&#xA;};&#xA;&#xA;void rtcInitRayQueryContext(&#xA;  struct RTCRayQueryContext* context&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInitRayQueryContext&lt;/code&gt; function initializes the intersection context to default values and should be called to initialize every ray query context.&lt;/p&gt; &#xA;&lt;p&gt;It is guaranteed that the pointer to the ray query context (&lt;code&gt;RTCRayQueryContext&lt;/code&gt; type) is passed to the registered callback functions. This way it is possible to attach arbitrary data to the end of the ray query context, such as a per-ray payload.&lt;/p&gt; &#xA;&lt;p&gt;Inside the user geometry callback the ray query context can get used to access the &lt;code&gt;instID&lt;/code&gt; stack to know which instance the user geometry object resides.&lt;/p&gt; &#xA;&lt;p&gt;If not ray query context is specified when tracing a ray, a default context is used.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;No error code is set by this function.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect1], [rtcIntersect4/8/16], [rtcOccluded1], [rtcOccluded4/8/16]&lt;/p&gt; &#xA;&lt;h2&gt;rtcIntersect1&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcIntersect1 - finds the closest hit for a single ray&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcIntersect1(&#xA;  RTCScene scene,&#xA;  struct RTCRayHit* rayhit&#xA;  struct RTCIntersectArguments* args = NULL&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcIntersect1&lt;/code&gt; function finds the closest hit of a single ray (&lt;code&gt;rayhit&lt;/code&gt; argument) with the scene (&lt;code&gt;scene&lt;/code&gt; argument). The provided ray/hit structure contains the ray to intersect and some hit output fields that are filled when a hit is found. The passed optional arguments struct (&lt;code&gt;args&lt;/code&gt; argument) can get used for advanced use cases, see section [rtcInitIntersectArguments] for more details.&lt;/p&gt; &#xA;&lt;p&gt;To trace a ray, the user has to initialize the ray origin (&lt;code&gt;org&lt;/code&gt; ray member), ray direction (&lt;code&gt;dir&lt;/code&gt; ray member), ray segment (&lt;code&gt;tnear&lt;/code&gt;, &lt;code&gt;tfar&lt;/code&gt; ray members), ray mask (&lt;code&gt;mask&lt;/code&gt; ray member), and set the ray flags to &lt;code&gt;0&lt;/code&gt; (&lt;code&gt;flags&lt;/code&gt; ray member). The ray time (&lt;code&gt;time&lt;/code&gt; ray member) must be initialized to a value in the range $[0, 1]. The ray segment has to be in the range $[0, \infty]$, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. See Section [RTCRay] for the ray layout description.&lt;/p&gt; &#xA;&lt;p&gt;The geometry ID (&lt;code&gt;geomID&lt;/code&gt; hit member) of the hit data must be initialized to &lt;code&gt;RTC_INVALID_GEOMETRY_ID&lt;/code&gt; (-1).&lt;/p&gt; &#xA;&lt;p&gt;When no intersection is found, the ray/hit data is not updated. When an intersection is found, the hit distance is written into the &lt;code&gt;tfar&lt;/code&gt; member of the ray and all hit data is set, such as unnormalized geometry normal in object space (&lt;code&gt;Ng&lt;/code&gt; hit member), local hit coordinates (&lt;code&gt;u&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; hit member), instance ID stack (&lt;code&gt;instID&lt;/code&gt; hit member), geometry ID (&lt;code&gt;geomID&lt;/code&gt; hit member), and primitive ID (&lt;code&gt;primID&lt;/code&gt; hit member). See Section [RTCHit] for the hit layout description.&lt;/p&gt; &#xA;&lt;p&gt;If the instance ID stack has a prefix of values not equal to &lt;code&gt;RTC_INVALID_GEOMETRY_ID&lt;/code&gt;, the instance ID on each level corresponds to the geometry ID of the hit instance of the higher-level scene, the geometry ID corresponds to the hit geometry inside the hit instanced scene, and the primitive ID corresponds to the n-th primitive of that geometry.&lt;/p&gt; &#xA;&lt;p&gt;If level 0 of the instance ID stack is equal to &lt;code&gt;RTC_INVALID_GEOMETRY_ID&lt;/code&gt;, the geometry ID corresponds to the hit geometry inside the top-level scene, and the primitive ID corresponds to the n-th primitive of that geometry.&lt;/p&gt; &#xA;&lt;p&gt;The implementation makes no guarantees that primitives whose hit distance is exactly at (or very close to) &lt;code&gt;tnear&lt;/code&gt; or &lt;code&gt;tfar&lt;/code&gt; are hit or missed. If you want to exclude intersections at &lt;code&gt;tnear&lt;/code&gt; just pass a slightly enlarged &lt;code&gt;tnear&lt;/code&gt;, and if you want to include intersections at &lt;code&gt;tfar&lt;/code&gt; pass a slightly enlarged &lt;code&gt;tfar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the ray query context. See section [rtcInitRayQueryContext] for more details.&lt;/p&gt; &#xA;&lt;p&gt;The ray/hit structure must be aligned to 16 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcOccluded1], [rtcIntersect4/8/16], [RTCRayHit], [rtcInitIntersectArguments]&lt;/p&gt; &#xA;&lt;h2&gt;rtcOccluded1&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcOccluded1 - finds any hit for a single ray&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcOccluded1(&#xA;  RTCScene scene,&#xA;  struct RTCRay* ray,&#xA;  struct RTCOccludedArguments* args = NULL&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcOccluded1&lt;/code&gt; function checks for a single ray (&lt;code&gt;ray&lt;/code&gt; argument) whether there is any hit with the scene (&lt;code&gt;scene&lt;/code&gt; argument). The passed optional arguments struct (&lt;code&gt;args&lt;/code&gt; argument) can get used for advanced use cases, see section [rtcInitOccludedArguments] for more details.&lt;/p&gt; &#xA;&lt;p&gt;To trace a ray, the user must initialize the ray origin (&lt;code&gt;org&lt;/code&gt; ray member), ray direction (&lt;code&gt;dir&lt;/code&gt; ray member), ray segment (&lt;code&gt;tnear&lt;/code&gt;, &lt;code&gt;tfar&lt;/code&gt; ray members), ray mask (&lt;code&gt;mask&lt;/code&gt; ray member), and must set the ray flags to &lt;code&gt;0&lt;/code&gt; (&lt;code&gt;flags&lt;/code&gt; ray member). The ray time (&lt;code&gt;time&lt;/code&gt; ray member) must be initialized to a value in the range $[0, 1]$. The ray segment must be in the range $[0, \infty]$, thus ranges that start behind the ray origin are not valid, but ranges can reach to infinity. See Section [RTCRay] for the ray layout description.&lt;/p&gt; &#xA;&lt;p&gt;When no intersection is found, the ray data is not updated. In case a hit was found, the &lt;code&gt;tfar&lt;/code&gt; component of the ray is set to &lt;code&gt;-inf&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The implementation makes no guarantees that primitives whose hit distance is exactly at (or very close to) &lt;code&gt;tnear&lt;/code&gt; or &lt;code&gt;tfar&lt;/code&gt; are hit or missed. If you want to exclude intersections at &lt;code&gt;tnear&lt;/code&gt; just pass a slightly enlarged &lt;code&gt;tnear&lt;/code&gt;, and if you want to include intersections at &lt;code&gt;tfar&lt;/code&gt; pass a slightly enlarged &lt;code&gt;tfar&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the ray query context. See section [rtcInitRayQueryContext] for more details.&lt;/p&gt; &#xA;&lt;p&gt;The ray must be aligned to 16 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect1], [rtcOccluded4/8/16], [RTCRay], [rtcInitOccludedArguments]&lt;/p&gt; &#xA;&lt;h2&gt;rtcIntersect4/8/16&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcIntersect4/8/16 - finds the closest hits for a ray packet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcIntersect4(&#xA;  const int* valid,&#xA;  RTCScene scene,&#xA;  struct RTCRayHit4* rayhit,&#xA;  struct RTCIntersectArguments* args = NULL&#xA;);&#xA;&#xA;void rtcIntersect8(&#xA;  const int* valid,&#xA;  RTCScene scene,&#xA;  struct RTCRayHit8* rayhit,&#xA;  struct RTCIntersectArguments* args = NULL&#xA;);&#xA;&#xA;void rtcIntersect16(&#xA;  const int* valid,&#xA;  RTCScene scene,&#xA;  struct RTCRayHit16* rayhit,&#xA;  struct RTCIntersectArguments* args = NULL&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; functions finds the closest hits for a ray packet of size 4, 8, or 16 (&lt;code&gt;rayhit&lt;/code&gt; argument) with the scene (&lt;code&gt;scene&lt;/code&gt; argument). The ray/hit input contains a ray packet and hit packet. The passed optional arguments struct (&lt;code&gt;args&lt;/code&gt; argument) are used to pass additional arguments for advanced features. See Section [rtcIntersect1] for more details and a description of how to set up and trace rays.&lt;/p&gt; &#xA;&lt;p&gt;A ray valid mask must be provided (&lt;code&gt;valid&lt;/code&gt; argument) which stores one 32-bit integer (&lt;code&gt;-1&lt;/code&gt; means valid and &lt;code&gt;0&lt;/code&gt; invalid) per ray in the packet. Only active rays are processed, and hit data of inactive rays is not changed.&lt;/p&gt; &#xA;&lt;p&gt;The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the ray query context. See section [rtcInitRayQueryContext] for more details.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;rtcIntersect4&lt;/code&gt; the ray packet must be aligned to 16 bytes, for &lt;code&gt;rtcIntersect8&lt;/code&gt; the alignment must be 32 bytes, and for &lt;code&gt;rtcIntersect16&lt;/code&gt; the alignment must be 64 bytes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcIntersect4&lt;/code&gt;, &lt;code&gt;rtcIntersect8&lt;/code&gt; and &lt;code&gt;rtcIntersect16&lt;/code&gt; functions may change the ray packet size and ray order when calling back into filter functions or user geometry callbacks. Under some conditions the application can assume packets to stay intakt, which can determined by querying the &lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED&lt;/code&gt;, &lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED&lt;/code&gt;, &lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED&lt;/code&gt; properties through the &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt; function. See [rtcGetDeviceProperty] for more information.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect1], [rtcOccluded4/8/16], [rtcInitIntersectArguments]&lt;/p&gt; &#xA;&lt;h2&gt;rtcOccluded4/8/16&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcOccluded4/8/16 - finds any hits for a ray packet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcOccluded4(&#xA;  const int* valid,&#xA;  RTCScene scene,&#xA;  struct RTCRay4* ray,&#xA;  struct RTCOccludedArguments* args = NULL&#xA;);&#xA;&#xA;void rtcOccluded8(&#xA;  const int* valid,&#xA;  RTCScene scene,&#xA;  struct RTCRay8* ray,&#xA;  struct RTCOccludedArguments* args = NULL&#xA;);&#xA;&#xA;void rtcOccluded16(&#xA;  const int* valid,&#xA;  RTCScene scene,&#xA;  struct RTCRay16* ray,&#xA;  struct RTCOccludedArguments* args = NULL&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt; functions checks for each active ray of the ray packet of size 4, 8, or 16 (&lt;code&gt;ray&lt;/code&gt; argument) whether there is any hit with the scene (&lt;code&gt;scene&lt;/code&gt; argument). The passed optional arguments struct (&lt;code&gt;args&lt;/code&gt; argument) can get used for advanced use cases, see section [rtcInitOccludedArguments] for more details. See Section [rtcOccluded1] for more details and a description of how to set up and trace occlusion rays.&lt;/p&gt; &#xA;&lt;p&gt;A ray valid mask must be provided (&lt;code&gt;valid&lt;/code&gt; argument) which stores one 32-bit integer (&lt;code&gt;-1&lt;/code&gt; means valid and &lt;code&gt;0&lt;/code&gt; invalid) per ray in the packet. Only active rays are processed, and hit data of inactive rays is not changed.&lt;/p&gt; &#xA;&lt;p&gt;The ray pointer passed to callback functions is not guaranteed to be identical to the original ray provided. To extend the ray with additional data to be accessed in callback functions, use the ray query context. See section [rtcInitRayQueryContext] for more details.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;rtcOccluded4&lt;/code&gt; the ray packet must be aligned to 16 bytes, for &lt;code&gt;rtcOccluded8&lt;/code&gt; the alignment must be 32 bytes, and for &lt;code&gt;rtcOccluded16&lt;/code&gt; the alignment must be 64 bytes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcOccluded4&lt;/code&gt;, &lt;code&gt;rtcOccluded8&lt;/code&gt; and &lt;code&gt;rtcOccluded16&lt;/code&gt; functions may change the ray packet size and ray order when calling back into intersect filter functions or user geometry callbacks. Under some conditions the application can assume packets to stay intakt, which can determined by querying the &lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY4_SUPPORTED&lt;/code&gt;, &lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY8_SUPPORTED&lt;/code&gt;, &lt;code&gt;RTC_DEVICE_PROPERTY_NATIVE_RAY16_SUPPORTED&lt;/code&gt; properties through the &lt;code&gt;rtcGetDeviceProperty&lt;/code&gt; function. See [rtcGetDeviceProperty] for more information.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcOccluded1], [rtcIntersect4/8/16], [rtcInitOccludedArguments]&lt;/p&gt; &#xA;&lt;h2&gt;rtcForwardIntersect1&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcForwardIntersect1 - forwards a single ray to new scene&#xA;  from user geometry callback&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcForwardIntersect1(&#xA;  const struct RTCIntersectFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay* ray,&#xA;  unsigned int instID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; function forwards the traversal of a transformed ray (&lt;code&gt;ray&lt;/code&gt; argument) into a scene (&lt;code&gt;scene&lt;/code&gt; argument) from a user geometry callback. The function can only get invoked from a user geometry callback for a ray traversal initiated with the &lt;code&gt;rtcIntersect1&lt;/code&gt; function. The callback arguments structure of the callback invokation has to get passed to the ray forwarding (&lt;code&gt;args&lt;/code&gt; argument). The user geometry callback should instantly terminate after invoking the &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Only the ray origin and ray direction members of the ray argument are used for forwarding, all additional ray properties are inherited from the initial ray traversal invokation of &lt;code&gt;rtcIntersect1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The implementation of the &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; function recursively continues the ray traversal into the specified scene and pushes the provided instance ID (&lt;code&gt;instID&lt;/code&gt; argument) to the instance ID stack. Hit information is updated into the ray hit structure passed to the original &lt;code&gt;rtcIntersect1&lt;/code&gt; invokation.&lt;/p&gt; &#xA;&lt;p&gt;This function can get used to implement user defined instancing using user geometries, e.g.&amp;nbsp;by transforming the ray in a special way, and/or selecting between different scenes to instantiate.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree on the CPU it is possible to recursively invoke &lt;code&gt;rtcIntersect1&lt;/code&gt; directly from a user geometry callback. However, when SYCL is used, recursively tracing rays is not directly supported, and the &lt;code&gt;rtcForwardIntersect1&lt;/code&gt; function must be used.&lt;/p&gt; &#xA;&lt;p&gt;The ray structure must be aligned to 16 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect1], [RTCRay]&lt;/p&gt; &#xA;&lt;h2&gt;rtcForwardOccluded1&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcForwardOccluded1 - forwards a single ray to new scene&#xA;  from user geometry callback&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcForwardOccluded1(&#xA;  const struct RTCOccludedFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay* ray,&#xA;  unsigned int instID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; function forwards the traversal of a transformed ray (&lt;code&gt;ray&lt;/code&gt; argument) into a scene (&lt;code&gt;scene&lt;/code&gt; argument) from a user geometry callback. The function can only get invoked from a user geometry callback for a ray traversal initiated with the &lt;code&gt;rtcOccluded1&lt;/code&gt; function. The callback arguments structure of the callback invokation has to get passed to the ray forwarding (&lt;code&gt;args&lt;/code&gt; argument). The user geometry callback should instantly terminate after invoking the &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Only the ray origin and ray direction members of the ray argument are used for forwarding, all additional ray properties are inherited from the initial ray traversal invokation of &lt;code&gt;rtcOccluded1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The implementation of the &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; function recursively continues the ray traversal into the specified scene and pushes the provided instance ID (&lt;code&gt;instID&lt;/code&gt; argument) to the instance ID stack. Hit information is updated into the ray structure passed to the original &lt;code&gt;rtcOccluded1&lt;/code&gt; invokation.&lt;/p&gt; &#xA;&lt;p&gt;This function can get used to implement user defined instancing using user geometries, e.g.&amp;nbsp;by transforming the ray in a special way, and/or selecting between different scenes to instantiate.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree on the CPU it is possible to recursively invoke &lt;code&gt;rtcOccluded1&lt;/code&gt; directly from a user geometry callback. However, when SYCL is used, recursively tracing rays is not directly supported, and the &lt;code&gt;rtcForwardOccluded1&lt;/code&gt; function must be used.&lt;/p&gt; &#xA;&lt;p&gt;The ray structure must be aligned to 16 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcOccluded1], [RTCRay]&lt;/p&gt; &#xA;&lt;h2&gt;rtcForwardIntersect4/8/16&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcForwardIntersect4/8/16 - forwards a ray packet to new scene&#xA;  from user geometry callback&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcForwardIntersect4(&#xA;  void int* valid,&#xA;  const struct RTCIntersectFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay4* ray,&#xA;  unsigned int instID&#xA;);&#xA;&#xA;void rtcForwardIntersect4(&#xA;  void int* valid,&#xA;  const struct RTCIntersectFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay4* ray,&#xA;  unsigned int instID&#xA;);&#xA;&#xA;void rtcForwardIntersect16(&#xA;  void int* valid,&#xA;  const struct RTCIntersectFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay16* ray,&#xA;  unsigned int instID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcForwardIntersect4/8/16&lt;/code&gt; functions forward the traversal of a transformed ray packet (&lt;code&gt;ray&lt;/code&gt; argument) into a scene (&lt;code&gt;scene&lt;/code&gt; argument) from a user geometry callback. The function can only get invoked from a user geometry callback for a ray traversal initiated with the &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; function. The callback arguments structure of the callback invokation has to get passed to the ray forwarding (&lt;code&gt;args&lt;/code&gt; argument). The user geometry callback should instantly terminate after invoking the &lt;code&gt;rtcForwardIntersect4/8/16&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Only the ray origin and ray direction members of the ray argument are used for forwarding, all additional ray properties are inherited from the initial ray traversal invokation of &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The implementation of the &lt;code&gt;rtcForwardIntersect4/8/16&lt;/code&gt; function recursively continues the ray traversal into the specified scene and pushes the provided instance ID (&lt;code&gt;instID&lt;/code&gt; argument) to the instance ID stack. Hit information is updated into the ray hit structure passed to the original &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; invokation.&lt;/p&gt; &#xA;&lt;p&gt;This function can get used to implement user defined instancing using user geometries, e.g.&amp;nbsp;by transforming the ray in a special way, and/or selecting between different scenes to instantiate.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree on the CPU it is possible to recursively invoke &lt;code&gt;rtcIntersect4/8/16&lt;/code&gt; directly from a user geometry callback. However, when SYCL is used, recursively tracing rays is not directly supported, and the &lt;code&gt;rtcForwardIntersect4/8/16&lt;/code&gt; function must be used.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;rtcForwardIntersect4&lt;/code&gt; the ray packet must be aligned to 16 bytes, for &lt;code&gt;rtcForwardIntersect8&lt;/code&gt; the alignment must be 32 bytes, and for &lt;code&gt;rtcForwardIntersect16&lt;/code&gt; the alignment must be 64 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcIntersect4/8/16]&lt;/p&gt; &#xA;&lt;h2&gt;rtcForwardOccluded4/8/16&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcForwardOccluded4/8/16 - forwards a ray packet to new scene&#xA;  from user geometry callback&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcForwardOccluded4(&#xA;  void int* valid,&#xA;  const struct RTCOccludedFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay4* ray,&#xA;  unsigned int instID&#xA;);&#xA;&#xA;void rtcForwardOccluded4(&#xA;  void int* valid,&#xA;  const struct RTCOccludedFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay4* ray,&#xA;  unsigned int instID&#xA;);&#xA;&#xA;void rtcForwardOccluded16(&#xA;  void int* valid,&#xA;  const struct RTCOccludedFunctionNArguments* args,&#xA;  RTCScene scene,&#xA;  struct RTCRay16* ray,&#xA;  unsigned int instID&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcForwardOccluded4/8/16&lt;/code&gt; functions forward the traversal of a transformed ray packet (&lt;code&gt;ray&lt;/code&gt; argument) into a scene (&lt;code&gt;scene&lt;/code&gt; argument) from a user geometry callback. The function can only get invoked from a user geometry callback for a ray traversal initiated with the &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt; function. The callback arguments structure of the callback invokation has to get passed to the ray forwarding (&lt;code&gt;args&lt;/code&gt; argument). The user geometry callback should instantly terminate after invoking the &lt;code&gt;rtcForwardOccluded4/8/16&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;Only the ray origin and ray direction members of the ray argument are used for forwarding, all additional ray properties are inherited from the initial ray traversal invokation of &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The implementation of the &lt;code&gt;rtcForwardOccluded4/8/16&lt;/code&gt; function recursively continues the ray traversal into the specified scene and pushes the provided instance ID (&lt;code&gt;instID&lt;/code&gt; argument) to the instance ID stack. Hit information is updated into the ray structure passed to the original &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt; invokation.&lt;/p&gt; &#xA;&lt;p&gt;This function can get used to implement user defined instancing using user geometries, e.g.&amp;nbsp;by transforming the ray in a special way, and/or selecting between different scenes to instantiate.&lt;/p&gt; &#xA;&lt;p&gt;When using Embree on the CPU it is possible to recursively invoke &lt;code&gt;rtcOccluded4/8/16&lt;/code&gt; directly from a user geometry callback. However, when SYCL is used, recursively tracing rays is not directly supported, and the &lt;code&gt;rtcForwardOccluded4/8/16&lt;/code&gt; function must be used.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;code&gt;rtcForwardOccluded4&lt;/code&gt; the ray packet must be aligned to 16 bytes, for &lt;code&gt;rtcForwardOccluded8&lt;/code&gt; the alignment must be 32 bytes, and for &lt;code&gt;rtcForwardOccluded16&lt;/code&gt; the alignment must be 64 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcOccluded4/8/16]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInitPointQueryContext&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInitPointQueryContext - initializes the context information (e.g.&#xA;  stack of (multilevel-)instance transformations) for point queries&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTC_ALIGN(16) RTCPointQueryContext&#xA;{&#xA;  // accumulated 4x4 column major matrices from world to instance space.&#xA;  float world2inst[RTC_MAX_INSTANCE_LEVEL_COUNT][16];&#xA;  &#xA;  // accumulated 4x4 column major matrices from instance to world space.&#xA;  float inst2world[RTC_MAX_INSTANCE_LEVEL_COUNT][16];&#xA;&#xA;  // instance ids.&#xA;  unsigned int instID[RTC_MAX_INSTANCE_LEVEL_COUNT];&#xA;  &#xA;  // number of instances currently on the stack.&#xA;  unsigned int instStackSize;&#xA;};&#xA;&#xA;void rtcInitPointQueryContext(&#xA;  struct RTCPointQueryContext* context&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;A stack (&lt;code&gt;RTCPointQueryContext&lt;/code&gt; type) which stores the IDs and instance transformations during a BVH traversal for a point query. The transformations are assumed to be affine transformations (3×3 matrix plus translation) and therefore the last column is ignored (see [RTC_GEOMETRY_TYPE_INSTANCE] for details).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInitPointContext&lt;/code&gt; function initializes the context to default values and should be called for initialization.&lt;/p&gt; &#xA;&lt;p&gt;The context will be passed as an argument to the point query callback function (see [rtcSetGeometryPointQueryFunction]) and should be used to pass instance information down the instancing chain for user defined instancing (see tutorial [ClosestPoint] for a reference implementation of point queries with user defined instancing).&lt;/p&gt; &#xA;&lt;p&gt;The context is an necessary argument to [rtcPointQuery] and Embree internally uses the topmost instance transformation of the stack to transform the point query into instance space.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;No error code is set by this function.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcPointQuery], [rtcSetGeometryPointQueryFunction]&lt;/p&gt; &#xA;&lt;h2&gt;rtcPointQuery&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcPointQuery - traverses the BVH with a point query object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTC_ALIGN(16) RTCPointQuery&#xA;{&#xA;  // location of the query&#xA;  float x;&#xA;  float y;&#xA;  float z;&#xA;&#xA;  // radius and time of the query&#xA;  float radius;&#xA;  float time;&#xA;};&#xA;&#xA;void rtcPointQuery(&#xA;  RTCScene scene,&#xA;  struct RTCPointQuery* query,&#xA;  struct RTCPointQueryContext* context,&#xA;  struct RTCPointQueryFunction* queryFunc,&#xA;  void* userPtr&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcPointQuery&lt;/code&gt; function traverses the BVH using a &lt;code&gt;RTCPointQuery&lt;/code&gt; object (&lt;code&gt;query&lt;/code&gt; argument) and calls a user defined callback function (e.g &lt;code&gt;queryFunc&lt;/code&gt; argument) for each primitive of the scene (&lt;code&gt;scene&lt;/code&gt; argument) that intersects the query domain.&lt;/p&gt; &#xA;&lt;p&gt;The user has to initialize the query location (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; member) and query radius in the range $[0, \infty]$. If the scene contains motion blur geometries, also the query time (&lt;code&gt;time&lt;/code&gt; member) must be initialized to a value in the range $[0, 1]$.&lt;/p&gt; &#xA;&lt;p&gt;Further, a &lt;code&gt;RTCPointQueryContext&lt;/code&gt; (&lt;code&gt;context&lt;/code&gt; argument) must be created and initialized. It contains ID and transformation information of the instancing hierarchy if (multilevel-)instancing is used. See [rtcInitPointQueryContext] for further information.&lt;/p&gt; &#xA;&lt;p&gt;For every primitive that intersects the query domain, the callback function (&lt;code&gt;queryFunc&lt;/code&gt; argument) is called, in which distance computations to the primitive can be implemented. The user will be provided with the primID and geomID of the according primitive, however, the geometry information (e.g. triangle index and vertex data) has to be determined manually. The &lt;code&gt;userPtr&lt;/code&gt; argument can be used to input geometry data of the scene or output results of the point query (e.g.&amp;nbsp;closest point currently found on surface geometry (see tutorial [ClosestPoint])).&lt;/p&gt; &#xA;&lt;p&gt;The parameter &lt;code&gt;queryFunc&lt;/code&gt; is optional and can be NULL, in which case the callback function is not invoked. However, a callback function can still get attached to a specific &lt;code&gt;RTCGeometry&lt;/code&gt; object using [rtcSetGeometryPointQueryFunction]. If a callback function is attached to a geometry and (a potentially different) callback function is passed as an argument to &lt;code&gt;rtcPointQuery&lt;/code&gt;, both functions are called for the primitives of the according geometries.&lt;/p&gt; &#xA;&lt;p&gt;The query radius can be decreased inside the callback function, which allows to efficiently cull parts of the scene during BVH traversal. Increasing the query radius and modifying time or location of the query will result in undefined behaviour.&lt;/p&gt; &#xA;&lt;p&gt;The callback function will be called for all primitives in a leaf node of the BVH even if the primitive is outside the query domain, since Embree does not gather geometry information of primitives internally.&lt;/p&gt; &#xA;&lt;p&gt;Point queries can be used with (multilevel)-instancing. However, care has to be taken when the instance transformation contains anisotropic scaling or sheering. In these cases distance computations have to be performed in world space to ensure correctness and the ellipsoidal query domain (in instance space) will be approximated with its axis aligned bounding box internally. Therefore, the callback function might be invoked even for primitives in inner BVH nodes that do not intersect the query domain. See [rtcSetGeometryPointQueryFunction] for details.&lt;/p&gt; &#xA;&lt;p&gt;The point query structure must be aligned to 16 bytes.&lt;/p&gt; &#xA;&lt;h4&gt;SUPPORTED PRIMITIVES&lt;/h4&gt; &#xA;&lt;p&gt;Currently, all primitive types are supported by the point query API except of points (see [RTC_GEOMETRY_TYPE_POINT]), curves (see [RTC_GEOMETRY_TYPE_CURVE]) and sudivision surfaces (see [RTC_GEOMETRY_SUBDIVISION]).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;For performance reasons this function does not do any error checks, thus will not set any error flags on failure.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryPointQueryFunction], [rtcInitPointQueryContext]&lt;/p&gt; &#xA;&lt;h2&gt;rtcCollide&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcCollide - intersects one BVH with another&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTCCollision {&#xA;  unsigned int geomID0, primID0;&#xA;  unsigned int geomID1, primID1;&#xA;};&#xA;&#xA;typedef void (*RTCCollideFunc) (&#xA;  void* userPtr,&#xA;  RTCCollision* collisions,&#xA;  size_t num_collisions);&#xA;&#xA;void rtcCollide (&#xA;    RTCScene hscene0, &#xA;    RTCScene hscene1, &#xA;    RTCCollideFunc callback, &#xA;    void* userPtr&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcCollide&lt;/code&gt; function intersects the BVH of &lt;code&gt;hscene0&lt;/code&gt; with the BVH of scene &lt;code&gt;hscene1&lt;/code&gt; and calls a user defined callback function (e.g &lt;code&gt;callback&lt;/code&gt; argument) for each pair of intersecting primitives between the two scenes. A user defined data pointer (&lt;code&gt;userPtr&lt;/code&gt; argument) can also be passed in.&lt;/p&gt; &#xA;&lt;p&gt;For every pair of primitives that may intersect each other, the callback function (&lt;code&gt;callback&lt;/code&gt; argument) is called. The user will be provided with the primID&#39;s and geomID&#39;s of multiple potentially intersecting primitive pairs. Currently, only scene entirely composed of user geometries are supported, thus the user is expected to implement a primitive/primitive intersection to filter out false positives in the callback function. The &lt;code&gt;userPtr&lt;/code&gt; argument can be used to input geometry data of the scene or output results of the intersection query.&lt;/p&gt; &#xA;&lt;h4&gt;SUPPORTED PRIMITIVES {#supported-primitives}&lt;/h4&gt; &#xA;&lt;p&gt;Currently, the only supported type is the user geometry type (see [RTC_GEOMETRY_TYPE_USER]).&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;h2&gt;rtcNewBVH&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcNewBVH - creates a new BVH object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;RTCBVH rtcNewBVH(RTCDevice device);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;This function creates a new BVH object and returns a handle to this BVH. The BVH object is reference counted with an initial reference count of 1. The handle can be released using the &lt;code&gt;rtcReleaseBVH&lt;/code&gt; API call.&lt;/p&gt; &#xA;&lt;p&gt;The BVH object can be used to build a BVH in a user-specified format over user-specified primitives. See the documentation of the &lt;code&gt;rtcBuildBVH&lt;/code&gt; call for more details.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcRetainBVH], [rtcReleaseBVH], [rtcBuildBVH]&lt;/p&gt; &#xA;&lt;h2&gt;rtcRetainBVH&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcRetainBVH - increments the BVH reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcRetainBVH(RTCBVH bvh);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;BVH objects are reference counted. The &lt;code&gt;rtcRetainBVH&lt;/code&gt; function increments the reference count of the passed BVH object (&lt;code&gt;bvh&lt;/code&gt; argument). This function together with &lt;code&gt;rtcReleaseBVH&lt;/code&gt; allows to use the internal reference counting in a C++ wrapper class to handle the ownership of the object.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewBVH], [rtcReleaseBVH]&lt;/p&gt; &#xA;&lt;h2&gt;rtcReleaseBVH&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcReleaseBVH - decrements the BVH reference count&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;void rtcReleaseBVH(RTCBVH bvh);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;BVH objects are reference counted. The &lt;code&gt;rtcReleaseBVH&lt;/code&gt; function decrements the reference count of the passed BVH object (&lt;code&gt;bvh&lt;/code&gt; argument). When the reference count falls to 0, the BVH gets destroyed.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewBVH], [rtcRetainBVH]&lt;/p&gt; &#xA;&lt;h2&gt;rtcBuildBVH&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcBuildBVH - builds a BVH&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;embree4/rtcore.h&amp;gt;&#xA;&#xA;struct RTC_ALIGN(32) RTCBuildPrimitive&#xA;{&#xA;  float lower_x, lower_y, lower_z; &#xA;  unsigned int geomID;&#xA;  float upper_x, upper_y, upper_z;&#xA;  unsigned int primID;&#xA;};&#xA;&#xA;typedef void* (*RTCCreateNodeFunction) (&#xA;  RTCThreadLocalAllocator allocator,&#xA;  unsigned int childCount,&#xA;  void* userPtr&#xA;);&#xA;&#xA;typedef void (*RTCSetNodeChildrenFunction) (&#xA;  void* nodePtr,&#xA;  void** children,&#xA;  unsigned int childCount,&#xA;  void* userPtr&#xA;);&#xA;&#xA;typedef void (*RTCSetNodeBoundsFunction) (&#xA;  void* nodePtr,&#xA;  const struct RTCBounds** bounds,&#xA;  unsigned int childCount,&#xA;  void* userPtr&#xA;);&#xA;&#xA;typedef void* (*RTCCreateLeafFunction) (&#xA;  RTCThreadLocalAllocator allocator,&#xA;  const struct RTCBuildPrimitive* primitives,&#xA;  size_t primitiveCount,&#xA;  void* userPtr&#xA;);&#xA;&#xA;typedef void (*RTCSplitPrimitiveFunction) (&#xA;  const struct RTCBuildPrimitive* primitive,&#xA;  unsigned int dimension,&#xA;  float position,&#xA;  struct RTCBounds* leftBounds,&#xA;  struct RTCBounds* rightBounds,&#xA;  void* userPtr&#xA;);&#xA;&#xA;typedef bool (*RTCProgressMonitorFunction)(&#xA;  void* userPtr, double n&#xA;);&#xA;&#xA;enum RTCBuildFlags&#xA;{&#xA;  RTC_BUILD_FLAG_NONE,&#xA;  RTC_BUILD_FLAG_DYNAMIC&#xA;};&#xA;&#xA;struct RTCBuildArguments&#xA;{&#xA;  size_t byteSize;&#xA;&#xA;  enum RTCBuildQuality buildQuality;&#xA;  enum RTCBuildFlags buildFlags;&#xA;  unsigned int maxBranchingFactor;&#xA;  unsigned int maxDepth;&#xA;  unsigned int sahBlockSize;&#xA;  unsigned int minLeafSize;&#xA;  unsigned int maxLeafSize;&#xA;  float traversalCost;&#xA;  float intersectionCost;&#xA;&#xA;  RTCBVH bvh;&#xA;  struct RTCBuildPrimitive* primitives;&#xA;  size_t primitiveCount;&#xA;  size_t primitiveArrayCapacity;&#xA;  &#xA;  RTCCreateNodeFunction createNode;&#xA;  RTCSetNodeChildrenFunction setNodeChildren;&#xA;  RTCSetNodeBoundsFunction setNodeBounds;&#xA;  RTCCreateLeafFunction createLeaf;&#xA;  RTCSplitPrimitiveFunction splitPrimitive;&#xA;  RTCProgressMonitorFunction buildProgress;&#xA;  void* userPtr;&#xA;};&#xA;&#xA;struct RTCBuildArguments rtcDefaultBuildArguments();&#xA;&#xA;void* rtcBuildBVH(&#xA;  const struct RTCBuildArguments* args&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcBuildBVH&lt;/code&gt; function can be used to build a BVH in a user-defined format over arbitrary primitives. All arguments to the function are provided through the &lt;code&gt;RTCBuildArguments&lt;/code&gt; structure. The first member of that structure must be set to the size of the structure in bytes (&lt;code&gt;bytesSize&lt;/code&gt; member) which allows future extensions of the structure. It is recommended to initialize the build arguments structure using the &lt;code&gt;rtcDefaultBuildArguments&lt;/code&gt; function.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcBuildBVH&lt;/code&gt; function gets passed the BVH to build (&lt;code&gt;bvh&lt;/code&gt; member), the array of primitives (&lt;code&gt;primitives&lt;/code&gt; member), the capacity of that array (&lt;code&gt;primitiveArrayCapacity&lt;/code&gt; member), the number of primitives stored inside the array (&lt;code&gt;primitiveCount&lt;/code&gt; member), callback function pointers, and a user-defined pointer (&lt;code&gt;userPtr&lt;/code&gt; member) that is passed to all callback functions when invoked. The &lt;code&gt;primitives&lt;/code&gt; array can be freed by the application after the BVH is built. All callback functions are typically called from multiple threads, thus their implementation must be thread-safe.&lt;/p&gt; &#xA;&lt;p&gt;Four callback functions must be registered, which are invoked during build to create BVH nodes (&lt;code&gt;createNode&lt;/code&gt; member), to set the pointers to all children (&lt;code&gt;setNodeChildren&lt;/code&gt; member), to set the bounding boxes of all children (&lt;code&gt;setNodeBounds&lt;/code&gt; member), and to create a leaf node (&lt;code&gt;createLeaf&lt;/code&gt; member).&lt;/p&gt; &#xA;&lt;p&gt;The function pointer to the primitive split function (&lt;code&gt;splitPrimitive&lt;/code&gt; member) may be &lt;code&gt;NULL&lt;/code&gt;, however, then no spatial splitting in high quality mode is possible. The function pointer used to report the build progress (&lt;code&gt;buildProgress&lt;/code&gt; member) is optional and may also be &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Further, some build settings are passed to configure the BVH build. Using the build quality settings (&lt;code&gt;buildQuality&lt;/code&gt; member), one can select between a faster, low quality build which is good for dynamic scenes, and a standard quality build for static scenes. One can also specify the desired maximum branching factor of the BVH (&lt;code&gt;maxBranchingFactor&lt;/code&gt; member), the maximum depth the BVH should have (&lt;code&gt;maxDepth&lt;/code&gt; member), the block size for the SAH heuristic (&lt;code&gt;sahBlockSize&lt;/code&gt; member), the minimum and maximum leaf size (&lt;code&gt;minLeafSize&lt;/code&gt; and &lt;code&gt;maxLeafSize&lt;/code&gt; member), and the estimated costs of one traversal step and one primitive intersection (&lt;code&gt;traversalCost&lt;/code&gt; and &lt;code&gt;intersectionCost&lt;/code&gt; members). When enabling the &lt;code&gt;RTC_BUILD_FLAG_DYNAMIC&lt;/code&gt; build flags (&lt;code&gt;buildFlags&lt;/code&gt; member), re-build performance for dynamic scenes is improved at the cost of higher memory requirements.&lt;/p&gt; &#xA;&lt;p&gt;To spatially split primitives in high quality mode, the builder needs extra space at the end of the build primitive array to store split primitives. The total capacity of the build primitive array is passed using the &lt;code&gt;primitiveArrayCapacity&lt;/code&gt; member, and should be about twice the number of primitives when using spatial splits.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCCreateNodeFunc&lt;/code&gt; and &lt;code&gt;RTCCreateLeafFunc&lt;/code&gt; callbacks are passed a thread local allocator object that should be used for fast allocation of nodes using the &lt;code&gt;rtcThreadLocalAlloc&lt;/code&gt; function. We strongly recommend using this allocation mechanism, as alternative approaches like standard &lt;code&gt;malloc&lt;/code&gt; can be over 10× slower. The allocator object passed to the create callbacks may be used only inside the current thread. Memory allocated using &lt;code&gt;rtcThreadLocalAlloc&lt;/code&gt; is automatically freed when the &lt;code&gt;RTCBVH&lt;/code&gt; object is deleted. If you use your own memory allocation scheme you have to free the memory yourself when the &lt;code&gt;RTCBVH&lt;/code&gt; object is no longer used.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCCreateNodeFunc&lt;/code&gt; callback additionally gets the number of children for this node in the range from 2 to &lt;code&gt;maxBranchingFactor&lt;/code&gt; (&lt;code&gt;childCount&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCSetNodeChildFunc&lt;/code&gt; callback function gets a pointer to the node as input (&lt;code&gt;nodePtr&lt;/code&gt; argument), an array of pointers to the children (&lt;code&gt;childPtrs&lt;/code&gt; argument), and the size of this array (&lt;code&gt;childCount&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCSetNodeBoundsFunc&lt;/code&gt; callback function gets a pointer to the node as input (&lt;code&gt;nodePtr&lt;/code&gt; argument), an array of pointers to the bounding boxes of the children (&lt;code&gt;bounds&lt;/code&gt; argument), and the size of this array (&lt;code&gt;childCount&lt;/code&gt; argument).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCCreateLeafFunc&lt;/code&gt; callback additionally gets an array of primitives as input (&lt;code&gt;primitives&lt;/code&gt; argument), and the size of this array (&lt;code&gt;primitiveCount&lt;/code&gt; argument). The callback should read the &lt;code&gt;geomID&lt;/code&gt; and &lt;code&gt;primID&lt;/code&gt; members from the passed primitives to construct the leaf.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCSplitPrimitiveFunc&lt;/code&gt; callback is invoked in high quality mode to split a primitive (&lt;code&gt;primitive&lt;/code&gt; argument) at the specified position (&lt;code&gt;position&lt;/code&gt; argument) and dimension (&lt;code&gt;dimension&lt;/code&gt; argument). The callback should return bounds of the clipped left and right parts of the primitive (&lt;code&gt;leftBounds&lt;/code&gt; and &lt;code&gt;rightBounds&lt;/code&gt; arguments).&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;RTCProgressMonitorFunction&lt;/code&gt; callback function is called with the estimated completion rate &lt;code&gt;n&lt;/code&gt; in the range $[0,1]$. Returning &lt;code&gt;true&lt;/code&gt; from the callback lets the build continue; returning &lt;code&gt;false&lt;/code&gt; cancels the build.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;On failure an error code is set that can be queried using &lt;code&gt;rtcGetDeviceError&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcNewBVH]&lt;/p&gt; &#xA;&lt;h2&gt;RTCQuaternionDecomposition&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTCQuaternionDecomposition - structure that represents a quaternion&#xA;  decomposition of an affine transformation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;struct RTCQuaternionDecomposition&#xA;{&#xA;  float scale_x, scale_y, scale_z;&#xA;  float skew_xy, skew_xz, skew_yz;&#xA;  float shift_x, shift_y, shift_z;&#xA;  float quaternion_r, quaternion_i, quaternion_j, quaternion_k;&#xA;  float translation_x, translation_y, translation_z;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The struct &lt;code&gt;RTCQuaternionDecomposition&lt;/code&gt; represents an affine transformation decomposed into three parts. An upper triangular scaling/skew/shift matrix&lt;/p&gt; &#xA;&lt;p&gt;$$ S = \left( \begin{array}{cccc} scale_x &amp;amp; skew_{xy} &amp;amp; skew_{xz} &amp;amp; shift_x \&amp;nbsp; 0 &amp;amp; scale_y &amp;amp; skew_{yz} &amp;amp; shift_y \&amp;nbsp; 0 &amp;amp; 0 &amp;amp; scale_z &amp;amp; shift_z \&amp;nbsp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \&amp;nbsp; \end{array} \right), $$&lt;/p&gt; &#xA;&lt;p&gt;a translation matrix&lt;/p&gt; &#xA;&lt;p&gt;$$ T = \left( \begin{array}{cccc} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; translation_x \&amp;nbsp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; translation_y \&amp;nbsp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; translation_z \&amp;nbsp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \&amp;nbsp; \end{array} \right), $$&lt;/p&gt; &#xA;&lt;p&gt;and a rotation matrix $R$, represented as a quaternion&lt;/p&gt; &#xA;&lt;p&gt;$quaternion_r + quaternion_i &amp;nbsp;\mathbf{i} + quaternion_j &amp;nbsp;\mathbf{i} + quaternion_k &amp;nbsp;\mathbf{k}$&lt;/p&gt; &#xA;&lt;p&gt;where $\mathbf{i}$, $\mathbf{j}$ $\mathbf{k}$ are the imaginary quaternion units. The passed quaternion will be normalized internally.&lt;/p&gt; &#xA;&lt;p&gt;The affine transformation matrix corresponding to a &lt;code&gt;RTCQuaternionDecomposition&lt;/code&gt; is $TRS$ and a point $p = (p_x, p_y, p_z, 1)^T$ will be transformed as $$p&#39; = T &amp;nbsp;R &amp;nbsp;S &amp;nbsp;p.$$&lt;/p&gt; &#xA;&lt;p&gt;The functions &lt;code&gt;rtcInitQuaternionDecomposition&lt;/code&gt;, &lt;code&gt;rtcQuaternionDecompositionSetQuaternion&lt;/code&gt;, &lt;code&gt;rtcQuaternionDecompositionSetScale&lt;/code&gt;, &lt;code&gt;rtcQuaternionDecompositionSetSkew&lt;/code&gt;, &lt;code&gt;rtcQuaternionDecompositionSetShift&lt;/code&gt;, and &lt;code&gt;rtcQuaternionDecompositionSetTranslation&lt;/code&gt; allow to set the fields of the structure more conveniently.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;No error code is set by this function.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryTransformQuaternion], [rtcInitQuaternionDecomposition]&lt;/p&gt; &#xA;&lt;h2&gt;rtcInitQuaternionDecomposition&lt;/h2&gt; &#xA;&lt;h4&gt;NAME {#name}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;rtcInitQuaternionDecomposition - initializes quaternion decomposition&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;SYNOPSIS {#synopsis}&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;void rtcInitQuaternionDecomposition(&#xA;  struct RTCQuaternionDecomposition* qd&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;DESCRIPTION {#description}&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;rtcInitQuaternionDecomposition&lt;/code&gt; function initializes a &lt;code&gt;RTCQuaternionDecomposition&lt;/code&gt; structure to represent an identity transformation.&lt;/p&gt; &#xA;&lt;h4&gt;EXIT STATUS {#exit-status}&lt;/h4&gt; &#xA;&lt;p&gt;No error code is set by this function.&lt;/p&gt; &#xA;&lt;h4&gt;SEE ALSO {#see-also}&lt;/h4&gt; &#xA;&lt;p&gt;[rtcSetGeometryTransformQuaternion], [RTCQuaternionDecomposition]&lt;/p&gt; &#xA;&lt;h1&gt;CPU Performance Recommendations&lt;/h1&gt; &#xA;&lt;h2&gt;MXCSR control and status register&lt;/h2&gt; &#xA;&lt;p&gt;It is strongly recommended to have the &lt;code&gt;Flush to Zero&lt;/code&gt; and &lt;code&gt;Denormals are Zero&lt;/code&gt; mode of the MXCSR control and status register enabled for each thread before calling the &lt;code&gt;rtcIntersect&lt;/code&gt;-type and &lt;code&gt;rtcOccluded&lt;/code&gt;-type functions. Otherwise, under some circumstances special handling of denormalized floating point numbers can significantly reduce application and Embree performance. When using Embree together with the Intel® Threading Building Blocks, it is sufficient to execute the following code at the beginning of the application main thread (before the creation of the &lt;code&gt;tbb::task_scheduler_init&lt;/code&gt; object):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;xmmintrin.h&amp;gt;&#xA;#include &amp;lt;pmmintrin.h&amp;gt;&#xA;...&#xA;_MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);&#xA;_MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If using a different tasking system, make sure each rendering thread has the proper mode set.&lt;/p&gt; &#xA;&lt;h2&gt;Thread Creation and Affinity Settings&lt;/h2&gt; &#xA;&lt;p&gt;Tasking systems like TBB create worker threads on demand, which will add a runtime overhead for the very first &lt;code&gt;rtcCommitScene&lt;/code&gt; call. In case you want to benchmark the scene build time, you should start the threads at application startup. You can let Embree start TBB threads by passing &lt;code&gt;start_threads=1&lt;/code&gt; to the &lt;code&gt;cfg&lt;/code&gt; parameter of &lt;code&gt;rtcNewDevice&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On machines with a high thread count (e.g.&amp;nbsp;dual-socket Xeon or Xeon Phi machines), affinitizing TBB worker threads increases build and rendering performance. You can let Embree affinitize TBB worker threads by passing &lt;code&gt;set_affinity=1&lt;/code&gt; to the &lt;code&gt;cfg&lt;/code&gt; parameter of &lt;code&gt;rtcNewDevice&lt;/code&gt;. By default, threads are not affinitized by Embree with the exception of Xeon Phi Processors where they are affinitized by default.&lt;/p&gt; &#xA;&lt;p&gt;All Embree tutorials automatically start and affinitize TBB worker threads by passing &lt;code&gt;start_threads=1,set_affinity=1&lt;/code&gt; to &lt;code&gt;rtcNewDevice&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Fast Coherent Rays&lt;/h2&gt; &#xA;&lt;p&gt;For getting the highest performance for highly coherent rays, e.g. primary or hard shadow rays, it is recommended to use packets with setting the &lt;code&gt;RTC_RAY_QUERY_FLAG_COHERENT&lt;/code&gt; flag in the &lt;code&gt;RTCIntersectArguments&lt;/code&gt; struct passed to the &lt;code&gt;rtcIntersect&lt;/code&gt;/&lt;code&gt;rtcOccluded&lt;/code&gt; calls. The rays inside each packet should be grouped as coherent as possible.&lt;/p&gt; &#xA;&lt;h2&gt;Huge Page Support&lt;/h2&gt; &#xA;&lt;p&gt;It is recommended to use huge pages under Linux to increase rendering performance. Embree supports 2MB huge pages under Windows, Linux, and macOS. Under Linux huge page support is enabled by default, and under Windows and macOS disabled by default. Huge page support can be enabled in Embree by passing &lt;code&gt;hugepages=1&lt;/code&gt; to &lt;code&gt;rtcNewDevice&lt;/code&gt; or disabled by passing &lt;code&gt;hugepages=0&lt;/code&gt; to &lt;code&gt;rtcNewDevice&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We recommend using 2MB huge pages with Embree under Linux as this improves ray tracing performance by about 5-10%. Under Windows using huge pages requires the application to run in elevated mode which is a security issue, thus likely not an option for most use cases. Under macOS huge pages are rarely available as memory tends to get quickly fragmented, thus we do not recommend using huge pages on macOS.&lt;/p&gt; &#xA;&lt;h3&gt;Huge Pages under Linux&lt;/h3&gt; &#xA;&lt;p&gt;Linux supports transparent huge pages and explicit huge pages. To enable transparent huge page support under Linux, execute the following as root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo always &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When transparent huge pages are enabled, the kernel tries to merge 4KB pages to 2MB pages when possible as a background job. Many Linux distributions have transparent huge pages enabled by default. See the following webpage for more information on &lt;a href=&#34;https://www.kernel.org/doc/Documentation/vm/transhuge.txt&#34;&gt;transparent huge pages under Linux&lt;/a&gt;. In this mode each application, including your rendering application based on Embree, will automatically tend to use huge pages.&lt;/p&gt; &#xA;&lt;p&gt;Using transparent huge pages, the transitioning from 4KB to 2MB pages might take some time. For that reason Embree also supports allocating 2MB pages directly when a huge page pool is configured. Such a pool can be configured by writing some number of huge pages to allocate to &lt;code&gt;/proc/sys/vm/nr_overcommit_hugepages&lt;/code&gt; as root user. E.g. to configure 2GB of address space for huge page allocation, execute the following as root:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;echo 1000 &amp;gt; /proc/sys/vm/nr_overcommit_hugepages&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the following webpage for more information on &lt;a href=&#34;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&#34;&gt;huge pages under Linux&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Huge Pages under Windows&lt;/h3&gt; &#xA;&lt;p&gt;To use huge pages under Windows, the current user must have the &#34;Lock pages in memory&#34; (SeLockMemoryPrivilege) assigned. This can be configured through the &#34;Local Security Policy&#34; application, by adding a user to &#34;Local Policies&#34; -&amp;gt; &#34;User Rights Assignment&#34; -&amp;gt; &#34;Lock pages in memory&#34;. You have to log out and in again for this change to take effect.&lt;/p&gt; &#xA;&lt;p&gt;Further, your application must be executed as an elevated process (&#34;Run as administrator&#34;) and the &#34;SeLockMemoryPrivilege&#34; must be explicitly enabled by your application. Example code on how to enable this privilege can be found in the &#34;common/sys/alloc.cpp&#34; file of Embree. Alternatively, Embree will try to enable this privilege when passing &lt;code&gt;enable_selockmemoryprivilege=1&lt;/code&gt; to &lt;code&gt;rtcNewDevice&lt;/code&gt;. Further, huge pages should be enabled in Embree by passing &lt;code&gt;hugepages=1&lt;/code&gt; to &lt;code&gt;rtcNewDevice&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When the system has been running for a while, physical memory gets fragmented, which can slow down the allocation of huge pages significantly under Windows.&lt;/p&gt; &#xA;&lt;h3&gt;Huge Pages under macOS&lt;/h3&gt; &#xA;&lt;p&gt;To use huge pages under macOS you have to pass &lt;code&gt;hugepages=1&lt;/code&gt; to &lt;code&gt;rtcNewDevice&lt;/code&gt; to enable that feature in Embree.&lt;/p&gt; &#xA;&lt;p&gt;When the system has been running for a while, physical memory gets quickly fragmented, and causes huge page allocations to fail. For this reason, huge pages are not very useful under macOS in practice.&lt;/p&gt; &#xA;&lt;h2&gt;Avoid store-to-load forwarding issues with single rays&lt;/h2&gt; &#xA;&lt;p&gt;We recommend to use a single SSE store to set up the &lt;code&gt;org&lt;/code&gt; and &lt;code&gt;tnear&lt;/code&gt; components, and a single SSE store to set up the &lt;code&gt;dir&lt;/code&gt; and &lt;code&gt;time&lt;/code&gt; components of a single ray (&lt;code&gt;RTCRay&lt;/code&gt; type). Storing these values using scalar stores causes a store-to-load forwarding penalty because Embree is reading these components using SSE loads later on.&lt;/p&gt; &#xA;&lt;h1&gt;GPU Performance Recommendations&lt;/h1&gt; &#xA;&lt;h2&gt;Low Code Complexity&lt;/h2&gt; &#xA;&lt;p&gt;As a general rule try to keep code complexity low, to avoid spill code generation. To achieve this we recommend splitting your renderer into separate kernels instead of using a single Uber kernel invokation.&lt;/p&gt; &#xA;&lt;p&gt;Code can further get reduced by using SYCL specialization constants to just enable rendering features required to render a given scene.&lt;/p&gt; &#xA;&lt;h2&gt;Feature Flags&lt;/h2&gt; &#xA;&lt;p&gt;Use SYCL specialization constants and the feature flags (see section [RTCFeatureFlags]) of the &lt;code&gt;rtcIntersect1&lt;/code&gt; and &lt;code&gt;rtcOccluded1&lt;/code&gt; calls to JIT compile minimal code. The passed feature flags should just contain features required to render the current scene. If JIT compile times are an issue, reduce the number of feature masks used and use JIT caching (see section &lt;a href=&#34;https://raw.githubusercontent.com/embree/embree/master/#sycl-jit-caching&#34;&gt;SYCL JIT caching&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Inline Indirect Calls&lt;/h2&gt; &#xA;&lt;p&gt;Attaching user geometry and intersection filter callbacks to the geometries of the scene is not supported in SYCL for performance reasons.&lt;/p&gt; &#xA;&lt;p&gt;Instead directly pass the user geometry and intersection filter callback functions through the &lt;code&gt;RTCIntersectArguments&lt;/code&gt; (and &lt;code&gt;RTCOccludedArguments&lt;/code&gt;) struct to &lt;code&gt;rtcIntersect1&lt;/code&gt; (and &lt;code&gt;rtcOccluded1&lt;/code&gt;) API functions as in the following example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;RTC_SYCL_INDIRECTLY_CALLABLE void intersectionFilter(&#xA;  const RTCFilterFunctionNArguments* args&#xA;) { ... }&#xA;&#xA;RTCIntersectArguments args;&#xA;rtcInitIntersectArguments(&amp;amp;args);&#xA;args.filter = intersectionFilter;&#xA;&#xA;rtcIntersect1(scene,&amp;amp;ray,&amp;amp;args);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the callback function is directly passed that way, the SYCL compiler can inline the indirect call, which gives a huge performance benefit. Do &lt;em&gt;not&lt;/em&gt; read a function pointer form some memory location and pass it to &lt;code&gt;rtcIntersect1&lt;/code&gt; (and &lt;code&gt;rtcOccluded1&lt;/code&gt;) as this will also prevent inlining.&lt;/p&gt; &#xA;&lt;h2&gt;7 Bit Ray Mask&lt;/h2&gt; &#xA;&lt;p&gt;Use just the lower 7 bits of the ray and geometry mask if possible, even though Embree supports 32 bit ray masks for geometry masking. On the CPU using any of the 32 bits yields the same performance, but the ray tracing hardware only supports an 8 bit mask, thus Embree has to emulate 32 bit masking if used. For that reason the lower 7 mask bits are hardware accelerated and fast, while the mask bits 7-31 require some software intervention and using them reduces performance. To turn on 32 bit ray masks use the RTC_FEATURE_FLAG_32_BIT_RAY_MASK (see section [RTCFeatureFlags]).&lt;/p&gt; &#xA;&lt;h2&gt;Limit Motion Blur Motions&lt;/h2&gt; &#xA;&lt;p&gt;The motion blur implementation on SYCL has some limitations regarding supported motion. Primitive motion should be maximally as large as a small multiple of the primitive size, otherwise performance can degrade a lot. If detailed geometry moves fast, best put the geometry into an instance, and apply motion blur to the instance itself, which efficiently allows larger motions. As a fallback, problematic scenes can always still get rendered robustly on the CPU.&lt;/p&gt; &#xA;&lt;h2&gt;Generic Pointers&lt;/h2&gt; &#xA;&lt;p&gt;Embree uses standard C++ pointers in its implementation. SYCL might not be able to detect the memory space these pointers refer to and has to treat them as generic pointers which are not performing optimal. The DPC++ compiler has advanced optimizations to infer the proper address space to avoid usage of generic pointers.&lt;/p&gt; &#xA;&lt;p&gt;However, if you still encounter the following warning during ahead of time compilation of SYCL kernels, then loads from generic pointer are present:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;warning: Adding XX occurrences of additional control flow due to presence&#xA;         of generic address space operations in function YYY.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To work around this issue we recommend:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Do not use local memory inside kernels that trace rays. In this case the DPC++ compiler knows that no local memory pointer can exist and will optimize generic loads. As this is typically the case for renderers, generic pointer will typically not cause issues.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Indirectly callable functions may still cause problems, even if your kernel does not use local memory. Thus best use SYCL pointers like sycl::global_ptr&#xA;   &lt;t&gt;&#xA;     and sycl::private_ptr&#xA;    &lt;t&gt;&#xA;      in indirectly callable functions to avoid generic address space usage.&#xA;    &lt;/t&gt;&#xA;   &lt;/t&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can also enforce usage of global pointers using the following DPC++ compile flags: &lt;code&gt;-cl-intel-force-global-mem-allocation -cl-intel-no-local-to-generic&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Embree Tutorials&lt;/h1&gt; &#xA;&lt;p&gt;Embree comes with a set of tutorials aimed at helping users understand how Embree can be used and extended. There is a very basic minimal that can be compiled as both C and C++, which should get new users started quickly. All other tutorials exist in an Intel® ISPC and C++ version to demonstrate the two versions of the API. Look for files named &lt;code&gt;tutorialname_device.ispc&lt;/code&gt; for the Intel® ISPC implementation of the tutorial, and files named &lt;code&gt;tutorialname_device.cpp&lt;/code&gt; for the single ray C++ version of the tutorial. To start the C++ version use the &lt;code&gt;tutorialname&lt;/code&gt; executables, to start the Intel® ISPC version use the &lt;code&gt;tutorialname_ispc&lt;/code&gt; executables. All tutorials can print available command line options using the &lt;code&gt;--help&lt;/code&gt; command line parameter.&lt;/p&gt; &#xA;&lt;p&gt;For all tutorials except minimal, you can select an initial camera using the &lt;code&gt;--vp&lt;/code&gt; (camera position), &lt;code&gt;--vi&lt;/code&gt; (camera look-at point), &lt;code&gt;--vu&lt;/code&gt; (camera up vector), and &lt;code&gt;--fov&lt;/code&gt; (vertical field of view) command line parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./triangle_geometry --vp 10 10 10 --vi 0 0 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can select the initial window size using the &lt;code&gt;--size&lt;/code&gt; command line parameter, or start the tutorials in full screen using the &lt;code&gt;--fullscreen&lt;/code&gt; parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./triangle_geometry --size 1024 1024&#xA;./triangle_geometry --fullscreen&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The initialization string for the Embree device (&lt;code&gt;rtcNewDevice&lt;/code&gt; call) can be passed to the ray tracing core through the &lt;code&gt;--rtcore&lt;/code&gt; command line parameter, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./triangle_geometry --rtcore verbose=2,threads=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The navigation in the interactive display mode follows the camera orbit model, where the camera revolves around the current center of interest. With the left mouse button you can rotate around the center of interest (the point initially set with &lt;code&gt;--vi&lt;/code&gt;). Holding Control pressed while clicking the left mouse button rotates the camera around its location. You can also use the arrow keys for navigation.&lt;/p&gt; &#xA;&lt;p&gt;You can use the following keys:&lt;/p&gt; &#xA;&lt;p&gt;F1 : Default shading&lt;/p&gt; &#xA;&lt;p&gt;F2 : Gray EyeLight shading&lt;/p&gt; &#xA;&lt;p&gt;F3 : Traces occlusion rays only.&lt;/p&gt; &#xA;&lt;p&gt;F4 : UV Coordinate visualization&lt;/p&gt; &#xA;&lt;p&gt;F5 : Geometry normal visualization&lt;/p&gt; &#xA;&lt;p&gt;F6 : Geometry ID visualization&lt;/p&gt; &#xA;&lt;p&gt;F7 : Geometry ID and Primitive ID visualization&lt;/p&gt; &#xA;&lt;p&gt;F8 : Simple shading with 16 rays per pixel for benchmarking.&lt;/p&gt; &#xA;&lt;p&gt;F9 : Switches to render cost visualization. Pressing again reduces brightness.&lt;/p&gt; &#xA;&lt;p&gt;F10 : Switches to render cost visualization. Pressing again increases brightness.&lt;/p&gt; &#xA;&lt;p&gt;f : Enters or leaves full screen mode.&lt;/p&gt; &#xA;&lt;p&gt;c : Prints camera parameters.&lt;/p&gt; &#xA;&lt;p&gt;ESC : Exits the tutorial.&lt;/p&gt; &#xA;&lt;p&gt;q : Exits the tutorial.&lt;/p&gt; &#xA;&lt;h2&gt;Minimal&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial is designed to get new users started with Embree. It can be compiled as both C and C++. It demonstrates how to initialize a device and scene, and how to intersect rays with the scene. There is no image output to keep the tutorial as simple as possible.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/minimal/minimal.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Triangle Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/triangle_geometry/triangle_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/triangle_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the creation of a static cube and ground plane using triangle meshes. It also demonstrates the use of the &lt;code&gt;rtcIntersect1&lt;/code&gt; and &lt;code&gt;rtcOccluded1&lt;/code&gt; functions to render primary visibility and hard shadows. The cube sides are colored based on the ID of the hit primitive.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/triangle_geometry/triangle_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Dynamic Scene&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/dynamic_scene/dynamic_scene_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/dynamic_scene.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the creation of a dynamic scene, consisting of several deforming spheres. Half of the spheres use the &lt;code&gt;RTC_BUILD_QUALITY_REFIT&lt;/code&gt; geometry build quality, which allows Embree to use a refitting strategy for these spheres, the other half uses the &lt;code&gt;RTC_BUILD_QUALITY_LOW&lt;/code&gt; geometry build quality, causing a high performance rebuild of their spatial data structure each frame. The spheres are colored based on the ID of the hit sphere geometry.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/dynamic_scene/dynamic_scene_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Multi Scene Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/multiscene_geometry/multiscene_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/dynamic_scene.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the creation of multiple scenes sharing the same geometry objects. Here, three scenes are built. One with all the dynamic spheres of the Dynamic Scene test and two others each with half. The ground plane is shared by all three scenes. The space bar is used to cycle the scene chosen for rendering.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/multiscene_geometry/multiscene_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;User Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/user_geometry/user_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/user_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial shows the use of user-defined geometry, to re-implement instancing, and to add analytic spheres. A two-level scene is created, with a triangle mesh as ground plane, and several user geometries that instance other scenes with a small number of spheres of different kinds. The spheres are colored using the instance ID and geometry ID of the hit sphere, to demonstrate how the same geometry instanced in different ways can be distinguished.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/user_geometry/user_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Viewer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/viewer/viewer_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/viewer.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates a simple OBJ viewer that traces primary visibility rays only. A scene consisting of multiple meshes is created, each mesh sharing the index and vertex buffer with the application. It also demonstrates how to support additional per-vertex data, such as shading normals.&lt;/p&gt; &#xA;&lt;p&gt;You need to specify an OBJ file at the command line for this tutorial to work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./viewer -i model.obj&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/viewer/viewer_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Intersection Filter&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/intersection_filter/intersection_filter_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/intersection_filter.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of filter callback functions to efficiently implement transparent objects. The filter function used for primary rays lets the ray pass through the geometry if it is entirely transparent. Otherwise, the shading loop handles the transparency properly, by potentially shooting secondary rays. The filter function used for shadow rays accumulates the transparency of all surfaces along the ray, and terminates traversal if an opaque occluder is hit.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/intersection_filter/intersection_filter_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Instanced Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/instanced_geometry/instanced_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/instanced_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the in-build instancing feature of Embree, by instancing a number of other scenes built from triangulated spheres. The spheres are again colored using the instance ID and geometry ID of the hit sphere, to demonstrate how the same geometry instanced in different ways can be distinguished.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/instanced_geometry/instanced_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Multi Level Instancing&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/multi_instanced_geometry/multi_instanced_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/multi_level_instancing.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates multi-level instancing, i.e., nesting instances into instances. To enable the tutorial, set the compile-time variable &lt;code&gt;EMBREE_MAX_INSTANCE_LEVEL_COUNT&lt;/code&gt; to a value other than the default 1. This variable is available in the code as &lt;code&gt;RTC_MAX_INSTANCE_LEVEL_COUNT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The renderer uses a basic path tracing approach, and the image will progressively refine over time. There are two levels of instances in this scene: multiple instances of the same tree nest instances of a twig. Intersections on up to &lt;code&gt;RTC_MAX_INSTANCE_LEVEL_COUNT&lt;/code&gt; nested levels of instances work out of the box. Users may obtain the &lt;em&gt;instance ID stack&lt;/em&gt; for a given hitpoint from the &lt;code&gt;instID&lt;/code&gt; member. During shading, the instance ID stack is used to accumulate normal transformation matrices for each hit. The tutorial visualizes transformed normals as colors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/multi_instanced_geometry/multi_instanced_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Path Tracer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/pathtracer/pathtracer_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/pathtracer.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial is a simple path tracer, based on the viewer tutorial.&lt;/p&gt; &#xA;&lt;p&gt;You need to specify an OBJ file and light source at the command line for this tutorial to work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./pathtracer -i model.obj --ambientlight 1 1 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As example models we provide the &#34;Austrian Imperial Crown&#34; model by &lt;a href=&#34;http://www.loramel.net&#34;&gt;Martin Lubich&lt;/a&gt; and the &#34;Asian Dragon&#34; model from the &lt;a href=&#34;http://graphics.stanford.edu/data/3Dscanrep/&#34;&gt;Stanford 3D Scanning Repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/models/releases/download/release/crown.zip&#34;&gt;crown.zip&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/models/releases/download/release/asian_dragon.zip&#34;&gt;asian_dragon.zip&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To render these models execute the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./pathtracer -c crown/crown.ecs&#xA;./pathtracer -c asian_dragon/asian_dragon.ecs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/pathtracer/pathtracer_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hair&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/hair_geometry/hair_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/hair_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of the hair geometry to render a hairball.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/hair_geometry/hair_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Curve Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/curve_geometry/curve_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/curve_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of the Linear Basis, B-Spline, and Catmull-Rom curve geometries.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/curve_geometry/curve_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Subdivision Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/subdivision_geometry/subdivision_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/subdivision_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of Catmull-Clark subdivision surfaces.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/subdivision_geometry/subdivision_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Displacement Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/displacement_geometry/displacement_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/displacement_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of Catmull-Clark subdivision surfaces with procedural displacement mapping using a constant edge tessellation level.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/displacement_geometry/displacement_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Grid Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/tree/master/tutorials/grid_geometry&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/grid_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of the memory efficient grid primitive to handle highly tessellated and displaced geometry.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/tree/master/tutorials/grid_geometry&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Point Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/point_geometry/point_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/point_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates the use of the three representations of point geometry.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/point_geometry/point_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Motion Blur Geometry&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/motion_blur_geometry/motion_blur_geometry_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/motion_blur_geometry.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates rendering of motion blur using the multi-segment motion blur feature. Shown is motion blur of a triangle mesh, quad mesh, subdivision surface, line segments, hair geometry, Bézier curves, instantiated triangle mesh where the instance moves, instantiated quad mesh where the instance and the quads move, and user geometry.&lt;/p&gt; &#xA;&lt;p&gt;The number of time steps used can be configured using the &lt;code&gt;--time-steps &amp;lt;int&amp;gt;&lt;/code&gt; and &lt;code&gt;--time-steps2 &amp;lt;int&amp;gt;&lt;/code&gt; command line parameters, and the geometry can be rendered at a specific time using the the &lt;code&gt;--time &amp;lt;float&amp;gt;&lt;/code&gt; command line parameter.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/motion_blur_geometry/motion_blur_geometry_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quaternion Motion Blur&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/quaternion_motion_blur/quaternion_motion_blur_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/quaternion_motion_blur.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates rendering of motion blur using quaternion interpolation. Shown is motion blur using spherical linear interpolation of the rotational component of the instance transformation on the left and simple linear interpolation of the instance transformation on the right. The number of time steps can be modified as well.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/quaternion_motion_blur/quaternion_motion_blur_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Interpolation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/interpolation/interpolation_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/interpolation.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates interpolation of user-defined per-vertex data.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/interpolation/interpolation_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Closest Point&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/closest_point/closest_point_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/closest_point.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates a use-case of the point query API. The scene consists of a simple collection of objects that are instanced and for several point in the scene (red points) the closest point on the surfaces of the scene are computed (white points). The closest point functionality is implemented for Embree internal and for user-defined instancing. The tutorial also illustrates how to handle instance transformations that are not similarity transforms.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/closest_point/closest_point_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Voronoi&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/voronoi/voronoi_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/voronoi.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates how to implement nearest neighbour lookups using the point query API. Several colored points are located on a plane and the corresponding voroni regions are illustrated.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/voronoi/voronoi_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Collision Detection&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/collide/collide_device.cpp&#34;&gt;&lt;img src=&#34;https://embree.github.io/images/collide.jpg&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This tutorial demonstrates how to implement collision detection using the collide API. A simple cloth solver is setup to collide with a sphere.&lt;/p&gt; &#xA;&lt;p&gt;The cloth can be reset with the &lt;code&gt;space&lt;/code&gt; bar. The sim stepped once with &lt;code&gt;n&lt;/code&gt; and continuous simulation started and paused with &lt;code&gt;p&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/collide/collide_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;BVH Builder&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial demonstrates how to use the templated hierarchy builders of Embree to build a bounding volume hierarchy with a user-defined memory layout using a high-quality SAH builder using spatial splits, a standard SAH builder, and a very fast Morton builder.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/bvh_builder/bvh_builder_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;BVH Access&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial demonstrates how to access the internal triangle acceleration structure build by Embree. Please be aware that the internal Embree data structures might change between Embree updates.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/bvh_access/bvh_access.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Find Embree&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial demonstrates how to use the &lt;code&gt;FIND_PACKAGE&lt;/code&gt; CMake feature to use an installed Embree. Under Linux and macOS the tutorial finds the Embree installation automatically, under Windows the &lt;code&gt;embree_DIR&lt;/code&gt; CMake variable must be set to the following folder of the Embree installation: &lt;code&gt;C:\Program Files\Intel\Embree3&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/find_embree/CMakeLists.txt&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Next Hit&lt;/h2&gt; &#xA;&lt;p&gt;This tutorial demonstrates how to robustly enumerate all hits along the ray using multiple ray queries and an intersection filter function. To improve performance, the tutorial also supports collecting the next N hits in a single ray query.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/embree/embree/raw/master/tutorials/next_hit/next_hit_device.cpp&#34;&gt;Source Code&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>