<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-14T01:30:43Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>facontidavide/PlotJuggler</title>
    <updated>2022-07-14T01:30:43Z</updated>
    <id>tag:github.com,2022-07-14:/facontidavide/PlotJuggler</id>
    <link href="https://github.com/facontidavide/PlotJuggler" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Time Series Visualization Tool that you deserve.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/plotjuggler3_banner.svg?sanitize=true&#34; alt=&#34;PlotJuggler&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/actions/workflows/windows.yaml&#34;&gt;&lt;img src=&#34;https://github.com/facontidavide/PlotJuggler/actions/workflows/windows.yaml/badge.svg?sanitize=true&#34; alt=&#34;windows&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/actions/workflows/ubuntu.yaml&#34;&gt;&lt;img src=&#34;https://github.com/facontidavide/PlotJuggler/actions/workflows/ubuntu.yaml/badge.svg?sanitize=true&#34; alt=&#34;ubuntu&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/actions/workflows/macos.yaml&#34;&gt;&lt;img src=&#34;https://github.com/facontidavide/PlotJuggler/actions/workflows/macos.yaml/badge.svg?sanitize=true&#34; alt=&#34;macos&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/actions?query=workflow%3Aros1&#34;&gt;&lt;img src=&#34;https://github.com/facontidavide/PlotJuggler/workflows/ros1/badge.svg?sanitize=true&#34; alt=&#34;ROS1&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/actions?query=workflow%3Aros2&#34;&gt;&lt;img src=&#34;https://github.com/facontidavide/PlotJuggler/workflows/ros2/badge.svg?sanitize=true&#34; alt=&#34;ROS2&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/intent/tweet?text=I%20use%20PlotJuggler%20and%20it%20is%20amazing%0D%0A&amp;amp;url=https://github.com/facontidavide/PlotJuggler&amp;amp;via=facontidavide&amp;amp;hashtags=dataviz,plotjuggler,GoROS,PX4&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/url/http/shields.io.svg?style=social&#34; alt=&#34;Tweet&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Gold Sponsor&lt;/strong&gt;: &lt;a href=&#34;https://www.greenzie.com/&#34;&gt;Greenzie&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;PlotJuggler 3.5&lt;/h1&gt; &#xA;&lt;p&gt;PlotJuggler is a tool to visualize time series that is &lt;strong&gt;fast&lt;/strong&gt;, &lt;strong&gt;powerful&lt;/strong&gt; and &lt;strong&gt;intuitive&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Noteworthy features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple Drag &amp;amp; Drop user interface.&lt;/li&gt; &#xA; &lt;li&gt;Load &lt;strong&gt;data from file&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Connect to live &lt;strong&gt;streaming&lt;/strong&gt; of data.&lt;/li&gt; &#xA; &lt;li&gt;Save the visualization layout and configurations to re-use them later.&lt;/li&gt; &#xA; &lt;li&gt;Fast &lt;strong&gt;OpenGL&lt;/strong&gt; visualization.&lt;/li&gt; &#xA; &lt;li&gt;Can handle &lt;strong&gt;thousands&lt;/strong&gt; of timeseries and &lt;strong&gt;millions&lt;/strong&gt; of data points.&lt;/li&gt; &#xA; &lt;li&gt;Transform your data using a simple editor: derivative, moving average, integral, etcâ€¦&lt;/li&gt; &#xA; &lt;li&gt;PlotJuggler can be easily extended using &lt;strong&gt;plugins&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/plotjuggler3.gif&#34; alt=&#34;PlotJuggler&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Data sources (file and streaming)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Load CSV files.&lt;/li&gt; &#xA; &lt;li&gt;Load &lt;a href=&#34;https://dev.px4.io/v1.9.0/en/log/ulog_file_format.html&#34;&gt;ULog&lt;/a&gt; (PX4).&lt;/li&gt; &#xA; &lt;li&gt;Subscribe to many different streaming sources: MQTT, Websockets, ZeroMQ, UDP, etc.&lt;/li&gt; &#xA; &lt;li&gt;Understands data formats such as JSON, CBOR, BSON, Message Pack, etc.&lt;/li&gt; &#xA; &lt;li&gt;Well integrated with &lt;a href=&#34;https://www.ros.org/&#34;&gt;ROS&lt;/a&gt;: open &lt;em&gt;rosbags&lt;/em&gt; and/or subscribe to ROS &lt;em&gt;topics&lt;/em&gt; (both ROS1 and ROS2).&lt;/li&gt; &#xA; &lt;li&gt;Supports the &lt;a href=&#34;https://labstreaminglayer.readthedocs.io/info/intro.html&#34;&gt;Lab Streaming Layer&lt;/a&gt;, that is used by &lt;a href=&#34;https://labstreaminglayer.readthedocs.io/info/supported_devices.html&#34;&gt;many devices&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Easily add your custom data source and/or formats...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/data_sources.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Transform and analyze your data&lt;/h2&gt; &#xA;&lt;p&gt;PlotJuggler makes it easy to visualize data but also to analyze it. You can manipulate your time series using a simple and extendable Transform Editor.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/function_editor.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you may use the Custom Function Editor, that allows you to create Multi-input / Single-output functions using a scripting language based on &lt;a href=&#34;https://www.tutorialspoint.com/lua/index.htm&#34;&gt;Lua&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you are not familiar with Lua, don&#39;t be afraid, you won&#39;t need more than 5 minutes to learn it ;)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/custom_editor.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Tutorials&lt;/h2&gt; &#xA;&lt;p&gt;To learn how to use PlotJuggler, check the tutorials here:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tutorial 1&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tutorial 2&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tutorial 3&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://slides.com/davidefaconti/introduction-to-plotjuggler&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/tutorial_1.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://slides.com/davidefaconti/plotjuggler-data&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/tutorial_2.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://slides.com/davidefaconti/plotjuggler-transforms&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/docs/tutorial_3.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Supported plugins&lt;/h2&gt; &#xA;&lt;p&gt;Some plugin can be found in a different repository. The individual README files &lt;em&gt;should&lt;/em&gt; include all the information needed to compile and use the plugin.&lt;/p&gt; &#xA;&lt;p&gt;Please submit specific issues, Pull Requests and questions on the related Github repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PlotJuggler/plotjuggler-mqtt&#34;&gt;MQTT DataStreamer&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PlotJuggler/plotjuggler-lsl&#34;&gt;Lab Streaming Layer DataStreamer&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PlotJuggler/plotjuggler-ros-plugins&#34;&gt;ROS plugins&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/PlotJuggler/plotjuggler-CAN-dbs&#34;&gt;CAN .dbg DataLoader&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want a simple example to learn how to write your own plugins, have a look at &lt;a href=&#34;https://github.com/PlotJuggler/plotjuggler-sample-plugins&#34;&gt;PlotJuggler/plotjuggler-sample-plugins&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Binary installers (with basic plugins)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Linux AppImage&lt;/strong&gt; (compatible with Ubuntu 18.04 or later): &lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/releases/download/3.5.0/PlotJuggler-3.5.0-x86_64.AppImage&#34;&gt;PlotJuggler-3.5.0-x86_64.AppImage&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Windows Installer&lt;/strong&gt;: &lt;a href=&#34;https://github.com/facontidavide/PlotJuggler/releases/download/3.5.0/PlotJuggler-Windows-3.5.0-installer.exe&#34;&gt;PlotJuggler-Windows-3.5.0-installer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;For ROS User&lt;/h3&gt; &#xA;&lt;p&gt;Install the debian packages using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; sudo apt install ros-$ROS_DISTRO-plotjuggler-ros&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to build&lt;/h2&gt; &#xA;&lt;p&gt;Clone the repository as usual:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/facontidavide/PlotJuggler.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The only binary dependency that you need installed in your system is Qt5. On Ubuntu, the debians can be installed with the the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt -y install qtbase5-dev libqt5svg5-dev libqt5websockets5-dev libqt5opengl5-dev libqt5x11extras5-dev libprotoc-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Fedora:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo dnf install qt5-qtbase-devel qt5-qtsvg-devel qt5-websockets-devel qt5-qtopendl-devel qt5-qtx11extras-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then compile using cmake (qmake is NOT supported):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; mkdir build; cd build&#xA; cmake ..&#xA; make&#xA; sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: the plugins need to be installed in the same folder of the executable.&lt;/p&gt; &#xA;&lt;h2&gt;Note for ROS users&lt;/h2&gt; &#xA;&lt;p&gt;To install PlotJuggler, just type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install ros-${ROS_DISTRO}-plotjuggler-ros&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To launch PlotJuggler on ROS, use the command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;  rosrun plotjuggler plotjuggler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or, if are using ROS2:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;   ros2 run plotjuggler plotjuggler&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since version 3.x, ROS plugins have been moved to a separate repository:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/PlotJuggler/plotjuggler-ros-plugins&#34;&gt;https://github.com/PlotJuggler/plotjuggler-ros-plugins&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Refer to the instructions in the this repository if you want to compile PJ and its ROS plugins from source.&lt;/p&gt; &#xA;&lt;h1&gt;Sponsorship and commercial support&lt;/h1&gt; &#xA;&lt;p&gt;PlotJuggler required a lot of work to be developed; my goal is to build the most intuitive and powerfull tool to visualize data and timeseries.&lt;/p&gt; &#xA;&lt;p&gt;If you find PlotJuggler useful, consider making a donation on &lt;a href=&#34;https://www.paypal.me/facontidavide&#34;&gt;PayPal&lt;/a&gt; or become a &lt;a href=&#34;https://github.com/sponsors/facontidavide&#34;&gt;Github Sponsor&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you need to extend any of the functionalities of PlotJuggler to cover a specific need or to parse your custom data formats, you can receive commercial support from the main author, &lt;a href=&#34;mailto:davide.faconti@gmail.com&#34;&gt;Davide Faconti&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;PlotJuggler is released under the &lt;a href=&#34;https://raw.githubusercontent.com/facontidavide/PlotJuggler/main/LICENSE.md&#34;&gt;Mozilla Public License Version 2.0&lt;/a&gt;, which allows user to develop closed-source plugins.&lt;/p&gt; &#xA;&lt;p&gt;Please note that some third party dependencies (including Qt) use the &lt;strong&gt;GNU Lesser General Public License&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Stargazers&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://starchart.cc/facontidavide/PlotJuggler&#34;&gt;&lt;img src=&#34;https://starchart.cc/facontidavide/PlotJuggler.svg?sanitize=true&#34; alt=&#34;Stargazers over time&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/tcmalloc</title>
    <updated>2022-07-14T01:30:43Z</updated>
    <id>tag:github.com,2022-07-14:/google/tcmalloc</id>
    <link href="https://github.com/google/tcmalloc" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TCMalloc&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains the TCMalloc C++ code.&lt;/p&gt; &#xA;&lt;p&gt;TCMalloc is Google&#39;s customized implementation of C&#39;s &lt;code&gt;malloc()&lt;/code&gt; and C++&#39;s &lt;code&gt;operator new&lt;/code&gt; used for memory allocation within our C and C++ code. TCMalloc is a fast, multi-threaded malloc implementation.&lt;/p&gt; &#xA;&lt;h2&gt;Building TCMalloc&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bazel.build&#34;&gt;Bazel&lt;/a&gt; is the official build system for TCMalloc.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/platforms.md&#34;&gt;TCMalloc Platforms Guide&lt;/a&gt; contains information on platform support for TCMalloc.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;All users of TCMalloc should consult the following documentation resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/quickstart.md&#34;&gt;TCMalloc Quickstart&lt;/a&gt; covers downloading, installing, building, and testing TCMalloc, including incorporating within your codebase.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/overview.md&#34;&gt;TCMalloc Overview&lt;/a&gt; covers the basic architecture of TCMalloc, and how that may affect configuration choices.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/reference.md&#34;&gt;TCMalloc Reference&lt;/a&gt; covers the C and C++ TCMalloc API endpoints.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More advanced usages of TCMalloc may find the following documentation useful:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/tuning.md&#34;&gt;TCMalloc Tuning Guide&lt;/a&gt; covers the configuration choices in more depth, and also illustrates other ways to customize TCMalloc. This also covers important operating system-level properties for improving TCMalloc performance.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/design.md&#34;&gt;TCMalloc Design Doc&lt;/a&gt; covers how TCMalloc works underneath the hood, and why certain design choices were made. Most developers will not need this level of implementation detail.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/google/tcmalloc/master/docs/compatibility.md&#34;&gt;TCMalloc Compatibility Guide&lt;/a&gt; which documents our expectations for how our APIs are used.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The TCMalloc library is licensed under the terms of the Apache license. See LICENSE for more information.&lt;/p&gt; &#xA;&lt;p&gt;Disclaimer: This is not an officially supported Google product.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Chlumsky/msdfgen</title>
    <updated>2022-07-14T01:30:43Z</updated>
    <id>tag:github.com,2022-07-14:/Chlumsky/msdfgen</id>
    <link href="https://github.com/Chlumsky/msdfgen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Multi-channel signed distance field generator&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Multi-channel signed distance field generator&lt;/h1&gt; &#xA;&lt;p&gt;This is a utility for generating signed distance fields from vector shapes and font glyphs, which serve as a texture representation that can be used in real-time graphics to efficiently reproduce said shapes. Although it can also be used to generate conventional signed distance fields best known from &lt;a href=&#34;https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf&#34;&gt;this Valve paper&lt;/a&gt; and pseudo-distance fields, its primary purpose is to generate multi-channel distance fields, using a method I have developed. Unlike monochrome distance fields, they have the ability to reproduce sharp corners almost perfectly by utilizing all three color channels.&lt;/p&gt; &#xA;&lt;p&gt;The following comparison demonstrates the improvement in image quality.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/18639794/106391899-e37ebe80-63ef-11eb-988b-4764004bb196.png&#34; alt=&#34;demo-msdf16&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/18639794/106391905-e679af00-63ef-11eb-96c3-993176330911.png&#34; alt=&#34;demo-sdf16&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/18639794/106391906-e7aadc00-63ef-11eb-8f84-d402d0dd9174.png&#34; alt=&#34;demo-sdf32&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To learn more about this method, you can read my &lt;a href=&#34;https://github.com/Chlumsky/msdfgen/files/3050967/thesis.pdf&#34;&gt;Master&#39;s thesis&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Check out my &lt;a href=&#34;https://github.com/Chlumsky/msdf-atlas-gen&#34;&gt;MSDF-Atlas-Gen&lt;/a&gt; if you want to generate entire glyph atlases for text rendering.&lt;/li&gt; &#xA; &lt;li&gt;See what&#39;s new in the &lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/CHANGELOG.md&#34;&gt;changelog&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;The project can be used either as a library or as a console program. It is divided into two parts, &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/core&#34;&gt;core&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/ext&#34;&gt;extensions&lt;/a&gt;&lt;/strong&gt;. The core module has no dependencies and only uses bare C++. It contains all key data structures and algorithms, which can be accessed through the &lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/msdfgen.h&#34;&gt;msdfgen.h&lt;/a&gt; header. Extensions contain utilities for loading fonts and SVG files, as well as saving PNG images. Those are exposed by the &lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/msdfgen-ext.h&#34;&gt;msdfgen-ext.h&lt;/a&gt; header. This module uses &lt;a href=&#34;http://www.freetype.org/&#34;&gt;FreeType&lt;/a&gt;, &lt;a href=&#34;http://www.grinninglizard.com/tinyxml2/&#34;&gt;TinyXML2&lt;/a&gt;, &lt;a href=&#34;http://lodev.org/lodepng/&#34;&gt;LodePNG&lt;/a&gt;, and (optionally) &lt;a href=&#34;https://skia.org/&#34;&gt;Skia&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, there is the &lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/main.cpp&#34;&gt;main.cpp&lt;/a&gt;, which wraps the functionality into a comprehensive standalone console program. To start using the program immediately, there is a Windows binary available for download in the &lt;a href=&#34;https://github.com/Chlumsky/msdfgen/releases&#34;&gt;&#34;Releases&#34; section&lt;/a&gt;. To build the project, you may use the included &lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/Msdfgen.sln&#34;&gt;Visual Studio solution&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/Chlumsky/msdfgen/master/CMakeLists.txt&#34;&gt;CMake script&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Console commands&lt;/h2&gt; &#xA;&lt;p&gt;The standalone program is executed as&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;msdfgen.exe &amp;lt;mode&amp;gt; &amp;lt;input&amp;gt; &amp;lt;options&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where only the input specification is required.&lt;/p&gt; &#xA;&lt;p&gt;Mode can be one of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;sdf&lt;/strong&gt; â€“ generates a conventional monochrome (true) signed distance field.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;psdf&lt;/strong&gt; â€“ generates a monochrome signed pseudo-distance field.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;msdf&lt;/strong&gt; (default) â€“ generates a multi-channel signed distance field using my new method.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;mtsdf&lt;/strong&gt; â€“ generates a combined multi-channel and true signed distance field in the alpha channel.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The input can be specified as one of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;-font &amp;lt;filename.ttf&amp;gt; &amp;lt;character code&amp;gt;&lt;/strong&gt; â€“ to load a glyph from a font file. Character code can be expressed as either a decimal (63) or hexadecimal (0x3F) Unicode value, or an ASCII character in single quotes (&#39;?&#39;).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-svg &amp;lt;filename.svg&amp;gt;&lt;/strong&gt; â€“ to load an SVG file. Note that only the last vector path in the file will be used.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-shapedesc &amp;lt;filename.txt&amp;gt;&lt;/strong&gt;, -defineshape &amp;lt;definition&amp;gt;, -stdin â€“ to load a text description of the shape from either a file, the next argument, or the standard input, respectively. Its syntax is documented further down.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The complete list of available options can be printed with &lt;strong&gt;-help&lt;/strong&gt;. Some of the important ones are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;-o &amp;lt;filename&amp;gt;&lt;/strong&gt; â€“ specifies the output file name. The desired format will be deduced from the extension (png, bmp, tif, txt, bin). Otherwise, use -format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-size &amp;lt;width&amp;gt; &amp;lt;height&amp;gt;&lt;/strong&gt; â€“ specifies the dimensions of the output distance field (in pixels).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-range &amp;lt;range&amp;gt;&lt;/strong&gt;, &lt;strong&gt;-pxrange &amp;lt;range&amp;gt;&lt;/strong&gt; â€“ specifies the width of the range around the shape between the minimum and maximum representable signed distance in shape units or distance field pixels, respectivelly.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-scale &amp;lt;scale&amp;gt;&lt;/strong&gt; â€“ sets the scale used to convert shape units to distance field pixels.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-translate &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/strong&gt; â€“ sets the translation of the shape in shape units. Otherwise the origin (0, 0) lies in the bottom left corner.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-autoframe&lt;/strong&gt; â€“ automatically frames the shape to fit the distance field. If the output must be precisely aligned, you should manually position it using -translate and -scale instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-angle &amp;lt;angle&amp;gt;&lt;/strong&gt; â€“ specifies the maximum angle to be considered a corner. Can be expressed in radians (3.0) or degrees with D at the end (171.9D).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-testrender &amp;lt;filename.png&amp;gt; &amp;lt;width&amp;gt; &amp;lt;height&amp;gt;&lt;/strong&gt; - tests the generated distance field by using it to render an image of the original shape into a PNG file with the specified dimensions. Alternatively, -testrendermulti renders an image without combining the color channels, and may give you an insight in how the multi-channel distance field works.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-exportshape &amp;lt;filename.txt&amp;gt;&lt;/strong&gt; - saves the text description of the shape with edge coloring to the specified file. This can be later edited and used as input through -shapedesc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;-printmetrics&lt;/strong&gt; â€“ prints some useful information about the shape&#39;s layout.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;msdfgen.exe msdf -font C:\Windows\Fonts\arialbd.ttf &#39;M&#39; -o msdf.png -size 32 32 -pxrange 4 -autoframe -testrender render.png 1024 1024&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will take the glyph capital M from the Arial Bold typeface, generate a 32Ã—32 multi-channel distance field with a 4 pixels wide distance range, store it into msdf.png, and create a test render of the glyph as render.png.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Do not use &lt;code&gt;-autoframe&lt;/code&gt; to generate character maps! It is intended as a quick preview only.&lt;/p&gt; &#xA;&lt;h2&gt;Library API&lt;/h2&gt; &#xA;&lt;p&gt;If you choose to use this utility inside your own program, there are a few simple steps you need to perform in order to generate a distance field. Please note that all classes and functions are in the &lt;code&gt;msdfgen&lt;/code&gt; namespace.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Acquire a &lt;code&gt;Shape&lt;/code&gt; object. You can either load it via &lt;code&gt;loadGlyph&lt;/code&gt; or &lt;code&gt;loadSvgShape&lt;/code&gt;, or construct it manually. It consists of closed contours, which in turn consist of edges. An edge is represented by a &lt;code&gt;LinearEdge&lt;/code&gt;, &lt;code&gt;QuadraticEdge&lt;/code&gt;, or &lt;code&gt;CubicEdge&lt;/code&gt;. You can construct them from two endpoints and 0 to 2 BÃ©zier control points.&lt;/li&gt; &#xA; &lt;li&gt;Normalize the shape using its &lt;code&gt;normalize&lt;/code&gt; method and assign colors to edges if you need a multi-channel SDF. This can be performed automatically using the &lt;code&gt;edgeColoringSimple&lt;/code&gt; heuristic, or manually by setting each edge&#39;s &lt;code&gt;color&lt;/code&gt; member. Keep in mind that at least two color channels must be turned on in each edge, and iff two edges meet at a sharp corner, they must only have one channel in common.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;code&gt;generateSDF&lt;/code&gt;, &lt;code&gt;generatePseudoSDF&lt;/code&gt;, or &lt;code&gt;generateMSDF&lt;/code&gt; to generate a distance field into a floating point &lt;code&gt;Bitmap&lt;/code&gt; object. This can then be worked with further or saved to a file using &lt;code&gt;saveBmp&lt;/code&gt;, &lt;code&gt;savePng&lt;/code&gt;, or &lt;code&gt;saveTiff&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;You may also render an image from the distance field using &lt;code&gt;renderSDF&lt;/code&gt;. Consider calling &lt;code&gt;simulate8bit&lt;/code&gt; on the distance field beforehand to simulate the standard 8 bits/channel image format.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &#34;msdfgen.h&#34;&#xA;#include &#34;msdfgen-ext.h&#34;&#xA;&#xA;using namespace msdfgen;&#xA;&#xA;int main() {&#xA;    FreetypeHandle *ft = initializeFreetype();&#xA;    if (ft) {&#xA;        FontHandle *font = loadFont(ft, &#34;C:\\Windows\\Fonts\\arialbd.ttf&#34;);&#xA;        if (font) {&#xA;            Shape shape;&#xA;            if (loadGlyph(shape, font, &#39;A&#39;)) {&#xA;                shape.normalize();&#xA;                //                      max. angle&#xA;                edgeColoringSimple(shape, 3.0);&#xA;                //           image width, height&#xA;                Bitmap&amp;lt;float, 3&amp;gt; msdf(32, 32);&#xA;                //                     range, scale, translation&#xA;                generateMSDF(msdf, shape, 4.0, 1.0, Vector2(4.0, 4.0));&#xA;                savePng(msdf, &#34;output.png&#34;);&#xA;            }&#xA;            destroyFont(font);&#xA;        }&#xA;        deinitializeFreetype(ft);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using a multi-channel distance field&lt;/h2&gt; &#xA;&lt;p&gt;Using a multi-channel distance field generated by this program is similarly simple to how a monochrome distance field is used. The only additional operation is computing the &lt;strong&gt;median&lt;/strong&gt; of the three channels inside the fragment shader, right after sampling the distance field. This signed distance value can then be used the same way as usual.&lt;/p&gt; &#xA;&lt;p&gt;The following is an example GLSL fragment shader with anti-aliasing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;in vec2 texCoord;&#xA;out vec4 color;&#xA;uniform sampler2D msdf;&#xA;uniform vec4 bgColor;&#xA;uniform vec4 fgColor;&#xA;&#xA;float median(float r, float g, float b) {&#xA;    return max(min(r, g), min(max(r, g), b));&#xA;}&#xA;&#xA;void main() {&#xA;    vec3 msd = texture(msdf, texCoord).rgb;&#xA;    float sd = median(msd.r, msd.g, msd.b);&#xA;    float screenPxDistance = screenPxRange()*(sd - 0.5);&#xA;    float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);&#xA;    color = mix(bgColor, fgColor, opacity);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;screenPxRange()&lt;/code&gt; represents the distance field range in output screen pixels. For example, if the pixel range was set to 2 when generating a 32x32 distance field, and it is used to draw a quad that is 72x72 pixels on the screen, it should return 4.5 (because 72/32 * 2 = 4.5). &lt;strong&gt;For 2D rendering, this can generally be replaced by a precomputed uniform value.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;For rendering in a &lt;strong&gt;3D perspective only&lt;/strong&gt;, where the texture scale varies across the screen, you may want to implement this function with fragment derivatives in the following way. I would suggest precomputing &lt;code&gt;unitRange&lt;/code&gt; as a uniform variable instead of &lt;code&gt;pxRange&lt;/code&gt; for better performance.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform float pxRange; // set to distance field&#39;s pixel range&#xA;&#xA;float screenPxRange() {&#xA;    vec2 unitRange = vec2(pxRange)/vec2(textureSize(msdf, 0));&#xA;    vec2 screenTexSize = vec2(1.0)/fwidth(texCoord);&#xA;    return max(0.5*dot(unitRange, screenTexSize), 1.0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;screenPxRange()&lt;/code&gt; must never be lower than 1. If it is lower than 2, there is a high probability that the anti-aliasing will fail and you may want to re-generate your distance field with a wider range.&lt;/p&gt; &#xA;&lt;h2&gt;Shape description syntax&lt;/h2&gt; &#xA;&lt;p&gt;The text shape description has the following syntax.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Each closed contour is enclosed by braces: &lt;code&gt;{ &amp;lt;contour 1&amp;gt; } { &amp;lt;contour 2&amp;gt; }&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Each point (and control point) is written as two real numbers separated by a comma.&lt;/li&gt; &#xA; &lt;li&gt;Points in a contour are separated with semicolons.&lt;/li&gt; &#xA; &lt;li&gt;The last point of each contour must be equal to the first, or the symbol &lt;code&gt;#&lt;/code&gt; can be used, which represents the first point.&lt;/li&gt; &#xA; &lt;li&gt;There can be an edge segment specification between any two points, also separated by semicolons. This can include the edge&#39;s color (&lt;code&gt;c&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;w&lt;/code&gt;) and/or one or two BÃ©zier curve control points inside parentheses.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{ -1, -1; m; -1, +1; y; +1, +1; m; +1, -1; y; # }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would represent a square with magenta and yellow edges,&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;{ 0, 1; (+1.6, -0.8; -1.6, -0.8); # }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is a teardrop shape formed by a single cubic BÃ©zier curve.&lt;/p&gt;</summary>
  </entry>
</feed>