<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-14T01:30:44Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>spaceandtimelabs/blitzar</title>
    <updated>2024-01-14T01:30:44Z</updated>
    <id>tag:github.com,2024-01-14:/spaceandtimelabs/blitzar</id>
    <link href="https://github.com/spaceandtimelabs/blitzar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Zero-knowledge proof acceleration with GPUs for C++ and Rust&lt;/p&gt;&lt;hr&gt;&lt;div id=&#34;top&#34;&gt;&lt;/div&gt; &#xA;&lt;!-- PROJECT LOGO --&gt; &#xA;&lt;br&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;picture&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: dark)&#34; width=&#34;200px&#34; srcset=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar-rs/assets/logo_dark_background.png&#34;&gt; &#xA;  &lt;source media=&#34;(prefers-color-scheme: light)&#34; width=&#34;200px&#34; srcset=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar-rs/assets/logo_light_background.png&#34;&gt; &#xA;  &lt;img alt=&#34;Blitzar&#34; width=&#34;200px&#34; src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar-rs/assets/logo_light_background.png&#34;&gt; &#xA; &lt;/picture&gt; &#xA; &lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/actions/workflows/release.yml&#34;&gt; &lt;img alt=&#34;Build State&#34; src=&#34;https://github.com/spaceandtimelabs/blitzar/actions/workflows/release.yml/badge.svg?sanitize=true&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=spaceandtimedb&#34;&gt; &lt;img alt=&#34;Twitter&#34; src=&#34;https://img.shields.io/twitter/follow/spaceandtimedb.svg?style=social&amp;amp;label=Follow&#34;&gt; &lt;/a&gt; &lt;a href=&#34;http://discord.gg/SpaceandTimeDB&#34;&gt; &lt;img alt=&#34;Discord Server&#34; src=&#34;https://img.shields.io/discord/953025874154893342?logo=discord&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/raw/main/LICENSE&#34;&gt; &lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34;&gt; &lt;/a&gt;  &lt;a href=&#34;https://en.cppreference.com/w/cpp/20&#34;&gt; &lt;img alt=&#34;C++ Logo&#34; src=&#34;https://img.shields.io/badge/C%2B%2B-20-blue?style=flat&amp;amp;logo=c%2B%2B&#34;&gt; &lt;/a&gt;  &lt;a href=&#34;https://www.linux.org/&#34;&gt; &lt;img alt=&#34;OS&#34; src=&#34;https://img.shields.io/badge/OS-Linux-blue?logo=linux&#34;&gt; &lt;/a&gt;  &lt;a href=&#34;https://www.linux.org/&#34;&gt; &lt;img alt=&#34;CPU&#34; src=&#34;https://img.shields.io/badge/CPU-x86-red&#34;&gt; &lt;/a&gt;  &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt; &lt;img alt=&#34;CUDA&#34; src=&#34;https://img.shields.io/badge/CUDA-12.2-green?style=flat&amp;amp;logo=nvidia&#34;&gt; &lt;/a&gt;  &lt;/p&gt;&#xA; &lt;p align=&#34;center&#34;&gt; Space and Time C++ library for accelerating cryptographic zero-knowledge proofs algorithms on the CPU and GPU. &lt;br&gt; &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/issues&#34;&gt;Report Bug&lt;/a&gt; | &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/issues&#34;&gt;Request a Feature&lt;/a&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h4&gt;Background&lt;/h4&gt; &#xA;&lt;p&gt;Blitzar was created by the core cryptography team at &lt;a href=&#34;https://www.spaceandtime.io/&#34;&gt;Space and Time&lt;/a&gt; to accelerate Proof of SQL, a novel zero-knowledge proof for SQL operations. After surveying our options for a GPU acceleration framework, we realized that Proof of SQL needed something better… so we built Blitzar. Now, Proof of SQL runs with a 3.2 second proving time against a million-row table on a single GPU, and it’s only getting faster.&lt;/p&gt; &#xA;&lt;p&gt;We’ve open-sourced Blitzar to provide the Web3 community with a faster and more robust framework for building GPU-accelerated zk-proofs. We’re excited to open the project to community contributions to expand the scope of Blitzar and lay the foundation for the next wave of lightning fast zk-proofs.&lt;/p&gt; &#xA;&lt;h4&gt;Overview&lt;/h4&gt; &#xA;&lt;p&gt;Blitzar is a C++ library for accelerating cryptographic zero-knowledge proof algorithms on the CPU and GPU.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;br&gt; This repo contains the C++ implementation along with cbindings and a Rust sys-crate. If you are using Rust, use the crate from the companion &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar-rs&#34;&gt;blitzar-rs&lt;/a&gt; repo.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The library provides&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Functions for doing group operations on &lt;a href=&#34;https://en.wikipedia.org/wiki/Curve25519&#34;&gt;Curve-25519&lt;/a&gt; and &lt;a href=&#34;https://ristretto.group/&#34;&gt;Ristretto25519&lt;/a&gt; elements.&lt;/li&gt; &#xA; &lt;li&gt;An implementation of &lt;a href=&#34;https://eprint.iacr.org/2017/1066.pdf&#34;&gt;Inner Product Argument Protocol&lt;/a&gt; for producing and verifying a compact proof of the inner product of two vectors.&lt;/li&gt; &#xA; &lt;li&gt;A sys-crate and bindings to make commitment computations usable from &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar-rs&#34;&gt;Rust&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The library is adopted from code in &lt;a href=&#34;https://github.com/jedisct1/libsodium&#34;&gt;libsodium&lt;/a&gt; and extends libsodium&#39;s cryptographic functions to support CUDA so that they are usable on GPUs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: This project has not undergone a security audit and is NOT ready for production use.&lt;/p&gt; &#xA;&lt;h4&gt;Computational Backends&lt;/h4&gt; &#xA;&lt;p&gt;Although the primary goal of this library is to provide GPU acceleration for cryptographic zk-proof algorithms, the library also provides CPU support for the sake of testing. The following backends are supported:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Backend&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Implementation&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Target Hardware&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;cpu&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Serial&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;x86 capable CPUs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;gpu&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Parallel&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Nvidia CUDA capable GPUs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Cryptographic Primitives&lt;/h2&gt; &#xA;&lt;h4&gt;Multi-Scalar Multiplication (MSM) / Generalized Pedersen Commitment / Multiexponentiation&lt;/h4&gt; &#xA;&lt;p&gt;Blitzar provides an implementation of Multi-Scalar Multiplication (i.e. generalized Pedersen commitments)&lt;/p&gt; &#xA;&lt;p&gt;Let $g_0\ldots g_n\in \mathbb{G}$ be elements of a group (with prime order), and let $a_0\ldots a_n\in\mathbb{F}$ be elements of the corresponding scalar field. (i.e. the field $\mathbb{F}_p$ where $p$ is the order of the group.)&lt;/p&gt; &#xA;&lt;p&gt;Then, the Generalized Pedersen Commitment of the vector $\mathbf{a}=(a_1,\ldots, a_n)$ is&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;P = a_1\cdot g_1+\cdots+ a_n\cdot g_n&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: we interchangeably use the terms &#34;multi-scalar multiplication&#34; and &#34;multiexponentiation&#34; to refer to the this operation because when the group is written additively, the operation is a multi-scalar multiplication, and when the group is written multiplicatively, the operation is a multiexponentiation.&lt;/p&gt; &#xA;&lt;p&gt;The Blitzar implementation allows for computation of multiple, potentially different length, MSMs simultaneously. Additionally, either built-in, precomputed, generators $g_n$ can be used, or they can be provided as needed.&lt;/p&gt; &#xA;&lt;p&gt;Currently, Blitzar supports Curve25519 as the group. We&#39;re always working to expand the curves that we support, so check back for updates.&lt;/p&gt; &#xA;&lt;h4&gt;Inner Product Argument&lt;/h4&gt; &#xA;&lt;p&gt;Blitzar provides a modified implementation of an inner product argument (e.g. &lt;a href=&#34;https://eprint.iacr.org/2017/1066.pdf&#34;&gt;Bulletproofs&lt;/a&gt; and &lt;a href=&#34;https://zcash.github.io/halo2/background/pc-ipa.html&#34;&gt;Halo2&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Given generators $g_1, \ldots, g_n$; Pedersen commitment $P$; scalar $c$; and vectors $\mathbf{a}=(a_1,\ldots, a_n)$ and $\mathbf{b}=(b_1,\ldots, b_n)$; Blitzar&#39;s version of the inner product proof allows a Prover to establish that&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-math&#34;&gt;\begin{aligned}&#xA;P &amp;amp;= a_1\cdot g_1+\cdots+ a_n\cdot g_n \\&#xA;c &amp;amp;= \langle \mathbf{a}, \mathbf{b} \rangle = a_1\cdot b_1+\cdots+ a_n\cdot b_n&#xA;\end{aligned}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where it is assumed that $\boldsymbol{g}$, $\boldsymbol{b}$, and $c$ are known to both the Prover and Verifier.&lt;/p&gt; &#xA;&lt;p&gt;This version of the inner product argument can be used in the context of a broader protocol.&lt;/p&gt; &#xA;&lt;h4&gt;Other Features to Come&lt;/h4&gt; &#xA;&lt;p&gt;If there is a particular feature that you would like to see, please &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/issues&#34;&gt;reach out&lt;/a&gt;. Blitzar is a community-first project, and we want to hear from you.&lt;/p&gt; &#xA;&lt;h2&gt;Performance (&lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/commit/a03f80bae30546c0b02d7e968056e3473be3a851&#34;&gt;associated commit hash&lt;/a&gt;)&lt;/h2&gt; &#xA;&lt;p&gt;Benchmarks are run against four different types of GPU:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/geforce/graphics-cards/30-series/rtx-3060-3060ti/&#34;&gt;Nvidia 3060&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/virtual-machines/nct4-v3-series&#34;&gt;Nvidia T4 - Standard_NC4as_T4_v3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/virtual-machines/ncv3-series&#34;&gt;Nvidia V100 - Standard_NC6s_v3&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/azure/virtual-machines/nc-a100-v4-series&#34;&gt;Nvidia A100 - Standard_NC24ads_A100_v4&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Multi-Scalar Multiplication / Generalized Pedersen Commitment Results:&lt;/summary&gt; &#xA; &lt;p&gt;The subsequent outcomes are derived from the preceding benchmark execution of the pedersen commitment, during which the number of sequences, bytes per element, sequence length, and GPU type were varied.&lt;/p&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/spaceandtimelabs/blitzar/raw/assets/benchmark/multiexponentiation_seconds.png&#34; alt=&#34;Multiexponentiation Benchmarks&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Inner Product Argument Results:&lt;/summary&gt; &#xA; &lt;p&gt;The subsequent outcomes are derived from the preceding benchmark execution of the inner product, during which the number of elements and the type of GPU were changed.&lt;/p&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/spaceandtimelabs/blitzar/raw/assets/benchmark/innerprod_seconds.png&#34; alt=&#34;Inner Product Benchmarks&#34;&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar/main/example&#34;&gt;example&lt;/a&gt; folder for some examples.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites to build from source&lt;/h3&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Build environment&lt;/summary&gt; &#xA; &lt;p&gt;Prerequisites:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;x86_64&lt;/code&gt; Linux instance.&lt;/li&gt; &#xA;  &lt;li&gt;Nix with flake support (check out &lt;a href=&#34;https://github.com/DeterminateSystems/nix-installer&#34;&gt;The Determinate Nix Installer&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;Nvidia GPU capable of running CUDA 12.2 code.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;From your terminal, run the following command in the root of the source directory to set up a build environment.&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Note: if this is the first time, it may take a while as we build a clang compiler from source.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Building and Testing the C++/CUDA code:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;# build all the code assets&#xA;bazel build //...&#xA;&#xA;# run all tests&#xA;bazel test //...&#xA;&#xA;# run all memory sanitized tests&#xA;bazel test --config=asan //...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Note: some tests will fail in case you don&#39;t have a GPU available.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Building and Testing the Rust Sys-Crate code:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;# run the sys-crate tests&#xA;cargo test --manifest-path rust/blitzar-sys/Cargo.toml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Although possible, this sys-crate is not meant to be used directly by Rust users. Instead, consider using the &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar-rs&#34;&gt;blitzar-rs&lt;/a&gt;, which is a high-level wrapper around this sys-crate.&lt;/p&gt; &#xA; &lt;p&gt;Note: the shared library byproduct of the C++/CUDA code is automatically copied to the Rust sys-crate under the &lt;code&gt;rust/blitzar-sys/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Add to your project&lt;/h2&gt; &#xA;&lt;p&gt;You can find release ready versions of this library under the &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/releases/&#34;&gt;release page&lt;/a&gt;. You can also build and test the library from source by following the instructions below.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;C++ Project:&lt;/summary&gt; &#xA; &lt;p&gt;See the C++ example here: &lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar/main/example/cbindings1/main.cc&#34;&gt;example/cbindings1/main.cc&lt;/a&gt;. To run this example, execute:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;bazel run //example/cbindings1:cbind1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Alternatively, compile this example code with g++:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;# Build the shared library&#xA;bazel build -c opt --config=portable_glibc //cbindings:libblitzar.so&#xA;&#xA;# Compile the C++ example code&#xA;g++ example/cbindings1/main.cc -o main -I . -L bazel-bin/cbindings/ -lblitzar&#xA;&#xA;# Execute the example code&#xA;LD_LIBRARY_PATH=$LD_LIBRARY_PATH:bazel-bin/cbindings/ ./main&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Rust Project:&lt;/summary&gt; &#xA; &lt;p&gt;See the Rust example here: &lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar/main/rust/tests/src/main.rs&#34;&gt;rust/tests/src/main.rs&lt;/a&gt;. To run this example, execute:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;cargo test --manifest-path rust/tests/Cargo.toml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Development Process&lt;/h2&gt; &#xA;&lt;p&gt;The main branch is regularly built and tested, being the only source of truth. &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/tags&#34;&gt;Tags&lt;/a&gt; are created regularly from automated semantic release executions.&lt;/p&gt; &#xA;&lt;h4&gt;Code format:&lt;/h4&gt; &#xA;&lt;p&gt;This repository follows some C++ formatting rules. To check if your modified code is compliant, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;./tools/code_format/check_format.py check&#xA;&#xA;./tools/code_format/check_format.py fix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Executing the Benchmarks:&lt;/h2&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Generalized Pedersen Commitment (MSM):&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;# Usage: benchmark &amp;lt;cpu|gpu&amp;gt; &amp;lt;n&amp;gt; &amp;lt;num_samples&amp;gt; &amp;lt;num_commitments&amp;gt; &amp;lt;element_nbytes&amp;gt; &amp;lt;verbose&amp;gt;&#xA;# - n: the size of the multiexponentiation vector (or the sequence length).&#xA;# - num_samples: the number of times to run the benchmark.&#xA;# - num_commitments: the number of commitments to generate.&#xA;# - element_nbytes: the number of bytes of each element in the vector (exponent size).&#xA;# - verbose: whether to print the results of each run.&#xA;bazel run -c opt //benchmark/multi_commitment:benchmark -- gpu 1000 5 1 32 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details open&gt; &#xA; &lt;summary&gt;Inner Product Argument:&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nix develop&#xA;&#xA;# Usage: benchmark &amp;lt;cpu|gpu&amp;gt; &amp;lt;n&amp;gt; &amp;lt;num_samples&amp;gt;&#xA;# - n: the size of the inner product vector (or the sequence length).&#xA;# - num_samples: the number of times to run the benchmark.&#xA;bazel run -c opt //benchmark/inner_product_proof:benchmark -- gpu 1000 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;re excited to open Blitzar to the community, but are not accepting community Pull Requests yet due to logistic reasons. However, feel free to contribute with any suggestion, idea, or bugfix on our &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar/issues&#34;&gt;Issues&lt;/a&gt; panel. Also, see &lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar/main/CONTRIBUTING.md&#34;&gt;contribution guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Community &amp;amp; support&lt;/h2&gt; &#xA;&lt;p&gt;Join our &lt;a href=&#34;https://discord.com/invite/SpaceandTimeDB&#34;&gt;Discord server&lt;/a&gt; to ask questions, discuss features, and for general chat.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is released under the &lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/blitzar/main/LICENSE&#34;&gt;Apache 2 License&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Rust crate&lt;/h2&gt; &#xA;&lt;p&gt;This repo contains the C++ implementation along with cbindings and a Rust sys-crate. If you are using Rust, use the crate from the companion repo here: &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar-rs&#34;&gt;https://github.com/spaceandtimelabs/blitzar-rs&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>