<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-14T01:27:20Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mr-Wiseguy/N64Recomp</title>
    <updated>2024-05-14T01:27:20Z</updated>
    <id>tag:github.com,2024-05-14:/Mr-Wiseguy/N64Recomp</id>
    <link href="https://github.com/Mr-Wiseguy/N64Recomp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tool to statically recompile N64 games into native executables&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;N64: Recompiled&lt;/h1&gt; &#xA;&lt;p&gt;N64: Recompiled is a tool to statically recompile N64 binaries into C code that can be compiled for any platform. This can be used for ports or tools as well as for simulating behaviors significantly faster than interpreters or dynamic recompilation can. More widely, it can be used in any context where you want to run some part of an N64 binary in a standalone environment.&lt;/p&gt; &#xA;&lt;p&gt;This is not the first project that uses static recompilation on game console binaries. A well known example is &lt;a href=&#34;https://github.com/andrewrk/jamulator&#34;&gt;jamulator&lt;/a&gt;, which targets NES binaries. Additionally, this is not even the first project to apply static recompilation to N64-related projects: the &lt;a href=&#34;https://github.com/decompals/ido-static-recomp&#34;&gt;IDO static recompilation&lt;/a&gt; recompiles the SGI IRIX IDO compiler on modern systems to faciliate matching decompilation of N64 games. This project works similarly to the IDO static recomp project in some ways, and that project was my main inspiration for making this.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#how-it-works&#34;&gt;How it Works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#overlays&#34;&gt;Overlays&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#how-to-use&#34;&gt;How to Use&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#single-file-output-mode-for-patches&#34;&gt;Single File Output Mode&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#rsp-microcode-support&#34;&gt;RSP Microcode Support&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#planned-features&#34;&gt;Planned Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/N64Recomp/main/#building&#34;&gt;Building&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How it Works&lt;/h2&gt; &#xA;&lt;p&gt;The recompiler works by accepting a list of symbols and metadata alongside the binary with the goal of splitting the input binary into functions that are each individually recompiled into a C function, named according to the metadata.&lt;/p&gt; &#xA;&lt;p&gt;Instructions are processed one-by-one and corresponding C code is emitted as each one gets processed. This translation is very literal in order to keep complexity low. For example, the instruction &lt;code&gt;addiu $r4, $r4, 0x20&lt;/code&gt;, which adds &lt;code&gt;0x20&lt;/code&gt; to the 32-bit value in the low bytes of register &lt;code&gt;$r4&lt;/code&gt; and stores the sign extended 64-bit result in &lt;code&gt;$r4&lt;/code&gt;, gets recompiled into &lt;code&gt;ctx-&amp;gt;r4 = ADD32(ctx-&amp;gt;r4, 0X20);&lt;/code&gt; The &lt;code&gt;jal&lt;/code&gt; (jump-and-link) instruction is recompiled directly into a function call, and &lt;code&gt;j&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; instructions (unconditional jumps and branches) that can be identified as tail-call optimizations are also recompiled into function calls as well. Branch delay slots are handled by duplicating instructions as necessary. There are other specific behaviors for certain instructions, such as the recompiler attempting to turn a &lt;code&gt;jr&lt;/code&gt; instruction into a switch-case statement if it can tell that it&#39;s being used with a jump table. The recompiler has mostly been tested on binaries built with old MIPS compilers (e.g. mips gcc 2.7.2 and IDO) as well as modern clang targeting mips. Modern mips gcc may trip up the recompiler due to certain optimizations it can do, but those cases can probably be avoided by setting specific compilation flags.&lt;/p&gt; &#xA;&lt;p&gt;Every output function created by the recompiler is currently emitted into its own file. An option may be provided in the future to group functions together into output files, which should help improve build times of the recompiler output by reducing file I/O in the build process.&lt;/p&gt; &#xA;&lt;p&gt;Recompiler output can be compiled with any C compiler (tested with msvc, gcc and clang). The output is expected to be used with a runtime that can provide the necessary functionality and macro implementations to run it. An example of most of the required macro implementations can be found in the Zelda 64: Recompiled project &lt;a href=&#34;https://github.com/Mr-Wiseguy/Zelda64Recomp/raw/dev/include/recomp.h&#34;&gt;here&lt;/a&gt;, with the project also containing accompanying code for implementing the rest of the required runtime.&lt;/p&gt; &#xA;&lt;h2&gt;Overlays&lt;/h2&gt; &#xA;&lt;p&gt;Statically linked and relocatable overlays can both be handled by this tool. In both cases, the tool emits function lookups for jump-and-link-register (i.e. function pointers or virtual functions) which the provided runtime can implement using any sort of lookup table. For example, the instruction &lt;code&gt;jalr $25&lt;/code&gt; would get recompiled as &lt;code&gt;LOOKUP_FUNC(ctx-&amp;gt;r25)(rdram, ctx);&lt;/code&gt; The runtime can then maintain a list of which program sections are loaded and at what address they are at in order to determine which function to run whenever a lookup is triggered during runtime.&lt;/p&gt; &#xA;&lt;p&gt;For relocatable overlays, the tool will modify supported instructions possessing relocation data (&lt;code&gt;lui&lt;/code&gt;, &lt;code&gt;addiu&lt;/code&gt;, load and store instructions) by emitting an extra macro that enables the runtime to relocate the instruction&#39;s immediate value field. For example, the instruction &lt;code&gt;lui $24, 0x80C0&lt;/code&gt; in a section beginning at address &lt;code&gt;0x80BFA100&lt;/code&gt; with a relocation against a symbol with an address of &lt;code&gt;0x80BFA730&lt;/code&gt; will get recompiled as &lt;code&gt;ctx-&amp;gt;r24 = S32(RELOC_HI16(1754, 0X630) &amp;lt;&amp;lt; 16);&lt;/code&gt;, where 1754 is the index of this section. The runtime can then implement the RELOC_HI16 and RELOC_LO16 macros in order to handle modifying the immediate based on the current loaded address of the section.&lt;/p&gt; &#xA;&lt;p&gt;Support for relocations for TLB mapping is coming in the future, which will add the ability to provide a list of MIPS32 relocations so that the runtime can relocate them on load. Combining this with the functionality used for relocatable overlays should allow running most TLB mapped code without incurring a performance penalty on every RAM access.&lt;/p&gt; &#xA;&lt;h2&gt;How to Use&lt;/h2&gt; &#xA;&lt;p&gt;The recompiler is configured by providing a toml file in order to configure the recompiler behavior, which is the only argument provided to the recompiler. The toml is where you specify input and output file paths, as well as optionally stub out specific functions, skip recompilation of specific functions, and patch single instructions in the target binary. There is also planned functionality to be able to emit hooks in the recompiler output by adding them to the toml (the &lt;code&gt;[[patches.func]]&lt;/code&gt; and &lt;code&gt;[[patches.hook]]&lt;/code&gt; sections of the linked toml below), but this is currently unimplemented. Documentation on every option that the recompiler provides is not currently available, but an example toml can be found in the Zelda 64: Recompiled project &lt;a href=&#34;https://github.com/Mr-Wiseguy/Zelda64Recomp/raw/dev/us.rev1.toml&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently, the only way to provide the required metadata is by passing an elf file to this tool. The easiest way to get such an elf is to set up a disassembly or decompilation of the target binary, but there will be support for providing the metadata via a custom format to bypass the need to do so in the future.&lt;/p&gt; &#xA;&lt;h2&gt;Single File Output Mode (for Patches)&lt;/h2&gt; &#xA;&lt;p&gt;This tool can also be configured to recompile in &#34;single file output&#34; mode via an option in the configuration toml. This will emit all of the functions in the provided elf into a single output file. The purpose of this mode is to be able to compile patched versions of functions from the target binary.&lt;/p&gt; &#xA;&lt;p&gt;This mode can be combined with the functionality provided by almost all linkers (ld, lld, MSVC&#39;s link.exe, etc.) to replace functions from the original recompiler output with modified versions. Those linkers only look for symbols in a static library if they weren&#39;t already found in a previous input file, so providing the recompiled patches to the linker before providing the original recompiler output will result in the patches taking priority over functions with the same names from the original recompiler output.&lt;/p&gt; &#xA;&lt;p&gt;This saves a tremendous amount of time while iterating on patches for the target binary, as you can bypass rerunning the recompiler on the target binary as well as compiling the original recompiler output. An example of using this single file output mode for that purpose can be found in the Zelda 64: Recompiled project &lt;a href=&#34;https://github.com/Mr-Wiseguy/Zelda64Recomp/raw/dev/patches.toml&#34;&gt;here&lt;/a&gt;, with the corresponding Makefile that gets used to build the elf for those patches &lt;a href=&#34;https://github.com/Mr-Wiseguy/Zelda64Recomp/raw/dev/patches/Makefile&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;RSP Microcode Support&lt;/h2&gt; &#xA;&lt;p&gt;RSP microcode can also be recompiled with this tool. Currently there is no support for recompiling RSP overlays, but it may be added in the future if desired. Documentation on how to use this functionality will be coming soon.&lt;/p&gt; &#xA;&lt;h2&gt;Planned Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Custom metadata format to provide symbol names, relocations, and any other necessary data in order to operate without an elf&lt;/li&gt; &#xA; &lt;li&gt;Emitting multiple functions per output file to speed up compilation&lt;/li&gt; &#xA; &lt;li&gt;Support for recording MIPS32 relocations to allow runtimes to relocate them for TLB mapping&lt;/li&gt; &#xA; &lt;li&gt;Ability to recompile into a dynamic language (such as Lua) to be able to load code at runtime for mod support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;This project can be built with CMake 3.20 or above and a C++ compiler that supports C++20. This repo uses git submodules, so be sure to clone recursively (&lt;code&gt;git clone --recurse-submodules&lt;/code&gt;) or initialize submodules recursively after cloning (&lt;code&gt;git submodule update --init --recursive&lt;/code&gt;). From there, building is identical to any other cmake project, e.g. run &lt;code&gt;cmake&lt;/code&gt; in the target build folder and point it at the root of this repo, then run &lt;code&gt;cmake --build .&lt;/code&gt; from that target folder.&lt;/p&gt; &#xA;&lt;h2&gt;Libraries Used&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Decompollaborate/rabbitizer&#34;&gt;rabbitizer&lt;/a&gt; for instruction decoding/analysis&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/serge1/ELFIO&#34;&gt;ELFIO&lt;/a&gt; for elf parsing&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ToruNiina/toml11&#34;&gt;toml11&lt;/a&gt; for toml parsing&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fmtlib/fmt&#34;&gt;fmtlib&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>Mr-Wiseguy/Zelda64Recomp</title>
    <updated>2024-05-14T01:27:20Z</updated>
    <id>tag:github.com,2024-05-14:/Mr-Wiseguy/Zelda64Recomp</id>
    <link href="https://github.com/Mr-Wiseguy/Zelda64Recomp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Static recompilation of Majora&#39;s Mask (and soon Ocarina of Time) for PC (Windows/Linux)&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Zelda 64: Recompiled&lt;/h1&gt; &#xA;&lt;p&gt;Zelda 64: Recompiled is a project that uses &lt;a href=&#34;https://github.com/Mr-Wiseguy/N64Recomp&#34;&gt;N64: Recompiled&lt;/a&gt; to &lt;strong&gt;statically recompile&lt;/strong&gt; Majora&#39;s Mask (and soon Ocarina of Time) into a native port with many new features and enhancements. This project uses &lt;a href=&#34;https://github.com/rt64/rt64&#34;&gt;RT64&lt;/a&gt; as the rendering engine to provide some of these enhancements.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/Mr-Wiseguy/Zelda64Recomp/releases/tag/v1.0.0&#34;&gt;Check out the latest release here&lt;/a&gt;.&lt;/h3&gt; &#xA;&lt;h3&gt;&lt;strong&gt;This repository and its releases do not contain game assets. The original game is required to build or run this project.&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#system-requirements&#34;&gt;System Requirements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#features&#34;&gt;Features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#plug-and-play&#34;&gt;Plug and Play&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#fully-intact-n64-effects&#34;&gt;Fully Intact N64 Effects&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#easy-to-use-menus&#34;&gt;Easy-to-Use Menus&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#high-framerate-support&#34;&gt;High Framerate Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#widescreen-and-ultrawide-support&#34;&gt;Widescreen and Ultrawide Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#gyro-aim&#34;&gt;Gyro Aim&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#autosaving&#34;&gt;Autosaving&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#low-input-lag&#34;&gt;Low Input Lag&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#instant-load-times&#34;&gt;Instant Load Times&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#linux-and-steam-deck-support&#34;&gt;Linux and Steam Deck Support&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#planned-features&#34;&gt;Planned Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#faq&#34;&gt;FAQ&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#known-issues&#34;&gt;Known Issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#building&#34;&gt;Building&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#libraries-used-and-projects-referenced&#34;&gt;Libraries Used and Projects Referenced&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;System Requirements&lt;/h2&gt; &#xA;&lt;p&gt;A GPU supporting Direct3D 12.0 (Shader Model 6) or Vulkan 1.2 is required to run this project. The oldest GPUs that should be supported for each vendor are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GeForce GT 630&lt;/li&gt; &#xA; &lt;li&gt;Radeon HD 7750 (the one from 2012, not to be confused with the RX 7000 series) and newer&lt;/li&gt; &#xA; &lt;li&gt;Intel HD 510 (Skylake)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A CPU supporting the AVX instruction set is also required (Intel Core 2000 series or AMD Bulldozer and newer).&lt;/p&gt; &#xA;&lt;p&gt;If you have issues with crashes on startup, make sure your graphics drivers are fully up to date.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;h4&gt;Plug and Play&lt;/h4&gt; &#xA;&lt;p&gt;Simply provide your copy of the North American version of the game in the main menu and start playing! This project will automatically load assets from the provided copy, so there is no need to go through a separate extraction step or build the game yourself. Other versions of the game may be supported in the future.&lt;/p&gt; &#xA;&lt;h4&gt;Fully Intact N64 Effects&lt;/h4&gt; &#xA;&lt;p&gt;A lot of care was put into RT64 to make sure all graphical effects were rendered exactly as they did originally on the N64. No workarounds or &#34;hacks&#34; were made to replicate these effects, with the only modifications to them being made for enhancement purposes such as widescreen support. This includes framebuffer effects like the grayscale cutscenes and the Deku bubble projectile, depth effects like the lens of truth, decals such as shadows or impact textures, accurate lighting, shading effects like the fire arrows and bomb explosions, and various textures that are often rendered incorrectly.&lt;/p&gt; &#xA;&lt;h4&gt;Easy-to-Use Menus&lt;/h4&gt; &#xA;&lt;p&gt;Gameplay settings, graphics settings, input mappings, and audio settings can all be configured with the in-game config menu. The menus can all be used with mouse, controller, or keyboard for maximum convenience.&lt;/p&gt; &#xA;&lt;h4&gt;High Framerate Support&lt;/h4&gt; &#xA;&lt;p&gt;Play at any framerate you want thanks to functionality provided by RT64! Game objects and terrain, texture scrolling, screen effects, and most HUD elements are all rendered at high framerates. By default, this project is configured to run at your monitor&#39;s refresh rate. You can also play at the original framerate of the game if you prefer. &lt;strong&gt;Changing framerate has no effect on gameplay.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: External framerate limiters (such as the NVIDIA Control Panel) are known to potentially cause problems, so if you notice any stuttering then turn them off and use the manual framerate slider in the in-game graphics menu instead.&lt;/p&gt; &#xA;&lt;h4&gt;Widescreen and Ultrawide Support&lt;/h4&gt; &#xA;&lt;p&gt;Any aspect ratio is supported, with most effects modded to work correctly in widescreen. The HUD can also be positioned at 16:9 when using ultrawide aspect ratios if preferred.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Some animation quirks can be seen at the edges of the screen in certain cutscenes when using very wide aspect ratios.&lt;/p&gt; &#xA;&lt;h4&gt;Gyro Aim&lt;/h4&gt; &#xA;&lt;p&gt;When playing with a supported controller, first-person items such as the bow can be aimed with your controller&#39;s gyro sensor. This includes (but is not limited to) controllers such as the Dualshock 4, Dualsense, Switch Pro, and most third party Switch controllers (such as the 8BitDo Pro 2 in Switch mode).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Gamepad mappers such as BetterJoy or DS4Windows may intercept gyro data and prevent the game from receiving it. Most controllers are natively supported, so turning gamepad mappers off is recommended if you want to use gyro.&lt;/p&gt; &#xA;&lt;h4&gt;Autosaving&lt;/h4&gt; &#xA;&lt;p&gt;Never worry about losing progress if your power goes out thanks to autosaving! The autosave system is designed to respect Majora&#39;s Mask&#39;s original save system and maintain the intention of owl saves by triggering automatically and replacing the previous autosave or owl save. However, if you&#39;d still rather play with the untouched save system, simply turn off autosaving in the ingame menu.&lt;/p&gt; &#xA;&lt;h4&gt;Low Input Lag&lt;/h4&gt; &#xA;&lt;p&gt;This project has been optimized to have as little input lag as possible, making the game feel more responsive than ever!&lt;/p&gt; &#xA;&lt;h4&gt;Instant Load Times&lt;/h4&gt; &#xA;&lt;p&gt;Saving and loading files, going from place to place, and pausing all happen in the blink of an eye thanks to the game running natively on modern hardware.&lt;/p&gt; &#xA;&lt;h4&gt;Linux and Steam Deck Support&lt;/h4&gt; &#xA;&lt;p&gt;A Linux binary is available for playing on most up-to-date distros, including on the Steam Deck.&lt;/p&gt; &#xA;&lt;p&gt;To play on Steam Deck, extract the Linux build onto your deck. Then, in desktop mode, right click the Zelda64Recompiled executable file and select &#34;Add to Steam&#34; as shown. From there, you can return to Gaming mode and configure the controls as needed. See the &lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/#how-do-i-set-up-gyro-aiming-on-steam-deck&#34;&gt;Steam Deck gyro aim FAQ section&lt;/a&gt; for more detailed instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Planned Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dual analog control scheme (with analog camera)&lt;/li&gt; &#xA; &lt;li&gt;Configurable deadzone and analog stick sensitivity&lt;/li&gt; &#xA; &lt;li&gt;Ocarina of Time support&lt;/li&gt; &#xA; &lt;li&gt;Mod support and Randomizer&lt;/li&gt; &#xA; &lt;li&gt;Texture Packs&lt;/li&gt; &#xA; &lt;li&gt;Model Replacements&lt;/li&gt; &#xA; &lt;li&gt;Ray Tracing (via RT64)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h4&gt;What is static recompilation?&lt;/h4&gt; &#xA;&lt;p&gt;Static recompilation is the process of automatically translating an application from one platform to another. For more details, check out the full description of how this project&#39;s recompilation works here: &lt;a href=&#34;https://github.com/Mr-Wiseguy/N64Recomp&#34;&gt;N64: Recompiled&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;How is this related to the decompilation project?&lt;/h4&gt; &#xA;&lt;p&gt;Unlike N64 ports in the past, this project is not based on the source code provided by a decompilation of the game. This is because static recompilation bypasses the need for decompiled source code when making a port, allowing ports to be made &lt;strong&gt;without source code&lt;/strong&gt;. However, the reverse engineering work done by the decompilation team was invaluable for providing some of the enhancements featured in this project. For this reason, the project uses headers and some functions from the decompilation project in order to make modifications to the game. Many thanks to the decompilation team for all of the hard work they&#39;ve done.&lt;/p&gt; &#xA;&lt;h4&gt;How do I set up gyro aiming on Steam Deck?&lt;/h4&gt; &#xA;&lt;p&gt;This project provides mouse aiming as a way to allow using gyro on Steam Deck, as the Steam Deck&#39;s gyro sensors cannot be read directly. First, launch the game in Gaming Mode, press the Steam button and go to &#34;Controller Settings&#34;. Choose &#34;Controller Settings&#34; again in the menu that follows, and then set &#34;Gyro Behavior&#34; to &#34;As Mouse&#34;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/docs/deck_gyro_1.jpg&#34; alt=&#34;Controller Settings menu&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll probably also want to change the default behavior so that you don&#39;t need to be touching the right stick to allow gyro input. To do so, click on the Gear icon to the right of &#34;Gyro Behavior&#34; and ensure that &#34;Gyro Activation Buttons&#34; is set to &#34;None Selected (Gyro Always On).&#34; If this isn&#39;t the case, then select that option and then press &#34;Select None&#34; in the following menu.&lt;/p&gt; &#xA;&lt;h2&gt;Known Issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The motion blur effect used by the game was capped to prevent ghosting at incredibly high framerates, which causes it to be less noticeable (this is only really noticeable above 120FPS). This may be fixed in the future by offering the option to render to an HDR framebuffer internally, which would allow it to be uncapped.&lt;/li&gt; &#xA; &lt;li&gt;Intel GPUs on Linux may not currently work. If you have experience with Vulkan development on Linux, help here would be greatly appreciated!&lt;/li&gt; &#xA; &lt;li&gt;The prebuilt Linux binary may not work correctly on some distributions of Linux. If you encounter such an issue, building the project locally yourself is recommended. A Flatpak or AppImage may be provided in the future to solve this issue. Alternatively, running the Windows version with Proton is known to work well and may work around this issue.&lt;/li&gt; &#xA; &lt;li&gt;Overlays such as MSI Afterburner and other software such as Wallpaper Engine can cause performance issues with this project that prevent the game from rendering correctly. Disabling such software is recommended.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Building is not required to play this project, as prebuilt binaries (which do not contain game assets) can be found in the &lt;a href=&#34;https://github.com/Mr-Wiseguy/Zelda64Recomp/releases&#34;&gt;Releases section&lt;/a&gt;. Instructions on how to build this project are being worked on and will be available in the near future.&lt;/p&gt; &#xA;&lt;h2&gt;Libraries Used and Projects Referenced&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rt64/rt64&#34;&gt;RT64&lt;/a&gt; for the project&#39;s rendering engine&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/mikke89/RmlUi&#34;&gt;RmlUi&lt;/a&gt; for building the menus and launcher&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sammycage/lunasvg&#34;&gt;lunasvg&lt;/a&gt; for SVG rendering, used by RmlUi&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://freetype.org/&#34;&gt;FreeType&lt;/a&gt; for font rendering, used by RmlUi&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cameron314/concurrentqueue&#34;&gt;moodycamel::ConcurrentQueue&lt;/a&gt; for semaphores and fast, lock-free MPMC queues&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/JibbSmart/GamepadMotionHelpers&#34;&gt;Gamepad Motion Helpers&lt;/a&gt; for sensor fusion and calibration algorithms to implement gyro aiming&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zeldaret/mm&#34;&gt;Majora&#39;s Mask Decompilation&lt;/a&gt; for headers and some function definitions, used for making patches or some enhancements&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ares-emulator/ares&#34;&gt;Ares emulator&lt;/a&gt; for RSP vector instruction reference implementations, used in RSP recompilation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Special thanks to &lt;a href=&#34;https://raw.githubusercontent.com/Mr-Wiseguy/Zelda64Recomp/dev/github.com/thecozies&#34;&gt;thecozies&lt;/a&gt; for designing and helping implement the launcher and config menus!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>rt64/rt64</title>
    <updated>2024-05-14T01:27:20Z</updated>
    <id>tag:github.com,2024-05-14:/rt64/rt64</id>
    <link href="https://github.com/rt64/rt64" rel="alternate"></link>
    <summary type="html">&lt;p&gt;RT64 is an N64 graphics renderer for playing with enhancements in emulators and native ports.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RT64&lt;/h1&gt; &#xA;&lt;p&gt;RT64 is an N64 graphics renderer for playing games with enhancements in emulators and native ports.&lt;/p&gt; &#xA;&lt;h1&gt;Work in Progress&lt;/h1&gt; &#xA;&lt;h3&gt;&lt;strong&gt;Emulator Support (Plugin) and Ray Tracing (RT) are not available in this repository yet.&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This repository has been made public to provide a working implementation to native ports that wish to use RT64 as their renderer.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Development of these features is still ongoing and will be added to this repository when they&#39;re ready.&lt;/strong&gt; Thank you for your patience!&lt;/p&gt; &#xA;&lt;h1&gt;Features available&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Modern N64 renderer built on the latest APIs (D3D12 and Vulkan).&lt;/li&gt; &#xA; &lt;li&gt;Uses ubershaders to guarantee no stutters due to pipeline compilation.&lt;/li&gt; &#xA; &lt;li&gt;Brand new architecture designed around offering novel enhancements.&lt;/li&gt; &#xA; &lt;li&gt;High level of accuracy and no tolerance for game-specific workarounds to achieve correct rendering.&lt;/li&gt; &#xA; &lt;li&gt;Input latency reduction options to either skip the game&#39;s native buffering or draw as early as possible.&lt;/li&gt; &#xA; &lt;li&gt;Render with a higher resolution and downsample to a resolution closer to the original game.&lt;/li&gt; &#xA; &lt;li&gt;Support for Widescreen with arbitrary aspect ratios, including Ultrawide support (limited game support).&lt;/li&gt; &#xA; &lt;li&gt;Interpolate the game&#39;s visuals to 60 FPS or above (HFR) by generating new frames and modifying them in 3D space (limited game support).&lt;/li&gt; &#xA; &lt;li&gt;Extended command set for better integration of widescreen, interpolation and path tracing features (for use with rom patches, rom hacks, and ports).&lt;/li&gt; &#xA; &lt;li&gt;Supports Windows 10, Windows 11 and Linux.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Features in development (in priority order)&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;HD texture packs. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Compatibility with texture packs that use the Rice texture format.&lt;/li&gt; &#xA;   &lt;li&gt;Brand new texture pack configuration format for higher levels of control.&lt;/li&gt; &#xA;   &lt;li&gt;Supports both DDS (with mipmaps) and PNG.&lt;/li&gt; &#xA;   &lt;li&gt;Asynchronous streaming.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Game script interpreter. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Support a runtime language for configuring the path traced renderer based on the contents of the game&#39;s memory.&lt;/li&gt; &#xA;   &lt;li&gt;Support patching the game&#39;s memory to provide various enhancements automatically integrated with the game script.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Fully path traced renderer (RT). &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Calculate all lighting in real time and replace the contents of the drawn scene entirely with a path traced version.&lt;/li&gt; &#xA;   &lt;li&gt;Provide support for extra modifications for altering the material properties of the surfaces in the game.&lt;/li&gt; &#xA;   &lt;li&gt;Game support will be limited to a very small selection of games initially.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Emulator integration. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Game compatibility database and feature whitelist.&lt;/li&gt; &#xA;   &lt;li&gt;Configuration screen.&lt;/li&gt; &#xA;   &lt;li&gt;List of supported emulators to be determined.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Model replacements. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Details to be determined.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Building&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;CMake 3.20 or above.&lt;/li&gt; &#xA; &lt;li&gt;C++17 compiler. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Known to work with Microsoft Visual C++, Clang or GCC.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Windows 10 or 11 SDK (Windows only).&lt;/li&gt; &#xA; &lt;li&gt;Make sure to clone submodules correctly when checking out the repository. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Use &lt;code&gt;git submodule update --init --recursive&lt;/code&gt; if you cloned without using &lt;code&gt;--recursive&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Architecture&lt;/h1&gt; &#xA;&lt;h2&gt;Deferred frames&lt;/h2&gt; &#xA;&lt;p&gt;Draw calls are never sent right away to the GPU but instead stored on an auxiliary structure that logs the history of an entire frame. A frame&#39;s contents can be examined in great detail with the in-game debugger included with RT64. The renderer requires this to be able to optimize the rendering process, perform enhancements, replace assets and even generate new frames entirely.&lt;/p&gt; &#xA;&lt;h2&gt;Deferred RDP&lt;/h2&gt; &#xA;&lt;p&gt;Any operation related to reading memory and using it as texture information during rendering is completely deferred until the game requires a full synchronization of the RDP. All requests are stored in a list of operations and flushed before it is time to render. This allows RT64 to perform extra optimizations and detect when it is necessary to synchronize the output of the RDP back to memory. It also opens up the ability to detect when direct copies can be made on GPU memory and even detect patterns that can be replaced with equivalent but faster operations.&lt;/p&gt; &#xA;&lt;h2&gt;Deferred RSP (Compute)&lt;/h2&gt; &#xA;&lt;p&gt;All vertex transformations by the RSP (e.g. position, lighting, texturing, etc.) are performed by a highly parallel compute shader in the GPU. This saves a lot of CPU processing time and allows for much higher vertex and polygon counts. Since all transformations are deferred to this step, it&#39;s very easy for RT64 to patch transformations of the objects in the scene and the camera and produce a new frame very quickly. This effectively removes CPU bottlenecks that are critical for reaching very high target framerates.&lt;/p&gt; &#xA;&lt;h2&gt;Texture Decoder (Compute)&lt;/h2&gt; &#xA;&lt;p&gt;RT64 does not decode textures on the CPU and instead opts for uploading TMEM (4 KB) directly to the GPU. If possible, a RGBA32 version of the texture will be decoded and cached using a compute shader. If the sampling parameters prove to be too troublesome for that (e.g. giant texture masks with no clamp due to bad configuration), then RT64 can sample TMEM directly just like the console with a small performance sacrifice.&lt;/p&gt; &#xA;&lt;p&gt;RT64 features one of the most accurate TMEM loaders to date so far which has been directly reverse engineered by observing console behavior with the aid of homebrew test ROMs developed by &lt;a href=&#34;https://github.com/Mr-Wiseguy&#34;&gt;Wiseguy&lt;/a&gt;. All the color conversion formulas for decoding have also been sourced from &lt;a href=&#34;https://github.com/Thar0&#34;&gt;Tharo&lt;/a&gt;&#39;s excellent RDP research.&lt;/p&gt; &#xA;&lt;h2&gt;Dual renderers&lt;/h2&gt; &#xA;&lt;p&gt;RT64 takes advantage of the multi-threaded capabilities of modern APIs to run two renderers at the same time with highly different goals. One renderer draws at native resolution (e.g. 240p) and synchronizes back immediately with the game running at its original rate. The other renderer replays all the draw calls detected by the main renderer at higher resolution and even at a different rate when using interpolation. This design guarantees that the game will see the correct data in RAM, which is very important for games that read from these memory regions for gameplay reasons. If it&#39;s not required by the game, this native resolution renderer can be turned off completely to save performance.&lt;/p&gt; &#xA;&lt;h2&gt;Framebuffer detection&lt;/h2&gt; &#xA;&lt;p&gt;RT64 will keep track of any memory addresses used as framebuffers, their dimensions and their matching contents that live in GPU memory. If other operations in the frame load and sample a part of memory owned by a framebuffer, then a direct copy of one of its regions is performed and stored in memory.&lt;/p&gt; &#xA;&lt;p&gt;The framebuffer copy mechanic is only used when the load and sample parameters line up correctly and the final result would look no different than if it was sampled from RAM (except for preserving the high precision of the image). As framebuffer detection works at the RDP level, that means all related performance and visual enhancements can apply even in LLE mode.&lt;/p&gt; &#xA;&lt;h2&gt;Framebuffer upscaling&lt;/h2&gt; &#xA;&lt;p&gt;When framebuffer operations are detected, the renderer is able to upscale these effects by increasing the resolution of all framebuffers and any associated region copies by a scaling factor. The resolution increase is only performed in the high resolution renderer. All texture coordinates are adjusted automatically to account for this change.&lt;/p&gt; &#xA;&lt;h2&gt;Framebuffer reinterpretation&lt;/h2&gt; &#xA;&lt;p&gt;Games will sometimes draw to a framebuffer using one format and then read it as another format to perform post-processing on the screen. RT64 supports this operation natively at high resolution using per-pixel reinterpretation inside a dedicated compute shader. While this requires adding specific paths encountered on a case-by-case basis (to preserve high precision), the framework can be easily extended to support as many cases as possible. This feature is essential for emulating some of the more infamous effects in higher resolutions such as greyscale filters.&lt;/p&gt; &#xA;&lt;h2&gt;Draw call matching&lt;/h2&gt; &#xA;&lt;p&gt;Once all information for a particular game frame has been recorded, RT64 will attempt to perform automatic matching of draw calls between frames based on their rendering parameters, the textures in use, their position, orientation, their tracked velocities and much more. Matching is essential to generating interpolated frames and providing motion vector information to the path traced renderer. Draw call matching is still a highly experimental area that is prone to errors and requires a lot of processing to get right. The algorithms behind this feature will be likely to change as more research is done to accommodate as many games as possible.&lt;/p&gt; &#xA;&lt;h2&gt;Frame interpolation&lt;/h2&gt; &#xA;&lt;p&gt;New frames are generated using the information from the previous draw call matching step. For any calls that match, new 3D transformations will be created via interpolation and uploaded to the GPU for the deferred RSP to do its work again. When possible, transformations are decomposed into their constituent components. Those components are interpolated separately and recomposed into the resultant transform to prevent interpolation artifacts caused by naive transformation interpolation. This interpolation can also be applied to texture scrolling coordinates and even per vertex if vertex velocities are computed. More parameters are planned to be supported in the future as long as they&#39;re part of the recorded frame data.&lt;/p&gt; &#xA;&lt;h2&gt;Extended command set&lt;/h2&gt; &#xA;&lt;p&gt;RT64 offers an extended command set that can be used by native ports, ROM patches, and ROM hacks to provide extra information that the renderer can use to enhance the final result. Using this feature is vital to providing accurate frame interpolation and widescreen enhancements for 2D elements. If you&#39;re interested in using this feature, check out the &lt;a href=&#34;https://github.com/rt64/rt64/raw/main/include/rt64_extended_gbi.h&#34;&gt;included header in the repository&lt;/a&gt;. The main activation method is encoded into a NOOP command so it should be safe to run it in real hardware. RT64 will recognize this command and enable the extended command set feature, allowing for an extended repertoire of functions aimed at fixing some common grievances that show up at high framerates or wide aspect ratios.&lt;/p&gt; &#xA;&lt;p&gt;For example, objects that rely on pixel depth checks to draw can instead use the &lt;code&gt;gEXVertexZTest()&lt;/code&gt; command to specify any triangles drawn after the command should only be drawn if the vertex is not covered by something else. This means that effects such as light halos can be replaced with this command and it&#39;ll automatically work on widescreen ratios and no longer be delayed by one frame. Instead, RT64 will just flush the depth buffer at the correct step and run a small compute shader that will invalidate the draw call&#39;s triangles if the depth test doesn&#39;t pass. Though the original effect already works as-is thanks to the native renderer, the extended GBI method can be leveraged to make the experience feel even better.&lt;/p&gt; &#xA;&lt;h2&gt;Future texture and asset replacement&lt;/h2&gt; &#xA;&lt;p&gt;Texture replacements are easily performed at runtime by using two capabilities that RT64 already supports: bindless textures and texture coordinate scaling. The entire renderer uses only one contiguous array of texture resources and replacing one of these by an HD texture replacement is straightforward. By detecting the difference in sizes between the original texture and the replacement, the texture coordinates can be scaled easily with the same logic that is used for framebuffer tiles.&lt;/p&gt; &#xA;&lt;p&gt;Asset replacement, while not currently implemented and more of a long term feature, will leverage the fact that only one contiguous vertex and index array is used by RT64. This allows for highly efficient rendering as it minimizes the amount of times vertex and index buffers must be bound, but it also means the RSP can process the vertices placed in this buffer during rendering time as if they came from the game itself. Therefore, the entire process of model replacement will just consist of allocating chunks of the buffer directly for replacements in a native format, assigning it the correct transforms used by the draw call and letting the RSP compute shader do its job. This will allow the renderer to draw models that have orders of magnitude higher triangle counts with very little additional cost to the CPU.&lt;/p&gt; &#xA;&lt;h2&gt;Future path tracing&lt;/h2&gt; &#xA;&lt;p&gt;RT64 will attempt to perform scene detection by merging as many draw calls as it can as long as they&#39;re inside of the same compatible perspective view point. Since all data remains untransformed, bottom-level acceleration structures (BLAS) can be built by using a compute shader to transform vertices to world space instead of screen space. Once these BLAS are built, a top-level acceleration structure (TLAS) is constructed with all the BLAS that were detected.&lt;/p&gt; &#xA;&lt;p&gt;These structures are used directly for path tracing the scene and generating all lighting in real time. Lighting information is derived from various sources (the game itself, scripts, integrated light editor) and will be detailed more in the future as this feature is closer to a final state.&lt;/p&gt;</summary>
  </entry>
</feed>