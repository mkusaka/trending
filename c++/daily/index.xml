<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-07T01:28:42Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mamba-org/mamba</title>
    <updated>2023-12-07T01:28:42Z</updated>
    <id>tag:github.com,2023-12-07:/mamba-org/mamba</id>
    <link href="https://github.com/mamba-org/mamba" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Fast Cross-Platform Package Manager&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mamba-org/mamba/main/docs/assets/mamba_header.png&#34; alt=&#34;mamba header image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;The Fast Cross-Platform Package Manager&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead align=&#34;center&#34; cellspacing=&#34;10&#34;&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th colspan=&#34;3&#34; align=&#34;center&#34; border=&#34;&#34;&gt;part of mamba-org&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr background=&#34;#FFF&#34;&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Package Manager &lt;a href=&#34;https://github.com/mamba-org/mamba&#34;&gt;mamba&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Package Server &lt;a href=&#34;https://github.com/mamba-org/quetz&#34;&gt;quetz&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Package Builder &lt;a href=&#34;https://github.com/mamba-org/boa&#34;&gt;boa&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;mamba&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mamba-org/mamba/actions&#34;&gt;&lt;img src=&#34;https://github.com/mamba-org/mamba/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/mamba-org/Lobby?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Join%20Chat.svg?sanitize=true&#34; alt=&#34;Join the Gitter Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://mamba.readthedocs.io/en/latest&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/mamba/badge/?version=latest&amp;amp;style=flat&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;mamba&lt;/code&gt; is a reimplementation of the conda package manager in C++.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;parallel downloading of repository data and package files using multi-threading&lt;/li&gt; &#xA; &lt;li&gt;libsolv for much faster dependency solving, a state of the art library used in the RPM package manager of Red Hat, Fedora and OpenSUSE&lt;/li&gt; &#xA; &lt;li&gt;core parts of &lt;code&gt;mamba&lt;/code&gt; are implemented in C++ for maximum efficiency&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At the same time, &lt;code&gt;mamba&lt;/code&gt; utilizes the same command line parser, package installation and deinstallation code and transaction verification routines as &lt;code&gt;conda&lt;/code&gt; to stay as compatible as possible.&lt;/p&gt; &#xA;&lt;p&gt;Mamba is part of a bigger ecosystem to make scientific packaging more sustainable. You can read our &lt;a href=&#34;https://medium.com/@QuantStack/open-software-packaging-for-science-61cecee7fc23&#34;&gt;announcement blog post&lt;/a&gt;. The ecosystem also consists of &lt;code&gt;quetz&lt;/code&gt;, an open source &lt;code&gt;conda&lt;/code&gt; package server and &lt;code&gt;boa&lt;/code&gt;, a fast &lt;code&gt;conda&lt;/code&gt; package builder.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to the &lt;a href=&#34;https://mamba.readthedocs.io/en/latest/installation/mamba-installation.html&#34;&gt;mamba&lt;/a&gt; and &lt;a href=&#34;https://mamba.readthedocs.io/en/latest/installation/micromamba-installation.html&#34;&gt;micromamba&lt;/a&gt; installation guide in the documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Additional features in Mamba and Micromamba&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;mamba&lt;/code&gt; and &lt;code&gt;micromamba&lt;/code&gt; come with features on top of stock &lt;code&gt;conda&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;repoquery&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To efficiently query repositories and query package dependencies you can use &lt;code&gt;mamba repoquery&lt;/code&gt; or &lt;code&gt;micromamba repoquery&lt;/code&gt;. See the &lt;a href=&#34;https://mamba.readthedocs.io/en/latest/user_guide/mamba.html#repoquery&#34;&gt;repoquery documentation&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h3&gt;Installing lock files&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;micromamba&lt;/code&gt; can be used to install lock files generated by &lt;a href=&#34;https://conda.github.io/conda-lock/&#34;&gt;conda-lock&lt;/a&gt; without having to install &lt;code&gt;conda-lock&lt;/code&gt;. Simply invoke e.g. &lt;code&gt;micromamba create -n my-env -f conda-lock.yml&lt;/code&gt; with an environment lockfile named &lt;code&gt;*-lock.yml&lt;/code&gt; or &lt;code&gt;*-lock.yaml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;setup-micromamba (setup-miniconda replacement)&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/marketplace/actions/setup-micromamba&#34;&gt;setup-micromamba&lt;/a&gt; is a replacement for &lt;a href=&#34;https://github.com/marketplace/actions/setup-miniconda&#34;&gt;setup-miniconda&lt;/a&gt; that uses &lt;code&gt;micromamba&lt;/code&gt;. It can significantly reduce your CI setup time by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using &lt;code&gt;micromamba&lt;/code&gt;, which takes around 1 s to install.&lt;/li&gt; &#xA; &lt;li&gt;Caching package downloads.&lt;/li&gt; &#xA; &lt;li&gt;Caching entire &lt;code&gt;conda&lt;/code&gt; environments.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;micromamba&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;micromamba&lt;/code&gt; is a small, pure-C++ reimplementation of &lt;code&gt;mamba&lt;/code&gt;/&lt;code&gt;conda&lt;/code&gt;. It strives to be a full replacement for &lt;code&gt;mamba&lt;/code&gt; and &lt;code&gt;conda&lt;/code&gt;. As such, it doesn&#39;t use any &lt;code&gt;conda&lt;/code&gt; code (in fact it doesn&#39;t require Python at all).&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://mamba.readthedocs.io/en/latest/user_guide/micromamba.html&#34;&gt;documentation on &lt;code&gt;micromamba&lt;/code&gt;&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;h2&gt;Development installation&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to the instructions given by the &lt;a href=&#34;https://mamba.readthedocs.io/en/latest/developer_zone/dev_environment.html&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Support us&lt;/h2&gt; &#xA;&lt;p&gt;For questions, you can also join us on the &lt;a href=&#34;https://gitter.im/QuantStack/Lobby&#34;&gt;QuantStack Chat&lt;/a&gt; or on the &lt;a href=&#34;https://gitter.im/conda/conda&#34;&gt;Conda channel&lt;/a&gt; (note that this project is not officially affiliated with &lt;code&gt;conda&lt;/code&gt; or Anaconda Inc.).&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;We use a shared copyright model that enables all contributors to maintain the copyright on their contributions.&lt;/p&gt; &#xA;&lt;p&gt;This software is licensed under the BSD-3-Clause license. See the &lt;a href=&#34;https://raw.githubusercontent.com/mamba-org/mamba/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Biweekly Dev Meeting&lt;/h3&gt; &#xA;&lt;p&gt;We have videoconference meetings every two weeks where we discuss what we have been working on and get feedback from one another.&lt;/p&gt; &#xA;&lt;p&gt;Anyone is welcome to attend, if they would like to discuss a topic or just listen in.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When: Tuesday &lt;a href=&#34;https://calendar.google.com/calendar/u/0/embed?src=ab3jrfpede0kq0ubsroe82cd00@group.calendar.google.com&amp;amp;ctz=Europe/Paris&#34;&gt;4:00 PM CET (Europe)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Where: &lt;a href=&#34;https://meet.jit.si/mamba-org&#34;&gt;Mamba jitsi&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;What: &lt;a href=&#34;https://hackmd.io/@guj2k_aBSSyr1YHBG9raWw/HyHt-Ekzj&#34;&gt;Meeting notes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>zeroasiccorp/switchboard</title>
    <updated>2023-12-07T01:28:42Z</updated>
    <id>tag:github.com,2023-12-07:/zeroasiccorp/switchboard</id>
    <link href="https://github.com/zeroasiccorp/switchboard" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Communication framework for RTL simulation and emulation.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Switchboard&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zeroasiccorp/switchboard/actions&#34;&gt;&lt;img src=&#34;https://github.com/zeroasiccorp/switchboard/actions/workflows/regression.yml/badge.svg?branch=main&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://zeroasiccorp.github.io/switchboard/&#34;&gt;&lt;img src=&#34;https://github.com/zeroasiccorp/switchboard/actions/workflows/documentation.yml/badge.svg?branch=main&#34; alt=&#34;Documentation Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://badge.fury.io/py/switchboard-hw&#34;&gt;&lt;img src=&#34;https://badge.fury.io/py/switchboard-hw.svg?sanitize=true&#34; alt=&#34;PyPI version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/Apache-2.0&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache_2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Switchboard (SB) is a framework for communication between distinct hardware models, such as RTL simulations, RTL implemented on FPGAs, and fast SW models. This makes it possible to simulate large hardware systems in a distributed fashion, using whatever models are available for the different components.&lt;/p&gt; &#xA;&lt;p&gt;In such a simulation, each hardware model has one or more SB ports. Each is unidirectional: it may act as an input or an output, but not both. In addition, each SB connection is single-producer, single-consumer (SPSC): an output port may not drive more than one input port, and an input port may not be driven by more than one output port.&lt;/p&gt; &#xA;&lt;p&gt;Here&#39;s an example of what a switchboard connection topology might look like:&lt;/p&gt; &#xA;&lt;img width=&#34;318&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/19254098/225485548-ff127b2e-d959-46c0-af1d-2c4bbe3f119d.png&#34;&gt; &#xA;&lt;p&gt;The method for adding a switchboard port depends on the language that a HW model is implemented in. For RTL-based models, SB ports are instantiated as Verilog models, whereas for C++ and Python-based models, these ports are instantiated as objects. We provide both a low-level interface for moving data directly between SB ports, as well as a higher-level interface for running &lt;a href=&#34;https://github.com/zeroasiccorp/umi&#34;&gt;UMI&lt;/a&gt; transactions over SB connections.&lt;/p&gt; &#xA;&lt;p&gt;Under the hood, communication happens through shared-memory queues, where an SB output port is driving packets into the queue, and an SB input port is reading from that queue. This standardization is what allows any two kinds of models to talk to each other. A shared-memory SPSC queue is an appealing common interface because it is one of the fastest interprocess communication techniques, with latencies on the order of hundreds of nanoseconds; no system calls are required to transmit and receive data. At the same time, this type of queue is straightforward to implement for FPGA platforms, with queue read and write operations only requiring a handful of memory transactions.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The fastest way to install this package is from PyPI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install switchboard-hw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, if you want to run the examples below (or if you&#39;re a switchboard developer), clone this repository and install the Python package in-place:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ git clone https://github.com/zeroasiccorp/switchboard.git&#xA;$ cd switchboard&#xA;$ git submodule update --init&#xA;$ pip install --upgrade pip&#xA;$ pip install -e .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Various examples demonstrating the features of switchboard are in the &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples&#34;&gt;examples&lt;/a&gt; folder. If you&#39;d like to run them yourself, please run this command first:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;./examples/get_deps.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This clones some additional repositories that are needed by the examples.&lt;/p&gt; &#xA;&lt;p&gt;A good starting point is the &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/python&#34;&gt;python&lt;/a&gt; example, where a Python script sends packets to and receives packets from a Verilator RTL simulation. The configuration is simple: there is a small RTL simulation that accepts an SB packet, increments the data payload, and transmits the result on its SB output port. On the other side, a Python script sends an SB packet to the simulation, and checks that the packet it gets back has been incremented.&lt;/p&gt; &#xA;&lt;img width=&#34;311&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/19254098/225485672-1793521d-a9db-4c18-ad61-c22a605f8720.png&#34;&gt; &#xA;&lt;p&gt;To run this example, you&#39;ll need &lt;code&gt;verilator&lt;/code&gt; (&lt;code&gt;sudo apt install verilator&lt;/code&gt; for Ubuntu, &lt;code&gt;brew install verilator&lt;/code&gt; for macOS). You can then run the example by changing directory to &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/python&#34;&gt;examples/python&lt;/a&gt; and then typing &lt;code&gt;make&lt;/code&gt;. That should produce output similar to the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;*** TX packet ***&#xA;dest: 123456789&#xA;last: 1&#xA;data: [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23&#xA; 24 25 26 27 28 29 30 31]&#xA;&#xA;*** RX packet ***&#xA;dest: 123456789&#xA;last: 1&#xA;data: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24&#xA; 25 26 27 28 29 30 31 32]&#xA;&#xA;- ../verilog/testbench.sv:72: Verilog $finish&#xA;PASS!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get a sense of how this works, open the Python script &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/python/test.py&#34;&gt;examples/python/test.py&lt;/a&gt;. The core logic is essentially:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from switchboard import PySbPacket, PySbTx, PySbRx&#xA;...&#xA;tx = PySbTx(&#34;to_rtl.q&#34;)&#xA;rx = PySbRx(&#34;from_rtl.q&#34;)&#xA;...&#xA;txp = PySbPacket(...)&#xA;tx.send(txp)&#xA;...&#xA;rxp = rx.recv()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, we create an SB output port (&lt;code&gt;tx&lt;/code&gt;) and an SB input port (&lt;code&gt;rx&lt;/code&gt;). An SB packet is then created (&lt;code&gt;txp&lt;/code&gt;) and sent via the output port. Finally, a new SB packet is received from the input port.&lt;/p&gt; &#xA;&lt;p&gt;To get a sense of how switchboard is used in RTL, have a look at the Verilog part of this example in &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/python/testbench.sv&#34;&gt;examples/python/testbench.sv&lt;/a&gt;. The core logic is the instantiation of &lt;code&gt;queue_to_sb_sim&lt;/code&gt; (SB input port) and &lt;code&gt;sb_to_queue_sim&lt;/code&gt; (SB output port), along with the initialization step to define the name of each SB connection. Notice that the Python output port is matched to the Verilog input port (&lt;code&gt;to_rtl.q&lt;/code&gt;) and similarly the Python input port is matched to the Verilog output port (&lt;code&gt;from_rtl.q&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-verilog&#34;&gt;// ...&#xA;&#xA;queue_to_sb_sim rx_i (&#xA;    .clk(clk),&#xA;    .data(sb_rx_data),&#xA;    .dest(sb_rx_dest),&#xA;    .last(sb_rx_last),&#xA;    .ready(sb_rx_ready),&#xA;    .valid(sb_rx_valid)&#xA;);&#xA;&#xA;sb_to_queue_sim tx_i (&#xA;    .clk(clk),&#xA;    .data(sb_tx_data),&#xA;    .dest(sb_tx_dest),&#xA;    .last(sb_tx_last),&#xA;    .ready(sb_tx_ready),&#xA;    .valid(sb_tx_valid)&#xA;);&#xA;&#xA;// ...&#xA;&#xA;initial begin&#xA;    rx_i.init(&#34;to_rtl.q&#34;);&#xA;    tx_i.init(&#34;from_rtl.q&#34;);&#xA;end&#xA;&#xA;// ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Using the same name for two ports is what establishes a connection between them. You can use any name that you like for a SB connection, as long as it is a valid file name. The reason is that SB connections are visible as files on your file system. After this example runs, it will leave behind files called &lt;code&gt;to_rtl.q&lt;/code&gt; and &lt;code&gt;from_rtl.q&lt;/code&gt;. It&#39;s convenient to name SB connections in a way that is amenable to pattern matching, so that you can do things like &lt;code&gt;rm *.q&lt;/code&gt; to clean up old connections.&lt;/p&gt; &#xA;&lt;p&gt;We encourage you to explore the other examples, which demonstrate simulation with Icarus Verilog and switchboard&#39;s C++ library (&lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/minimal&#34;&gt;minimal&lt;/a&gt;), bridging SB connections via TCP (&lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/tcp&#34;&gt;tcp&lt;/a&gt;), and switchboard&#39;s UMI abstraction (&lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/umiram&#34;&gt;umiram&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;Build automation&lt;/h2&gt; &#xA;&lt;p&gt;We also provide build automation powered by &lt;a href=&#34;https://github.com/siliconcompiler/siliconcompiler&#34;&gt;SiliconCompiler&lt;/a&gt; that makes it easy to build RTL simulations with switchboard infrastructure (&lt;code&gt;queue_to_sb_sim&lt;/code&gt;, &lt;code&gt;sb_to_queue_sim&lt;/code&gt;, etc.). This is mainly important because Verilog DPI and VPI are used under the hood, requiring certain flags to be passed to the RTL simulator during the build. Using our build automation lets you focus on specifying RTL sources, without having to deal with these details.&lt;/p&gt; &#xA;&lt;p&gt;As an example, we return to &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/python&#34;&gt;examples/python&lt;/a&gt;. The basic logic for a Verilator build is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from switchboard import SbDut&#xA;&#xA;dut = SbDut(&#39;name-of-top-level-module&#39;, default_main=True)&#xA;&#xA;dut.input(&#39;path/to/file/1&#39;)&#xA;dut.input(&#39;path/to/file/2&#39;)&#xA;...&#xA;&#xA;dut.build()&#xA;&#xA;dut.simulate()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, create an &lt;code&gt;SbDut&lt;/code&gt; object, &lt;code&gt;input()&lt;/code&gt; files, &lt;code&gt;build()&lt;/code&gt; it to compile the Verilator simulator, and use &lt;code&gt;simulate()&lt;/code&gt; to start the simulator. &lt;code&gt;SbDut&lt;/code&gt; is a subclass of &lt;code&gt;siliconcompiler.Chip&lt;/code&gt;, which allows you to invoke a range of features to control the simulator build, such as specifying include paths and &lt;code&gt;`define&lt;/code&gt; macros. More information about &lt;code&gt;siliconcompiler.Chip&lt;/code&gt; can be found &lt;a href=&#34;https://docs.siliconcompiler.com/en/stable/reference_manual/core_api.html#siliconcompiler.core.Chip&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Packet format&lt;/h2&gt; &#xA;&lt;p&gt;An SB packet is a simple data structure with three parts, defined in &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/switchboard/cpp/switchboard.hpp&#34;&gt;switchboard/cpp/switchboard.hpp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A 32-bit &lt;code&gt;destination&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A 32-bit &lt;code&gt;flags&lt;/code&gt; bit vector. Currently only bit &#34;0&#34; is used, providing the &lt;code&gt;last&lt;/code&gt; flag.&lt;/li&gt; &#xA; &lt;li&gt;A 416-bit data payload. This width was chosen to accommodate a UMI packet with a 256 bit payload, 64-bit source and destination addresses, and a 32-bit command. In the future, we may support parameterizable data widths for switchboard connections.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;code&gt;destination&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; control how the packet is routed. &lt;code&gt;destination&lt;/code&gt; indicates the intended recipient of the packet as a flat, unsigned 32-bit integer. This provides a mechanism where a packet can be routed through multiple hops before reaching its final destination.&lt;/p&gt; &#xA;&lt;p&gt;For example, consider using switchboard to build a simple topology in which packets can be sent from one HW block to one of two other blocks. One could indicate which block should receive the packet using the &lt;code&gt;destination&lt;/code&gt; field, with a router transmitting the packet to the right one.&lt;/p&gt; &#xA;&lt;img width=&#34;291&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/19254098/225485726-60ce5539-f282-4ceb-8e33-6cb2b7220ffd.png&#34;&gt; &#xA;&lt;p&gt;The &lt;code&gt;last&lt;/code&gt; indicator (part of the &lt;code&gt;flags&lt;/code&gt; bit vector) indicates whether there is more to come as part of a transaction. The rule is that a transmission cannot be interrupted as long as as &lt;code&gt;last&lt;/code&gt; is zero. As an example, consider the system below, where Block A and Block B are both sending SB packets to the same port on Block C, using a router to multiplex between the two. Following the rule of unbroken transmissions, if the router starts sending a sequence of packets from Block A to Block C, it cannot switch to sending packets from Block B to Block C until it gets a packet from Block A that has &lt;code&gt;last&lt;/code&gt; set to one. It is legal to have &lt;code&gt;last=1&lt;/code&gt; set in all packets, meaning that packets can be interspersed at any time.&lt;/p&gt; &#xA;&lt;img width=&#34;253&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/19254098/225485752-59cd02f3-6877-4cbd-960c-823276d8a815.png&#34;&gt; &#xA;&lt;p&gt;The purpose of &lt;code&gt;last&lt;/code&gt; is two-fold. For one, it simplifies the process of transmitting &#34;burstable&#34; protocols such as UMI through switchboard. It also provides opportunities for performance optimization. For example, if a long sequence of SB packets is being sent over TCP, the TCP bridge knows it can wait to fill up its transmission buffer as long as &lt;code&gt;last=0&lt;/code&gt;. Without the &lt;code&gt;last&lt;/code&gt; bit, the bridge would have to send each packet one at a time (or speculatively wait for more packets), since any given packet may be the last one.&lt;/p&gt; &#xA;&lt;h2&gt;UMI interface&lt;/h2&gt; &#xA;&lt;p&gt;In addition to supporting data movement directly through SB packets, we provide a higher-level interface for running &lt;a href=&#34;https://github.com/zeroasiccorp/umi&#34;&gt;UMI&lt;/a&gt; transactions over switchboard connections. The mechanisms for this can be seen in the &lt;code&gt;examples/umi*&lt;/code&gt; examples. Here&#39;s a sketch of what UMI transactions look like, adapted from the definition of &lt;code&gt;python_intf()&lt;/code&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/umiram/test.py&#34;&gt;examples/umiram/test.py&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from switchboard import UmiTxRx&#xA;&#xA;umi = UmiTxRx(from_client, to_client, fresh=True)&#xA;&#xA;wrbuf = np.array([elem1, elem2, ...], dtype)&#xA;umi.write(wraddr, wrbuf)&#xA;&#xA;rdbuf = umi.read(rdaddr, num, dtype)  # also a numpy array&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We are no longer creating &lt;code&gt;PySbTx&lt;/code&gt; and &lt;code&gt;PySbRx&lt;/code&gt; objects, but rather a single &lt;code&gt;UmiTxRx&lt;/code&gt; object with two SB ports: &lt;code&gt;from_client&lt;/code&gt;, and &lt;code&gt;to_client&lt;/code&gt;. Transactions are sent by the Python script through the &lt;code&gt;from_client&lt;/code&gt; port, and responses are received back through the &lt;code&gt;to_client&lt;/code&gt; port.&lt;/p&gt; &#xA;&lt;p&gt;UMI write transactions are generated with the &lt;code&gt;umi.write()&lt;/code&gt; method, which accepts an address and numpy array or scalar as arguments. This sends out one or more &lt;a href=&#34;https://github.com/zeroasiccorp/umi#4-signal-umi-layer-sumi&#34;&gt;SUMI&lt;/a&gt; packets to implement the write request, packing the data, source address, destination address, and command into SB packets. Since an SB packet is 416 bits, and the two addresses + command take up 160 bits, each SB packet contains up to 256b data. Switchboard automatically splits up larger transactions into multiple SUMI packets as needed, incrementing the source and destination addresses automatically. Optional arguments to &lt;code&gt;write()&lt;/code&gt; control where a ack&#39;d or non-ack&#39;d (posted) write is used and the maximum amount of data to send in a single SUMI packet. If an ack&#39;d write is used, &lt;code&gt;write()&lt;/code&gt; blocks until the response is received.&lt;/p&gt; &#xA;&lt;p&gt;In a similar fashion, &lt;code&gt;umi.read()&lt;/code&gt; reads a certain number of words from a given address. For example, &lt;code&gt;umi.read(0x1234, 4, np.uint16)&lt;/code&gt; will send out a UMI read request with &lt;code&gt;dstaddr=0x1234&lt;/code&gt;, &lt;code&gt;LEN=3&lt;/code&gt;, &lt;code&gt;SIZE=1&lt;/code&gt; from the SB port &lt;code&gt;from_client&lt;/code&gt;. When it gets the response to that query on &lt;code&gt;to_client&lt;/code&gt;, it will return an array of 4 &lt;code&gt;np.uint16&lt;/code&gt; words to the Python script. A &lt;code&gt;umi.atomic()&lt;/code&gt; method is also provided to generate UMI atomic transactions.&lt;/p&gt; &#xA;&lt;p&gt;Sometimes it is convenient to work directly with SUMI packets, for example when testing a UMI FIFO or UMI router. For that situation, we provide &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; methods for &lt;code&gt;UmiTxRx&lt;/code&gt;, highlighted in &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/examples/umi_fifo/test.py&#34;&gt;examples/umi_fifo/test.py&lt;/a&gt;. In that exampe, we are sending SUMI packets into a UMI FIFO, and want to make sure that the sequence of packets read out of the FIFO is the same as the sequence of packets written in.&lt;/p&gt; &#xA;&lt;p&gt;The main &lt;code&gt;while&lt;/code&gt; loop is essentially:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;txq = []&#xA;&#xA;while ...:&#xA;    txp = random_umi_packet()&#xA;    if umi.send(txp, blocking=False):&#xA;        txq.append(txp)&#xA;&#xA;    rxp = umi.recv(blocking=False)&#xA;    if rxp is not None:&#xA;        assert rxp == txq[0]&#xA;        txq.pop(0)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In other words, first try to write a random packet into the FIFO. If successful, add it to the back of a list of outstanding packets. Then, try to read a packet from the FIFO. If successful, make sure that the packet is equal to the oldest outstanding packet (since this is a first-in, first-out queue) and remove that outstanding packet from our records. Continue in a loop until a sufficient number of transactions have been checked.&lt;/p&gt; &#xA;&lt;p&gt;This code example demonstrates several features:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; for working with SUMI packets, represented using &lt;code&gt;PyUmiPacket&lt;/code&gt; objects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;blocking=False&lt;/code&gt; for non-blocking transactions. &lt;code&gt;send()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; if successful and &lt;code&gt;False&lt;/code&gt; otherwise; &lt;code&gt;recv()&lt;/code&gt; returns a &lt;code&gt;PyUmiPacket&lt;/code&gt; if successful, and &lt;code&gt;None&lt;/code&gt; otherwise. A transaction might be unsuccessful if the underlying UMI FIFO is full or empty. For example, if we don&#39;t call &lt;code&gt;umi.recv()&lt;/code&gt;, eventually the FIFO will fill, and subsequent &lt;code&gt;send()&lt;/code&gt; invocations will fail (returning &lt;code&gt;False&lt;/code&gt;). Similarly, if we keep calling &lt;code&gt;umi.recv()&lt;/code&gt; without calling &lt;code&gt;umi.send()&lt;/code&gt;, eventually the FIFO will be empty, and &lt;code&gt;umi.recv()&lt;/code&gt; will fail (returning &lt;code&gt;None&lt;/code&gt;).&lt;/li&gt; &#xA; &lt;li&gt;The ability to generate random SUMI packets with &lt;code&gt;random_umi_packet()&lt;/code&gt;. Various optional arguments can constrain the opcodes, addresses, and data.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PyUmiPacket&lt;/code&gt; objects can be compared using Python &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators. This checks if two packets have equal commands, addresses, and data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Queue format&lt;/h2&gt; &#xA;&lt;p&gt;Under the hood, SB ports are implemented using shared memory queues. The data structure used is made simple enough that RTL running on FPGAs can directly read and write to these queues, without the need for bridge programs. In fact, if two FPGAs have access to the same memory space, they can communicate through a shared memory queue without any involvement from the host operating system, after the initial setup.&lt;/p&gt; &#xA;&lt;p&gt;The layout of the queue is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Bytes 0-3: head (int32)&lt;/li&gt; &#xA; &lt;li&gt;Bytes 64-67: tail (int32)&lt;/li&gt; &#xA; &lt;li&gt;Bytes 128-179: SB packet&lt;/li&gt; &#xA; &lt;li&gt;Bytes 256-307: SB packet&lt;/li&gt; &#xA; &lt;li&gt;Bytes 320-371: SB packet&lt;/li&gt; &#xA; &lt;li&gt;...&lt;/li&gt; &#xA; &lt;li&gt;Bytes 4,032-4,095: SB packet&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To write an SB packet to the queue, compute &lt;code&gt;next_head = head + 1&lt;/code&gt;. If &lt;code&gt;next_head&lt;/code&gt; equals &lt;code&gt;62&lt;/code&gt; (the end of the queue), then set &lt;code&gt;next_head&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;next_head&lt;/code&gt; equals &lt;code&gt;tail&lt;/code&gt;, then the write fails - the queue is full. Otherwise, write the SB packet to address &lt;code&gt;128 + (64 * head)&lt;/code&gt;, and then set &lt;code&gt;head&lt;/code&gt; to &lt;code&gt;next_head&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Reading an SB packet works in a similar fashion. If &lt;code&gt;tail&lt;/code&gt; equals &lt;code&gt;head&lt;/code&gt;, the read fails - the queue is empty. Otherwise, read the SB packet from address &lt;code&gt;128 + (64 * tail)&lt;/code&gt;, and then increment &lt;code&gt;tail&lt;/code&gt;. If &lt;code&gt;tail&lt;/code&gt; equals &lt;code&gt;62&lt;/code&gt; (the end of the queue), then set &lt;code&gt;tail&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The queue implementation in C is in &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/switchboard/cpp/spsc_queue.h&#34;&gt;switchboard/cpp/spsc_queue.h&lt;/a&gt;, with care taken to avoid memory ordering hazards, and various cache-oriented optimizations. The queue implementation in Verilog (intended for FPGA-based emulation) can be found in &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/switchboard/verilog/fpga/sb_rx_fpga.sv&#34;&gt;switchboard/verilog/fpga/sb_rx_fpga.sv&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/switchboard/verilog/fpga/sb_tx_fpga.sv&#34;&gt;switchboard/verilog/fpga/sb_tx_fpga.sv&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/LICENSE&#34;&gt;Apache 2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;switchboard is an open-source project and welcomes contributions. To find out how to contribute to the project, see our &lt;a href=&#34;https://raw.githubusercontent.com/zeroasiccorp/switchboard/main/CONTRIBUTING.md&#34;&gt;Contributing Guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Issues / Bugs&lt;/h2&gt; &#xA;&lt;p&gt;We use &lt;a href=&#34;https://github.com/zeroasiccorp/switchboard/issues&#34;&gt;GitHub Issues&lt;/a&gt; for tracking requests and bugs.&lt;/p&gt;</summary>
  </entry>
</feed>