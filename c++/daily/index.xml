<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-11-01T01:29:37Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mortennobel/cpp-cheatsheet</title>
    <updated>2024-11-01T01:29:37Z</updated>
    <id>tag:github.com,2024-11-01:/mortennobel/cpp-cheatsheet</id>
    <link href="https://github.com/mortennobel/cpp-cheatsheet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Modern C++ Cheatsheet&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/mortennobel/cpp-cheatsheet&#34;&gt;&lt;img align=&#34;right&#34; src=&#34;https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67&#34; alt=&#34;Fork me on GitHub&#34; data-canonical-src=&#34;https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;C++ QUICK REFERENCE / C++ CHEATSHEET&lt;/h1&gt; &#xA;&lt;p&gt;Based on &lt;a href=&#34;http://www.pa.msu.edu/~duxbury/courses/phy480/Cpp_refcard.pdf&#34;&gt;Phillip M. Duxbury&#39;s C++ Cheatsheet&lt;/a&gt; and edited by Morten Nobel-JÃ¸rgensen. The cheatsheet focus is both on the language as well as common classes from the standard library. C++11 additions is inspired by &lt;a href=&#34;https://isocpp.org/blog/2012/12/c11-a-cheat-sheet-alex-sinyakov&#34;&gt;ISOCPP.org C++11 Cheatsheet&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;The goal is to give a concise overview of basic, modern C++ (C++14).&lt;/p&gt; &#xA;&lt;p&gt;The document is hosted on &lt;a href=&#34;https://github.com/mortennobel/cpp-cheatsheet&#34;&gt;https://github.com/mortennobel/cpp-cheatsheet&lt;/a&gt;. Any comments and feedback are appreciated.&lt;/p&gt; &#xA;&lt;h2&gt;Preprocessor&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;                            // Comment to end of line&#xA;                            /* Multi-line comment */&#xA;#include  &amp;lt;stdio.h&amp;gt;         // Insert standard header file&#xA;#include &#34;myfile.h&#34;         // Insert file in current directory&#xA;#define X some text         // Replace X with some text&#xA;#define F(a,b) a+b          // Replace F(1,2) with 1+2&#xA;#define X \&#xA; some text                  // Multiline definition&#xA;#undef X                    // Remove definition&#xA;#if defined(X)              // Conditional compilation (#ifdef X)&#xA;#else                       // Optional (#ifndef X or #if !defined(X))&#xA;#endif                      // Required after #if, #ifdef&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Literals&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;255, 0377, 0xff             // Integers (decimal, octal, hex)&#xA;2147483647L, 0x7fffffffl    // Long (32-bit) integers&#xA;123.0, 1.23e2               // double (real) numbers&#xA;&#39;a&#39;, &#39;\141&#39;, &#39;\x61&#39;         // Character (literal, octal, hex)&#xA;&#39;\n&#39;, &#39;\\&#39;, &#39;\&#39;&#39;, &#39;\&#34;&#39;      // Newline, backslash, single quote, double quote&#xA;&#34;string\n&#34;                  // Array of characters ending with newline and \0&#xA;&#34;hello&#34; &#34;world&#34;             // Concatenated strings&#xA;true, false                 // bool constants 1 and 0&#xA;nullptr                     // Pointer type with the address of 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Declarations&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x;                      // Declare x to be an integer (value undefined)&#xA;int x=255;                  // Declare and initialize x to 255&#xA;short s; long l;            // Usually 16 or 32 bit integer (int may be either)&#xA;char c=&#39;a&#39;;                 // Usually 8 bit character&#xA;unsigned char u=255;&#xA;signed char s=-1;           // char might be either&#xA;unsigned long x =&#xA;  0xffffffffL;              // short, int, long are signed&#xA;float f; double d;          // Single or double precision real (never unsigned)&#xA;bool b=true;                // true or false, may also use int (1 or 0)&#xA;int a, b, c;                // Multiple declarations&#xA;int a[10];                  // Array of 10 ints (a[0] through a[9])&#xA;int a[]={0,1,2};            // Initialized array (or a[3]={0,1,2}; )&#xA;int a[2][2]={{1,2},{4,5}};  // Array of array of ints&#xA;char s[]=&#34;hello&#34;;           // String (6 elements including &#39;\0&#39;)&#xA;std::string s = &#34;Hello&#34;     // Creates string object with value &#34;Hello&#34;&#xA;std::string s = R&#34;(Hello&#xA;World)&#34;;                    // Creates string object with value &#34;Hello\nWorld&#34;&#xA;int* p;                     // p is a pointer to (address of) int&#xA;char* s=&#34;hello&#34;;            // s points to unnamed array containing &#34;hello&#34;&#xA;void* p=nullptr;            // Address of untyped memory (nullptr is 0)&#xA;int&amp;amp; r=x;                   // r is a reference to (alias of) int x&#xA;enum weekend {SAT,SUN};     // weekend is a type with values SAT and SUN&#xA;enum weekend day;           // day is a variable of type weekend&#xA;enum weekend{SAT=0,SUN=1};  // Explicit representation as int&#xA;enum {SAT,SUN} day;         // Anonymous enum&#xA;enum class Color {Red,Blue};// Color is a strict type with values Red and Blue&#xA;Color x = Color::Red;       // Assign Color x to red&#xA;typedef String char*;       // String s; means char* s;&#xA;const int c=3;              // Constants must be initialized, cannot assign to&#xA;const int* p=a;             // Contents of p (elements of a) are constant&#xA;int* const p=a;             // p (but not contents) are constant&#xA;const int* const p=a;       // Both p and its contents are constant&#xA;const int&amp;amp; cr=x;            // cr cannot be assigned to change x&#xA;int8_t,uint8_t,int16_t,&#xA;uint16_t,int32_t,uint32_t,&#xA;int64_t,uint64_t            // Fixed length standard types&#xA;auto it = m.begin();        // Declares it to the result of m.begin()&#xA;auto const param = config[&#34;param&#34;];&#xA;                            // Declares it to the const result&#xA;auto&amp;amp; s = singleton::instance();&#xA;                            // Declares it to a reference of the result&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;STORAGE Classes&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x;                      // Auto (memory exists only while in scope)&#xA;static int x;               // Global lifetime even if local scope&#xA;extern int x;               // Information only, declared elsewhere&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Statements&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;x=y;                        // Every expression is a statement&#xA;int x;                      // Declarations are statements&#xA;;                           // Empty statement&#xA;{                           // A block is a single statement&#xA;    int x;                  // Scope of x is from declaration to end of block&#xA;}&#xA;if (x) a;                   // If x is true (not 0), evaluate a&#xA;else if (y) b;              // If not x and y (optional, may be repeated)&#xA;else c;                     // If not x and not y (optional)&#xA;&#xA;while (x) a;                // Repeat 0 or more times while x is true&#xA;&#xA;for (x; y; z) a;            // Equivalent to: x; while(y) {a; z;}&#xA;&#xA;for (x : y) a;              // Range-based for loop e.g.&#xA;                            // for (auto&amp;amp; x in someList) x.y();&#xA;&#xA;do a; while (x);            // Equivalent to: a; while(x) a;&#xA;&#xA;switch (x) {                // x must be int&#xA;    case X1: a;             // If x == X1 (must be a const), jump here&#xA;    case X2: b;             // Else if x == X2, jump here&#xA;    default: c;             // Else jump here (optional)&#xA;}&#xA;break;                      // Jump out of while, do, or for loop, or switch&#xA;continue;                   // Jump to bottom of while, do, or for loop&#xA;return x;                   // Return x from function to caller&#xA;try { a; }&#xA;catch (T t) { b; }          // If a throws a T, then jump here&#xA;catch (...) { c; }          // If a throws something else, jump here&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Functions&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f(int x, int y);        // f is a function taking 2 ints and returning int&#xA;void f();                   // f is a procedure taking no arguments&#xA;void f(int a=0);            // f() is equivalent to f(0)&#xA;f();                        // Default return type is int&#xA;inline f();                 // Optimize for speed&#xA;f() { statements; }         // Function definition (must be global)&#xA;T operator+(T x, T y);      // a+b (if type T) calls operator+(a, b)&#xA;T operator-(T x);           // -a calls function operator-(a)&#xA;T operator++(int);          // postfix ++ or -- (parameter ignored)&#xA;extern &#34;C&#34; {void f();}      // f() was compiled in C&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Function parameters and return values may be of any type. A function must either be declared or defined before it is used. It may be declared first and defined later. Every program consists of a set of a set of global variable declarations and a set of function definitions (possibly in separate files), one of which must be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main()  { statements... }     // or&#xA;int main(int argc, char* argv[]) { statements... }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;argv&lt;/code&gt; is an array of &lt;code&gt;argc&lt;/code&gt; strings from the command line. By convention, &lt;code&gt;main&lt;/code&gt; returns status &lt;code&gt;0&lt;/code&gt; if successful, &lt;code&gt;1&lt;/code&gt; or higher for errors.&lt;/p&gt; &#xA;&lt;p&gt;Functions with different parameters may have the same name (overloading). Operators except &lt;code&gt;::&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; &lt;code&gt;?:&lt;/code&gt; may be overloaded. Precedence order is not affected. New operators may not be created.&lt;/p&gt; &#xA;&lt;h2&gt;Expressions&lt;/h2&gt; &#xA;&lt;p&gt;Operators are grouped by precedence, highest first. Unary operators and assignment evaluate right to left. All others are left to right. Precedence does not affect order of evaluation, which is undefined. There are no run time checks for arrays out of bounds, invalid pointers, etc.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;T::X                        // Name X defined in class T&#xA;N::X                        // Name X defined in namespace N&#xA;::X                         // Global name X&#xA;&#xA;t.x                         // Member x of struct or class t&#xA;p-&amp;gt; x                       // Member x of struct or class pointed to by p&#xA;a[i]                        // i&#39;th element of array a&#xA;f(x,y)                      // Call to function f with arguments x and y&#xA;T(x,y)                      // Object of class T initialized with x and y&#xA;x++                         // Add 1 to x, evaluates to original x (postfix)&#xA;x--                         // Subtract 1 from x, evaluates to original x&#xA;typeid(x)                   // Type of x&#xA;typeid(T)                   // Equals typeid(x) if x is a T&#xA;dynamic_cast&amp;lt; T&amp;gt;(x)         // Converts x to a T, checked at run time.&#xA;static_cast&amp;lt; T&amp;gt;(x)          // Converts x to a T, not checked&#xA;reinterpret_cast&amp;lt; T&amp;gt;(x)     // Interpret bits of x as a T&#xA;const_cast&amp;lt; T&amp;gt;(x)           // Converts x to same type T but not const&#xA;&#xA;sizeof x                    // Number of bytes used to represent object x&#xA;sizeof(T)                   // Number of bytes to represent type T&#xA;++x                         // Add 1 to x, evaluates to new value (prefix)&#xA;--x                         // Subtract 1 from x, evaluates to new value&#xA;~x                          // Bitwise complement of x&#xA;!x                          // true if x is 0, else false (1 or 0 in C)&#xA;-x                          // Unary minus&#xA;+x                          // Unary plus (default)&#xA;&amp;amp;x                          // Address of x&#xA;*p                          // Contents of address p (*&amp;amp;x equals x)&#xA;new T                       // Address of newly allocated T object&#xA;new T(x, y)                 // Address of a T initialized with x, y&#xA;new T[x]                    // Address of allocated n-element array of T&#xA;delete p                    // Destroy and free object at address p&#xA;delete[] p                  // Destroy and free array of objects at p&#xA;(T) x                       // Convert x to T (obsolete, use .._cast&amp;lt;T&amp;gt;(x))&#xA;&#xA;x * y                       // Multiply&#xA;x / y                       // Divide (integers round toward 0)&#xA;x % y                       // Modulo (result has sign of x)&#xA;&#xA;x + y                       // Add, or \&amp;amp;x[y]&#xA;x - y                       // Subtract, or number of elements from *x to *y&#xA;x &amp;lt;&amp;lt; y                      // x shifted y bits to left (x * pow(2, y))&#xA;x &amp;gt;&amp;gt; y                      // x shifted y bits to right (x / pow(2, y))&#xA;&#xA;x &amp;lt; y                       // Less than&#xA;x &amp;lt;= y                      // Less than or equal to&#xA;x &amp;gt; y                       // Greater than&#xA;x &amp;gt;= y                      // Greater than or equal to&#xA;&#xA;x &amp;amp; y                       // Bitwise and (3 &amp;amp; 6 is 2)&#xA;x ^ y                       // Bitwise exclusive or (3 ^ 6 is 5)&#xA;x | y                       // Bitwise or (3 | 6 is 7)&#xA;x &amp;amp;&amp;amp; y                      // x and then y (evaluates y only if x (not 0))&#xA;x || y                      // x or else y (evaluates y only if x is false (0))&#xA;x = y                       // Assign y to x, returns new value of x&#xA;x += y                      // x = x + y, also -= *= /= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;= &amp;amp;= |= ^=&#xA;x ? y : z                   // y if x is true (nonzero), else z&#xA;throw x                     // Throw exception, aborts if not caught&#xA;x , y                       // evaluates x and y, returns y (seldom used)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Classes&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class T {                   // A new type&#xA;private:                    // Section accessible only to T&#39;s member functions&#xA;protected:                  // Also accessible to classes derived from T&#xA;public:                     // Accessible to all&#xA;    int x;                  // Member data&#xA;    void f();               // Member function&#xA;    void g() {return;}      // Inline member function&#xA;    void h() const;         // Does not modify any data members&#xA;    int operator+(int y);   // t+y means t.operator+(y)&#xA;    int operator-();        // -t means t.operator-()&#xA;    T(): x(1) {}            // Constructor with initialization list&#xA;    T(const T&amp;amp; t): x(t.x) {}// Copy constructor&#xA;    T&amp;amp; operator=(const T&amp;amp; t)&#xA;    {x=t.x; return *this; } // Assignment operator&#xA;    ~T();                   // Destructor (automatic cleanup routine)&#xA;    explicit T(int a);      // Allow t=T(3) but not t=3&#xA;    T(float x): T((int)x) {}// Delegate constructor to T(int)&#xA;    operator int() const&#xA;    {return x;}             // Allows int(t)&#xA;    friend void i();        // Global function i() has private access&#xA;    friend class U;         // Members of class U have private access&#xA;    static int y;           // Data shared by all T objects&#xA;    static void l();        // Shared code.  May access y but not x&#xA;    class Z {};             // Nested class T::Z&#xA;    typedef int V;          // T::V means int&#xA;};&#xA;void T::f() {               // Code for member function f of class T&#xA;    this-&amp;gt;x = x;}           // this is address of self (means x=x;)&#xA;int T::y = 2;               // Initialization of static member (required)&#xA;T::l();                     // Call to static member&#xA;T t;                        // Create object t implicit call constructor&#xA;t.f();                      // Call method f on object t&#xA;&#xA;struct T {                  // Equivalent to: class T { public:&#xA;  virtual void i();         // May be overridden at run time by derived class&#xA;  virtual void g()=0; };    // Must be overridden (pure virtual)&#xA;class U: public T {         // Derived class U inherits all members of base T&#xA;  public:&#xA;  void g(int) override; };  // Override method g&#xA;class V: private T {};      // Inherited members of T become private&#xA;class W: public T, public U {};&#xA;                            // Multiple inheritance&#xA;class X: public virtual T {};&#xA;                            // Classes derived from X have base T directly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All classes have a default copy constructor, assignment operator, and destructor, which perform the corresponding operations on each data member and each base class as shown above. There is also a default no-argument constructor (required to create arrays) if the class has no constructors. Constructors, assignment, and destructors do not inherit.&lt;/p&gt; &#xA;&lt;h2&gt;Templates&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class T&amp;gt; T f(T t);// Overload f for all types&#xA;template &amp;lt;class T&amp;gt; class X {// Class with type parameter T&#xA;  X(T t); };                // A constructor&#xA;template &amp;lt;class T&amp;gt; X&amp;lt;T&amp;gt;::X(T t) {}&#xA;                            // Definition of constructor&#xA;X&amp;lt;int&amp;gt; x(3);                // An object of type &#34;X of int&#34;&#xA;template &amp;lt;class T, class U=T, int n=0&amp;gt;&#xA;                            // Template with default parameters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Namespaces&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace N {class T {};}   // Hide name T&#xA;N::T t;                     // Use name T in namespace N&#xA;using namespace N;          // Make T visible without N::&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;memory&lt;/code&gt; (dynamic memory management)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;memory&amp;gt;           // Include memory (std namespace)&#xA;shared_ptr&amp;lt;int&amp;gt; x;          // Empty shared_ptr to a integer on heap. Uses reference counting for cleaning up objects.&#xA;x = make_shared&amp;lt;int&amp;gt;(12);   // Allocate value 12 on heap&#xA;shared_ptr&amp;lt;int&amp;gt; y = x;      // Copy shared_ptr, implicit changes reference count to 2.&#xA;cout &amp;lt;&amp;lt; *y;                 // Dereference y to print &#39;12&#39;&#xA;if (y.get() == x.get()) {   // Raw pointers (here x == y)&#xA;    cout &amp;lt;&amp;lt; &#34;Same&#34;;  &#xA;}  &#xA;y.reset();                  // Eliminate one owner of object&#xA;if (y.get() != x.get()) { &#xA;    cout &amp;lt;&amp;lt; &#34;Different&#34;;  &#xA;}  &#xA;if (y == nullptr) {         // Can compare against nullptr (here returns true)&#xA;    cout &amp;lt;&amp;lt; &#34;Empty&#34;;  &#xA;}  &#xA;y = make_shared&amp;lt;int&amp;gt;(15);   // Assign new value&#xA;cout &amp;lt;&amp;lt; *y;                 // Dereference x to print &#39;15&#39;&#xA;cout &amp;lt;&amp;lt; *x;                 // Dereference x to print &#39;12&#39;&#xA;weak_ptr&amp;lt;int&amp;gt; w;            // Create empty weak pointer&#xA;w = y;                      // w has weak reference to y.&#xA;if (shared_ptr&amp;lt;int&amp;gt; s = w.lock()) { // Has to be copied into a shared_ptr before usage&#xA;    cout &amp;lt;&amp;lt; *s;&#xA;}&#xA;unique_ptr&amp;lt;int&amp;gt; z;          // Create empty unique pointers&#xA;unique_ptr&amp;lt;int&amp;gt; q;&#xA;z = make_unique&amp;lt;int&amp;gt;(16);   // Allocate int (16) on heap. Only one reference allowed.&#xA;q = move(z);                // Move reference from z to q.&#xA;if (z == nullptr){&#xA;    cout &amp;lt;&amp;lt; &#34;Z null&#34;;&#xA;}&#xA;cout &amp;lt;&amp;lt; *q;&#xA;shared_ptr&amp;lt;B&amp;gt; r;&#xA;r = dynamic_pointer_cast&amp;lt;B&amp;gt;(t); // Converts t to a shared_ptr&amp;lt;B&amp;gt;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;math.h&lt;/code&gt;, &lt;code&gt;cmath&lt;/code&gt; (floating point math)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cmath&amp;gt;            // Include cmath (std namespace)&#xA;sin(x); cos(x); tan(x);     // Trig functions, x (double) is in radians&#xA;asin(x); acos(x); atan(x);  // Inverses&#xA;atan2(y, x);                // atan(y/x)&#xA;sinh(x); cosh(x); tanh(x);  // Hyperbolic sin, cos, tan functions&#xA;exp(x); log(x); log10(x);   // e to the x, log base e, log base 10&#xA;pow(x, y); sqrt(x);         // x to the y, square root&#xA;ceil(x); floor(x);          // Round up or down (as a double)&#xA;fabs(x); fmod(x, y);        // Absolute value, x mod y&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;assert.h&lt;/code&gt;, &lt;code&gt;cassert&lt;/code&gt; (Debugging Aid)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;cassert&amp;gt;        // Include iostream (std namespace)&#xA;assert(e);                // If e is false, print message and abort&#xA;#define NDEBUG            // (before #include &amp;lt;assert.h&amp;gt;), turn off assert&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;iostream.h&lt;/code&gt;, &lt;code&gt;iostream&lt;/code&gt; (Replaces &lt;code&gt;stdio.h&lt;/code&gt;)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;         // Include iostream (std namespace)&#xA;cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;              // Read words x and y (any type) from stdin&#xA;cout &amp;lt;&amp;lt; &#34;x=&#34; &amp;lt;&amp;lt; 3 &amp;lt;&amp;lt; endl;  // Write line to stdout&#xA;cerr &amp;lt;&amp;lt; x &amp;lt;&amp;lt; y &amp;lt;&amp;lt; flush;    // Write to stderr and flush&#xA;c = cin.get();              // c = getchar();&#xA;cin.get(c);                 // Read char&#xA;cin.getline(s, n, &#39;\n&#39;);    // Read line into char s[n] to &#39;\n&#39; (default)&#xA;if (cin)                    // Good state (not EOF)?&#xA;                            // To read/write any type T:&#xA;istream&amp;amp; operator&amp;gt;&amp;gt;(istream&amp;amp; i, T&amp;amp; x) {i &amp;gt;&amp;gt; ...; x=...; return i;}&#xA;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; o, const T&amp;amp; x) {return o &amp;lt;&amp;lt; ...;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;fstream.h&lt;/code&gt;, &lt;code&gt;fstream&lt;/code&gt; (File I/O works like &lt;code&gt;cin&lt;/code&gt;, &lt;code&gt;cout&lt;/code&gt; as above)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;fstream&amp;gt;          // Include filestream (std namespace)&#xA;ifstream f1(&#34;filename&#34;);    // Open text file for reading&#xA;if (f1)                     // Test if open and input available&#xA;    f1 &amp;gt;&amp;gt; x;                // Read object from file&#xA;f1.get(s);                  // Read char or line&#xA;f1.getline(s, n);           // Read line into string s[n]&#xA;ofstream f2(&#34;filename&#34;);    // Open file for writing&#xA;if (f2) f2 &amp;lt;&amp;lt; x;            // Write to file&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;string&lt;/code&gt; (Variable sized character array)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;string&amp;gt;         // Include string (std namespace)&#xA;string s1, s2=&#34;hello&#34;;    // Create strings&#xA;s1.size(), s2.size();     // Number of characters: 0, 5&#xA;s1 += s2 + &#39; &#39; + &#34;world&#34;; // Concatenation&#xA;s1 == &#34;hello world&#34;       // Comparison, also &amp;lt;, &amp;gt;, !=, etc.&#xA;s1[0];                    // &#39;h&#39;&#xA;s1.substr(m, n);          // Substring of size n starting at s1[m]&#xA;s1.c_str();               // Convert to const char*&#xA;s1 = to_string(12.05);    // Converts number to string&#xA;getline(cin, s);          // Read line ending in &#39;\n&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;vector&lt;/code&gt; (Variable sized array/stack with built in memory allocation)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;vector&amp;gt;         // Include vector (std namespace)&#xA;vector&amp;lt;int&amp;gt; a(10);        // a[0]..a[9] are int (default size is 0)&#xA;vector&amp;lt;int&amp;gt; b{1,2,3};        // Create vector with values 1,2,3&#xA;a.size();                 // Number of elements (10)&#xA;a.push_back(3);           // Increase size to 11, a[10]=3&#xA;a.back()=4;               // a[10]=4;&#xA;a.pop_back();             // Decrease size by 1&#xA;a.front();                // a[0];&#xA;a[20]=1;                  // Crash: not bounds checked&#xA;a.at(20)=1;               // Like a[20] but throws out_of_range()&#xA;for (int&amp;amp; p : a)&#xA;  p=0;                    // C++11: Set all elements of a to 0&#xA;for (vector&amp;lt;int&amp;gt;::iterator p=a.begin(); p!=a.end(); ++p)&#xA;  *p=0;                   // C++03: Set all elements of a to 0&#xA;vector&amp;lt;int&amp;gt; b(a.begin(), a.end());  // b is copy of a&#xA;vector&amp;lt;T&amp;gt; c(n, x);        // c[0]..c[n-1] init to x&#xA;T d[10]; vector&amp;lt;T&amp;gt; e(d, d+10);      // e is initialized from d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;deque&lt;/code&gt; (Array stack queue)&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;deque&amp;lt;T&amp;gt;&lt;/code&gt; is like &lt;code&gt;vector&amp;lt;T&amp;gt;&lt;/code&gt;, but also supports:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;deque&amp;gt;          // Include deque (std namespace)&#xA;a.push_front(x);          // Puts x at a[0], shifts elements toward back&#xA;a.pop_front();            // Removes a[0], shifts toward front&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;utility&lt;/code&gt; (pair)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;utility&amp;gt;        // Include utility (std namespace)&#xA;pair&amp;lt;string, int&amp;gt; a(&#34;hello&#34;, 3);  // A 2-element struct&#xA;a.first;                  // &#34;hello&#34;&#xA;a.second;                 // 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;map&lt;/code&gt; (associative array - usually implemented as binary search trees - avg. time complexity: O(log n))&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;map&amp;gt;            // Include map (std namespace)&#xA;map&amp;lt;string, int&amp;gt; a;       // Map from string to int&#xA;a[&#34;hello&#34;] = 3;           // Add or replace element a[&#34;hello&#34;]&#xA;for (auto&amp;amp; p:a)&#xA;    cout &amp;lt;&amp;lt; p.first &amp;lt;&amp;lt; p.second;  // Prints hello, 3&#xA;a.size();                 // 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;unordered_map&lt;/code&gt; (associative array - usually implemented as hash table - avg. time complexity: O(1))&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;unordered_map&amp;gt;  // Include map (std namespace)&#xA;unordered_map&amp;lt;string, int&amp;gt; a; // Map from string to int&#xA;a[&#34;hello&#34;] = 3;           // Add or replace element a[&#34;hello&#34;]&#xA;for (auto&amp;amp; p:a)&#xA;    cout &amp;lt;&amp;lt; p.first &amp;lt;&amp;lt; p.second;  // Prints hello, 3&#xA;a.size();                 // 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;set&lt;/code&gt; (store unique elements - usually implemented as binary search trees - avg. time complexity: O(log n))&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;set&amp;gt;            // Include set (std namespace)&#xA;set&amp;lt;int&amp;gt; s;               // Set of integers&#xA;s.insert(123);            // Add element to set&#xA;if (s.find(123) != s.end()) // Search for an element&#xA;    s.erase(123);&#xA;cout &amp;lt;&amp;lt; s.size();         // Number of elements in set&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;unordered_set&lt;/code&gt; (store unique elements - usually implemented as a hash set - avg. time complexity: O(1))&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;unordered_set&amp;gt;  // Include set (std namespace)&#xA;unordered_set&amp;lt;int&amp;gt; s;     // Set of integers&#xA;s.insert(123);            // Add element to set&#xA;if (s.find(123) != s.end()) // Search for an element&#xA;    s.erase(123);&#xA;cout &amp;lt;&amp;lt; s.size();         // Number of elements in set&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;algorithm&lt;/code&gt; (A collection of 60 algorithms on sequences with iterators)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;      // Include algorithm (std namespace)&#xA;min(x, y); max(x, y);     // Smaller/larger of x, y (any type defining &amp;lt;)&#xA;swap(x, y);               // Exchange values of variables x and y&#xA;sort(a, a+n);             // Sort array a[0]..a[n-1] by &amp;lt;&#xA;sort(a.begin(), a.end()); // Sort vector or deque&#xA;reverse(a.begin(), a.end()); // Reverse vector or deque&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;chrono&lt;/code&gt; (Time related library)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;chrono&amp;gt;         // Include chrono&#xA;using namespace std::chrono; // Use namespace&#xA;auto from =               // Get current time_point&#xA;  high_resolution_clock::now();&#xA;// ... do some work       &#xA;auto to =                 // Get current time_point&#xA;  high_resolution_clock::now();&#xA;using ms =                // Define ms as floating point duration&#xA;  duration&amp;lt;float, milliseconds::period&amp;gt;;&#xA;                          // Compute duration in milliseconds&#xA;cout &amp;lt;&amp;lt; duration_cast&amp;lt;ms&amp;gt;(to - from)&#xA;  .count() &amp;lt;&amp;lt; &#34;ms&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;thread&lt;/code&gt; (Multi-threading library)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;thread&amp;gt;         // Include thread&#xA;unsigned c = &#xA;  hardware_concurrency(); // Hardware threads (or 0 for unknown)&#xA;auto lambdaFn = [](){     // Lambda function used for thread body&#xA;    cout &amp;lt;&amp;lt; &#34;Hello multithreading&#34;;&#xA;};&#xA;thread t(lambdaFn);       // Create and run thread with lambda&#xA;t.join();                 // Wait for t finishes&#xA;&#xA;// --- shared resource example ---&#xA;mutex mut;                         // Mutex for synchronization&#xA;condition_variable cond;           // Shared condition variable&#xA;const char* sharedMes              // Shared resource&#xA;  = nullptr;&#xA;auto pingPongFn =                  // thread body (lambda). Print someone else&#39;s message&#xA;  [&amp;amp;](const char* mes){&#xA;    while (true){&#xA;      unique_lock&amp;lt;mutex&amp;gt; lock(mut);// locks the mutex &#xA;      do {                &#xA;        cond.wait(lock, [&amp;amp;](){     // wait for condition to be true (unlocks while waiting which allows other threads to modify)        &#xA;          return sharedMes != mes; // statement for when to continue&#xA;        });&#xA;      } while (sharedMes == mes);  // prevents spurious wakeup&#xA;      cout &amp;lt;&amp;lt; sharedMes &amp;lt;&amp;lt; endl;&#xA;      sharedMes = mes;       &#xA;      lock.unlock();               // no need to have lock on notify &#xA;      cond.notify_all();           // notify all condition has changed&#xA;    }&#xA;  };&#xA;sharedMes = &#34;ping&#34;;&#xA;thread t1(pingPongFn, sharedMes);  // start example with 3 concurrent threads&#xA;thread t2(pingPongFn, &#34;pong&#34;);&#xA;thread t3(pingPongFn, &#34;boing&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;future&lt;/code&gt; (thread support library)&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;future&amp;gt;         // Include future&#xA;function&amp;lt;int(int)&amp;gt; fib =  // Create lambda function&#xA;  [&amp;amp;](int i){&#xA;    if (i &amp;lt;= 1){&#xA;      return 1;&#xA;    }&#xA;    return fib(i-1) &#xA;         + fib(i-2);&#xA;  };&#xA;future&amp;lt;int&amp;gt; fut =         // result of async function&#xA;  async(launch::async, fib, 4); // start async function in other thread&#xA;// do some other work &#xA;cout &amp;lt;&amp;lt; fut.get();        // get result of async function. Wait if needed.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>