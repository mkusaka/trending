<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-08-03T01:30:58Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>paullouisageneau/libdatachannel</title>
    <updated>2025-08-03T01:30:58Z</updated>
    <id>tag:github.com,2025-08-03:/paullouisageneau/libdatachannel</id>
    <link href="https://github.com/paullouisageneau/libdatachannel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;C/C++ WebRTC network library featuring Data Channels, Media Transport, and WebSockets&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;libdatachannel - C/C++ WebRTC network library&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.mozilla.org/en-US/MPL/2.0/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MPL_2.0-blue.svg?sanitize=true&#34; alt=&#34;License: MPL 2.0&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/actions/workflows/build-gnutls.yml&#34;&gt;&lt;img src=&#34;https://github.com/paullouisageneau/libdatachannel/actions/workflows/build-gnutls.yml/badge.svg?sanitize=true&#34; alt=&#34;Build with GnuTLS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/actions/workflows/build-mbedtls.yml&#34;&gt;&lt;img src=&#34;https://github.com/paullouisageneau/libdatachannel/actions/workflows/build-mbedtls.yml/badge.svg?sanitize=true&#34; alt=&#34;Build with Mbed TLS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/actions/workflows/build-openssl.yml&#34;&gt;&lt;img src=&#34;https://github.com/paullouisageneau/libdatachannel/actions/workflows/build-openssl.yml/badge.svg?sanitize=true&#34; alt=&#34;Build with OpenSSL&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://repology.org/project/libdatachannel/versions&#34;&gt;&lt;img src=&#34;https://repology.org/badge/tiny-repos/libdatachannel.svg?sanitize=true&#34; alt=&#34;Packaging status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://repology.org/project/libdatachannel/versions&#34;&gt;&lt;img src=&#34;https://repology.org/badge/latest-versions/libdatachannel.svg?sanitize=true&#34; alt=&#34;Latest packaged version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/libdatachannel/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/libdatachannel/community.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/jXAP8jp3Nn&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/903257095539925006?logo=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;libdatachannel is a standalone implementation of WebRTC Data Channels, WebRTC Media Transport, and WebSockets in C++ with C bindings for multiple platforms, including GNU/Linux, Android, FreeBSD, Apple macOS, iOS, and Microsoft Windows. WebRTC is a W3C and IETF standard enabling real-time peer-to-peer data and media exchange between two devices.&lt;/p&gt; &#xA;&lt;p&gt;The library aims at being both straightforward and lightweight with minimal external dependencies, to enable direct connectivity between native applications and web browsers without the pain of importing Google&#39;s bloated &lt;a href=&#34;https://webrtc.googlesource.com/src/&#34;&gt;reference library&lt;/a&gt;. The interface consists of somewhat simplified versions of the JavaScript WebRTC and WebSocket APIs present in browsers, in order to ease the design of cross-environment applications.&lt;/p&gt; &#xA;&lt;p&gt;It can be compiled with multiple backends:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The security layer can be provided through &lt;a href=&#34;https://www.gnutls.org/&#34;&gt;GnuTLS&lt;/a&gt;, &lt;a href=&#34;https://www.trustedfirmware.org/projects/mbed-tls/&#34;&gt;Mbed TLS&lt;/a&gt;, or &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The connectivity for WebRTC can be provided through my ad-hoc ICE library &lt;a href=&#34;https://github.com/paullouisageneau/libjuice&#34;&gt;libjuice&lt;/a&gt; as submodule or through &lt;a href=&#34;https://github.com/libnice/libnice&#34;&gt;libnice&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The WebRTC stack is fully compatible with browsers like Firefox and Chromium, see &lt;a href=&#34;https://raw.githubusercontent.com/paullouisageneau/libdatachannel/master/#Compatibility&#34;&gt;Compatibility&lt;/a&gt; below. Additionally, code using Data Channels and WebSockets from the library may be compiled as is to WebAssembly for browsers with &lt;a href=&#34;https://github.com/paullouisageneau/datachannel-wasm&#34;&gt;datachannel-wasm&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;libdatachannel is licensed under MPL 2.0 since version 0.18, see &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/raw/master/LICENSE&#34;&gt;LICENSE&lt;/a&gt; (previous versions were licensed under LGPLv2.1 or later).&lt;/p&gt; &#xA;&lt;p&gt;libdatachannel is available on &lt;a href=&#34;https://aur.archlinux.org/packages/libdatachannel/&#34;&gt;AUR&lt;/a&gt;, &lt;a href=&#34;https://vcpkg.io/en/getting-started&#34;&gt;vcpkg&lt;/a&gt;, &lt;a href=&#34;https://conan.io/center/recipes/libdatachannel&#34;&gt;conan&lt;/a&gt;, and &lt;a href=&#34;https://www.freshports.org/www/libdatachannel&#34;&gt;FreeBSD ports&lt;/a&gt;. Bindings are available for &lt;a href=&#34;https://crates.io/crates/datachannel&#34;&gt;Rust&lt;/a&gt; and &lt;a href=&#34;https://www.npmjs.com/package/node-datachannel&#34;&gt;Node.js&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnutls.org/&#34;&gt;GnuTLS&lt;/a&gt;, &lt;a href=&#34;https://www.trustedfirmware.org/projects/mbed-tls/&#34;&gt;Mbed TLS&lt;/a&gt;, or &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sctplab/usrsctp&#34;&gt;usrsctp&lt;/a&gt; (as submodule by default)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/SergiusTheBest/plog&#34;&gt;plog&lt;/a&gt; (as submodule by default)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/paullouisageneau/libjuice&#34;&gt;libjuice&lt;/a&gt; (as submodule by default) or &lt;a href=&#34;https://nice.freedesktop.org/&#34;&gt;libnice&lt;/a&gt; as an ICE backend.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cisco/libsrtp&#34;&gt;libsrtp&lt;/a&gt; (as submodule by default) required if compiled with media support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nlohmann/json&#34;&gt;nlohmann JSON&lt;/a&gt; (as submodule by default) required to build examples.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/raw/master/BUILDING.md&#34;&gt;BUILDING.md&lt;/a&gt; for building instructions.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/raw/master/examples/&#34;&gt;examples&lt;/a&gt; for complete usage examples with signaling server (under MPL 2.0).&lt;/p&gt; &#xA;&lt;p&gt;Additionally, you might want to have a look at the &lt;a href=&#34;https://github.com/paullouisageneau/libdatachannel/raw/master/DOC.md&#34;&gt;C API documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Signal a PeerConnection&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &#34;rtc/rtc.hpp&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;rtc::Configuration config;&#xA;config.iceServers.emplace_back(&#34;mystunserver.org:3478&#34;);&#xA;&#xA;rtc::PeerConnection pc(config);&#xA;&#xA;pc.onLocalDescription([](rtc::Description sdp) {&#xA;    // Send the SDP to the remote peer&#xA;    MY_SEND_DESCRIPTION_TO_REMOTE(std::string(sdp));&#xA;});&#xA;&#xA;pc.onLocalCandidate([](rtc::Candidate candidate) {&#xA;    // Send the candidate to the remote peer&#xA;    MY_SEND_CANDIDATE_TO_REMOTE(candidate.candidate(), candidate.mid());&#xA;});&#xA;&#xA;MY_ON_RECV_DESCRIPTION_FROM_REMOTE([&amp;amp;pc](std::string sdp) {&#xA;    pc.setRemoteDescription(rtc::Description(sdp));&#xA;});&#xA;&#xA;MY_ON_RECV_CANDIDATE_FROM_REMOTE([&amp;amp;pc](std::string candidate, std::string mid) {&#xA;    pc.addRemoteCandidate(rtc::Candidate(candidate, mid));&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Observe the PeerConnection state&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;pc.onStateChange([](rtc::PeerConnection::State state) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;State: &#34; &amp;lt;&amp;lt; state &amp;lt;&amp;lt; std::endl;&#xA;});&#xA;&#xA;pc.onGatheringStateChange([](rtc::PeerConnection::GatheringState state) {&#xA;    std::cout &amp;lt;&amp;lt; &#34;Gathering state: &#34; &amp;lt;&amp;lt; state &amp;lt;&amp;lt; std::endl;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Create a DataChannel&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto dc = pc.createDataChannel(&#34;test&#34;);&#xA;&#xA;dc-&amp;gt;onOpen([]() {&#xA;    std::cout &amp;lt;&amp;lt; &#34;Open&#34; &amp;lt;&amp;lt; std::endl;&#xA;});&#xA;&#xA;dc-&amp;gt;onMessage([](std::variant&amp;lt;rtc::binary, rtc::string&amp;gt; message) {&#xA;    if (std::holds_alternative&amp;lt;rtc::string&amp;gt;(message)) {&#xA;        std::cout &amp;lt;&amp;lt; &#34;Received: &#34; &amp;lt;&amp;lt; get&amp;lt;rtc::string&amp;gt;(message) &amp;lt;&amp;lt; std::endl;&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Receive a DataChannel&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::shared_ptr&amp;lt;rtc::DataChannel&amp;gt; dc;&#xA;pc.onDataChannel([&amp;amp;dc](std::shared_ptr&amp;lt;rtc::DataChannel&amp;gt; incoming) {&#xA;    dc = incoming;&#xA;    dc-&amp;gt;send(&#34;Hello world!&#34;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Open a WebSocket&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;rtc::WebSocket ws;&#xA;&#xA;ws.onOpen([]() {&#xA;    std::cout &amp;lt;&amp;lt; &#34;WebSocket open&#34; &amp;lt;&amp;lt; std::endl;&#xA;});&#xA;&#xA;ws.onMessage([](std::variant&amp;lt;rtc::binary, rtc::string&amp;gt; message) {&#xA;    if (std::holds_alternative&amp;lt;rtc::string&amp;gt;(message)) {&#xA;        std::cout &amp;lt;&amp;lt; &#34;WebSocket received: &#34; &amp;lt;&amp;lt; std::get&amp;lt;rtc::string&amp;gt;(message) &amp;lt;&amp;lt; endl;&#xA;    }&#xA;});&#xA;&#xA;ws.open(&#34;wss://my.websocket/service&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;The library implements the following communication protocols:&lt;/p&gt; &#xA;&lt;h3&gt;WebRTC Data Channels and Media Transport&lt;/h3&gt; &#xA;&lt;p&gt;WebRTC allows real-time data and media exchange between two devices through a Peer Connection (or RTCPeerConnection), a signaled peer-to-peer connection which can carry both Data Channels and media tracks. It is compatible with browsers Firefox, Chromium, and Safari, and other WebRTC libraries (see &lt;a href=&#34;https://github.com/sipsorcery/webrtc-echoes&#34;&gt;webrtc-echoes&lt;/a&gt;). Media transport is optional and can be disabled at compile time.&lt;/p&gt; &#xA;&lt;p&gt;Protocol stack:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;SCTP-based Data Channels (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8831.html&#34;&gt;RFC8831&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;SRTP-based Media Transport (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8834.html&#34;&gt;RFC8834&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;DTLS/UDP (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc7350.html&#34;&gt;RFC7350&lt;/a&gt; and &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8261.html&#34;&gt;RFC8261&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;ICE (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8445.html&#34;&gt;RFC8445&lt;/a&gt;) with STUN (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8489.html&#34;&gt;RFC8489&lt;/a&gt;) and its extension TURN (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8656.html&#34;&gt;RFC8656&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Full IPv6 support (as mandated by &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8835.html&#34;&gt;RFC8835&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Trickle ICE (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8838.html&#34;&gt;RFC8838&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;JSEP-compatible session establishment with SDP (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8829.html&#34;&gt;RFC8829&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;SCTP over DTLS with SDP offer/answer (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8841.html&#34;&gt;RFC8841&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;DTLS with ECDSA or RSA keys (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8827.html&#34;&gt;RFC8827&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;SRTP and SRTCP key derivation from DTLS (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc5764.html&#34;&gt;RFC5764&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Differentiated Services QoS (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8837.html&#34;&gt;RFC8837&lt;/a&gt;) where possible&lt;/li&gt; &#xA; &lt;li&gt;Multicast DNS candidates (&lt;a href=&#34;https://datatracker.ietf.org/doc/html/draft-ietf-rtcweb-mdns-ice-candidates-04&#34;&gt;draft-ietf-rtcweb-mdns-ice-candidates-04&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Multiplexing connections on a single UDP port with libjuice as ICE backend&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note only SDP BUNDLE mode is supported for media multiplexing (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8843.html&#34;&gt;RFC8843&lt;/a&gt;). The behavior is equivalent to the JSEP bundle-only policy: the library always negotiates one unique network component, where SRTP media streams are multiplexed with SRTCP control packets (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc5761.html&#34;&gt;RFC5761&lt;/a&gt;) and SCTP/DTLS data traffic (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc8261.html&#34;&gt;RFC8261&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;WebSocket&lt;/h3&gt; &#xA;&lt;p&gt;WebSocket is the protocol of choice for WebRTC signaling. The support is optional and can be disabled at compile time.&lt;/p&gt; &#xA;&lt;p&gt;Protocol stack:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;WebSocket protocol (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc6455.html&#34;&gt;RFC6455&lt;/a&gt;), client and server side&lt;/li&gt; &#xA; &lt;li&gt;HTTP over TLS (&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc2818.html&#34;&gt;RFC2818&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;IPv6 and IPv4/IPv6 dual-stack support&lt;/li&gt; &#xA; &lt;li&gt;Keepalive with ping/pong&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;External resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Rust bindings for libdatachannel: &lt;a href=&#34;https://github.com/lerouxrgd/datachannel-rs&#34;&gt;datachannel-rs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Node.js bindings for libdatachannel: &lt;a href=&#34;https://github.com/murat-dogan/node-datachannel&#34;&gt;node-datachannel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Unity bindings for Windows 10 and Hololens: &lt;a href=&#34;https://github.com/hanseuljun/datachannel-unity&#34;&gt;datachannel-unity&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;WebAssembly wrapper compatible with libdatachannel: &lt;a href=&#34;https://github.com/paullouisageneau/datachannel-wasm&#34;&gt;datachannel-wasm&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Lightweight STUN/TURN server: &lt;a href=&#34;https://github.com/paullouisageneau/violet&#34;&gt;Violet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Native platform (Android/iOS/macOS) wrapper for libdatachannel: &lt;a href=&#34;https://github.com/swarm-cloud/datachannel-native&#34;&gt;datachannel-native&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://streamr.network/&#34;&gt;Streamr&lt;/a&gt;, &lt;a href=&#34;https://vagon.io/&#34;&gt;Vagon&lt;/a&gt;, &lt;a href=&#34;https://github.com/shiguredo&#34;&gt;Shiguredo&lt;/a&gt;, &lt;a href=&#34;https://github.com/dbotha&#34;&gt;Deon Botha&lt;/a&gt;, and &lt;a href=&#34;https://github.com/micoolcho&#34;&gt;Michael Cho&lt;/a&gt; for sponsoring this work!&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/longfellow-zk</title>
    <updated>2025-08-03T01:30:58Z</updated>
    <id>tag:github.com,2025-08-03:/google/longfellow-zk</id>
    <link href="https://github.com/google/longfellow-zk" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Implementation of the Google Zero-Knowledge library for Identity Protocols.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Longfellow ZK&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/google/longfellow-zk/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License: Apache 2.0&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://eprint.iacr.org/2024/2010&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/eprint-2024%2F2010-blue&#34; alt=&#34;eprint&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://datatracker.ietf.org/doc/draft-google-cfrg-libzk/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/IETF%20Draft-draft--google--cfrg--libzk-lightgrey&#34; alt=&#34;IETF Draft&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;The Longfellow library enables the construction of zero-knowledge protocols concerning legacy identity verification standards such as the ISO MDOC standard, the JWT standard, and W3 Verifiable Credentials. This implementation is described in:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://eprint.iacr.org/2024/2010&#34;&gt;Anonymous credentials from ECDSA&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/draft-google-cfrg-libzk/&#34;&gt;libzk: A C++ Library for Zero-Knowledge Proofs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://google.github.io/longfellow-zk/&#34;&gt;Project documentation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It is named after the bridge outside the Google Cambridge office.&lt;/p&gt; &#xA;&lt;h1&gt;Ongoing Security Reviews&lt;/h1&gt; &#xA;&lt;p&gt;This project is currently undergoing two independent security reviews by panels of academic and industry experts in the field. Their reports will be made public on this repo when completed, targetted for Aug 20.&lt;/p&gt; &#xA;&lt;h1&gt;Testing via devcontainer&lt;/h1&gt; &#xA;&lt;p&gt;You can quickly test our library by using the associated devcontainer to create its environment. Simply click on &lt;code&gt;Code&lt;/code&gt;--&amp;gt;&lt;code&gt;Codespaces&lt;/code&gt;--&amp;gt;&lt;code&gt;Create codespace on master&lt;/code&gt; above to get started. This creates a docker container on a Github server that includes all of the dependencies and provides a web-based VScode interface to our current codebase. You can compile and run our benchmarks in this environment, but some of them may be slower than our reported values due to the VM.&lt;/p&gt; &#xA;&lt;h1&gt;Instructions to build&lt;/h1&gt; &#xA;&lt;h2&gt;Requirements&lt;/h2&gt; &#xA;&lt;p&gt;This package depends on cmake, openssl, zstd, clang, googletest and googlebenchmark.&lt;/p&gt; &#xA;&lt;h3&gt;Ubuntu, debian&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt install -y clang cmake libssl-dev libzstd-dev libgtest-dev libbenchmark-dev zlib1g-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fedora, redhat&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ yum install -y clang libzstd-devel openssl-devel git cmake google-benchmark-devel gtest-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;MacOS&lt;/h3&gt; &#xA;&lt;p&gt;Ensure that Xcode command line tools such as &lt;code&gt;clang&lt;/code&gt; and &lt;code&gt;cmake&lt;/code&gt; are installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ brew install googletest google-benchmark zstd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building manually&lt;/h2&gt; &#xA;&lt;p&gt;First run the cmake initialization step&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ CXX=clang++ cmake -D CMAKE_BUILD_TYPE=Release -S lib -B clang-build-release --install-prefix ${PWD}/install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cd clang-build-release &amp;amp;&amp;amp; make -j 16 &amp;amp;&amp;amp; ctest -j 16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Running benchmarks&lt;/h1&gt; &#xA;&lt;p&gt;We have defined several unit, sumcheck, and zk benchmarks. Here are some of them:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ ./algebra/fft_test --benchmark_filter=&#39;BM_*&#39;&#xA;$ ./circuits/sha/flatsha256_circuit_test --benchmark_filter=BM_ShaZK_fp2_128&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>