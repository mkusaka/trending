<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-27T01:30:07Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>PabloMK7/ENLBufferPwn</title>
    <updated>2022-12-27T01:30:07Z</updated>
    <id>tag:github.com,2022-12-27:/PabloMK7/ENLBufferPwn</id>
    <link href="https://github.com/PabloMK7/ENLBufferPwn" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Information and PoC about the ENLBufferPwn vulnerability&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ENLBufferPwn (CVE-2022-47949)&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;320&#34; height=&#34;168&#34; src=&#34;https://github.com/PabloMK7/ENLBufferPwn/raw/main/images/enlbufferpwn_logo.png?raw=true&#34;&gt; &lt;/p&gt; &#xA;&lt;table align=&#34;center&#34;&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CVE:&lt;/td&gt; &#xA;   &lt;td&gt;CVE-2022-47949&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CVSS v3.1:&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&#34;&gt;9.8/10 (Critical)&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Authors:&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/PabloMK7&#34;&gt;PabloMK7&lt;/a&gt;, &lt;a href=&#34;https://github.com/Rambo6Glaz&#34;&gt;Rambo6Glaz&lt;/a&gt;, &lt;a href=&#34;https://github.com/fishguy6564&#34;&gt;Fishguy6564&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Reported:&lt;/td&gt; &#xA;   &lt;td&gt;August 8th, 2021 (Mario Kart 7) &lt;br&gt; April 14th, 2022 (Mario Kart 8) &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Disclosed:&lt;/td&gt; &#xA;   &lt;td&gt;December 22nd, 2022&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Table of contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#vulnerability-details&#34;&gt;Vulnerability details&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#enlbufferpwn-in-mario-kart-7-3ds&#34;&gt;ENLBufferPwn in Mario Kart 7 (3DS)&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#technical-details&#34;&gt;Technical details&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#enlbufferpwn-in-mario-kart-8-wii-u&#34;&gt;ENLBufferPwn in Mario Kart 8 (Wii U)&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#technical-details-1&#34;&gt;Technical details&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Description&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;ENLBufferPwn&lt;/strong&gt; is a vulnerability in the common network code of several first party Nintendo games since the Nintendo 3DS that allows an attacker to execute code remotely in the victim&#39;s console by just having an online game with them (remote code execution). It was dicovered by multiple people independently during 2021 and reported to Nintendo during 2021 and 2022. Since the initial report, Nintendo has patched the vulnerability in many vulnerable games. The information in this repository has been safely disclosed after getting permission from Nintendo.&lt;/p&gt; &#xA;&lt;p&gt;The vulnerability has scored a &lt;a href=&#34;https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H&#34;&gt;9.8/10 (Critical)&lt;/a&gt; in the CVSS 3.1 calculator.&lt;/p&gt; &#xA;&lt;p&gt;Here is a list of games that are known to have had the vulnerability at some point (all the Switch and 3DS games listed have received updates that patch the vulnerability, so they are no longer affected):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mario Kart 7 (fixed in v1.2)&lt;/li&gt; &#xA; &lt;li&gt;Mario Kart 8 (still not fixed)&lt;/li&gt; &#xA; &lt;li&gt;Mario Kart 8 Deluxe (fixed in v2.1.0)&lt;/li&gt; &#xA; &lt;li&gt;Animal Crossing: New Horizons (fixed in v2.0.6)&lt;/li&gt; &#xA; &lt;li&gt;ARMS (fixed in v5.4.1)&lt;/li&gt; &#xA; &lt;li&gt;Splatoon (still not fixed)&lt;/li&gt; &#xA; &lt;li&gt;Splatoon 2 (fixed in v5.5.1)&lt;/li&gt; &#xA; &lt;li&gt;Splatoon 3 (fixed in late 2022, exact version unknown)&lt;/li&gt; &#xA; &lt;li&gt;Super Mario Maker 2 (fixed in v3.0.2)&lt;/li&gt; &#xA; &lt;li&gt;Nintendo Switch Sports (fixed in late 2022, exact version unknown)&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Probably more...&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Vulnerability details&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;ENLBufferPwn&lt;/strong&gt; vulnerability exploits a buffer overflow in the C++ class &lt;code&gt;NetworkBuffer&lt;/code&gt; present in the network library &lt;code&gt;enl&lt;/code&gt; (&lt;code&gt;Net&lt;/code&gt; in Mario Kart 7) used by many first party Nintendo games. This class contains two methods &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; which fill a network buffer with data coming from other players. However, none of those methods check that the input data actually fits in the network buffer. Since the input data is controllable, a buffer overflow can be triggered on a remote console by just having an online game session with the attacker. If done properly, the victim user may not even notice a vulnerability was triggered in their console. The consequences of this buffer overflow vary on the game, from simple inoffensive modifications to the game&#39;s memory (&lt;a href=&#34;https://www.youtube.com/watch?v=nVCPjUrkfPg&#34;&gt;like repeatedly opening and closing the home menu on the 3DS&lt;/a&gt;) to more severe actions like taking full control of the console, as shown below.&lt;/p&gt; &#xA;&lt;p&gt;The rest of the report will focus on Mario Kart 7, as due to the lack of security measures (ASLR, for example) of the 3DS, it is the most severe case of the vulnerability. However, it may be possible to bypass ASLR on Switch games by hijacking the &lt;code&gt;NetworkBuffer&lt;/code&gt; used to send data back to the attacker (and making it leak pointers to the heap and code).&lt;/p&gt; &#xA;&lt;h2&gt;ENLBufferPwn in Mario Kart 7 (3DS)&lt;/h2&gt; &#xA;&lt;p&gt;The following video showcases a severe case of the vulnerability in Mario Kart 7, where a console controlled by an attacker (left side) fully takes over an unmodified console (right side). The only interaction done by the user is joining an online game session with the attacker, in this case, using the &#34;communities&#34; feature (note that a &#34;community&#34; was used to safely test the vulnerability in an isolated manner and not affect any other users playing in public lobbies). The takeover is done by copying a ROP payload to the remote console and then executing it. This ROP payload then uses other vulnerabilities in the OS to escalate privileges and get total control. In the video, the remote console is forced to run a CFW installer (&lt;code&gt;SafeB9SInstaller&lt;/code&gt;). Using the same tchniques, it would be theoretically possible to &lt;strong&gt;steal account/credit card information&lt;/strong&gt; or &lt;strong&gt;take unauthorized audio/video recordings using the console built-in mic/cameras&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=PLAVmp5ky-k&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/PLAVmp5ky-k/0.jpg&#34; alt=&#34;ENLBufferPwn - Mario Kart 7 Demonstration - Youtube&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Technical details&lt;/h3&gt; &#xA;&lt;p&gt;As previously stated, the vulnerability comes from an oversight in two methods of the class &lt;code&gt;NetworkBuffer&lt;/code&gt;. Here is an implementation of the class and methods in C++:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class NetworkBuffer&#xA;{&#xA;public:&#xA;    u8&#x9;bufferType;&#xA;    u8* dataPtr;&#xA;    u32 dataSize;&#xA;    u32 currentSize;&#xA;&#xA;    void Set(u8* newData, u32 newDataSize);&#xA;    void Add(u8* newData, u32 newDataSize);&#xA;}&#xA;&#xA;void NetworkBuffer::Set(u8* newData, u32 newDataSize)&#xA;{&#xA;    memcpy(this-&amp;gt;dataPtr, newData, newDataSize);&#xA;    this-&amp;gt;currentSize = newDataSize;&#xA;}&#xA;&#xA;void NetworkBuffer::Add(u8* newData, u32 newDataSize)&#xA;{&#xA;    memcpy(this-&amp;gt;dataPtr + this-&amp;gt;currentSize, newData, newDataSize);&#xA;    this-&amp;gt;currentSize += newDataSize;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can see, neither &lt;code&gt;Set&lt;/code&gt; nor &lt;code&gt;Add&lt;/code&gt; check that the incoming &lt;code&gt;newDataSize&lt;/code&gt; fits in the buffer size (&lt;code&gt;dataSize&lt;/code&gt;). Since this &lt;code&gt;NetworkBuffer&lt;/code&gt; class is used as a generic container to interchange data between players online, the contents of &lt;code&gt;newData&lt;/code&gt; and the value of &lt;code&gt;newDataSize&lt;/code&gt; can be controlled by an attacker, and a buffer overflow can be performed.&lt;/p&gt; &#xA;&lt;p&gt;Another detail of the network library is that it is asynchronous, so that games can be doing other operations while data is being filled up into the buffer. In order to accomplish this, a double buffer technique is used. This way, the game can access already received data in a &lt;code&gt;NetworkBuffer&lt;/code&gt; at the same time as new data is being received. After the second &lt;code&gt;NetworkBuffer&lt;/code&gt; is filled, the buffers are swapped and the cycle repeats.&lt;/p&gt; &#xA;&lt;p&gt;For this PoC, we will be exploiting the double &lt;code&gt;NetworkBuffer&lt;/code&gt; used to receive Mii data (&lt;code&gt;bufferType = 9&lt;/code&gt;). Due to the order of heap allocation, it just happens that the &lt;code&gt;NetworkBuffer&lt;/code&gt; object and its contents are placed next to each other. Also, both buffers from the double buffer are contigous in memory. The following diagram represents how the memory looks after the buffer allocation:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/images/memory_layout.png&#34; alt=&#34;Representation of the mii data double NetworBuffer in the game&#39;s heap&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;From now on, the buffer in the top of the image will be references as &lt;code&gt;Buffer0&lt;/code&gt;, while the buffer in the bottom will be &lt;code&gt;Buffer1&lt;/code&gt;. Using this knowledge, an attacker can trigger the buffer overflow in &lt;code&gt;Buffer0&lt;/code&gt; to overwrite the attributes of &lt;code&gt;Buffer1&lt;/code&gt;, including its &lt;code&gt;dataPtr&lt;/code&gt; member. Since 3DS games do not implement ASLR, all the memory locations in the remote console are known, so &lt;code&gt;dataPtr&lt;/code&gt; can be pointed to an arbitrary location. Once the game swaps the buffer, the new data will be copied to the arbitrary location. Doing the following steps, a payload of any size can be copied to the remote console:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Build a specially crafted payload and send it in &lt;code&gt;Buffer0&lt;/code&gt;. It will trigger an overflow in the remote console overwriting &lt;code&gt;dataPtr&lt;/code&gt; of &lt;code&gt;Buffer1&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Set the contents of &lt;code&gt;Buffer1&lt;/code&gt; with arbitrary data. It will be copied to the arbitrary address pointed by &lt;code&gt;dataPtr&lt;/code&gt; of &lt;code&gt;Buffer1&lt;/code&gt; of the remote console.&lt;/li&gt; &#xA; &lt;li&gt;Increase the arbitrary address and size and start again from step &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Below is an animation of the normal operation of the game, followed by performing the steps described above.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/images/exploit_operation.gif&#34; alt=&#34;Animation of the normal operation of the double buffers, followed by vulnerability operation&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains a PoC that exploits this vulnerability to perform the following operations, depending on the compiler flags:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Send a 4 byte value that is written to the application status address of the remote console, forcing it to close and return to the home menu.&lt;/li&gt; &#xA; &lt;li&gt;Send a ROP payload that is stored in the remote console memory. Once the ROP is sent, the stack is overwritten so that the game executes it (the ROP payload itself is not provided in the PoC).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Keep in mind that this PoC does not implement any kind of packet drop detection, as communications between consoles are done using UDP. To obtain the best results, packet drop handling should be implemented in the PoC code or the consoles should be placed in the same network to reduce the chances of packets dropping.&lt;/p&gt; &#xA;&lt;p&gt;A possible fix of the vulnerable &lt;code&gt;NetworkBuffer&lt;/code&gt; class is &lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/Mario_Kart_7_PoC/Includes/MK7NetworkBuffer.hpp&#34;&gt;also provided&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;ENLBufferPwn in Mario Kart 8 (Wii U)&lt;/h2&gt; &#xA;&lt;p&gt;The following video showcases a severe case of the vulnerability in Mario Kart 8 for the Wii U, where code that prints a custom message is executed remotely on a Wii U console (in the background) by making it connect to a simulated player via a PC utility (bottom right corner). The only interaction done by the user is joining an online game session with the attacker, in this case, using the &#34;friends&#34; feature (note that a &#34;friend room&#34; was used to safely test the vulnerability in an isolated manner and not affect any other users playing in public lobbies). Remote code execution is achieved the same way as in Mario Kart 7: A ROP payload is sent to the remote console and then executed by overwriting the stack. While this video doesn&#39;t showcase full console takeover, it is possible to combine the ROP payload with other vulnerabilities to achieve it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=6Z7jSUimmuc&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/6Z7jSUimmuc/0.jpg&#34; alt=&#34;ENLBufferPwn - Mario Kart 8 Demonstration - Youtube&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Technical details&lt;/h3&gt; &#xA;&lt;p&gt;All the details explained in the section &lt;a href=&#34;https://raw.githubusercontent.com/PabloMK7/ENLBufferPwn/main/#enlbufferpwn-in-mario-kart-7-3ds&#34;&gt;ENLBufferPwn in Mario Kart 7 (3DS)&lt;/a&gt; apply to Mario Kart 8 as well. The only notable difference is the implementation of the &lt;code&gt;NetworkBuffer&lt;/code&gt; class, which has a few extra attributes. However, none of the differences affect how the vulnerability works.&lt;/p&gt; &#xA;&lt;p&gt;This repository contains a PoC that exploits this vulnerability to perform the following operations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Send a ROP payload that is stored in the remote console stack. Part of the payload is used to overwrite the return address of the function, making the game execute it immediately. The PoC only implements sending payloads of 0x9C bytes.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The PoC requires an old version of NintendoClients that implements PIA communications&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;While this vulnerability was discovered by multiple users independently, many of them decided to keep the vulnerability information private. However, the folowing people are responsible for safely disclosing the vulnerability to Nintendo:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;PabloMK7 (&lt;a href=&#34;https://github.com/PabloMK7&#34;&gt;GitHub&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/Pablomf6&#34;&gt;Twitter&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Rambo6Glaz (&lt;a href=&#34;https://github.com/Rambo6Glaz&#34;&gt;GitHub&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Fishguy6564 (&lt;a href=&#34;https://github.com/fishguy6564&#34;&gt;GitHub&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/fishguy6564&#34;&gt;Twitter&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p xmlns:dct=&#34;http://purl.org/dc/terms/&#34; xmlns:vcard=&#34;http://www.w3.org/2001/vcard-rdf/3.0#&#34;&gt; &lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/publicdomain/zero/1.0/&#34;&gt; &lt;img src=&#34;http://i.creativecommons.org/p/zero/1.0/88x31.png&#34; style=&#34;border-style: none;&#34; alt=&#34;CC0&#34;&gt; &lt;/a&gt; &lt;br&gt; To the extent possible under law, &lt;a rel=&#34;dct:publisher&#34; href=&#34;https://github.com/PabloMK7/ENLBufferPwn&#34;&gt; &lt;span property=&#34;dct:title&#34;&gt;PabloMK7, Rambo6Glaz and Fishguy6564&lt;/span&gt;&lt;/a&gt; have waived all copyright and related or neighboring rights to &lt;span property=&#34;dct:title&#34;&gt;ENLBufferPwn&lt;/span&gt;. This work is published from: &lt;span property=&#34;vcard:Country&#34; datatype=&#34;dct:ISO3166&#34; content=&#34;ES&#34; about=&#34;https://github.com/PabloMK7/ENLBufferPwn&#34;&gt; Spain&lt;/span&gt;. &lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Arduino-IRremote/Arduino-IRremote</title>
    <updated>2022-12-27T01:30:07Z</updated>
    <id>tag:github.com,2022-12-27:/Arduino-IRremote/Arduino-IRremote</id>
    <link href="https://github.com/Arduino-IRremote/Arduino-IRremote" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Infrared remote library for Arduino: send and receive infrared signals with multiple protocols&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Arduino IRremote&lt;/h1&gt; &#xA; &lt;p&gt;A library enabling the sending &amp;amp; receiving of infra-red signals.&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-ac8b11.svg?style=for-the-badge&amp;amp;labelColor=yellow&#34; alt=&#34;Badge License: MIT&#34;&gt;&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/Arduino-IRremote/Arduino-IRremote?include_prereleases&amp;amp;style=for-the-badge&amp;amp;color=33660e&amp;amp;labelColor=428813&amp;amp;logoColor=white&amp;amp;logo=DocuSign&#34; alt=&#34;Badge Version&#34;&gt;&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/commits/master&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/commits-since/Arduino-IRremote/Arduino-IRremote/latest?style=for-the-badge&amp;amp;color=004463&amp;amp;labelColor=00557f&#34; alt=&#34;Badge Commits since latest&#34;&gt;&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/Arduino-IRremote/Arduino-IRremote/LibraryBuild.yml?branch=master&amp;amp;style=for-the-badge&amp;amp;color=551f47&amp;amp;labelColor=752a61&#34; alt=&#34;Badge LibraryBuild&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;a href=&#34;https://stand-with-ukraine.pp.ua&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/badges/StandWithUkraine.svg?sanitize=true&#34; alt=&#34;Stand With Ukraine&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;Available as &lt;a href=&#34;https://www.arduinolibraries.info/libraries/i-rremote&#34;&gt;Arduino library &#34;IRremote&#34;&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://www.ardu-badge.com/IRremote&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Install-yellow?style=for-the-badge&amp;amp;logoColor=white&amp;amp;logo=GitBook&#34; alt=&#34;Button Install&#34;&gt;&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=&#34;https://arduino-irremote.github.io/Arduino-IRremote/classIRrecv.html&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/API-1c8840?style=for-the-badge&amp;amp;logoColor=white&amp;amp;logo=OpenStreetMap&#34; alt=&#34;Button API&#34;&gt;&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/changelog.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Changelog-00557f?style=for-the-badge&amp;amp;logoColor=white&amp;amp;logo=AzureArtifacts&#34; alt=&#34;Button Changelog&#34;&gt;&lt;/a&gt; &amp;nbsp; &amp;nbsp; &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/Contributing.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Contribute-752a61?style=for-the-badge&amp;amp;logoColor=white&amp;amp;logo=GitHub&#34; alt=&#34;Button Contribute&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1&gt;Overview&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#supported-ir-protocols&#34;&gt;Supported IR Protocols&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#features&#34;&gt;Features&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#new-features-with-version-3x&#34;&gt;New features with version 3.x&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#converting-your-2x-program-to-the-3x-version&#34;&gt;Converting your 2.x program to the 3.x version&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#how-to-convert-old-msb-first-32-bit-ir-data-codes-to-new-lsb-first-32-bit-ir-data-codes&#34;&gt;How to convert old MSB first 32 bit IR data codes to new LSB first 32 bit IR data codes&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#errors-with-using-the-3x-versions-for-old-tutorials&#34;&gt;Errors with using the 3.x versions for old tutorials&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#staying-on-2x&#34;&gt;Staying on 2.x&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#why-hpp-instead-of-cpp&#34;&gt;Why *.hpp instead of *.cpp&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#using-the-new-hpp-files&#34;&gt;Using the new *.hpp files&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#receiving-ir-codes&#34;&gt;Receiving IR codes&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#data-format&#34;&gt;Data format&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#minimal-nec-receiver&#34;&gt;Minimal NEC receiver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#sending-ir-codes&#34;&gt;Sending IR codes&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#list-of-public-ir-code-databases&#34;&gt;List of public IR code databases&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#faq-and-hints&#34;&gt;FAQ and hints&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#problems-with-neopixels-fastled-etc&#34;&gt;Problems with Neopixels, FastLed etc.&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#does-not-workcompile-with-another-library&#34;&gt;Does not work/compile with another library&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#multiple-ir-receiver&#34;&gt;Multiple IR receiver&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#increase-strength-of-sent-output-signal&#34;&gt;Increase strength of sent output signal&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#minimal-cpu-frequency&#34;&gt;Minimal CPU frequency&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#handling-unknown-protocols&#34;&gt;Handling unknown Protocols&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#disclaimer&#34;&gt;Disclaimer&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#protocolpulse_distance&#34;&gt;Protocol=PULSE_DISTANCE&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#protocolunknown&#34;&gt;Protocol=UNKNOWN&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#how-to-deal-with-protocols-not-supported-by-irremote&#34;&gt;How to deal with protocols not supported by IRremote&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#examples-for-this-library&#34;&gt;Examples for this library&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#wokwi-online-examples&#34;&gt;WOKWI online examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#issues-and-discussions&#34;&gt;Issues and discussions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#compile-options--macros-for-this-library&#34;&gt;Compile options / macros for this library&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#changing-include-h-files-with-arduino-ide&#34;&gt;Changing include (*.h) files with Arduino IDE&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#modifying-compile-options--macros-with-sloeber-ide&#34;&gt;Modifying compile options with Sloeber IDE&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#supported-boards&#34;&gt;Supported Boards&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#timer-and-pin-usage&#34;&gt;Timer and pin usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#incompatibilities-to-other-libraries-and-arduino-commands-like-tone-and-analogwrite&#34;&gt;Incompatibilities to other libraries and Arduino commands like tone() and analogWrite()&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#hardware-pwm-signal-generation-for-sending&#34;&gt;Hardware-PWM signal generation for sending&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#why-do-we-use-30-duty-cycle-for-sending&#34;&gt;Why do we use 30% duty cycle for sending&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#how-we-decode-signals&#34;&gt;How we decode signals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#nec-encoding-diagrams&#34;&gt;NEC encoding diagrams&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#quick-comparison-of-5-arduino-ir-receiving-libraries&#34;&gt;Quick comparison of 5 Arduino IR receiving libraries&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#useful-links&#34;&gt;Useful links&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/Contributors.md&#34;&gt;Contributors&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#copyright&#34;&gt;Copyright&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Supported IR Protocols&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;NEC / Onkyo / Apple&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Denon / Sharp&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Panasonic / Kaseikyo&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;JVC&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;LG&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;RC5&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;RC6&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Samsung&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Sony&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;Universal Pulse Distance&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Universal Pulse Width&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Hash&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Pronto&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;BoseWave&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Bang &amp;amp; Olufsen&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Lego&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Whynter&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;MagiQuest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Protocols can be switched off and on by defining macros before the line &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt; like &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/examples/SimpleReceiver/SimpleReceiver.ino#L33&#34;&gt;here&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define DECODE_NEC&#xA;//#define DECODE_DENON&#xA;#include &amp;lt;IRremote.hpp&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lots of tutorials and examples.&lt;/li&gt; &#xA; &lt;li&gt;Actively maintained.&lt;/li&gt; &#xA; &lt;li&gt;Allows receiving and sending of &lt;strong&gt;raw timing data&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;New features with version 4.x&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;New universal &lt;strong&gt;Pulse Distance / Pulse Width decoder&lt;/strong&gt; added, which covers many previous unknown protocols.&lt;/li&gt; &#xA; &lt;li&gt;Printout of code how to send received command by &lt;code&gt;IrReceiver.printIRSendUsage(&amp;amp;Serial)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;RawData type is now 64 bit for 32 bit platforms and therefore contains complete frame information for more protocols.&lt;/li&gt; &#xA; &lt;li&gt;Callback after receiving a command - call your own code if a message was received.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Converting your 3.x program to the 4.x version&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;You must replace &lt;code&gt;#define DECODE_DISTANCE_WIDTH&lt;/code&gt; by &lt;code&gt;#define DECODE_DISTANCE_WIDTH&lt;/code&gt; (only if you explicitly enabled this decoder).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;New features with version 3.x&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Any pin&lt;/strong&gt; can be used for sending -if &lt;code&gt;SEND_PWM_BY_TIMER&lt;/code&gt; is not defined- and receiving.&lt;/li&gt; &#xA; &lt;li&gt;Feedback LED can be activated for sending / receiving.&lt;/li&gt; &#xA; &lt;li&gt;An 8/16 bit **&lt;strong&gt;command&lt;/strong&gt; value as well as an 16 bit &lt;strong&gt;address&lt;/strong&gt; and a protocol number is provided for decoding (instead of the old 32 bit value).&lt;/li&gt; &#xA; &lt;li&gt;Protocol values comply to &lt;strong&gt;protocol standards&lt;/strong&gt;.&lt;br&gt; NEC, Panasonic, Sony, Samsung and JVC decode &amp;amp; send LSB first.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;strong&gt;Universal Distance protocol&lt;/strong&gt;, which covers a lot of previous unknown protocols.&lt;/li&gt; &#xA; &lt;li&gt;Compatible with &lt;strong&gt;tone()&lt;/strong&gt; library. See the &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/21b5747a58e9d47c9e3f1beb056d58c875a92b47/examples/ReceiveDemo/ReceiveDemo.ino#L159-L169&#34;&gt;ReceiveDemo&lt;/a&gt; example.&lt;/li&gt; &#xA; &lt;li&gt;Simultaneous sending and receiving. See the &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/examples/SendAndReceive/SendAndReceive.ino#L167-L170&#34;&gt;SendAndReceive&lt;/a&gt; example.&lt;/li&gt; &#xA; &lt;li&gt;Supports &lt;strong&gt;more platforms&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Allows for the generation of non PWM signal to just &lt;strong&gt;simulate an active low receiver signal&lt;/strong&gt; for direct connect to existent receiving devices without using IR.&lt;/li&gt; &#xA; &lt;li&gt;Easy protocol configuration, &lt;strong&gt;directly in your &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/examples/SimpleReceiver/SimpleReceiver.ino#L33-L57&#34;&gt;source code&lt;/a&gt;&lt;/strong&gt;.&lt;br&gt; Reduces memory footprint and decreases decoding time.&lt;/li&gt; &#xA; &lt;li&gt;Contains a &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#minimal-nec-receiver&#34;&gt;very small NEC only decoder&lt;/a&gt;, which &lt;strong&gt;does not require any timer resource&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#quick-comparison-of-5-arduino-ir-receiving-libraries&#34;&gt;-&amp;gt; Feature comparison of 5 Arduino IR libraries&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Converting your 2.x program to the 3.x version&lt;/h1&gt; &#xA;&lt;p&gt;Starting with the 3.1 version, &lt;strong&gt;the generation of PWM for sending is done by software&lt;/strong&gt;, thus saving the hardware timer and &lt;strong&gt;enabling arbitrary output pins for sending&lt;/strong&gt;.&lt;br&gt; If you use an (old) Arduino core that does not use the &lt;code&gt;-flto&lt;/code&gt; flag for compile, you can activate the line &lt;code&gt;#define SUPPRESS_ERROR_MESSAGE_FOR_BEGIN&lt;/code&gt; in IRRemote.h, if you get false error messages regarding begin() during compilation.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;IRreceiver&lt;/strong&gt; and &lt;strong&gt;IRsender&lt;/strong&gt; object have been added and can be used without defining them, like the well known Arduino &lt;strong&gt;Serial&lt;/strong&gt; object.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Just remove the line &lt;code&gt;IRrecv IrReceiver(IR_RECEIVE_PIN);&lt;/code&gt; and/or &lt;code&gt;IRsend IrSender;&lt;/code&gt; in your program, and replace all occurrences of &lt;code&gt;IRrecv.&lt;/code&gt; or &lt;code&gt;irrecv.&lt;/code&gt; with &lt;code&gt;IrReceiver&lt;/code&gt; and replace all &lt;code&gt;IRsend&lt;/code&gt; or &lt;code&gt;irsend&lt;/code&gt; with &lt;code&gt;IrSender&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Since the decoded values are now in &lt;code&gt;IrReceiver.decodedIRData&lt;/code&gt; and not in &lt;code&gt;results&lt;/code&gt; any more, remove the line &lt;code&gt;decode_results results&lt;/code&gt; or similar.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Like for the Serial object, call &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/examples/ReceiveDemo/ReceiveDemo.ino#L106&#34;&gt;&lt;code&gt;IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;IrReceiver.begin(IR_RECEIVE_PIN, DISABLE_LED_FEEDBACK)&lt;/code&gt; instead of the &lt;code&gt;IrReceiver.enableIRIn()&lt;/code&gt; or &lt;code&gt;irrecv.enableIRIn()&lt;/code&gt; in setup().&lt;br&gt; For sending, call &lt;code&gt;IrSender.begin(ENABLE_LED_FEEDBACK);&lt;/code&gt; or &lt;code&gt;IrSender.begin(DISABLE_LED_FEEDBACK);&lt;/code&gt; in setup().&lt;br&gt; If IR_SEND_PIN is not defined you must use e.g. &lt;code&gt;IrSender.begin(3, ENABLE_LED_FEEDBACK, USE_DEFAULT_FEEDBACK_LED_PIN);&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Old &lt;code&gt;decode(decode_results *aResults)&lt;/code&gt; function is replaced by simple &lt;code&gt;decode()&lt;/code&gt;. So if you have a statement &lt;code&gt;if(irrecv.decode(&amp;amp;results))&lt;/code&gt; replace it with &lt;code&gt;if (IrReceiver.decode())&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The decoded result is now in in &lt;code&gt;IrReceiver.decodedIRData&lt;/code&gt; and not in &lt;code&gt;results&lt;/code&gt; any more, therefore replace any occurrences of &lt;code&gt;results.value&lt;/code&gt; and &lt;code&gt;results.decode_type&lt;/code&gt; (and similar) to &lt;code&gt;IrReceiver.decodedIRData.decodedRawData&lt;/code&gt; and &lt;code&gt;IrReceiver.decodedIRData.protocol&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Overflow, Repeat and other flags are now in &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/IRremoteInt.h#L164-L187&#34;&gt;&lt;code&gt;IrReceiver.receivedIRData.flags&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Seldom used: &lt;code&gt;results.rawbuf&lt;/code&gt; and &lt;code&gt;results.rawlen&lt;/code&gt; must be replaced by &lt;code&gt;IrReceiver.decodedIRData.rawDataPtr-&amp;gt;rawbuf&lt;/code&gt; and &lt;code&gt;IrReceiver.decodedIRData.rawDataPtr-&amp;gt;rawlen&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The 5 protocols &lt;strong&gt;NEC, Panasonic, Sony, Samsung and JVC&lt;/strong&gt; have been converted to LSB first. Send functions for sending old MSB data for &lt;strong&gt;NEC&lt;/strong&gt; and &lt;strong&gt;JVC&lt;/strong&gt; were renamed to &lt;code&gt;sendNECMSB&lt;/code&gt;, and &lt;code&gt;sendJVCMSB()&lt;/code&gt;. The old &lt;code&gt;sendSAMSUNG()&lt;/code&gt; and &lt;code&gt;sendSony()&lt;/code&gt; MSB functions are still available. The old MSB version of &lt;code&gt;sendPanasonic()&lt;/code&gt; function was deleted, since it had bugs nobody recognized.&lt;br&gt; For converting MSB codes to LSB see &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#how-to-convert-old-msb-first-32-bit-ir-data-codes-to-new-lsb-first-32-bit-ir-data-codes&#34;&gt;below&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;h4&gt;2.x program:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;IRremote.h&amp;gt;&#xA;&#xA;IRrecv irrecv(RECV_PIN);&#xA;decode_results results;&#xA;&#xA;void setup()&#xA;{&#xA;...&#xA;  irrecv.enableIRIn(); // Start the receiver&#xA;}&#xA;&#xA;void loop() {&#xA;  if (irrecv.decode(&amp;amp;results)) {&#xA;      Serial.println(results.value, HEX);&#xA;      ...&#xA;      irrecv.resume(); // Receive the next value&#xA;  }&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3.x program:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;IRremote.hpp&amp;gt;&#xA;&#xA;void setup()&#xA;{&#xA;...&#xA;  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK); // Start the receiver&#xA;}&#xA;&#xA;void loop() {&#xA;  if (IrReceiver.decode()) {&#xA;      Serial.println(IrReceiver.decodedIRData.decodedRawData, HEX);&#xA;      IrReceiver.printIRResultShort(&amp;amp;Serial); // optional use new print version&#xA;      ...&#xA;      IrReceiver.resume(); // Enable receiving of the next value&#xA;  }&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to convert old MSB first 32 bit IR data codes to new LSB first 32 bit IR data codes&lt;/h2&gt; &#xA;&lt;p&gt;For the new decoders for &lt;strong&gt;NEC, Panasonic, Sony, Samsung and JVC&lt;/strong&gt;, the result &lt;code&gt;IrReceiver.decodedIRData.decodedRawData&lt;/code&gt; is now &lt;strong&gt;LSB-first&lt;/strong&gt;, as the definition of these protocols suggests!&lt;br&gt; &lt;br&gt; To convert one into the other, you must reverse the byte/nibble positions and then reverse all bit positions of each byte/nibble or write it as one binary string and reverse/mirror it.&lt;br&gt;&lt;br&gt; Example: &lt;code&gt;0xCB 34 01 02&lt;/code&gt;&lt;br&gt; &lt;code&gt;0x20 10 43 BC&lt;/code&gt; after nibble reverse&lt;br&gt; &lt;code&gt;0x40 80 2C D3&lt;/code&gt; after bit reverse of each nibble&lt;br&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Nibble reverse map:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt; 0-&amp;gt;0   1-&amp;gt;8   2-&amp;gt;4   3-&amp;gt;C&#xA; 4-&amp;gt;2   5-&amp;gt;A   6-&amp;gt;6   7-&amp;gt;E&#xA; 8-&amp;gt;1   9-&amp;gt;9   A-&amp;gt;5   B-&amp;gt;D&#xA; C-&amp;gt;3   D-&amp;gt;B   E-&amp;gt;7   F-&amp;gt;F&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;0xCB340102&lt;/code&gt; is binary &lt;code&gt;1100 1011 0011 0100 0000 0001 0000 0010&lt;/code&gt;.&lt;br&gt; &lt;code&gt;0x40802CD3&lt;/code&gt; is binary &lt;code&gt;0100 0000 1000 0000 0010 1100 1101 0011&lt;/code&gt;.&lt;br&gt; If you &lt;strong&gt;read the first binary sequence backwards&lt;/strong&gt; (right to left), you get the second sequence.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Errors with using the 3.x versions for old tutorials&lt;/h1&gt; &#xA;&lt;p&gt;If you suffer from errors with old tutorial code including &lt;code&gt;IRremote.h&lt;/code&gt; instead of &lt;code&gt;IRremote.hpp&lt;/code&gt;, just try to rollback to &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/releases/tag/v2.4.0&#34;&gt;Version 2.4.0&lt;/a&gt;.&lt;br&gt; Most likely your code will run and you will not miss the new features...&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Staying on 2.x&lt;/h2&gt; &#xA;&lt;p&gt;Consider using the &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/releases/tag/v2.4.0&#34;&gt;original 2.4 release form 2017&lt;/a&gt; or the last backwards compatible &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/releases/tag/2.8.0&#34;&gt;2.8 version&lt;/a&gt; for you project.&lt;br&gt; It may be sufficient and deals flawlessly with 32 bit IR codes.&lt;br&gt; If this doesn&#39;t fit your case, be assured that 3.x is at least trying to be backwards compatible, so your old examples should still work fine.&lt;/p&gt; &#xA;&lt;h3&gt;Drawbacks&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Only the following decoders are available:&lt;br&gt; &lt;code&gt;NEC&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Denon&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Panasonic&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;JVC&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;LG&lt;/code&gt;&lt;br&gt; &lt;code&gt;RC5&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;RC6&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Samsung&lt;/code&gt; &amp;nbsp; &amp;nbsp; &lt;code&gt;Sony&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The call of &lt;code&gt;irrecv.decode(&amp;amp;results)&lt;/code&gt; uses the old MSB first decoders like in 2.x and sets the 32 bit codes in &lt;code&gt;results.value&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The old functions &lt;code&gt;sendNEC()&lt;/code&gt; and &lt;code&gt;sendJVC()&lt;/code&gt; are renamed to &lt;code&gt;sendNECMSB()&lt;/code&gt; and &lt;code&gt;sendJVCMSB()&lt;/code&gt;.&lt;br&gt; Use them to send your &lt;strong&gt;old MSB-first 32 bit IR data codes&lt;/strong&gt;.&lt;/li&gt; &#xA; &lt;li&gt;No decoding by a (constant) 8/16 bit address and an 8 bit command.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Why *.hpp instead of *.cpp?&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Every *.cpp file is compiled separately&lt;/strong&gt; by a call of the compiler exclusively for this cpp file. These calls are managed by the IDE / make system. In the Arduino IDE the calls are executed when you click on &lt;em&gt;Verify&lt;/em&gt; or &lt;em&gt;Upload&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;And now our problem with Arduino is:&lt;br&gt; &lt;strong&gt;How to set &lt;a href=&#34;https://raw.githubusercontent.com/Arduino-IRremote/Arduino-IRremote/master/#compile-options--macros-for-this-library&#34;&gt;compile options&lt;/a&gt; for all *.cpp files, especially for libraries used?&lt;/strong&gt;&lt;br&gt; IDE&#39;s like &lt;a href=&#34;https://github.com/ArminJo/ServoEasing#modifying-compile-options--macros-with-sloeber-ide&#34;&gt;Sloeber&lt;/a&gt; or &lt;a href=&#34;https://github.com/ArminJo/ServoEasing#modifying-compile-options--macros-with-platformio&#34;&gt;PlatformIO&lt;/a&gt; support this by allowing to specify a set of options per project. They add these options at each compiler call e.g. &lt;code&gt;-DTRACE&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But Arduino lacks this feature. So the &lt;strong&gt;workaround&lt;/strong&gt; is not to compile all sources separately, but to concatenate them to one huge source file by including them in your source.&lt;br&gt; This is done by e.g. &lt;code&gt;#include &#34;IRremote.hpp&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But why not &lt;code&gt;#include &#34;IRremote.cpp&#34;&lt;/code&gt;?&lt;br&gt; Try it and you will see tons of errors, because each function of the *.cpp file is now compiled twice, first by compiling the huge file and second by compiling the *.cpp file separately, like described above.&lt;br&gt; So using the extension &lt;em&gt;cpp&lt;/em&gt; is not longer possible, and one solution is to use &lt;em&gt;hpp&lt;/em&gt; as extension, to show that it is an included *.cpp file.&lt;br&gt; Every other extension e.g. &lt;em&gt;cinclude&lt;/em&gt; would do, but &lt;em&gt;hpp&lt;/em&gt; seems to be common sense.&lt;/p&gt; &#xA;&lt;h1&gt;Using the new *.hpp files&lt;/h1&gt; &#xA;&lt;p&gt;In order to support &lt;a href=&#34;https://raw.githubusercontent.com/Arduino-IRremote/Arduino-IRremote/master/#compile-options--macros-for-this-library&#34;&gt;compile options&lt;/a&gt; more easily, you must use the statement &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt; instead of &lt;code&gt;#include &amp;lt;IRremote.h&amp;gt;&lt;/code&gt; in your main program (aka *.ino file with setup() and loop()).&lt;/p&gt; &#xA;&lt;p&gt;In &lt;strong&gt;all other files&lt;/strong&gt; you must use the following, to &lt;strong&gt;prevent &lt;code&gt;multiple definitions&lt;/code&gt; linker errors&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define USE_IRREMOTE_HPP_AS_PLAIN_INCLUDE&#xA;#include &amp;lt;IRremote.hpp&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ensure that all macros in your main program are defined before any&lt;/strong&gt; &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt;. &lt;br&gt; The following macros will definitely be overridden with default values otherwise:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;RAW_BUFFER_LENGTH&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IR_SEND_PIN&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SEND_PWM_BY_TIMER&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Receiving IR codes&lt;/h1&gt; &#xA;&lt;p&gt;Check for &lt;strong&gt;received data&lt;/strong&gt; with:&lt;br&gt; &lt;code&gt;if (IrReceiver.decode()) {}&lt;/code&gt;&lt;br&gt; This also decodes the received data.&lt;/p&gt; &#xA;&lt;h2&gt;Data format&lt;/h2&gt; &#xA;&lt;p&gt;After successful decoding, the IR data is contained in the IRData structure, available as &lt;code&gt;IrReceiver.decodedIRData&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct IRData {&#xA;    decode_type_t protocol;     // UNKNOWN, NEC, SONY, RC5, PULSE_DISTANCE, ...&#xA;    uint16_t address;           // Decoded address&#xA;    uint16_t command;           // Decoded command&#xA;    uint16_t extra;             // Used for Kaseikyo unknown vendor ID. Ticks used for decoding Distance protocol.&#xA;    uint16_t numberOfBits;      // Number of bits received for data (address + command + parity) - to determine protocol length if different length are possible.&#xA;    uint8_t flags;              // See IRDATA_FLAGS_* definitions&#xA;    uint32_t decodedRawData;    // Up to 32 bit decoded raw data, used for sendRaw functions.&#xA;    uint32_t decodedRawDataArray[RAW_DATA_ARRAY_SIZE]; // 32 bit decoded raw data, to be used for send function.&#xA;    irparams_struct *rawDataPtr; // Pointer of the raw timing data to be decoded. Mainly the data buffer filled by receiving ISR.&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;To access the &lt;strong&gt;RAW data&lt;/strong&gt;, use:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;uint32_t myRawdata= IrReceiver.decodedIRData.decodedRawData;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The definitions for the &lt;code&gt;IrReceiver.decodedIRData.flags&lt;/code&gt; are described &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/IRremoteInt.h#L128-L140&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Print all fields:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;IrReceiver.printIRResultShort(&amp;amp;Serial);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Print the raw timing data received:&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;IrReceiver.printIRResultRawFormatted(&amp;amp;Serial, true);`&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Minimal NEC receiver&lt;/h1&gt; &#xA;&lt;p&gt;For applications only requiring NEC protocol, there is a special receiver included,&lt;br&gt; which has very &lt;strong&gt;small code size of 500 bytes and does NOT require any timer&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#minimalreceiver&#34;&gt;MinimalReceiver&lt;/a&gt; and &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#irdispatcherdemo&#34;&gt;IRDispatcherDemo&lt;/a&gt; examples.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Sending IR codes&lt;/h1&gt; &#xA;&lt;p&gt;If you have a device at hand which can generate the IR codes you want to work with (aka IR remote), &lt;strong&gt;it is recommended&lt;/strong&gt; to receive the codes with the &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/examples/ReceiveDemo/ReceiveDemo.ino&#34;&gt;ReceiveDemo example&lt;/a&gt;, which will tell you on the serial output how to send them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Protocol=LG Address=0x2 Command=0x3434 Raw-Data=0x23434E 28 bits MSB first&#xA;Send with: IrSender.sendLG(0x2, 0x3434, &amp;lt;numberOfRepeats&amp;gt;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You will discover that &lt;strong&gt;the address is a constant&lt;/strong&gt; and the commands sometimes are sensibly grouped.&lt;br&gt; If you are uncertain about the numbers of repeats to use for sending, &lt;strong&gt;3&lt;/strong&gt; is a good starting point. If this works, you can check lower values afterwards.&lt;/p&gt; &#xA;&lt;p&gt;The codes found in the &lt;a href=&#34;https://github.com/probonopd/irdb/tree/master/codes&#34;&gt;irdb database&lt;/a&gt; specify a &lt;strong&gt;device&lt;/strong&gt;, a &lt;strong&gt;subdevice&lt;/strong&gt; and a &lt;strong&gt;function&lt;/strong&gt;. Most of the times, &lt;em&gt;device&lt;/em&gt; and &lt;em&gt;subdevice&lt;/em&gt; can be taken as upper and lower byte of the &lt;strong&gt;address parameter&lt;/strong&gt; and &lt;em&gt;function&lt;/em&gt; is the &lt;strong&gt;command parameter&lt;/strong&gt; for the &lt;strong&gt;new structured functions&lt;/strong&gt; with address, command and repeat-count parameters like e.g. &lt;code&gt;IrSender.sendNEC((device &amp;lt;&amp;lt; 8) | subdevice, 0x19, 2)&lt;/code&gt;.&lt;br&gt; An &lt;strong&gt;exact mapping&lt;/strong&gt; can be found in the &lt;a href=&#34;https://github.com/probonopd/MakeHex/tree/master/protocols&#34;&gt;IRP definition files for IR protocols&lt;/a&gt;. &#34;D&#34; and &#34;S&#34; denotes device and subdevice and &#34;F&#34; denotes the function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;All sending functions support the sending of repeats&lt;/strong&gt; if sensible. Repeat frames are sent at a fixed period determined by the protocol. e.g. 110 ms from start to start for NEC.&lt;br&gt; Keep in mind, that &lt;strong&gt;there is no delay after the last sent mark&lt;/strong&gt;. If you handle the sending of repeat frames by your own, you must insert sensible delays before the repeat frames to enable correct decoding.&lt;/p&gt; &#xA;&lt;p&gt;The old send*Raw() functions for sending like e.g. &lt;code&gt;IrSender.sendNECRaw(0xE61957A8,2)&lt;/code&gt; are kept for backward compatibility to &lt;strong&gt;(old)&lt;/strong&gt; tutorials and unsupported as well as error prone.&lt;/p&gt; &#xA;&lt;h3&gt;List of public IR code databases&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://www.harctoolbox.org/IR-resources.html&#34;&gt;http://www.harctoolbox.org/IR-resources.html&lt;/a&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;FAQ and hints&lt;/h1&gt; &#xA;&lt;h2&gt;Problems with Neopixels, FastLed etc.&lt;/h2&gt; &#xA;&lt;p&gt;IRremote will not work right when you use &lt;strong&gt;Neopixels&lt;/strong&gt; (aka WS2811/WS2812/WS2812B) or other libraries blocking interrupts for a longer time (&amp;gt; 50 µs).&lt;br&gt; Whether you use the Adafruit Neopixel lib, or FastLED, interrupts get disabled on many lower end CPUs like the basic Arduinos for longer than 50 µs. In turn, this stops the IR interrupt handler from running when it needs to.&lt;/p&gt; &#xA;&lt;p&gt;One &lt;strong&gt;workaround&lt;/strong&gt; is to wait for the IR receiver to be idle before you send the Neopixel data with &lt;code&gt;if (IrReceiver.isIdle()) { strip.show();}&lt;/code&gt;.&lt;br&gt; This &lt;strong&gt;prevents at least breaking a running IR transmission&lt;/strong&gt; and -depending of the update rate of the Neopixel- may work quite well.&lt;br&gt; There are some other solutions to this on more powerful processors, &lt;a href=&#34;http://marc.merlins.org/perso/arduino/post_2017-04-03_Arduino-328P-Uno-Teensy3_1-ESP8266-ESP32-IR-and-Neopixels.html&#34;&gt;see this page from Marc MERLIN&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Does not work/compile with another library&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Another library is only working/compiling&lt;/strong&gt; if you deactivate the line &lt;code&gt;IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);&lt;/code&gt;.&lt;br&gt; This is often due to &lt;strong&gt;timer resource conflicts&lt;/strong&gt; with the other library. Please see &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#timer-and-pin-usage&#34;&gt;below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Multiple IR receivers&lt;/h2&gt; &#xA;&lt;p&gt;You can use &lt;strong&gt;multiple IR receiver&lt;/strong&gt; by just connecting the output pins of several IR receivers together. The IR receivers use an NPN transistor as output device with just a 30k resistor to VCC. This is almost &#34;open collector&#34; and allows connecting of several output pins to one Arduino input pin.&lt;/p&gt; &#xA;&lt;h2&gt;Increase strength of sent output signal&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;The best way to increase the IR power for free&lt;/strong&gt; is to use 2 or 3 IR diodes in series. One diode requires 1.2 volt at 20 mA or 1.5 volt at 100 mA so you can supply up to 3 diodes with a 5 volt output.&lt;br&gt; To power &lt;strong&gt;2 diodes&lt;/strong&gt; with 1.2 V and 20 mA and a 5 V supply, set the resistor to: (5 V - 2.4 V) -&amp;gt; 2.6 V / 20 mA = &lt;strong&gt;130 Ω&lt;/strong&gt;.&lt;br&gt; For &lt;strong&gt;3 diodes&lt;/strong&gt; it requires 1.4 V / 20 mA = &lt;strong&gt;70 Ω&lt;/strong&gt;.&lt;br&gt; The actual current might be lower since of &lt;strong&gt;loss at the AVR pin&lt;/strong&gt;. E.g. 0.3 V at 20 mA.&lt;br&gt; If you do not require more current than 20 mA, there is no need to use an external transistor (at least for AVR chips).&lt;/p&gt; &#xA;&lt;p&gt;On my Arduino Nanos, I always use a 100 Ω series resistor and one IR LED &lt;span&gt;😀&lt;/span&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Minimal CPU frequency&lt;/h2&gt; &#xA;&lt;p&gt;For receiving, the &lt;strong&gt;minimal CPU frequency is 4 MHz&lt;/strong&gt;, since the 50 µs timer ISR (Interrupt Service Routine) takes around 12 µs on a 16 MHz ATmega.&lt;br&gt; For sending, the &lt;strong&gt;default software generated PWM has problems on AVR running with 8 MHz&lt;/strong&gt;. The PWM frequency is around 30 instead of 38 kHz and RC6 is not reliable. You can switch to timer PWM generation by &lt;code&gt;#define SEND_PWM_BY_TIMER&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Bang &amp;amp; Olufsen protocol&lt;/h2&gt; &#xA;&lt;p&gt;The Bang &amp;amp; Olufsen protocol decoder is not enabled by default, i.e if no protocol is enabled explicitly by #define &lt;code&gt;DECODE_&amp;lt;XYZ&amp;gt;&lt;/code&gt;. It must always be enabled explicitly by &lt;code&gt;#define DECODE_BEO&lt;/code&gt;. This is because it has an &lt;strong&gt;IR transmit frequency of 455 kHz&lt;/strong&gt; and therefore requires a different receiver hardware (TSOP7000).&lt;br&gt; And because &lt;strong&gt;generating a 455 kHz PWM signal is currently not implemented&lt;/strong&gt;, sending only works if &lt;code&gt;USE_NO_SEND_PWM&lt;/code&gt; is defined!&lt;br&gt; For more info, see &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/ir_BangOlufsen.hpp#L42&#34;&gt;ir_BangOlufsen.hpp&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Handling unknown Protocols&lt;/h1&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;This library was designed to fit inside MCUs with relatively low levels of resources and was intended to work as a library together with other applications which also require some resources of the MCU to operate.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;For &lt;strong&gt;air conditioners&lt;/strong&gt; &lt;a href=&#34;https://github.com/crankyoldgit/IRremoteESP8266&#34;&gt;see this fork&lt;/a&gt;, which supports an impressive set of protocols and a lot of air conditioners.&lt;/p&gt; &#xA;&lt;p&gt;For &lt;strong&gt;long signals&lt;/strong&gt; see the blog entry: &lt;a href=&#34;https://www.analysir.com/blog/2014/03/19/air-conditioners-problems-recording-long-infrared-remote-control-signals-arduino&#34;&gt;&#34;Recording long Infrared Remote control signals with Arduino&#34;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Protocol=PULSE_DISTANCE&lt;/h2&gt; &#xA;&lt;p&gt;If you get something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;PULSE_DISTANCE: HeaderMarkMicros=8900 HeaderSpaceMicros=4450 MarkMicros=550 OneSpaceMicros=1700 ZeroSpaceMicros=600  NumberOfBits=56 0x43D8613C 0x3BC3BC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then you have a code consisting of &lt;strong&gt;56 bits&lt;/strong&gt;, which is probably from an air conditioner remote.&lt;br&gt; You can send it with sendPulseDistance().&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;uint32_t tRawData[] = { 0xB02002, 0xA010 };&#xA;IrSender.sendPulseDistance(38, 3450, 1700, 450, 1250, 450, 400, &amp;amp;tRawData[0], 48, false, 0, 0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can send it with calling sendPulseDistanceWidthData() twice, once for the first 32 bit and next for the remaining 24 bits.&lt;br&gt; &lt;strong&gt;The PulseDistance or PulseWidth decoders just decode a timing steam to a bit stream&lt;/strong&gt;. They can not put any semantics like address, command or checksum on this bitstream, since it is no known protocol. But the bitstream is way more readable, than a timing stream. This bitstream is read &lt;strong&gt;LSB first by default&lt;/strong&gt;. If this does not suit you for further research, you can change it &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/ir_DistanceProtocol.hpp#L48&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Protocol=UNKNOWN&lt;/h2&gt; &#xA;&lt;p&gt;If you see something like &lt;code&gt;Protocol=UNKNOWN Hash=0x13BD886C 35 bits received&lt;/code&gt; as output of e.g. the ReceiveDemo example, you either have a problem with decoding a protocol, or an unsupported protocol.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you have an &lt;strong&gt;odd number of bits&lt;/strong&gt; received, it is likely, that your receiver circuit has problems. Maybe because the IR signal is too weak.&lt;/li&gt; &#xA; &lt;li&gt;If you see timings like &lt;code&gt;+ 600,- 600 + 550,- 150 + 200,- 100 + 750,- 550&lt;/code&gt; then one 450 µs space was split into two 150 and 100 µs spaces with a spike / error signal of 200 µs between. Maybe because of a defective receiver or a weak signal in conjunction with another light emitting source nearby.&lt;/li&gt; &#xA; &lt;li&gt;If you see timings like &lt;code&gt;+ 500,- 550 + 450,- 550 + 500,- 500 + 500,-1550&lt;/code&gt;, then marks are generally shorter than spaces and therefore &lt;code&gt;MARK_EXCESS_MICROS&lt;/code&gt; (specified in your ino file) should be &lt;strong&gt;negative&lt;/strong&gt; to compensate for this at decoding.&lt;/li&gt; &#xA; &lt;li&gt;If you see &lt;code&gt;Protocol=UNKNOWN Hash=0x0 1 bits received&lt;/code&gt; it may be that the space after the initial mark is longer than &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/IRremote.h#L124&#34;&gt;&lt;code&gt;RECORD_GAP_MICROS&lt;/code&gt;&lt;/a&gt;. This was observed for some LG air conditioner protocols. Try again with a line e.g. &lt;code&gt;#define RECORD_GAP_MICROS 12000&lt;/code&gt; before the line &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt; in your .ino file.&lt;/li&gt; &#xA; &lt;li&gt;To see more info supporting you to find the reason for your UNKNOWN protocol, you must enable the line &lt;code&gt;//#define DEBUG&lt;/code&gt; in IRremoteInt.h.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to deal with protocols not supported by IRremote&lt;/h2&gt; &#xA;&lt;p&gt;If you do not know which protocol your IR transmitter uses, you have several choices.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use the &lt;a href=&#34;https://raw.githubusercontent.com/Arduino-IRremote/Arduino-IRremote/master/examples/ReceiveDump&#34;&gt;IRreceiveDump example&lt;/a&gt; to dump out the IR timing. You can then reproduce/send this timing with the &lt;a href=&#34;https://raw.githubusercontent.com/Arduino-IRremote/Arduino-IRremote/master/examples/SendRawDemo&#34;&gt;SendRawDemo example&lt;/a&gt;. For &lt;strong&gt;long codes&lt;/strong&gt; with more than 48 bits like from air conditioners, you can &lt;strong&gt;change the length of the input buffer&lt;/strong&gt; in &lt;a href=&#34;https://raw.githubusercontent.com/Arduino-IRremote/Arduino-IRremote/master/src/IRremoteInt.h#L36&#34;&gt;IRremote.h&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://github.com/IRMP-org/IRMP#allprotocol-example&#34;&gt;IRMP AllProtocol example&lt;/a&gt; prints the protocol and data for one of the &lt;strong&gt;40 supported protocols&lt;/strong&gt;. The same library can be used to send this codes.&lt;/li&gt; &#xA; &lt;li&gt;If you have a bigger Arduino board at hand (&amp;gt; 100 kByte program memory) you can try the &lt;a href=&#34;https://github.com/bengtmartensson/Arduino-DecodeIR/raw/master/examples/IRremoteDecode/IRremoteDecode.ino&#34;&gt;IRremoteDecode example&lt;/a&gt; of the Arduino library &lt;a href=&#34;https://github.com/bengtmartensson/Arduino-DecodeIR&#34;&gt;DecodeIR&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;http://www.harctoolbox.org/IrScrutinizer.html&#34;&gt;IrScrutinizer&lt;/a&gt;. It can automatically generate a send sketch for your protocol by exporting as &#34;Arduino Raw&#34;. It supports IRremote, the old &lt;a href=&#34;https://github.com/cyborg5/IRLib&#34;&gt;IRLib&lt;/a&gt; and &lt;a href=&#34;https://github.com/bengtmartensson/Infrared4Arduino&#34;&gt;Infrared4Arduino&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Examples for this library&lt;/h1&gt; &#xA;&lt;p&gt;In order to fit the examples to the 8K flash of ATtiny85 and ATtiny88, the &lt;a href=&#34;https://github.com/ArminJo/ATtinySerialOut&#34;&gt;Arduino library ATtinySerialOut&lt;/a&gt; is required for this CPU&#39;s.&lt;/p&gt; &#xA;&lt;h4&gt;SimpleReceiver + SimpleSender&lt;/h4&gt; &#xA;&lt;p&gt;This examples are a good starting point. A simple example can be tested online with &lt;a href=&#34;https://wokwi.com/projects/338611596994544210&#34;&gt;WOKWI&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;MinimalReceiver + MinimalSender&lt;/h4&gt; &#xA;&lt;p&gt;If &lt;strong&gt;code size&lt;/strong&gt; matters, look at these examples.&lt;br&gt; The &lt;strong&gt;MinimalReceiver&lt;/strong&gt; example uses the &lt;strong&gt;TinyReceiver&lt;/strong&gt; library which can &lt;strong&gt;only receive NEC and FAST codes, but does not require any timer&lt;/strong&gt;.&lt;br&gt; MinimalReceiver can be tested online with &lt;a href=&#34;https://wokwi.com/arduino/projects/339264565653013075&#34;&gt;WOKWI&lt;/a&gt;. Click on the receiver while simulation is running to specify individual IR codes.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;strong&gt;MinimalSender&lt;/strong&gt; example uses the &lt;strong&gt;TinySender&lt;/strong&gt; library which can &lt;strong&gt;only send NEC and FAST codes&lt;/strong&gt;.&lt;br&gt; Sending NEC protocol codes in standard format with 8 bit address and 8 bit command as in SimpleSender example. Saves 780 bytes program memory and 26 bytes RAM compared to SimpleSender, which does the same, but uses the IRRemote library (and is therefore much more flexible).&lt;/p&gt; &#xA;&lt;h4&gt;SmallReceiver&lt;/h4&gt; &#xA;&lt;p&gt;If the protocol is not NEC and code size matters, look at this example.&lt;br&gt;&lt;/p&gt; &#xA;&lt;h4&gt;ReceiveDemo + AllProtocolsOnLCD&lt;/h4&gt; &#xA;&lt;p&gt;Receives all protocols and &lt;strong&gt;generates a beep with the Arduino tone() function&lt;/strong&gt; on each packet received.&lt;br&gt; AllProtocolsOnLCD additionally &lt;strong&gt;displays the short result on a 1602 LCD&lt;/strong&gt;. The LCD can be connected parallel or serial (I2C).&lt;br&gt; By connecting pin debug pin to ground, you can see the raw values for each packet. The pin number of the debug pin is printed during setup, because it depends on board and LCD connection type.&lt;br&gt; This example also serves as an &lt;strong&gt;example how to use IRremote and tone() together&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;AllProtocolsOnLCD&lt;/h4&gt; &#xA;&lt;p&gt;Like ReceiveDemo but with 1604 LCD output and without tone().&lt;/p&gt; &#xA;&lt;h4&gt;ReceiveDump&lt;/h4&gt; &#xA;&lt;p&gt;Receives all protocols and dumps the received signal in different flavors. Since the printing takes so much time, repeat signals may be skipped or interpreted as UNKNOWN.&lt;/p&gt; &#xA;&lt;h4&gt;SendDemo&lt;/h4&gt; &#xA;&lt;p&gt;Sends all available protocols at least once.&lt;/p&gt; &#xA;&lt;h4&gt;SendAndReceive&lt;/h4&gt; &#xA;&lt;p&gt;Demonstrates &lt;strong&gt;receiving while sending&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;ReceiveAndSend&lt;/h4&gt; &#xA;&lt;p&gt;Record and &lt;strong&gt;play back last received IR signal&lt;/strong&gt; at button press.&lt;/p&gt; &#xA;&lt;h4&gt;ReceiveOneAndSendMultiple&lt;/h4&gt; &#xA;&lt;p&gt;Serves as a IR &lt;strong&gt;remote macro expander&lt;/strong&gt;. Receives Samsung32 protocol and on receiving a specified input frame, it sends multiple Samsung32 frames with appropriate delays in between. This serves as a &lt;strong&gt;Netflix-key emulation&lt;/strong&gt; for my old Samsung H5273 TV.&lt;/p&gt; &#xA;&lt;h4&gt;IRDispatcherDemo&lt;/h4&gt; &#xA;&lt;p&gt;Framework for &lt;strong&gt;calling different functions of your program&lt;/strong&gt; for different IR codes.&lt;/p&gt; &#xA;&lt;h4&gt;IRrelay&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Control a relay&lt;/strong&gt; (connected to an output pin) with your remote.&lt;/p&gt; &#xA;&lt;h4&gt;IRremoteExtensionTest&lt;/h4&gt; &#xA;&lt;p&gt;Example for a user defined class, which itself uses the IRrecv class from IRremote.&lt;/p&gt; &#xA;&lt;h4&gt;SendLGAirConditionerDemo&lt;/h4&gt; &#xA;&lt;p&gt;Example for sending LG air conditioner IR codes controlled by Serial input.&lt;br&gt; By just using the function &lt;code&gt;bool Aircondition_LG::sendCommandAndParameter(char aCommand, int aParameter)&lt;/code&gt; you can control the air conditioner by any other command source.&lt;br&gt; The file &lt;em&gt;acLG.h&lt;/em&gt; contains the command documentation of the LG air conditioner IR protocol. Based on reverse engineering of the LG AKB73315611 remote. &lt;img src=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/pictures/LG_AKB73315611.jpg&#34; alt=&#34;LG AKB73315611 remote&#34;&gt;&lt;br&gt; IReceiverTimingAnalysis can be tested online with &lt;a href=&#34;https://wokwi.com/projects/299033930562011656&#34;&gt;WOKWI&lt;/a&gt; Click on the receiver while simulation is running to specify individual IR codes.&lt;/p&gt; &#xA;&lt;h4&gt;ReceiverTimingAnalysis&lt;/h4&gt; &#xA;&lt;p&gt;This example analyzes the signal delivered by your IR receiver module. Values can be used to determine the stability of the received signal as well as a hint for determining the protocol.&lt;br&gt; It also computes the &lt;code&gt;MARK_EXCESS_MICROS&lt;/code&gt; value, which is the extension of the mark (pulse) duration introduced by the IR receiver module.&lt;br&gt; It can be tested online with &lt;a href=&#34;https://wokwi.com/arduino/projects/299033930562011656&#34;&gt;WOKWI&lt;/a&gt;. Click on the receiver while simulation is running to specify individual NEC IR codes.&lt;/p&gt; &#xA;&lt;h4&gt;UnitTest&lt;/h4&gt; &#xA;&lt;p&gt;ReceiveDemo + SendDemo in one program. Demonstrates &lt;strong&gt;receiving while sending&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;WOKWI online examples&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wokwi.com/projects/338611596994544210&#34;&gt;Simple receiver&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wokwi.com/arduino/projects/339264565653013075&#34;&gt;MinimalReceiver&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wokwi.com/projects/299033930562011656&#34;&gt;ReceiverTimingAnalysis&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wokwi.com/projects/298934082074575369&#34;&gt;Receiver with LCD output and switch statement&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Issues and discussions&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Do not open an issue without first testing some of the examples!&lt;/li&gt; &#xA; &lt;li&gt;If you have a problem, please post the MCVE (Minimal Complete Verifiable Example) showing this problem. My experience is, that most of the times you will find the problem while creating this MCVE &lt;span&gt;😄&lt;/span&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#code&#34;&gt;Use code blocks&lt;/a&gt;; &lt;strong&gt;it helps us help you when we can read your code!&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Compile options / macros for this library&lt;/h1&gt; &#xA;&lt;p&gt;To customize the library to different requirements, there are some compile options / macros available.&lt;br&gt; These macros must be defined in your program &lt;strong&gt;before&lt;/strong&gt; the line &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt; to take effect.&lt;br&gt; Modify them by enabling / disabling them, or change the values if applicable.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Default value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;RAW_BUFFER_LENGTH&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;100&lt;/td&gt; &#xA;   &lt;td&gt;Buffer size of raw input buffer. Must be even! 100 is sufficient for &lt;em&gt;regular&lt;/em&gt; protocols of up to 48 bits, but for most air conditioner protocols a value of up to 750 is required. Use the ReceiveDump example to find smallest value for your requirements.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;EXCLUDE_UNIVERSAL_PROTOCOLS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Excludes the universal decoder for pulse distance protocols and decodeHash (special decoder for all protocols) from &lt;code&gt;decode()&lt;/code&gt;. Saves up to 1000 bytes program memory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;DECODE_&amp;lt;Protocol name&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;all&lt;/td&gt; &#xA;   &lt;td&gt;Selection of individual protocol(s) to be decoded. You can specify multiple protocols. See &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/IRremote.hpp#L98-L121&#34;&gt;here&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;DECODE_STRICT_CHECKS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Check for additional characteristics of protocol timing like length of mark for a constant mark protocol, where space length determines the bit value. Requires up to 194 additional bytes of program memory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_REMOTE_DISABLE_RECEIVE_COMPLETE_CALLBACK&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Saves up to 60 bytes of program memory and 2 bytes RAM.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;MARK_EXCESS_MICROS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;20&lt;/td&gt; &#xA;   &lt;td&gt;MARK_EXCESS_MICROS is subtracted from all marks and added to all spaces before decoding, to compensate for the signal forming of different IR receiver modules.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;RECORD_GAP_MICROS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;5000&lt;/td&gt; &#xA;   &lt;td&gt;Minimum gap between IR transmissions, to detect the end of a protocol.&lt;br&gt;Must be greater than any space of a protocol e.g. the NEC header space of 4500 µs.&lt;br&gt;Must be smaller than any gap between a command and a repeat; e.g. the retransmission gap for Sony is around 24 ms.&lt;br&gt;Keep in mind, that this is the delay between the end of the received command and the start of decoding.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_INPUT_IS_ACTIVE_HIGH&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Enable it if you use a RF receiver, which has an active HIGH output signal.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_SEND_PIN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;If specified (as constant), reduces program size and improves send timing for AVR. If you want to use a runtime variable send pin e.g. with &lt;code&gt;setSendPin(uint8_t aSendPinNumber)&lt;/code&gt; , you must disable this macro.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;SEND_PWM_BY_TIMER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Disables carrier PWM generation in software and use hardware PWM (by timer). Has the advantage of more exact PWM generation, especially the duty cycle (which is not very relevant for most IR receiver circuits), and the disadvantage of using a hardware timer, which in turn is not available for other libraries and to fix the send pin (but not the receive pin) at the &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#timer-and-pin-usage&#34;&gt;dedicated timer output pin(s)&lt;/a&gt;. Is enabled for ESP32 and RP2040 in all examples, since they support PWM gereration for each pin without using a shared resource (timer).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;USE_NO_SEND_PWM&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Uses no carrier PWM, just simulate an &lt;strong&gt;active low&lt;/strong&gt; receiver signal. Overrides &lt;code&gt;SEND_PWM_BY_TIMER&lt;/code&gt; definition.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_SEND_DUTY_CYCLE_PERCENT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;30&lt;/td&gt; &#xA;   &lt;td&gt;Duty cycle of IR send signal.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;USE_OPEN_DRAIN_OUTPUT_FOR_SEND_PIN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Uses or simulates open drain output mode at send pin. &lt;strong&gt;Attention, active state of open drain is LOW&lt;/strong&gt;, so connect the send LED between positive supply and send pin!&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;DISABLE_CODE_FOR_RECEIVER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Saves up to 450 bytes program memory and 269 bytes RAM if receiving functionality is not required.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;EXCLUDE_EXOTIC_PROTOCOLS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Excludes BANG_OLUFSEN, BOSEWAVE, WHYNTER and LEGO_PF from &lt;code&gt;decode()&lt;/code&gt; and from sending with &lt;code&gt;IrSender.write()&lt;/code&gt;. Saves up to 650 bytes program memory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;FEEDBACK_LED_IS_ACTIVE_LOW&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Required on some boards (like my BluePill and my ESP8266 board), where the feedback LED is active low.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;NO_LED_FEEDBACK_CODE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Disables the LED feedback code for send and receive. Saves around 100 bytes program memory for receiving, around 500 bytes for sending and halving the receiver ISR (Interrupt Service Routine) processing time.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;MICROS_PER_TICK&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;50&lt;/td&gt; &#xA;   &lt;td&gt;Resolution of the raw input buffer data. Corresponds to 2 pulses of each 26.3 µs at 38 kHz.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;TOLERANCE_FOR_DECODERS_MARK_OR_SPACE_MATCHING&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;25&lt;/td&gt; &#xA;   &lt;td&gt;Relative tolerance (in percent) for matchTicks(), matchMark() and matchSpace() functions used for protocol decoding.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Enables lots of lovely debug output.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_USE_AVR_TIMER*&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Selection of timer to be used for generating IR receiving sample interval.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;These next macros for &lt;strong&gt;TinyIRReceiver&lt;/strong&gt; must be defined in your program before the line &lt;code&gt;#include &amp;lt;TinyIRReceiver.hpp&amp;gt;&lt;/code&gt; to take effect.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Default value&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_INPUT_PIN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;The pin number for TinyIRReceiver IR input, which gets compiled in.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;IR_FEEDBACK_LED_PIN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;code&gt;LED_BUILTIN&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The pin number for TinyIRReceiver feedback LED, which gets compiled in.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;NO_LED_FEEDBACK_CODE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Disables the feedback LED function. Saves 14 bytes program memory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;DISABLE_PARITY_CHECKS&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Disables the addres and command parity checks. Saves 48 bytes program memory.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;code&gt;USE_FAST_8_BIT_AND_PARITY_TIMING&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;disabled&lt;/td&gt; &#xA;   &lt;td&gt;Receives a special fast protocol instead of NEC.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The next macro for &lt;strong&gt;IRCommandDispatcher&lt;/strong&gt; must be defined in your program before the line &lt;code&gt;#include &amp;lt;IRCommandDispatcher.hpp&amp;gt;&lt;/code&gt; to take effect. | &lt;code&gt;IR_COMMAND_HAS_MORE_THAN_8_BIT&lt;/code&gt; | disabled | Enables mapping and dispatching of IR commands consisting of more than 8 bits. Saves up to 160 bytes program memory and 4 bytes RAM + 1 byte RAM per mapping entry. |&lt;/p&gt; &#xA;&lt;h3&gt;Changing include (*.h) files with Arduino IDE&lt;/h3&gt; &#xA;&lt;p&gt;First, use &lt;em&gt;Sketch &amp;gt; Show Sketch Folder (Ctrl+K)&lt;/em&gt;.&lt;br&gt; If you have not yet saved the example as your own sketch, then you are instantly in the right library folder.&lt;br&gt; Otherwise you have to navigate to the parallel &lt;code&gt;libraries&lt;/code&gt; folder and select the library you want to access.&lt;br&gt; In both cases the library source and include files are located in the libraries &lt;code&gt;src&lt;/code&gt; directory.&lt;br&gt; The modification must be renewed for each new library version!&lt;/p&gt; &#xA;&lt;h3&gt;Modifying compile options / macros with PlatformIO&lt;/h3&gt; &#xA;&lt;p&gt;If you are using PlatformIO, you can define the macros in the &lt;em&gt;&lt;a href=&#34;https://docs.platformio.org/en/latest/projectconf/section_env_build.html&#34;&gt;platformio.ini&lt;/a&gt;&lt;/em&gt; file with &lt;code&gt;build_flags = -D MACRO_NAME&lt;/code&gt; or &lt;code&gt;build_flags = -D MACRO_NAME=macroValue&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Modifying compile options / macros with Sloeber IDE&lt;/h3&gt; &#xA;&lt;p&gt;If you are using &lt;a href=&#34;https://eclipse.baeyens.it&#34;&gt;Sloeber&lt;/a&gt; as your IDE, you can easily define global symbols with &lt;em&gt;Properties &amp;gt; Arduino &amp;gt; CompileOptions&lt;/em&gt;.&lt;br&gt; &lt;img src=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/pictures/SloeberDefineSymbols.png&#34; alt=&#34;Sloeber settings&#34;&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Supported Boards&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Issues and discussions with the content &#34;Is it possible to use this library with the ATTinyXYZ? / board XYZ&#34; without any reasonable explanations will be immediately closed without further notice.&lt;/strong&gt;&lt;br&gt; &lt;br&gt; ATtiny and Digispark boards are only tested with the recommended &lt;a href=&#34;https://github.com/SpenceKonde/ATTinyCore&#34;&gt;ATTinyCore&lt;/a&gt; using &lt;code&gt;New Style&lt;/code&gt; pin mapping for the pro board.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Arduino Uno / Mega / Leonardo / Duemilanove / Diecimila / LilyPad / Mini / Fio / Nano etc.&lt;/li&gt; &#xA; &lt;li&gt;Teensy 1.0 / 1.0++ / 2.0 / 2++ / 3.0 / 3.1 / Teensy-LC - but &lt;a href=&#34;https://forum.pjrc.com/threads/65912-Enable-Continuous-Integration-with-arduino-cli-for-3-party-libraries&#34;&gt;limited support&lt;/a&gt;; Credits: PaulStoffregen (Teensy Team)&lt;/li&gt; &#xA; &lt;li&gt;Sanguino&lt;/li&gt; &#xA; &lt;li&gt;ATmega8, 48, 88, 168, 328&lt;/li&gt; &#xA; &lt;li&gt;ATmega8535, 16, 32, 164, 324, 644, 1284,&lt;/li&gt; &#xA; &lt;li&gt;ATmega64, 128&lt;/li&gt; &#xA; &lt;li&gt;ATmega4809 (Nano every)&lt;/li&gt; &#xA; &lt;li&gt;ATtiny3217 (Tiny Core 32 Dev Board)&lt;/li&gt; &#xA; &lt;li&gt;ATtiny84, 85, 167 (Digispark + Digispark Pro)&lt;/li&gt; &#xA; &lt;li&gt;SAMD21 (Zero, MKR*, &lt;strong&gt;but not SAMD51 and not DUE, the latter is SAM architecture&lt;/strong&gt;)&lt;/li&gt; &#xA; &lt;li&gt;ESP8266&lt;/li&gt; &#xA; &lt;li&gt;ESP32 (ESP32 C3 since board package 2.0.2 from Espressif)&lt;/li&gt; &#xA; &lt;li&gt;Sparkfun Pro Micro&lt;/li&gt; &#xA; &lt;li&gt;Nano Every, Uno WiFi Rev2, nRF5 BBC MicroBit, Nano33_BLE&lt;/li&gt; &#xA; &lt;li&gt;BluePill with STM32&lt;/li&gt; &#xA; &lt;li&gt;RP2040 based boards (Raspberry Pi Pico, Nano RP2040 Connect etc.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For ESP8266/ESP32, &lt;a href=&#34;https://github.com/crankyoldgit/IRremoteESP8266&#34;&gt;this library&lt;/a&gt; supports an &lt;a href=&#34;https://github.com/crankyoldgit/IRremoteESP8266/raw/master/SupportedProtocols.md&#34;&gt;impressive set of protocols and a lot of air conditioners&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;We are open to suggestions for adding support to new boards, however we highly recommend you contact your supplier first and ask them to provide support from their side.&lt;br&gt; If you can provide &lt;strong&gt;examples of using a periodic timer for interrupts&lt;/strong&gt; for the new board, and the board name for selection in the Arduino IDE, then you have way better chances to get your board supported by IRremote.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Timer and pin usage&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;strong&gt;receiver sample interval of 50 µs is generated by a timer&lt;/strong&gt;. On many boards this must be a hardware timer. On some boards where a software timer is available, the software timer is used.&lt;br&gt; Every pin can be used for receiving.&lt;/p&gt; &#xA;&lt;p&gt;The MinimalReceiver example uses the &lt;strong&gt;TinyReceiver&lt;/strong&gt; library, which can &lt;strong&gt;only receive NEC codes, but does not require any timer&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The code for the timer and the &lt;strong&gt;timer selection&lt;/strong&gt; is located in &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/private/IRTimer.hpp&#34;&gt;private/IRTimer.hpp&lt;/a&gt;. It can be adjusted here.&lt;br&gt; &lt;strong&gt;Be aware that the hardware timer used for receiving should not be used for analogWrite()!&lt;/strong&gt;.&lt;br&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Board/CPU&lt;/th&gt; &#xA;   &lt;th&gt;Receive&lt;br&gt;&amp;amp; PWM Timers&lt;/th&gt; &#xA;   &lt;th&gt;Hardware-PWM Pin&lt;/th&gt; &#xA;   &lt;th&gt;analogWrite()&lt;br&gt;pins occupied by timer&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/ATTinyCore&#34;&gt;ATtiny84&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/ATTinyCore&#34;&gt;ATtiny85 &amp;gt; 4 MHz&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;, 1&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;, 4&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;0&lt;/strong&gt;, 1 &amp;amp; 4&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/ATTinyCore&#34;&gt;ATtiny88 &amp;gt; 4 MHz&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PB1 / 8&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PB1 / 8 &amp;amp; PB2 / 9&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/ATTinyCore&#34;&gt;ATtiny167 &amp;gt; 4 MHz&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;9&lt;/strong&gt;, 8 - 15&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;8 - 15&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/megaTinyCore&#34;&gt;ATtiny1604&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TCB0&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PA05&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/megaTinyCore&#34;&gt;ATtiny1614, ATtiny816&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TCA0&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PA3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/SpenceKonde/megaTinyCore&#34;&gt;ATtiny3217&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TCA0&lt;/strong&gt;, TCD&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/MCUdude/MiniCore&#34;&gt;ATmega8&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ATmega168, &lt;strong&gt;ATmega328&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1, &lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;9, &lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;9 &amp;amp; 10, &lt;strong&gt;3 &amp;amp; 11&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/MCUdude/MightyCore&#34;&gt;ATmega1284&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1, &lt;strong&gt;2&lt;/strong&gt;, 3&lt;/td&gt; &#xA;   &lt;td&gt;13, 14, 6&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/MCUdude/MightyCore&#34;&gt;ATmega164, ATmega324, ATmega644&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1, &lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;13, &lt;strong&gt;14&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/MCUdude/MightyCore&#34;&gt;ATmega8535 ATmega16, ATmega32&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;13&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/MCUdude/MegaCore&#34;&gt;ATmega64, ATmega128, ATmega1281, ATmega2561&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;13&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/MCUdude/MajorCore&#34;&gt;ATmega8515, ATmega162&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;13&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ATmega1280, ATmega2560&lt;/td&gt; &#xA;   &lt;td&gt;1, &lt;strong&gt;2&lt;/strong&gt;, 3, 4, 5&lt;/td&gt; &#xA;   &lt;td&gt;5, 6, &lt;strong&gt;9&lt;/strong&gt;, 11, 46&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ATmega4809&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TCB0&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;A4&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Leonardo (Atmega32u4)&lt;/td&gt; &#xA;   &lt;td&gt;1, 3, &lt;strong&gt;4_HS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;5, &lt;strong&gt;9&lt;/strong&gt;, 13&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Zero (SAMD)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TC3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;*, &lt;strong&gt;9&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;http://esp32.net/&#34;&gt;ESP32&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Ledc chan. 0&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;All pins&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.sparkfun.com/products/12640&#34;&gt;Sparkfun Pro Micro&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1, &lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;, 9&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.pjrc.com/teensy/pinout.html&#34;&gt;Teensy 1.0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;17&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;15, 18&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.pjrc.com/teensy/pinout.html&#34;&gt;Teensy 2.0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1, 3, &lt;strong&gt;4_HS&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;9, &lt;strong&gt;10&lt;/strong&gt;, 14&lt;/td&gt; &#xA;   &lt;td&gt;12&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.pjrc.com/teensy/pinout.html&#34;&gt;Teensy++ 1.0 / 2.0&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;1, &lt;strong&gt;2&lt;/strong&gt;, 3&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;, 16, 25&lt;/td&gt; &#xA;   &lt;td&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.pjrc.com/teensy/pinout.html&#34;&gt;Teensy-LC&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TPM1&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;16&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;17&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.pjrc.com/teensy/pinout.html&#34;&gt;Teensy 3.0 - 3.6&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;CMT&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.pjrc.com/teensy/pinout.html&#34;&gt;Teensy 4.0 - 4.1&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;FlexPWM1.3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;7, 25&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/stm32duino/Arduino_Core_STM32&#34;&gt;BluePill / STM32F103C8T6&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PA6 &amp;amp; PA7 &amp;amp; PB0 &amp;amp; PB1&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill&#34;&gt;BluePill / STM32F103C8T6&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;TIM4&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;PB6 &amp;amp; PB7 &amp;amp; PB8 &amp;amp; PB9&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/earlephilhower/arduino-pico&#34;&gt;RP2040 / Pi Pico&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raspberrypi.github.io/pico-sdk-doxygen/group__repeating__timer.html&#34;&gt;default alarm pool&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;All pins&lt;/td&gt; &#xA;   &lt;td&gt;No pin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/arduino/ArduinoCore-mbed&#34;&gt;RP2040 / Mbed based&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mbed Ticker&lt;/td&gt; &#xA;   &lt;td&gt;All pins&lt;/td&gt; &#xA;   &lt;td&gt;No pin&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The &lt;strong&gt;send PWM signal&lt;/strong&gt; is by default generated by software. &lt;strong&gt;Therefore every pin can be used for sending&lt;/strong&gt;. The PWM pulse length is guaranteed to be constant by using &lt;code&gt;delayMicroseconds()&lt;/code&gt;. Take care not to generate interrupts during sending with software generated PWM, otherwise you will get jitter in the generated PWM. E.g. wait for a former &lt;code&gt;Serial.print()&lt;/code&gt; statement to be finished by &lt;code&gt;Serial.flush()&lt;/code&gt;. Since the Arduino &lt;code&gt;micros()&lt;/code&gt; function has a resolution of 4 µs at 16 MHz, we always see a small jitter in the signal, which seems to be OK for the receivers.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Software generated PWM showing small jitter because of the limited resolution of 4 µs of the Arduino core &lt;code&gt;micros()&lt;/code&gt; function for an ATmega328&lt;/th&gt; &#xA;   &lt;th&gt;Detail (ATmega328 generated) showing 30% duty cycle&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/pictures/IR_PWM_by_software_jitter.png&#34; alt=&#34;Software PWM&#34;&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;img src=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/pictures/IR_PWM_by_software_detail.png&#34; alt=&#34;Software PWM detail&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Incompatibilities to other libraries and Arduino commands like tone() and analogWrite()&lt;/h2&gt; &#xA;&lt;p&gt;If you use a library which requires the same timer as IRremote, you have a problem, since &lt;strong&gt;the timer resource cannot be shared simultaneously&lt;/strong&gt; by both libraries.&lt;/p&gt; &#xA;&lt;h3&gt;Change timer&lt;/h3&gt; &#xA;&lt;p&gt;The best approach is to change the timer used for IRremote, which can be accomplished by specifying the timer before &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt;.&lt;br&gt; The timer specifications available for your board can be found in &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/private/IRTimer.hpp&#34;&gt;private/IRTimer.hpp&lt;/a&gt;.&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Arduino Mega&#xA;#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xA;#  if !defined(IR_USE_AVR_TIMER1) &amp;amp;&amp;amp; !defined(IR_USE_AVR_TIMER2) &amp;amp;&amp;amp; !defined(IR_USE_AVR_TIMER3) &amp;amp;&amp;amp; !defined(IR_USE_AVR_TIMER4) &amp;amp;&amp;amp; !defined(IR_USE_AVR_TIMER5)&#xA;//#define IR_USE_AVR_TIMER1   // send pin = pin 11&#xA;#define IR_USE_AVR_TIMER2     // send pin = pin 9&#xA;//#define IR_USE_AVR_TIMER3   // send pin = pin 5&#xA;//#define IR_USE_AVR_TIMER4   // send pin = pin 6&#xA;//#define IR_USE_AVR_TIMER5   // send pin = pin 46&#xA;#  endif&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here you see the Arduino Mega board and the available specifications are &lt;code&gt;IR_USE_AVR_TIMER[1,2,3,4,5]&lt;/code&gt;.&lt;br&gt; You &lt;strong&gt;just have to include a line&lt;/strong&gt; e.g. &lt;code&gt;#define IR_USE_AVR_TIMER3&lt;/code&gt; before &lt;code&gt;#include &amp;lt;IRremote.hpp&amp;gt;&lt;/code&gt; to enable timer 3.&lt;/p&gt; &#xA;&lt;p&gt;But be aware that the new timer in turn might be incompatible with other libraries or commands.&lt;br&gt; For other boards/platforms you must look for the appropriate section guarded by e.g. &lt;code&gt;#elif defined(ESP32)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Stop and start timer&lt;/h3&gt; &#xA;&lt;p&gt;Another approach can be to share the timer &lt;strong&gt;sequentially&lt;/strong&gt; if their functionality is used only for a short period of time like for the &lt;strong&gt;Arduino tone() command&lt;/strong&gt;. An example can be seen &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/21b5747a58e9d47c9e3f1beb056d58c875a92b47/examples/ReceiveDemo/ReceiveDemo.ino#L159-L169&#34;&gt;here&lt;/a&gt;, where the timer settings for IR receive are restored after the tone has stopped. For this we must call &lt;code&gt;IrReceiver.start()&lt;/code&gt; or better &lt;code&gt;IrReceiver.start(microsecondsOfToneDuration)&lt;/code&gt;.&lt;br&gt; This only works since each call to&lt;code&gt; tone()&lt;/code&gt; completely initializes the timer 2 used by the &lt;code&gt;tone()&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;h2&gt;Hardware-PWM signal generation for sending&lt;/h2&gt; &#xA;&lt;p&gt;If you define &lt;code&gt;SEND_PWM_BY_TIMER&lt;/code&gt;, the send PWM signal is forced to be generated by a hardware timer on most platforms.&lt;br&gt; By default, the same timer as for the receiver is used.&lt;br&gt; Since each hardware timer has its dedicated output pin(s), you must change timer or timer sub-specifications to change PWM output pin. See &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/private/IRTimer.hpp&#34;&gt;private/IRTimer.hpp&lt;/a&gt;&lt;br&gt; &lt;strong&gt;Exeptions&lt;/strong&gt; are currently &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/39bdf8d7bf5b90dc221f8ae9fb3efed9f0a8a1db/examples/SimpleSender/PinDefinitionsAndMore.h#L273&#34;&gt;ESP32, ARDUINO_ARCH_RP2040, PARTICLE and ARDUINO_ARCH_MBED&lt;/a&gt;, where &lt;strong&gt;PWM generation does not require a timer&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Why do we use 30% duty cycle for sending&lt;/h2&gt; &#xA;&lt;p&gt;We do it according to the statement in the &lt;a href=&#34;https://www.vishay.com/docs/80069/circuit.pdf&#34;&gt;Vishay datasheet&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Carrier duty cycle 50 %, peak current of emitter IF = 200 mA, the resulting transmission distance is 25 m.&lt;/li&gt; &#xA; &lt;li&gt;Carrier duty cycle 10 %, peak current of emitter IF = 800 mA, the resulting transmission distance is 29 m. - Factor 1.16 The reason is, that it is not the pure energy of the fundamental which is responsible for the receiver to detect a signal. Due to automatic gain control and other bias effects, high intensity of the 38 kHz pulse counts more than medium intensity (e.g. 50% duty cycle) at the same total energy.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;How we decode signals&lt;/h1&gt; &#xA;&lt;p&gt;The IR signal is sampled at a &lt;strong&gt;50 µs interval&lt;/strong&gt;. For a constant 525 µs pulse or pause we therefore get 10 or 11 samples, each with 50% probability.&lt;br&gt; And believe me, if you send a 525 µs signal, your receiver will output something between around 400 and 700 µs!&lt;br&gt; Therefore &lt;strong&gt;we decode by default with a +/- 25% margin&lt;/strong&gt; using the formulas &lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/raw/master/src/IRremoteInt.h#L376-L399&#34;&gt;here&lt;/a&gt;.&lt;br&gt; E.g. for the NEC protocol with its 560 µs unit length, we have TICKS_LOW = 8.358 and TICKS_HIGH = 15.0. This means, we accept any value between 8 ticks / 400 µs and 15 ticks / 750 µs (inclusive) as a mark or as a zero space. For a one space we have TICKS_LOW = 25.07 and TICKS_HIGH = 45.0.&lt;br&gt; And since the receivers generated marks are longer or shorter than the spaces, we have introduced the [&lt;code&gt;MARK_EXCESS_MICROS&lt;/code&gt; value]/&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote#protocolunknown&#34;&gt;https://github.com/Arduino-IRremote/Arduino-IRremote#protocolunknown&lt;/a&gt;) to compensate for this receiver (and signal strength as well as ambient light dependent &lt;span&gt;😞&lt;/span&gt; ) specific deviation.&lt;br&gt; Welcome to the world of &lt;strong&gt;real world signal processing&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;NEC encoding diagrams&lt;/h1&gt; &#xA;&lt;p&gt;Created with sigrok PulseView with IR_NEC decoder by DjordjeMandic.&lt;br&gt; 8 bit address NEC code &lt;img src=&#34;https://user-images.githubusercontent.com/6750655/108884951-78e42b80-7607-11eb-9513-b07173a169c0.png&#34; alt=&#34;8 bit address NEC code&#34;&gt; 16 bit address NEC code &lt;img src=&#34;https://user-images.githubusercontent.com/6750655/108885081-a6c97000-7607-11eb-8d35-274a7065b6c4.png&#34; alt=&#34;16 bit address NEC code&#34;&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Quick comparison of 5 Arduino IR receiving libraries&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/crankyoldgit/IRremoteESP8266&#34;&gt;Here&lt;/a&gt; you find an &lt;strong&gt;ESP8266/ESP32&lt;/strong&gt; version of IRremote with an &lt;strong&gt;&lt;a href=&#34;https://github.com/crankyoldgit/IRremoteESP8266/raw/master/SupportedProtocols.md&#34;&gt;impressive list of supported protocols&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;This is a short comparison and may not be complete or correct.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;I created this comparison matrix for &lt;a href=&#34;https://github.com/ArminJo&#34;&gt;myself&lt;/a&gt; in order to choose a small IR lib for my project and to have a quick overview, when to choose which library.&lt;br&gt; It is dated from &lt;strong&gt;24.06.2022&lt;/strong&gt;. If you have complains about the data or request for extensions, please send a PM or open a discussion.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Subject&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/IRMP-org/IRMP&#34;&gt;IRMP&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/NicoHood/IRLremote&#34;&gt;IRLremote&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/cyborg5/IRLib2&#34;&gt;IRLib2&lt;/a&gt;&lt;br&gt;&lt;strong&gt;mostly unmaintained&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote&#34;&gt;IRremote&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/Arduino-IRremote/Arduino-IRremote/tree/master/examples/MinimalReceiver&#34;&gt;Minimal NEC&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;a href=&#34;https://github.com/LuisMiCa/IRsmallDecoder&#34;&gt;IRsmallDecoder&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Number of protocols&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;50&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Nec + Panasonic + Hash *&lt;/td&gt; &#xA;   &lt;td&gt;12 + Hash *&lt;/td&gt; &#xA;   &lt;td&gt;17 + PulseDistance + Hash *&lt;/td&gt; &#xA;   &lt;td&gt;NEC&lt;/td&gt; &#xA;   &lt;td&gt;NEC + RC5 + Sony + Samsung&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Timing method receive&lt;/td&gt; &#xA;   &lt;td&gt;Timer2 or interrupt for pin 2 or 3&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Interrupt&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Timer2 or interrupt for pin 2 or 3&lt;/td&gt; &#xA;   &lt;td&gt;Timer2&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Interrupt&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Interrupt&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Timing method send&lt;/td&gt; &#xA;   &lt;td&gt;PWM and timing with Timer2 interrupts&lt;/td&gt; &#xA;   &lt;td&gt;Timer2 interrupts&lt;/td&gt; &#xA;   &lt;td&gt;Timer2 and blocking wait&lt;/td&gt; &#xA;   &lt;td&gt;PWM with Timer2 and/or blocking wait with delay&lt;br&gt;Microseconds()&lt;/td&gt; &#xA;   &lt;td&gt;blocking wait with delay&lt;br&gt;Microseconds()&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Send pins&lt;/td&gt; &#xA;   &lt;td&gt;All&lt;/td&gt; &#xA;   &lt;td&gt;All&lt;/td&gt; &#xA;   &lt;td&gt;All ?&lt;/td&gt; &#xA;   &lt;td&gt;Timer dependent&lt;/td&gt; &#xA;   &lt;td&gt;All&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Decode method&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;RAM&lt;/td&gt; &#xA;   &lt;td&gt;RAM&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Encode method&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly or RAM&lt;/td&gt; &#xA;   &lt;td&gt;OnTheFly&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Callback support&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Repeat handling&lt;/td&gt; &#xA;   &lt;td&gt;Receive + Send (partially)&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;?&lt;/td&gt; &#xA;   &lt;td&gt;Receive + Send&lt;/td&gt; &#xA;   &lt;td&gt;Receive + Send&lt;/td&gt; &#xA;   &lt;td&gt;Receive&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;LED feedback&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;   &lt;td&gt;Receive&lt;/td&gt; &#xA;   &lt;td&gt;%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FLASH usage (simple NEC example with 5 prints)&lt;/td&gt; &#xA;   &lt;td&gt;1820&lt;br&gt;(4300 for 15 main / 8000 for all 40 protocols)&lt;br&gt;(+200 for callback)&lt;br&gt;(+80 for interrupt at pin 2+3)&lt;/td&gt; &#xA;   &lt;td&gt;1270&lt;br&gt;(1400 for pin 2+3)&lt;/td&gt; &#xA;   &lt;td&gt;4830&lt;/td&gt; &#xA;   &lt;td&gt;1770&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;900&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;?1100?&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;RAM usage&lt;/td&gt; &#xA;   &lt;td&gt;52&lt;br&gt;(73 / 100 for 15 (main) / 40 protocols)&lt;/td&gt; &#xA;   &lt;td&gt;62&lt;/td&gt; &#xA;   &lt;td&gt;334&lt;/td&gt; &#xA;   &lt;td&gt;227&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;19&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;29&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Supported platforms&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;avr, megaavr, attiny, Digispark (Pro), esp8266, ESP32, STM32, SAMD 21, Apollo3&lt;br&gt;(plus arm and pic for non Arduino IDE)&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;avr, esp8266&lt;/td&gt; &#xA;   &lt;td&gt;avr, SAMD 21, SAMD 51&lt;/td&gt; &#xA;   &lt;td&gt;avr, attiny, &lt;a href=&#34;https://github.com/crankyoldgit/IRremoteESP8266&#34;&gt;esp8266&lt;/a&gt;, esp32, SAM, SAMD&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;All platforms with attach&lt;br&gt;Interrupt()&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;All platforms with attach&lt;br&gt;Interrupt()&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Last library update&lt;/td&gt; &#xA;   &lt;td&gt;6/2022&lt;/td&gt; &#xA;   &lt;td&gt;4/2018&lt;/td&gt; &#xA;   &lt;td&gt;3/2022&lt;/td&gt; &#xA;   &lt;td&gt;6/2022&lt;/td&gt; &#xA;   &lt;td&gt;6/2022&lt;/td&gt; &#xA;   &lt;td&gt;2/2022&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Remarks&lt;/td&gt; &#xA;   &lt;td&gt;Decodes 40 protocols concurrently.&lt;br&gt;39 Protocols to send.&lt;br&gt;Work in progress.&lt;/td&gt; &#xA;   &lt;td&gt;Only one protocol at a time.&lt;/td&gt; &#xA;   &lt;td&gt;Consists of 5 libraries. &lt;strong&gt;Project containing bugs - 45 issues, no reaction for at least one year.&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Universal decoder and encoder.&lt;br&gt;Supports &lt;strong&gt;Pronto&lt;/strong&gt; codes and sending of raw timing values.&lt;/td&gt; &#xA;   &lt;td&gt;Requires no timer.&lt;/td&gt; &#xA;   &lt;td&gt;Requires no timer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;* The Hash protocol gives you a hash as code, which may be sufficient to distinguish your keys on the remote, but may not work with some protocols like Mitsubishi&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Useful links&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.harctoolbox.org/IR-resources.html&#34;&gt;List of public IR code databases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://lirc-remotes.sourceforge.net/remotes-table.html&#34;&gt;LIRC database&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.mikrocontroller.net/articles/IRMP_-_english#IR_Protocols&#34;&gt;IRMP list of IR protocols&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/probonopd/irdb/tree/master/codes&#34;&gt;IRDB database for IR codes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/probonopd/MakeHex/tree/master/protocols&#34;&gt;IRP definition files for IR protocols&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.sbprojects.net/knowledge/ir/&#34;&gt;IR Remote Control Theory and some protocols (upper right hamburger icon)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.hifi-remote.com/johnsfine/DecodeIR.html&#34;&gt;Interpreting Decoded IR Signals (v2.45)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.analysir.com/blog/2014/03/19/air-conditioners-problems-recording-long-infrared-remote-control-signals-arduino&#34;&gt;&#34;Recording long Infrared Remote control signals with Arduino&#34;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The original blog post of Ken Shirriff &lt;a href=&#34;http://www.arcfn.com/2009/08/multi-protocol-infrared-remote-library.html&#34;&gt;A Multi-Protocol Infrared Remote Library for the Arduino&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.vishay.com/docs/80069/circuit.pdf&#34;&gt;Vishay datasheet&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Up to the version 2.7.0, the License is GPLv2. From the version 2.8.0, the license is the MIT license.&lt;/p&gt; &#xA;&lt;h1&gt;Copyright&lt;/h1&gt; &#xA;&lt;p&gt;Initially coded 2009 Ken Shirriff &lt;a href=&#34;http://www.righto.com&#34;&gt;http://www.righto.com&lt;/a&gt;&lt;br&gt; Copyright (c) 2016-2017 Rafi Khan&lt;br&gt; Copyright (c) 2020-2022 &lt;a href=&#34;https://github.com/ArminJo&#34;&gt;Armin Joachimsmeyer&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>google/fully-homomorphic-encryption</title>
    <updated>2022-12-27T01:30:07Z</updated>
    <id>tag:github.com,2022-12-27:/google/fully-homomorphic-encryption</id>
    <link href="https://github.com/google/fully-homomorphic-encryption" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An FHE compiler for C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Fully Homomorphic Encryption (FHE)&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains open-source libraries and tools to perform fully homomorphic encryption (FHE) operations on an encrypted data set.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;About Fully Homomorphic Encryption&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fully Homomorphic Encryption (FHE) is an emerging cryptographic technique that allows developers to perform computations on encrypted data. This represents a paradigm shift in how data processing and data privacy relate to each other.&lt;/p&gt; &#xA;&lt;p&gt;Previously, if an application had to perform some computation on data that was encrypted, this application would necessarily need to decrypt the data first, perform the desired computations on the clear data, and then re-encrypt the data. FHE, on the other hand, simply removes the need for this decryption-encryption steps by the application, all at once.&lt;/p&gt; &#xA;&lt;p&gt;In practice, for an application that needs to perform some computation F on data that is encrypted, the FHE scheme would provide some alternative computation F&#39; which when applied directly over the encrypted data will result in the encryption of the application of F over the data in the clear. More formally: F(unencrypted_data) = Decrypt(F&#39;(encrypted_data)).&lt;/p&gt; &#xA;&lt;p&gt;As a result, FHE can have an enormous impact to our society. It can change the way computations are performed by preserving end-to-end privacy. For example, users would be able to offload expensive computations to cloud providers in a way that cloud providers will not have access to the users&#39; data at all.&lt;/p&gt; &#xA;&lt;p&gt;The main hindrance for the adoption of FHE has been its very poor performance. Despite significant scientific improvements, performing computations on encrypted data using FHE is still orders of magnitude slower than performing the computation on the plaintext. On top of that, converting a program that operates on unencrypted data to one that FHE-operates on encrypted data is far from being a trivial translation. If not properly done, this translation can significantly increase the performance gap between computing on unencrypted data and the FHE-computation on encrypted data, thus precluding wide FHE adoption.&lt;/p&gt; &#xA;&lt;h2&gt;FHE C++ Transpiler&lt;/h2&gt; &#xA;&lt;p&gt;The FHE C++ Transpiler is a general purpose library that converts C++ into FHE-C++ that works on encrypted input.&lt;/p&gt; &#xA;&lt;p&gt;The transpiler has a modular architecture that allows varying the underlying FHE library, the high-level program description and the output language as well. We hope that this flexibility will allow researchers from different fields to work together on this exciting goal of making FHE more efficient and broadly applicable.&lt;/p&gt; &#xA;&lt;p&gt;The code, examples, and more information is in the &lt;a href=&#34;https://raw.githubusercontent.com/google/fully-homomorphic-encryption/main/transpiler/&#34;&gt;&lt;code&gt;transpiler&lt;/code&gt;&lt;/a&gt; subdirectory.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;We will continue to publish updates and improvements to the FHE library. We are not yet accepting external contributions to this project. We will respond to issues filed in this project. If we ever intend to stop publishing improvements and responding to issues we will publish notice here at least 3 months in advance.&lt;/p&gt; &#xA;&lt;h2&gt;Support disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;This is not an officially supported Google product.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Apache License 2.0. See &lt;a href=&#34;https://raw.githubusercontent.com/google/fully-homomorphic-encryption/main/LICENSE&#34;&gt;&lt;code&gt;LICENSE&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contact information&lt;/h2&gt; &#xA;&lt;p&gt;We are committed to open-sourcing our work to support your use cases. We want to know how you use this library and what problems it helps you to solve. We have two communication channels for you to contact us:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A &lt;a href=&#34;https://groups.google.com/g/fhe-open-source-users&#34;&gt;public discussion group&lt;/a&gt; where we will also share our preliminary roadmap, updates, events, and more.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;A private email alias at &lt;a href=&#34;mailto:fhe-open-source@google.com&#34;&gt;fhe-open-source@google.com&lt;/a&gt; where you can reach out to us directly about your use cases and what more we can do to help and improve the library.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please refrain from sending any sensitive or confidential information. If you wish to delete a message you&#39;ve previously sent, please contact us.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;The contributors to this project are (sorted by last name):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ericastor&#34;&gt;Eric Astor&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://desfontain.es/serious.html&#34;&gt;Damien Desfontaines&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Christoph Dibak&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://people.scs.carleton.ca/~aforget/&#34;&gt;Alain Forget&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/bryant-gipson-33478419&#34;&gt;Bryant Gipson&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/code-perspective&#34;&gt;Shruthi Gorantala&lt;/a&gt; (Lead)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/miguel-guevara-8a5a332a&#34;&gt;Miguel Guevara&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/aishe-k&#34;&gt;Aishwarya Krishnamurthy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Sasha Kulankhina&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/william-m-lam&#34;&gt;William Lam&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://dmarn.org&#34;&gt;David Marn&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/rafael-misoczki-phd-24b33013&#34;&gt;Rafael Misoczki&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Bernat Guillén Pegueroles&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://milinda-perera.com&#34;&gt;Milinda Perera&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/sean-purser-haskell-30b5268&#34;&gt;Sean Purser-Haskell&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/samuelruth&#34;&gt;Sam Ruth&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/RobSpringer&#34;&gt;Rob Springer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/in/midnighter&#34;&gt;Yurii Sushko&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cam2337&#34;&gt;Cameron Tew&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://research.google/people/RoyceJWilson&#34;&gt;Royce Wilson&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/xinyuye&#34;&gt;Xinyu Ye&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/izuk&#34;&gt;Itai Zukerman&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/malchev&#34;&gt;Iliyan Malchev&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Citing FHE Transpiler&lt;/h2&gt; &#xA;&lt;p&gt;To cite FHE Transpiler in academic papers, please use the following entry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;@misc{cryptoeprint:2021/811,&#xA;      author = {Shruthi Gorantala and Rob Springer and Sean Purser-Haskell and William Lam and Royce Wilson and Asra Ali and Eric P. Astor and Itai Zukerman and Sam Ruth and Christoph Dibak and Phillipp Schoppmann and Sasha Kulankhina and Alain Forget and David Marn and Cameron Tew and Rafael Misoczki and Bernat Guillen and Xinyu Ye and Dennis Kraft and Damien Desfontaines and Aishe Krishnamurthy and Miguel Guevara and Irippuge Milinda Perera and Yurii Sushko and Bryant Gipson},&#xA;      title = {A General Purpose Transpiler for Fully Homomorphic Encryption},&#xA;      howpublished = {Cryptology ePrint Archive, Paper 2021/811},&#xA;      year = {2021},&#xA;      note = {\url{https://eprint.iacr.org/2021/811}},&#xA;      url = {https://eprint.iacr.org/2021/811}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>