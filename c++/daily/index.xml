<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-10T01:31:22Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ZhuriLab/Joker</title>
    <updated>2022-11-10T01:31:22Z</updated>
    <id>tag:github.com,2022-11-10:/ZhuriLab/Joker</id>
    <link href="https://github.com/ZhuriLab/Joker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;一款基于Http.sys的利用工具&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Joker&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902160054.png&#34; alt=&#34;image-20220902160052965&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;版本 1.0&lt;/h3&gt; &#xA;&lt;h3&gt;工具原理介绍&lt;/h3&gt; &#xA;&lt;p&gt;利用 &lt;strong&gt;Http.sys&lt;/strong&gt; 驱动对urlacl进行操作，由于Http.sys是IIS服务器的基础，其优先级高于IIS，不会造成端口bind冲突，达到端口服用效果，由于与受害机对外服务端口相同，可做到极高的隐蔽性。由于其生效后效果很类似于LOL的小丑，故起名为Joker。&lt;/p&gt; &#xA;&lt;h3&gt;使用方法&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;此工具的使用前提是 管理员权限 IIS环境&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h4&gt;1. 基于路径进行复用&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Joker.exe &#34;http://*:{PORT}/{PATH}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902160751.png&#34; alt=&#34;image-20220902160750422&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;可直接使用&lt;strong&gt;蚁剑&lt;/strong&gt;进行连接，配置如下：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902161011.png&#34; alt=&#34;image-20220902161010316&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;​ &lt;em&gt;连接密码随便填写&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902161212.png&#34; alt=&#34;image-20220902161210934&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;2.基于HOST进行复用（强烈推荐）&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;Joker.exe &#34;http://{HOST}:{PORT}/&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902161436.png&#34; alt=&#34;image-20220902161434903&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;蚁剑配置如下&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902161604.png&#34; alt=&#34;image-20220902161603406&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902161621.png&#34; alt=&#34;image-20220902161619869&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;这样，在正常访问80端口的时候为正常业务，在带特殊的头访问80端口的时候则为后门程序。&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h4&gt;3.Regeorg适配&lt;/h4&gt; &#xA;&lt;p&gt;项目JokerTunnel为对Regeorg适配版本。&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image-20221107111636996.png&#34; alt=&#34;image-20221107111636996&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image-20221107111724185.png&#34; alt=&#34;image-20221107111724185&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;客户端使用Regeorg进行连接即可&lt;/p&gt; &#xA;&lt;h3&gt;二次开发&lt;/h3&gt; &#xA;&lt;p&gt;此项目的handle都集中在handle.h当中，以执行为例，传入参数依次为 &lt;strong&gt;Request的body、RequestBody的长度与响应内容的指针&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://image.perng.cn/image20220902162523.png&#34; alt=&#34;image-20220902162522544&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>MegEngine/MegCC</title>
    <updated>2022-11-10T01:31:22Z</updated>
    <id>tag:github.com,2022-11-10:/MegEngine/MegCC</id>
    <link href="https://github.com/MegEngine/MegCC" rel="alternate"></link>
    <summary type="html">&lt;p&gt;MegCC是一个运行时超轻量，高效，移植简单的深度学习模型编译器&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/doc/picture/cc.png&#34; width=&#34;50%&#34; height=&#34;50%&#34; alt=&#34;logo&#34; align=&#34;center/&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/README_ENGLISH.md&#34;&gt;English README&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;MegCC 特点&lt;/h2&gt; &#xA;&lt;p&gt;MegCC 是一个面向推理的深度学习模型编译器，具有如下特点：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;font color=&#34;Red&#34; size=&#34;4&#34;&gt; 极其轻量的运行时库 &lt;/font&gt;&lt;/strong&gt; ：只编译 mobilenetv1 模型进行推理情况下，strip 符号之后，整个运行时二进制大小只有 &lt;strong&gt;&lt;font color=&#34;Red&#34; size=&#34;4&#34;&gt; 81KB &lt;/font&gt;&lt;/strong&gt; 。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;font color=&#34;Red&#34; size=&#34;4&#34;&gt; 高性能 &lt;/font&gt;&lt;/strong&gt; ：Arm 上的每一个 Kernel 都是经过人工精心调优的，&lt;strong&gt;&lt;font color=&#34;Red&#34; size=&#34;4&#34;&gt; 同样的模型，性能对比 &lt;a href=&#34;https://github.com/MegEngine/MegEngine&#34;&gt;MegEngine&lt;/a&gt; 有进一步的升级 &lt;/font&gt;&lt;/strong&gt; 。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;font color=&#34;Red&#34; size=&#34;4&#34;&gt; 方便移植 &lt;/font&gt;&lt;/strong&gt; ：运行时所有 Code 都是纯 C 代码，可以方便在 Arm，X86，裸板中进行移植。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;font color=&#34;Red&#34; size=&#34;4&#34;&gt; 低内存使用，快启动 &lt;/font&gt;&lt;/strong&gt; ：模型编译期间会进行内存规划，尽可能的复用内存，并进行静态绑定，减少运行时开销。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;MegCC 框架&lt;/h2&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/doc/picture/megcc.png&#34; width=&#34;100%&#34; height=&#34;100%&#34; alt=&#34;MegCC结构&#34; align=&#34;center&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;MegCC 主要由两部分组成：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;编译器：负责将模型进行编译，优化，最终生成新模型和对应的 Kernels&lt;/li&gt; &#xA; &lt;li&gt;runtime 运行时：运行时需要和生成的 Kernels 结合在一起进行编译，编译完成之后可以加载编译器生成的模型，并计算输出结果&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;MegCC 模型编译器是基于 MLIR 框架构建起来的，使用 MLIR 的 IR 进行图优化，内存规划以及 Kernel 生成，目前 MegCC 生成的 Kernel 大多数都是 基于人工优化之后写好的模板生成的。MegCC 支持多种场景的模型编译，不仅仅包含静态 shape 编译，而且还支持动态 shape 的编译，多个模型同时编译，以及同一个模型多种 shape 同时编译，另外为了获得极致的最小运行时库，还提供必要的纯 C 形式的 CV 算子生成。&lt;/p&gt; &#xA;&lt;p&gt;模型编译完成之后，MegCC 会生成两个产物，分别是：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;优化之后的新模型： 这个模型里面包含整个计算图的信息，以及每一个 Operator 运行时的内存规划信息，输入输出信息，计算 Kernel 的信息&lt;/li&gt; &#xA; &lt;li&gt;运行这些模型对应的 Kernel：上面模型运行时候需要的所有高性能 Kernel 的集合。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;MegCC runtime 会在运行时会加载生成的模型，并调用生成的高性能 Kernel 进行计算，并输出计算结果，目前测试一个可以高效运行 mobilenetv1 的可执行文件大小仅仅只需要 81KB。&lt;/p&gt; &#xA;&lt;p&gt;MegCC 现在支持的平台处理器平台有 Arm64/ArmV7/X86/risc-v/单片机, 所有支持的 Operator 列表见：&lt;a href=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/doc/opr.md&#34;&gt;operator list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;文档&lt;/h2&gt; &#xA;&lt;h5&gt;获取 MegCC 编译器&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;下载提预编译好的 MegCC 模型编译器 &lt;a href=&#34;https://github.com/MegEngine/MegCC/releases/download/v0.1.2/megcc_release_0.1.2.tar.gz&#34;&gt;下载 MegCC 编译器&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;从源码获取 MegCC 编译器&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如果是开发者需要从源码编译 MegCC 编译器，参考文档 &lt;a href=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/compiler/README.md&#34;&gt;源码编译 MegCC&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;MegCC 发行新版本&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;如果需要对 MegCC 进行发版，则参考文档 &lt;a href=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/doc/how-to-release.md&#34;&gt;MegCC 发版&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;如何使用 MegCC&lt;/h5&gt; &#xA;&lt;p&gt;目前 MegCC 只支持 MegEngine 模型作为输入，其他模型格式可以考虑转到 ONNX，然后通过 &lt;a href=&#34;https://github.com/MegEngine/mgeconvert&#34;&gt;mgeconvert&lt;/a&gt; 转换到 MegEngine。&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;首次尝鲜，参考 &lt;a href=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/doc/first-use.md&#34;&gt;初次使用&lt;/a&gt;。&lt;/li&gt; &#xA; &lt;li&gt;模型的编译，运行时库编译以及推理执行相关的详细文档，请参考 &lt;a href=&#34;https://raw.githubusercontent.com/MegEngine/MegCC/main/doc/how-to-use-chinese.md&#34;&gt;使用文档&lt;/a&gt;。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MegCC is licensed under the Apache License, Version 2.0&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Thanks a lot, please enjoy it&lt;/strong&gt;&lt;/p&gt;</summary>
  </entry>
</feed>