<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-13T01:28:45Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>KhronosGroup/glslang</title>
    <updated>2024-08-13T01:28:45Z</updated>
    <id>tag:github.com,2024-08-13:/KhronosGroup/glslang</id>
    <link href="https://github.com/KhronosGroup/glslang" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Khronos-reference front end for GLSL/ESSL, partial front end for HLSL, and a SPIR-V generator.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/KhronosGroup/glslang/actions/workflows/continuous_integration.yml/badge.svg?sanitize=true&#34; alt=&#34;Continuous Integration&#34;&gt; &lt;img src=&#34;https://github.com/KhronosGroup/glslang/actions/workflows/continuous_deployment.yml/badge.svg?sanitize=true&#34; alt=&#34;Continuous Deployment&#34;&gt; &lt;a href=&#34;https://securityscorecards.dev/viewer/?uri=github.com/KhronosGroup/glslang&#34;&gt;&lt;img src=&#34;https://api.securityscorecards.dev/projects/github.com/KhronosGroup/glslang/badge&#34; alt=&#34;OpenSSF Scorecard&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;News&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;OGLCompiler&lt;/code&gt; and &lt;code&gt;HLSL&lt;/code&gt; stub libraries have been fully removed from the build.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;OVERRIDE_MSVCCRT&lt;/code&gt; has been removed in favor of &lt;code&gt;CMAKE_MSVC_RUNTIME_LIBRARY&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Users are encouraged to utilize the standard approach via &lt;a href=&#34;https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html&#34;&gt;CMAKE_MSVC_RUNTIME_LIBRARY&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Glslang Components and Status&lt;/h1&gt; &#xA;&lt;p&gt;There are several components:&lt;/p&gt; &#xA;&lt;h3&gt;Reference Validator and GLSL/ESSL -&amp;gt; AST Front End&lt;/h3&gt; &#xA;&lt;p&gt;An OpenGL GLSL and OpenGL|ES GLSL (ESSL) front-end for reference validation and translation of GLSL/ESSL into an internal abstract syntax tree (AST).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: Virtually complete, with results carrying similar weight as the specifications.&lt;/p&gt; &#xA;&lt;h3&gt;HLSL -&amp;gt; AST Front End&lt;/h3&gt; &#xA;&lt;p&gt;An HLSL front-end for translation of an approximation of HLSL to glslang&#39;s AST form.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: Partially complete. Semantics are not reference quality and input is not validated. This is in contrast to the &lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler&#34;&gt;DXC project&lt;/a&gt;, which receives a much larger investment and attempts to have definitive/reference-level semantics.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/KhronosGroup/glslang/issues/362&#34;&gt;issue 362&lt;/a&gt; and &lt;a href=&#34;https://github.com/KhronosGroup/glslang/issues/701&#34;&gt;issue 701&lt;/a&gt; for current status.&lt;/p&gt; &#xA;&lt;h3&gt;AST -&amp;gt; SPIR-V Back End&lt;/h3&gt; &#xA;&lt;p&gt;Translates glslang&#39;s AST to the Khronos-specified SPIR-V intermediate language.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: Virtually complete.&lt;/p&gt; &#xA;&lt;h3&gt;Reflector&lt;/h3&gt; &#xA;&lt;p&gt;An API for getting reflection information from the AST, reflection types/variables/etc. from the HLL source (not the SPIR-V).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Status&lt;/strong&gt;: There is a large amount of functionality present, but no specification/goal to measure completeness against. It is accurate for the input HLL and AST, but only approximate for what would later be emitted for SPIR-V.&lt;/p&gt; &#xA;&lt;h3&gt;Standalone Wrapper&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;glslang&lt;/code&gt; is command-line tool for accessing the functionality above.&lt;/p&gt; &#xA;&lt;p&gt;Status: Complete.&lt;/p&gt; &#xA;&lt;p&gt;Tasks waiting to be done are documented as GitHub issues.&lt;/p&gt; &#xA;&lt;h2&gt;Other References&lt;/h2&gt; &#xA;&lt;p&gt;Also see the Khronos landing page for glslang as a reference front end:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/&#34;&gt;https://www.khronos.org/opengles/sdk/tools/Reference-Compiler/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The above page, while not kept up to date, includes additional information regarding glslang as a reference validator.&lt;/p&gt; &#xA;&lt;h1&gt;How to Use Glslang&lt;/h1&gt; &#xA;&lt;h2&gt;Execution of Standalone Wrapper&lt;/h2&gt; &#xA;&lt;p&gt;To use the standalone binary form, execute &lt;code&gt;glslang&lt;/code&gt;, and it will print a usage statement. Basic operation is to give it a file containing a shader, and it will print out warnings/errors and optionally an AST.&lt;/p&gt; &#xA;&lt;p&gt;The applied stage-specific rules are based on the file extension:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.vert&lt;/code&gt; for a vertex shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.tesc&lt;/code&gt; for a tessellation control shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.tese&lt;/code&gt; for a tessellation evaluation shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.geom&lt;/code&gt; for a geometry shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.frag&lt;/code&gt; for a fragment shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.comp&lt;/code&gt; for a compute shader&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For ray tracing pipeline shaders:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.rgen&lt;/code&gt; for a ray generation shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.rint&lt;/code&gt; for a ray intersection shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.rahit&lt;/code&gt; for a ray any-hit shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.rchit&lt;/code&gt; for a ray closest-hit shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.rmiss&lt;/code&gt; for a ray miss shader&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;.rcall&lt;/code&gt; for a callable shader&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is also a non-shader extension:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;.conf&lt;/code&gt; for a configuration file of limits, see usage statement for example&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building (CMake)&lt;/h2&gt; &#xA;&lt;p&gt;Instead of building manually, you can also download the binaries for your platform directly from the &lt;a href=&#34;https://github.com/KhronosGroup/glslang/releases/tag/main-tot&#34;&gt;main-tot release&lt;/a&gt; on GitHub. Those binaries are automatically uploaded by the buildbots after successful testing and they always reflect the current top of the tree of the main branch.&lt;/p&gt; &#xA;&lt;h3&gt;Dependencies&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A C++17 compiler. (For MSVS: use 2019 or later.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;: for generating compilation targets.&lt;/li&gt; &#xA; &lt;li&gt;make: &lt;em&gt;Linux&lt;/em&gt;, ninja is an alternative, if configured.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.python.org/&#34;&gt;Python 3.x&lt;/a&gt;: for executing SPIRV-Tools scripts. (Optional if not using SPIRV-Tools and the &#39;External&#39; subdirectory does not exist.)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/bison/&#34;&gt;bison&lt;/a&gt;: &lt;em&gt;optional&lt;/em&gt;, but needed when changing the grammar (glslang.y).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/googletest&#34;&gt;googletest&lt;/a&gt;: &lt;em&gt;optional&lt;/em&gt;, but should use if making any changes to glslang.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Build steps&lt;/h3&gt; &#xA;&lt;p&gt;The following steps assume a Bash shell. On Windows, that could be the Git Bash shell or some other shell of your choosing.&lt;/p&gt; &#xA;&lt;h4&gt;1) Check-Out this project&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd &amp;lt;parent of where you want glslang to be&amp;gt;&#xA;git clone https://github.com/KhronosGroup/glslang.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;2) Check-Out External Projects&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./update_glslang_sources.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3) Configure&lt;/h4&gt; &#xA;&lt;p&gt;Assume the source directory is &lt;code&gt;$SOURCE_DIR&lt;/code&gt; and the build directory is &lt;code&gt;$BUILD_DIR&lt;/code&gt;. First ensure the build directory exists, then navigate to it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p $BUILD_DIR&#xA;cd $BUILD_DIR&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For building on Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=&#34;$(pwd)/install&#34; $SOURCE_DIR&#xA;# &#34;Release&#34; (for CMAKE_BUILD_TYPE) could also be &#34;Debug&#34; or &#34;RelWithDebInfo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For building on Android:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake $SOURCE_DIR -G &#34;Unix Makefiles&#34; -DCMAKE_INSTALL_PREFIX=&#34;$(pwd)/install&#34; -DANDROID_ABI=arm64-v8a -DCMAKE_BUILD_TYPE=Release -DANDROID_STL=c++_static -DANDROID_PLATFORM=android-24 -DCMAKE_SYSTEM_NAME=Android -DANDROID_TOOLCHAIN=clang -DANDROID_ARM_MODE=arm -DCMAKE_MAKE_PROGRAM=$ANDROID_NDK_HOME/prebuilt/linux-x86_64/bin/make -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake&#xA;# If on Windows will be -DCMAKE_MAKE_PROGRAM=%ANDROID_NDK_HOME%\prebuilt\windows-x86_64\bin\make.exe&#xA;# -G is needed for building on Windows&#xA;# -DANDROID_ABI can also be armeabi-v7a for 32 bit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For building on Windows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cmake $SOURCE_DIR -DCMAKE_INSTALL_PREFIX=&#34;$(pwd)/install&#34;&#xA;# The CMAKE_INSTALL_PREFIX part is for testing (explained later).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The CMake GUI also works for Windows (version 3.4.1 tested).&lt;/p&gt; &#xA;&lt;p&gt;Also, consider using &lt;code&gt;git config --global core.fileMode false&lt;/code&gt; (or with &lt;code&gt;--local&lt;/code&gt;) on Windows to prevent the addition of execution permission on files.&lt;/p&gt; &#xA;&lt;h4&gt;4) Build and Install&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# for Linux:&#xA;make -j4 install&#xA;&#xA;# for Windows:&#xA;cmake --build . --config Release --target install&#xA;# &#34;Release&#34; (for --config) could also be &#34;Debug&#34;, &#34;MinSizeRel&#34;, or &#34;RelWithDebInfo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If using MSVC, after running CMake to configure, use the Configuration Manager to check the &lt;code&gt;INSTALL&lt;/code&gt; project.&lt;/p&gt; &#xA;&lt;p&gt;If you want to enable testing via CMake set &lt;code&gt;GLSLANG_TESTS=ON&lt;/code&gt; when configuring the build.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;GLSLANG_TESTS&lt;/code&gt; is off by default to streamline the packaging / Vulkan SDK process.&lt;/p&gt; &#xA;&lt;h3&gt;Building (GN)&lt;/h3&gt; &#xA;&lt;p&gt;glslang can also be built with the &lt;a href=&#34;https://gn.googlesource.com/gn/&#34;&gt;GN build system&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;1) Install &lt;code&gt;depot_tools&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Download &lt;a href=&#34;https://storage.googleapis.com/chrome-infra/depot_tools.zip&#34;&gt;depot_tools.zip&lt;/a&gt;, extract to a directory, and add this directory to your &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;2) Synchronize dependencies and generate build files&lt;/h4&gt; &#xA;&lt;p&gt;This only needs to be done once after updating &lt;code&gt;glslang&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;With the current directory set to your &lt;code&gt;glslang&lt;/code&gt; checkout, type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./update_glslang_sources.py&#xA;gclient sync --gclientfile=standalone.gclient&#xA;gn gen out/Default&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;3) Build&lt;/h4&gt; &#xA;&lt;p&gt;With the current directory set to your &lt;code&gt;glslang&lt;/code&gt; checkout, type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd out/Default&#xA;ninja&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;If you need to change the GLSL grammar&lt;/h3&gt; &#xA;&lt;p&gt;The grammar in &lt;code&gt;glslang/MachineIndependent/glslang.y&lt;/code&gt; has to be recompiled with bison if it changes, the output files are committed to the repo to avoid every developer needing to have bison configured to compile the project when grammar changes are quite infrequent. For windows you can get binaries from &lt;a href=&#34;http://gnuwin32.sourceforge.net/packages/bison.htm&#34;&gt;GnuWin32&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The command to rebuild is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bison --defines=MachineIndependent/glslang_tab.cpp.h&#xA;      -t MachineIndependent/glslang.y&#xA;      -o MachineIndependent/glslang_tab.cpp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The above command is also available in the bash script in &lt;code&gt;updateGrammar&lt;/code&gt;, when executed from the glslang subdirectory of the glslang repository.&lt;/p&gt; &#xA;&lt;h3&gt;Building to WASM for the Web and Node&lt;/h3&gt; &#xA;&lt;h3&gt;Building a standalone JS/WASM library for the Web and Node&lt;/h3&gt; &#xA;&lt;p&gt;Use the steps in &lt;a href=&#34;https://raw.githubusercontent.com/KhronosGroup/glslang/main/#build-steps&#34;&gt;Build Steps&lt;/a&gt;, with the following notes/exceptions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;emsdk&lt;/code&gt; needs to be present in your executable search path, &lt;em&gt;PATH&lt;/em&gt; for Bash-like environments: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://emscripten.org/docs/getting_started/downloads.html#sdk-download-and-install&#34;&gt;Instructions located here&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Wrap cmake call: &lt;code&gt;emcmake cmake&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Set &lt;code&gt;-DENABLE_OPT=OFF&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Set &lt;code&gt;-DENABLE_HLSL=OFF&lt;/code&gt; if HLSL is not needed.&lt;/li&gt; &#xA; &lt;li&gt;For a standalone JS/WASM library, turn on &lt;code&gt;-DENABLE_GLSLANG_JS=ON&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;To get a fully minimized build, make sure to use &lt;code&gt;brotli&lt;/code&gt; to compress the .js and .wasm files&lt;/li&gt; &#xA; &lt;li&gt;Note that by default, Emscripten allocates a very small stack size, which may cause stack overflows when compiling large shaders. Use the &lt;a href=&#34;https://emscripten.org/docs/tools_reference/settings_reference.html?highlight=environment#stack-size&#34;&gt;STACK_SIZE&lt;/a&gt; compiler setting to increase the stack size.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;emcmake cmake -DCMAKE_BUILD_TYPE=Release -DENABLE_GLSLANG_JS=ON \&#xA;    -DENABLE_HLSL=OFF -DENABLE_OPT=OFF ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building glslang - Using vcpkg&lt;/h2&gt; &#xA;&lt;p&gt;You can download and install glslang using the &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt; dependency manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;./vcpkg install glslang&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The glslang port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;create an issue or pull request&lt;/a&gt; on the vcpkg repository.&lt;/p&gt; &#xA;&lt;h2&gt;Testing&lt;/h2&gt; &#xA;&lt;p&gt;Right now, there are two test harnesses existing in glslang: one is &lt;a href=&#34;https://raw.githubusercontent.com/KhronosGroup/glslang/main/gtests/&#34;&gt;Google Test&lt;/a&gt;, one is the &lt;a href=&#34;https://raw.githubusercontent.com/KhronosGroup/glslang/main/Test/runtests&#34;&gt;&lt;code&gt;runtests&lt;/code&gt; script&lt;/a&gt;. The former runs unit tests and single-shader single-threaded integration tests, while the latter runs multiple-shader linking tests and multi-threaded tests.&lt;/p&gt; &#xA;&lt;p&gt;Tests may erroneously fail or pass if using &lt;code&gt;ALLOW_EXTERNAL_SPIRV_TOOLS&lt;/code&gt; with any commit other than the one specified in &lt;code&gt;known_good.json&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Running tests&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/KhronosGroup/glslang/main/Test/runtests&#34;&gt;&lt;code&gt;runtests&lt;/code&gt; script&lt;/a&gt; requires compiled binaries to be installed into &lt;code&gt;$BUILD_DIR/install&lt;/code&gt;. Please make sure you have supplied the correct configuration to CMake (using &lt;code&gt;-DCMAKE_INSTALL_PREFIX&lt;/code&gt;) when building; otherwise, you may want to modify the path in the &lt;code&gt;runtests&lt;/code&gt; script.&lt;/p&gt; &#xA;&lt;p&gt;Running Google Test-backed tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd $BUILD_DIR&#xA;&#xA;# for Linux:&#xA;ctest&#xA;&#xA;# for Windows:&#xA;ctest -C {Debug|Release|RelWithDebInfo|MinSizeRel}&#xA;&#xA;# or, run the test binary directly&#xA;# (which gives more fine-grained control like filtering):&#xA;&amp;lt;dir-to-glslangtests-in-build-dir&amp;gt;/glslangtests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running &lt;code&gt;runtests&lt;/code&gt; script-backed tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd $SOURCE_DIR/Test &amp;amp;&amp;amp; ./runtests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If some tests fail with validation errors, there may be a mismatch between the version of &lt;code&gt;spirv-val&lt;/code&gt; on the system and the version of glslang. In this case, it is necessary to run &lt;code&gt;update_glslang_sources.py&lt;/code&gt;. See &#34;Check-Out External Projects&#34; above for more details.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing tests&lt;/h3&gt; &#xA;&lt;p&gt;Test results should always be included with a pull request that modifies functionality.&lt;/p&gt; &#xA;&lt;p&gt;If you are writing unit tests, please use the Google Test framework and place the tests under the &lt;code&gt;gtests/&lt;/code&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;Integration tests are placed in the &lt;code&gt;Test/&lt;/code&gt; directory. It contains test input and a subdirectory &lt;code&gt;baseResults/&lt;/code&gt; that contains the expected results of the tests. Both the tests and &lt;code&gt;baseResults/&lt;/code&gt; are under source-code control.&lt;/p&gt; &#xA;&lt;p&gt;Google Test runs those integration tests by reading the test input, compiling them, and then compare against the expected results in &lt;code&gt;baseResults/&lt;/code&gt;. The integration tests to run via Google Test is registered in various &lt;code&gt;gtests/*.FromFile.cpp&lt;/code&gt; source files. &lt;code&gt;glslangtests&lt;/code&gt; provides a command-line option &lt;code&gt;--update-mode&lt;/code&gt;, which, if supplied, will overwrite the golden files under the &lt;code&gt;baseResults/&lt;/code&gt; directory with real output from that invocation. For more information, please check &lt;code&gt;gtests/&lt;/code&gt; directory&#39;s &lt;a href=&#34;https://raw.githubusercontent.com/KhronosGroup/glslang/main/gtests/README.md&#34;&gt;README&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For the &lt;code&gt;runtests&lt;/code&gt; script, it will generate current results in the &lt;code&gt;localResults/&lt;/code&gt; directory and &lt;code&gt;diff&lt;/code&gt; them against the &lt;code&gt;baseResults/&lt;/code&gt;. When you want to update the tracked test results, they need to be copied from &lt;code&gt;localResults/&lt;/code&gt; to &lt;code&gt;baseResults/&lt;/code&gt;. This can be done by the &lt;code&gt;bump&lt;/code&gt; shell script.&lt;/p&gt; &#xA;&lt;p&gt;You can add your own private list of tests, not tracked publicly, by using &lt;code&gt;localtestlist&lt;/code&gt; to list non-tracked tests. This is automatically read by &lt;code&gt;runtests&lt;/code&gt; and included in the &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;bump&lt;/code&gt; process.&lt;/p&gt; &#xA;&lt;h2&gt;Programmatic Interfaces&lt;/h2&gt; &#xA;&lt;p&gt;Another piece of software can programmatically translate shaders to an AST using one of two different interfaces:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A new C++ class-oriented interface, or&lt;/li&gt; &#xA; &lt;li&gt;The original C functional interface&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;main()&lt;/code&gt; in &lt;code&gt;StandAlone/StandAlone.cpp&lt;/code&gt; shows examples using both styles.&lt;/p&gt; &#xA;&lt;h3&gt;C++ Class Interface (new, preferred)&lt;/h3&gt; &#xA;&lt;p&gt;This interface is in roughly the last 1/3 of &lt;code&gt;ShaderLang.h&lt;/code&gt;. It is in the glslang namespace and contains the following, here with suggested calls for generating SPIR-V:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cxx&#34;&gt;const char* GetEsslVersionString();&#xA;const char* GetGlslVersionString();&#xA;bool InitializeProcess();&#xA;void FinalizeProcess();&#xA;&#xA;class TShader&#xA;    setStrings(...);&#xA;    setEnvInput(EShSourceHlsl or EShSourceGlsl, stage,  EShClientVulkan or EShClientOpenGL, 100);&#xA;    setEnvClient(EShClientVulkan or EShClientOpenGL, EShTargetVulkan_1_0 or EShTargetVulkan_1_1 or EShTargetOpenGL_450);&#xA;    setEnvTarget(EShTargetSpv, EShTargetSpv_1_0 or EShTargetSpv_1_3);&#xA;    bool parse(...);&#xA;    const char* getInfoLog();&#xA;&#xA;class TProgram&#xA;    void addShader(...);&#xA;    bool link(...);&#xA;    const char* getInfoLog();&#xA;    Reflection queries&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For just validating (not generating code), substitute these calls:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cxx&#34;&gt;    setEnvInput(EShSourceHlsl or EShSourceGlsl, stage,  EShClientNone, 0);&#xA;    setEnvClient(EShClientNone, 0);&#xA;    setEnvTarget(EShTargetNone, 0);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;code&gt;ShaderLang.h&lt;/code&gt; and the usage of it in &lt;code&gt;StandAlone/StandAlone.cpp&lt;/code&gt; for more details. There is a block comment giving more detail above the calls for &lt;code&gt;setEnvInput, setEnvClient, and setEnvTarget&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;C Functional Interface (original)&lt;/h3&gt; &#xA;&lt;p&gt;This interface is in roughly the first 2/3 of &lt;code&gt;ShaderLang.h&lt;/code&gt;, and referred to as the &lt;code&gt;Sh*()&lt;/code&gt; interface, as all the entry points start &lt;code&gt;Sh&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;Sh*()&lt;/code&gt; interface takes a &#34;compiler&#34; call-back object, which it calls after building call back that is passed the AST and can then execute a back end on it.&lt;/p&gt; &#xA;&lt;p&gt;The following is a simplified resulting run-time call stack:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ShCompile(shader, compiler) -&amp;gt; compiler(AST) -&amp;gt; &amp;lt;back end&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In practice, &lt;code&gt;ShCompile()&lt;/code&gt; takes shader strings, default version, and warning/error and other options for controlling compilation.&lt;/p&gt; &#xA;&lt;h3&gt;C Functional Interface (new)&lt;/h3&gt; &#xA;&lt;p&gt;This interface is located &lt;code&gt;glslang_c_interface.h&lt;/code&gt; and exposes functionality similar to the C++ interface. The following snippet is a complete example showing how to compile GLSL into SPIR-V 1.5 for Vulkan 1.2.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;glslang/Include/glslang_c_interface.h&amp;gt;&#xA;&#xA;// Required for use of glslang_default_resource&#xA;#include &amp;lt;glslang/Public/resource_limits_c.h&amp;gt;&#xA;&#xA;typedef struct SpirVBinary {&#xA;    uint32_t *words; // SPIR-V words&#xA;    int size; // number of words in SPIR-V binary&#xA;} SpirVBinary;&#xA;&#xA;SpirVBinary compileShaderToSPIRV_Vulkan(glslang_stage_t stage, const char* shaderSource, const char* fileName) {&#xA;    const glslang_input_t input = {&#xA;        .language = GLSLANG_SOURCE_GLSL,&#xA;        .stage = stage,&#xA;        .client = GLSLANG_CLIENT_VULKAN,&#xA;        .client_version = GLSLANG_TARGET_VULKAN_1_2,&#xA;        .target_language = GLSLANG_TARGET_SPV,&#xA;        .target_language_version = GLSLANG_TARGET_SPV_1_5,&#xA;        .code = shaderSource,&#xA;        .default_version = 100,&#xA;        .default_profile = GLSLANG_NO_PROFILE,&#xA;        .force_default_version_and_profile = false,&#xA;        .forward_compatible = false,&#xA;        .messages = GLSLANG_MSG_DEFAULT_BIT,&#xA;        .resource = glslang_default_resource(),&#xA;    };&#xA;&#xA;    glslang_shader_t* shader = glslang_shader_create(&amp;amp;input);&#xA;&#xA;    SpirVBinary bin = {&#xA;        .words = NULL,&#xA;        .size = 0,&#xA;    };&#xA;    if (!glslang_shader_preprocess(shader, &amp;amp;input))&#x9;{&#xA;        printf(&#34;GLSL preprocessing failed %s\n&#34;, fileName);&#xA;        printf(&#34;%s\n&#34;, glslang_shader_get_info_log(shader));&#xA;        printf(&#34;%s\n&#34;, glslang_shader_get_info_debug_log(shader));&#xA;        printf(&#34;%s\n&#34;, input.code);&#xA;        glslang_shader_delete(shader);&#xA;        return bin;&#xA;    }&#xA;&#xA;    if (!glslang_shader_parse(shader, &amp;amp;input)) {&#xA;        printf(&#34;GLSL parsing failed %s\n&#34;, fileName);&#xA;        printf(&#34;%s\n&#34;, glslang_shader_get_info_log(shader));&#xA;        printf(&#34;%s\n&#34;, glslang_shader_get_info_debug_log(shader));&#xA;        printf(&#34;%s\n&#34;, glslang_shader_get_preprocessed_code(shader));&#xA;        glslang_shader_delete(shader);&#xA;        return bin;&#xA;    }&#xA;&#xA;    glslang_program_t* program = glslang_program_create();&#xA;    glslang_program_add_shader(program, shader);&#xA;&#xA;    if (!glslang_program_link(program, GLSLANG_MSG_SPV_RULES_BIT | GLSLANG_MSG_VULKAN_RULES_BIT)) {&#xA;        printf(&#34;GLSL linking failed %s\n&#34;, fileName);&#xA;        printf(&#34;%s\n&#34;, glslang_program_get_info_log(program));&#xA;        printf(&#34;%s\n&#34;, glslang_program_get_info_debug_log(program));&#xA;        glslang_program_delete(program);&#xA;        glslang_shader_delete(shader);&#xA;        return bin;&#xA;    }&#xA;&#xA;    glslang_program_SPIRV_generate(program, stage);&#xA;&#xA;    bin.size = glslang_program_SPIRV_get_size(program);&#xA;    bin.words = malloc(bin.size * sizeof(uint32_t));&#xA;    glslang_program_SPIRV_get(program, bin.words);&#xA;&#xA;    const char* spirv_messages = glslang_program_SPIRV_get_messages(program);&#xA;    if (spirv_messages)&#xA;        printf(&#34;(%s) %s\b&#34;, fileName, spirv_messages);&#xA;&#xA;    glslang_program_delete(program);&#xA;    glslang_shader_delete(shader);&#xA;&#xA;    return bin;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Basic Internal Operation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Initial lexical analysis is done by the preprocessor in &lt;code&gt;MachineIndependent/Preprocessor&lt;/code&gt;, and then refined by a GLSL scanner in &lt;code&gt;MachineIndependent/Scan.cpp&lt;/code&gt;. There is currently no use of flex.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Code is parsed using bison on &lt;code&gt;MachineIndependent/glslang.y&lt;/code&gt; with the aid of a symbol table and an AST. The symbol table is not passed on to the back-end; the intermediate representation stands on its own. The tree is built by the grammar productions, many of which are offloaded into &lt;code&gt;ParseHelper.cpp&lt;/code&gt;, and by &lt;code&gt;Intermediate.cpp&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The intermediate representation is very high-level, and represented as an in-memory tree. This serves to lose no information from the original program, and to have efficient transfer of the result from parsing to the back-end. In the AST, constants are propagated and folded, and a very small amount of dead code is eliminated.&lt;/p&gt; &lt;p&gt;To aid linking and reflection, the last top-level branch in the AST lists all global symbols.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The primary algorithm of the back-end compiler is to traverse the tree (high-level intermediate representation), and create an internal object code representation. There is an example of how to do this in &lt;code&gt;MachineIndependent/intermOut.cpp&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Reduction of the tree to a linear byte-code style low-level intermediate representation is likely a good way to generate fully optimized code.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There is currently some dead old-style linker-type code still lying around.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Memory pool: parsing uses types derived from C++ &lt;code&gt;std&lt;/code&gt; types, using a custom allocator that puts them in a memory pool. This makes allocation of individual container/contents just few cycles and deallocation free. This pool is popped after the AST is made and processed.&lt;/p&gt; &lt;p&gt;The use is simple: if you are going to call &lt;code&gt;new&lt;/code&gt;, there are three cases:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;the object comes from the pool (its base class has the macro &lt;code&gt;POOL_ALLOCATOR_NEW_DELETE&lt;/code&gt; in it) and you do not have to call &lt;code&gt;delete&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;it is a &lt;code&gt;TString&lt;/code&gt;, in which case call &lt;code&gt;NewPoolTString()&lt;/code&gt;, which gets it from the pool, and there is no corresponding &lt;code&gt;delete&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;the object does not come from the pool, and you have to do normal C++ memory management of what you &lt;code&gt;new&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Features can be protected by version/extension/stage/profile: See the comment in &lt;code&gt;glslang/MachineIndependent/Versions.cpp&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>