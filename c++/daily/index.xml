<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-12T01:28:40Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>raspberrypi/picotool</title>
    <updated>2024-08-12T01:28:40Z</updated>
    <id>tag:github.com,2024-08-12:/raspberrypi/picotool</id>
    <link href="https://github.com/raspberrypi/picotool" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;You need to set PICO_SDK_PATH in the environment, or pass it to cmake with &lt;code&gt;-DPICO_SDK_PATH=/path/to/pico-sdk&lt;/code&gt;. To use features such as signing or hashing, you will need to make sure the mbedtls submodule in the SDK is checked out - this can be done by running this from your SDK directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;git submodule update --init lib/mbedtls&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You also need to install &lt;code&gt;libusb-1.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Linux / macOS&lt;/h3&gt; &#xA;&lt;p&gt;Use your favorite package tool to install dependencies. For example, on Ubuntu:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;sudo apt install build-essential pkg-config libusb-1.0-0-dev cmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then simply build like a normal CMake project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;mkdir build&#xA;cd build&#xA;cmake ..&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Linux you can add udev rules in order to run picotool without sudo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;sudo cp udev/99-picotool.rules /etc/udev/rules.d/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;h5&gt;For Windows without MinGW&lt;/h5&gt; &#xA;&lt;p&gt;Download libUSB from here &lt;a href=&#34;https://libusb.info/&#34;&gt;https://libusb.info/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;set LIBUSB_ROOT environment variable to the install directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;mkdir build&#xA;cd build&#xA;cmake -G &#34;NMake Makefiles&#34; ..&#xA;nmake&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;For Windows with MinGW in WSL&lt;/h5&gt; &#xA;&lt;p&gt;Download libUSB from here &lt;a href=&#34;https://libusb.info/&#34;&gt;https://libusb.info/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;set LIBUSB_ROOT environment variable to the install directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;mkdir build&#xA;cd build&#xA;cmake ..&#xA;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;For Windows with MinGW in MSYS2:&lt;/h5&gt; &#xA;&lt;p&gt;No need to download libusb separately or set &lt;code&gt;LIBUSB_ROOT&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;pacman -S $MINGW_PACKAGE_PREFIX-{toolchain,cmake,libusb}&#xA;mkdir build&#xA;cd build&#xA;MSYS2_ARG_CONV_EXCL=- cmake .. -G&#34;MSYS Makefiles&#34; -DCMAKE_INSTALL_PREFIX=$MINGW_PREFIX&#xA;make&#xA;make install DESTDIR=/  # optional&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage by the Raspberry Pi Pico SDK&lt;/h2&gt; &#xA;&lt;p&gt;The Raspberry Pi Pico SDK (&lt;a href=&#34;https://github.com/raspberrypi/pico-sdk&#34;&gt;pico-sdk&lt;/a&gt;) version 2.0.0 and above, uses &lt;code&gt;picotool&lt;/code&gt; to do the ELF-&amp;gt;UF2 conversion previously handled by the &lt;code&gt;elf2uf2&lt;/code&gt; tool in the SDK. &lt;code&gt;picootol&lt;/code&gt; is also used by the SDK for hashing and/or signing binaries.&lt;/p&gt; &#xA;&lt;p&gt;Whilst the SDK can download picotool on its own per project, if you have multiple projects or build configurations, it is preferable to install a single copy of &lt;code&gt;picotool&lt;/code&gt; locally.&lt;/p&gt; &#xA;&lt;p&gt;This can be done most simply with &lt;code&gt;make install&lt;/code&gt;; the SDK will use this installed version by default.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively you can install in a custom path via:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR -DPICOTOOL_FLAT_INSTALL=1 ..&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In order for the SDK to find &lt;code&gt;picotool&lt;/code&gt; in this custom path, you will need to set the &lt;code&gt;picotool_DIR&lt;/code&gt; variable in your project, either by passing to &lt;code&gt;-Dpicotool_DIR=$MY_INSTALL_DIR/picotool&lt;/code&gt; to your SDK &lt;code&gt;cmake&lt;/code&gt; command, or by adding&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-CMake&#34;&gt;set(picotool_DIR $MY_INSTALL_DIR/picotool)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your CMakeLists.txt file.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;picotool&lt;/code&gt; is a tool for working with RP2040/RP2350 binaries, and interacting with RP2040/RP2350 devices when they are in BOOTSEL mode. (As of version 1.1 of &lt;code&gt;picotool&lt;/code&gt; it is also possible to interact with devices that are not in BOOTSEL mode, but are using USB stdio support from the Raspberry Pi Pico SDK by using the &lt;code&gt;-f&lt;/code&gt; argument of &lt;code&gt;picotool&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Note for additional documentation see &lt;a href=&#34;https://rptl.io/pico-get-started&#34;&gt;https://rptl.io/pico-get-started&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ picotool help&#xA;PICOTOOL:&#xA;Tool for interacting with RP2040/RP2350 device(s) in BOOTSEL mode, or with an RP2040/RP2350 binary&#xA;&#xA;SYNOPSIS:&#xA;    picotool info [-b] [-p] [-d] [--debug] [-l] [-a] [device-selection]&#xA;    picotool info [-b] [-p] [-d] [--debug] [-l] [-a] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;]&#xA;    picotool config [-s &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;] [-g &amp;lt;group&amp;gt;] [device-selection]&#xA;    picotool config [-s &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;] [-g &amp;lt;group&amp;gt;] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;]&#xA;    picotool load [-p] [-n] [-N] [-u] [-v] [-x] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [-o &amp;lt;offset&amp;gt;] [device-selection]&#xA;    picotool encrypt [--quiet] [--verbose] [--hash] [--sign] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] [-o &amp;lt;offset&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;aes_key&amp;gt; [-t &amp;lt;type&amp;gt;] [&amp;lt;signing_key&amp;gt;] [-t &amp;lt;type&amp;gt;]&#xA;    picotool seal [--quiet] [--verbose] [--hash] [--sign] [--clear] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] [-o &amp;lt;offset&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] [&amp;lt;key&amp;gt;] [-t &amp;lt;type&amp;gt;] [&amp;lt;otp&amp;gt;] [-t &amp;lt;type&amp;gt;] [--major &amp;lt;major&amp;gt;] [--minor &amp;lt;minor&amp;gt;] [--rollback &amp;lt;rollback&amp;gt; [&amp;lt;rows&amp;gt;..]]&#xA;    picotool link [--quiet] [--verbose] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;infile1&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;infile2&amp;gt; [-t &amp;lt;type&amp;gt;] [&amp;lt;infile3&amp;gt;] [-t &amp;lt;type&amp;gt;] [-p] &amp;lt;pad&amp;gt;&#xA;    picotool save [-p] [device-selection]&#xA;    picotool save -a [device-selection]&#xA;    picotool save -r &amp;lt;from&amp;gt; &amp;lt;to&amp;gt; [device-selection]&#xA;    picotool verify [device-selection]&#xA;    picotool reboot [-a] [-u] [-g &amp;lt;partition&amp;gt;] [-c &amp;lt;cpu&amp;gt;] [device-selection]&#xA;    picotool otp list|get|set|load|dump|permissions|white-label&#xA;    picotool partition info|create&#xA;    picotool uf2 info|convert&#xA;    picotool version [-s] [&amp;lt;version&amp;gt;]&#xA;    picotool coprodis [--quiet] [--verbose] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;]&#xA;    picotool help [&amp;lt;cmd&amp;gt;]&#xA;&#xA;COMMANDS:&#xA;    info        Display information from the target device(s) or file.&#xA;                Without any arguments, this will display basic information for all connected RP2040 devices in BOOTSEL mode&#xA;    config      Display or change program configuration settings from the target device(s) or file.&#xA;    load        Load the program / memory range stored in a file onto the device.&#xA;    encrypt     Encrypt the program.&#xA;    seal        Add final metadata to a binary, optionally including a hash and/or signature.&#xA;    link        Link multiple binaries into one block loop.&#xA;    save        Save the program / memory stored in flash on the device to a file.&#xA;    verify      Check that the device contents match those in the file.&#xA;    reboot      Reboot the device&#xA;    otp         Commands related to the RP2350 OTP (One-Time-Programmable) Memory&#xA;    partition   Commands related to RP2350 Partition Tables&#xA;    uf2         Commands related to UF2 creation and status&#xA;    version     Display picotool version&#xA;    coprodis    Post-process coprocessor instructions in dissassembly files.&#xA;    help        Show general help or help for a specific command&#xA;&#xA;Use &#34;picotool help &amp;lt;cmd&amp;gt;&#34; for more info&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note commands that aren&#39;t acting on files require a device in BOOTSEL mode to be connected.&lt;/p&gt; &#xA;&lt;h2&gt;info&lt;/h2&gt; &#xA;&lt;p&gt;The is &lt;em&gt;Binary Information&lt;/em&gt; support in the SDK which allows for easily storing compact information that &lt;code&gt;picotool&lt;/code&gt; can find (See Binary Info section below). The info command is for reading this information.&lt;/p&gt; &#xA;&lt;p&gt;The information can be either read from one or more connected devices in BOOTSEL mode, or from a file. This file can be an ELF, a UF2 or a BIN file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ picotool help info&#xA;INFO:&#xA;    Display information from the target device(s) or file.&#xA;    Without any arguments, this will display basic information for all connected RP2040 devices in BOOTSEL mode&#xA;&#xA;SYNOPSIS:&#xA;    picotool info [-b] [-p] [-d] [--debug] [-l] [-a] [device-selection]&#xA;    picotool info [-b] [-p] [-d] [--debug] [-l] [-a] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;]&#xA;&#xA;OPTIONS:&#xA;    Information to display&#xA;        -b, --basic&#xA;            Include basic information. This is the default&#xA;        -p, --pins&#xA;            Include pin information&#xA;        -d, --device&#xA;            Include device information&#xA;        --debug&#xA;            Include device debug information&#xA;        -l, --build&#xA;            Include build attributes&#xA;        -a, --all&#xA;            Include all information&#xA;&#xA;TARGET SELECTION:&#xA;    To target one or more connected RP2040 device(s) in BOOTSEL mode (the default)&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;    To target a file&#xA;        &amp;lt;filename&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the -f arguments vary slightly for Windows vs macOS / Unix platforms.&lt;/p&gt; &#xA;&lt;p&gt;e.g.&lt;/p&gt; &#xA;&lt;p&gt;$ picotool info Program Information name: hello_world features: stdout to UART&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;&#xA;$ picotool info -a&#xA;Program Information&#xA; name:          hello_world&#xA; features:      stdout to UART&#xA; binary start:  0x10000000&#xA; binary end:    0x1000606c&#xA;&#xA;Fixed Pin Information&#xA; 20:  UART1 TX&#xA; 21:  UART1 RX&#xA;&#xA;Build Information&#xA; build date:        Dec 31 2020&#xA; build attributes:  Debug build&#xA;&#xA;Device Information&#xA; flash size:   2048K&#xA; ROM version:  2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;$ picotool info -bp Program Information name: hello_world features: stdout to UART&lt;/p&gt; &#xA;&lt;p&gt;Fixed Pin Information 20: UART1 TX 21: UART1 RX&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#xA;&#xA;$ picotool info -a lcd_1602_i2c.uf2&#xA;File lcd_1602_i2c.uf2:&#xA;&#xA;Program Information&#xA; name:          lcd_1602_i2c&#xA; web site:      https://github.com/raspberrypi/pico-examples/tree/HEAD/i2c/lcd_1602_i2c&#xA; binary start:  0x10000000&#xA; binary end:    0x10003c1c&#xA;&#xA;Fixed Pin Information&#xA; 4:  I2C0 SDA&#xA; 5:  I2C0 SCL&#xA;&#xA;Build Information&#xA; build date:  Dec 31 2020&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;config&lt;/h2&gt; &#xA;&lt;p&gt;Config allows you to configure the binary info on a device, if it is configurable. Specifically, you can configure &lt;code&gt;bi_ptr_int32&lt;/code&gt; and &lt;code&gt;bi_ptr_string&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help config&#xA;CONFIG:&#xA;    Display or change program configuration settings from the target device(s) or file.&#xA;&#xA;SYNOPSIS:&#xA;    picotool config [-s &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;] [-g &amp;lt;group&amp;gt;] [device-selection]&#xA;    picotool config [-s &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;] [-g &amp;lt;group&amp;gt;] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;]&#xA;&#xA;OPTIONS:&#xA;        &amp;lt;key&amp;gt;&#xA;            Variable name&#xA;        &amp;lt;value&amp;gt;&#xA;            New value&#xA;        -g &amp;lt;group&amp;gt;&#xA;            Filter by feature group&#xA;&#xA;TARGET SELECTION:&#xA;    To target one or more connected RP2040 device(s) in BOOTSEL mode (the default)&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;    To target a file&#xA;        &amp;lt;filename&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool config&#xA;n = 5&#xA;name = &#34;Billy&#34;&#xA;nonconst_pins:&#xA; default_pin = 3&#xA; default_name = &#34;My First Pin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool config -g nonconst_pins&#xA;nonconst_pins:&#xA; default_pin = 3&#xA; default_name = &#34;My First Pin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool config -s name Jane&#xA;name = &#34;Billy&#34;&#xA;setting name -&amp;gt; &#34;Jane&#34;&#xA;&#xA;$ picotool config&#xA;n = 5&#xA;name = &#34;Jane&#34;&#xA;nonconst_pins:&#xA; default_pin = 3&#xA; default_name = &#34;My First Pin&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;load&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;load&lt;/code&gt; allows you to write data from a file onto the device (either writing to flash, or to RAM)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help load&#xA;LOAD:&#xA;    Load the program / memory range stored in a file onto the device.&#xA;&#xA;SYNOPSIS:&#xA;    picotool load [--ignore-partitions] [--family &amp;lt;family_id&amp;gt;] [-p &amp;lt;partition&amp;gt;] [-n] [-N] [-u] [-v] [-x] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [-o&#xA;                &amp;lt;offset&amp;gt;] [device-selection]&#xA;&#xA;OPTIONS:&#xA;    Post load actions&#xA;        --ignore-partitions&#xA;            When writing flash data, ignore the partition table and write to absolute space&#xA;        --family&#xA;            Specify the family ID of the file to load&#xA;        &amp;lt;family_id&amp;gt;&#xA;            family id to use for load&#xA;        -p, --partition&#xA;            Specify the partition to load into&#xA;        &amp;lt;partition&amp;gt;&#xA;            partition to load into&#xA;        -n, --no-overwrite&#xA;            When writing flash data, do not overwrite an existing program in flash. If picotool cannot determine the size/presence of the&#xA;            program in flash, the command fails&#xA;        -N, --no-overwrite-unsafe&#xA;            When writing flash data, do not overwrite an existing program in flash. If picotool cannot determine the size/presence of the&#xA;            program in flash, the load continues anyway&#xA;        -u, --update&#xA;            Skip writing flash sectors that already contain identical data&#xA;        -v, --verify&#xA;            Verify the data was written correctly&#xA;        -x, --execute&#xA;            Attempt to execute the downloaded file as a program after the load&#xA;    File to load from&#xA;        &amp;lt;filename&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    BIN file options&#xA;        -o, --offset&#xA;            Specify the load address for a BIN file&#xA;        &amp;lt;offset&amp;gt;&#xA;            Load offset (memory address; default 0x10000000)&#xA;    Target device selection&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool load blink.uf2&#xA;Loading into Flash: [==============================]  100%&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;save&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;save&lt;/code&gt; allows you to save a range of RAM, the program in flash, or an explicit range of flash from the device to a BIN file or a UF2 file.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help save&#xA;SAVE:&#xA;    Save the program / memory stored in flash on the device to a file.&#xA;&#xA;SYNOPSIS:&#xA;    picotool save [-p] [device-selection]&#xA;    picotool save -a [device-selection]&#xA;    picotool save -r &amp;lt;from&amp;gt; &amp;lt;to&amp;gt; [device-selection]&#xA;&#xA;OPTIONS:&#xA;    Selection of data to save&#xA;        -p, --program&#xA;            Save the installed program only. This is the default&#xA;        -a, --all&#xA;            Save all of flash memory&#xA;        -r, --range&#xA;            Save a range of memory. Note that UF2s always store complete 256 byte-aligned blocks of 256 bytes, and the range is expanded&#xA;            accordingly&#xA;        &amp;lt;from&amp;gt;&#xA;            The lower address bound in hex&#xA;        &amp;lt;to&amp;gt;&#xA;            The upper address bound in hex&#xA;    Source device selection&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;    File to save to&#xA;        &amp;lt;filename&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;e.g. first looking at what is on the device...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool info&#xA;Program Information&#xA;name:      lcd_1602_i2c&#xA;web site:  https://github.com/raspberrypi/pico-examples/tree/HEAD/i2c/lcd_1602_i2c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... saving it to a file ...&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool save spoon.uf2&#xA;Saving file: [==============================]  100%&#xA;Wrote 51200 bytes to spoon.uf2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... and looking at the file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool info spoon.uf2&#xA;File spoon.uf2:&#xA;Program Information&#xA;name:      lcd_1602_i2c&#xA;web site:  https://github.com/raspberrypi/pico-examples/tree/HEAD/i2c/lcd_1602_i2c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;seal&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;seal&lt;/code&gt; allows you to sign and/or hash a binary to run on RP2350.&lt;/p&gt; &#xA;&lt;p&gt;By default, it will just sign the binary, but this can be configured with the &lt;code&gt;--hash&lt;/code&gt; and &lt;code&gt;--no-sign&lt;/code&gt; arguments.&lt;/p&gt; &#xA;&lt;p&gt;Your signing key must be for the &lt;em&gt;secp256k1&lt;/em&gt; curve, in PEM format. You can create a .PEM file with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;openssl ecparam -name secp256k1 -genkey -out private.pem&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help seal&#xA;SEAL:&#xA;    Add final metadata to a binary, optionally including a hash and/or signature.&#xA;&#xA;SYNOPSIS:&#xA;    picotool seal [--quiet] [--verbose] [--hash] [--sign] [--clear] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] [-o &amp;lt;offset&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] [&amp;lt;key&amp;gt;] [-t&#xA;                &amp;lt;type&amp;gt;] [&amp;lt;otp&amp;gt;] [-t &amp;lt;type&amp;gt;] [--major &amp;lt;major&amp;gt;] [--minor &amp;lt;minor&amp;gt;] [--rollback &amp;lt;rollback&amp;gt; [&amp;lt;rows&amp;gt;..]]&#xA;&#xA;OPTIONS:&#xA;        --quiet&#xA;            Don&#39;t print any output&#xA;        --verbose&#xA;            Print verbose output&#xA;        --major &amp;lt;major&amp;gt;&#xA;            Add Major Version&#xA;        --minor &amp;lt;minor&amp;gt;&#xA;            Add Minor Version&#xA;        --rollback &amp;lt;rollback&amp;gt; [&amp;lt;rows&amp;gt;..]&#xA;            Add Rollback Version&#xA;    Configuration&#xA;        --hash&#xA;            Hash the file&#xA;        --sign&#xA;            Sign the file&#xA;        --clear&#xA;            Clear all of SRAM on load&#xA;    File to load from&#xA;        &amp;lt;infile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    BIN file options&#xA;        -o, --offset&#xA;            Specify the load address for a BIN file&#xA;        &amp;lt;offset&amp;gt;&#xA;            Load offset (memory address; default 0x10000000)&#xA;    File to save to&#xA;        &amp;lt;outfile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    Key file&#xA;        &amp;lt;key&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (pem) explicitly, ignoring file extension&#xA;    File to save OTP to (will edit existing file if it exists)&#xA;        &amp;lt;otp&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (json) explicitly, ignoring file extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;encrypt&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;encrypt&lt;/code&gt; allows you to encrypt and sign a binary for use on the RP2350. By default, it will sign the encrypted binary, but that can be configured similarly to &lt;code&gt;picotool sign&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The encrypted binary will have the following structure:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;First metadata block (5 words)&lt;/li&gt; &#xA; &lt;li&gt;IV (4 words)&lt;/li&gt; &#xA; &lt;li&gt;Encrypted Binary&lt;/li&gt; &#xA; &lt;li&gt;Padding to ensure the encrypted length is a multiple of 4 words&lt;/li&gt; &#xA; &lt;li&gt;Signature metadata block&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The AES key must be provided as a .bin file of the 256 bit AES key to be used for encryption.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help encrypt&#xA;ENCRYPT:&#xA;    Encrypt the program.&#xA;&#xA;SYNOPSIS:&#xA;    picotool encrypt [--quiet] [--verbose] [--hash] [--sign] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] [-o &amp;lt;offset&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;aes_key&amp;gt; [-t &amp;lt;type&amp;gt;]&#xA;                [&amp;lt;signing_key&amp;gt;] [-t &amp;lt;type&amp;gt;]&#xA;&#xA;OPTIONS:&#xA;        --quiet&#xA;            Don&#39;t print any output&#xA;        --verbose&#xA;            Print verbose output&#xA;    Signing Configuration&#xA;        --hash&#xA;            Hash the encrypted file&#xA;        --sign&#xA;            Sign the encrypted file&#xA;    File to load from&#xA;        &amp;lt;infile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    BIN file options&#xA;        -o, --offset&#xA;            Specify the load address for a BIN file&#xA;        &amp;lt;offset&amp;gt;&#xA;            Load offset (memory address; default 0x10000000)&#xA;    File to save to&#xA;        &amp;lt;outfile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    AES Key&#xA;        &amp;lt;aes_key&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (bin) explicitly, ignoring file extension&#xA;    Signing Key file&#xA;        &amp;lt;signing_key&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (pem) explicitly, ignoring file extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;partition&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;partition&lt;/code&gt; commands allow you to interact with the partition tables on RP2350 devices, and also create them.&lt;/p&gt; &#xA;&lt;h3&gt;info&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help partition info&#xA;PARTITION INFO:&#xA;    Print the device&#39;s partition table.&#xA;&#xA;SYNOPSIS:&#xA;    picotool partition info -m &amp;lt;family_id&amp;gt; [device-selection]&#xA;&#xA;OPTIONS:&#xA;        -m &amp;lt;family_id&amp;gt; [device-selection]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool partition info&#xA;un-partitioned_space :  S(rw) NSBOOT(rw) NS(rw), uf2 { absolute }&#xA;partitions:&#xA;  0(A)       00002000-&amp;gt;00201000 S(rw) NSBOOT(rw) NS(rw), id=0000000000000000, &#34;A&#34;, uf2 { rp2350-arm-s, rp2350-riscv }, arm_boot 1, riscv_boot 1&#xA;  1(B w/ 0)  00201000-&amp;gt;00400000 S(rw) NSBOOT(rw) NS(rw), id=0000000000000001, &#34;B&#34;, uf2 { rp2350-arm-s, rp2350-riscv }, arm_boot 1, riscv_boot 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool partition info -m rp2350-arm-s&#xA;un-partitioned_space :  S(rw) NSBOOT(rw) NS(rw), uf2 { absolute }&#xA;partitions:&#xA;  0(A)       00002000-&amp;gt;00201000 S(rw) NSBOOT(rw) NS(rw), id=0000000000000000, &#34;A&#34;, uf2 { rp2350-arm-s, rp2350-riscv }, arm_boot 1, riscv_boot 1&#xA;  1(B w/ 0)  00201000-&amp;gt;00400000 S(rw) NSBOOT(rw) NS(rw), id=0000000000000001, &#34;B&#34;, uf2 { rp2350-arm-s, rp2350-riscv }, arm_boot 1, riscv_boot 1&#xA;Family id &#39;rp2350-arm-s&#39; can be downloaded in partition 0:&#xA;  00002000-&amp;gt;00201000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;create&lt;/h3&gt; &#xA;&lt;p&gt;This command allows you to create partition tables, and additionally embed them into the block loop if ELF files (for example, for bootloaders). By default, all partition tables are hashed, and you can also sign them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help partition create&#xA;PARTITION CREATE:&#xA;    Create a partition table from json&#xA;&#xA;SYNOPSIS:&#xA;    picotool partition create [--quiet] [--verbose] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] [[-o &amp;lt;offset&amp;gt;] [--family &amp;lt;family_id&amp;gt;]]&#xA;                [&amp;lt;bootloader&amp;gt;] [-t &amp;lt;type&amp;gt;] [[--sign &amp;lt;keyfile&amp;gt;] [-t &amp;lt;type&amp;gt;] [--no-hash] [--singleton]] [[--abs-block] [&amp;lt;abs_block_loc&amp;gt;]]&#xA;&#xA;OPTIONS:&#xA;        --quiet&#xA;            Don&#39;t print any output&#xA;        --verbose&#xA;            Print verbose output&#xA;    partition table JSON&#xA;        &amp;lt;infile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (json) explicitly, ignoring file extension&#xA;    output file&#xA;        &amp;lt;outfile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    UF2 output options&#xA;        -o, --offset&#xA;            Specify the load address for UF2 file output&#xA;        &amp;lt;offset&amp;gt;&#xA;            Load offset (memory address; default 0x10000000)&#xA;        --family&#xA;            Specify the family if for UF2 file output&#xA;        &amp;lt;family_id&amp;gt;&#xA;            family id for UF2 (default absolute)&#xA;    embed partition table into bootloader ELF&#xA;        &amp;lt;bootloader&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (elf) explicitly, ignoring file extension&#xA;    Partition Table Options&#xA;        --sign &amp;lt;keyfile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (pem) explicitly, ignoring file extension&#xA;        --no-hash&#xA;            Don&#39;t hash the partition table&#xA;        --singleton&#xA;            Singleton partition table&#xA;    Errata RP2350-E9 Fix&#xA;        --abs-block&#xA;            Enforce support for an absolute block&#xA;        &amp;lt;abs_block_loc&amp;gt;&#xA;            absolute block location (default to 0x10ffff00)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;uf2&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;uf2&lt;/code&gt; commands allow for creation of UF2s, and cam provide information when if a UF2 download has failed.&lt;/p&gt; &#xA;&lt;h3&gt;convert&lt;/h3&gt; &#xA;&lt;p&gt;This command replaces the elf2uf2 functionality that was previously in the Raspberry Pi Pico SDK. It will attempt to auto-detect the family ID, but if this fails you can specify one manually with the &lt;code&gt;--family&lt;/code&gt; argument.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;picotool help uf2 convert&#xA;UF2 CONVERT:&#xA;    Convert ELF/BIN to UF2.&#xA;&#xA;SYNOPSIS:&#xA;    picotool uf2 convert [--quiet] [--verbose] &amp;lt;infile&amp;gt; [-t &amp;lt;type&amp;gt;] &amp;lt;outfile&amp;gt; [-t &amp;lt;type&amp;gt;] [-o &amp;lt;offset&amp;gt;] [--family &amp;lt;family_id&amp;gt;]&#xA;                [[--abs-block] [&amp;lt;abs_block_loc&amp;gt;]]&#xA;&#xA;OPTIONS:&#xA;        --quiet&#xA;            Don&#39;t print any output&#xA;        --verbose&#xA;            Print verbose output&#xA;    File to load from&#xA;        &amp;lt;infile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2 | elf | bin) explicitly, ignoring file extension&#xA;    File to save UF2 to&#xA;        &amp;lt;outfile&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (uf2) explicitly, ignoring file extension&#xA;    Packaging Options&#xA;        -o, --offset&#xA;            Specify the load address&#xA;        &amp;lt;offset&amp;gt;&#xA;            Load offset (memory address; default 0x10000000 for BIN file)&#xA;    UF2 Family options&#xA;        &amp;lt;family_id&amp;gt;&#xA;            family id for UF2&#xA;    Errata RP2350-E9 Fix&#xA;        --abs-block&#xA;            Add an absolute block&#xA;        &amp;lt;abs_block_loc&amp;gt;&#xA;            absolute block location (default to 0x10ffff00)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;info&lt;/h3&gt; &#xA;&lt;p&gt;This command reads the information on a device about why a UF2 download has failed. It will only give information if the most recent download has failed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help uf2 info&#xA;UF2 INFO:&#xA;    Print info about UF2 download.&#xA;&#xA;SYNOPSIS:&#xA;    picotool uf2 info [device-selection]&#xA;&#xA;OPTIONS:&#xA;    Target device selection&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;otp&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;otp&lt;/code&gt; commands are for interacting with the RP2350 OTP Memory. They are not available on RP2040 devices, as RP2040 has no OTP.&lt;/p&gt; &#xA;&lt;p&gt;Note that the OTP Memory is One-Time-Programmable, which means that once a bit has been changed from 0 to 1, it cannot be changed back. Therefore, caution should be used when using these commands, as they risk bricking your RP2350 device. For example, if you set SECURE_BOOT_ENABLE but don&#39;t set a boot key, and disable the PICOBOOT interface, then your device will be unusable.&lt;/p&gt; &#xA;&lt;p&gt;For the &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; commands, you can define your own OTP layout in a JSON file and pass that in with the &lt;code&gt;-i&lt;/code&gt; argument. These rows will be added to the default rows when parsing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help otp&#xA;OTP:&#xA;    Commands related to the RP2350 OTP (One-Time-Programmable) Memory&#xA;&#xA;SYNOPSIS:&#xA;    picotool otp list [-p] [-n] [-i &amp;lt;filename&amp;gt;] [&amp;lt;selector&amp;gt;..]&#xA;    picotool otp get [-c &amp;lt;copies&amp;gt;] [-r] [-e] [-n] [-i &amp;lt;filename&amp;gt;] [device-selection] [-z] [&amp;lt;selector&amp;gt;..]&#xA;    picotool otp set [-c &amp;lt;copies&amp;gt;] [-r] [-e] [-i &amp;lt;filename&amp;gt;] [-z] &amp;lt;selector&amp;gt; &amp;lt;value&amp;gt; [device-selection]&#xA;    picotool otp load [-r] [-e] [-s &amp;lt;row&amp;gt;] [-i &amp;lt;filename&amp;gt;] &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [device-selection]&#xA;    picotool otp dump [-r] [-e] [device-selection]&#xA;    picotool otp permissions &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [--led &amp;lt;pin&amp;gt;] [--hash] [--sign] [&amp;lt;key&amp;gt;] [-t &amp;lt;type&amp;gt;] [device-selection]&#xA;    picotool otp white-label -s &amp;lt;row&amp;gt; &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [device-selection]&#xA;&#xA;SUB COMMANDS:&#xA;    list          List matching known registers/fields&#xA;    get           Get the value of one or more OTP registers/fields (RP2350 only)&#xA;    set           Set the value of an OTP row/field (RP2350 only)&#xA;    load          Load the row range stored in a file into OTP and verify. Data is 2 bytes/row for ECC, 4 bytes/row for raw. (RP2350 only)&#xA;    dump          Dump entire OTP (RP2350 only)&#xA;    permissions   Set the OTP access permissions (RP2350 only)&#xA;    white-label   Set the white labelling values in OTP (RP2350 only)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;set/get&lt;/h3&gt; &#xA;&lt;p&gt;These commands will set/get specific rows of OTP. By default, they will write/read all redundant rows, but this can be overridden with the &lt;code&gt;-c&lt;/code&gt; argument&lt;/p&gt; &#xA;&lt;h3&gt;load&lt;/h3&gt; &#xA;&lt;p&gt;This command allows loading of a range of OTP rows onto the device. The source can be a binary file, or a JSON file such as the one output by &lt;code&gt;picotool sign&lt;/code&gt;. For example, if you wish to sign a binary and then test secure boot with it, you can run the following set of commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool sign hello_world.elf hello_world.signed.elf private.pem otp.json&#xA;$ picotool load hello_world.signed.elf&#xA;$ picotool otp load otp.json&#xA;$ picotool reboot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;white-label&lt;/h3&gt; &#xA;&lt;p&gt;This command allows for OTP white-labelling, which sets the USB configuration used by the device in BOOTSEL mode. This can be configured from a JSON file, an example of which is in &lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/picotool/master/sample-wl.json&#34;&gt;sample-wl.json&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help otp white-label&#xA;OTP WHITE-LABEL:&#xA;    Set the white labelling values in OTP&#xA;&#xA;SYNOPSIS:&#xA;    picotool otp white-label -s &amp;lt;row&amp;gt; &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [device-selection]&#xA;&#xA;OPTIONS:&#xA;    File with white labelling values&#xA;        &amp;lt;filename&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (json) explicitly, ignoring file extension&#xA;    Target device selection&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool otp white-label -s 0x100 ../sample-wl.json &#xA;Setting attributes 20e0&#xA;0x2e8b, 0x000e, 0x0215, 0x0c09, 0x1090, 0x200c, 0x2615, 0x20e0, 0x310b, 0x3706, 0x3a04, 0x3c04, 0x3e21, 0x4f15, 0x5a0a, 0x5f0a, 0x007a, 0x00df, 0x6c34, 0xd83c, 0xdf4c, 0x0020, 0x0054, 0x0065, 0x0073, 0x0074, 0x0027, 0x0073,&#xA;0x0020, 0x0050, 0x0069, 0x0073, 0x6554, 0x7473, 0x5220, 0x3250, 0x3533, 0x3f30, 0x6f6e, 0x6e74, 0x6365, 0x7365, 0x6173, 0x6972, 0x796c, 0x6e61, 0x6d75, 0x6562, 0x0072, 0x6554, 0x7473, 0x6950, 0x4220, 0x6f6f, 0x0074, 0x6554,&#xA;0x7473, 0x6950, 0x794d, 0x6950, 0x3876, 0x3739, 0x7468, 0x7074, 0x3a73, 0x2f2f, 0x7777, 0x2e77, 0x6172, 0x7073, 0x6562, 0x7272, 0x7079, 0x2e69, 0x6f63, 0x2f6d, 0x656e, 0x7377, 0x002f, 0x6f53, 0x656d, 0x4e20, 0x7765, 0x2073,&#xA;0x6241, 0x756f, 0x2074, 0x7453, 0x6675, 0x0066, 0x794d, 0x5420, 0x7365, 0x2074, 0x6950, 0x5054, 0x2d49, 0x5052, 0x3332, 0x3035,&#xA;$ picotool reboot -u&#xA;$ lsusb -v -s 1:102&#xA;Bus 001 Device 102: ID 2e8b:000e z√üÊ∞¥üçå Test&#39;s Pis Test RP2350?&#xA;Device Descriptor:&#xA;  bLength                18&#xA;  bDescriptorType         1&#xA;  bcdUSB               2.10&#xA;  bDeviceClass            0 &#xA;  bDeviceSubClass         0 &#xA;  bDeviceProtocol         0 &#xA;  bMaxPacketSize0        64&#xA;  idVendor           0x2e8b &#xA;  idProduct          0x000e &#xA;  bcdDevice            2.15&#xA;  iManufacturer           1 z√üÊ∞¥üçå Test&#39;s Pis&#xA;  iProduct                2 Test RP2350?&#xA;  iSerial                 3 notnecessarilyanumber&#xA;  bNumConfigurations      1&#xA;  Configuration Descriptor:&#xA;    bLength                 9&#xA;    bDescriptorType         2&#xA;    wTotalLength       0x0037&#xA;    bNumInterfaces          2&#xA;    bConfigurationValue     1&#xA;    iConfiguration          0 &#xA;    bmAttributes         0xc0&#xA;      Self Powered&#xA;    MaxPower               64mA&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;permissions&lt;/h3&gt; &#xA;&lt;p&gt;This command will run a binary on your device in order to set the OTP permissions, as these are not directly accessible from &lt;code&gt;picotool&lt;/code&gt; on due to the default permissions settings required to fix errata XXX on RP2350. Because it runs a binary, the binary needs to be sign it if secure boot is enabled. The binary will print what it is doing over uart, which can be configured using the UART Configuration arguments. You can define your OTP permissions in a json file, an example of which is in &lt;a href=&#34;https://raw.githubusercontent.com/raspberrypi/picotool/master/sample-permissions.json&#34;&gt;sample-permissions.json&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool help otp permissions&#xA;OTP PERMISSIONS:&#xA;    Set the OTP access permissions&#xA;&#xA;SYNOPSIS:&#xA;    picotool otp permissions &amp;lt;filename&amp;gt; [-t &amp;lt;type&amp;gt;] [--led &amp;lt;pin&amp;gt;] [--hash] [--sign] [&amp;lt;key&amp;gt;] [-t &amp;lt;type&amp;gt;] [device-selection]&#xA;&#xA;OPTIONS:&#xA;    File to load permissions from&#xA;        &amp;lt;filename&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (json) explicitly, ignoring file extension&#xA;        --led &amp;lt;pin&amp;gt;&#xA;            LED Pin to flash; default 25&#xA;    Signing Configuration&#xA;        --hash&#xA;            Hash the executable&#xA;        --sign&#xA;            Sign the executable&#xA;    Key file&#xA;        &amp;lt;key&amp;gt;&#xA;            The file name&#xA;        -t &amp;lt;type&amp;gt;&#xA;            Specify file type (pem) explicitly, ignoring file extension&#xA;    Target device selection&#xA;        --bus &amp;lt;bus&amp;gt;&#xA;            Filter devices by USB bus number&#xA;        --address &amp;lt;addr&amp;gt;&#xA;            Filter devices by USB device address&#xA;        --vid &amp;lt;vid&amp;gt;&#xA;            Filter by vendor id&#xA;        --pid &amp;lt;pid&amp;gt;&#xA;            Filter by product id&#xA;        --ser &amp;lt;ser&amp;gt;&#xA;            Filter by serial number&#xA;        -f, --force&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be rebooted back to application mode&#xA;        -F, --force-no-reboot&#xA;            Force a device not in BOOTSEL mode but running compatible code to reset so the command can be executed. After executing the&#xA;            command (unless the command itself is a &#39;reboot&#39;) the device will be left connected and accessible to picotool, but without the&#xA;            RPI-RP2 drive mounted&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool otp permissions --sign private.pem --tx 46 ../sample-permissions.json &#xA;Picking file ./xip_ram_perms.elf&#xA;page10&#xA;page10 = 0&#xA;setting page10 -&amp;gt; 4063233&#xA;page11&#xA;page11 = 0&#xA;setting page11 -&amp;gt; 4128781&#xA;page12&#xA;page12 = 0&#xA;setting page12 -&amp;gt; 4128781&#xA;tx_pin = 0&#xA;setting tx_pin -&amp;gt; 46&#xA;Loading into XIP RAM: [==============================]  100%&#xA;&amp;gt;&amp;gt;&amp;gt; using flash update boot of 13ffc000&#xA;&#xA;The device was rebooted to start the application.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Binary Information&lt;/h2&gt; &#xA;&lt;p&gt;Binary information is machine locatable and generally machine consumable. I say generally because anyone can include any information, and we can tell it from ours, but it is up to them whether they make their data self describing.&lt;/p&gt; &#xA;&lt;p&gt;Note that we will certainly add more binary info over time, but I&#39;d like to get a minimum core set included in most binaries from launch!!&lt;/p&gt; &#xA;&lt;h3&gt;Basic Information&lt;/h3&gt; &#xA;&lt;p&gt;This information is really handy when you pick up a Pico and don&#39;t know what is on it!&lt;/p&gt; &#xA;&lt;p&gt;Basic information includes&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;program name&lt;/li&gt; &#xA; &lt;li&gt;program description&lt;/li&gt; &#xA; &lt;li&gt;program version string&lt;/li&gt; &#xA; &lt;li&gt;program build date&lt;/li&gt; &#xA; &lt;li&gt;program url&lt;/li&gt; &#xA; &lt;li&gt;program end address&lt;/li&gt; &#xA; &lt;li&gt;program features - this is a list built from individual strings in the binary, that can be displayed (e.g. we will have one for UART stdio and one for USB stdio) in the SDK&lt;/li&gt; &#xA; &lt;li&gt;build attributes - this is a similar list of strings, for things pertaining to the binary itself (e.g. Debug Build)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The binary information is self-describing/extensible, so programs can include information picotool is not aware of (e.g. MicroPython includes a list of in-built libraries)&lt;/p&gt; &#xA;&lt;h3&gt;Pins&lt;/h3&gt; &#xA;&lt;p&gt;This is certainly handy when you have an executable called &#39;hello_world.elf&#39; but you forgot what board it is built for...&lt;/p&gt; &#xA;&lt;p&gt;Static (fixed) pin assignments can be recorded in the binary in very compact form:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool info --pins sprite_demo.elf&#xA;File sprite_demo.elf:&#xA;&#xA;Fixed Pin Information&#xA;0-4:    Red 0-4&#xA;6-10:   Green 0-4&#xA;11-15:  Blue 0-4&#xA;16:     HSync&#xA;17:     VSync&#xA;18:     Display Enable&#xA;19:     Pixel Clock&#xA;20:     UART1 TX&#xA;21:     UART1 RX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;This is very handy if you want to be able to modify parameters in a binary, without having to recompile it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool config -s name Jane&#xA;name = &#34;Billy&#34;&#xA;setting name -&amp;gt; &#34;Jane&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Including Binary information&lt;/h3&gt; &#xA;&lt;p&gt;Binary information is declared in the program by macros (vile warped macros); for the pins example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;$ picotool info --pins sprite_demo.elf&#xA;File sprite_demo.elf:&#xA;&#xA;Fixed Pin Information&#xA;0-4:    Red 0-4&#xA;6-10:   Green 0-4&#xA;11-15:  Blue 0-4&#xA;16:     HSync&#xA;17:     VSync&#xA;18:     Display Enable&#xA;19:     Pixel Clock&#xA;20:     UART1 TX&#xA;21:     UART1 RX&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;... there is one line in the &lt;code&gt;setup_default_uart&lt;/code&gt; function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bi_decl_if_func_used(bi_2pins_with_func(PICO_DEFAULT_UART_RX_PIN, PICO_DEFAULT_UART_TX_PIN, GPIO_FUNC_UART));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The two pin numbers, and the function UART are stored, then decoded to their actual function names (UART1 TX etc) by picotool. The &lt;code&gt;bi_decl_if_func_used&lt;/code&gt; makes sure the binary information is only included if the containing function is called.&lt;/p&gt; &#xA;&lt;p&gt;Equally, the video code contains a few lines like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bi_decl_if_func_used(bi_pin_mask_with_name(0x1f &amp;lt;&amp;lt; (PICO_SCANVIDEO_COLOR_PIN_BASE + PICO_SCANVIDEO_DPI_PIXEL_RSHIFT), &#34;Red 0-4&#34;));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the configuration example, you put the line&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bi_decl(bi_ptr_string(0x1111, 0x3333, name, &#34;Billy&#34;, 128));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;into your code, which will then create the name variable for you to subsequently print. The parameters are the tag, the ID, variable name, default value, and maximum string length.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&#34;Name is %s\n&#34;, name);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Details&lt;/h3&gt; &#xA;&lt;p&gt;Things are designed to waste as little space as possible, but you can turn everything off with preprocessor variable &lt;code&gt;PICO_NO_BINARY_INFO=1&lt;/code&gt;. Additionally, any SDK code that inserts binary info can be separately excluded by its own preprocessor variable.&lt;/p&gt; &#xA;&lt;p&gt;You need&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &#34;pico/binary_info.h&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Basically you either use &lt;code&gt;bi_decl(bi_blah(...))&lt;/code&gt; for unconditional inclusion of the binary info blah, or &lt;code&gt;bi_decl_if_func_used(bi_blah(...))&lt;/code&gt; for binary information that may be stripped if the enclosing function is not included in the binary by the linker (think &lt;code&gt;--gc-sections&lt;/code&gt;)&lt;/p&gt; &#xA;&lt;p&gt;There are a bunch of bi_ macros in the headers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define bi_binary_end(end) ...&#xA;#define bi_program_name(name) ...&#xA;#define bi_program_description(description) ...&#xA;#define bi_program_version_string(version_string) ...&#xA;#define bi_program_build_date_string(date_string) ...&#xA;#define bi_program_url(url) ...&#xA;#define bi_program_feature(feature) ...&#xA;#define bi_program_build_attribute(attr) ...&#xA;#define bi_1pin_with_func(p0, func) ...&#xA;#define bi_2pins_with_func(p0, p1, func) ...&#xA;#define bi_3pins_with_func(p0, p1, p2, func) ...&#xA;#define bi_4pins_with_func(p0, p1, p2, p3, func) ...&#xA;#define bi_5pins_with_func(p0, p1, p2, p3, p4, func) ...&#xA;#define bi_pin_range_with_func(plo, phi, func) ...&#xA;#define bi_pin_mask_with_name(pmask, label) ...&#xA;#define bi_pin_mask_with_names(pmask, label) ...&#xA;#define bi_1pin_with_name(p0, name) ...&#xA;#define bi_2pins_with_names(p0, name0, p1, name1) ...&#xA;#define bi_3pins_with_names(p0, name0, p1, name1, p2, name2) ...&#xA;#define bi_4pins_with_names(p0, name0, p1, name1, p2, name2, p3, name3) ... &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which make use of underlying macros, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define bi_program_url(url) bi_string(BINARY_INFO_TAG_RASPBERRY_PI, BINARY_INFO_ID_RP_PROGRAM_URL, url)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;NOTE: It is easy to forget to enclose these in &lt;code&gt;bi_decl&lt;/code&gt; etc., so an effort has been made (at the expense of a lot of kittens) to make the build fail with a &lt;em&gt;somewhat&lt;/em&gt; helpful error message if you do so.&lt;/p&gt; &#xA;&lt;p&gt;For example, trying to compile&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bi_1pin_with_name(0, &#34;Toaster activator&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;gives&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/home/graham/dev/mu/pico_sdk/src/common/pico_binary_info/include/pico/binary_info/code.h:17:55: error: &#39;_error_bi_is_missing_enclosing_decl_261&#39; undeclared here (not in a function)&#xA;17 | #define __bi_enclosure_check_lineno_var_name __CONCAT(_error_bi_is_missing_enclosing_decl_,__LINE__)&#xA;|                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#xA;... more macro call stack of doom&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Setting common fields from CMake&lt;/h2&gt; &#xA;&lt;p&gt;You can use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;pico_set_program_name(foo &#34;not foo&#34;) # as &#34;foo&#34; would be the default&#xA;pico_set_program_description(foo &#34;this is a foo&#34;)&#xA;pico_set_program_version(foo &#34;0.00001a&#34;)&#xA;pico_set_program_url(foo &#34;www.plinth.com/foo&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note all of these are passed as command line arguments to the compilation, so if you plan to use quotes, newlines etc you may have better luck defining via bi_decl in the code.&lt;/p&gt; &#xA;&lt;h2&gt;Additional binary information/picotool features&lt;/h2&gt; &#xA;&lt;h3&gt;Block devices&lt;/h3&gt; &#xA;&lt;p&gt;MicroPython and CircuitPython, eventually the SDK and others may support one or more storage devices in flash. We already have macros to define these although picotool doesn&#39;t do anything with them yet... but backup/restore/file copy and even fuse mount in the future might be interesting.&lt;/p&gt; &#xA;&lt;p&gt;I suggest we tag these now...&lt;/p&gt; &#xA;&lt;p&gt;This is what I have right now off the top of my head (at the time)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define bi_block_device(_tag, _name, _offset, _size, _extra, _flags)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;with the data going into&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct __packed _binary_info_block_device {&#xA;        struct _binary_info_core core;&#xA;        bi_ptr_of(const char) name; // optional static name (independent of what is formatted)&#xA;        uint32_t offset;&#xA;        uint32_t size;&#xA;        bi_ptr_of(binary_info_t) extra; // additional info&#xA;        uint16_t flags;&#xA;} binary_info_block_device_t;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;enum {&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_READ = 1 &amp;lt;&amp;lt; 0, // if not readable, then it is basically hidden, but tools may choose to avoid overwriting it&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_WRITE = 1 &amp;lt;&amp;lt; 1,&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_REFORMAT = 1 &amp;lt;&amp;lt; 2, // may be reformatted..&#xA;&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_PT_UNKNOWN = 0 &amp;lt;&amp;lt; 4, // unknown free to look&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_PT_MBR = 1 &amp;lt;&amp;lt; 4, // expect MBR&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_PT_GPT = 2 &amp;lt;&amp;lt; 4, // expect GPT&#xA;    BINARY_INFO_BLOCK_DEV_FLAG_PT_NONE = 3 &amp;lt;&amp;lt; 4, // no partition table&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Forced Reboots&lt;/h3&gt; &#xA;&lt;p&gt;Running commands with &lt;code&gt;-f/F&lt;/code&gt; requires compatible code to be running on the device. The definition of compatible code for the purposes of binaries compiled using the &lt;a href=&#34;https://github.com/raspberrypi/pico-sdk&#34;&gt;pico-sdk&lt;/a&gt; is code that&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Is still running - If your code has returned then rebooting with &lt;code&gt;-f/F&lt;/code&gt; will not work - instead you can set the compile definition &lt;code&gt;PICO_ENTER_USB_BOOT_ON_EXIT&lt;/code&gt; to reboot and be accessible to picotool once your code has finished execution, for example with &lt;code&gt;target_compile_definitions(&amp;lt;yourTargetName&amp;gt; PRIVATE PICO_ENTER_USB_BOOT_ON_EXIT=1)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Uses stdio_usb - If your binary calls &lt;code&gt;stdio_init_all()&lt;/code&gt; and you have &lt;code&gt;pico_enable_stdio_usb(&amp;lt;yourTargetName&amp;gt; 1)&lt;/code&gt; in your CMakeLists.txt file then you meet this requirement (see the &lt;a href=&#34;https://github.com/raspberrypi/pico-examples/tree/master/hello_world/usb&#34;&gt;hello_usb&lt;/a&gt; example)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Issues&lt;/h3&gt; &#xA;&lt;p&gt;If you ctrl+c out of the middle of a long operation, then libusb seems to get a bit confused, which means we aren&#39;t able to unlock our lockout of USB MSD writes (we have turned them off so the user doesn&#39;t step on their own toes). Simply running &lt;code&gt;picotool info&lt;/code&gt; again will unlock it properly the next time (or you can reboot the device).&lt;/p&gt;</summary>
  </entry>
</feed>