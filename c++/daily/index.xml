<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-21T01:31:31Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>daquexian/onnx-simplifier</title>
    <updated>2023-04-21T01:31:31Z</updated>
    <id>tag:github.com,2023-04-21:/daquexian/onnx-simplifier</id>
    <link href="https://github.com/daquexian/onnx-simplifier" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simplify your onnx model&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ONNX Simplifier&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://pypi.python.org/pypi/onnx-simplifier/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/v/onnx-simplifier.svg?sanitize=true&#34; alt=&#34;PyPI version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pypi.python.org/pypi/onnx-simplifier/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/pyversions/onnx-simplifier.svg?sanitize=true&#34; alt=&#34;PyPI pyversions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pypi.python.org/pypi/onnx-simplifier/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/l/onnx-simplifier.svg?sanitize=true&#34; alt=&#34;PyPI license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/daquexian/onnx-simplifier/pulls&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?sanitize=true&#34; alt=&#34;PRs Welcome&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;ONNX is great, but sometimes too complicated.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;One day I wanted to export the following simple reshape operation to ONNX:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import torch&#xA;&#xA;&#xA;class JustReshape(torch.nn.Module):&#xA;    def __init__(self):&#xA;        super(JustReshape, self).__init__()&#xA;&#xA;    def forward(self, x):&#xA;        return x.view((x.shape[0], x.shape[1], x.shape[3], x.shape[2]))&#xA;&#xA;&#xA;net = JustReshape()&#xA;model_name = &#39;just_reshape.onnx&#39;&#xA;dummy_input = torch.randn(2, 3, 4, 5)&#xA;torch.onnx.export(net, dummy_input, model_name, input_names=[&#39;input&#39;], output_names=[&#39;output&#39;])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The input shape in this model is static, so what I expected is&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/daquexian/onnx-simplifier/master/imgs/simple_reshape.png&#34; alt=&#34;simple_reshape&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;However, I got the following complicated model instead:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/daquexian/onnx-simplifier/master/imgs/complicated_reshape.png&#34; alt=&#34;complicated_reshape&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Our solution&lt;/h2&gt; &#xA;&lt;p&gt;ONNX Simplifier is presented to simplify the ONNX model. It infers the whole computation graph and then replaces the redundant operators with their constant outputs (a.k.a. constant folding).&lt;/p&gt; &#xA;&lt;h3&gt;Web version&lt;/h3&gt; &#xA;&lt;p&gt;We have published ONNX Simplifier on &lt;a href=&#34;https://www.convertmodel.com/#input=onnx&amp;amp;output=onnx&#34;&gt;convertmodel.com&lt;/a&gt;. It works out of the box and &lt;strong&gt;doesn&#39;t need any installation&lt;/strong&gt;. Note that it runs in the browser locally and your model is completely safe.&lt;/p&gt; &#xA;&lt;h3&gt;Python version&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip3 install -U pip &amp;amp;&amp;amp; pip3 install onnxsim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;onnxsim input_onnx_model output_onnx_model&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more advanced features, try the following command for help message&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;onnxsim -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Demonstration&lt;/h2&gt; &#xA;&lt;p&gt;An overall comparison between &lt;a href=&#34;https://github.com/JDAI-CV/DNNLibrary/issues/17#issuecomment-455934190&#34;&gt;a complicated model&lt;/a&gt; and its simplified version:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/daquexian/onnx-simplifier/master/imgs/comparison.png&#34; alt=&#34;Comparison between old model and new model&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;In-script workflow&lt;/h2&gt; &#xA;&lt;p&gt;If you would like to embed ONNX simplifier python package in another script, it is just that simple.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import onnx&#xA;from onnxsim import simplify&#xA;&#xA;# load your predefined ONNX model&#xA;model = onnx.load(filename)&#xA;&#xA;# convert model&#xA;model_simp, check = simplify(model)&#xA;&#xA;assert check, &#34;Simplified ONNX model could not be validated&#34;&#xA;&#xA;# use model_simp as a standard ONNX model object&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can see more details of the API in &lt;a href=&#34;https://raw.githubusercontent.com/daquexian/onnx-simplifier/master/onnxsim/onnx_simplifier.py&#34;&gt;onnxsim/onnx_simplifier.py&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Projects Using ONNX Simplifier&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mxnet.apache.org/versions/1.9.1/api/python/docs/tutorials/deploy/export/onnx.html#Simplify-the-exported-ONNX-model&#34;&gt;MXNet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/open-mmlab/mmdetection&#34;&gt;MMDetection&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ultralytics/yolov5&#34;&gt;YOLOv5&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/ncnn&#34;&gt;ncnn&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Chat&lt;/h2&gt; &#xA;&lt;p&gt;We created a Chinese QQ group for ONNX!&lt;/p&gt; &#xA;&lt;p&gt;ONNX QQ Group (Chinese): 1021964010, verification code: nndab. Welcome to join!&lt;/p&gt; &#xA;&lt;p&gt;For English users, I&#39;m active on the &lt;a href=&#34;https://github.com/onnx/onnx#discuss&#34;&gt;ONNX Slack&lt;/a&gt;. You can find and chat with me (daquexian) there.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mlesniew/PicoMQTT</title>
    <updated>2023-04-21T01:31:31Z</updated>
    <id>tag:github.com,2023-04-21:/mlesniew/PicoMQTT</id>
    <link href="https://github.com/mlesniew/PicoMQTT" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ESP MQTT client and broker library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PicoMQTT&lt;/h1&gt; &#xA;&lt;p&gt;This is a lightweight and easy to use MQTT library for ESP8266 and ESP32 devices.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/mlesniew/PicoMQTT/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;Build&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/mlesniew/PicoMQTT&#34; alt=&#34;License&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.ardu-badge.com/PicoMQTT&#34;&gt;&lt;img src=&#34;https://www.ardu-badge.com/badge/PicoMQTT.svg?&#34; alt=&#34;arduino-library-badge&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://registry.platformio.org/libraries/mlesniew/PicoMQTT&#34;&gt;&lt;img src=&#34;https://badges.registry.platformio.org/packages/mlesniew/library/PicoMQTT.svg?sanitize=true&#34; alt=&#34;PlatformIO library&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.espressif.com/en/products/socs/esp8266&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/ESP-8266-000000.svg?longCache=true&amp;amp;style=flat&amp;amp;colorA=CC101F&#34; alt=&#34;ESP8266&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.espressif.com/en/products/socs/esp32&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/ESP-32-000000.svg?longCache=true&amp;amp;style=flat&amp;amp;colorA=CC101F&#34; alt=&#34;ESP32&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Client and broker mode supported&lt;/li&gt; &#xA; &lt;li&gt;Intuitive API&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html&#34;&gt;MQTT 3.1.1&lt;/a&gt; implementation&lt;/li&gt; &#xA; &lt;li&gt;Publishing and consuming of &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/#arbitrary-sized-messages&#34;&gt;arbitrary sized messages&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;High performance -- the broker can deliver thousands of messages per second -- &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/#benchmarks&#34;&gt;see benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Easy integration with the &lt;a href=&#34;https://arduinojson.org/&#34;&gt;ArduinoJson&lt;/a&gt; library to publish and consume JSON messages -- &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/#json&#34;&gt;see examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Low memory usage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Limitations:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Client only supports MQTT QoS levels 0 and 1&lt;/li&gt; &#xA; &lt;li&gt;Broker only supports MQTT QoS level 0, ignores will and retained messages.&lt;/li&gt; &#xA; &lt;li&gt;Currently only ESP8266 and ESP32 boards are supported&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation instructions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.ardu-badge.com/PicoMQTT&#34;&gt;Arduino IDE&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://registry.platformio.org/libraries/mlesniew/PicoMQTT/installation&#34;&gt;PlatformIO&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, PicoMQTT requires a recent version of the board core: ** For ESP8266 core version 3.1 or later ** For ESP32 core version 2.0.7 or later&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;To get started, try compiling and running the code below or explore &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/examples&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Client&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;Arduino.h&amp;gt;&#xA;#include &amp;lt;PicoMQTT.h&amp;gt;&#xA;&#xA;PicoMQTT::Client mqtt(&#34;broker.hivemq.com&#34;);&#xA;&#xA;void setup() {&#xA;    // Usual setup&#xA;    Serial.begin(115200);&#xA;    WiFi.mode(WIFI_STA);&#xA;    WiFi.begin(&#34;MyWiFi&#34;, &#34;password&#34;);&#xA;&#xA;    // Subscribe to a topic pattern and attach a callback&#xA;    mqtt.subscribe(&#34;#&#34;, [](const char * topic, const char * payload) {&#xA;        Serial.printf(&#34;Received message in topic &#39;%s&#39;: %s\n&#34;, topic, payload);&#xA;    });&#xA;&#xA;    // Start the client&#xA;    mqtt.begin();&#xA;}&#xA;&#xA;void loop() {&#xA;    // This will automatically reconnect the client if needed.  Re-subscribing to topics is never required.&#xA;    mqtt.loop();&#xA;&#xA;    if (random(1000) == 0)&#xA;        mqtt.publish(&#34;picomqtt/welcome&#34;, &#34;Hello from PicoMQTT!&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Broker&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;Arduino.h&amp;gt;&#xA;#include &amp;lt;PicoMQTT.h&amp;gt;&#xA;&#xA;PicoMQTT::Server mqtt;&#xA;&#xA;void setup() {&#xA;    // Usual setup&#xA;    Serial.begin(115200);&#xA;    WiFi.mode(WIFI_STA);&#xA;    WiFi.begin(&#34;MyWiFi&#34;, &#34;password&#34;);&#xA;&#xA;    // Subscribe to a topic pattern and attach a callback&#xA;    mqtt.subscribe(&#34;#&#34;, [](const char * topic, const char * payload) {&#xA;        Serial.printf(&#34;Received message in topic &#39;%s&#39;: %s\n&#34;, topic, payload);&#xA;    });&#xA;&#xA;    // Start the broker&#xA;    mqtt.begin();&#xA;}&#xA;&#xA;void loop() {&#xA;    // This will automatically handle client connections.  By default, all clients are accepted.&#xA;    mqtt.loop();&#xA;&#xA;    if (random(1000) == 0)&#xA;        mqtt.publish(&#34;picomqtt/welcome&#34;, &#34;Hello from PicoMQTT!&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Publishing messages&lt;/h2&gt; &#xA;&lt;p&gt;To publish messages, the &lt;code&gt;publish&lt;/code&gt; and &lt;code&gt;publish_P&lt;/code&gt; methods can be used. The client and the broker have both the same API for publishing.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;PicoMQTT.h&amp;gt;&#xA;&#xA;PicoMQTT::Client mqtt(&#34;broker.hivemq.com&#34;);  // or PicoMQTT::Server mqtt;&#xA;&#xA;void setup() { /* ... */ }&#xA;&#xA;void loop() {&#xA;    mqtt.loop();&#xA;&#xA;    mqtt.publish(&#34;picomqtt/simple_publish&#34;, &#34;Message&#34;);&#xA;    mqtt.publish(&#34;picomqtt/another_simple_publish&#34;, F(&#34;Message&#34;));&#xA;&#xA;    const char binary_payload[] = &#34;This string could contain binary data including a zero byte&#34;;&#xA;    size_t binary_payload_size = strlen(binary_payload);&#xA;    mqtt.publish(&#34;picomqtt/binary_payload&#34;, (const void *) binary_payload, binary_payload_size);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It&#39;s not required to check if the client is connected before publishing. Calls to &lt;code&gt;publish()&lt;/code&gt; will have no effect and will return immediately in such cases.&lt;/li&gt; &#xA; &lt;li&gt;More examples available &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/examples/advanced_publish/advanced_publish.ino&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Subscribing and consuming messages&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;subscribe&lt;/code&gt; methods can be used with client and broker to set up callbacks for specific topic patterns.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;PicoMQTT.h&amp;gt;&#xA;&#xA;PicoMQTT::Client mqtt(&#34;broker.hivemq.com&#34;);  // or PicoMQTT::Server mqtt;&#xA;&#xA;void setup() {&#xA;    /* ... */&#xA;&#xA;    mqtt.subscribe(&#34;picomqtt/foo&#34;, [](const char * payload) { /* handle message here */ });&#xA;    mqtt.subscribe(&#34;picomqtt/bar&#34;, [](const char * topic, const char * payload) { /* handle message here */ });&#xA;    mqtt.subscribe(&#34;picomqtt/baz&#34;, [](const char * topic, const void * payload, size_t payload_size) { /* handle message here */ });&#xA;&#xA;    // Pattern subscriptions&#xA;    mqtt.subscribe(&#34;picomqtt/+/foo/#&#34;, [](const char * topic, const char * payload) {&#xA;        // To extract individual elements from the topic use:&#xA;        String wildcard_value = mqtt.get_topic_element(topic, 1);  // second parameter is the index (zero based)&#xA;    });&#xA;&#xA;    mqtt.begin();&#xA;}&#xA;&#xA;void loop() {&#xA;    mqtt.loop();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;New subscriptions can be added at any point, not just in the &lt;code&gt;setup()&lt;/code&gt; function.&lt;/li&gt; &#xA; &lt;li&gt;All strings (&lt;code&gt;const char *&lt;/code&gt; parameters) are guaranteed to have a null terminator. It&#39;s safe to treat them as strings.&lt;/li&gt; &#xA; &lt;li&gt;Message payloads can be binary, which means they can contain a zero byte in the middle. To handle binary data, use a callback with a &lt;code&gt;size_t&lt;/code&gt; parameter to know the exact size of the message.&lt;/li&gt; &#xA; &lt;li&gt;The topic and the payload are both buffers allocated on the stack. They will become invalid after the callback returns. If you need to store the payload for later, make sure to copy it to a separate buffer.&lt;/li&gt; &#xA; &lt;li&gt;By default, the maximum topic and payload sizes are is 128 and 1024 bytes respectively. This can be tuned by using &lt;code&gt;#define&lt;/code&gt; directives to override values from &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/src/PicoMQTT/config.h&#34;&gt;config.h&lt;/a&gt;. Consider using the advanced API described in the later sections to handle bigger messages.&lt;/li&gt; &#xA; &lt;li&gt;If a received message&#39;s topic matches more than one pattern, then only one of the callbacks will be fired.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;PicoMQTT::Server&lt;/code&gt; will not deliver published messages locally. This means that if you set up a &lt;code&gt;PicoMQTT::Server&lt;/code&gt; and use &lt;code&gt;subscribe&lt;/code&gt;, your callback will only be called when messages from clients are received. Messages published on the same device will not trigger the callback.&lt;/li&gt; &#xA; &lt;li&gt;Try to return from message handlers quickly. Don&#39;t call functions which may block (like reading from serial or network connections), don&#39;t use the &lt;code&gt;delay()&lt;/code&gt; function.&lt;/li&gt; &#xA; &lt;li&gt;More examples available &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/examples/advanced_consume/advanced_consume.ino&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Arbitrary sized messages&lt;/h2&gt; &#xA;&lt;p&gt;It is possible to send and handle messages of arbitrary size, even if they are significantly bigger than the available memory.&lt;/p&gt; &#xA;&lt;h3&gt;Publishing&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;auto publish = mqtt.begin_publish(&#xA;        &#34;picomqtt/advanced&#34;,  // topic&#xA;        1000000               // payload size&#xA;        );&#xA;&#xA;// The returned publish is a Print subclass, so all Print&#39;s functions will work:&#xA;publish.println(&#34;Hello MQTT&#34;);&#xA;publish.println(2023, HEX);&#xA;publish.write(&#39;c&#39;);&#xA;publish.write((const uint8_t *) &#34;1234567890&#34;, 10);&#xA;&#xA;// We can always check how much space is left&#xA;size_t remaining_size = publish.get_remaining_size();&#xA;&#xA;// ...&#xA;&#xA;// Once all data is written, we have to send the message&#xA;publish.send();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Consuming&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;mqtt.subscribe(&#34;picomqtt/advanced&#34;, [](const char * topic, PicoMQTT::IncomingPacket &amp;amp; packet) {&#xA;    // at any point we can check the remaining payload size&#xA;    size_t payload_size = packet.get_remaining_size();&#xA;&#xA;    // packet is a Stram object, so we can use its methods&#xA;    int val1 = packet.read();&#xA;&#xA;    char buf[100];&#xA;    packet.read(buf, 100);&#xA;&#xA;    // it&#39;s OK to not read the whole content of the message&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Notes&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;When consuming or producing a message using the advanced API, don&#39;t call other MQTT methods. Don&#39;t try to publish multiple messages at a time or publish a message while consuming another.&lt;/li&gt; &#xA; &lt;li&gt;Even with this API, the topic size is still limited. The limit can be increased by overriding values from &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/src/PicoMQTT/config.h&#34;&gt;config.h&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Json&lt;/h2&gt; &#xA;&lt;p&gt;It&#39;s easy to publish and subscribe to JSON messages by integrating with &lt;a href=&#34;https://arduinojson.org/&#34;&gt;ArduinoJson&lt;/a&gt;. Of course, you can always simply use &lt;code&gt;serializeJson&lt;/code&gt; and &lt;code&gt;deserializeJson&lt;/code&gt; with strings, but it&#39;s much more efficient to use the advanced API for this. Check the examples below or try the &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/examples/arduinojson/arduinojson.ino&#34;&gt;arduinojson.ino&lt;/a&gt; example.&lt;/p&gt; &#xA;&lt;h3&gt;Subscribing&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;mqtt.subscribe(&#34;picomqtt/json/#&#34;, [](const char * topic, Stream &amp;amp; stream) {&#xA;    // declare a StaticJsonDocument or DynamicJsonDocument as usual&#xA;    StaticJsonDocument&amp;lt;1024&amp;gt; json;&#xA;&#xA;    // Deserialize straight from the Stream object&#xA;    if (deserializeJson(json, stream)) {&#xA;        // don&#39;t forget to check for errors&#xA;        Serial.println(&#34;Json parsing failed.&#34;);&#xA;        return;&#xA;    }&#xA;&#xA;    // work with the object as usual&#xA;    int value = json[&#34;foo&#34;].as&amp;lt;int&amp;gt;();&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Publishing&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;// declare a StaticJsonDocument or DynamicJsonDocument and add data as usual&#xA;StaticJsonDocument&amp;lt;1024&amp;gt; json;&#xA;json[&#34;foo&#34;] = &#34;bar&#34;;&#xA;json[&#34;millis&#34;] = millis();&#xA;&#xA;// publish using begin_publish()/send() API&#xA;auto publish = mqtt.begin_publish(topic, measureJson(json));&#xA;serializeJson(json, publish);&#xA;publish.send();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;Charts in this section show PicoMQTT how many messages a broker running on the ESP8266 and ESP32 was able to deliver per second per client depending on the payload size and the number of subscribed clients.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Test were executed using the library version from commit 406e879e8b25b84c1488c1e2789e4b3719dd1496&lt;/li&gt; &#xA; &lt;li&gt;The library was using default configuration values (as defined in &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/src/PicoMQTT/config.h&#34;&gt;config.h&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Measurements were done on a PC using scripts in &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/benchmark/&#34;&gt;benchmark/&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The broker was configured to do nothing but forward the messages to subscribed clients, see &lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/benchmark/benchmark.ino&#34;&gt;benchmark.ino&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The ESPs were connecting to a router just next to them to avoid interference. The test PC was connected to the same router using an Ethernet cable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;ESP8266&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/doc/img/benchmark-esp8266.svg?sanitize=true&#34; alt=&#34;ESP8266 broker performance&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/doc/benchmark/esp8266.csv&#34;&gt;Get CSV&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;ESP32&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/doc/img/benchmark-esp32.svg?sanitize=true&#34; alt=&#34;ESP32 broker performance&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/mlesniew/PicoMQTT/master/doc/benchmark/esp32.csv&#34;&gt;Get CSV&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This library is open-source software licensed under GNU LGPLv3.&lt;/p&gt;</summary>
  </entry>
</feed>