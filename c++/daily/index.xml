<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-23T01:31:16Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mitsuba-renderer/mitsuba3</title>
    <updated>2022-07-23T01:31:16Z</updated>
    <id>tag:github.com,2022-07-23:/mitsuba-renderer/mitsuba3</id>
    <link href="https://github.com/mitsuba-renderer/mitsuba3" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Mitsuba 3: A Retargetable Forward and Inverse Renderer&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mitsuba-renderer/mitsuba-data/master/docs/images/banners/banner_01.jpg&#34; alt=&#34;Mitsuba banner&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Mitsuba Renderer 3&lt;/h1&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Documentation&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tutorial videos&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Linux&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;MacOS&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Windows&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://mitsuba.readthedocs.io/en/latest/&#34;&gt;&lt;img src=&#34;https://readthedocs.org/projects/mitsuba/badge/?version=latest&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=9Ja9buZx0Cs&amp;amp;list=PLI9y-85z_Po6da-pyTNGTns2n4fhpbLe5&amp;amp;index=1&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/YouTube-View-green?style=plastic&amp;amp;logo=youtube&#34; alt=&#34;vids&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://rgl-ci.epfl.ch/viewType.html?buildTypeId=Mitsuba3_LinuxAmd64Clang10&amp;amp;guest=1&#34;&gt;&lt;img src=&#34;https://rgl-ci.epfl.ch/app/rest/builds/buildType(id:Mitsuba3_LinuxAmd64Clang10)/statusIcon.svg?sanitize=true&#34; alt=&#34;rgl-ci&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://rgl-ci.epfl.ch/viewType.html?buildTypeId=Mitsuba3_LinuxAmd64gcc9&amp;amp;guest=1&#34;&gt;&lt;img src=&#34;https://rgl-ci.epfl.ch/app/rest/builds/buildType(id:Mitsuba3_LinuxAmd64gcc9)/statusIcon.svg?sanitize=true&#34; alt=&#34;rgl-ci&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://rgl-ci.epfl.ch/viewType.html?buildTypeId=Mitsuba3_WindowsAmd64msvc2020&amp;amp;guest=1&#34;&gt;&lt;img src=&#34;https://rgl-ci.epfl.ch/app/rest/builds/buildType(id:Mitsuba3_WindowsAmd64msvc2020)/statusIcon.svg?sanitize=true&#34; alt=&#34;rgl-ci&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Mitsuba 3 is a research-oriented rendering system for forward and inverse light transport simulation developed at &lt;a href=&#34;https://www.epfl.ch&#34;&gt;EPFL&lt;/a&gt; in Switzerland. It consists of a core library and a set of plugins that implement functionality ranging from materials and light sources to complete rendering algorithms.&lt;/p&gt; &#xA;&lt;p&gt;Mitsuba 3 is &lt;em&gt;retargetable&lt;/em&gt;: this means that the underlying implementations and data structures can transform to accomplish various different tasks. For example, the same code can simulate both scalar (classic one-ray-at-a-time) RGB transport or differential spectral transport on the GPU. This all builds on &lt;a href=&#34;https://github.com/mitsuba-renderer/drjit&#34;&gt;Dr.Jit&lt;/a&gt;, a specialized &lt;em&gt;just-in-time&lt;/em&gt; (JIT) compiler developed specifically for this project.&lt;/p&gt; &#xA;&lt;h2&gt;Main Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Cross-platform&lt;/strong&gt;: Mitsuba 3 has been tested on Linux (&lt;code&gt;x86_64&lt;/code&gt;), macOS (&lt;code&gt;aarch64&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;), and Windows (&lt;code&gt;x86_64&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;High performance&lt;/strong&gt;: The underlying Dr.Jit compiler fuses rendering code into kernels that achieve state-of-the-art performance using an LLVM backend targeting the CPU and a CUDA/OptiX backend targeting NVIDIA GPUs with ray tracing hardware acceleration.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Python first&lt;/strong&gt;: Mitsuba 3 is deeply integrated with Python. Materials, textures, and even full rendering algorithms can be developed in Python, which the system JIT-compiles (and optionally differentiates) on the fly. This enables the experimentation needed for research in computer graphics and other disciplines.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Differentiation&lt;/strong&gt;: Mitsuba 3 is a differentiable renderer, meaning that it can compute derivatives of the entire simulation with respect to input parameters such as camera pose, geometry, BSDFs, textures, and volumes. It implements recent differentiable rendering algorithms developed at EPFL.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Spectral &amp;amp; Polarization&lt;/strong&gt;: Mitsuba 3 can be used as a monochromatic renderer, RGB-based renderer, or spectral renderer. Each variant can optionally account for the effects of polarization if desired.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tutorial videos, documentation&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve recorded several &lt;a href=&#34;https://www.youtube.com/watch?v=9Ja9buZx0Cs&amp;amp;list=PLI9y-85z_Po6da-pyTNGTns2n4fhpbLe5&amp;amp;index=1&#34;&gt;YouTube videos&lt;/a&gt; that provide a gentle introduction Mitsuba 3 and Dr.Jit. Beyond this you can find complete Juypter notebooks covering a variety of applications, how-to guides, and reference documentation on &lt;a href=&#34;https://mitsuba.readthedocs.io/en/latest/&#34;&gt;readthedocs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;We provide pre-compiled binary wheels via PyPI. Installing Mitsuba this way is as simple as running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install mitsuba&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;on the command line. The Python package includes four variants by default:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;scalar_spectral&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;scalar_rgb&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;llvm_ad_rgb&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cuda_ad_rgb&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The first two perform classic one-ray-at-a-time simulation using either a RGB or spectral color representation, while the latter two can be used for inverse rendering on the CPU or GPU. To access additional variants, you will need to compile a custom version of Dr.Jit using CMake. Please see the &lt;a href=&#34;https://mitsuba.readthedocs.io/en/latest/src/developer_guide/compiling.html&#34;&gt;documentation&lt;/a&gt; for details on this.&lt;/p&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Python &amp;gt;= 3.8&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;(optional) For computation on the GPU: &lt;code&gt;Nvidia driver &amp;gt;= 495.89&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;(optional) For vectorized / parallel computation on the CPU: &lt;code&gt;LLVM &amp;gt;= 11.1&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Here is a simple &#34;Hello World&#34; example that shows how simple it is to render a scene using Mitsuba 3 from Python:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Import the library using the alias &#34;mi&#34;&#xA;import mitsuba as mi&#xA;# Set the variant of the renderer&#xA;mi.set_variant(&#39;scalar_rgb&#39;)&#xA;# Load a scene&#xA;scene = mi.load_dict(mi.cornell_box())&#xA;# Render the scene&#xA;img = mi.render(scene)&#xA;# Write the rendered image to an EXR file&#xA;mi.Bitmap(img).write(&#39;cbox.exr&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Tutorials and example notebooks covering a variety of applications can be found in the &lt;a href=&#34;https://mitsuba.readthedocs.io/en/latest/&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;This project was created by &lt;a href=&#34;http://rgl.epfl.ch/people/wjakob&#34;&gt;Wenzel Jakob&lt;/a&gt;. Significant features and/or improvements to the code were contributed by &lt;a href=&#34;https://speierers.github.io/&#34;&gt;Sébastien Speierer&lt;/a&gt;, &lt;a href=&#34;https://github.com/njroussel&#34;&gt;Nicolas Roussel&lt;/a&gt;, &lt;a href=&#34;https://merlin.nimierdavid.fr/&#34;&gt;Merlin Nimier-David&lt;/a&gt;, &lt;a href=&#34;https://dvicini.github.io/&#34;&gt;Delio Vicini&lt;/a&gt;, &lt;a href=&#34;https://tizianzeltner.com/&#34;&gt;Tizian Zeltner&lt;/a&gt;, &lt;a href=&#34;https://bnicolet.com/&#34;&gt;Baptiste Nicolet&lt;/a&gt;, &lt;a href=&#34;https://mcrespo.me/&#34;&gt;Miguel Crespo&lt;/a&gt;, &lt;a href=&#34;https://github.com/leroyvn&#34;&gt;Vincent Leroy&lt;/a&gt;, and &lt;a href=&#34;https://github.com/ziyi-zhang&#34;&gt;Ziyi Zhang&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>taskflow/taskflow</title>
    <updated>2022-07-23T01:31:16Z</updated>
    <id>tag:github.com,2022-07-23:/taskflow/taskflow</id>
    <link href="https://github.com/taskflow/taskflow" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A General-purpose Parallel and Heterogeneous Task Programming System&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Taskflow &lt;img align=&#34;right&#34; width=&#34;10%&#34; src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/taskflow_logo.png&#34;&gt;&lt;/h1&gt; &#xA;&lt;!--[![Linux Build Status](https://travis-ci.com/taskflow/taskflow.svg?branch=master)](https://travis-ci.com/taskflow/taskflow)--&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/taskflow/taskflow/actions?query=workflow%3AUbuntu&#34;&gt;&lt;img src=&#34;https://github.com/taskflow/taskflow/workflows/Ubuntu/badge.svg?sanitize=true&#34; alt=&#34;Ubuntu&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taskflow/taskflow/actions?query=workflow%3AmacOS&#34;&gt;&lt;img src=&#34;https://github.com/taskflow/taskflow/workflows/macOS/badge.svg?sanitize=true&#34; alt=&#34;macOS&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/taskflow/taskflow/actions?query=workflow%3AWindows&#34;&gt;&lt;img src=&#34;https://github.com/taskflow/taskflow/workflows/Windows/badge.svg?sanitize=true&#34; alt=&#34;Windows&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://taskflow.github.io/taskflow/index.html&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/api-doc.svg?sanitize=true&#34; alt=&#34;Wiki&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://taskflow.github.io/tfprof/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/tfprof.svg?sanitize=true&#34; alt=&#34;TFProf&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://tsung-wei-huang.github.io/papers/tpds21-taskflow.pdf&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/cite-tpds.svg?sanitize=true&#34; alt=&#34;Cite&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Taskflow helps you quickly write parallel and heterogeneous task programs in modern C++&lt;/p&gt; &#xA;&lt;h1&gt;Why Taskflow?&lt;/h1&gt; &#xA;&lt;p&gt;Taskflow is faster, more expressive, and easier for drop-in integration than many of existing task programming frameworks in handling complex parallel workloads.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/performance.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Taskflow lets you quickly implement task decomposition strategies that incorporate both regular and irregular compute patterns, together with an efficient &lt;em&gt;work-stealing&lt;/em&gt; scheduler to optimize your multithreaded performance.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#get-started-with-taskflow&#34;&gt;Static Tasking&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#dynamic-tasking&#34;&gt;Dynamic Tasking&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/static_graph.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/dynamic_graph.svg?sanitize=true&#34; width=&#34;100%&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Taskflow supports conditional tasking for you to make rapid control-flow decisions across dependent tasks to implement cycles and conditions that were otherwise difficult to do with existing tools.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#conditional-tasking&#34;&gt;Conditional Tasking&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/condition.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Taskflow is composable. You can create large parallel graphs through composition of modular and reusable blocks that are easier to optimize at an individual scope.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#composable-tasking&#34;&gt;Taskflow Composition&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/framework.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Taskflow supports heterogeneous tasking for you to accelerate a wide range of scientific computing applications by harnessing the power of CPU-GPU collaborative computing.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#concurrent-cpu-gpu-tasking&#34;&gt;Concurrent CPU-GPU Tasking&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/cudaflow.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Taskflow provides visualization and tooling needed for profiling Taskflow programs.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://taskflow.github.io/tfprof&#34;&gt;Taskflow Profiler&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/image/tfprof.png&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;We are committed to support trustworthy developments for both academic and industrial research projects in parallel computing. Check out &lt;a href=&#34;https://taskflow.github.io/#tag_users&#34;&gt;Who is Using Taskflow&lt;/a&gt; and what our users say:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;&#34;Taskflow is the cleanest Task API I&#39;ve ever seen.&#34; &lt;a href=&#34;http://coreliuminc.com&#34;&gt;Damien Hocking @Corelium Inc&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&#34;Taskflow has a very simple and elegant tasking interface. The performance also scales very well.&#34; &lt;a href=&#34;https://github.com/totalgee&#34;&gt;Glen Fraser&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&#34;Taskflow lets me handle parallel processing in a smart way.&#34; &lt;a href=&#34;https://cpp-learning.com/cpp-taskflow/&#34;&gt;Hayabusa @Learning&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&#34;Taskflow improves the throughput of our graph engine in just a few hours of coding.&#34; &lt;a href=&#34;https://ossia.io/&#34;&gt;Jean-Michaël @KDAB&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&#34;Best poster award for open-source parallel programming library.&#34; &lt;a href=&#34;https://github.com/CppCon/CppCon2018&#34;&gt;Cpp Conference 2018&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&#34;Second Prize of Open-source Software Competition.&#34; &lt;a href=&#34;https://tsung-wei-huang.github.io/img/mm19-ossc-award.jpg&#34;&gt;ACM Multimedia Conference 2019&lt;/a&gt;&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See a quick &lt;a href=&#34;https://taskflow.github.io/&#34;&gt;presentation&lt;/a&gt; and visit the &lt;a href=&#34;https://taskflow.github.io/taskflow/index.html&#34;&gt;documentation&lt;/a&gt; to learn more about Taskflow. Technical details can be referred to our &lt;a href=&#34;https://tsung-wei-huang.github.io/papers/tpds21-taskflow.pdf&#34;&gt;IEEE TPDS paper&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Start Your First Taskflow Program&lt;/h1&gt; &#xA;&lt;p&gt;The following program (&lt;code&gt;simple.cpp&lt;/code&gt;) creates four tasks &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; runs before &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt; runs after &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;. When &lt;code&gt;A&lt;/code&gt; finishes, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; can run in parallel.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;taskflow/taskflow.hpp&amp;gt;  // Taskflow is header-only&#xA;&#xA;int main(){&#xA;  &#xA;  tf::Executor executor;&#xA;  tf::Taskflow taskflow;&#xA;&#xA;  auto [A, B, C, D] = taskflow.emplace(  // create four tasks&#xA;    [] () { std::cout &amp;lt;&amp;lt; &#34;TaskA\n&#34;; },&#xA;    [] () { std::cout &amp;lt;&amp;lt; &#34;TaskB\n&#34;; },&#xA;    [] () { std::cout &amp;lt;&amp;lt; &#34;TaskC\n&#34;; },&#xA;    [] () { std::cout &amp;lt;&amp;lt; &#34;TaskD\n&#34;; } &#xA;  );                                  &#xA;                                      &#xA;  A.precede(B, C);  // A runs before B and C&#xA;  D.succeed(B, C);  // D runs after  B and C&#xA;                                      &#xA;  executor.run(taskflow).wait(); &#xA;&#xA;  return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Taskflow is &lt;em&gt;header-only&lt;/em&gt; and there is no wrangle with installation. To compile the program, clone the Taskflow project and tell the compiler to include the &lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/taskflow/&#34;&gt;headers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~$ git clone https://github.com/taskflow/taskflow.git  # clone it only once&#xA;~$ g++ -std=c++17 simple.cpp -I taskflow/taskflow -O2 -pthread -o simple&#xA;~$ ./simple&#xA;TaskA&#xA;TaskC &#xA;TaskB &#xA;TaskD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Visualize Your First Taskflow Program&lt;/h1&gt; &#xA;&lt;p&gt;Taskflow comes with a built-in profiler, &lt;a href=&#34;https://taskflow.github.io/tfprof/&#34;&gt;TFProf&lt;/a&gt;, for you to profile and visualize taskflow programs in an easy-to-use web-based interface.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/tfprof.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# run the program with the environment variable TF_ENABLE_PROFILER enabled&#xA;~$ TF_ENABLE_PROFILER=simple.json ./simple&#xA;~$ cat simple.json&#xA;[&#xA;{&#34;executor&#34;:&#34;0&#34;,&#34;data&#34;:[{&#34;worker&#34;:0,&#34;level&#34;:0,&#34;data&#34;:[{&#34;span&#34;:[172,186],&#34;name&#34;:&#34;0_0&#34;,&#34;type&#34;:&#34;static&#34;},{&#34;span&#34;:[187,189],&#34;name&#34;:&#34;0_1&#34;,&#34;type&#34;:&#34;static&#34;}]},{&#34;worker&#34;:2,&#34;level&#34;:0,&#34;data&#34;:[{&#34;span&#34;:[93,164],&#34;name&#34;:&#34;2_0&#34;,&#34;type&#34;:&#34;static&#34;},{&#34;span&#34;:[170,179],&#34;name&#34;:&#34;2_1&#34;,&#34;type&#34;:&#34;static&#34;}]}]}&#xA;]&#xA;# paste the profiling json data to https://taskflow.github.io/tfprof/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to execution diagram, you can dump the graph to a DOT format and visualize it using a number of free &lt;a href=&#34;https://www.graphviz.org/&#34;&gt;GraphViz&lt;/a&gt; tools.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// dump the taskflow graph to a DOT format through std::cout&#xA;taskflow.dump(std::cout); &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/simple.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Express Task Graph Parallelism&lt;/h1&gt; &#xA;&lt;p&gt;Taskflow empowers users with both static and dynamic task graph constructions to express end-to-end parallelism in a task graph that embeds in-graph control flow.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#create-a-subflow-graph&#34;&gt;Create a Subflow Graph&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#integrate-control-flow-to-a-task-graph&#34;&gt;Integrate Control Flow to a Task Graph&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#offload-a-task-to-a-gpu&#34;&gt;Offload a Task to a GPU&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#compose-task-graphs&#34;&gt;Compose Task Graphs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#launch-asynchronous-tasks&#34;&gt;Launch Asynchronous Tasks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#execute-a-taskflow&#34;&gt;Execute a Taskflow&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/#leverage-standard-parallel-algorithms&#34;&gt;Leverage Standard Parallel Algorithms&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Create a Subflow Graph&lt;/h2&gt; &#xA;&lt;p&gt;Taskflow supports &lt;em&gt;dynamic tasking&lt;/em&gt; for you to create a subflow graph from the execution of a task to perform dynamic parallelism. The following program spawns a task dependency graph parented at task &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tf::Task A = taskflow.emplace([](){}).name(&#34;A&#34;);  &#xA;tf::Task C = taskflow.emplace([](){}).name(&#34;C&#34;);  &#xA;tf::Task D = taskflow.emplace([](){}).name(&#34;D&#34;);  &#xA;&#xA;tf::Task B = taskflow.emplace([] (tf::Subflow&amp;amp; subflow) { &#xA;  tf::Task B1 = subflow.emplace([](){}).name(&#34;B1&#34;);  &#xA;  tf::Task B2 = subflow.emplace([](){}).name(&#34;B2&#34;);  &#xA;  tf::Task B3 = subflow.emplace([](){}).name(&#34;B3&#34;);  &#xA;  B3.succeed(B1, B2);  // B3 runs after B1 and B2&#xA;}).name(&#34;B&#34;);&#xA;&#xA;A.precede(B, C);  // A runs before B and C&#xA;D.succeed(B, C);  // D runs after  B and C&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/subflow_join.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Integrate Control Flow to a Task Graph&lt;/h2&gt; &#xA;&lt;p&gt;Taskflow supports &lt;em&gt;conditional tasking&lt;/em&gt; for you to make rapid control-flow decisions across dependent tasks to implement cycles and conditions in an &lt;em&gt;end-to-end&lt;/em&gt; task graph.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tf::Task init = taskflow.emplace([](){}).name(&#34;init&#34;);&#xA;tf::Task stop = taskflow.emplace([](){}).name(&#34;stop&#34;);&#xA;&#xA;// creates a condition task that returns a random binary&#xA;tf::Task cond = taskflow.emplace(&#xA;  [](){ return std::rand() % 2; }&#xA;).name(&#34;cond&#34;);&#xA;&#xA;init.precede(cond);&#xA;&#xA;// creates a feedback loop {0: cond, 1: stop}&#xA;cond.precede(cond, stop);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/conditional-tasking-1.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Offload a Task to a GPU&lt;/h2&gt; &#xA;&lt;p&gt;Taskflow supports GPU tasking for you to accelerate a wide range of scientific computing applications by harnessing the power of CPU-GPU collaborative computing using CUDA.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;__global__ void saxpy(size_t N, float alpha, float* dx, float* dy) {&#xA;  int i = blockIdx.x*blockDim.x + threadIdx.x;&#xA;  if (i &amp;lt; n) {&#xA;    y[i] = a*x[i] + y[i];&#xA;  }&#xA;}&#xA;tf::Task cudaflow = taskflow.emplace([&amp;amp;](tf::cudaFlow&amp;amp; cf) {&#xA;&#xA;  // data copy tasks&#xA;  tf::cudaTask h2d_x = cf.copy(dx, hx.data(), N).name(&#34;h2d_x&#34;);&#xA;  tf::cudaTask h2d_y = cf.copy(dy, hy.data(), N).name(&#34;h2d_y&#34;);&#xA;  tf::cudaTask d2h_x = cf.copy(hx.data(), dx, N).name(&#34;d2h_x&#34;);&#xA;  tf::cudaTask d2h_y = cf.copy(hy.data(), dy, N).name(&#34;d2h_y&#34;);&#xA;  &#xA;  // kernel task with parameters to launch the saxpy kernel&#xA;  tf::cudaTask saxpy = cf.kernel(&#xA;    (N+255)/256, 256, 0, saxpy, N, 2.0f, dx, dy&#xA;  ).name(&#34;saxpy&#34;);&#xA;&#xA;  saxpy.succeed(h2d_x, h2d_y)&#xA;       .precede(d2h_x, d2h_y);&#xA;}).name(&#34;cudaFlow&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/saxpy_1_cudaflow.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Compose Task Graphs&lt;/h2&gt; &#xA;&lt;p&gt;Taskflow is composable. You can create large parallel graphs through composition of modular and reusable blocks that are easier to optimize at an individual scope.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tf::Taskflow f1, f2;&#xA;&#xA;// create taskflow f1 of two tasks&#xA;tf::Task f1A = f1.emplace([]() { std::cout &amp;lt;&amp;lt; &#34;Task f1A\n&#34;; })&#xA;                 .name(&#34;f1A&#34;);&#xA;tf::Task f1B = f1.emplace([]() { std::cout &amp;lt;&amp;lt; &#34;Task f1B\n&#34;; })&#xA;                 .name(&#34;f1B&#34;);&#xA;&#xA;// create taskflow f2 with one module task composed of f1&#xA;tf::Task f2A = f2.emplace([]() { std::cout &amp;lt;&amp;lt; &#34;Task f2A\n&#34;; })&#xA;                 .name(&#34;f2A&#34;);&#xA;tf::Task f2B = f2.emplace([]() { std::cout &amp;lt;&amp;lt; &#34;Task f2B\n&#34;; })&#xA;                 .name(&#34;f2B&#34;);&#xA;tf::Task f2C = f2.emplace([]() { std::cout &amp;lt;&amp;lt; &#34;Task f2C\n&#34;; })&#xA;                 .name(&#34;f2C&#34;);&#xA;&#xA;tf::Task f1_module_task = f2.composed_of(f1)&#xA;                            .name(&#34;module&#34;);&#xA;&#xA;f1_module_task.succeed(f2A, f2B)&#xA;              .precede(f2C);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/composition.svg?sanitize=true&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Launch Asynchronous Tasks&lt;/h2&gt; &#xA;&lt;p&gt;Taskflow supports &lt;em&gt;asynchronous&lt;/em&gt; tasking. You can launch tasks asynchronously to incorporate independent, dynamic parallelism in your taskflows.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tf::Executor executor;&#xA;tf::Taskflow taskflow;&#xA;&#xA;// create asynchronous tasks directly from an executor&#xA;tf::Future&amp;lt;std::optional&amp;lt;int&amp;gt;&amp;gt; future = executor.async([](){ &#xA;  std::cout &amp;lt;&amp;lt; &#34;async task returns 1\n&#34;;&#xA;  return 1;&#xA;}); &#xA;executor.silent_async([](){ std::cout &amp;lt;&amp;lt; &#34;async task of no return\n&#34;; });&#xA;&#xA;// launch an asynchronous task from a running task&#xA;taskflow.emplace([&amp;amp;](){&#xA;  executor.async([](){ std::cout &amp;lt;&amp;lt; &#34;async task within a task\n&#34;; });&#xA;});&#xA;&#xA;executor.run(taskflow).wait();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Execute a Taskflow&lt;/h2&gt; &#xA;&lt;p&gt;The executor provides several &lt;em&gt;thread-safe&lt;/em&gt; methods to run a taskflow. You can run a taskflow once, multiple times, or until a stopping criteria is met. These methods are non-blocking with a &lt;code&gt;tf::Future&amp;lt;void&amp;gt;&lt;/code&gt; return to let you query the execution status.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// runs the taskflow once&#xA;tf::Future&amp;lt;void&amp;gt; run_once = executor.run(taskflow); &#xA;&#xA;// wait on this run to finish&#xA;run_once.get();&#xA;&#xA;// run the taskflow four times&#xA;executor.run_n(taskflow, 4);&#xA;&#xA;// runs the taskflow five times&#xA;executor.run_until(taskflow, [counter=5](){ return --counter == 0; });&#xA;&#xA;// block the executor until all submitted taskflows complete&#xA;executor.wait_for_all();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Leverage Standard Parallel Algorithms&lt;/h2&gt; &#xA;&lt;p&gt;Taskflow defines algorithms for you to quickly express common parallel patterns using standard C++ syntaxes, such as parallel iterations, parallel reductions, and parallel sort.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// standard parallel CPU algorithms&#xA;tf::Task task1 = taskflow.for_each( // assign each element to 100 in parallel&#xA;  first, last, [] (auto&amp;amp; i) { i = 100; }    &#xA;);&#xA;tf::Task task2 = taskflow.reduce(   // reduce a range of items in parallel&#xA;  first, last, init, [] (auto a, auto b) { return a + b; }&#xA;);&#xA;tf::Task task3 = taskflow.sort(     // sort a range of items in parallel&#xA;  first, last, [] (auto a, auto b) { return a &amp;lt; b; }&#xA;);&#xA;&#xA;// standard parallel GPU algorithms&#xA;tf::cudaTask cuda1 = cudaflow.for_each( // assign each element to 100 on GPU&#xA;  dfirst, dlast, [] __device__ (auto i) { i = 100; }&#xA;);&#xA;tf::cudaTask cuda2 = cudaflow.reduce(   // reduce a range of items on GPU&#xA;  dfirst, dlast, init, [] __device__ (auto a, auto b) { return a + b; }&#xA;);&#xA;tf::cudaTask cuda3 = cudaflow.sort(     // sort a range of items on GPU&#xA;  dfirst, dlast, [] __device__ (auto a, auto b) { return a &amp;lt; b; }&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, Taskflow provides composable graph building blocks for you to efficiently implement common parallel algorithms, such as parallel pipeline.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// create a pipeline to propagate five tokens through three serial stages&#xA;tf::Pipeline pl(num_parallel_lines,&#xA;  tf::Pipe{tf::PipeType::SERIAL, [](tf::Pipeflow&amp;amp; pf) {&#xA;    if(pf.token() == 5) {&#xA;      pf.stop();&#xA;    }&#xA;  }},&#xA;  tf::Pipe{tf::PipeType::SERIAL, [](tf::Pipeflow&amp;amp; pf) {&#xA;    printf(&#34;stage 2: input buffer[%zu] = %d\n&#34;, pf.line(), buffer[pf.line()]);&#xA;  }},&#xA;  tf::Pipe{tf::PipeType::SERIAL, [](tf::Pipeflow&amp;amp; pf) {&#xA;    printf(&#34;stage 3: input buffer[%zu] = %d\n&#34;, pf.line(), buffer[pf.line()]);&#xA;  }}&#xA;);&#xA;taskflow.composed_of(pl)&#xA;executor.run(taskflow).wait();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Supported Compilers&lt;/h1&gt; &#xA;&lt;p&gt;To use Taskflow, you only need a compiler that supports C++17:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;GNU C++ Compiler at least v8.4 with -std=c++17&lt;/li&gt; &#xA; &lt;li&gt;Clang C++ Compiler at least v6.0 with -std=c++17&lt;/li&gt; &#xA; &lt;li&gt;Microsoft Visual Studio at least v19.27 with /std:c++17&lt;/li&gt; &#xA; &lt;li&gt;AppleClang Xode Version at least v12.0 with -std=c++17&lt;/li&gt; &#xA; &lt;li&gt;Nvidia CUDA Toolkit and Compiler (nvcc) at least v11.1 with -std=c++17&lt;/li&gt; &#xA; &lt;li&gt;Intel C++ Compiler at least v19.0.1 with -std=c++17&lt;/li&gt; &#xA; &lt;li&gt;Intel DPC++ Clang Compiler at least v13.0.0 with -std=c++17 and SYCL20&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Taskflow works on Linux, Windows, and Mac OS X.&lt;/p&gt; &#xA;&lt;h1&gt;Learn More about Taskflow&lt;/h1&gt; &#xA;&lt;p&gt;Visit our &lt;a href=&#34;https://taskflow.github.io/&#34;&gt;project website&lt;/a&gt; and &lt;a href=&#34;https://taskflow.github.io/taskflow/index.html&#34;&gt;documentation&lt;/a&gt; to learn more about Taskflow. To get involved:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;See &lt;a href=&#34;https://taskflow.github.io/taskflow/Releases.html&#34;&gt;release notes&lt;/a&gt; to stay up-to-date with newest versions&lt;/li&gt; &#xA; &lt;li&gt;Read the step-by-step tutorial at &lt;a href=&#34;https://taskflow.github.io/taskflow/pages.html&#34;&gt;cookbook&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Submit an issue at &lt;a href=&#34;https://github.com/taskflow/taskflow/issues&#34;&gt;GitHub issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Find out our technical details at &lt;a href=&#34;https://taskflow.github.io/taskflow/References.html&#34;&gt;references&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Watch our technical talks at YouTube&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=MX15huP5DsM&#34;&gt;CppCon20 Tech Talk&lt;/a&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=u8Mc_WgGwVY&#34;&gt;MUC++ Tech Talk&lt;/a&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/cppcon20-thumbnail.jpg&#34; alt=&#34;&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/muc++20-thumbnail.jpg&#34; width=&#34;100%&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;We are committed to support trustworthy developments for both academic and industrial research projects in parallel and heterogeneous computing. If you are using Taskflow, please cite the following paper we publised at 2021 IEEE TPDS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tsung-Wei Huang, Dian-Lun Lin, Chun-Xun Lin, and Yibo Lin, &#34;&lt;a href=&#34;https://tsung-wei-huang.github.io/papers/tpds21-taskflow.pdf&#34;&gt;Taskflow: A Lightweight Parallel and Heterogeneous Task Graph Computing System&lt;/a&gt;,&#34; &lt;i&gt;IEEE Transactions on Parallel and Distributed Systems (TPDS)&lt;/i&gt;, vol. 33, no. 6, pp. 1303-1320, June 2022&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More importantly, we appreciate all Taskflow &lt;a href=&#34;https://taskflow.github.io/taskflow/contributors.html&#34;&gt;contributors&lt;/a&gt; and the following organizations for sponsoring the Taskflow project!&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&#xA;    &lt;!-- --&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&#xA;    &lt;!-- --&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&#xA;    &lt;!-- --&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&#xA;    &lt;!-- --&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/utah-ece-logo.png&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/nsf.png&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/darpa.png&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/NumFocus.png&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/doxygen/images/nvidia-logo.png&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Taskflow is licensed with the &lt;a href=&#34;https://raw.githubusercontent.com/taskflow/taskflow/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;. You are completely free to re-distribute your work derived from Taskflow.&lt;/p&gt; &#xA;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>cdcseacave/openMVS</title>
    <updated>2022-07-23T01:31:16Z</updated>
    <id>tag:github.com,2022-07-23:/cdcseacave/openMVS</id>
    <link href="https://github.com/cdcseacave/openMVS" rel="alternate"></link>
    <summary type="html">&lt;p&gt;open Multi-View Stereo reconstruction library&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OpenMVS: open Multi-View Stereo reconstruction library&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sketchfab.com/models/3aedcdd22c31447199c18dd9aec5d952/embed&#34;&gt;&lt;img src=&#34;https://i.imgur.com/S4L0E6r.jpeg&#34; alt=&#34;Watch reconstruction&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://cdcseacave.github.io/openMVS&#34;&gt;OpenMVS (Multi-View Stereo)&lt;/a&gt; is a library for computer-vision scientists and especially targeted to the Multi-View Stereo reconstruction community. While there are mature and complete open-source projects targeting Structure-from-Motion pipelines (like &lt;a href=&#34;https://github.com/openMVG/openMVG&#34;&gt;OpenMVG&lt;/a&gt;) which recover camera poses and a sparse 3D point-cloud from an input set of images, there are none addressing the last part of the photogrammetry chain-flow. &lt;em&gt;OpenMVS&lt;/em&gt; aims at filling that gap by providing a complete set of algorithms to recover the full surface of the scene to be reconstructed. The input is a set of camera poses plus the sparse point-cloud and the output is a textured mesh. The main topics covered by this project are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;dense point-cloud reconstruction&lt;/strong&gt; for obtaining a complete and accurate as possible point-cloud&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;mesh reconstruction&lt;/strong&gt; for estimating a mesh surface that explains the best the input point-cloud&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;mesh refinement&lt;/strong&gt; for recovering all fine details&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;mesh texturing&lt;/strong&gt; for computing a sharp and accurate texture to color the mesh&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the complete &lt;a href=&#34;https://github.com/cdcseacave/openMVS/wiki&#34;&gt;documentation&lt;/a&gt; on wiki.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/cdcseacave/openMVS/wiki/Building&#34;&gt;building&lt;/a&gt; wiki page. Windows and Ubuntu x64 continuous integration status &lt;a href=&#34;https://ci.appveyor.com/project/cdcseacave/openmvs&#34;&gt;&lt;img src=&#34;https://ci.appveyor.com/api/projects/status/github/cdcseacave/openmvs?branch=master&amp;amp;svg=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; Automatic Windows x64 binary builds can be found for each commit on its Appveyor Artifacts page.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;p&gt;See the usage &lt;a href=&#34;https://github.com/cdcseacave/openMVS/wiki/Usage&#34;&gt;example&lt;/a&gt; wiki page.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/cdcseacave/openMVS/raw/master/COPYRIGHT.md&#34;&gt;copyright&lt;/a&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;openmvs[AT]googlegroups.com&lt;/p&gt;</summary>
  </entry>
</feed>