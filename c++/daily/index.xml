<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-04T01:25:19Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zk-Call/zkp-hmac-communication-cpp</title>
    <updated>2024-05-04T01:25:19Z</updated>
    <id>tag:github.com,2024-05-04:/zk-Call/zkp-hmac-communication-cpp</id>
    <link href="https://github.com/zk-Call/zkp-hmac-communication-cpp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&#34;Zero-Knowledge&#34; Proof Implementation with HMAC Communication in C++&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;assets/zk-Call Preview [C++].png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;zk-Call &amp;amp; Labs&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;strong&gt;&#34;Zero-Knowledge&#34; Proof Implementation with HMAC Communication in C++&lt;/strong&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;http://badges.github.io/stability-badges/dist/experimental.svg?sanitize=true&#34; alt=&#34;Experimental&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;sub&gt; Built by &lt;a href=&#34;https://github.com/zk-Call&#34;&gt; zk-Call&lt;/a&gt; :) &lt;/sub&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#credits&#34;&gt;Credits&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#purpose&#34;&gt;Purpose&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#how-it-works&#34;&gt;How it Works&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#api&#34;&gt;API&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/#example-usage&#34;&gt;Example Usage&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;This repository hosts a refined implementation of &lt;a href=&#34;https://en.wikipedia.org/wiki/Schnorr_signature&#34;&gt;&lt;strong&gt;Schnorr&#39;s Protocol&lt;/strong&gt;&lt;/a&gt;, innovatively incorporating a state seed for enhanced security measures. While the underlying proofs may appear intricate, I aim to elucidate their functionality to the best of my ability. However, for a deeper understanding, I encourage referencing the seminal research papers underpinning this implementation, as they offer comprehensive insights.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Schnorr&#39;s%20Protocol.png&#34; alt=&#34;Detailed Schematic Overview of Schnorr&#39;s Protocol (Example)&#34;&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;For further exploration:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/1107.1626.pdf&#34;&gt;&lt;strong&gt;Elliptic Curve Based &#34;Zero-Knowledge&#34; Proofs and Their Applicability on Resource Constrained Devices by Ioannis Chatzigiannakis, Apostolos Pyrgelis, Paul G. Spirakis, and Yannis C. Stamatiou&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Elliptic%20Curve.png&#34; alt=&#34;Detailed Schematic Overview of Elliptic Curves (Example)&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Additionally, this repository delves into the concepts of &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; and &lt;strong&gt;Hash-based Message Authentication Codes (HMACs)&lt;/strong&gt;. &lt;strong&gt;ZKPs&lt;/strong&gt; are cryptographic protocols that allow one party &lt;strong&gt;(the prover)&lt;/strong&gt; to prove to another party &lt;strong&gt;(the verifier)&lt;/strong&gt; that a given statement is true, without revealing any additional information beyond the validity of the statement itself. This property is particularly valuable for preserving privacy while establishing trust. &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;On the other hand, &lt;strong&gt;HMACs&lt;/strong&gt; are a type of cryptographic hash function used for message authentication. They involve a cryptographic hash function &lt;strong&gt;(such as SHA-256)&lt;/strong&gt; and a secret cryptographic key. &lt;strong&gt;HMACs&lt;/strong&gt; provide a way to verify both the data integrity and the authenticity of a message, ensuring that it has not been altered or tampered with during transmission and that it indeed originates from the purported sender. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Purpose&lt;/h1&gt; &#xA;&lt;p&gt;In today&#39;s rapidly evolving IT and application development landscape, &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; emerge as a pivotal paradigm for authentication security. Their capacity to affirm the validity of a claim, such as proving possession of a secret password â€” without revealing any sensitive information about the claim itself, such as passwords or hashes, revolutionizes the assurance of secure &lt;strong&gt;AAA operations&lt;/strong&gt; (&lt;strong&gt;authentication&lt;/strong&gt;, &lt;strong&gt;authorization&lt;/strong&gt;, and &lt;strong&gt;accounting&lt;/strong&gt;).&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Purpose-1.png&#34; alt=&#34;The Purpose of our Repositories and The Overall Technology&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;zk-Call &amp;amp; Labs&lt;/strong&gt; represents an implementation of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof&#34;&gt;&lt;strong&gt;Non-Interactive &#34;Zero-Knowledge&#34; Proof&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;(NIZKP)&lt;/strong&gt; protocol tailored specifically for validating text-based secrets. This framework proves invaluable for safeguarding passwords and other authentication mechanisms, ensuring robust security measures without compromising privacy. Additionally, the integration of &lt;strong&gt;HMAC (Hash-Based Message Authentication Code)&lt;/strong&gt; further fortifies the authentication process, enhancing data integrity and thwarting potential security breaches. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;How It Works&lt;/h1&gt; &#xA;&lt;p&gt;The authentication protocol employed in this system operates based on two fundamental concepts: &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/strong&gt; and &lt;strong&gt;Hash-Based Message Authentication Code (HMAC)&lt;/strong&gt;. Let&#39;s delve into each of these components and understand how they synergize to ensure secure authentication in messaging applications. &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs)&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs (ZKPs):&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;ZKPs&lt;/strong&gt; form the bedrock of privacy-preserving authentication mechanisms. These proofs allow one party &lt;strong&gt;(the prover)&lt;/strong&gt; to demonstrate the validity of a claim to another party &lt;strong&gt;(the verifier)&lt;/strong&gt; without revealing any additional information beyond the claim&#39;s validity. In essence, &lt;strong&gt;ZKPs&lt;/strong&gt; enable authentication without the need for the prover to disclose sensitive data, such as passwords or cryptographic keys.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-1.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (1)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-2.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (2)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-3.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (3)&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/ZKP-HMAC-4.png&#34; alt=&#34;Detailed Schematic Overview of &amp;quot;Zero-Knowledge&amp;quot; Technology (4)&#34;&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Application in Authentication:&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In the context of messaging applications, &lt;strong&gt;ZKPs&lt;/strong&gt; play a pivotal role in verifying a user&#39;s identity without the need to transmit explicit credentials over the network. Instead, users can generate cryptographic proofs attesting to their identity or possession of certain credentials without exposing those credentials themselves. This ensures that sensitive information remains confidential during the authentication process, bolstering security and privacy. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Hash-Based Message Authentication Code (HMAC)&lt;/h2&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Hash-Based Message Authentication Code (HMAC):&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;HMAC&lt;/strong&gt; provides a robust mechanism for verifying the integrity and authenticity of messages exchanged between parties. It involves the use of a cryptographic hash function in conjunction with a secret key to generate a unique code &lt;strong&gt;(the HMAC)&lt;/strong&gt; for each message. This code serves as a digital signature, allowing the recipient to verify that the message has not been tampered with or altered during transmission.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/HMAC.png&#34; alt=&#34;Detailed Schematic Overview of HMAC Encryption&#34;&gt;&lt;/p&gt; &#xA;&lt;h4&gt;&lt;strong&gt;Application in Authentication:&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;In messaging applications, &lt;strong&gt;HMAC&lt;/strong&gt; can be employed to authenticate message senders and ensure the integrity of communication channels. By appending an &lt;strong&gt;HMAC&lt;/strong&gt; to each message using a shared secret key, both the sender and recipient can validate the message&#39;s authenticity upon receipt. Any unauthorized modifications to the message would result in a mismatch between the &lt;strong&gt;computed HMAC&lt;/strong&gt; and the &lt;strong&gt;received HMAC&lt;/strong&gt;, thereby alerting the recipient to potential tampering. &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Synergistic Operation&lt;/h2&gt; &#xA;&lt;p&gt;When combined, &lt;strong&gt;&#34;Zero-Knowledge&#34; Proofs&lt;/strong&gt; and &lt;strong&gt;HMAC&lt;/strong&gt; create a formidable framework for secure authentication in messaging applications. &lt;strong&gt;ZKPs&lt;/strong&gt; facilitate identity verification without divulging sensitive information, while &lt;strong&gt;HMAC&lt;/strong&gt; ensures the integrity and authenticity of messages exchanged between parties. Together, these mechanisms uphold the confidentiality, integrity, and authenticity of communication channels, safeguarding users&#39; privacy and security in the digital realm.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Synergistic%20Operation.png&#34; alt=&#34;The Advantages of Synergy between &amp;quot;Zero-Knowledge&amp;quot; Proof and HMAC&#34;&gt; &lt;br&gt; &lt;br&gt;&lt;/p&gt; &#xA;&lt;h1&gt;API&lt;/h1&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;&#34;HMAC_Client&#34;&lt;/code&gt;&lt;/strong&gt; Ð¡++ API is meant to be simple and intuitive:&lt;/p&gt; &#xA;&lt;h2&gt;Core Components&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;strong&gt;&lt;code&gt;Core Components&lt;/code&gt;&lt;/strong&gt; streamline secure &lt;strong&gt;Message Encryption&lt;/strong&gt; and &lt;strong&gt;Decryption&lt;/strong&gt;, supporting both &lt;strong&gt;Chunk&lt;/strong&gt; and &lt;strong&gt;Character-Level&lt;/strong&gt; processing for enhanced data protection.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zk-Call/zkp-hmac-communication-cpp/master/assets/Core%20Components%20(C++).png&#34; alt=&#34;Detailed Schematic Overview of Core Components&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h4&gt;HMAC_Client.encrypt_message_by_chunks&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;encrypt a message&lt;/strong&gt; by processing it in &lt;strong&gt;chunks&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;std::string encrypt_message_by_chunks(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be encrypted, processed in chunks&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HMAC_Client.encrypt_message&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;encrypt a message&lt;/strong&gt; by a &lt;strong&gt;chars&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;std::string encrypt_message(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be encrypted, processed in characters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HMAC_Client.decrypt_message_by_chunks&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;decrypt a message&lt;/strong&gt; by processing it in &lt;strong&gt;chunks&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; std::string decrypt_message_by_chunks(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be decrypted, processed in chunks&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;HMAC_Client.decrypt_message&lt;/h4&gt; &#xA;&lt;p&gt;Method to &lt;strong&gt;decrypt a message&lt;/strong&gt; by processing it in &lt;strong&gt;chars&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt; std::string encrypt_message(const std::string&amp;amp; message);&#xA;&#xA;    message: string                    # The message to be decrypted, processed in characters&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Example Usage&lt;/h1&gt; &#xA;&lt;p&gt;TODO: Include &lt;strong&gt;&lt;code&gt;Example Usage&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example 1&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt; // Include the input/output stream standard header&#xA;#include &amp;lt;thread&amp;gt; // Include the thread standard header&#xA;#include &amp;lt;queue&amp;gt; // Include the queue standard header&#xA;#include &amp;lt;string&amp;gt; // Include the string standard header&#xA;#include &#34;src/HMAC/core/base.h&#34; // Include the header file for HMAC_Client functionality&#xA;#include &#34;src/SeedGeneration/core/base.h&#34; // Include the header file for SeedGenerator functionality&#xA;&#xA;constexpr bool DEBUG = true; // Define a constexpr boolean variable DEBUG with value true&#xA;&#xA;void print_msg(const std::string &amp;amp;who, const std::string &amp;amp;message) { // Define a function to print messages&#xA;    if (DEBUG) { // Check if debugging is enabled&#xA;        std::cout &amp;lt;&amp;lt; &#34;[&#34; &amp;lt;&amp;lt; who &amp;lt;&amp;lt; &#34;] &#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; std::endl; // Print the message with source identifier&#xA;    }&#xA;}&#xA;&#xA;bool check_if_queue_empty(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to check if a queue is empty&#xA;    while (true) { // Infinite loop&#xA;        if (!socket.empty()) { // Check if the queue is not empty&#xA;            return true; // Return true if the queue is not empty&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;std::string get_content_from_socket(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to get content from a socket (queue)&#xA;    if (check_if_queue_empty(socket)) { // Check if the queue is not empty&#xA;        std::string val = socket.front(); // Get the front element of the queue&#xA;        socket.pop(); // Remove the front element from the queue&#xA;        return val; // Return the retrieved value&#xA;    }&#xA;}&#xA;&#xA;void client(std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket) { // Define the client function&#xA;    // Generating the main seed&#xA;    SeedGenerator seed_generator(&#34;job&#34;); // Create an instance of SeedGenerator&#xA;    std::vector&amp;lt;unsigned char&amp;gt; main_seed = seed_generator.generate(); // Generate the main seed&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    print_msg(&#34;client&#34;, &#34;first&#34;);&#xA;    HMAC_Client obj(&#34;sha256&#34;, main_seed, 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending the main seed to the server&#xA;    server_socket.emplace(main_seed.begin(), main_seed.end()); // Convert the main seed vector to a string and send it to the server&#xA;    print_msg(&#34;client&#34;, &#34;after obj&#34;);&#xA;&#xA;    // Checking if the server has successfully received the seed&#xA;    if (get_content_from_socket(client_socket) == obj.encrypt_message(&#34;&#34;)) { // Check if the server received the seed&#xA;        print_msg(&#34;client&#34;, &#34;after if&#34;);&#xA;&#xA;        // If successful, send a message to the server&#xA;        std::string message = &#34;hello&#34;; // Define the message to be sent&#xA;        server_socket.push(obj.encrypt_message_by_chunks(message)); // Encrypt and send the message to the server&#xA;        print_msg(&#34;client&#34;, &#34;client sent message &#34; + message);&#xA;&#xA;        // Checking if the server has successfully decrypted the message&#xA;        if (get_content_from_socket(client_socket) == obj.encrypt_message(message)) { // Check if the server decrypted the message&#xA;            print_msg(&#34;client&#34;, &#34;server has decrypted message&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;void server(std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket) { // Define the server function&#xA;    // Receiving the main seed from the client&#xA;    std::string main_seed = get_content_from_socket(server_socket); // Receive the main seed from the client&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    HMAC_Client obj(&#34;sha256&#34;, std::vector&amp;lt;unsigned char&amp;gt;(main_seed.begin(), main_seed.end()), 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending an empty message to the client as acknowledgment&#xA;    client_socket.push(obj.encrypt_message(&#34;&#34;)); // Encrypt and send an empty message to the client as acknowledgment&#xA;&#xA;    // Receiving the encrypted message from the client&#xA;    std::string msg = get_content_from_socket(server_socket); // Receive the encrypted message from the client&#xA;    print_msg(&#34;server&#34;, &#34;message encrypted: &#34; + msg);&#xA;&#xA;    // Decrypting the message&#xA;    print_msg(&#34;server&#34;, &#34;before decrypt &#34;);&#xA;    std::string msg_raw = obj.decrypt_message_by_chunks(msg); // Decrypt the received message&#xA;    print_msg(&#34;server&#34;, &#34;message raw: &#34; + msg_raw);&#xA;&#xA;    // Sending the encrypted message back to the client&#xA;    client_socket.push(obj.encrypt_message(msg_raw)); // Encrypt and send the decrypted message back to the client&#xA;}&#xA;&#xA;int main() { // Main function&#xA;    std::queue&amp;lt;std::string&amp;gt; client_socket, server_socket; // Create queues for client and server sockets&#xA;    std::thread client_thread(client, std::ref(client_socket), std::ref(server_socket)); // Create a thread for the client function&#xA;    std::thread server_thread(server, std::ref(server_socket), std::ref(client_socket)); // Create a thread for the server function&#xA;&#xA;    // Joining the threads to wait for their completion&#xA;    client_thread.join(); // Wait for the client thread to finish&#xA;    server_thread.join(); // Wait for the server thread to finish&#xA;&#xA;    return 0; // Return 0 to indicate successful execution&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example 2&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;src/ZeroKnowledge/core/base.h&#34; // Include the header file for ZeroKnowledge class&#xA;&#xA;int main() { // Main function&#xA;    // Creating a ZeroKnowledge object for the client with specified curve and hash algorithm&#xA;    ZeroKnowledge clientObject = ZeroKnowledge::createNew(&#34;secp256k1&#34;, &#34;sha3_256&#34;);&#xA;&#xA;    // Creating a ZeroKnowledge object for the server with specified curve and hash algorithm&#xA;    ZeroKnowledge serverObject = ZeroKnowledge::createNew(&#34;secp384r1&#34;, &#34;sha3_512&#34;);&#xA;&#xA;    // Setting the server password&#xA;    std::string serverPassword = &#34;SecretServerPassword&#34;;&#xA;&#xA;    // Creating a signature for the server password&#xA;    ZeroKnowledgeSignature serverSignature = serverObject.createSignature(serverPassword);&#xA;&#xA;    // Creating a signature for the client identity&#xA;    std::string identity = &#34;John&#34;;&#xA;    ZeroKnowledgeSignature clientSignature = clientObject.createSignature(identity);&#xA;    std::cout&amp;lt;&amp;lt;&#34;before\n&#34;;&#xA;&#xA;    // Generating a token signed by the server for the client&#xA;    std::cout&amp;lt;&amp;lt;clientObject.token()&amp;lt;&amp;lt;&#34;\n&#34;;&#xA;&#xA;    ZeroKnowledgeData token = serverObject.sign(serverPassword, clientObject.token());&#xA;    std::cout&amp;lt;&amp;lt;&#34;after\n&#34;;&#xA;&#xA;    // Generating proof using client identity and token&#xA;    ZeroKnowledgeData proof = clientObject.sign(identity, token.data);&#xA;&#xA;    // Verifying the received proof&#xA;    bool serverVerification = serverObject.verify(token, serverSignature);&#xA;    if (!serverVerification) { // Check if server verification failed&#xA;        std::cout &amp;lt;&amp;lt; &#34;Server verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;    } else { // If server verification succeeded&#xA;        // Otherwise, verify the proof using client signature&#xA;        bool clientVerification = clientObject.verify(token, clientSignature, proof.proof);&#xA;        if (!clientVerification) { // Check if client verification failed&#xA;            std::cout &amp;lt;&amp;lt; &#34;Client verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;        } else { // If client verification succeeded&#xA;            std::cout &amp;lt;&amp;lt; &#34;Authentication successful&#34; &amp;lt;&amp;lt; std::endl; // Print success message&#xA;        }&#xA;    }&#xA;&#xA;    return 0; // Return 0 to indicate successful execution&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Example 3&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;#include &#34;src/ZeroKnowledge/core/base.h&#34; // Include the header file for ZeroKnowledge class&#xA;#include &#34;src/HMAC/core/base.h&#34; // Include the header file for HMAC_Client functionality&#xA;#include &#34;src/SeedGeneration/core/base.h&#34; // Include the header file for SeedGenerator functionality&#xA;#include &amp;lt;iostream&amp;gt; // Include the input/output stream standard header&#xA;#include &amp;lt;thread&amp;gt; // Include the thread standard header&#xA;#include &amp;lt;queue&amp;gt; // Include the queue standard header&#xA;#include &amp;lt;string&amp;gt; // Include the string standard header&#xA;&#xA;constexpr bool DEBUG = true; // Define a constexpr boolean variable DEBUG with value true&#xA;&#xA;void print_msg(const std::string &amp;amp;who, const std::string &amp;amp;message) { // Define a function to print messages&#xA;    if (DEBUG) { // Check if debugging is enabled&#xA;        std::cout &amp;lt;&amp;lt; &#34;[&#34; &amp;lt;&amp;lt; who &amp;lt;&amp;lt; &#34;] &#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; std::endl; // Print the message with source identifier&#xA;    }&#xA;}&#xA;&#xA;bool check_if_queue_empty(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to check if a queue is empty&#xA;    while (true) { // Infinite loop&#xA;        if (!socket.empty()) { // Check if the queue is not empty&#xA;            return true; // Return true if the queue is not empty&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;std::string get_content_from_socket(std::queue&amp;lt;std::string&amp;gt; &amp;amp;socket) { // Define a function to get content from a socket (queue)&#xA;    if (check_if_queue_empty(socket)) { // Check if the queue is not empty&#xA;        std::string val = socket.front(); // Get the front element of the queue&#xA;        socket.pop(); // Remove the front element from the queue&#xA;        return val; // Return the retrieved value&#xA;    }&#xA;}&#xA;&#xA;void client(std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket) { // Define the client function&#xA;    // Generating the main seed&#xA;    SeedGenerator seed_generator(&#34;job&#34;); // Create an instance of SeedGenerator&#xA;    std::vector&amp;lt;unsigned char&amp;gt; main_seed = seed_generator.generate(); // Generate the main seed&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    print_msg(&#34;client&#34;, &#34;first&#34;);&#xA;    HMAC_Client obj(&#34;sha256&#34;, main_seed, 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending the main seed to the server&#xA;    server_socket.emplace(main_seed.begin(), main_seed.end()); // Convert the main seed vector to a string and send it to the server&#xA;    print_msg(&#34;client&#34;, &#34;after obj&#34;);&#xA;&#xA;    // Checking if the server has successfully received the seed&#xA;    if (get_content_from_socket(client_socket) == obj.encrypt_message(&#34;&#34;)) { // Check if the server received the seed&#xA;        print_msg(&#34;client&#34;, &#34;after if&#34;);&#xA;&#xA;        // If successful, send a message to the server&#xA;        std::string message = &#34;hello&#34;; // Define the message to be sent&#xA;        server_socket.push(obj.encrypt_message_by_chunks(message)); // Encrypt and send the message to the server&#xA;        print_msg(&#34;client&#34;, &#34;client sent message &#34; + message);&#xA;&#xA;        // Checking if the server has successfully decrypted the message&#xA;        if (get_content_from_socket(client_socket) == obj.encrypt_message(message)) { // Check if the server decrypted the message&#xA;            print_msg(&#34;client&#34;, &#34;server has decrypted message&#34;);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;void server(std::queue&amp;lt;std::string&amp;gt; &amp;amp;server_socket, std::queue&amp;lt;std::string&amp;gt; &amp;amp;client_socket) { // Define the server function&#xA;    // Receiving the main seed from the client&#xA;    std::string main_seed = get_content_from_socket(server_socket); // Receive the main seed from the client&#xA;&#xA;    // Creating an instance of HMAC_Client for encrypting messages&#xA;    HMAC_Client obj(&#34;sha256&#34;, std::vector&amp;lt;unsigned char&amp;gt;(main_seed.begin(), main_seed.end()), 1); // Create an instance of HMAC_Client&#xA;&#xA;    // Sending an empty message to the client as acknowledgment&#xA;    client_socket.push(obj.encrypt_message(&#34;&#34;)); // Encrypt and send an empty message to the client as acknowledgment&#xA;&#xA;    // Receiving the encrypted message from the client&#xA;    std::string msg = get_content_from_socket(server_socket); // Receive the encrypted message from the client&#xA;    print_msg(&#34;server&#34;, &#34;message encrypted: &#34; + msg);&#xA;&#xA;    // Decrypting the message&#xA;    print_msg(&#34;server&#34;, &#34;before decrypt &#34;);&#xA;    std::string msg_raw = obj.decrypt_message_by_chunks(msg); // Decrypt the received message&#xA;    print_msg(&#34;server&#34;, &#34;message raw: &#34; + msg_raw);&#xA;&#xA;    // Sending the encrypted message back to the client&#xA;    client_socket.push(obj.encrypt_message(msg_raw)); // Encrypt and send the decrypted message back to the client&#xA;}&#xA;&#xA;void init_talking() { // Define a function to initialize client-server communication&#xA;    std::queue&amp;lt;std::string&amp;gt; client_socket, server_socket; // Create queues for client and server sockets&#xA;    std::thread client_thread(client, std::ref(client_socket), std::ref(server_socket)); // Create a thread for the client function&#xA;    std::thread server_thread(server, std::ref(server_socket), std::ref(client_socket)); // Create a thread for the server function&#xA;&#xA;    // Joining the threads to wait for their completion&#xA;    client_thread.join(); // Wait for the client thread to finish&#xA;    server_thread.join(); // Wait for the server thread to finish&#xA;}&#xA;&#xA;int main() { // Main function&#xA;&#xA;    // Creating a ZeroKnowledge object for the client with specified curve and hash algorithm&#xA;    ZeroKnowledge clientObject = ZeroKnowledge::createNew(&#34;secp256k1&#34;, &#34;sha3_256&#34;);&#xA;&#xA;    // Creating a ZeroKnowledge object for the server with specified curve and hash algorithm&#xA;    ZeroKnowledge serverObject = ZeroKnowledge::createNew(&#34;secp384r1&#34;, &#34;sha3_512&#34;);&#xA;&#xA;    // Setting the server password&#xA;    std::string serverPassword = &#34;SecretServerPassword&#34;;&#xA;&#xA;    // Creating a signature for the server password&#xA;    ZeroKnowledgeSignature serverSignature = serverObject.createSignature(serverPassword);&#xA;&#xA;    // Creating a signature for the client identity&#xA;    std::string identity = &#34;John&#34;;&#xA;    ZeroKnowledgeSignature clientSignature = clientObject.createSignature(identity);&#xA;    std::cout &amp;lt;&amp;lt; &#34;before\n&#34;;&#xA;&#xA;    // Generating a token signed by the server for the client&#xA;    std::cout &amp;lt;&amp;lt; clientObject.token() &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;&#xA;    ZeroKnowledgeData token = serverObject.sign(serverPassword, clientObject.token());&#xA;    std::cout &amp;lt;&amp;lt; &#34;after\n&#34;;&#xA;&#xA;    // Generating proof using client identity and token&#xA;    ZeroKnowledgeData proof = clientObject.sign(identity, token.data);&#xA;&#xA;    // Verifying the received proof&#xA;    bool serverVerification = serverObject.verify(token, serverSignature);&#xA;    if (!serverVerification) { // Check if server verification failed&#xA;        std::cout &amp;lt;&amp;lt; &#34;Server verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;    } else { // If server verification succeeded&#xA;        // Otherwise, verify the proof using client signature&#xA;        bool clientVerification = clientObject.verify(token, clientSignature, proof.proof);&#xA;        if (!clientVerification) { // Check if client verification failed&#xA;            std::cout &amp;lt;&amp;lt; &#34;Client verification failed&#34; &amp;lt;&amp;lt; std::endl; // Print error message&#xA;        } else { // If client verification succeeded&#xA;            std::cout &amp;lt;&amp;lt; &#34;Authentication successful&#34; &amp;lt;&amp;lt; std::endl; // Print success message&#xA;            init_talking(); // Initialize client-server communication&#xA;&#xA;        }&#xA;    }&#xA;&#xA;    return 0; // Return 0 to indicate successful execution&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>