<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-31T01:24:59Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hanickadot/compile-time-regular-expressions</title>
    <updated>2023-08-31T01:24:59Z</updated>
    <id>tag:github.com,2023-08-31:/hanickadot/compile-time-regular-expressions</id>
    <link href="https://github.com/hanickadot/compile-time-regular-expressions" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compile Time Regular Expression in C++&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Compile time regular expressions v3&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/hanickadot/compile-time-regular-expressions&#34;&gt;&lt;img src=&#34;https://travis-ci.org/hanickadot/compile-time-regular-expressions.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Fast compile-time regular expressions with support for matching/searching/capturing during compile-time or runtime.&lt;/p&gt; &#xA;&lt;p&gt;You can use the single header version from directory &lt;code&gt;single-header&lt;/code&gt;. This header can be regenerated with &lt;code&gt;make single-header&lt;/code&gt;. If you are using cmake, you can add this directory as subdirectory and link to target &lt;code&gt;ctre&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More info at &lt;a href=&#34;https://compile-time.re/&#34;&gt;compile-time.re&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;What this library can do&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ctre::match&amp;lt;&#34;REGEX&#34;&amp;gt;(subject); // C++20&#xA;&#34;REGEX&#34;_ctre.match(subject); // C++17 + N3599 extension&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Matching&lt;/li&gt; &#xA; &lt;li&gt;Searching (&lt;code&gt;search&lt;/code&gt; or &lt;code&gt;starts_with&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Capturing content (named captures are supported too)&lt;/li&gt; &#xA; &lt;li&gt;Back-Reference (\g{N} syntax, and \1...\9 syntax too)&lt;/li&gt; &#xA; &lt;li&gt;Multiline support (with &lt;code&gt;multi_&lt;/code&gt;) functions&lt;/li&gt; &#xA; &lt;li&gt;Unicode properties and UTF-8 support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The library is implementing most of the PCRE syntax with a few exceptions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;callouts&lt;/li&gt; &#xA; &lt;li&gt;comments&lt;/li&gt; &#xA; &lt;li&gt;conditional patterns&lt;/li&gt; &#xA; &lt;li&gt;control characters (&lt;code&gt;\cX&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;match point reset (&lt;code&gt;\K&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;named characters&lt;/li&gt; &#xA; &lt;li&gt;octal numbers&lt;/li&gt; &#xA; &lt;li&gt;options / modes&lt;/li&gt; &#xA; &lt;li&gt;subroutines&lt;/li&gt; &#xA; &lt;li&gt;unicode grapheme cluster (&lt;code&gt;\X&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;More documentation on &lt;a href=&#34;https://www.pcre.org/current/doc/html/pcre2syntax.html&#34;&gt;pcre.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Unknown character escape behaviour&lt;/h3&gt; &#xA;&lt;p&gt;Not all escaped characters are automatically inserted as self, behaviour of the library is escaped characters are with special meaning, unknown escaped character is a syntax error.&lt;/p&gt; &#xA;&lt;p&gt;Explicitly allowed character escapes which insert only the character are:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;\-\&#34;\&amp;lt;\&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Basic API&lt;/h2&gt; &#xA;&lt;p&gt;This is approximated API specification from a user perspective (omitting &lt;code&gt;constexpr&lt;/code&gt; and &lt;code&gt;noexcept&lt;/code&gt; which are everywhere, and using C++20 syntax even the API is C++17 compatible):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// look if whole input matches the regex:&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::match(auto Range &amp;amp;&amp;amp;) -&amp;gt; regex_results;&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::match(auto First &amp;amp;&amp;amp;, auto Last &amp;amp;&amp;amp;) -&amp;gt; regex_results;&#xA;&#xA;// look if input contains match somewhere inside of itself:&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::search(auto Range &amp;amp;&amp;amp;) -&amp;gt; regex_results;&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::search(auto First &amp;amp;&amp;amp;, auto Last &amp;amp;&amp;amp;) -&amp;gt; regex_results;&#xA;&#xA;// check if input starts with match (but doesn&#39;t need to match everything):&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::starts_with(auto Range &amp;amp;&amp;amp;) -&amp;gt; regex_results;&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::starts_with(auto First &amp;amp;&amp;amp;, auto Last &amp;amp;&amp;amp;) -&amp;gt; regex_results;&#xA;&#xA;// result type is deconstructible into a structured bindings&#xA;template &amp;lt;...&amp;gt; struct regex_results {&#xA;&#x9;operator bool() const; // if it&#39;s a match&#xA;&#x9;auto to_view() const -&amp;gt; std::string_view; // also view()&#xA;&#x9;auto to_string() const -&amp;gt; std::string; // also str()&#xA;&#x9;operator std::string_view() const; // also supports all char variants&#xA;&#x9;explicit operator std::string() const;&#xA;&#x9;&#xA;&#x9;// also size(), begin(), end(), data()&#xA;&#x9;&#xA;&#x9;size_t count() const; // number of captures &#xA;&#x9;template &amp;lt;size_t Id&amp;gt; const captured_content &amp;amp; get() const; // provide specific capture, whole regex_results is implicit capture 0&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Range outputing API&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// search for regex in input and return each occurence, ignoring rest:&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::range(auto Range &amp;amp;&amp;amp;) -&amp;gt; range of regex_result;&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::range(auto First &amp;amp;&amp;amp;, auto Last &amp;amp;&amp;amp;) -&amp;gt; range of regex_result;&#xA;&#xA;// return range of each match, stopping at something which can&#39;t be matched&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::tokenize(auto Range &amp;amp;&amp;amp;) -&amp;gt; range of regex_result;&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::tokenize(auto First &amp;amp;&amp;amp;, auto Last &amp;amp;&amp;amp;) -&amp;gt; range of regex_result;&#xA;&#xA;// return parts of the input splited by the regex, returning it as part of content of the implicit zero capture (other captures are not changed, you can use it to access how the values were splitted):&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::split(auto Range &amp;amp;&amp;amp;) -&amp;gt; regex_result;&#xA;template &amp;lt;fixed_string regex&amp;gt; auto ctre::split(auto First &amp;amp;&amp;amp;, auto Last &amp;amp;&amp;amp;) -&amp;gt; range of regex_result;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Functors&lt;/h3&gt; &#xA;&lt;p&gt;All the functions (&lt;code&gt;ctre::match&lt;/code&gt;, &lt;code&gt;ctre::search&lt;/code&gt;, &lt;code&gt;ctre::starts_with&lt;/code&gt;, &lt;code&gt;ctre::range&lt;/code&gt;, &lt;code&gt;ctre::tokenize&lt;/code&gt;, &lt;code&gt;ctre::split&lt;/code&gt;) are functors and can be used without parenthesis:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto matcher = ctre::match&amp;lt;&#34;regex&#34;&amp;gt;;&#xA;if (matcher(input)) ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Possible subjects (inputs)&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;std::string&lt;/code&gt;-like objects (&lt;code&gt;std::string_view&lt;/code&gt; or your own string if it&#39;s providing &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; functions with forward iterators)&lt;/li&gt; &#xA; &lt;li&gt;pairs of forward iterators&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Unicode support&lt;/h3&gt; &#xA;&lt;p&gt;To enable you need to include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;&amp;lt;ctre-unicode.hpp&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;or &lt;code&gt;&amp;lt;ctre.hpp&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;unicode-db.hpp&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Otherwise you will get missing symbols if you try to use the unicode support without enabling it.&lt;/p&gt; &#xA;&lt;h2&gt;Supported compilers&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;clang 7.0+ (template UDL, C++17 syntax)&lt;/li&gt; &#xA; &lt;li&gt;xcode clang 10.0+ (template UDL, C++17 syntax)&lt;/li&gt; &#xA; &lt;li&gt;clang 12.0+ (C++17 syntax, C++20 cNTTP syntax)&lt;/li&gt; &#xA; &lt;li&gt;gcc 8.0+ (template UDL, C++17 syntax)&lt;/li&gt; &#xA; &lt;li&gt;gcc 9.0+ (C++17 &amp;amp; C++20 cNTTP syntax)&lt;/li&gt; &#xA; &lt;li&gt;MSVC 14.29+ (Visual Studio 16.11+) (C++20)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Template UDL syntax&lt;/h3&gt; &#xA;&lt;p&gt;The compiler must support extension N3599, for example as GNU extension in gcc (not in GCC 9.1+) and clang.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr auto match(std::string_view sv) noexcept {&#xA;    using namespace ctre::literals;&#xA;    return &#34;h.*&#34;_ctre.match(sv);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need extension N3599 in GCC 9.1+, you can&#39;t use -pedantic. Also, you need to define macro &lt;code&gt;CTRE_ENABLE_LITERALS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;C++17 syntax&lt;/h3&gt; &#xA;&lt;p&gt;You can provide a pattern as a &lt;code&gt;constexpr ctll::fixed_string&lt;/code&gt; variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static constexpr auto pattern = ctll::fixed_string{ &#34;h.*&#34; };&#xA;&#xA;constexpr auto match(std::string_view sv) noexcept {&#xA;    return ctre::match&amp;lt;pattern&amp;gt;(sv);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(this is tested in MSVC 15.8.8)&lt;/p&gt; &#xA;&lt;h3&gt;C++20 syntax&lt;/h3&gt; &#xA;&lt;p&gt;Currently, the only compiler which supports cNTTP syntax &lt;code&gt;ctre::match&amp;lt;PATTERN&amp;gt;(subject)&lt;/code&gt; is GCC 9+.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr auto match(std::string_view sv) noexcept {&#xA;    return ctre::match&amp;lt;&#34;h.*&#34;&amp;gt;(sv);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Extracting number from input&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::optional&amp;lt;std::string_view&amp;gt; extract_number(std::string_view s) noexcept {&#xA;    if (auto m = ctre::match&amp;lt;&#34;[a-z]+([0-9]+)&#34;&amp;gt;(s)) {&#xA;        return m.get&amp;lt;1&amp;gt;().to_view();&#xA;    } else {&#xA;        return std::nullopt;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gcc.godbolt.org/z/5U67_e&#34;&gt;link to compiler explorer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Extracting values from date&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct date { std::string_view year; std::string_view month; std::string_view day; };&#xA;&#xA;std::optional&amp;lt;date&amp;gt; extract_date(std::string_view s) noexcept {&#xA;    using namespace ctre::literals;&#xA;    if (auto [whole, year, month, day] = ctre::match&amp;lt;&#34;(\\d{4})/(\\d{1,2})/(\\d{1,2})&#34;&amp;gt;(s); whole) {&#xA;        return date{year, month, day};&#xA;    } else {&#xA;        return std::nullopt;&#xA;    }&#xA;}&#xA;&#xA;//static_assert(extract_date(&#34;2018/08/27&#34;sv).has_value());&#xA;//static_assert((*extract_date(&#34;2018/08/27&#34;sv)).year == &#34;2018&#34;sv);&#xA;//static_assert((*extract_date(&#34;2018/08/27&#34;sv)).month == &#34;08&#34;sv);&#xA;//static_assert((*extract_date(&#34;2018/08/27&#34;sv)).day == &#34;27&#34;sv);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gcc.godbolt.org/z/x64CVp&#34;&gt;link to compiler explorer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Using captures&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto result = ctre::match&amp;lt;&#34;(?&amp;lt;year&amp;gt;\\d{4})/(?&amp;lt;month&amp;gt;\\d{1,2})/(?&amp;lt;day&amp;gt;\\d{1,2})&#34;&amp;gt;(s);&#xA;return date{result.get&amp;lt;&#34;year&#34;&amp;gt;(), result.get&amp;lt;&#34;month&#34;&amp;gt;, result.get&amp;lt;&#34;day&#34;&amp;gt;};&#xA;&#xA;// or in C++ emulation, but the object must have a linkage&#xA;static constexpr ctll::fixed_string year = &#34;year&#34;;&#xA;static constexpr ctll::fixed_string month = &#34;month&#34;;&#xA;static constexpr ctll::fixed_string day = &#34;day&#34;;&#xA;return date{result.get&amp;lt;year&amp;gt;(), result.get&amp;lt;month&amp;gt;, result.get&amp;lt;day&amp;gt;};&#xA;&#xA;// or use numbered access&#xA;// capture 0 is the whole match&#xA;return date{result.get&amp;lt;1&amp;gt;(), result.get&amp;lt;2&amp;gt;, result.get&amp;lt;3&amp;gt;};&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Lexer&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum class type {&#xA;    unknown, identifier, number&#xA;};&#xA;&#xA;struct lex_item {&#xA;    type t;&#xA;    std::string_view c;&#xA;};&#xA;&#xA;std::optional&amp;lt;lex_item&amp;gt; lexer(std::string_view v) noexcept {&#xA;    if (auto [m,id,num] = ctre::match&amp;lt;&#34;([a-z]+)|([0-9]+)&#34;&amp;gt;(v); m) {&#xA;        if (id) {&#xA;            return lex_item{type::identifier, id};&#xA;        } else if (num) {&#xA;            return lex_item{type::number, num};&#xA;        }&#xA;    }&#xA;    return std::nullopt;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://gcc.godbolt.org/z/PKTiCC&#34;&gt;link to compiler explorer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Range over input&lt;/h3&gt; &#xA;&lt;p&gt;This support is preliminary, probably the API will be changed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto input = &#34;123,456,768&#34;sv;&#xA;&#xA;for (auto match: ctre::range&amp;lt;&#34;([0-9]+),?&#34;&amp;gt;(input)) {&#xA;    std::cout &amp;lt;&amp;lt; std::string_view{match.get&amp;lt;0&amp;gt;()} &amp;lt;&amp;lt; &#34;\n&#34;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Unicode&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;ctre-unicode.hpp&amp;gt;&#xA;#include &amp;lt;iostream&amp;gt;&#xA;// needed if you want to output to the terminal&#xA;std::string_view cast_from_unicode(std::u8string_view input) noexcept {&#xA;    return std::string_view(reinterpret_cast&amp;lt;const char *&amp;gt;(input.data()), input.size());&#xA;}&#xA;int main()&#xA;{&#xA;    using namespace std::literals;&#xA;    std::u8string_view original = u8&#34;Tu es un g√©nie&#34;sv;&#xA;&#xA;    for (auto match : ctre::range&amp;lt;&#34;\\p{Letter}+&#34;&amp;gt;(original))&#xA;        std::cout &amp;lt;&amp;lt; cast_from_unicode(match) &amp;lt;&amp;lt; std::endl;&#xA;    return 0;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://godbolt.org/z/erTshe6sz&#34;&gt;link to compiler explorer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installing ctre using vcpkg&lt;/h2&gt; &#xA;&lt;p&gt;You can download and install ctre using the &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;vcpkg&lt;/a&gt; dependency manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Microsoft/vcpkg.git&#xA;cd vcpkg&#xA;./bootstrap-vcpkg.sh&#xA;./vcpkg integrate install&#xA;./vcpkg install ctre&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ctre port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please &lt;a href=&#34;https://github.com/Microsoft/vcpkg&#34;&gt;create an issue or pull request&lt;/a&gt; on the vcpkg repository.&lt;/p&gt; &#xA;&lt;h2&gt;Running tests (for developers)&lt;/h2&gt; &#xA;&lt;p&gt;Just run &lt;code&gt;make&lt;/code&gt; in root of this project.&lt;/p&gt;</summary>
  </entry>
</feed>