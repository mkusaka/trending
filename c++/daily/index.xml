<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-17T01:31:50Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>google/snappy</title>
    <updated>2022-11-17T01:31:50Z</updated>
    <id>tag:github.com,2022-11-17:/google/snappy</id>
    <link href="https://github.com/google/snappy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast compressor/decompressor&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Snappy, a fast compressor/decompressor.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/google/snappy/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/google/snappy/actions/workflows/build.yml/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Introduction&lt;/h1&gt; &#xA;&lt;p&gt;Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression. For instance, compared to the fastest mode of zlib, Snappy is an order of magnitude faster for most inputs, but the resulting compressed files are anywhere from 20% to 100% bigger. (For more information, see &#34;Performance&#34;, below.)&lt;/p&gt; &#xA;&lt;p&gt;Snappy has the following properties:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fast: Compression speeds at 250 MB/sec and beyond, with no assembler code. See &#34;Performance&#34; below.&lt;/li&gt; &#xA; &lt;li&gt;Stable: Over the last few years, Snappy has compressed and decompressed petabytes of data in Google&#39;s production environment. The Snappy bitstream format is stable and will not change between versions.&lt;/li&gt; &#xA; &lt;li&gt;Robust: The Snappy decompressor is designed not to crash in the face of corrupted or malicious input.&lt;/li&gt; &#xA; &lt;li&gt;Free and open source software: Snappy is licensed under a BSD-type license. For more information, see the included COPYING file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Snappy has previously been called &#34;Zippy&#34; in some Google presentations and the like.&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;Snappy is intended to be fast. On a single core of a Core i7 processor in 64-bit mode, it compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more. (These numbers are for the slowest inputs in our benchmark suite; others are much faster.) In our tests, Snappy usually is faster than algorithms in the same class (e.g. LZO, LZF, QuickLZ, etc.) while achieving comparable compression ratios.&lt;/p&gt; &#xA;&lt;p&gt;Typical compression ratios (based on the benchmark suite) are about 1.5-1.7x for plain text, about 2-4x for HTML, and of course 1.0x for JPEGs, PNGs and other already-compressed data. Similar numbers for zlib in its fastest mode are 2.6-2.8x, 3-7x and 1.0x, respectively. More sophisticated algorithms are capable of achieving yet higher compression rates, although usually at the expense of speed. Of course, compression ratio will vary significantly with the input.&lt;/p&gt; &#xA;&lt;p&gt;Although Snappy should be fairly portable, it is primarily optimized for 64-bit x86-compatible processors, and may run slower in other environments. In particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Snappy uses 64-bit operations in several places to process more data at once than would otherwise be possible.&lt;/li&gt; &#xA; &lt;li&gt;Snappy assumes unaligned 32 and 64-bit loads and stores are cheap. On some platforms, these must be emulated with single-byte loads and stores, which is much slower.&lt;/li&gt; &#xA; &lt;li&gt;Snappy assumes little-endian throughout, and needs to byte-swap data in several places if running on a big-endian platform.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Experience has shown that even heavily tuned code can be improved. Performance optimizations, whether for 64-bit x86 or other platforms, are of course most welcome; see &#34;Contact&#34;, below.&lt;/p&gt; &#xA;&lt;h1&gt;Building&lt;/h1&gt; &#xA;&lt;p&gt;You need the CMake version specified in &lt;a href=&#34;https://raw.githubusercontent.com/google/snappy/main/CMakeLists.txt&#34;&gt;CMakeLists.txt&lt;/a&gt; or later to build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule update --init&#xA;mkdir build&#xA;cd build &amp;amp;&amp;amp; cmake ../ &amp;amp;&amp;amp; make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Note that Snappy, both the implementation and the main interface, is written in C++. However, several third-party bindings to other languages are available; see the &lt;a href=&#34;https://raw.githubusercontent.com/google/snappy/main/docs/README.md&#34;&gt;home page&lt;/a&gt; for more information. Also, if you want to use Snappy from C code, you can use the included C bindings in snappy-c.h.&lt;/p&gt; &#xA;&lt;p&gt;To use Snappy from your own C++ program, include the file &#34;snappy.h&#34; from your calling file, and link against the compiled library.&lt;/p&gt; &#xA;&lt;p&gt;There are many ways to call Snappy, but the simplest possible is&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;snappy::Compress(input.data(), input.size(), &amp;amp;output);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and similarly&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;snappy::Uncompress(input.data(), input.size(), &amp;amp;output);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where &#34;input&#34; and &#34;output&#34; are both instances of std::string.&lt;/p&gt; &#xA;&lt;p&gt;There are other interfaces that are more flexible in various ways, including support for custom (non-array) input sources. See the header file for more information.&lt;/p&gt; &#xA;&lt;h1&gt;Tests and benchmarks&lt;/h1&gt; &#xA;&lt;p&gt;When you compile Snappy, the following binaries are compiled in addition to the library itself. You do not need them to use the compressor from your own library, but they are useful for Snappy development.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;snappy_benchmark&lt;/code&gt; contains microbenchmarks used to tune compression and decompression performance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;snappy_unittests&lt;/code&gt; contains unit tests, verifying correctness on your machine in various scenarios.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;snappy_test_tool&lt;/code&gt; can benchmark Snappy against a few other compression libraries (zlib, LZO, LZF, and QuickLZ), if they were detected at configure time. To benchmark using a given file, give the compression algorithm you want to test Snappy against (e.g. --zlib) and then a list of one or more file names on the command line.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you want to change or optimize Snappy, please run the tests and benchmarks to verify you have not broken anything.&lt;/p&gt; &#xA;&lt;p&gt;The testdata/ directory contains the files used by the microbenchmarks, which should provide a reasonably balanced starting point for benchmarking. (Note that baddata[1-3].snappy are not intended as benchmarks; they are used to verify correctness in the presence of corrupted data in the unit test.)&lt;/p&gt; &#xA;&lt;h1&gt;Contributing to the Snappy Project&lt;/h1&gt; &#xA;&lt;p&gt;In addition to the aims listed at the top of the &lt;a href=&#34;https://raw.githubusercontent.com/google/snappy/main/README.md&#34;&gt;README&lt;/a&gt; Snappy explicitly supports the following:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;C++11&lt;/li&gt; &#xA; &lt;li&gt;Clang (gcc and MSVC are best-effort).&lt;/li&gt; &#xA; &lt;li&gt;Low level optimizations (e.g. assembly or equivalent intrinsics) for:&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/X86&#34;&gt;x86&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/X86-64&#34;&gt;x86-64&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;ARMv7 (32-bit)&lt;/li&gt; &#xA; &lt;li&gt;ARMv8 (AArch64)&lt;/li&gt; &#xA; &lt;li&gt;Supports only the Snappy compression scheme as described in &lt;a href=&#34;https://raw.githubusercontent.com/google/snappy/main/format_description.txt&#34;&gt;format_description.txt&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;CMake for building&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Changes adding features or dependencies outside of the core area of focus listed above might not be accepted. If in doubt post a message to the &lt;a href=&#34;https://groups.google.com/g/snappy-compression&#34;&gt;Snappy discussion mailing list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We are unlikely to accept contributions to the build configuration files, such as &lt;code&gt;CMakeLists.txt&lt;/code&gt;. We are focused on maintaining a build configuration that allows us to test that the project works in a few supported configurations inside Google. We are not currently interested in supporting other requirements, such as different operating systems, compilers, or build systems.&lt;/p&gt; &#xA;&lt;h1&gt;Contact&lt;/h1&gt; &#xA;&lt;p&gt;Snappy is distributed through GitHub. For the latest version and other information, see &lt;a href=&#34;https://github.com/google/snappy&#34;&gt;https://github.com/google/snappy&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>uNetworking/uWebSockets.js</title>
    <updated>2022-11-17T01:31:50Z</updated>
    <id>tag:github.com,2022-11-17:/uNetworking/uWebSockets.js</id>
    <link href="https://github.com/uNetworking/uWebSockets.js" rel="alternate"></link>
    <summary type="html">&lt;p&gt;μWebSockets for Node.js back-ends 🤘&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/uNetworking/uWebSockets/master/misc/logo.svg?sanitize=true&#34; height=&#34;180&#34;&gt;&#xA; &lt;br&gt; &#xA; &lt;i&gt;Simple, secure&lt;/i&gt;&#xA; &lt;sup&gt;&lt;a href=&#34;https://github.com/uNetworking/uWebSockets/tree/master/fuzzing#fuzz-testing-of-various-parsers-and-mocked-examples&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&#xA; &lt;i&gt; &amp;amp; standards compliant&lt;/i&gt;&#xA; &lt;sup&gt;&lt;a href=&#34;https://unetworking.github.io/uWebSockets.js/report.pdf&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&#xA; &lt;i&gt; web server for the most demanding&lt;/i&gt;&#xA; &lt;sup&gt;&lt;a href=&#34;https://github.com/uNetworking/uWebSockets/tree/master/benchmarks#benchmark-driven-development&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&#xA; &lt;i&gt; of applications.&lt;/i&gt; &#xA; &lt;a href=&#34;https://github.com/uNetworking/uWebSockets/raw/master/misc/READMORE.md&#34;&gt;Read more...&lt;/a&gt;, &#xA; &lt;a href=&#34;https://unetworkingab.medium.com/a-shorter-take-on-the-npm-slander-38525dbe9484&#34;&gt;slander&lt;/a&gt; &#xA; &lt;br&gt;&#xA; &lt;br&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://github.com/uNetworking/uWebSockets.js/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/uNetworking/uWebSockets.js&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://lgtm.com/projects/g/uNetworking/uWebSockets.js/context:cpp&#34;&gt;&lt;img alt=&#34;Language grade: C/C++&#34; src=&#34;https://img.shields.io/lgtm/grade/cpp/g/uNetworking/uWebSockets.js.svg?logo=lgtm&amp;amp;logoWidth=18&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;amp;can=1&amp;amp;q=proj:uwebsockets&#34;&gt;&lt;img src=&#34;https://oss-fuzz-build-logs.storage.googleapis.com/badges/uwebsockets.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/downloads-65%20million-pink&#34;&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;h3&gt;&lt;span&gt;⚡&lt;/span&gt; Simple performance&lt;/h3&gt; &#xA;&lt;p&gt;µWebSockets.js is an HTTP/WebSocket server for Node.js that runs &lt;strong&gt;&lt;a href=&#34;https://alexhultman.medium.com/serving-100k-requests-second-from-a-fanless-raspberry-pi-4-over-ethernet-fdd2c2e05a1e&#34;&gt;8.5x that of Fastify&lt;/a&gt;&lt;/strong&gt; and at least &lt;strong&gt;&lt;a href=&#34;https://medium.com/swlh/100k-secure-websockets-with-raspberry-pi-4-1ba5d2127a23&#34;&gt;10x that of Socket.IO&lt;/a&gt;&lt;/strong&gt;. It comes with both router and pub/sub support and is suited for extraordinary performance needs. Browse the &lt;a href=&#34;https://unetworking.github.io/uWebSockets.js/generated/&#34;&gt;documentation&lt;/a&gt; and see the &lt;a href=&#34;https://github.com/uNetworking/uWebSockets&#34;&gt;main repo&lt;/a&gt;. There are tons of &lt;a href=&#34;https://raw.githubusercontent.com/uNetworking/uWebSockets.js/master/examples&#34;&gt;examples&lt;/a&gt; but here&#39;s the gist of it all:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/* Non-SSL is simply App() */&#xA;require(&#39;uWebSockets.js&#39;).SSLApp({&#xA;&#xA;  /* There are more SSL options, cut for brevity */&#xA;  key_file_name: &#39;misc/key.pem&#39;,&#xA;  cert_file_name: &#39;misc/cert.pem&#39;,&#xA;  &#xA;}).ws(&#39;/*&#39;, {&#xA;&#xA;  /* There are many common helper features */&#xA;  idleTimeout: 32,&#xA;  maxBackpressure: 1024,&#xA;  maxPayloadLength: 512,&#xA;  compression: DEDICATED_COMPRESSOR_3KB,&#xA;&#xA;  /* For brevity we skip the other events (upgrade, open, ping, pong, close) */&#xA;  message: (ws, message, isBinary) =&amp;gt; {&#xA;    /* You can do app.publish(&#39;sensors/home/temperature&#39;, &#39;22C&#39;) kind of pub/sub as well */&#xA;    &#xA;    /* Here we echo the message back, using compression if available */&#xA;    let ok = ws.send(message, isBinary, true);&#xA;  }&#xA;  &#xA;}).get(&#39;/*&#39;, (res, req) =&amp;gt; {&#xA;&#xA;  /* It does Http as well */&#xA;  res.writeStatus(&#39;200 OK&#39;).writeHeader(&#39;IsExample&#39;, &#39;Yes&#39;).end(&#39;Hello there!&#39;);&#xA;  &#xA;}).listen(9001, (listenSocket) =&amp;gt; {&#xA;&#xA;  if (listenSocket) {&#xA;    console.log(&#39;Listening to port 9001&#39;);&#xA;  }&#xA;  &#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;span&gt;💪&lt;/span&gt; Unfair advantage&lt;/h3&gt; &#xA;&lt;p&gt;Being written in native code directly targeting the Linux kernel makes it way faster than any JavaScript implementation.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/uNetworking/uWebSockets.js/master/misc/chart.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Low latencies are key to customer satisfaction and your competitive edge. Run low latency services at a lower cost.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/uNetworking/uWebSockets.js/master/misc/Manycast%20latency%20comparison%20%5Blower%20is%20better%5D.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;⚔&lt;/span&gt; Battle proven&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;ve been fully standards compliant with a perfect Autobahn|Testsuite score since 2016&lt;sup&gt;&lt;a href=&#34;https://unetworking.github.io/uWebSockets.js/report.pdf&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. µWebSockets powers many of the biggest crypto exchanges in the world, handling trade volumes of multiple billions of USD every day. If you trade crypto, chances are you do so via µWebSockets.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;📦&lt;/span&gt; Easily installed&lt;/h3&gt; &#xA;&lt;p&gt;We &lt;em&gt;recommend, for simplicity&lt;/em&gt; installing with &lt;code&gt;yarn add uWebSockets.js@uNetworking/uWebSockets.js#v20.15.0&lt;/code&gt; or any such &lt;a href=&#34;https://github.com/uNetworking/uWebSockets.js/releases&#34;&gt;release&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Being an open source project, you are of course perfectly free to choose &lt;a href=&#34;https://docs.npmjs.com/cli/v6/commands/npm-install&#34;&gt;other ways of installation&lt;/a&gt; as you might prefer.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;💼&lt;/span&gt; Commercially supported&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/uNetworking&#34;&gt;uNetworking AB&lt;/a&gt; is a Swedish consulting &amp;amp; contracting company dealing with anything related to µWebSockets; development, support and customer success.&lt;/p&gt; &#xA;&lt;p&gt;Don&#39;t hesitate &lt;a href=&#34;mailto:alexhultman@gmail.com&#34;&gt;sending a mail&lt;/a&gt; if you&#39;re building something large, in need of advice or having other business inquiries in mind. We&#39;ll figure out what&#39;s best for both parties and make sure you&#39;re not stepping into one of the many common pitfalls.&lt;/p&gt; &#xA;&lt;p&gt;Special thanks to BitMEX, Bitfinex, Google, Coinbase, Bitwyre and deepstreamHub for allowing the project itself to thrive on GitHub since 2016 - this project would not be possible without these beautiful companies.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;⚙&lt;/span&gt; Gear up&lt;/h3&gt; &#xA;&lt;p&gt;If performance is of utter importance, you don&#39;t necessarily have to use JavaScript/Node.js but could write apps in C++ using &lt;a href=&#34;https://github.com/uNetworking/uWebSockets&#34;&gt;µWebSockets&lt;/a&gt; directly. It works exactly the same way, and will offer the best performance for those highly demanding applications where scripting won&#39;t do.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;span&gt;🤝&lt;/span&gt; Permissively licensed&lt;/h3&gt; &#xA;&lt;p&gt;Intellectual property, all rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;Where such explicit notice is given, source code is licensed Apache License 2.0 which is a permissive OSI-approved license with very few limitations. Modified &#34;forks&#34; should be of nothing but licensed source code, and be made available under another product name. If you&#39;re uncertain about any of this, please ask before assuming.&lt;/p&gt;</summary>
  </entry>
</feed>