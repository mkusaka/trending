<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-28T01:31:49Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kkent030315/CVE-2022-42046</title>
    <updated>2022-12-28T01:31:49Z</updated>
    <id>tag:github.com,2022-12-28:/kkent030315/CVE-2022-42046</id>
    <link href="https://github.com/kkent030315/CVE-2022-42046" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CVE-2022-42046 Proof of Concept of wfshbr64.sys local privilege escalation via DKOM&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;EvilWfshbr&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-42046&#34;&gt;CVE-2022-42046&lt;/a&gt; Proof of Concept of wfshbr64.sys local privilege escalation&lt;/p&gt; &#xA;&lt;p&gt;wfshbr64.sys and wfshbr32.sys specially crafted payload allows arbitrary user to perform bitwise operation with arbitrary EPROCESS offset and flags value to purposely elevate the game process to CodeGen Full protection by manipulating &lt;code&gt;EPROCESS.Protection&lt;/code&gt; and &lt;code&gt;EPROCESS.SignatureLevel&lt;/code&gt; flags (security hole as a feature).&lt;/p&gt; &#xA;&lt;p&gt;The driver is signed by Microsoft hardware compatibility publisher that is submitted via Microsoft Hardware Program.&lt;/p&gt; &#xA;&lt;p&gt;This project was co-researched with &lt;a href=&#34;https://github.com/DoranekoSystems&#34;&gt;@DoranekoSystems&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;&lt;strong&gt;There is a rich Rust CLI version available &lt;a href=&#34;https://raw.githubusercontent.com/kkent030315/CVE-2022-42046/main/wfsexploit&#34;&gt;here&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.virustotal.com/gui/file/b8807e365be2813b7eccd2e4c49afb0d1e131086715638b7a6307cd7d7e9556c&#34;&gt;https://www.virustotal.com/gui/file/b8807e365be2813b7eccd2e4c49afb0d1e131086715638b7a6307cd7d7e9556c&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.virustotal.com/gui/file/89698cad598a56f9e45efffd15d1841e494a2409cc12279150a03842cd6bb7f3&#34;&gt;https://www.virustotal.com/gui/file/89698cad598a56f9e45efffd15d1841e494a2409cc12279150a03842cd6bb7f3&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;MIT. See &lt;a href=&#34;https://raw.githubusercontent.com/kkent030315/CVE-2022-42046/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Suggestion (For Developer)&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use &lt;a href=&#34;https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks&#34;&gt;&lt;code&gt;ObRegisterCallbacks&lt;/code&gt;&lt;/a&gt; instead of forcefully elevating process protection by performing direct kernel object manipulation. There is a good example in &lt;a href=&#34;https://github.com/microsoft/Windows-driver-samples/tree/main/general/obcallback&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;2. IRP&lt;/h2&gt; &#xA;&lt;p&gt;Do not reference IRP after completion. if you have driver verifier enabled you will get caught.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;IofCompleteRequest(Irp, IO_NO_INCREMENT); // IRP is freed here&#xA;return Irp-&amp;gt;IoStatus.Status;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead you should use local variable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NTSTATUS status = STATUS_SUCCESS;&#xA;Irp-&amp;gt;IoStatus.Status = status;&#xA;IofCompleteRequest(Irp, IO_NO_INCREMENT); // IRP is freed here&#xA;return status;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;3. Context Process&lt;/h2&gt; &#xA;&lt;p&gt;It looks like you&#39;re checking null pointer against return value of &lt;code&gt;IoGetCurrentProcess&lt;/code&gt;, but it never return null pointer by design so you do not have to check it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;PEPROCESS CurrentProcess = IoGetCurrentProcess();&#xA;  if ( !CurrentProcess ) // no need to check for null pointer&#xA;    break;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;The Trick&lt;/h1&gt; &#xA;&lt;p&gt;A while after the report, the developer implemented sneaky &#34;additional verification&#34; to defeat our first PoC instead of stepping down from making security holes as a feature.&lt;/p&gt; &#xA;&lt;p&gt;Checks added to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;IOCTL_WFSHBR_REMOVE_FLAG&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IOCTL_WFSHBR_ADD_FLAG&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;IOCTL_WFSHBR_AND_FLAG&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;case IOCTL_WFSHBR_ADD_FLAG: // 0xAA013884&#xA;      if ( !KwfsVerifyCaller(Buffer) ) // verify caller&#xA;        break;&#xA;-     if ( Buffer-&amp;gt;ArbitraryEProcessOffset &amp;gt;= 0x1000 ) // offset limitation check&#xA;+     if ( !KwfsVerifyOffsetAndFlags(Buffer-&amp;gt;ArbitraryEProcessOffset,&#xA;+                                    Buffer-&amp;gt;DesiredFlags) ) // verify the offset and flags&#xA;        break;&#xA;      *(ULONG*)(IoGetCurrentProcess() + Buffer-&amp;gt;ArbitraryEProcessOffset) |= Buffer-&amp;gt;DesiredFlags;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;KwfsVerifyOffsetAndFlags&lt;/h2&gt; &#xA;&lt;p&gt;This routine is designed to be called every time the client requests modification of EPROCESS, and performs verification of &lt;code&gt;Offset&lt;/code&gt; provided by &lt;code&gt;ArbitraryEProcessOffset&lt;/code&gt; field in this PoC â€• and also &lt;code&gt;Flags&lt;/code&gt; provided by &lt;code&gt;DesiredFlags&lt;/code&gt; field in this PoC.&lt;/p&gt; &#xA;&lt;p&gt;The verification is quite simple as it counts &lt;code&gt;1&lt;/code&gt; bits in every bits field of provided flags and if the count greater than eight it will fail.&lt;/p&gt; &#xA;&lt;p&gt;Possible flags pattern map is just four:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;22 00 00 00&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;00 22 00 00&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;00 00 22 00&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;00 00 00 22&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That said, performing following operations 4 times can guarantee that the at least one of attempt should be successfull:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Subtract the &lt;code&gt;ArbitraryEProcessOffset&lt;/code&gt; field by index: &lt;code&gt;offset - index&lt;/code&gt;,&lt;/li&gt; &#xA; &lt;li&gt;And adjust bits in &lt;code&gt;DesiredFlags&lt;/code&gt; field by index: &lt;code&gt;flag &amp;lt;&amp;lt; (index * 8)&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The offset is decremented, so the bitfield adjustment would cause offset to adjust in the bitwise operators.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;*(ULONG*)(IoGetCurrentProcess() + offset) |= flags;&#xA;*(ULONG*)(IoGetCurrentProcess() + offset) &amp;amp;= ~flags;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We have added &lt;code&gt;WfsProtectProcessSupreme&lt;/code&gt; and &lt;code&gt;WfsUnprotectProcessSupreme&lt;/code&gt; functions which performs the attempt and defeated the new trick.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum KwfsState {&#xA;  KwfsStateOnceCall = 0,&#xA;  KwfsStateNeedsValueEquality = 1,&#xA;  KwfsStateValueHasBeenSet = 2,&#xA;};&#xA;&#xA;bool KwfsVerifyOffsetAndFlags(_In_ ULONG offset, _In_ ULONG offset flags)&#xA;{&#xA;  if (KwfsState::KwfsState == KwfsState::KwfsStateOnceCall) {&#xA;    g_KwfsVerifyState = KwfsState::KwfsStateValueHasBeenSet;&#xA;    g_KwfsVerifyStateOffset = offset;&#xA;    g_KwfsVerifyStateFlags = flags;&#xA;    if (offset &amp;lt; 0x1000) { // offset limitation check moved here&#xA;      auto bitcount = 0;&#xA;      for (auto i = 0; i &amp;lt; 32; ++i) { // count `1` bits in flags&#xA;        if (flags &amp;amp; (1 &amp;lt;&amp;lt; i)) {&#xA;          ++bitcount;&#xA;        }&#xA;      }&#xA;      if (bitcount &amp;lt;= 8) { // count must less than nine&#xA;        g_KwfsVerifyState = 1;&#xA;        return true;&#xA;      }&#xA;    }&#xA;  }&#xA;  else&#xA;  {&#xA;    if (g_KwfsVerifyState != KwfsState::KwfsStateValueHasBeenSet&#xA;     || offset != g_KwfsVerifyStateOffset&#xA;     || flags != g_KwfsVerifyStateFlags) {&#xA;      return false;&#xA;    }&#xA;  }&#xA;  return false;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>