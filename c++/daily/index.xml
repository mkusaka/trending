<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-15T01:32:11Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SerenityOS/ladybird</title>
    <updated>2022-09-15T01:32:11Z</updated>
    <id>tag:github.com,2022-09-15:/SerenityOS/ladybird</id>
    <link href="https://github.com/SerenityOS/ladybird" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ladybird web browser&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ladybird Web Browser&lt;/h1&gt; &#xA;&lt;p&gt;The Ladybird Web Browser is a browser using the SerenityOS LibWeb engine with a Qt GUI.&lt;/p&gt; &#xA;&lt;h2&gt;Build Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;Qt6 development packages and a c++20-enabled compiler are required. On Debian/Ubuntu required packages include, but are not limited to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install build-essential cmake libgl1-mesa-dev ninja-build qt6-base-dev qt6-tools-dev-tools&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Arch Linux/Manjaro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo pacman -S base-devel cmake libgl ninja qt6-base qt6-tools qt6-wayland&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the c++ compiler, gcc-11 or clang-13 are required at a minimum for c++20 support.&lt;/p&gt; &#xA;&lt;p&gt;For Ubuntu 20.04 and above, ensure that the Qt6 Wayland packages are available:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install qt6-wayland&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build steps&lt;/h2&gt; &#xA;&lt;p&gt;Basic workflow, using serenity source dir cloned from github:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -GNinja -B Build&#xA;cmake --build Build&#xA;ninja -C Build run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Advanced workflow, using pre-existing serenity checkout.&lt;/p&gt; &#xA;&lt;p&gt;If you previously didn&#39;t set SERENITY_SOURCE_DIR, probably want to blast the Build directory before doing this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -GNinja -B Build -DSERENITY_SOURCE_DIR=/path/to/serenity&#xA;ninja -C Build run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To automatically run in gdb:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ninja -C Build debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run without ninja rule:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# or your existing serenity checkout /path/to/serenity&#xA;export SERENITY_SOURCE_DIR=${PWD}/Build/serenity&#xA;./Build/ladybird&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Experimental Android Build Steps&lt;/h2&gt; &#xA;&lt;h3&gt;Prepping Qt Creator&lt;/h3&gt; &#xA;&lt;p&gt;In order to build an Android APK, the following additional dependencies are required/recommended:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Qt Creator 6.4.0 (dev branch)&lt;/li&gt; &#xA; &lt;li&gt;Android Studio 2021.2 (dev branch)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that Qt Creator 6.3.x LTS does NOT have the required fix to &lt;a href=&#34;https://bugreports.qt.io/browse/QTBUG-104580&#34;&gt;QTBUG-104580&lt;/a&gt; as of 2022-07-16 in order to use NDK 24.&lt;/p&gt; &#xA;&lt;p&gt;The build configuration was tested with the following packages from the Android SDK:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Android Platform and Build Tools version 33&lt;/li&gt; &#xA; &lt;li&gt;Android System Images for API 33 aka &lt;code&gt;&#34;system-images;android-33;google-apis;x86_64&#34;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Android NDK 24.0.8215888 for the llvm-14 based toolchain&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In order to build ladybird for cross compilation, a separate serenity checkout is recommended.&lt;/p&gt; &#xA;&lt;p&gt;e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd ~/Repos&#xA;git clone https://github.com/SerenityOS/serenity&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First create a LagomTools build:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cmake -GNinja -S /path/to/serenity -B BuildTools -Dpackage=LagomTools -DCMAKE_INSTALL_PREFIX=tool-install&#xA;ninja -C BuildTools install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next, create a build configuration in Qt Creator that uses an &lt;code&gt;Android Qt 6.4.0 Debug x86_64&lt;/code&gt; Kit by following the instructions &lt;a href=&#34;https://doc.qt.io/qt-6/android-getting-started.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Ensure that you get Android API 30 or higher, and Android NDK 24 or higher. In the initial standup, an API 33 SDK for Android 13 was used.&lt;/p&gt; &#xA;&lt;p&gt;Setup Android device settings in Qt Creator following this &lt;a href=&#34;https://doc.qt.io/qtcreator/creator-developing-android.html&#34;&gt;link&lt;/a&gt;. Note that Qt Creator might not like the Android NDK version 24 we downloaded earlier, as it&#39;s &#34;too new&#34; and &#34;not supported&#34;. No worries, we can force it to like our version by editing the &lt;code&gt;sdk_defintions.json&lt;/code&gt; file as described under &lt;a href=&#34;https://doc.qt.io/qtcreator/creator-developing-android.html#viewing-android-tool-chain-settings&#34;&gt;Viewing Android Tool Chain Settings&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The relevant snippets of that JSON file are reproduced below. Just have to make sure it&#39;s happy with &#34;platforms;android-33&#34; and the exact installed NDK version.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;        &#34;sdk_essential_packages&#34;: {&#xA;            &#34;default&#34;: [&#34;platform-tools&#34;, &#34;platforms;android-33&#34;, &#34;cmdline-tools;latest&#34;],&#xA;            &#34;linux&#34;: [],&#xA;            &#34;mac&#34;: [],&#xA;            &#34;windows&#34;: [&#34;extras;google;usb_driver&#34;]&#xA;        }&#xA;    },&#xA;    &#34;specific_qt_versions&#34;: [&#xA;        {&#xA;            &#34;versions&#34;: [&#34;default&#34;],&#xA;            &#34;sdk_essential_packages&#34;: [&#34;build-tools;33.0.0&#34;, &#34;ndk;24.0.8215888&#34;],&#xA;            &#34;ndk_path&#34;: &#34;ndk/24.0.8215888&#34;&#xA;        },&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building Ladybird for Android&lt;/h3&gt; &#xA;&lt;p&gt;Next, we can select the &lt;code&gt;Android Qt 6.4.0 Debug x86_64&lt;/code&gt; Kit under the Projects tab of the Qt Creator, and watch CMake have a bad time because we need to edit the configuration.&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;code&gt;Initial Configuration&lt;/code&gt; Tab of the CMake configuration for the Kit, edit the following initial values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;ANDROID_NATIVE_API_LEVEL: 23 --&amp;gt; 30&lt;/li&gt; &#xA; &lt;li&gt;LagomTools_DIR: New Directory setting, set to &lt;code&gt;/path/to/ladybird/tool-install/share/Lagom&lt;/code&gt; for the LagomTools build we created earlier&lt;/li&gt; &#xA; &lt;li&gt;SERENITY_SOURCE_DIR: New path setting, set to your local serenity checkout&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Make sure to click the &lt;code&gt;Reconfigure With Initial Parameters&lt;/code&gt; button, and triple check you&#39;ve been editing the &lt;code&gt;Initial Configuration&lt;/code&gt; tab and not the &lt;code&gt;Current Configuration&lt;/code&gt; one.&lt;/p&gt; &#xA;&lt;p&gt;Build the project, and cross your fingers that it all works :)&lt;/p&gt; &#xA;&lt;h3&gt;Running the Android APK&lt;/h3&gt; &#xA;&lt;p&gt;In order to run the ladybird application, first make sure that the Debug settings in the bottom left of the Qt Creator window are trying to debug ladybird, and not another Lagom target, like LibArchive.&lt;/p&gt; &#xA;&lt;p&gt;Create an Android device to test using the Tools-&amp;gt;Options-&amp;gt;Devices-&amp;gt;Devices add button. This will only work for an Android device if the &lt;code&gt;&#34;system-images;android-33;google-apis;x86_64&#34;&lt;/code&gt; or similar package is installed with the Android SDK &lt;code&gt;sdkmanager&lt;/code&gt; tool.&lt;/p&gt; &#xA;&lt;p&gt;Open up Android Studio, and in the Device Manager edit the created AVD to update its Internal Storage under Advanced Settings. Make sure it&#39;s at least 1 GiB. The default of 800 MiB is generally too small to install ladybird.&lt;/p&gt; &#xA;&lt;p&gt;Hit the Debug or Run green arrows and hope for the best!&lt;/p&gt; &#xA;&lt;p&gt;With luck the application should start up, install the required resources into the internal storage from the APK, and open up the default webpage. Clicking the home button to load serenityos.org should work.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>isl-org/Open3D</title>
    <updated>2022-09-15T01:32:11Z</updated>
    <id>tag:github.com,2022-09-15:/isl-org/Open3D</id>
    <link href="https://github.com/isl-org/Open3D" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open3D: A Modern Library for 3D Data Processing&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/isl-org/Open3D/master/docs/_static/open3d_logo_horizontal.png&#34; width=&#34;320&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;Open3D: A Modern Library for 3D Data Processing&lt;/h1&gt; &#xA;&lt;h4&gt; &lt;a href=&#34;http://www.open3d.org&#34;&gt;Homepage&lt;/a&gt; | &lt;a href=&#34;http://www.open3d.org/docs&#34;&gt;Docs&lt;/a&gt; | &lt;a href=&#34;http://www.open3d.org/docs/release/getting_started.html&#34;&gt;Quick Start&lt;/a&gt; | &lt;a href=&#34;http://www.open3d.org/docs/release/compilation.html&#34;&gt;Compile&lt;/a&gt; | &lt;a href=&#34;http://www.open3d.org/docs/release/index.html#python-api-index&#34;&gt;Python&lt;/a&gt; | &lt;a href=&#34;http://www.open3d.org/docs/release/cpp_api.html&#34;&gt;C++&lt;/a&gt; | &lt;a href=&#34;https://github.com/isl-org/Open3D-ML&#34;&gt;Open3D-ML&lt;/a&gt; | &lt;a href=&#34;https://github.com/isl-org/Open3D/releases&#34;&gt;Viewer&lt;/a&gt; | &lt;a href=&#34;http://www.open3d.org/docs/release/contribute/contribute.html&#34;&gt;Contribute&lt;/a&gt; | &lt;a href=&#34;https://www.youtube.com/channel/UCRJBlASPfPBtPXJSPffJV-w&#34;&gt;Demo&lt;/a&gt; | &lt;a href=&#34;https://github.com/isl-org/Open3D/discussions&#34;&gt;Forum&lt;/a&gt; &lt;/h4&gt; &#xA;&lt;p&gt;Open3D is an open-source library that supports rapid development of software that deals with 3D data. The Open3D frontend exposes a set of carefully selected data structures and algorithms in both C++ and Python. The backend is highly optimized and is set up for parallelization. We welcome contributions from the open-source community.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/isl-org/Open3D/actions?query=workflow%3A%22Ubuntu+CI%22&#34;&gt;&lt;img src=&#34;https://github.com/isl-org/Open3D/workflows/Ubuntu%20CI/badge.svg?sanitize=true&#34; alt=&#34;Ubuntu CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/isl-org/Open3D/actions?query=workflow%3A%22macOS+CI%22&#34;&gt;&lt;img src=&#34;https://github.com/isl-org/Open3D/workflows/macOS%20CI/badge.svg?sanitize=true&#34; alt=&#34;macOS CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/isl-org/Open3D/actions?query=workflow%3A%22Windows+CI%22&#34;&gt;&lt;img src=&#34;https://github.com/isl-org/Open3D/workflows/Windows%20CI/badge.svg?sanitize=true&#34; alt=&#34;Windows CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Core features of Open3D include:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;3D data structures&lt;/li&gt; &#xA; &lt;li&gt;3D data processing algorithms&lt;/li&gt; &#xA; &lt;li&gt;Scene reconstruction&lt;/li&gt; &#xA; &lt;li&gt;Surface alignment&lt;/li&gt; &#xA; &lt;li&gt;3D visualization&lt;/li&gt; &#xA; &lt;li&gt;Physically based rendering (PBR)&lt;/li&gt; &#xA; &lt;li&gt;3D machine learning support with PyTorch and TensorFlow&lt;/li&gt; &#xA; &lt;li&gt;GPU acceleration for core 3D operations&lt;/li&gt; &#xA; &lt;li&gt;Available in C++ and Python&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more, please visit the &lt;a href=&#34;http://www.open3d.org/docs&#34;&gt;Open3D documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Python quick start&lt;/h2&gt; &#xA;&lt;p&gt;Pre-built pip packages support Ubuntu 18.04+, macOS 10.15+ and Windows 10+ (64-bit) with Python 3.6-3.9.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Install&#xA;pip install open3d&#xA;&#xA;# Verify installation&#xA;python -c &#34;import open3d as o3d; print(o3d.__version__)&#34;&#xA;&#xA;# Python API&#xA;python -c &#34;import open3d as o3d; \&#xA;           mesh = o3d.geometry.TriangleMesh.create_sphere(); \&#xA;           mesh.compute_vertex_normals(); \&#xA;           o3d.visualization.draw(mesh, raw_mode=True)&#34;&#xA;&#xA;# Open3D CLI&#xA;open3d example visualization/draw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To get the latest features in Open3D, install the &lt;a href=&#34;http://www.open3d.org/docs/latest/getting_started.html#development-version-pip&#34;&gt;development pip package&lt;/a&gt;. To compile Open3D from source, refer to &lt;a href=&#34;http://www.open3d.org/docs/release/compilation.html&#34;&gt;compiling from source&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;C++ quick start&lt;/h2&gt; &#xA;&lt;p&gt;Checkout the following links to get started with Open3D C++ API&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download Open3D binary package: &lt;a href=&#34;https://github.com/isl-org/Open3D/releases&#34;&gt;Release&lt;/a&gt; or &lt;a href=&#34;http://www.open3d.org/docs/latest/getting_started.html#c&#34;&gt;latest development version&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.open3d.org/docs/release/compilation.html&#34;&gt;Compiling Open3D from source&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.open3d.org/docs/release/cpp_api.html&#34;&gt;Open3D C++ API&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To use Open3D in your C++ project, checkout the following examples&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/isl-org/open3d-cmake-find-package&#34;&gt;Find Pre-Installed Open3D Package in CMake&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/isl-org/open3d-cmake-external-project&#34;&gt;Use Open3D as a CMake External Project&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Open3D-Viewer app&lt;/h2&gt; &#xA;&lt;img width=&#34;480&#34; src=&#34;https://raw.githubusercontent.com/isl-org/Open3D/master/docs/_static/open3d_viewer.png&#34;&gt; &#xA;&lt;p&gt;Open3D-Viewer is a standalone 3D viewer app available on Ubuntu and macOS. Please stay tuned for Windows. Download Open3D Viewer from the &lt;a href=&#34;https://github.com/isl-org/Open3D/releases&#34;&gt;release page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Open3D-ML&lt;/h2&gt; &#xA;&lt;img width=&#34;480&#34; src=&#34;https://raw.githubusercontent.com/isl-org/Open3D-ML/master/docs/images/getting_started_ml_visualizer.gif&#34;&gt; &#xA;&lt;p&gt;Open3D-ML is an extension of Open3D for 3D machine learning tasks. It builds on top of the Open3D core library and extends it with machine learning tools for 3D data processing. To try it out, install Open3D with PyTorch or TensorFlow and check out &lt;a href=&#34;https://github.com/isl-org/Open3D-ML&#34;&gt;Open3D-ML&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Communication channels&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/isl-org/Open3D/issues&#34;&gt;GitHub Issue&lt;/a&gt;: bug reports, feature requests, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/isl-org/Open3D/discussions&#34;&gt;Forum&lt;/a&gt;: discussion on the usage of Open3D.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/D35BGvn&#34;&gt;Discord Chat&lt;/a&gt;: online chats, discussions, and collaboration with other users and developers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Citation&lt;/h2&gt; &#xA;&lt;p&gt;Please cite &lt;a href=&#34;https://arxiv.org/abs/1801.09847&#34;&gt;our work&lt;/a&gt; if you use Open3D.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bib&#34;&gt;@article{Zhou2018,&#xA;    author    = {Qian-Yi Zhou and Jaesik Park and Vladlen Koltun},&#xA;    title     = {{Open3D}: {A} Modern Library for {3D} Data Processing},&#xA;    journal   = {arXiv:1801.09847},&#xA;    year      = {2018},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>A-Normal-User/NtSocket_NtClient_NtServer</title>
    <updated>2022-09-15T01:32:11Z</updated>
    <id>tag:github.com,2022-09-15:/A-Normal-User/NtSocket_NtClient_NtServer</id>
    <link href="https://github.com/A-Normal-User/NtSocket_NtClient_NtServer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Using NtCreateFile and NtDeviceIoControlFile to realize the function of winsock（利用NtCreateFile和NtDeviceIoControlFile 实现winsock的功能）&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;NtSocket_NtClient_NtServer：&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using NtCreateFile and NtDeviceIoControlFile to realize the function of winsock&lt;/li&gt; &#xA; &lt;li&gt;利用NtCreateFile和NtDeviceIoControlFile实现winsock的功能。&lt;/li&gt; &#xA; &lt;li&gt;部分功能参考ReactOS源码实现。&lt;/li&gt; &#xA; &lt;li&gt;现在已经成功封装出了一个NtClient和一个NtServer。&lt;/li&gt; &#xA; &lt;li&gt;源码主体实现了以下函数： &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;WSPSocket（创建socket句柄）&lt;/li&gt; &#xA;   &lt;li&gt;WSPCloseSocket（关闭socket）&lt;/li&gt; &#xA;   &lt;li&gt;WSPBind（Bind一个地址，支持IPv6）&lt;/li&gt; &#xA;   &lt;li&gt;WSPConnect（连接一个地址，大致用法同Connect函数，支持IPv6）&lt;/li&gt; &#xA;   &lt;li&gt;WSPShutdown（Shutdown指定操作，可以同WSAShutdown使用）&lt;/li&gt; &#xA;   &lt;li&gt;WSPListen（基本同Listen函数）&lt;/li&gt; &#xA;   &lt;li&gt;WSPRecv（接收数据，基本同Recv）&lt;/li&gt; &#xA;   &lt;li&gt;WSPSend（发送数据，基本同send）&lt;/li&gt; &#xA;   &lt;li&gt;WSPGetPeerName（基本同GetPeerName，支持IPv6）&lt;/li&gt; &#xA;   &lt;li&gt;WSPGetSockName（基本同GetSockName，支持IPv6）&lt;/li&gt; &#xA;   &lt;li&gt;WSPEventSelect（事件选择模型，基本同WSAEventSelect）&lt;/li&gt; &#xA;   &lt;li&gt;WSPEnumNetworkEvents（事件选择模型，基本同WSAEnumNetworkEvents）&lt;/li&gt; &#xA;   &lt;li&gt;WSPAccept（基本完整实现accept功能）&lt;/li&gt; &#xA;   &lt;li&gt;WSPProcessAsyncSelect（本源码最大的亮点，APC异步Select模型，这是winsock没有开放的模型，IOCP模型本质上也依赖这个完成）&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;前言：&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;本程序只能使用于Windows。&lt;/li&gt; &#xA; &lt;li&gt;本程序开发环境：Win11 x64.&lt;/li&gt; &#xA; &lt;li&gt;本程序理论上兼容x64和x86环境，不过具体出现问题还得具体分析。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;为什么写它？&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;之前看了一篇文章：&lt;a href=&#34;https://www.x86matthew.com/view_post?id=ntsockets&#34; title=&#34;NTSockets - Downloading a file via HTTP using the NtCreateFile and NtDeviceIoControlFile syscalls&#34;&gt;NTSockets - Downloading a file via HTTP using the NtCreateFile and NtDeviceIoControlFile syscalls&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;我觉得这篇文章非常有意思，&lt;strong&gt;直接利用NtCreateFile和Afd驱动建立通信，然后利用NtDeviceIoControlFile实现向afd发送socket控制的信息&lt;/strong&gt;。&lt;/li&gt; &#xA; &lt;li&gt;不过美中不足的是这个程序支持x86（原因是结构体定义的问题），同时也仅实现了Client，其他部分还没有完善。&lt;/li&gt; &#xA; &lt;li&gt;于是便有了这个程序。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;正文：&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;最基础的内容，利用NtCreateFile创建socket句柄：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;SOCKET WSPSocket(&#xA;&#x9;int AddressFamily,&#xA;&#x9;int SocketType,&#xA;&#x9;int Protocol) {&#xA;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;/// 类似于Socket函数，可以创建一个Socket文件句柄&#xA;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;AddressFamily&#34;&amp;gt;Address family(Support IPv6)&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;SocketType&#34;&amp;gt;Socket Type&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;Protocol&#34;&amp;gt;Protocol type&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;returns&amp;gt;如果失败返回INVALID_SOCKET，成功返回Socket文件句柄&amp;lt;/returns&amp;gt;&#xA;&#x9;if (AddressFamily == AF_UNSPEC &amp;amp;&amp;amp; SocketType == 0 &amp;amp;&amp;amp; Protocol == 0) {&#xA;&#x9;&#x9;return INVALID_SOCKET;&#xA;&#x9;}&#xA;&#x9;//进行基础数据设置&#xA;&#x9;if (AddressFamily == AF_UNSPEC) {&#xA;&#x9;&#x9;AddressFamily = AF_INET;&#xA;&#x9;}&#xA;&#x9;if (SocketType == 0)&#xA;&#x9;{&#xA;&#x9;&#x9;switch (Protocol)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;case IPPROTO_TCP:&#xA;&#x9;&#x9;&#x9;SocketType = SOCK_STREAM;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case IPPROTO_UDP:&#xA;&#x9;&#x9;&#x9;SocketType = SOCK_DGRAM;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case IPPROTO_RAW:&#xA;&#x9;&#x9;&#x9;SocketType = SOCK_RAW;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;SocketType = SOCK_STREAM;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (Protocol == 0)&#xA;&#x9;{&#xA;&#x9;&#x9;switch (SocketType)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;case SOCK_STREAM:&#xA;&#x9;&#x9;&#x9;Protocol = IPPROTO_TCP;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case SOCK_DGRAM:&#xA;&#x9;&#x9;&#x9;Protocol = IPPROTO_UDP;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;case SOCK_RAW:&#xA;&#x9;&#x9;&#x9;Protocol = IPPROTO_RAW;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;Protocol = IPPROTO_TCP;&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;byte EaBuffer[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, &#xA;&#x9;&#x9;0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50, &#xA;&#x9;&#x9;0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, &#xA;&#x9;&#x9;0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, &#xA;&#x9;&#x9;0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, &#xA;&#x9;&#x9;0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, &#xA;&#x9;&#x9;0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,&#xA;&#x9;&#x9;0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};&#xA;&#x9;memmove((PVOID)((__int64)EaBuffer + 32), &amp;amp;AddressFamily, 0x4);&#xA;&#x9;memmove((PVOID)((__int64)EaBuffer + 36), &amp;amp;SocketType, 0x4);&#xA;&#x9;memmove((PVOID)((__int64)EaBuffer + 40), &amp;amp;Protocol, 0x4);&#xA;&#x9;if (Protocol == IPPROTO_UDP)&#xA;&#x9;{&#xA;&#x9;&#x9;memmove((PVOID)((__int64)EaBuffer + 24), &amp;amp;Protocol, 0x4);&#xA;&#x9;}&#xA;&#x9;//初始化UNICODE_STRING：&#xA;&#x9;UNICODE_STRING AfdName;&#xA;&#x9;AfdName.Buffer = L&#34;\\Device\\Afd\\Endpoint&#34;;&#xA;&#x9;AfdName.Length = 2 * wcslen(AfdName.Buffer);&#xA;&#x9;AfdName.MaximumLength = AfdName.Length + 2;&#xA;&#x9;OBJECT_ATTRIBUTES  Object;&#xA;&#x9;IO_STATUS_BLOCK IOSB;&#xA;&#x9;//初始化OBJECT_ATTRIBUTES&#xA;&#x9;InitializeObjectAttributes(&amp;amp;Object,&#xA;&#x9;&#x9;&amp;amp;AfdName,&#xA;&#x9;&#x9;OBJ_CASE_INSENSITIVE | OBJ_INHERIT,&#xA;&#x9;&#x9;0,&#xA;&#x9;&#x9;0);&#xA;&#x9;HANDLE MySock;&#xA;&#x9;NTSTATUS Status;&#xA;&#x9;//创建AfdSocket：&#xA;&#x9;Status = ((NtCreateFile)MyNtCreateFile)(&amp;amp;MySock,&#xA;&#x9;&#x9;GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,&#xA;&#x9;&#x9;&amp;amp;Object,&#xA;&#x9;&#x9;&amp;amp;IOSB,&#xA;&#x9;&#x9;NULL,&#xA;&#x9;&#x9;0,&#xA;&#x9;&#x9;FILE_SHARE_READ | FILE_SHARE_WRITE,&#xA;&#x9;&#x9;FILE_OPEN_IF,&#xA;&#x9;&#x9;0,&#xA;&#x9;&#x9;EaBuffer,&#xA;&#x9;&#x9;sizeof(EaBuffer));&#xA;&#x9;if (Status != STATUS_SUCCESS) {&#xA;&#x9;&#x9;return INVALID_SOCKET;&#xA;&#x9;}&#xA;&#x9;else {&#xA;&#x9;&#x9;return (SOCKET)MySock;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;从总体上看来，这部分代码是最简单的，用NtCreateFile创建\Device\Afd\Endpoint的连接，麻烦一点的可能是传递的EaBuffer，不过这部分可以直接通过CE拦截的方式获取数据，也可以参考ReactOS的结构体，我选择了一种介于两者之间的方法实现。&lt;/li&gt; &#xA; &lt;li&gt;这部分的兼容性也是最难实现的，因为不知道不同的系统的结构体会不会有差异，不过我测试基本是没有问题的。&lt;/li&gt; &#xA; &lt;li&gt;创建出socket句柄后，剩下的事情就非常简单了，只需要根据不同的“IOCTL_AFD_”写出各个函数即可。&lt;/li&gt; &#xA; &lt;li&gt;最难的部分其实是WSPProcessAsyncSelect函数。&lt;/li&gt; &#xA; &lt;li&gt;这个需要从WSPAsyncSelect函数说起&lt;/li&gt; &#xA; &lt;li&gt;使用IDA看一下mswsock.WSPAsyncSelect函数，大概长这个样子：&lt;img src=&#34;https://raw.githubusercontent.com/A-Normal-User/NtSocket_NtClient_NtServer/main/image/Async.jpg&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;其中最重要的函数是SockCheckAndInitAsyncSelectHelper：&lt;img src=&#34;https://raw.githubusercontent.com/A-Normal-User/NtSocket_NtClient_NtServer/main/image/complet.jpg&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;SockCheckAndInitAsyncSelectHelper函数先创建了一个\Device\Afd\AsyncSelectHlp的IO（功能未知），&lt;strong&gt;然后用SockCreateAsyncQueuePort函数创建了一个完成端口&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;接着用NtSetInformationFile函数将完成端口和\Device\Afd\AsyncSelectHlp绑定。&lt;/li&gt; &#xA; &lt;li&gt;在SockAsyncSelectCompletion函数中找到SockProcessAsyncSelect：&lt;img src=&#34;https://raw.githubusercontent.com/A-Normal-User/NtSocket_NtClient_NtServer/main/image/SockAsyncSelectCompletion.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;在SockProcessAsyncSelect中找到AsyncSelect真正实现原理：&lt;img src=&#34;https://raw.githubusercontent.com/A-Normal-User/NtSocket_NtClient_NtServer/main/image/SockProcessAsyncSelect.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;（别问我怎么找的，参看ReactOS源码就会很清晰）&lt;/li&gt; &#xA; &lt;li&gt;图中的操作应该是轮询实现的，效率比较低。&lt;/li&gt; &#xA; &lt;li&gt;不过别忘了，NtDeviceIoControlFile是提供了APCRoutine的接口的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;实际上只需要给NtDeviceIoControlFile以APCRoutine接口，就可以实现无需轮询的AsyncSelect&lt;/strong&gt;。&lt;/li&gt; &#xA; &lt;li&gt;大致实现：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NTSTATUS WSPProcessAsyncSelect(&#xA;&#x9;SOCKET Handle,&#xA;&#x9;PVOID ApcRoutine,&#xA;&#x9;ULONG lNetworkEvents,&#xA;&#x9;PVOID UserContext&#xA;) {&#xA;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;/// WSPProcessAsyncSelect是本程序最大的亮点，利用异步化的IOCTL_AFD_SELECT&#xA;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;Handle&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;ApcRoutine&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;lNetworkEvents&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&#xA;&#x9;AFD_AsyncData* AsyncData = (AFD_AsyncData*)malloc(sizeof(AFD_AsyncData));&#xA;&#x9;if (AsyncData == NULL)&#xA;&#x9;{&#xA;&#x9;&#x9;return -1;&#xA;&#x9;}&#xA;&#x9;memset(AsyncData, 0, sizeof(AFD_AsyncData));&#xA;&#x9;AsyncData-&amp;gt;NowSocket = Handle;&#xA;&#x9;AsyncData-&amp;gt;PollInfo.Timeout.HighPart = 0x7FFFFFFF;&#xA;&#x9;AsyncData-&amp;gt;PollInfo.Timeout.LowPart = 0xFFFFFFFF;&#xA;&#x9;AsyncData-&amp;gt;PollInfo.HandleCount = 1;&#xA;&#x9;AsyncData-&amp;gt;PollInfo.Handle = Handle;&#xA;&#x9;AsyncData-&amp;gt;PollInfo.Events = lNetworkEvents;&#xA;&#x9;AsyncData-&amp;gt;UserContext = UserContext;&#xA;&#x9;NTSTATUS Status;&#xA;&#x9;Status = ((NtDeviceIoControlFile)(MyNtDeviceIoControlFile))((HANDLE)Handle,&#xA;&#x9;&#x9;NULL,&#xA;&#x9;&#x9;ApcRoutine,&#xA;&#x9;&#x9;AsyncData,&#xA;&#x9;&#x9;&amp;amp;AsyncData-&amp;gt;IOSB,&#xA;&#x9;&#x9;IOCTL_AFD_SELECT,&#xA;&#x9;&#x9;&amp;amp;AsyncData-&amp;gt;PollInfo,&#xA;&#x9;&#x9;sizeof(AFD_PollInfo),&#xA;&#x9;&#x9;&amp;amp;AsyncData-&amp;gt;PollInfo,&#xA;&#x9;&#x9;sizeof(AFD_PollInfo));&#xA;&#x9;return Status;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;既然已经做出了肌醇函数，剩下的就是封装了。&lt;/li&gt; &#xA; &lt;li&gt;我封装了“WSPClient”和“WSPServer”两个类（一个客户端，一个服务端）&lt;/li&gt; &#xA; &lt;li&gt;虽然功能不是很齐全，但是至少是能用的。&lt;/li&gt; &#xA; &lt;li&gt;主体说一下WSPServer的AsyncSelect：&lt;/li&gt; &#xA; &lt;li&gt;核心源码：&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;VOID __stdcall internal_APCRoutine(&#xA;&#x9;PVOID ApcContext,&#xA;&#x9;PIO_STATUS_BLOCK IoStatusBlock,&#xA;&#x9;PVOID Reserved)&#xA;{&#xA;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;/// 这是一个内部函数，也是本程序最大的亮点：APC异步select&#xA;&#x9;/// Client和服务器socket的select情况会全部调用这个函数，本函数用于分发回调事件。&#xA;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;ApcContext&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;IoStatusBlock&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;Reserved&#34;&amp;gt;&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&#xA;&#x9;AFD_AsyncData* AsyncData = (AFD_AsyncData*)ApcContext;&#xA;&#x9;//读取出ApcContext，保存的是AsyncData，AsyncData的详细使用情况请看WSPProcessAsyncSelect函数的实现。&#xA;&#x9;WSPServer* self = (WSPServer*)AsyncData-&amp;gt;UserContext;&#xA;&#x9;//读取出WSPServer对象，这个主要是读取出回调函数地址。&#xA;&#x9;//然后调用回调函数，参数是socket句柄和事件信息&#xA;&#x9;((WSPServerCallBack)self-&amp;gt;m_CallBack)(AsyncData-&amp;gt;NowSocket, AsyncData-&amp;gt;PollInfo.Events);&#xA;&#x9;//开启下一次APC异步select&#xA;&#x9;WSPProcessAsyncSelect(AsyncData-&amp;gt;NowSocket, internal_APCRoutine, self-&amp;gt;m_EnableEvent, (PVOID)self);&#xA;&#x9;//释放掉原来的AsyncData&#xA;&#x9;free(AsyncData);&#xA;}&#xA;&#xA;&#xA;VOID WSPServer::internal_APCThread(WSPServer* Server) {&#xA;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;/// 本函数是APC异步select的线程函数，用于开启每个socket的APC异步select&#xA;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;Server&#34;&amp;gt;WSPServer对象&amp;lt;/param&amp;gt;&#xA;&#x9;int i = 0;&#xA;&#x9;while (1) {&#xA;&#x9;&#x9;EnterCriticalSection(&amp;amp;Server-&amp;gt;m_CriticalSection);&#xA;&#x9;&#x9;if (!Server-&amp;gt;IsRun) {&#xA;&#x9;&#x9;&#x9;//已经通知本线程退出&#xA;&#x9;&#x9;&#x9;LeaveCriticalSection(&amp;amp;Server-&amp;gt;m_CriticalSection);&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i = Server-&amp;gt;m_NeedAPCSocket.size();&#xA;&#x9;&#x9;i--;&#xA;&#x9;&#x9;for (i; i &amp;gt;= 0; i--) {&#xA;&#x9;&#x9;&#x9;//将m_NeedAPCSocket每一socket读取出来，开启APC异步select&#xA;&#x9;&#x9;&#x9;WSPProcessAsyncSelect(&#xA;&#x9;&#x9;&#x9;&#x9;Server-&amp;gt;m_NeedAPCSocket[i],&#xA;&#x9;&#x9;&#x9;&#x9;internal_APCRoutine,&#xA;&#x9;&#x9;&#x9;&#x9;Server-&amp;gt;m_EnableEvent, &#xA;&#x9;&#x9;&#x9;&#x9;(PVOID)Server&#xA;&#x9;&#x9;&#x9;);&#xA;&#x9;&#x9;&#x9;//后面的APC异步select过程将由函数internal_APCRoutine完成&#xA;&#x9;&#x9;&#x9;Server-&amp;gt;m_NeedAPCSocket.pop_back();&#xA;&#x9;&#x9;&#x9;//删除m_NeedAPCSocket对应的socket&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;LeaveCriticalSection(&amp;amp;Server-&amp;gt;m_CriticalSection);&#xA;&#x9;&#x9;SleepEx(1, true);&#xA;&#x9;}&#xA;}&#xA;&#xA;HANDLE WSPServer::APCAsyncSelect(&#xA;&#x9;WSPServerCallBack*&#x9;ApcCallBack,&#xA;&#x9;int lNetworkEvents&#xA;) {&#xA;&#x9;/// &amp;lt;summary&amp;gt;&#xA;&#x9;/// 开启服务器的APC异步select模式，只能初始化一次&#xA;&#x9;/// &amp;lt;/summary&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;ApcCallBack&#34;&amp;gt;回调函数&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;param name=&#34;lNetworkEvents&#34;&amp;gt;需要异步处理的事件&amp;lt;/param&amp;gt;&#xA;&#x9;/// &amp;lt;returns&amp;gt;返回异步处理线程的句柄&amp;lt;/returns&amp;gt;&#xA;&#x9;if (this-&amp;gt;m_CallBack != NULL) {&#xA;&#x9;&#x9;return INVALID_HANDLE_VALUE;&#xA;&#x9;}&#xA;&#x9;EnterCriticalSection(&amp;amp;this-&amp;gt;m_CriticalSection);&#xA;&#x9;this-&amp;gt;m_EnableEvent = lNetworkEvents;&#xA;&#x9;this-&amp;gt;m_CallBack = ApcCallBack;&#xA;&#x9;//下面将把m_AllClientSocket已有的句柄拷贝到m_NeedAPCSocket&#xA;&#x9;std::copy(m_AllClientSocket.begin(), m_AllClientSocket.end(), m_NeedAPCSocket.begin());&#xA;&#x9;//将服务器socket加入m_NeedAPCSocket&#xA;&#x9;m_NeedAPCSocket.push_back(this-&amp;gt;m_socket);&#xA;&#x9;//启动线程&#xA;&#x9;m_ThreadHandle = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)internal_APCThread, this, 0, NULL);&#xA;&#x9;LeaveCriticalSection(&amp;amp;this-&amp;gt;m_CriticalSection);&#xA;&#x9;return m_ThreadHandle;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;就是利用WSPProcessAsyncSelect函数实现APC异步选择&lt;/li&gt; &#xA; &lt;li&gt;当select状态改变时，程序会通知internal_APCRoutine，internal_APCRoutine再进行回调函数的分发和下一次AsyncSelect的调用。&lt;/li&gt; &#xA; &lt;li&gt;写得不是很精简，勉强能用吧。&lt;/li&gt; &#xA; &lt;li&gt;这种APC方法省去了IOCP模型中很多复杂的步骤，可以说是一个最精简的异步模型了。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;测试：&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Client端请求&lt;code&gt;http://www.baidu.com/index.html&lt;/code&gt;测试：&lt;img src=&#34;https://raw.githubusercontent.com/A-Normal-User/NtSocket_NtClient_NtServer/main/image/Client.gif&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Server端1000连接测试：&lt;img src=&#34;https://raw.githubusercontent.com/A-Normal-User/NtSocket_NtClient_NtServer/main/image/Server.gif&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;测试Server端上万连接，APC效率基本无损失。&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>