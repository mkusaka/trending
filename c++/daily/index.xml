<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-28T01:30:47Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>SysSec-KAIST/LTESniffer</title>
    <updated>2023-04-28T01:30:47Z</updated>
    <id>tag:github.com,2023-04-28:/SysSec-KAIST/LTESniffer</id>
    <link href="https://github.com/SysSec-KAIST/LTESniffer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An Open-source LTE Downlink/Uplink Eavesdropper&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;LTESniffer - An Open-source LTE Downlink/Uplink Eavesdropper&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;LTESniffer&lt;/strong&gt; is An Open-source LTE Downlink/Uplink Eavesdropper&lt;/p&gt; &#xA;&lt;p&gt;It first decodes the Physical Downlink Control Channel (PDCCH) to obtain the Downlink Control Informations (DCIs) and Radio Network Temporary Identifiers (RNTIs) of all active users. Using decoded DCIs and RNTIs, LTESniffer further decodes the Physical Downlink Shared Channel (PDSCH) and Physical Uplink Shared Channel (PUSCH) to retrieve uplink and downlink data traffic.&lt;/p&gt; &#xA;&lt;p&gt;LTESniffer supports an API with three functions for security applications and research. Many LTE security research assumes a passive sniffer that can capture privacy-related packets on the air. However, non of the current open-source sniffers satisfy their requirements as they cannot decode protocol packets in PDSCH and PUSCH. We developed a proof-of-concept security API that supports three tasks that were proposed by previous works: 1) Identity mapping, 2) IMSI collecting, and 3) Capability profiling.&lt;/p&gt; &#xA;&lt;p&gt;Please refer to our &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2023/wisec2023_tuan.pdf&#34;&gt;paper&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;What does LTESniffer capture?&lt;/h2&gt; &#xA;&lt;p&gt;LTESniffer captures the LTE wireless packets between the cell tower and users. It supports capturing the traffic in two directions, the downlink traffic from the cell tower to users; and the uplink traffic from nearby users to the cell tower.&lt;/p&gt; &#xA;&lt;p&gt;LTESniffer can only obtain encrypted packets in most cases because the traffic between the cell tower and users is mostly encrypted. However, some packets are transferred in plaintext by design. For example, the following plain-text messages can be seen in the pcap files from LTESniffer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;System Information Blocks (SIBs), which are broadcast messages containing relevant information for UEs to access the cell tower.&lt;/li&gt; &#xA; &lt;li&gt;Paging messages, which are broadcast messages to request UEs to establish communication with the network.&lt;/li&gt; &#xA; &lt;li&gt;Messages at the beginning of the connection, before the encryption is activated between UEs and the network.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ethical Consideration&lt;/h2&gt; &#xA;&lt;p&gt;The main purpose of LTESniffer is to support security and analysis research on the cellular network. Due to the collection of uplink-downlink user data, any use of LTESniffer must follow the local regulations on sniffing the LTE traffic. We are not responsible for any illegal purposes such as intentionally collecting user privacy-related information.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;LTESniffer is implemented on top of &lt;a href=&#34;https://github.com/falkenber9/falcon&#34;&gt;FALCON&lt;/a&gt; with the help of &lt;a href=&#34;https://github.com/srsran/srsRAN_4G&#34;&gt;srsRAN&lt;/a&gt; library. LTESniffer supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Real-time decoding LTE uplink-downlink control-data channels: PDCCH, PDSCH, PUSCH&lt;/li&gt; &#xA; &lt;li&gt;LTE Advanced and LTE Advanced Pro, up to 256QAM in both uplink and downlink&lt;/li&gt; &#xA; &lt;li&gt;DCI formats: 0, 1A, 1, 1B, 1C, 2, 2A, 2B&lt;/li&gt; &#xA; &lt;li&gt;Transmission modes: 1, 2, 3, 4&lt;/li&gt; &#xA; &lt;li&gt;FDD only&lt;/li&gt; &#xA; &lt;li&gt;Maximum 20 MHz base station.&lt;/li&gt; &#xA; &lt;li&gt;Automatically detect maximum UL/DL modulation schemes of smartphones (64QAM/256QAM on DL and 16QAM/64QAM/256QAM on UL)&lt;/li&gt; &#xA; &lt;li&gt;Automatically detect physical layer configuration per UE.&lt;/li&gt; &#xA; &lt;li&gt;LTE Security API: RNTI-TMSI mapping, IMSI collecting, UECapability Profiling.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Hardware and Software Requirement&lt;/h2&gt; &#xA;&lt;h3&gt;OS Requirement&lt;/h3&gt; &#xA;&lt;p&gt;Recommend using Ubuntu 18.04&lt;/p&gt; &#xA;&lt;h3&gt;Hardware Requirement&lt;/h3&gt; &#xA;&lt;p&gt;Achieving real-time decoding of LTE traffic requires a high-performance CPU with multiple physical cores. Especially when the base station has many active users during the peak hour. LTESniffer was able to achieve real-time decoding when running on an Intel i7-9700K PC to decode traffic on a base station with 150 active users.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;The following hardware is recommended&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Intel i7 CPU with at least 8 physical cores&lt;/li&gt; &#xA; &lt;li&gt;At least 16Gb RAM&lt;/li&gt; &#xA; &lt;li&gt;256 Gb SSD storage&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;SDR&lt;/h3&gt; &#xA;&lt;p&gt;Currently, LTESniffer requires USRP X310 because it needs to synchronize with both uplink and downlink frequencies at a time. USRP X310 should be equipped with GPSDO to maintain stable synchronization. Additionally, two RX antennas are required to enable LTESniffer to decode downlink messages in transmission modes 3 and 4.&lt;/p&gt; &#xA;&lt;p&gt;To sniff only downlink traffic from the base station, one can operate LTESniffer with USRP B210 which is connected to PC via a USB 3.0 port. Similarly, USRB B210 should be equipped with GPSDO and two RX antennas to decode downlink messages in transmission modes 3 and 4.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Dependencies&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Important dependency&lt;/strong&gt;: &lt;a href=&#34;https://github.com/EttusResearch/uhd&#34;&gt;UHD&lt;/a&gt; library version &amp;gt;= 4.0 must be installed in advance (recommend building from source). The following steps can be used on Ubuntu 18.04. Refer to UHD Manual for full installation guidance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;UHD dependencies:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update&#xA;sudo apt-get install autoconf automake build-essential ccache cmake cpufrequtils doxygen ethtool \&#xA;g++ git inetutils-tools libboost-all-dev libncurses5 libncurses5-dev libusb-1.0-0 libusb-1.0-0-dev \&#xA;libusb-dev python3-dev python3-mako python3-numpy python3-requests python3-scipy python3-setuptools \&#xA;python3-ruamel.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Clone and build UHD from source (make sure that the current branch is higher than 4.0)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/EttusResearch/uhd.git&#xA;cd &amp;lt;uhd-repo-path&amp;gt;/host&#xA;mkdir build&#xA;cd build&#xA;cmake ../&#xA;make -j 4&#xA;make test&#xA;sudo make install&#xA;sudo ldconfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Download firmwares for USRPs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo uhd_images_downloader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We use a &lt;a href=&#34;https://www.ettus.com/all-products/10gige-kit/&#34;&gt;10Gb card&lt;/a&gt; to connect USRP X310 to PC, refer to UHD Manual &lt;a href=&#34;https://files.ettus.com/manual/page_usrp_x3x0.html&#34;&gt;[1]&lt;/a&gt;, &lt;a href=&#34;https://files.ettus.com/manual/page_usrp_x3x0_config.html&#34;&gt;[2]&lt;/a&gt; to configure USRP X310 and 10Gb card interface. For USRP B210, it should be connected to PC via a USB 3.0 port.&lt;/p&gt; &#xA;&lt;p&gt;Test the connection and firmware (for USRP X310 only):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo sysctl -w net.core.rmem_max=33554432&#xA;sudo sysctl -w net.core.wmem_max=33554432&#xA;sudo ifconfig &amp;lt;10Gb card interface&amp;gt; mtu 9000&#xA;sudo uhd_usrp_probe&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;srsRAN dependencies:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install build-essential git cmake libfftw3-dev libmbedtls-dev libboost-program-options-dev libconfig++-dev libsctp-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LTESniffer dependencies:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt-get install libglib2.0-dev libudev-dev libcurl4-gnutls-dev libboost-all-dev qtdeclarative5-dev libqt5charts5-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Build LTESniffer from source:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/SysSec-KAIST/LTESniffer.git&#xA;cd LTESniffer&#xA;mkdir build&#xA;cd build&#xA;cmake ../&#xA;make -j 4 (use 4 threads)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;LTESniffer has 3 main functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sniffing LTE downlink traffic from the base station&lt;/li&gt; &#xA; &lt;li&gt;Sniffing LTE uplink traffic from smartphones&lt;/li&gt; &#xA; &lt;li&gt;Security API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After building from source, &lt;code&gt;LTESniffer&lt;/code&gt; is located in &lt;code&gt;&amp;lt;build-dir&amp;gt;/src/LTESniffer&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;General downlink sniffing&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/png/dl_mode_png.png&#34; alt=&#34;LTESniffer Downlink Mode&#34;&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -C -m 0&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -C -m 0&#xA;-A: number of antennas&#xA;-W: number of threads&#xA;-f: downlink frequency&#xA;-C: turn on cell search&#xA;-m: sniffer mode, 0 for downlink sniffing and 1 for uplink sniffing&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: to run &lt;code&gt;LTESniffer&lt;/code&gt; with USRP B210 in the downlink mode, add option &lt;code&gt;-a &#34;num_recv_frames=512&#34; &lt;/code&gt; to the command line. This option extends the receiving buffer for USRP B210 to achieve better synchronization.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -C -m 0 -a &#34;num_recv_frames=512&#34;&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -C -m 0 -a &#34;num_recv_frames=512&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;General uplink sniffing&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/png/ul_mode_png.png&#34; alt=&#34;LTESniffer Uplink Mode&#34;&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -u &amp;lt;UL Freq&amp;gt; -C -m 1&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -u 1745e6 -C -m 1&#xA;-u: uplink frequency&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Security API&lt;/h3&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/png/api_png.png&#34; alt=&#34;LTESniffer API Mode&#34;&gt; &lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -u &amp;lt;UL Freq&amp;gt; -C -m 1 -z 3&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -u 1745e6 -C -m 1 -z 3&#xA;-z: 3 for turnning on 3 functions of sniffer, which are identity mapping, IMSI collecting, and UECapability profiling.&#xA;    2 for UECapability profiling&#xA;    1 for IMSI collecting&#xA;    0 for identity mapping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Specify a base station&lt;/h3&gt; &#xA;&lt;p&gt;LTESniffer can sniff on a specific base station by using options &lt;code&gt;-I &amp;lt;Phycial Cell ID (PCI)&amp;gt; -p &amp;lt;number of Physical Resource Block (PRB)&amp;gt;&lt;/code&gt;. In this case, LTESniffer does not do the cell search but connects directly to the specified cell.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -I &amp;lt;PCI&amp;gt; -p &amp;lt;PRB&amp;gt; -m 0&#xA;sudo ./&amp;lt;build-dir&amp;gt;/src/LTESniffer -A 2 -W &amp;lt;number of threads&amp;gt; -f &amp;lt;DL Freq&amp;gt; -u &amp;lt;UL Freq&amp;gt; -I &amp;lt;PCI&amp;gt; -p &amp;lt;PRB&amp;gt; -m 1&#xA;example: sudo ./src/LTESniffer -A 2 -W 4 -f 1840e6 -u 1745e6 -I 379 -p 100 -m 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The debug mode can be enabled by using option &lt;code&gt;-d&lt;/code&gt;. In this case, the debug messages will be printed on the terminal.&lt;/p&gt; &#xA;&lt;h3&gt;Output of LTESniffer&lt;/h3&gt; &#xA;&lt;p&gt;LTESniffer provides pcap files in the output. The pcap file can be opened by WireShark for further analysis and packet trace. The name of downlink pcap file: &lt;code&gt;sniffer_dl_mode.pcap&lt;/code&gt;, uplink pcap file: &lt;code&gt;sniffer_ul_mode.pcap&lt;/code&gt;, and API pcap file: &lt;code&gt;api_collector.pcap&lt;/code&gt;. The pcap files are located in the same directory &lt;code&gt;LTESniffer&lt;/code&gt; has been executed. To enable the WireShark to analyze the decoded packets correctly, please refer to the WireShark configuration guide &lt;a href=&#34;https://raw.githubusercontent.com/SysSec-KAIST/LTESniffer/main/pcap_file_example/README.md&#34;&gt;here&lt;/a&gt;. There are also some examples of pcap files in the link.&lt;/p&gt; &#xA;&lt;h2&gt;Application Note&lt;/h2&gt; &#xA;&lt;h3&gt;Uplink sniffing mode&lt;/h3&gt; &#xA;&lt;p&gt;When sniffing LTE uplink, LTESniffer requires USRP X310 because it needs to listen to two different frequencies at the same time, 1 for uplink and 1 for downlink. The main target of the uplink sniffing function is to decode uplink traffic from nearby smartphones. However, as LTESniffer needs to decode the downlink traffic to obtain uplink-downlink DCI messages, it also supports decoding downlink traffic at the same time. Nevertheless, the downlink sniffing function is limited to decoding messages which use transmission modes 1 and 2, since LTESniffer only has 1 antenna for downlink.&lt;/p&gt; &#xA;&lt;h3&gt;Distance for uplink sniffing&lt;/h3&gt; &#xA;&lt;p&gt;The effective range for sniffing uplink is limited in LTESniffer due to the capability of the RF front-end of the hardware (i.e. SDR). The uplink signal power from UE is significantly weaker compared to the downlink signal because UE is a handheld device that optimizes battery usage, while the eNB uses sufficient power to cover a large area. To successfully capture the uplink traffic, LTESniffer can increase the strength of the signal power by i) being physically close to the UE, or ii) improving the signal reception capability with specialized hardware, such as a directional antenna, dedicated RF front-end, and signal amplifier.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Is it possible to capture and see the phone call content using LTESniffer? &lt;br&gt; &lt;strong&gt;A:&lt;/strong&gt; No. LTE traffic including phone call traffic is encrypted, so you cannot use LTESniffer to know the content of phone calls of someone. Moreover, it is important to note that sniffing phone calls in the commercial network is illegal in most countries.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;We sincerely appreciate the &lt;a href=&#34;https://github.com/falkenber9/falcon&#34;&gt;FALCON&lt;/a&gt; and &lt;a href=&#34;https://github.com/srsran/srsRAN_4G&#34;&gt;SRS team&lt;/a&gt; for making their great softwares available.&lt;/p&gt; &#xA;&lt;h2&gt;BibTex&lt;/h2&gt; &#xA;&lt;p&gt;Please refer to our &lt;a href=&#34;https://syssec.kaist.ac.kr/pub/2023/wisec2023_tuan.pdf&#34;&gt;paper&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@inproceedings{hoang:ltesniffer,&#xA;  title = {{LTESniffer: An Open-source LTE Downlink/Uplink Eavesdropper}},&#xA;  author = {Hoang, Dinh Tuan and Park, CheolJun and Son, Mincheol and Oh, Taekkyung and Bae, Sangwook and Ahn, Junho and Oh, BeomSeok and Kim, Yongdae},&#xA;  booktitle = {16th ACM Conference on Security and Privacy in Wireless and Mobile Networks (WiSec &#39;23)},&#xA;  year = {2023}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>AcademySoftwareFoundation/MaterialX</title>
    <updated>2023-04-28T01:30:47Z</updated>
    <id>tag:github.com,2023-04-28:/AcademySoftwareFoundation/MaterialX</id>
    <link href="https://github.com/AcademySoftwareFoundation/MaterialX" rel="alternate"></link>
    <summary type="html">&lt;p&gt;MaterialX is an open standard for the exchange of rich material and look-development content across applications and renderers.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXLogo.png&#34; height=&#34;170&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-Apache%202.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/AcademySoftwareFoundation/MaterialX&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/actions?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/workflows/main/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bestpractices.coreinfrastructure.org/projects/6025&#34;&gt;&lt;img src=&#34;https://bestpractices.coreinfrastructure.org/projects/6025/badge&#34; alt=&#34;CII Best Practices&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Introduction&lt;/h3&gt; &#xA;&lt;p&gt;MaterialX is an open standard for representing rich material and look-development content in computer graphics, enabling its platform-independent description and exchange across applications and renderers. Launched at &lt;a href=&#34;https://www.ilm.com/&#34;&gt;Industrial Light &amp;amp; Magic&lt;/a&gt; in 2012, MaterialX has been a key technology in their feature films and real-time experiences since &lt;em&gt;Star Wars: The Force Awakens&lt;/em&gt; and &lt;em&gt;Millennium Falcon: Smugglers Run&lt;/em&gt;. The project was released as open source in 2017, with companies including Sony Pictures Imageworks, Pixar, Autodesk, Adobe, and SideFX contributing to its ongoing development. In 2021, MaterialX became the seventh hosted project of the &lt;a href=&#34;https://www.aswf.io/&#34;&gt;Academy Software Foundation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Quick Start for Developers&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the latest version of the &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; build system.&lt;/li&gt; &#xA; &lt;li&gt;Point CMake to the root of the MaterialX library and generate C++ projects for your platform and compiler.&lt;/li&gt; &#xA; &lt;li&gt;Select the &lt;code&gt;MATERIALX_BUILD_PYTHON&lt;/code&gt; option to build Python bindings.&lt;/li&gt; &#xA; &lt;li&gt;Select the &lt;code&gt;MATERIALX_BUILD_VIEWER&lt;/code&gt; option to build the MaterialX viewer.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Supported Platforms&lt;/h3&gt; &#xA;&lt;p&gt;The MaterialX codebase requires a compiler with support for C++14, and can be built with any of the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Microsoft Visual Studio 2017 or newer&lt;/li&gt; &#xA; &lt;li&gt;GCC 6 or newer&lt;/li&gt; &#xA; &lt;li&gt;Clang 6 or newer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Python bindings for MaterialX are based on &lt;a href=&#34;https://github.com/pybind/pybind11&#34;&gt;PyBind11&lt;/a&gt;, and support Python versions 3.6 and greater.&lt;/p&gt; &#xA;&lt;h3&gt;MaterialX Viewer&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/DeveloperGuide/Viewer.md&#34;&gt;MaterialX Viewer&lt;/a&gt; leverages shader generation to build GLSL shaders from MaterialX graphs, rendering the results using the NanoGUI framework.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Figure 1:&lt;/strong&gt; Procedural and uniform materials in the MaterialX viewer&lt;/p&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXView_Marble.png&#34; width=&#34;204&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXView_Copper.png&#34; width=&#34;204&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXView_Plastic.png&#34; width=&#34;204&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXView_Carpaint.png&#34; width=&#34;204&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Figure 2:&lt;/strong&gt; Textured, color-space-managed materials in the MaterialX viewer&lt;/p&gt; &#xA;&lt;p float=&#34;left&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXView_TiledBrass.png&#34; width=&#34;412&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/MaterialXView_TiledWood.png&#34; width=&#34;412&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Open Chess Set&lt;/h3&gt; &#xA;&lt;p&gt;The Open Chess Set is an open reference asset, consisting of a &lt;a href=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/resources/Materials/Examples/StandardSurface/standard_surface_chess_set.mtlx&#34;&gt;MaterialX file&lt;/a&gt; in the Standard Surface shading model and a &lt;a href=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/resources/Geometry&#34;&gt;geometry file&lt;/a&gt; in the glTF format. It was authored by Moeen Sayed and Mujtaba Sayed, and was contributed to the MaterialX project by Side Effects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Figure 3:&lt;/strong&gt; The Open Chess Set, rendered in Arnold for Maya &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/OpenChessSet_Arnold_01.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Figure 4:&lt;/strong&gt; The Open Chess Set, rendered in Karma XPU for Houdini &lt;img src=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/documents/Images/OpenChessSet_Karma_01.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Pre-Built Binaries&lt;/h3&gt; &#xA;&lt;p&gt;The following packages contain pre-built binaries for the latest release, including the MaterialX viewer, Python libraries, and example assets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/releases/latest/download/MaterialX_Windows_VS2022_x64_Python39.zip&#34;&gt;Microsoft Windows (Visual Studio 2022, Python 3.9)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/releases/latest/download/MaterialX_MacOS_Xcode_13_Python39.zip&#34;&gt;MacOS (Xcode 13, Python 3.9)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AcademySoftwareFoundation/MaterialX/releases/latest/download/MaterialX_Linux_GCC_11_Python39.zip&#34;&gt;Linux (GCC 11, Python 3.9)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Additional Resources&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;http://www.materialx.org/docs/api/index.html&#34;&gt;Developer Guide&lt;/a&gt; contains a developer-oriented overview of MaterialX with API documentation.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/python/Scripts&#34;&gt;Python Scripts&lt;/a&gt; folder contains standalone examples of MaterialX Python code.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/javascript&#34;&gt;JavaScript&lt;/a&gt; folder contains details on building JavaScript bindings for MaterialX.&lt;/li&gt; &#xA; &lt;li&gt;Presentations at &lt;a href=&#34;http://www.materialx.org/assets/ASWF_OSD2022_MaterialX_OSL_Final.pdf&#34;&gt;ASWF Open Source Days&lt;/a&gt; and the &lt;a href=&#34;https://blog.selfshadow.com/publications/s2020-shading-course/#materialx&#34;&gt;SIGGRAPH Physically Based Shading Course&lt;/a&gt; provide details on the roadmap for MaterialX development.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>