<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-28T01:33:58Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>qiayuanliao/legged_control</title>
    <updated>2022-09-28T01:33:58Z</updated>
    <id>tag:github.com,2022-09-28:/qiayuanliao/legged_control</id>
    <link href="https://github.com/qiayuanliao/legged_control" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nonlinear MPC and WBC for legged robot based on OCS2 and ros-controls&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;legged_control&lt;/h1&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;legged_control is an NMPC-WBC legged robot control stack and framework based on &lt;a href=&#34;https://github.com/leggedrobotics/ocs2&#34;&gt;OCS2&lt;/a&gt; and &lt;a href=&#34;http://wiki.ros.org/ros_control&#34;&gt;ros-control&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The advantage shows below:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;To the author&#39;s best knowledge, this framework is probably the best-performing open-source legged robot MPC control framework;&lt;/li&gt; &#xA; &lt;li&gt;You can deploy this framework in your A1 robot within a few hours;&lt;/li&gt; &#xA; &lt;li&gt;Thanks to the ros-control interface, you can easily use this framework for your custom robot.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;I believe this framework can provide a high-performance and easy-to-use model-based baseline for the legged robot community.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/21256355/192135828-8fa7d9bb-9b4d-41f9-907a-68d34e6809d8.mp4&#34;&gt;https://user-images.githubusercontent.com/21256355/192135828-8fa7d9bb-9b4d-41f9-907a-68d34e6809d8.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Source code&lt;/h3&gt; &#xA;&lt;p&gt;The source code is hosted on GitHub: &lt;a href=&#34;https://github.com/qiayuanliao/legged_control&#34;&gt;qiayuanliao/legged_control&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Clone legged_control&#xA;git clone git@github.com:qiayuanliao/legged_control.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;OCS2&lt;/h3&gt; &#xA;&lt;p&gt;OCS2 is a huge monorepo; &lt;strong&gt;DO NOT&lt;/strong&gt; try to compile the whole repo. You only need to compile &lt;code&gt;ocs2_legged_robot_ros&lt;/code&gt; and its dependencies following the step below.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;You are supposed to clone the OCS2, pinocchio, and hpp-fcl as described in the documentation of OCS2. &lt;pre&gt;&lt;code&gt;# Clone OCS2&#xA;git clone git@github.com:leggedrobotics/ocs2.git&#xA;# Clone pinocchio&#xA;git clone --recurse-submodules https://github.com/leggedrobotics/pinocchio.git&#xA;# Clone hpp-fcl&#xA;git clone --recurse-submodules https://github.com/leggedrobotics/hpp-fcl.git&#xA;# Clone ocs2_robotic_assets&#xA;git clone https://github.com/leggedrobotics/ocs2_robotic_assets.git&#xA;# Install dependencies&#xA;sudo apt install liburdfdom-dev liboctomap-dev libassimp-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt;Compile the &lt;code&gt;ocs2_legged_robot_ros&lt;/code&gt; package with &lt;a href=&#34;https://catkin-tools.readthedocs.io/en/latest/&#34;&gt;catkin tools&lt;/a&gt; instead of &lt;code&gt;catkin_make&lt;/code&gt;. It will take you about ten minutes. &lt;pre&gt;&lt;code&gt;catkin config -DCMAKE_BUILD_TYPE=RelWithDebInfo&#xA;catkin build ocs2_legged_robot_ros&#xA;&lt;/code&gt;&lt;/pre&gt; Ensure you can command the ANYmal as shown in the &lt;a href=&#34;https://leggedrobotics.github.io/ocs2/robotic_examples.html#legged-robot&#34;&gt;document&lt;/a&gt; and below. &lt;img src=&#34;https://leggedrobotics.github.io/ocs2/_images/legged_robot.gif&#34; alt=&#34;&#34;&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;p&gt;Build the source code of &lt;code&gt;legged_control&lt;/code&gt; by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;catkin build legged_controllers unitree_description&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build the simulation (&lt;strong&gt;DO NOT&lt;/strong&gt; run on the onboard computer)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;catkin build legged_gazebo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Build the hardware interface real robot. If you use your computer only for simulation, you &lt;strong&gt;DO NOT&lt;/strong&gt; need to compile &lt;code&gt;unitree_hw&lt;/code&gt; (TODO: add a legged prefix to the package name)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;catkin build unitree_hw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Set your robot type as an environment variable: ROBOT_TYPE&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;export ROBOT_TYPE=a1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Run the simulation:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;roslaunch unitree_description empty_world.launch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or on the robot hardware:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;roslaunch unitree_hw unitree_hw.launch&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Load the controller:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;roslaunch legged_controllers load_controller.launch cheater:=false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;You can start the controller using &lt;code&gt;rqt_controller_manager&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt install ros-noetic-rqt-controller-manager&#xA;rosrun rqt_controller_manager rqt_controller_manager&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Start the &lt;code&gt;legged_controller&lt;/code&gt; or &lt;code&gt;legged_cheater_controller&lt;/code&gt;, &lt;strong&gt;NOTE that you are not allowed to start the &lt;code&gt;legged_cheater_controller&lt;/code&gt; in real hardware!&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set the gait in the terminal of &lt;code&gt;load_controller.launch&lt;/code&gt;, then use RViz (you need to add what you want to display by yourself) and control the robot by &lt;code&gt;cmd_vel&lt;/code&gt; and &lt;code&gt;move_base_simple/goal&lt;/code&gt;:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/07/27/lBzdeRa1gmvwx9C.gif&#34; alt=&#34;ezgif-5-684a1e1e23.gif&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Framework&lt;/h2&gt; &#xA;&lt;p&gt;The system framework diagram is shown below.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/qiayuanliao/legged_control/master/docs/system_diagram.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The robot torso&#39;s desired velocity or position goal is converted to state trajectory and then sent to the NMPC;&lt;/li&gt; &#xA; &lt;li&gt;The NMPC will evaluate an optimized system state and input.&lt;/li&gt; &#xA; &lt;li&gt;The Whole-body Controller (WBC) figures out the joint torques according to the optimized states and inputs from the NMPC.&lt;/li&gt; &#xA; &lt;li&gt;The torque is set as a feed-forward term and is sent to the robot&#39;s motor controller. Low-gain joint-space position and velocity PD commands are sent to the robot&#39;s motors to reduce the shock during foot contact and for better tracking performance.&lt;/li&gt; &#xA; &lt;li&gt;The NMPC and WBC need to know the current robot state, the base orientation, and the joint state, all obtained directly from the IMU and the motors. Running in the same loop with WBC, a linear Kalman filter[1] estimates the base position and velocity from base orientation, base acceleration, and joint foot position measurements.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Module&lt;/h2&gt; &#xA;&lt;p&gt;The main module of the entire control framework is NMPC and WBC, and the following is only a very brief introduction.&lt;/p&gt; &#xA;&lt;h3&gt;NMPC&lt;/h3&gt; &#xA;&lt;p&gt;The NMPC part solves the following optimization problems at each cycle through the formulation and solving interfaces provided by OCS2:&lt;/p&gt; &#xA;&lt;p&gt;$$ \begin{split} \begin{cases} \underset{\mathbf u(.)}{\min} \ \ \phi(\mathbf x(t_I)) + \displaystyle \int_{t_0}^{t_I} l(\mathbf x(t), \mathbf u(t), t) , dt \ \text{s.t.} \ \ \mathbf x(t_0) = \mathbf x_0 ,\hspace{11.5em} \text{initial state} \ \ \ \ \ \ \dot{\mathbf x}(t) = \mathbf f(\mathbf x(t), \mathbf u(t), t) \hspace{7.5em} \text{system flow map} \ \ \ \ \ \ \mathbf g_1(\mathbf x(t), \mathbf u(t), t) = \mathbf{0} \hspace{8.5em} \text{state-input equality constraints} \ \ \ \ \ \ \mathbf g_2(\mathbf x(t), t) = \mathbf{0} \hspace{10.5em} \text{state-only equality constraints} \ \ \ \ \ \ \mathbf h(\mathbf x(t), \mathbf u(t), t) \geq \mathbf{0} \hspace{8.5em} \text{inequality constraints} \end{cases}\end{split} $$&lt;/p&gt; &#xA;&lt;p&gt;For this framework, we defined system state $\mathbf{x}$ and input $\mathbf{u}$ as:&lt;/p&gt; &#xA;&lt;p&gt;$$ \begin{equation} \mathbf{x}= [\mathbf{h}_{com}^T, \mathbf{q}_b^T, \mathbf{q}_j^T]^T, \mathbf{u} = [\mathbf{f}_c^T, \mathbf{v}_j^T]^T \end{equation} $$&lt;/p&gt; &#xA;&lt;p&gt;where $\mathbf{h}_{com} \in \mathbb{R}^6$ is the collection of the normalized centroidal momentum, $\mathbf{q}=[\mathbf{q}_b^T, \mathbf{q}_j^T]^T$ is the generalized coordinate. $\mathbf{f}_c \in \mathbb{R}^{12}$ consists of contact forces at four contact points, i.e., four ground reaction forces of the foot. $\mathbf{q}_j$ and $\mathbf{v}_j$ are the joint positions and velocities. While the cost function is simply the quadratic cost of tracking the error of all states and the input, the system dynamics uses centroidal dynamics with the following constraints:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Friction cone;&lt;/li&gt; &#xA; &lt;li&gt;No motion at the standing foot;&lt;/li&gt; &#xA; &lt;li&gt;The z-axis position of the swinging foot satisfies the gait-generated curve.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To solve this optimal control problem, a multiple shooting is formulated to transcribe the optimal control problem to a nonlinear program (NLP) problem, and the NLP problem is solved using Sequential Quadratic Programming (SQP). The QP subproblem is solved using HPIPM. For more details [2, 3]&lt;/p&gt; &#xA;&lt;h3&gt;WBC&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/qiayuanliao/legged_control/master/docs/tasks.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;WBC only considers the current moment. Several tasks are defined in the table above. Each task is the equality constraints or inequality constraints on decision variables. The decision variables of WBC are:&lt;/p&gt; &#xA;&lt;p&gt;$$ \mathbf{x}_{wbc} = [\ddot{\mathbf{q}}^T, \mathbf{f}_c^T, \mathbf{\tau}^T]^T $$&lt;/p&gt; &#xA;&lt;p&gt;where $\ddot{\mathbf{q}}$ is acceleration of generalized coordinate, $\mathbf{\tau}$ is the joint torque. The WBC solves the QP problem in the null space of the higher priority tasks&#39; linear constraints and tries to minimize the slacking variables of inequality constraints. This approach can consider the full nonlinear rigid body dynamics and ensure strict hierarchy results. For more details [4].&lt;/p&gt; &#xA;&lt;h2&gt;Deploy and Develop&lt;/h2&gt; &#xA;&lt;h3&gt;A1 robot&lt;/h3&gt; &#xA;&lt;p&gt;People with ROS foundation should be able to run through simulation and real machine deployment within a few hours. The following shows some known laboratories that have run through this framework on their own A1 objects. and the time spent The table below shows the labs successfully deploying this repo in their &lt;strong&gt;real A1&lt;/strong&gt;; feel free to open a PR to update it. (because the code they got at the time was not stable, so the spend time cannot represent the their level).&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Lab&lt;/th&gt; &#xA;   &lt;th&gt;XPeng Robotics&lt;/th&gt; &#xA;   &lt;th&gt;Unitree&lt;/th&gt; &#xA;   &lt;th&gt;Hybrid Robotics&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Spend Time&lt;/td&gt; &#xA;   &lt;td&gt;1 day&lt;/td&gt; &#xA;   &lt;td&gt;-&lt;/td&gt; &#xA;   &lt;td&gt;2 hours&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;I recommended to use an external computing device such as NUC to run this control framework. The author uses the 11th generation of NUC, and the computing frequency of NMPC can be close to 200Hz.&lt;/p&gt; &#xA;&lt;h3&gt;Your costum rorbots&lt;/h3&gt; &#xA;&lt;p&gt;Deploying this framework to your robot is very simple, the steps are as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Imitate the &lt;code&gt;UnitreeHW&lt;/code&gt; class in legged_examples/legged_unitree/unitree_hw , inherit &lt;code&gt;LeggedHW&lt;/code&gt; and implement the &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; functions of the hardware interface;&lt;/li&gt; &#xA; &lt;li&gt;Imitate the legged_examples/legged_unitree/unitree_description, write the xarco of the robot and generate the URDF file, note that the names of the joint and link need to be the same as unitree_description.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Reference&lt;/h2&gt; &#xA;&lt;p&gt;[1] T. Flayols, A. Del Prete, P. Wensing, A. Mifsud, M. Benallegue, and O. Stasse, “Experimental evaluation of simple estimators for humanoid robots,” IEEE-RAS Int. Conf. Humanoid Robot., pp. 889–895, 2017, doi: 10.1109/HUMANOIDS.2017.8246977.&lt;/p&gt; &#xA;&lt;p&gt;[2] J. P. Sleiman, F. Farshidian, M. V. Minniti, and M. Hutter, “A Unified MPC Framework for Whole-Body Dynamic Locomotion and Manipulation,” IEEE Robot. Autom. Lett., vol. 6, no. 3, pp. 4688–4695, 2021, doi: 10.1109/LRA.2021.3068908.&lt;/p&gt; &#xA;&lt;p&gt;[3] R. Grandia, F. Jenelten, S. Yang, F. Farshidian, and M. Hutter, “Perceptive Locomotion through Nonlinear Model Predictive Control,” (submitted to) IEEE Trans. Robot., no. August, 2022, doi: 10.48550/arXiv.2208.08373.&lt;/p&gt; &#xA;&lt;p&gt;[4] C. Dario Bellicoso, C. Gehring, J. Hwangbo, P. Fankhauser, and M. Hutter, “Perception-less terrain adaptation through whole body control and hierarchical optimization,” in IEEE-RAS International Conference on Humanoid Robots, 2016, pp. 558–564, doi: 10.1109/HUMANOIDS.2016.7803330.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>MicroCBer/BetterNCM</title>
    <updated>2022-09-28T01:33:58Z</updated>
    <id>tag:github.com,2022-09-28:/MicroCBer/BetterNCM</id>
    <link href="https://github.com/MicroCBer/BetterNCM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PC版网易云客户端插件管理器&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img width=&#34;140em&#34; src=&#34;https://user-images.githubusercontent.com/66859419/183120498-1dede5b4-0666-4891-b95f-c3a812b3f12f.png&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt;BetterNCM II&lt;/h1&gt; &#xA;&lt;h3 align=&#34;center&#34;&gt;PC版网易云客户端插件管理器&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/66859419/186859984-ac64b338-d649-410f-a156-8f7d676bc7a9.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;最新测试兼容版本：&lt;code&gt;2.10.3&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;安装&lt;/h1&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;使用&lt;a href=&#34;https://github.com/MicroCBer/BetterNCM-Installer&#34;&gt;BetterNCM Installer&lt;/a&gt;一键安装~&lt;/p&gt; &#xA;&lt;h1&gt;V2开发进度&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; JS注入 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; ScriptLoader&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; StyleLoader&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 强制GPU渲染&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 强制打开DevTools&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 插件机制 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 插件解压，加载&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 插件商城 &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 更新提示&amp;amp;一键更新&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 自检查更新&amp;amp;自动更新&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 插件迁移 &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 各类主题插件&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; CSSLoader &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 随机背景图&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 网易云精简插件 重写&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 操作增强&lt;/li&gt; &#xA;   &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 点歌姬&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; 安装器&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>kaust-csg-uaamg/uaamg</title>
    <updated>2022-09-28T01:33:58Z</updated>
    <id>tag:github.com,2022-09-28:/kaust-csg-uaamg/uaamg</id>
    <link href="https://github.com/kaust-csg-uaamg/uaamg" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A Fast Unsmoothed Aggregation Algebraic Multigrid Framework for the Large-Scale Simulation of Incompressible Flow&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains a FLIP simulator, a Poisson solver, and a variational viscosity equation solver all based on OpenVDB data structure accelerated by SIMD intrinsics.&lt;/p&gt; &#xA;&lt;p&gt;Please cite our paper if this repository helps you:&lt;/p&gt; &#xA;&lt;pre&gt;&#xA;@article{Shao:2022:Multigrid,  &#xA;  author    = {Han Shao and Libo Huang and Dominik L.~Michels},  &#xA;  title     = {A Fast Unsmoothed Aggregation Algebraic Multigrid Framework for the Large-Scale Simulation of Incompressible Flow},  &#xA;  journal   = {ACM Transaction on Graphics},  &#xA;  year      = {2022},  &#xA;  month     = {07},  &#xA;  volume    = {41},  &#xA;  number    = {4},  &#xA;  articleno = {49},  &#xA;  doi       = {https://doi.org/10.1145/3528223.3530109},  &#xA;  publisher = {ACM},  &#xA;  address   = {New York, NY, USA}  &#xA;}  &#xA;&lt;/pre&gt; &#xA;&lt;h1&gt;Build instructions:&lt;/h1&gt; &#xA;&lt;p&gt;Clone the repository&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;git clone https://github.com/kaust-csg-uaamg/uaamg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This project also depends on a few third party libraries not included in this repository.&lt;br&gt; OpenVDB&lt;br&gt; Eigen3&lt;br&gt; Intel TBB&lt;br&gt; yaml-cpp&lt;/p&gt; &#xA;&lt;p&gt;We rely on vcpkg to manage these libraries. Clone from the vcpkg repo&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;git clone https://github.com/microsoft/vcpkg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install vcpkg:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;cd vcpkg&#xA;bootstrap-vcpkg.bat&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install dependent libraries in x64 mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;vcpkg.exe install openvdb:x64-windows eigen3:x64-windows tbb:x64-windows yaml-cpp:x64-windows&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we can build the FILP simulator with the help of CMake. Take windows CMake GUI as an example.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Open CMake GUI, choose the source code path by clicking the &#34;Browse Source&#34; on the top right corner. Set it to our repository, e.g. &#34;D:/MyCodes/uaamg&#34;&lt;/li&gt; &#xA; &lt;li&gt;Create a new folder to hold the visual studio files. For example, &#34;D:/MyCodes/uaamg/build&#34;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;+ Add Entry&#34; button. Add a cache entry called &#34;CMAKE_TOOLCHAIN_FILE&#34;, which points to a file in vcpkg directory. In our example, it is &#34;D:/MyCodes/vcpkg/scripts/buildsystems/vcpkg.cmake&#34;&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Configure&#34; button on the bottom left corner. Choose Optional platform for generator as &#34;x64&#34;. Click. &#34;Finish&#34; button.&lt;/li&gt; &#xA; &lt;li&gt;Click &#34;Generate&#34; to generate the visual studio solution file.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Open the visual studio solution file in &#34;D:/MyCodes/uaamg/build/mgviscosity3d.sln&#34; and build in Release x64 mode.&lt;/p&gt; &#xA;&lt;p&gt;If successful, there is an &#34;INSTALL&#34; project in the Visual Studio solution. It builds the FLIP simulator as well as benchmark tests and copy them into a newly created &#34;bin&#34; folder in this directory.&lt;/p&gt; &#xA;&lt;h1&gt;How To Run a FLIP Scene and Benchmarks&lt;/h1&gt; &#xA;&lt;h2&gt;FLIP Scene&lt;/h2&gt; &#xA;&lt;p&gt;All scenes in our publications can be reproduced and rendered by scene files under &#34;Scene_Houdini&#34;. It contains many subfolders, one for each scene. Each folder typically contains a Houdini project file used to generate the simulation geometry, and another file for visualization and rendering. Each subfolder contains README.txt for further instructions.&lt;/p&gt; &#xA;&lt;p&gt;Our FLIP simulator takes a single yaml configuration file. Please check these .yaml config files inside each subfolders in &#34;Scene_Houdini&#34;. In a FLIP config file, the following parameters need to be defined:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;output_prefix&lt;/strong&gt; ,string, name of the folder that holds the simulation result.&lt;br&gt; &lt;strong&gt;time_step&lt;/strong&gt;, float, time step size in seconds, typically 1/24 s.&lt;br&gt; &lt;strong&gt;simulation_time&lt;/strong&gt;, float, total simulation duration in seconds.&lt;br&gt; &lt;strong&gt;init_vel_[x,y,z]&lt;/strong&gt;, three floats, initial velocity of the liquid when no velocity field is given in the source, typically zero. It is also the boundary flux velocity for the FLIP domain in some truncated water flow scenes. &lt;strong&gt;FLIP_domain_collision&lt;/strong&gt;, bool, whether the simulation bounding box collides with particles in both the advection step and pressure projection step. In the advection step, particles are pushed away from zero isosurface of collision signed distance fucntions.&lt;br&gt; &lt;strong&gt;FLIP_domain_solid&lt;/strong&gt;, bool, whether the simulation bounding box is treated as solid in the pressure projection step. This is useful to create an in/out flow boundary which does not collide with particles, but provide a correct Neumann boundary condition in the Poisson projection step.&lt;br&gt; &lt;strong&gt;FLIP_solid_friction&lt;/strong&gt;, float, value between 0 and 1. The face velocity after pressure projection is further blended according to solid face fractions multiplied by this number. The solid velocity portion is this number multiplied by solid face fraction (also 0 to 1).&lt;br&gt; &lt;strong&gt;FLIPCFL&lt;/strong&gt;, float, CFL number, maximum number of cells allowed for a particle to travel within a substep. This controls the adaptive time substep size.&lt;br&gt; &lt;strong&gt;FLIP_min_step_num&lt;/strong&gt;, int, minimum number of substeps within a time step.&lt;br&gt; &lt;strong&gt;FLIP_max_step_num&lt;/strong&gt;, int, maximum number of substeps within a time step.&lt;br&gt; &lt;strong&gt;pressure_acc&lt;/strong&gt;, float, pressure projection accuracy.&lt;br&gt; &lt;strong&gt;viscosity_acc&lt;/strong&gt;, float, variational viscosity solver accuracy.&lt;br&gt; &lt;strong&gt;FLIPpool-min[x,y,z]&lt;/strong&gt;, three floats, minimum corner of the FLIP solver domain in meters.&lt;br&gt; &lt;strong&gt;FLIPpool-max[x,y,z]&lt;/strong&gt;, three floats, maximum corner of the FLIP solver domain in meters.&lt;br&gt; &lt;strong&gt;FLIPdx&lt;/strong&gt;, float, edge length of a voxel in meters.&lt;br&gt; &lt;strong&gt;enable_viscosity&lt;/strong&gt;, bool, enable viscosity solver.&lt;br&gt; &lt;strong&gt;viscosity_coef&lt;/strong&gt;, float, dynamic viscosity coefficient.&lt;br&gt; &lt;strong&gt;solids_vdb&lt;/strong&gt;, string, a file name of static solid collision geometry. That file can contain multiple vdbs. If the name of the vdb is &#34;collision&#34;, it influence the particles in the advection step, and velocity field in the projection step. If the name of the vdb is &#34;solid&#34;, it only participates in the projection step.&lt;br&gt; &lt;strong&gt;source_vdb&lt;/strong&gt;, string, a file name of static liquid sources as well as initial liqui geometry. &#34;source_vdb&#34; can contain many vdbs. If the name of the vdb is &#34;initial_liquid_sdf&#34;, FLIP particles will be generated in the negative region of that vdb before any simulation steps. If the name of the vdb is &#34;source&#34;, new particles will be generated to fill the region where &#34;source&#34; vdb is negative and if the voxel contains less than 8 particles. If a Vec3f vdb grid named &#34;vel&#34; follows any SDF vdb, it is treated as the velocity field from which the generated particle samples initial velocity.&lt;br&gt; &lt;strong&gt;dynamic_obj_enabled&lt;/strong&gt;, bool, whether dynamic collision geometries are enabled.&lt;br&gt; &lt;strong&gt;dynamic_obj_folder&lt;/strong&gt;, string, a folder path that contains the dynamic collision geometry.&lt;br&gt; &lt;strong&gt;dynamic_obj_prefix&lt;/strong&gt;, string, the prefix of dynamic collision objects. Currently, only wavefront obj files with closed triangle mesh are supported. The file name must be &#34;prefix#framenumber.obj&#34;. For example if the prefix is &#34;solid.&#34;, and the simulation output is frame 0 to frame 120, then it is recommended to have &#34;solid.0.obj&#34; all the way to &#34;solid.121.obj&#34;. Topology of the mesh must remain unchanged, since the vertex velocity is calculated based on finite difference forward in time and its position in substeps is linearly interpolated based on two frames.&lt;/p&gt; &#xA;&lt;h2&gt;Linear Equation Solver Benchmark&lt;/h2&gt; &#xA;&lt;p&gt;After installation, the &#34;bin&#34; folder contains a subfolder called &#34;CG_benchmark&#34;, which contains the binary file as well as a config file used for the benchmark of Poisson solver, and the variational viscosity equation solver. Go inside the &#34;CG_benchmarks&#34; folder, open a command window, and use the following command to run the benchmark:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;CG_benchmarks.exe config.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The config file is copied from &#34;CG_benchmarks/scene/config.yaml&#34;. The following parameters controls its behavior.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;equation_type&lt;/strong&gt;, string, &#34;pressure&#34; or &#34;viscosity&#34;, a switch between Poisson equation and variational viscosity equation benchmarks.&lt;br&gt; &lt;strong&gt;nx&lt;/strong&gt;, int, subdivision count along a single direction. Typically the scene has a characteristic length of 1 meter.&lt;br&gt; &lt;strong&gt;output_prefix&lt;/strong&gt;, string, folder path that shows some output, such as the geometry of the liquid.&lt;br&gt; &lt;strong&gt;poisson_scene_type&lt;/strong&gt;, string, &#34;sparse&#34; or &#34;compact&#34;. Sparse scene consists of many spherical balls randomly distributed in a 1 meter cube. Compact scene is a box of liquid where only the top face is free surface, while other faces are solid boundaries.&lt;br&gt; &lt;strong&gt;pressure_solver_method&lt;/strong&gt;, int, available values are [0..5]. 0 uses Eigen diagonal preconditioner conjugate gradient (CG). 1 uses Incomplete Cholesky PCG in Eigen. 2 uses the Incomplete Cholesky PCG from Christopher Batty&#39;s code. 3 uses unsmoothed aggregation AMG PCG, but use explicitly built sparse matrix in Eigen. 4 is the method in our paper, UAAMG with SIMD. 5 is AMGCL library.&lt;br&gt; &lt;strong&gt;pressure_smoother&lt;/strong&gt;, int, available values are [0..3]. 0 is damped Jacobi with weight = 6/7. 1 is scheduled relaxed jacobi. 2 is red black Gauss Seidel. 3 is SPAI0.&lt;br&gt; &lt;strong&gt;nballs&lt;/strong&gt;, int, number of balls in the sparse scene. Please see the output sdf to see the exact liqui geometry. &lt;strong&gt;resizer&lt;/strong&gt;, float, further adjust the size of the ball. Please use the output sdf to visually adjust the size.&lt;br&gt; &lt;strong&gt;viscosity_solver_method&lt;/strong&gt;, int, available values are [0..3]. 0 is Eigen diagonal PCG. 1 is ICPCG from Batty&#39;s code. 2 is UAAMG with explict sparse Eigen matrix. 3 is UAAMG with SIMD. 4 is AMGCL.&lt;br&gt; &lt;strong&gt;viscosity_smoother&lt;/strong&gt;, int, available values are [3]. 0 is damped jacobi. 1 is scheduled relaxed Jacobi with coefficients optimal for poisson. 2 is multi-color Gauss Seidel smoother. 3 is SPAI0. Note these methods are only for the UAAMG with explicit sparse Eigen matrix, and AMGCL (only damped Jacobi and SPAI0 are available). UAAMG SIMD only use multi-color Gauss Seidel.&lt;br&gt; &lt;strong&gt;viscosity_coef&lt;/strong&gt;, float, dynamic viscosity coefficient.&lt;/p&gt;</summary>
  </entry>
</feed>