<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-11-16T01:31:55Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>NVIDIA-ISAAC-ROS/isaac_ros_visual_slam</title>
    <updated>2022-11-16T01:31:55Z</updated>
    <id>tag:github.com,2022-11-16:/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam</id>
    <link href="https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Visual odometry package based on hardware-accelerated NVIDIA Elbrus library with world class quality and performance.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Isaac ROS Visual SLAM&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/resources/elbrus_ros_3.gif&#34; width=&#34;400px&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This repository provides a ROS2 package that performs stereo visual simultaneous localization and mapping (VSLAM) and estimates stereo visual inertial odometry using the &lt;a href=&#34;https://docs.nvidia.com/isaac/packages/visual_slam/doc/elbrus_visual_slam.html&#34;&gt;Isaac Elbrus&lt;/a&gt; GPU-accelerated library. It takes in a time-synced pair of stereo images (grayscale) along with respective camera intrinsics to publish the current pose of the camera relative to its start pose.&lt;/p&gt; &#xA;&lt;p&gt;Elbrus is based on two core technologies: Visual Odometry (VO) and Simultaneous Localization and Mapping (SLAM).&lt;/p&gt; &#xA;&lt;p&gt;Visual SLAM is a method for estimating a camera position relative to its start position. This method has an iterative nature. At each iteration, it considers two consequential input frames (stereo pairs). On both the frames, it finds a set of keypoints. Matching keypoints in these two sets gives the ability to estimate the transition and relative rotation of the camera between frames.&lt;/p&gt; &#xA;&lt;p&gt;Simultaneous Localization and Mapping is a method built on top of the VO predictions. It aims to improve the quality of VO estimations by leveraging the knowledge of previously seen parts of a trajectory. It detects if the current scene was seen in the past (i.e. a loop in camera movement) and runs an additional optimization procedure to tune previously obtained poses.&lt;/p&gt; &#xA;&lt;p&gt;Along with visual data, Elbrus can optionally use Inertial Measurement Unit (IMU) measurements. It automatically switches to IMU when VO is unable to estimate a pose; for example, when there is dark lighting or long solid featureless surfaces in front of a camera. Elbrus delivers real-time tracking performance: more than 60 FPS for VGA resolution. For the KITTI benchmark, the algorithm achieves a drift of ~1% in localization and an orientation error of 0.003 degrees per meter of motion. Elbrus allows for robust tracking in various environments and with different use cases: indoor, outdoor, aerial, HMD, automotive, and robotics.&lt;/p&gt; &#xA;&lt;p&gt;To learn more about Elbrus SLAM click &lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/docs/elbrus-slam.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;The following are the benchmark performance results of the prepared pipelines in this package, by supported platform:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Pipeline&lt;/th&gt; &#xA;   &lt;th&gt;AGX Orin&lt;/th&gt; &#xA;   &lt;th&gt;Orin Nano&lt;/th&gt; &#xA;   &lt;th&gt;x86_64 w/ RTX 3060 Ti&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;VSLAM&lt;/td&gt; &#xA;   &lt;td&gt;250 fps &lt;br&gt; 3.1ms&lt;/td&gt; &#xA;   &lt;td&gt;105 fps &lt;br&gt; 10ms&lt;/td&gt; &#xA;   &lt;td&gt;265 fps &lt;br&gt; 5.2ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;These data have been collected per the methodology described &lt;a href=&#34;https://github.com/NVIDIA-ISAAC-ROS/.github/raw/main/profile/performance-summary.md#methodology&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Table of Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#isaac-ros-visual-slam&#34;&gt;Isaac ROS Visual SLAM&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#overview&#34;&gt;Overview&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#table-of-contents&#34;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#latest-update&#34;&gt;Latest Update&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#supported-platforms&#34;&gt;Supported Platforms&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#docker&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#coordinate-frames&#34;&gt;Coordinate Frames&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#next-steps&#34;&gt;Next Steps&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#try-more-examples&#34;&gt;Try More Examples&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#customize-your-dev-environment&#34;&gt;Customize your Dev Environment&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#package-reference&#34;&gt;Package Reference&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#isaac_ros_visual_slam&#34;&gt;isaac_ros_visual_slam&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#usage&#34;&gt;Usage&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#ros-parameters&#34;&gt;ROS Parameters&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#ros-topics-subscribed&#34;&gt;ROS Topics Subscribed&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#ros-topics-published&#34;&gt;ROS Topics Published&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#ros-services-advertised&#34;&gt;ROS Services Advertised&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#ros-actions-advertised&#34;&gt;ROS Actions Advertised&lt;/a&gt;&lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#troubleshooting&#34;&gt;Troubleshooting&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#isaac-ros-troubleshooting&#34;&gt;Isaac ROS Troubleshooting&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#troubleshooting-suggestions&#34;&gt;Troubleshooting Suggestions&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/#updates&#34;&gt;Updates&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Latest Update&lt;/h2&gt; &#xA;&lt;p&gt;Update 2022-10-19: Updated OSS licensing&lt;/p&gt; &#xA;&lt;h2&gt;Supported Platforms&lt;/h2&gt; &#xA;&lt;p&gt;This package is designed and tested to be compatible with ROS2 Humble running on &lt;a href=&#34;https://developer.nvidia.com/embedded-computing&#34;&gt;Jetson&lt;/a&gt; or an x86_64 system with an NVIDIA GPU.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Versions of ROS2 earlier than Humble are &lt;strong&gt;not&lt;/strong&gt; supported. This package depends on specific ROS2 implementation features that were only introduced beginning with the Humble release.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Hardware&lt;/th&gt; &#xA;   &lt;th&gt;Software&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jetson&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-orin/&#34;&gt;Jetson Orin&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-agx-xavier/&#34;&gt;Jetson Xavier&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://developer.nvidia.com/embedded/jetpack&#34;&gt;JetPack 5.0.2&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;For best performance, ensure that &lt;a href=&#34;https://docs.nvidia.com/jetson/archives/r34.1/DeveloperGuide/text/SD/PlatformPowerAndPerformance.html&#34;&gt;power settings&lt;/a&gt; are configured appropriately.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;x86_64&lt;/td&gt; &#xA;   &lt;td&gt;NVIDIA GPU&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://releases.ubuntu.com/20.04/&#34;&gt;Ubuntu 20.04+&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA 11.6.1+&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Docker&lt;/h3&gt; &#xA;&lt;p&gt;To simplify development, we strongly recommend leveraging the Isaac ROS Dev Docker images by following &lt;a href=&#34;https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_common/raw/main/docs/dev-env-setup.md&#34;&gt;these steps&lt;/a&gt;. This will streamline your development environment setup with the correct versions of dependencies on both Jetson and x86_64 platforms.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; All Isaac ROS Quickstarts, tutorials, and examples have been designed with the Isaac ROS Docker images as a prerequisite.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Coordinate Frames&lt;/h2&gt; &#xA;&lt;p&gt;This section describes the coordinate frames that are involved in the &lt;code&gt;VisualSlamNode&lt;/code&gt;. The frames discussed below are oriented as follows:&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/resources/Axes.png&#34; width=&#34;300px&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;input_base_frame&lt;/code&gt;: The name of the frame used to calculate transformation between baselink and left camera. The default value is empty (&#39;&#39;), which means the value of &lt;code&gt;base_frame_&lt;/code&gt; will be used. If &lt;code&gt;input_base_frame_&lt;/code&gt; and &lt;code&gt;base_frame_&lt;/code&gt; are both empty, the left camera is assumed to be in the robot&#39;s center.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;input_left_camera_frame&lt;/code&gt;: The frame associated with left eye of the stereo camera. Note that this is not the same as the optical frame. The default value is empty (&#39;&#39;), which means the left camera is in the robot&#39;s center and &lt;code&gt;left_pose_right&lt;/code&gt; will be calculated from the CameraInfo message.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;input_right_camera_frame&lt;/code&gt;: The frame associated with the right eye of the stereo camera. Note that this is not the same as the optical frame. The default value is empty (&#39;&#39;), which means left and right cameras have identity rotation and are horizontally aligned, so &lt;code&gt;left_pose_right&lt;/code&gt; will be calculated from CameraInfo.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;input_imu_frame&lt;/code&gt;: The frame associated with the IMU sensor (if available). It is used to calculate &lt;code&gt;left_pose_imu&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Set up your development environment by following the instructions &lt;a href=&#34;https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_common/raw/main/docs/dev-env-setup.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Clone this repository and its dependencies under &lt;code&gt;~/workspaces/isaac_ros-dev/src&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/workspaces/isaac_ros-dev/src&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_common&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_nitros&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Pull down a ROS Bag of sample data:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/workspaces/isaac_ros-dev/src/isaac_ros_visual_slam &amp;amp;&amp;amp; \ &#xA;  git lfs pull -X &#34;&#34; -I isaac_ros_visual_slam/test/test_cases/rosbags/&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Launch the Docker container using the &lt;code&gt;run_dev.sh&lt;/code&gt; script:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/workspaces/isaac_ros-dev/src/isaac_ros_common &amp;amp;&amp;amp; \&#xA;  ./scripts/run_dev.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Inside the container, build and source the workspace:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /workspaces/isaac_ros-dev &amp;amp;&amp;amp; \&#xA;  colcon build --symlink-install &amp;amp;&amp;amp; \&#xA;  source install/setup.bash&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;(Optional) Run tests to verify complete and correct installation:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;colcon test --executor sequential&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the following launch files in the current terminal:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ros2 launch isaac_ros_visual_slam isaac_ros_visual_slam.launch.py&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In a second terminal inside the Docker container, prepare rviz to display the output:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source /workspaces/isaac_ros-dev/install/setup.bash &amp;amp;&amp;amp; \&#xA;  rviz2 -d src/isaac_ros_visual_slam/isaac_ros_visual_slam/rviz/default.cfg.rviz &#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In an another terminal inside the Docker container, run the following ros bag file to start the demo:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;source /workspaces/isaac_ros-dev/install/setup.bash &amp;amp;&amp;amp; \&#xA;  ros2 bag play src/isaac_ros_visual_slam/isaac_ros_visual_slam/test/test_cases/rosbags/small_pol_test/&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Rviz should start displaying the point clouds and poses like below:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/resources/Rviz_quick_start.png&#34; width=&#34;600px&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Next Steps&lt;/h2&gt; &#xA;&lt;h3&gt;Try More Examples&lt;/h3&gt; &#xA;&lt;p&gt;To continue your exploration, check out the following suggested examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/docs/tutorial-isaac-sim.md#tutorial-with-isaac-sim&#34;&gt;Tutorial with Isaac Sim&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Customize your Dev Environment&lt;/h3&gt; &#xA;&lt;p&gt;To customize your development environment, reference &lt;a href=&#34;https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_common/raw/main/docs/modify-dockerfile.md&#34;&gt;this guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Package Reference&lt;/h2&gt; &#xA;&lt;h3&gt;isaac_ros_visual_slam&lt;/h3&gt; &#xA;&lt;h4&gt;Usage&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ros2 launch isaac_ros_visual_slam isaac_ros_visual_slam.launch.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;ROS Parameters&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ROS Parameter&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Default&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;denoise_input_images&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, input images are denoised. It can be enabled when images are noisy because of low-light conditions.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;rectified_images&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Flag to mark if the incoming images are rectified or raw.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_imu&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, IMU data is used.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_debug_mode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, a debug dump (image frames, timestamps, and camera info) is saved on to the disk at the path indicated by &lt;code&gt;debug_dump_path&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;debug_dump_path&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;/tmp/elbrus&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The path to the directory to store the debug dump data.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;input_base_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Name of the frame (baselink) to calculate transformation between the baselink and the left camera. Default is empty, which means the value of the &lt;code&gt;base_frame&lt;/code&gt; will be used. If &lt;code&gt;input_base_frame&lt;/code&gt; and &lt;code&gt;base_frame&lt;/code&gt; are both empty, the left camera is assumed to be in the robot&#39;s center.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;input_left_camera_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The name of the left camera frame. the default value is empty, which means the left camera is in the robot&#39;s center and &lt;code&gt;left_pose_right&lt;/code&gt; will be calculated from CameraInfo.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;input_right_camera_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;&#34;&#34;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The name of the right camera frame. The default value is empty, which means left and right cameras have identity rotation and are horizontally aligned. &lt;code&gt;left_pose_right&lt;/code&gt; will be calculated from CameraInfo.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;input_imu_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;imu&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Defines the name of the IMU frame used to calculate &lt;code&gt;left_camera_pose_imu&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;gravitational_force&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::vector&amp;lt;double&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;{0.0, 0, -9.8}&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The initial gravity vector defined in the odometry frame. If the IMU sensor is not parallel to the floor, update all the axes with appropriate values.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;publish_tf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, it will publish output frame hierarchy to TF tree.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;map_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The frame name associated with the map origin.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;odom_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;odom&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The frame name associated with the odometry origin.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;base_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;base_link&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The frame name associated with the robot.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_observations_view&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, 2D feature pointcloud will be available for visualization.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_landmarks_view&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, landmark pointcloud will be available for visualization.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_slam_visualization&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Main flag to enable or disable visualization.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;enable_localization_n_mapping&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;If enabled, SLAM mode is on. If diabled, only Visual Odometry is on.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;path_max_size&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;1024&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The maximum size of the buffer for pose trail visualization.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;publish_odom_to_base_tf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable tf broadcaster for odom_frame-&amp;gt;base_frame transform.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;publish_map_to_odom_tf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Enable tf broadcaster for map_frame-&amp;gt;odom_frame transform.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;invert_odom_to_base_tf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Invert the odom_frame-&amp;gt;base_frame transform before broadcasting to the tf tree.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;invert_map_to_odom_tf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Invert the map_frame-&amp;gt;odom_frame transform before broadcasting to the tf tree.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;map_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;String name for the map_frame.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;odom_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;odom&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;String name for the odom_frame.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;base_frame&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;base_link&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;String name for the base_frame.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;override_publishing_stamp&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Override timestamp received from the left image with the timetsamp from rclcpp::Clock.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;msg_filter_queue_size&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;100&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Image + Camera Info Synchronizer message filter queue size.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;image_qos&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;std::string&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;SENSOR_DATA&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;QoS profile for the left and right image subscribers.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;ROS Topics Subscribed&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ROS Topic&lt;/th&gt; &#xA;   &lt;th&gt;Interface&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/stereo_camera/left/image&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/sensor_msgs/msg/Image.msg&#34;&gt;&lt;code&gt;sensor_msgs/Image&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The image from the left eye of the stereo camera in grayscale.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/stereo_camera/left/camera_info&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/sensor_msgs/msg/CameraInfo.msg&#34;&gt;&lt;code&gt;sensor_msgs/CameraInfo&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CameraInfo from the left eye of the stereo camera.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/stereo_camera/right/image&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/sensor_msgs/msg/Image.msg&#34;&gt;&lt;code&gt;sensor_msgs/Image&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The image from the right eye of the stereo camera in grayscale.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;/stereo_camera/right/camera_info&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/sensor_msgs/msg/CameraInfo.msg&#34;&gt;&lt;code&gt;sensor_msgs/CameraInfo&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;CameraInfo from the right eye of the stereo camera.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/imu&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/sensor_msgs/msg/Imu.msg&#34;&gt;&lt;code&gt;sensor_msgs/Imu&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Sensor data from the IMU(optional).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;ROS Topics Published&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ROS Topic&lt;/th&gt; &#xA;   &lt;th&gt;Interface&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/tracking/odometry&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/nav_msgs/msg/Odometry.msg&#34;&gt;&lt;code&gt;nav_msgs/Odometry&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Odometry messages for the &lt;code&gt;base_link&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/tracking/vo_pose_covariance&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/geometry_msgs/msg/PoseWithCovarianceStamped.msg&#34;&gt;&lt;code&gt;geometry_msgs/PoseWithCovarianceStamped&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Current pose with covariance of the &lt;code&gt;base_link&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/tracking/vo_pose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/geometry_msgs/msg/PoseStamped.msg&#34;&gt;&lt;code&gt;geometry_msgs/PoseStamped&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Current pose of the &lt;code&gt;base_link&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/tracking/slam_path&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/nav_msgs/msg/Path.msg&#34;&gt;&lt;code&gt;nav_msgs/Path&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Trail of poses generated by SLAM.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/tracking/vo_path&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/ros2/common_interfaces/raw/humble/nav_msgs/msg/Path.msg&#34;&gt;&lt;code&gt;nav_msgs/Path&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Trail of poses generated by pure Visual Odometry.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/status&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/isaac_ros_visual_slam_interfaces/msg/VisualSlamStatus.msg&#34;&gt;&lt;code&gt;isaac_ros_visual_slam_interfaces/VisualSlamStatus&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Status message for diagnostics.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;ROS Services Advertised&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ROS Service&lt;/th&gt; &#xA;   &lt;th&gt;Interface&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/reset&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/isaac_ros_visual_slam_interfaces/srv/Reset.srv&#34;&gt;&lt;code&gt;isaac_ros_visual_slam_interfaces/Reset&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A service to reset the node.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/get_all_poses&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/isaac_ros_visual_slam_interfaces/srv/GetAllPoses.srv&#34;&gt;&lt;code&gt;isaac_ros_visual_slam_interfaces/GetAllPoses&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A service to get the series of poses for the path traversed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/set_odometry_pose&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/isaac_ros_visual_slam_interfaces/srv/SetOdometryPose.srv&#34;&gt;&lt;code&gt;isaac_ros_visual_slam_interfaces/SetOdometryPose&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A service to set the pose of the odometry frame.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;ROS Actions Advertised&lt;/h4&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;ROS Action&lt;/th&gt; &#xA;   &lt;th&gt;Interface&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/save_map&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/isaac_ros_visual_slam_interfaces/action/SaveMap.action&#34;&gt;&lt;code&gt;isaac_ros_visual_slam_interfaces/SaveMap&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An action to save the landmarks and pose graph into a map and onto the disk.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;visual_slam/load_map_and_localize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/NVIDIA-ISAAC-ROS/isaac_ros_visual_slam/main/isaac_ros_visual_slam_interfaces/action/LoadMapAndLocalize.action&#34;&gt;&lt;code&gt;isaac_ros_visual_slam_interfaces/LoadMapAndLocalize&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An action to load the map from the disk and localize within it given a prior pose.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;Isaac ROS Troubleshooting&lt;/h3&gt; &#xA;&lt;p&gt;For solutions to problems with Isaac ROS, please check &lt;a href=&#34;https://github.com/NVIDIA-ISAAC-ROS/isaac_ros_common/raw/main/docs/troubleshooting.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Troubleshooting Suggestions&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If RViz is not showing the poses, check the &lt;strong&gt;Fixed Frame&lt;/strong&gt; value.&lt;/li&gt; &#xA; &lt;li&gt;If you are seeing &lt;code&gt;Tracker is lost.&lt;/code&gt; messages frequently, it could be caused by the following issues: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Fast motion causing the motion blur in the frames.&lt;/li&gt; &#xA;   &lt;li&gt;Low-lighting conditions.&lt;/li&gt; &#xA;   &lt;li&gt;The wrong &lt;code&gt;camerainfo&lt;/code&gt; is being published.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;For better performance: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Increase the capture framerate from the camera to yield a better tracking result.&lt;/li&gt; &#xA;   &lt;li&gt;If input images are noisy, you can use the &lt;code&gt;denoise_input_images&lt;/code&gt; flag in the node.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Updates&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Date&lt;/th&gt; &#xA;   &lt;th&gt;Changes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2022-10-19&lt;/td&gt; &#xA;   &lt;td&gt;Updated OSS licensing&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2022-08-31&lt;/td&gt; &#xA;   &lt;td&gt;Update to be compatible with JetPack 5.0.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2022-06-30&lt;/td&gt; &#xA;   &lt;td&gt;Support for ROS2 Humble&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2022-03-17&lt;/td&gt; &#xA;   &lt;td&gt;Documentation update for new features&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2022-03-11&lt;/td&gt; &#xA;   &lt;td&gt;Renamed to isaac_ros_visual_slam&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2021-11-15&lt;/td&gt; &#xA;   &lt;td&gt;Isaac Sim HIL documentation update&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2021-10-20&lt;/td&gt; &#xA;   &lt;td&gt;Initial release&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>lumapu/ahoy</title>
    <updated>2022-11-16T01:31:55Z</updated>
    <id>tag:github.com,2022-11-16:/lumapu/ahoy</id>
    <link href="https://github.com/lumapu/ahoy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Various tools, examples, and documentation for communicating with Hoymiles microinverters&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/lumapu/actions/workflows/compile_esp8266.yml/badge.svg?sanitize=true&#34; alt=&#34;actions/workflows/compile_esp8266.yml&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/lumapu/actions/workflows/compile_development.yml/badge.svg?sanitize=true&#34; alt=&#34;actions/workflows/compile_development.yml&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;🖐 Ahoy!&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/grindylow/ahoy/raw/main/doc/logo1_small.png?raw=true&#34; alt=&#34;Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Communicate with Hoymiles inverters via radio&lt;/strong&gt;. Get actual values like power, current, daily energy and set parameters like the power limit via web interface or MQTT. In this repository you will find different approaches means Hardware / Software to realize the described functionalities.&lt;/p&gt; &#xA;&lt;p&gt;List of approaches&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lumapu/ahoy/main/tools/esp8266/&#34;&gt;ESP8266/ESP32, C++&lt;/a&gt; 👈 the most effort is spent here&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lumapu/ahoy/main/tools/nano/NRF24_SendRcv/&#34;&gt;Arduino Nano, C++&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lumapu/ahoy/main/tools/rpi/&#34;&gt;Raspberry Pi, Python&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lumapu/ahoy/main/tools/nano/NRF24_SendRcv/&#34;&gt;Others, C/C++&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start with ESP8266&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/lumapu/ahoy/main/tools/esp8266/README.md#things-needed&#34;&gt;Go here ✨&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Success Stories&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/16850-pv-power-ahoy/&#34;&gt;Getting the data into influxDB and visualize them in a Grafana Dashboard&lt;/a&gt; (thx @Carl)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Support, Feedback, Information and Discussion&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://discord.gg/WzhxEY62mB&#34;&gt;Discord Server (~ 300 Users)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.mikrocontroller.net/topic/525778&#34;&gt;The root of development&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Development&lt;/h3&gt; &#xA;&lt;p&gt;If you encounter issues use the issues here on github.&lt;/p&gt; &#xA;&lt;p&gt;Please try to describe your issues as precise as possible and think about if this is a issue with the software here in the repository or other software components.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Contributors are always welcome!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Related Projects&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tbnobody/OpenDTU&#34;&gt;OpenDTU&lt;/a&gt; &amp;lt;- Our sister project ✨ for Hoymiles HM-300, HM-600, HM-1200 (for ESP32 only!)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Ziyatoe/DTUsimMI1x00-Hoymiles&#34;&gt;DTU Simulator&lt;/a&gt; &amp;lt;- Go here ✨ for Hoymiles MI-300, MI-600, MI-1200 Software&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>