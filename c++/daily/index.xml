<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-03T01:30:50Z</updated>
  <subtitle>Daily Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cms-sw/cmssw</title>
    <updated>2023-08-03T01:30:50Z</updated>
    <id>tag:github.com,2023-08-03:/cms-sw/cmssw</id>
    <link href="https://github.com/cms-sw/cmssw" rel="alternate"></link>
    <summary type="html">&lt;p&gt;CMS Offline Software&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Introduction to CMSSW: &lt;a href=&#34;http://cms-sw.github.io&#34;&gt;http://cms-sw.github.io&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>triton-inference-server/python_backend</title>
    <updated>2023-08-03T01:30:50Z</updated>
    <id>tag:github.com,2023-08-03:/triton-inference-server/python_backend</id>
    <link href="https://github.com/triton-inference-server/python_backend" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Triton backend that enables pre-process, post-processing and other logic to be implemented in Python.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/BSD-3-Clause&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-BSD3-lightgrey.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Python Backend&lt;/h1&gt; &#xA;&lt;p&gt;The Triton backend for Python. The goal of Python backend is to let you serve models written in Python by Triton Inference Server without having to write any C++ code.&lt;/p&gt; &#xA;&lt;h2&gt;User Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#python-backend&#34;&gt;Python Backend&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#user-documentation&#34;&gt;User Documentation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#quick-start&#34;&gt;Quick Start&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#building-from-source&#34;&gt;Building from Source&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#auto_complete_config&#34;&gt;&lt;code&gt;auto_complete_config&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#initialize&#34;&gt;&lt;code&gt;initialize&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#execute&#34;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; &#xA;      &lt;ul&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#default-mode&#34;&gt;Default Mode&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#error-handling&#34;&gt;Error Handling&lt;/a&gt;&lt;/li&gt; &#xA;       &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#decoupled-mode&#34;&gt;Decoupled mode&lt;/a&gt; &#xA;        &lt;ul&gt; &#xA;         &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#use-cases&#34;&gt;Use Cases&lt;/a&gt;&lt;/li&gt; &#xA;         &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#known-issues&#34;&gt;Known Issues&lt;/a&gt;&lt;/li&gt; &#xA;        &lt;/ul&gt; &lt;/li&gt; &#xA;      &lt;/ul&gt; &lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#finalize&#34;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#model-config-file&#34;&gt;Model Config File&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#inference-request-parameters&#34;&gt;Inference Request Parameters&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#managing-python-runtime-and-libraries&#34;&gt;Managing Python Runtime and Libraries&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#building-custom-python-backend-stub&#34;&gt;Building Custom Python Backend Stub&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#creating-custom-execution-environments&#34;&gt;Creating Custom Execution Environments&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#important-notes&#34;&gt;Important Notes&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#error-handling-1&#34;&gt;Error Handling&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#managing-shared-memory&#34;&gt;Managing Shared Memory&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#multiple-model-instance-support&#34;&gt;Multiple Model Instance Support&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#running-multiple-instances-of-triton-server&#34;&gt;Running Multiple Instances of Triton Server&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#business-logic-scripting&#34;&gt;Business Logic Scripting&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#using-bls-with-decoupled-models&#34;&gt;Using BLS with Decoupled Models&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#model-loading-api&#34;&gt;Model Loading API&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#using-bls-with-stateful-models&#34;&gt;Using BLS with Stateful Models&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#limitation&#34;&gt;Limitation&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#interoperability-and-gpu-support&#34;&gt;Interoperability and GPU Support&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#pb_utilstensorto_dlpack---pycapsule&#34;&gt;&lt;code&gt;pb_utils.Tensor.to_dlpack() -&amp;gt; PyCapsule&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#pb_utilstensorfrom_dlpack---tensor&#34;&gt;&lt;code&gt;pb_utils.Tensor.from_dlpack() -&amp;gt; Tensor&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#pb_utilstensoris_cpu---bool&#34;&gt;&lt;code&gt;pb_utils.Tensor.is_cpu() -&amp;gt; bool&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#input-tensor-device-placement&#34;&gt;Input Tensor Device Placement&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#frameworks&#34;&gt;Frameworks&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#pytorch&#34;&gt;PyTorch&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#pytorch-determinism&#34;&gt;PyTorch Determinism&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#tensorflow&#34;&gt;TensorFlow&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#tensorflow-determinism&#34;&gt;TensorFlow Determinism&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#custom-metrics&#34;&gt;Custom Metrics&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#examples&#34;&gt;Examples&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#addsub-in-numpy&#34;&gt;AddSub in NumPy&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#addsubnet-in-pytorch&#34;&gt;AddSubNet in PyTorch&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#addsub-in-jax&#34;&gt;AddSub in JAX&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#business-logic-scripting-1&#34;&gt;Business Logic Scripting&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#preprocessing&#34;&gt;Preprocessing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#decoupled-models&#34;&gt;Decoupled Models&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#model-instance-kind&#34;&gt;Model Instance Kind&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#auto-complete-config&#34;&gt;Auto-complete config&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#custom-metrics-1&#34;&gt;Custom Metrics&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#running-with-inferentia&#34;&gt;Running with Inferentia&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#logging&#34;&gt;Logging&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#reporting-problems-asking-questions&#34;&gt;Reporting problems, asking questions&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Run the Triton Inference Server container.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run --shm-size=1g --ulimit memlock=-1 -p 8000:8000 -p 8001:8001 -p 8002:8002 --ulimit stack=67108864 -ti nvcr.io/nvidia/tritonserver:&amp;lt;xx.yy&amp;gt;-py3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Replace &amp;lt;xx.yy&amp;gt; with the Triton version (e.g. 21.05).&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Inside the container, clone the Python backend repository.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/triton-inference-server/python_backend -b r&amp;lt;xx.yy&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Install example model.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd python_backend&#xA;mkdir -p models/add_sub/1/&#xA;cp examples/add_sub/model.py models/add_sub/1/model.py&#xA;cp examples/add_sub/config.pbtxt models/add_sub/config.pbtxt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Start the Triton server.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;tritonserver --model-repository `pwd`/models&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;In the host machine, start the client container.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -ti --net host nvcr.io/nvidia/tritonserver:&amp;lt;xx.yy&amp;gt;-py3-sdk /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;In the client container, clone the Python backend repository.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/triton-inference-server/python_backend -b r&amp;lt;xx.yy&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;Run the example client.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 python_backend/examples/add_sub/client.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Building from Source&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Requirements&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;cmake &amp;gt;= 3.17&lt;/li&gt; &#xA; &lt;li&gt;numpy&lt;/li&gt; &#xA; &lt;li&gt;rapidjson-dev&lt;/li&gt; &#xA; &lt;li&gt;libarchive-dev&lt;/li&gt; &#xA; &lt;li&gt;zlib1g-dev&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip3 install numpy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On Ubuntu or Debian you can use the command below to install &lt;code&gt;rapidjson&lt;/code&gt;, &lt;code&gt;libarchive&lt;/code&gt;, and &lt;code&gt;zlib&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install rapidjson-dev libarchive-dev zlib1g-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Build Python backend. Replace &amp;lt;GIT_BRANCH_NAME&amp;gt; with the GitHub branch that you want to compile. For release branches it should be r&amp;lt;xx.yy&amp;gt; (e.g. r21.06).&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir build&#xA;cd build&#xA;cmake -DTRITON_ENABLE_GPU=ON -DTRITON_BACKEND_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt; -DTRITON_COMMON_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt; -DTRITON_CORE_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt; -DCMAKE_INSTALL_PREFIX:PATH=`pwd`/install ..&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following required Triton repositories will be pulled and used in the build. If the CMake variables below are not specified, &#34;main&#34; branch of those repositories will be used. &amp;lt;GIT_BRANCH_NAME&amp;gt; should be the same as the Python backend repository branch that you are trying to compile.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;triton-inference-server/backend: &lt;code&gt;-DTRITON_BACKEND_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;triton-inference-server/common: &lt;code&gt;-DTRITON_COMMON_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;triton-inference-server/core: &lt;code&gt;-DTRITON_CORE_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Set &lt;code&gt;-DCMAKE_INSTALL_PREFIX&lt;/code&gt; to the location where the Triton Server is installed. In the released containers, this location is &lt;code&gt;/opt/tritonserver&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Copy example model and configuration&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;mkdir -p models/add_sub/1/&#xA;cp examples/add_sub/model.py models/add_sub/1/model.py&#xA;cp examples/add_sub/config.pbtxt models/add_sub/config.pbtxt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Start the Triton Server&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;/opt/tritonserver/bin/tritonserver --model-repository=`pwd`/models&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Use the client app to perform inference&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 examples/add_sub/client.py&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;In order to use the Python backend, you need to create a Python file that has a structure similar to below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;    &#34;&#34;&#34;Your Python model must use the same class name. Every Python model&#xA;    that is created must have &#34;TritonPythonModel&#34; as the class name.&#xA;    &#34;&#34;&#34;&#xA;&#xA;    @staticmethod&#xA;    def auto_complete_config(auto_complete_model_config):&#xA;        &#34;&#34;&#34;`auto_complete_config` is called only once when loading the model&#xA;        assuming the server was not started with&#xA;        `--disable-auto-complete-config`. Implementing this function is&#xA;        optional. No implementation of `auto_complete_config` will do nothing.&#xA;        This function can be used to set `max_batch_size`, `input` and `output`&#xA;        properties of the model using `set_max_batch_size`, `add_input`, and&#xA;        `add_output`. These properties will allow Triton to load the model with&#xA;        minimal model configuration in absence of a configuration file. This&#xA;        function returns the `pb_utils.ModelConfig` object with these&#xA;        properties. You can use the `as_dict` function to gain read-only access&#xA;        to the `pb_utils.ModelConfig` object. The `pb_utils.ModelConfig` object&#xA;        being returned from here will be used as the final configuration for&#xA;        the model.&#xA;&#xA;        Note: The Python interpreter used to invoke this function will be&#xA;        destroyed upon returning from this function and as a result none of the&#xA;        objects created here will be available in the `initialize`, `execute`,&#xA;        or `finalize` functions.&#xA;&#xA;        Parameters&#xA;        ----------&#xA;        auto_complete_model_config : pb_utils.ModelConfig&#xA;          An object containing the existing model configuration. You can build&#xA;          upon the configuration given by this object when setting the&#xA;          properties for this model.&#xA;&#xA;        Returns&#xA;        -------&#xA;        pb_utils.ModelConfig&#xA;          An object containing the auto-completed model configuration&#xA;        &#34;&#34;&#34;&#xA;        inputs = [{&#xA;            &#39;name&#39;: &#39;INPUT0&#39;,&#xA;            &#39;data_type&#39;: &#39;TYPE_FP32&#39;,&#xA;            &#39;dims&#39;: [4]&#xA;        }, {&#xA;            &#39;name&#39;: &#39;INPUT1&#39;,&#xA;            &#39;data_type&#39;: &#39;TYPE_FP32&#39;,&#xA;            &#39;dims&#39;: [4]&#xA;        }]&#xA;        outputs = [{&#xA;            &#39;name&#39;: &#39;OUTPUT0&#39;,&#xA;            &#39;data_type&#39;: &#39;TYPE_FP32&#39;,&#xA;            &#39;dims&#39;: [4]&#xA;        }, {&#xA;            &#39;name&#39;: &#39;OUTPUT1&#39;,&#xA;            &#39;data_type&#39;: &#39;TYPE_FP32&#39;,&#xA;            &#39;dims&#39;: [4]&#xA;        }]&#xA;&#xA;        # Demonstrate the usage of `as_dict`, `add_input`, `add_output`,&#xA;        # `set_max_batch_size`, and `set_dynamic_batching` functions.&#xA;        # Store the model configuration as a dictionary.&#xA;        config = auto_complete_model_config.as_dict()&#xA;        input_names = []&#xA;        output_names = []&#xA;        for input in config[&#39;input&#39;]:&#xA;            input_names.append(input[&#39;name&#39;])&#xA;        for output in config[&#39;output&#39;]:&#xA;            output_names.append(output[&#39;name&#39;])&#xA;&#xA;        for input in inputs:&#xA;            # The name checking here is only for demonstrating the usage of&#xA;            # `as_dict` function. `add_input` will check for conflicts and&#xA;            # raise errors if an input with the same name already exists in&#xA;            # the configuration but has different data_type or dims property.&#xA;            if input[&#39;name&#39;] not in input_names:&#xA;                auto_complete_model_config.add_input(input)&#xA;        for output in outputs:&#xA;            # The name checking here is only for demonstrating the usage of&#xA;            # `as_dict` function. `add_output` will check for conflicts and&#xA;            # raise errors if an output with the same name already exists in&#xA;            # the configuration but has different data_type or dims property.&#xA;            if output[&#39;name&#39;] not in output_names:&#xA;                auto_complete_model_config.add_output(output)&#xA;&#xA;        auto_complete_model_config.set_max_batch_size(0)&#xA;&#xA;        # To enable a dynamic batcher with default settings, you can use&#xA;        # auto_complete_model_config set_dynamic_batching() function. It is&#xA;        # commented in this example because the max_batch_size is zero.&#xA;        #&#xA;        # auto_complete_model_config.set_dynamic_batching()&#xA;&#xA;        return auto_complete_model_config&#xA;&#xA;    def initialize(self, args):&#xA;        &#34;&#34;&#34;`initialize` is called only once when the model is being loaded.&#xA;        Implementing `initialize` function is optional. This function allows&#xA;        the model to initialize any state associated with this model.&#xA;&#xA;        Parameters&#xA;        ----------&#xA;        args : dict&#xA;          Both keys and values are strings. The dictionary keys and values are:&#xA;          * model_config: A JSON string containing the model configuration&#xA;          * model_instance_kind: A string containing model instance kind&#xA;          * model_instance_device_id: A string containing model instance device&#xA;            ID&#xA;          * model_repository: Model repository path&#xA;          * model_version: Model version&#xA;          * model_name: Model name&#xA;        &#34;&#34;&#34;&#xA;        print(&#39;Initialized...&#39;)&#xA;&#xA;    def execute(self, requests):&#xA;        &#34;&#34;&#34;`execute` must be implemented in every Python model. `execute`&#xA;        function receives a list of pb_utils.InferenceRequest as the only&#xA;        argument. This function is called when an inference is requested&#xA;        for this model.&#xA;&#xA;        Parameters&#xA;        ----------&#xA;        requests : list&#xA;          A list of pb_utils.InferenceRequest&#xA;&#xA;        Returns&#xA;        -------&#xA;        list&#xA;          A list of pb_utils.InferenceResponse. The length of this list must&#xA;          be the same as `requests`&#xA;        &#34;&#34;&#34;&#xA;&#xA;        responses = []&#xA;&#xA;        # Every Python backend must iterate through list of requests and create&#xA;        # an instance of pb_utils.InferenceResponse class for each of them.&#xA;        # Reusing the same pb_utils.InferenceResponse object for multiple&#xA;        # requests may result in segmentation faults. You should avoid storing&#xA;        # any of the input Tensors in the class attributes as they will be&#xA;        # overridden in subsequent inference requests. You can make a copy of&#xA;        # the underlying NumPy array and store it if it is required.&#xA;        for request in requests:&#xA;            # Perform inference on the request and append it to responses&#xA;            # list...&#xA;&#xA;        # You must return a list of pb_utils.InferenceResponse. Length&#xA;        # of this list must match the length of `requests` list.&#xA;        return responses&#xA;&#xA;    def finalize(self):&#xA;        &#34;&#34;&#34;`finalize` is called only once when the model is being unloaded.&#xA;        Implementing `finalize` function is optional. This function allows&#xA;        the model to perform any necessary clean ups before exit.&#xA;        &#34;&#34;&#34;&#xA;        print(&#39;Cleaning up...&#39;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Every Python backend can implement four main functions:&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;auto_complete_config&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;auto_complete_config&lt;/code&gt; is called only once when loading the model assuming the server was not started with &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#auto-generated-model-configuration&#34;&gt;&lt;code&gt;--disable-auto-complete-config&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Implementing this function is optional. No implementation of &lt;code&gt;auto_complete_config&lt;/code&gt; will do nothing. This function can be used to set &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#maximum-batch-size&#34;&gt;&lt;code&gt;max_batch_size&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#dynamic-batcher&#34;&gt;dynamic_batching&lt;/a&gt;, &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#inputs-and-outputs&#34;&gt;&lt;code&gt;input&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#inputs-and-outputs&#34;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; properties of the model using &lt;code&gt;set_max_batch_size&lt;/code&gt;, &lt;code&gt;set_dynamic_batching&lt;/code&gt;, &lt;code&gt;add_input&lt;/code&gt;, and &lt;code&gt;add_output&lt;/code&gt;. These properties will allow Triton to load the model with &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#minimal-model-configuration&#34;&gt;minimal model configuration&lt;/a&gt; in absence of a configuration file. This function returns the &lt;code&gt;pb_utils.ModelConfig&lt;/code&gt; object with these properties. You can use the &lt;code&gt;as_dict&lt;/code&gt; function to gain read-only access to the &lt;code&gt;pb_utils.ModelConfig&lt;/code&gt; object. The &lt;code&gt;pb_utils.ModelConfig&lt;/code&gt; object being returned from here will be used as the final configuration for the model.&lt;/p&gt; &#xA;&lt;p&gt;Note: The Python interpreter used to invoke this function will be destroyed upon returning from this function and as a result none of the objects created here will be available in the &lt;code&gt;initialize&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, or &lt;code&gt;finalize&lt;/code&gt; functions.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;initialize&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;initialize&lt;/code&gt; is called once the model is being loaded. Implementing &lt;code&gt;initialize&lt;/code&gt; is optional. &lt;code&gt;initialize&lt;/code&gt; allows you to do any necessary initializations before execution. In the &lt;code&gt;initialize&lt;/code&gt; function, you are given an &lt;code&gt;args&lt;/code&gt; variable. &lt;code&gt;args&lt;/code&gt; is a Python dictionary. Both keys and values for this Python dictionary are strings. You can find the available keys in the &lt;code&gt;args&lt;/code&gt; dictionary along with their description in the table below:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;key&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;model_config&lt;/td&gt; &#xA;   &lt;td&gt;A JSON string containing the model configuration&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;model_instance_kind&lt;/td&gt; &#xA;   &lt;td&gt;A string containing model instance kind&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;model_instance_device_id&lt;/td&gt; &#xA;   &lt;td&gt;A string containing model instance device ID&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;model_repository&lt;/td&gt; &#xA;   &lt;td&gt;Model repository path&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;model_version&lt;/td&gt; &#xA;   &lt;td&gt;Model version&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;model_name&lt;/td&gt; &#xA;   &lt;td&gt;Model name&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;execute&lt;/code&gt; function is called whenever an inference request is made. Every Python model must implement &lt;code&gt;execute&lt;/code&gt; function. In the &lt;code&gt;execute&lt;/code&gt; function you are given a list of &lt;code&gt;InferenceRequest&lt;/code&gt; objects. There are two modes of implementing this function. The mode you choose should depend on your use case. That is whether or not you want to return decoupled responses from this model or not.&lt;/p&gt; &#xA;&lt;h4&gt;Default Mode&lt;/h4&gt; &#xA;&lt;p&gt;This is the most generic way you would like to implement your model and requires the &lt;code&gt;execute&lt;/code&gt; function to return exactly one response per request. This entails that in this mode, your &lt;code&gt;execute&lt;/code&gt; function must return a list of &lt;code&gt;InferenceResponse&lt;/code&gt; objects that has the same length as &lt;code&gt;requests&lt;/code&gt;. The work flow in this mode is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;execute&lt;/code&gt; function receives a batch of pb_utils.InferenceRequest as a length N array.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Perform inference on the pb_utils.InferenceRequest and append the corresponding pb_utils.InferenceResponse to a response list.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Return back the response list.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;The length of response list being returned must be N.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Each element in the list should be the response for the corresponding element in the request array.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Each element must contain a response (a response can be either output tensors or an error); an element cannot be None.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Triton checks to ensure that these requirements on response list are satisfied and if not returns an error response for all inference requests. Upon return from the execute function all tensor data associated with the InferenceRequest objects passed to the function are deleted, and so InferenceRequest objects should not be retained by the Python model.&lt;/p&gt; &#xA;&lt;h4&gt;Error Handling&lt;/h4&gt; &#xA;&lt;p&gt;In case one of the requests has an error, you can use the &lt;code&gt;TritonError&lt;/code&gt; object to set the error message for that specific request. Below is an example of setting errors for an &lt;code&gt;InferenceResponse&lt;/code&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;    ...&#xA;&#xA;    def execute(self, requests):&#xA;        responses = []&#xA;&#xA;        for request in requests:&#xA;            if an_error_occurred:&#xA;              # If there is an error, there is no need to pass the&#xA;              # &#34;output_tensors&#34; to the InferenceResponse. The &#34;output_tensors&#34;&#xA;              # that are passed in this case will be ignored.&#xA;              responses.append(pb_utils.InferenceResponse(&#xA;                error=pb_utils.TritonError(&#34;An Error Occurred&#34;)))&#xA;&#xA;        return responses&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Decoupled mode&lt;/h4&gt; &#xA;&lt;p&gt;This mode allows user to send multiple responses for a request or not send any responses for a request. A model may also send responses out-of-order relative to the order that the request batches are executed. Such models are called &lt;em&gt;decoupled&lt;/em&gt; models. In order to use this mode, the &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#model-transaction-policy&#34;&gt;transaction policy&lt;/a&gt; in the model configuration must be set to decoupled.&lt;/p&gt; &#xA;&lt;p&gt;In decoupled mode, model must use &lt;code&gt;InferenceResponseSender&lt;/code&gt; object per request to keep creating and sending any number of responses for the request. The workflow in this mode may look like:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;execute&lt;/code&gt; function receives a batch of pb_utils.InferenceRequest as a length N array.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Iterate through each pb_utils.InferenceRequest and perform for the following steps for each pb_utils.InferenceRequest object:&lt;/p&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt; &lt;p&gt;Get &lt;code&gt;InferenceResponseSender&lt;/code&gt; object for the InferenceRequest using InferenceRequest.get_response_sender().&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Create and populate pb_utils.InferenceResponse to be sent back.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;Use InferenceResponseSender.send() to send the above response. If this is the last request then pass pb_utils.TRITONSERVER_RESPONSE_COMPLETE_FINAL as a flag with InferenceResponseSender.send(). Otherwise continue with Step 1 for sending next request.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The return value for &lt;code&gt;execute&lt;/code&gt; function in this mode should be None.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Similar to above, in case one of the requests has an error, you can use the &lt;code&gt;TritonError&lt;/code&gt; object to set the error message for that specific request. After setting errors for an pb_utils.InferenceResponse object, use InferenceResponseSender.send() to send response with the error back to the user.&lt;/p&gt; &#xA;&lt;h5&gt;Use Cases&lt;/h5&gt; &#xA;&lt;p&gt;The decoupled mode is powerful and supports various other use cases:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;If the model should not send any response for the request, then call InferenceResponseSender.send() with no response but flag parameter set to pb_utils.TRITONSERVER_RESPONSE_COMPLETE_FINAL.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The model can also send responses out-of-order in which it received requests.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The request data and &lt;code&gt;InferenceResponseSender&lt;/code&gt; object can be passed to a separate thread in the model. This means main caller thread can exit from &lt;code&gt;execute&lt;/code&gt; function and the model can still continue generating responses as long as it holds &lt;code&gt;InferenceResponseSender&lt;/code&gt; object.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/decoupled/README.md&#34;&gt;decoupled examples&lt;/a&gt; demonstrate full power of what can be achieved from decoupled API. Read &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/decoupled_models.md&#34;&gt;Decoupled Backends and Models&lt;/a&gt; for more details on how to host a decoupled model.&lt;/p&gt; &#xA;&lt;h5&gt;Known Issues&lt;/h5&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Currently, decoupled Python models can not make async infer requests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Implementing &lt;code&gt;finalize&lt;/code&gt; is optional. This function allows you to do any clean ups necessary before the model is unloaded from Triton server.&lt;/p&gt; &#xA;&lt;p&gt;You can look at the &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/add_sub/model.py&#34;&gt;add_sub example&lt;/a&gt; which contains a complete example of implementing all these functions for a Python model that adds and subtracts the inputs given to it. After implementing all the necessary functions, you should save this file as &lt;code&gt;model.py&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Model Config File&lt;/h2&gt; &#xA;&lt;p&gt;Every Python Triton model must provide a &lt;code&gt;config.pbtxt&lt;/code&gt; file describing the model configuration. In order to use this backend you must set the &lt;code&gt;backend&lt;/code&gt; field of your model &lt;code&gt;config.pbtxt&lt;/code&gt; file to &lt;code&gt;python&lt;/code&gt;. You shouldn&#39;t set &lt;code&gt;platform&lt;/code&gt; field of the configuration.&lt;/p&gt; &#xA;&lt;p&gt;Your models directory should look like below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;models&#xA;└── add_sub&#xA;    ├── 1&#xA;    │   └── model.py&#xA;    └── config.pbtxt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Inference Request Parameters&lt;/h2&gt; &#xA;&lt;p&gt;You can retrieve the parameters associated with an inference request using the &lt;code&gt;inference_request.parameters()&lt;/code&gt; function. This function returns a JSON string where the keys are the keys of the parameters object and the values are the values for the parameters field. Note that you need to parse this string using &lt;code&gt;json.loads&lt;/code&gt; to convert it to a dictionary.&lt;/p&gt; &#xA;&lt;p&gt;You can read more about the inference request parameters in the &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/protocol/extension_parameters.md&#34;&gt;parameters extension&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h2&gt;Managing Python Runtime and Libraries&lt;/h2&gt; &#xA;&lt;p&gt;Python backend shipped in the &lt;a href=&#34;https://ngc.nvidia.com/&#34;&gt;NVIDIA GPU Cloud&lt;/a&gt; containers uses Python 3.10. Python backend is able to use the libraries that exist in the current Python environment. These libraries can be installed in a virtualenv, conda environment, or the global system Python. These libraries will only be used if the Python version matches the Python version of the Python backend&#39;s stub executable. For example, if you install a set of libraries in a Python 3.9 environment and your Python backend stub is compiled with Python 3.10 these libraries will NOT be available in your Python model served using Triton. You would need to compile the stub executable with Python 3.9 using the instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#building-custom-python-backend-stub&#34;&gt;Building Custom Python Backend Stub&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h3&gt;Building Custom Python Backend Stub&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important Note: You only need to compile a custom Python backend stub if the Python version is different from Python 3.10 which is shipped by default in the Triton containers.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Python backend uses a &lt;em&gt;stub&lt;/em&gt; process to connect your &lt;code&gt;model.py&lt;/code&gt; file to the Triton C++ core. This stub process has an embedded Python interpreter with a fixed Python version. If you intend to use a Python interpreter with different version from the default Python backend stub, you need to compile your own Python backend stub by following the steps below:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the software packages below:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cmake.org&#34;&gt;cmake&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;rapidjson and libarchive (instructions for installing these packages in Ubuntu or Debian are included in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#building-from-source&#34;&gt;Building from Source Section&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Make sure that the expected Python version is available in your environment.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you are using &lt;code&gt;conda&lt;/code&gt;, you should make sure to activate the environment by &lt;code&gt;conda activate &amp;lt;conda-env-name&amp;gt;&lt;/code&gt;. Note that you don&#39;t have to use &lt;code&gt;conda&lt;/code&gt; and can install Python however you wish. Python backend relies on &lt;a href=&#34;https://github.com/pybind/pybind11&#34;&gt;pybind11&lt;/a&gt; to find the correct Python version. If you noticed that the correct Python version is not picked up, you can read more on how &lt;a href=&#34;https://pybind11.readthedocs.io/en/stable/faq.html?highlight=cmake#cmake-doesn-t-detect-the-right-python-version&#34;&gt;pybind11 decides which Python to use&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Clone the Python backend repository and compile the Python backend stub (replace &amp;lt;GIT_BRANCH_NAME&amp;gt; with the branch name that you want to use, for release branches it should be r&amp;lt;xx.yy&amp;gt;):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/triton-inference-server/python_backend -b&#xA;&amp;lt;GIT_BRANCH_NAME&amp;gt;&#xA;cd python_backend&#xA;mkdir build &amp;amp;&amp;amp; cd build&#xA;cmake -DTRITON_ENABLE_GPU=ON -DTRITON_BACKEND_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt; -DTRITON_COMMON_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt; -DTRITON_CORE_REPO_TAG=&amp;lt;GIT_BRANCH_NAME&amp;gt; -DCMAKE_INSTALL_PREFIX:PATH=`pwd`/install ..&#xA;make triton-python-backend-stub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, you have access to a Python backend stub with your Python version. You can verify that using &lt;code&gt;ldd&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ldd triton_python_backend_stub&#xA;...&#xA;libpython3.6m.so.1.0 =&amp;gt; /home/ubuntu/envs/miniconda3/envs/python-3-6/lib/libpython3.6m.so.1.0 (0x00007fbb69cf3000)&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are many other shared libraries printed in addition to the library posted above. However, it is important to see &lt;code&gt;libpython&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;m.so.1.0&lt;/code&gt; in the list of linked shared libraries. If you use a different Python version, you should see that version instead. You need to copy the &lt;code&gt;triton_python_backend_stub&lt;/code&gt; to the model directory of the models that want to use the custom Python backend stub. For example, if you have &lt;code&gt;model_a&lt;/code&gt; in your &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_repository.md&#34;&gt;model repository&lt;/a&gt;, the folder structure should look like below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;models&#xA;|-- model_a&#xA;    |-- 1&#xA;    |   |-- model.py&#xA;    |-- config.pbtxt&#xA;    `-- triton_python_backend_stub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note the location of &lt;code&gt;triton_python_backend_stub&lt;/code&gt; in the directory structure above.&lt;/p&gt; &#xA;&lt;h3&gt;Creating Custom Execution Environments&lt;/h3&gt; &#xA;&lt;p&gt;If you want to create a tar file that contains all your Python dependencies or you want to use different Python environments for each Python model you need to create a &lt;em&gt;Custom Execution Environment&lt;/em&gt; in Python backend. Currently, Python backend supports &lt;a href=&#34;https://conda.github.io/conda-pack/&#34;&gt;conda-pack&lt;/a&gt; for this purpose. &lt;a href=&#34;https://conda.github.io/conda-pack/&#34;&gt;conda-pack&lt;/a&gt; ensures that your conda environment is portable. You can create a tar file for your conda environment using &lt;code&gt;conda-pack&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;conda-pack&#xA;Collecting packages...&#xA;Packing environment at &#39;/home/iman/miniconda3/envs/python-3-6&#39; to &#39;python-3-6.tar.gz&#39;&#xA;[########################################] | 100% Completed |  4.5s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Important Note:&lt;/strong&gt; Before installing the packages in your conda environment, make sure that you have exported &lt;a href=&#34;https://docs.python.org/3/using/cmdline.html#envvar-PYTHONNOUSERSITE&#34;&gt;&lt;code&gt;PYTHONNOUSERSITE&lt;/code&gt;&lt;/a&gt; environment variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;export PYTHONNOUSERSITE=True&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If this variable is not exported and similar packages are installed outside your conda environment, your tar file may not contain all the dependencies required for an isolated Python environment.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, Python backend also supports unpacked conda execution environments, given it points to an activation script to setup the conda environment. To do this, the execution environment can be first packed using &lt;a href=&#34;https://conda.github.io/conda-pack/&#34;&gt;conda-pack&lt;/a&gt; and then unpacked, or created using &lt;a href=&#34;https://docs.conda.io/projects/conda/en/latest/commands/create.html&#34;&gt;conda create -p&lt;/a&gt;. In this case, the conda activation script is located in: &lt;code&gt;$path_to_conda_pack/lib/python&amp;lt;your.python.version&amp;gt;/site-packages/conda_pack/scripts/posix/activate&lt;/code&gt; This speeds up the server loading time for models.&lt;/p&gt; &#xA;&lt;p&gt;After creating the packed file from the conda environment or creating a conda environment with a custom activation script, you need to tell Python backend to use that environment for your model. You can do this by adding the lines below to the &lt;code&gt;config.pbtxt&lt;/code&gt; file:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;name: &#34;model_a&#34;&#xA;backend: &#34;python&#34;&#xA;&#xA;...&#xA;&#xA;parameters: {&#xA;  key: &#34;EXECUTION_ENV_PATH&#34;,&#xA;  value: {string_value: &#34;/home/iman/miniconda3/envs/python-3-6/python3.6.tar.gz&#34;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to provide the execution environment path relative to the model folder in model repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;name: &#34;model_a&#34;&#xA;backend: &#34;python&#34;&#xA;&#xA;...&#xA;&#xA;parameters: {&#xA;  key: &#34;EXECUTION_ENV_PATH&#34;,&#xA;  value: {string_value: &#34;$$TRITON_MODEL_DIRECTORY/python3.6.tar.gz&#34;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, &lt;code&gt;python3.tar.gz&lt;/code&gt; should be placed in the model folder and the model repository should look like below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;models&#xA;|-- model_a&#xA;|   |-- 1&#xA;|   |   `-- model.py&#xA;|   |-- config.pbtxt&#xA;|   |-- python3.6.tar.gz&#xA;|   `-- triton_python_backend_stub&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example above, &lt;code&gt;$$TRITON_MODEL_DIRECTORY&lt;/code&gt; is resolved to &lt;code&gt;$pwd/models/model_a&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is useful if you want to use S3, GCS, or Azure and you do not have access to the absolute path of the execution env that is stored in the cloud object storage service.&lt;/p&gt; &#xA;&lt;h3&gt;Important Notes&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;The version of the Python interpreter in the execution environment must match the version of triton_python_backend_stub.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you don&#39;t want to use a different Python interpreter, you can skip &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#building-custom-python-backend-stub&#34;&gt;Building Custom Python Backend Stub&lt;/a&gt;. In this case you only need to pack your environment using &lt;code&gt;conda-pack&lt;/code&gt; and provide the path to tar file in the model config. However, the previous note still applies here and the version of the Python interpreter inside the conda environment must match the Python version of stub used by Python backend. The default version of the stub is Python 3.10.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can share a single execution environment across multiple models. You need to provide the path to the tar file in the &lt;code&gt;EXECUTION_ENV_PATH&lt;/code&gt; in the &lt;code&gt;config.pbtxt&lt;/code&gt; of all the models that want to use the execution environment.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If &lt;code&gt;$$TRITON_MODEL_DIRECTORY&lt;/code&gt; is used in the &lt;code&gt;EXECUTION_ENV_PATH&lt;/code&gt;, the final &lt;code&gt;EXECUTION_ENV_PATH&lt;/code&gt; &lt;strong&gt;must not&lt;/strong&gt; escape from the &lt;code&gt;$$TRITON_MODEL_DIRECTORY&lt;/code&gt;, as the behavior of accessing anywhere outside the &lt;code&gt;$$TRITON_MODEL_DIRECTORY&lt;/code&gt; is &lt;strong&gt;undefined&lt;/strong&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If a non-&lt;code&gt;$$TRITON_MODEL_DIRECTORY&lt;/code&gt; &lt;code&gt;EXECUTION_ENV_PATH&lt;/code&gt; is used, only local file system paths are currently supported. The behavior of using cloud paths is &lt;strong&gt;undefined&lt;/strong&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you need to compile the Python backend stub, it is recommended that you compile it in the official Triton NGC containers. Otherwise, your compiled stub may use dependencies that are not available in the Triton container that you are using for deployment. For example, compiling the Python backend stub on an OS other than Ubuntu 22.04 can lead to unexpected errors.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you encounter the &#34;GLIBCXX_3.4.30 not found&#34; error during runtime, we recommend upgrading your conda version and installing &lt;code&gt;libstdcxx-ng=12&lt;/code&gt; by running &lt;code&gt;conda install -c conda-forge libstdcxx-ng=12 -y&lt;/code&gt;. If this solution does not resolve the issue, please feel free to open an issue on the &lt;a href=&#34;https://github.com/triton-inference-server/server/issues&#34;&gt;GitHub issue page&lt;/a&gt; following the provided &lt;a href=&#34;https://github.com/triton-inference-server/server#reporting-problems-asking-questions&#34;&gt;instructions&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Error Handling&lt;/h2&gt; &#xA;&lt;p&gt;If there is an error that affects the &lt;code&gt;initialize&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, or &lt;code&gt;finalize&lt;/code&gt; function of the Python model you can use &lt;code&gt;TritonInferenceException&lt;/code&gt;. Example below shows how you can do error handling in &lt;code&gt;finalize&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;    ...&#xA;&#xA;    def finalize(self):&#xA;      if error_during_finalize:&#xA;        raise pb_utils.TritonModelException(&#xA;          &#34;An error occurred during finalize.&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Managing Shared Memory&lt;/h2&gt; &#xA;&lt;p&gt;Starting from 21.04 release, Python backend uses shared memory to connect user&#39;s code to Triton. Note that this change is completely transparent and does not require any change to the existing user&#39;s model code.&lt;/p&gt; &#xA;&lt;p&gt;Python backend, by default, allocates 64 MBs for each model instance. Then, it will grow the shared memory region by 64 MBs whenever an increase is required. You can configure the default shared memory used by each model instance using the &lt;code&gt;shm-default-byte-size&lt;/code&gt; flag. The amount of shared memory growth can be configured using the &lt;code&gt;shm-growth-byte-size&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can also configure the timeout used for connecting Triton main process to the Python backend stubs using the &lt;code&gt;stub-timeout-seconds&lt;/code&gt;. The default value is 30 seconds.&lt;/p&gt; &#xA;&lt;p&gt;The config values described above can be passed to Triton using &lt;code&gt;--backend-config&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/opt/tritonserver/bin/tritonserver --model-repository=`pwd`/models --backend-config=python,&amp;lt;config-key&amp;gt;=&amp;lt;config-value&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also, if you are running Triton inside a Docker container you need to properly set the &lt;code&gt;--shm-size&lt;/code&gt; flag depending on the size of your inputs and outputs. The default value for docker run command is &lt;code&gt;64MB&lt;/code&gt; which is very small.&lt;/p&gt; &#xA;&lt;h2&gt;Multiple Model Instance Support&lt;/h2&gt; &#xA;&lt;p&gt;Python interpreter uses a global lock known as &lt;a href=&#34;https://docs.python.org/3/c-api/init.html#thread-state-and-the-global-interpreter-lock&#34;&gt;GIL&lt;/a&gt;. Because of GIL, it is not possible have multiple threads running in the same Python interpreter simultaneously as each thread requires to acquire the GIL when accessing Python objects which will serialize all the operations. In order to work around this issue, Python backend spawns a separate process for each &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#multiple-model-instances&#34;&gt;model instance&lt;/a&gt;. This is in contrast with how other Triton backends such as &lt;a href=&#34;https://github.com/triton-inference-server/onnxruntime_backend&#34;&gt;ONNXRuntime&lt;/a&gt;, &lt;a href=&#34;https://github.com/triton-inference-server/tensorflow_backend&#34;&gt;TensorFlow&lt;/a&gt;, and &lt;a href=&#34;https://github.com/triton-inference-server/pytorch_backend&#34;&gt;PyTorch&lt;/a&gt; handle multiple instances. Increasing the instance count for these backends will create additional threads instead of spawning separate processes.&lt;/p&gt; &#xA;&lt;h2&gt;Running Multiple Instances of Triton Server&lt;/h2&gt; &#xA;&lt;p&gt;Python backend uses shared memory to transfer requests to the stub process. When running multiple instances of Triton Server on the same machine that use Python models, there would be shared memory region name conflicts that can result in segmentation faults or hangs. In order to avoid this issue, you need to specify different &lt;code&gt;shm-region-prefix-name&lt;/code&gt; using the &lt;code&gt;--backend-config&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Triton instance 1&#xA;tritonserver --model-repository=/models --backend-config=python,shm-region-prefix-name=prefix1&#xA;&#xA;# Triton instance 2&#xA;tritonserver --model-repository=/models --backend-config=python,shm-region-prefix-name=prefix2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the hangs would only occur if the &lt;code&gt;/dev/shm&lt;/code&gt; is shared between the two instances of the server. If you run the servers in different containers that don&#39;t share this location, you don&#39;t need to specify &lt;code&gt;shm-region-prefix-name&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Business Logic Scripting&lt;/h1&gt; &#xA;&lt;p&gt;Triton&#39;s &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/architecture.md#ensemble-models&#34;&gt;ensemble&lt;/a&gt; feature supports many use cases where multiple models are composed into a pipeline (or more generally a DAG, directed acyclic graph). However, there are many other use cases that are not supported because as part of the model pipeline they require loops, conditionals (if-then-else), data-dependent control-flow and other custom logic to be intermixed with model execution. We call this combination of custom logic and model executions &lt;em&gt;Business Logic Scripting (BLS)&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Starting from 21.08, you can implement BLS in your Python model. A new set of utility functions allows you to execute inference requests on other models being served by Triton as a part of executing your Python model. Note that BLS should only be used inside the &lt;code&gt;execute&lt;/code&gt; function and is not supported in the &lt;code&gt;initialize&lt;/code&gt; or &lt;code&gt;finalize&lt;/code&gt; methods. Example below shows how to use this feature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;  ...&#xA;    def execute(self, requests):&#xA;      ...&#xA;      # Create an InferenceRequest object. `model_name`,&#xA;      # `requested_output_names`, and `inputs` are the required arguments and&#xA;      # must be provided when constructing an InferenceRequest object. Make&#xA;      # sure to replace `inputs` argument with a list of `pb_utils.Tensor`&#xA;      # objects.&#xA;      inference_request = pb_utils.InferenceRequest(&#xA;          model_name=&#39;model_name&#39;,&#xA;          requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;          inputs=[&amp;lt;pb_utils.Tensor object&amp;gt;])&#xA;&#xA;      # `pb_utils.InferenceRequest` supports request_id, correlation_id,&#xA;      # model version, timeout and preferred_memory in addition to the&#xA;      # arguments described above.&#xA;      # These arguments are optional. An example containing all the arguments:&#xA;      # inference_request = pb_utils.InferenceRequest(model_name=&#39;model_name&#39;,&#xA;      #   requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;      #   inputs=[&amp;lt;list of pb_utils.Tensor objects&amp;gt;],&#xA;      #   request_id=&#34;1&#34;, correlation_id=4, model_version=1, flags=0, timeout=5,&#xA;      #   preferred_memory=pb_utils.PreferredMemory(&#xA;      #     pb_utils.TRITONSERVER_MEMORY_GPU, # or pb_utils.TRITONSERVER_MEMORY_CPU&#xA;      #     0))&#xA;&#xA;      # Execute the inference_request and wait for the response&#xA;      inference_response = inference_request.exec()&#xA;&#xA;      # Check if the inference response has an error&#xA;      if inference_response.has_error():&#xA;          raise pb_utils.TritonModelException(&#xA;            inference_response.error().message())&#xA;      else:&#xA;          # Extract the output tensors from the inference response.&#xA;          output1 = pb_utils.get_output_tensor_by_name(&#xA;            inference_response, &#39;REQUESTED_OUTPUT_1&#39;)&#xA;          output2 = pb_utils.get_output_tensor_by_name(&#xA;            inference_response, &#39;REQUESTED_OUTPUT_2&#39;)&#xA;&#xA;          # Decide the next steps for model execution based on the received&#xA;          # output tensors. It is possible to use the same output tensors&#xA;          # to for the final inference response too.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to the &lt;code&gt;inference_request.exec&lt;/code&gt; function that allows you to execute blocking inference requests, &lt;code&gt;inference_request.async_exec&lt;/code&gt; allows you to perform async inference requests. This can be useful when you do not need the result of the inference immediately. Using &lt;code&gt;async_exec&lt;/code&gt; function, it is possible to have multiple inflight inference requests and wait for the responses only when needed. Example below shows how to use &lt;code&gt;async_exec&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;import asyncio&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;  ...&#xA;&#xA;    # You must add the Python &#39;async&#39; keyword to the beginning of `execute`&#xA;    # function if you want to use `async_exec` function.&#xA;    async def execute(self, requests):&#xA;      ...&#xA;      # Create an InferenceRequest object. `model_name`,&#xA;      # `requested_output_names`, and `inputs` are the required arguments and&#xA;      # must be provided when constructing an InferenceRequest object. Make&#xA;      # sure to replace `inputs` argument with a list of `pb_utils.Tensor`&#xA;      # objects.&#xA;      inference_request = pb_utils.InferenceRequest(&#xA;          model_name=&#39;model_name&#39;,&#xA;          requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;          inputs=[&amp;lt;pb_utils.Tensor object&amp;gt;])&#xA;&#xA;      infer_response_awaits = []&#xA;      for i in range(4):&#xA;        # async_exec function returns an&#xA;        # [Awaitable](https://docs.python.org/3/library/asyncio-task.html#awaitables)&#xA;        # object.&#xA;        infer_response_awaits.append(inference_request.async_exec())&#xA;&#xA;      # Wait for all of the inference requests to complete.&#xA;      infer_responses = await asyncio.gather(*infer_response_awaits)&#xA;&#xA;      for infer_response in infer_responses:&#xA;        # Check if the inference response has an error&#xA;        if inference_response.has_error():&#xA;            raise pb_utils.TritonModelException(&#xA;              inference_response.error().message())&#xA;        else:&#xA;            # Extract the output tensors from the inference response.&#xA;            output1 = pb_utils.get_output_tensor_by_name(&#xA;              inference_response, &#39;REQUESTED_OUTPUT_1&#39;)&#xA;            output2 = pb_utils.get_output_tensor_by_name(&#xA;              inference_response, &#39;REQUESTED_OUTPUT_2&#39;)&#xA;&#xA;            # Decide the next steps for model execution based on the received&#xA;            # output tensors.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete example for sync and async BLS in Python backend is included in the &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#examples&#34;&gt;Examples&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;h2&gt;Using BLS with Decoupled Models&lt;/h2&gt; &#xA;&lt;p&gt;Starting from 23.03 release, you can execute inference requests on decoupled models in both &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#default-mode&#34;&gt;default mode&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#decoupled-mode&#34;&gt;decoupled mode&lt;/a&gt;. By setting the &lt;code&gt;decoupled&lt;/code&gt; parameter to &lt;code&gt;True&lt;/code&gt;, the &lt;code&gt;exec&lt;/code&gt; and &lt;code&gt;async_exec&lt;/code&gt; function will return an &lt;a href=&#34;https://docs.python.org/3/glossary.html#term-iterator&#34;&gt;iterator&lt;/a&gt; of inference responses returned by a decoupled model. If the &lt;code&gt;decoupled&lt;/code&gt; parameter is set to &lt;code&gt;False&lt;/code&gt;, the &lt;code&gt;exec&lt;/code&gt; and &lt;code&gt;async_exec&lt;/code&gt; function will return a single response as shown in the example above. Besides, you can set the timeout via the parameter &#39;timeout&#39; in microseconds within the constructor of &lt;code&gt;InferenceRequest&lt;/code&gt;. If the request times out, the request will respond with an error. The default of &#39;timeout&#39; is 0 which indicates that the request has no timeout.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, starting from the 23.04 release, you have the flexibility to select a specific device to receive output tensors from BLS calls. This can be achieved by setting the optional &lt;code&gt;preferred_memory&lt;/code&gt; parameter within the &lt;code&gt;InferenceRequest&lt;/code&gt; constructor. To do this, you can create a &lt;code&gt;PreferredMemory&lt;/code&gt; object and specify the &lt;code&gt;preferred_memory_type&lt;/code&gt; as either &lt;code&gt;TRITONSERVER_MEMORY_GPU&lt;/code&gt; or &lt;code&gt;TRITONSERVER_MEMORY_CPU&lt;/code&gt;, as well as the &lt;code&gt;preferred_device_id&lt;/code&gt; as an integer to indicate the memory type and device ID on which you wish to receive output tensors. If you do not specify the &lt;code&gt;preferred_memory&lt;/code&gt; parameter, the output tensors will be allocated on the same device where the output tensors were received from the model to which the BLS call is made.&lt;/p&gt; &#xA;&lt;p&gt;Example below shows how to use this feature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;  ...&#xA;    def execute(self, requests):&#xA;      ...&#xA;      # Create an InferenceRequest object. `model_name`,&#xA;      # `requested_output_names`, and `inputs` are the required arguments and&#xA;      # must be provided when constructing an InferenceRequest object. Make&#xA;      # sure to replace `inputs` argument with a list of `pb_utils.Tensor`&#xA;      # objects.&#xA;      inference_request = pb_utils.InferenceRequest(&#xA;          model_name=&#39;model_name&#39;,&#xA;          requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;          inputs=[&amp;lt;pb_utils.Tensor object&amp;gt;])&#xA;&#xA;      # `pb_utils.InferenceRequest` supports request_id, correlation_id,&#xA;      # model version, timeout and preferred_memory in addition to the&#xA;      # arguments described above.&#xA;      # These arguments are optional. An example containing all the arguments:&#xA;      # inference_request = pb_utils.InferenceRequest(model_name=&#39;model_name&#39;,&#xA;      #   requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;      #   inputs=[&amp;lt;list of pb_utils.Tensor objects&amp;gt;],&#xA;      #   request_id=&#34;1&#34;, correlation_id=4, model_version=1, flags=0, timeout=5,&#xA;      #   preferred_memory=pb_utils.PreferredMemory(&#xA;      #     pb_utils.TRITONSERVER_MEMORY_GPU, # or pb_utils.TRITONSERVER_MEMORY_CPU&#xA;      #     0))&#xA;&#xA;      # Execute the inference_request and wait for the response. Here we are&#xA;      # running a BLS request on a decoupled model, hence setting the parameter&#xA;      # &#39;decoupled&#39; to &#39;True&#39;.&#xA;      inference_responses = inference_request.exec(decoupled=True)&#xA;&#xA;      for inference_response in inference_responses:&#xA;        # Check if the inference response has an error&#xA;        if inference_response.has_error():&#xA;            raise pb_utils.TritonModelException(&#xA;              inference_response.error().message())&#xA;&#xA;        # For some models, it is possible that the last response is empty&#xA;        if len(infer_response.output_tensors()) &amp;gt; 0:&#xA;          # Extract the output tensors from the inference response.&#xA;          output1 = pb_utils.get_output_tensor_by_name(&#xA;            inference_response, &#39;REQUESTED_OUTPUT_1&#39;)&#xA;          output2 = pb_utils.get_output_tensor_by_name(&#xA;            inference_response, &#39;REQUESTED_OUTPUT_2&#39;)&#xA;&#xA;          # Decide the next steps for model execution based on the received&#xA;          # output tensors. It is possible to use the same output tensors to&#xA;          # for the final inference response too.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In addition to the &lt;code&gt;inference_request.exec(decoupled=True)&lt;/code&gt; function that allows you to execute blocking inference requests on decoupled models, &lt;code&gt;inference_request.async_exec(decoupled=True)&lt;/code&gt; allows you to perform async inference requests. This can be useful when you do not need the result of the inference immediately. Using &lt;code&gt;async_exec&lt;/code&gt; function, it is possible to have multiple inflight inference requests and wait for the responses only when needed. Example below shows how to use &lt;code&gt;async_exec&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;import asyncio&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;  ...&#xA;&#xA;    # You must add the Python &#39;async&#39; keyword to the beginning of `execute`&#xA;    # function if you want to use `async_exec` function.&#xA;    async def execute(self, requests):&#xA;      ...&#xA;      # Create an InferenceRequest object. `model_name`,&#xA;      # `requested_output_names`, and `inputs` are the required arguments and&#xA;      # must be provided when constructing an InferenceRequest object. Make&#xA;      # sure to replace `inputs` argument with a list of `pb_utils.Tensor`&#xA;      # objects.&#xA;      inference_request = pb_utils.InferenceRequest(&#xA;          model_name=&#39;model_name&#39;,&#xA;          requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;          inputs=[&amp;lt;pb_utils.Tensor object&amp;gt;])&#xA;&#xA;      infer_response_awaits = []&#xA;      for i in range(4):&#xA;        # async_exec function returns an&#xA;        # [Awaitable](https://docs.python.org/3/library/asyncio-task.html#awaitables)&#xA;        # object.&#xA;        infer_response_awaits.append(&#xA;          inference_request.async_exec(decoupled=True))&#xA;&#xA;      # Wait for all of the inference requests to complete.&#xA;      async_responses = await asyncio.gather(*infer_response_awaits)&#xA;&#xA;      for infer_responses in async_responses:&#xA;        for infer_response in infer_responses:&#xA;          # Check if the inference response has an error&#xA;          if inference_response.has_error():&#xA;              raise pb_utils.TritonModelException(&#xA;                inference_response.error().message())&#xA;&#xA;          # For some models, it is possible that the last response is empty&#xA;          if len(infer_response.output_tensors()) &amp;gt; 0:&#xA;              # Extract the output tensors from the inference response.&#xA;              output1 = pb_utils.get_output_tensor_by_name(&#xA;                inference_response, &#39;REQUESTED_OUTPUT_1&#39;)&#xA;              output2 = pb_utils.get_output_tensor_by_name(&#xA;                inference_response, &#39;REQUESTED_OUTPUT_2&#39;)&#xA;&#xA;              # Decide the next steps for model execution based on the received&#xA;              # output tensors.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A complete example for sync and async BLS for decoupled models is included in the &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#examples&#34;&gt;Examples&lt;/a&gt; section.&lt;/p&gt; &#xA;&lt;p&gt;Starting from the 22.04 release, the lifetime of the BLS output tensors have been improved such that if a tensor is no longer needed in your Python model it will be automatically deallocated. This can increase the number of BLS requests that you can execute in your model without running into the out of GPU or shared memory error.&lt;/p&gt; &#xA;&lt;p&gt;Note: Async BLS is not supported on Python 3.6 or lower due to the &lt;code&gt;async&lt;/code&gt; keyword and &lt;code&gt;asyncio.run&lt;/code&gt; being introduced in Python 3.7.&lt;/p&gt; &#xA;&lt;h2&gt;Model Loading API&lt;/h2&gt; &#xA;&lt;p&gt;Starting from 23.07 release, you can use the model loading API to load models required by your BLS model. The model loading API is equivalent to the Triton C API for loading models which are documented in &lt;a href=&#34;https://github.com/triton-inference-server/core/raw/main/include/triton/core/tritonserver.h&#34;&gt;tritonserver.h&lt;/a&gt;. Below is an example of how to use the model loading API:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;class TritonPythonModel:&#xA;    def initialize(self, args):&#xA;        self.model_name=&#34;onnx_model&#34;&#xA;        # Check if the model is ready, and load the model if it is not ready.&#xA;        # You can specify the model version in string format. The version is&#xA;        # optional, and if not provided, the server will choose a version based&#xA;        # on the model and internal policy.&#xA;        if not pb_utils.is_model_ready(model_name=self.model_name,&#xA;                                       model_version=&#34;1&#34;):&#xA;            # Load the model from the model repository&#xA;            pb_utils.load_model(model_name=self.model_name)&#xA;&#xA;            # Load the model with an optional override model config in JSON&#xA;            # representation. If provided, this config will be used for&#xA;            # loading the model.&#xA;            config = &#34;{\&#34;backend\&#34;:\&#34;onnxruntime\&#34;, \&#34;version_policy\&#34;:{\&#34;specific\&#34;:{\&#34;versions\&#34;:[1]}}}&#34;&#xA;            pb_utils.load_model(model_name=self.model_name, config=config)&#xA;&#xA;            # Load the mode with optional override files. The override files are&#xA;            # specified as a dictionary where the key is the file path (with&#xA;            # &#34;file:&#34; prefix) and the value is the file content as bytes. The&#xA;            # files will form the model directory that the model will be loaded&#xA;            # from. If specified, &#39;config&#39; must be provided to be the model&#xA;            # configuration of the override model directory.&#xA;            with open(&#39;models/onnx_int32_int32_int32/1/model.onnx&#39;, &#39;rb&#39;) as file:&#xA;                data = file.read()&#xA;            files = {&#34;file:1/model.onnx&#34;: data}&#xA;            pb_utils.load_model(model_name=self.model_name,&#xA;                                config=config, files=files)&#xA;&#xA;    def execute(self, requests):&#xA;        # Execute the model&#xA;        ...&#xA;        # If the model is no longer needed, you can unload it. You can also&#xA;        # specify whether the dependents of the model should also be unloaded by&#xA;        # setting the &#39;unload_dependents&#39; parameter to True. The default value&#xA;        # is False. Need to be careful when unloading the model as it can affect&#xA;        # other model instances or other models that depend on it.&#xA;        pb_utils.unload_model(model_name=self.model_name,&#xA;                              unload_dependents=True)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the model loading API is only supported if the server is running in &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_management.md#model-control-mode-explicit&#34;&gt;explicit model control mode&lt;/a&gt;. Additionally, the model loading API should only be used after the server has been running, which means that the BLS model should not be loaded during server startup. You can use different &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/protocol/extension_model_repository.md&#34;&gt;client endpoints&lt;/a&gt; to load the model after the server has been started. The model loading API is currently not supported during the &lt;code&gt;auto_complete_config&lt;/code&gt; and &lt;code&gt;finalize&lt;/code&gt; functions.&lt;/p&gt; &#xA;&lt;h2&gt;Using BLS with Stateful Models&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/architecture.md#stateful-models&#34;&gt;Stateful models&lt;/a&gt; require setting additional flags in the inference request to indicate the start and end of a sequence. The &lt;code&gt;flags&lt;/code&gt; argument in the &lt;code&gt;pb_utils.InferenceRequest&lt;/code&gt; object can be used to indicate whether the request is the first or last request in the sequence. An example indicating that the request is starting the sequence:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;inference_request = pb_utils.InferenceRequest(model_name=&#39;model_name&#39;,&#xA;  requested_output_names=[&#39;REQUESTED_OUTPUT_1&#39;, &#39;REQUESTED_OUTPUT_2&#39;],&#xA;  inputs=[&amp;lt;list of pb_utils.Tensor objects&amp;gt;],&#xA;  request_id=&#34;1&#34;, correlation_id=4,&#xA;  flags=pb_utils.TRITONSERVER_REQUEST_FLAG_SEQUENCE_START)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For indicating the ending of the sequence you can use the &lt;code&gt;pb_utils.TRITONSERVER_REQUEST_FLAG_SEQUENCE_END&lt;/code&gt; flag. If the request is both starting and ending a sequence at the same time (i.e. the sequence has only a single request), you can use the bitwise OR operator to enable both of the flags:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;flags = pb_utils.TRITONSERVER_REQUEST_FLAG_SEQUENCE_START | pb_utils.TRITONSERVER_REQUEST_FLAG_SEQUENCE_END&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Limitation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You need to make sure that the inference requests performed as a part of your model do not create a circular dependency. For example, if model A performs an inference request on itself and there are no more model instances ready to execute the inference request, the model will block on the inference execution forever.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Async BLS is not supported when running a Python model in decoupled mode.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Interoperability and GPU Support&lt;/h1&gt; &#xA;&lt;p&gt;Starting from 21.09 release, Python backend supports &lt;a href=&#34;https://github.com/dmlc/dlpack&#34;&gt;DLPack&lt;/a&gt; for zero-copy transfer of Python backend tensors to other frameworks. The methods below are added to the &lt;code&gt;pb_utils.Tensor&lt;/code&gt; object to facilitate the same:&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;pb_utils.Tensor.to_dlpack() -&amp;gt; PyCapsule&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This method can be called on existing instantiated tensors to convert a Tensor to DLPack. The code snippet below shows how this works with PyTorch:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from torch.utils.dlpack import from_dlpack&#xA;import triton_python_backend_utils as pb_utils&#xA;&#xA;class TritonPythonModel:&#xA;&#xA;  def execute(self, requests):&#xA;    ...&#xA;    input0 = pb_utils.get_input_tensor_by_name(request, &#34;INPUT0&#34;)&#xA;&#xA;    # We have converted a Python backend tensor to a PyTorch tensor without&#xA;    # making any copies.&#xA;    pytorch_tensor = from_dlpack(input0.to_dlpack())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;code&gt;pb_utils.Tensor.from_dlpack() -&amp;gt; Tensor&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This static method can be used for creating a &lt;code&gt;Tensor&lt;/code&gt; object from the DLPack encoding of the tensor. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from torch.utils.dlpack import to_dlpack&#xA;import torch&#xA;import triton_python_backend_utils as pb_utils&#xA;&#xA;class TritonPythonModel:&#xA;&#xA;  def execute(self, requests):&#xA;    ...&#xA;    pytorch_tensor = torch.tensor([1, 2, 3], device=&#39;cuda&#39;)&#xA;&#xA;    # Create a Python backend tensor from the DLPack encoding of a PyTorch&#xA;    # tensor.&#xA;    input0 = pb_utils.Tensor.from_dlpack(&#34;INPUT0&#34;, to_dlpack(pytorch_tensor))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Python backend allows tensors implementing &lt;a href=&#34;https://data-apis.org/array-api/2022.12/API_specification/generated/array_api.array.__dlpack__.html&#34;&gt;&lt;code&gt;__dlpack__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://data-apis.org/array-api/2022.12/API_specification/generated/array_api.array.__dlpack_device__.html&#34;&gt;&lt;code&gt;__dlpack_device__&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://dmlc.github.io/dlpack/latest/python_spec.html&#34;&gt;interface&lt;/a&gt; to be converted to Python backend tensors. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;input0 = pb_utils.Tensor.from_dlpack(&#34;INPUT0&#34;, pytorch_tensor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This method only supports contiguous Tensors that are in C-order. If the tensor is not C-order contiguous an exception will be raised.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;code&gt;pb_utils.Tensor.is_cpu() -&amp;gt; bool&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This function can be used to check whether a tensor is placed in CPU or not.&lt;/p&gt; &#xA;&lt;h2&gt;Input Tensor Device Placement&lt;/h2&gt; &#xA;&lt;p&gt;By default, the Python backend moves all input tensors to CPU before providing them to the Python model. Starting from 21.09, you can change this default behavior. By setting &lt;code&gt;FORCE_CPU_ONLY_INPUT_TENSORS&lt;/code&gt; to &#34;no&#34;, Triton will not move input tensors to CPU for the Python model. Instead, Triton will provide the input tensors to the Python model in either CPU or GPU memory, depending on how those tensors were last used. You cannot predict which memory will be used for each input tensor so your Python model must be able to handle tensors in both CPU and GPU memory. To enable this setting, you need to add this setting to the &lt;code&gt;parameters&lt;/code&gt; section of model configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;parameters: { key: &#34;FORCE_CPU_ONLY_INPUT_TENSORS&#34; value: {string_value:&#34;no&#34;}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Frameworks&lt;/h1&gt; &#xA;&lt;p&gt;Since Python Backend models can support most python packages, it is a common workflow for users to use Deep Learning Frameworks like PyTorch in their &lt;code&gt;model.py&lt;/code&gt; implementation. This section will document some notes and FAQ about this workflow.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;Using a deep learning framework/package in a Python Backend model is not necessarily the same as using the corresponding Triton Backend implementation. For example, the &lt;a href=&#34;https://github.com/triton-inference-server/pytorch_backend&#34;&gt;PyTorch Backend&lt;/a&gt; is different from using a Python Backend model that uses &lt;code&gt;import torch&lt;/code&gt;. If you are seeing significantly different results from a model executed by the framework (ex: PyTorch) compared to the Python Backend model running the same framework, some of the first things you should check is that the framework versions being used and the input/output preparation are the same.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;PyTorch&lt;/h2&gt; &#xA;&lt;p&gt;For a simple example of using PyTorch in a Python Backend model, see the &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#addsubnet-in-pytorch&#34;&gt;AddSubNet PyTorch example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;PyTorch Determinism&lt;/h3&gt; &#xA;&lt;p&gt;When running PyTorch code, you may notice slight differences in output values across runs or across servers depending on hardware, system load, driver, or even batch size. These differences are generally related to the selection of CUDA kernels used to execute the operations, based on the factors mentioned.&lt;/p&gt; &#xA;&lt;p&gt;For most intents and purposes, these differences aren&#39;t large enough to affect a model&#39;s final prediction. However, to understand where these differences come from, see this &lt;a href=&#34;https://pytorch.org/docs/stable/notes/randomness.html&#34;&gt;doc&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;On Ampere devices and later, there is an optimization related to FP32 operations called &lt;a href=&#34;https://blogs.nvidia.com/blog/2020/05/14/tensorfloat-32-precision-format/&#34;&gt;TensorFloat32 (TF32)&lt;/a&gt;. Typically this optimization will improve overall performance at the cost of minor precision loss, but similarly this precision loss is acceptable for most model predictions. For more info on TF32 in PyTorch and how to enable/disable it as needed, see &lt;a href=&#34;https://pytorch.org/docs/stable/notes/cuda.html#tensorfloat-32-tf32-on-ampere-devices&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;TensorFlow&lt;/h2&gt; &#xA;&lt;h3&gt;TensorFlow Determinism&lt;/h3&gt; &#xA;&lt;p&gt;Similar to the PyTorch determinism section above, TensorFlow can have slight differences in outputs based on various factors like hardware, system configurations, or batch sizes due to the library&#39;s internal CUDA kernel selection process. For more information on improving the determinism of outputs in TensorFlow, see &lt;a href=&#34;https://www.tensorflow.org/api_docs/python/tf/config/experimental/enable_op_determinism&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Custom Metrics&lt;/h1&gt; &#xA;&lt;p&gt;Starting from 23.05, you can utlize Custom Metrics API to register and collect custom metrics in the &lt;code&gt;initialize&lt;/code&gt;, &lt;code&gt;execute&lt;/code&gt;, and &lt;code&gt;finalize&lt;/code&gt; functions of your Python model. The Custom Metrics API is the Python equivalent of the &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/metrics.md#custom-metrics&#34;&gt;TRITON C API custom metrics&lt;/a&gt; support. You will need to take the ownership of the custom metrics created through the APIs and must manage their lifetime. Note that a &lt;code&gt;MetricFamily&lt;/code&gt; object should be deleted only after all the &lt;code&gt;Metric&lt;/code&gt; objects under it are deleted if you&#39;d like to explicitly delete the custom metrics objects.&lt;/p&gt; &#xA;&lt;p&gt;Example below shows how to use this feature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;&#xA;class TritonPythonModel:&#xA;    def initialize(self, args):&#xA;      # Create a MetricFamily object to report the latency of the model&#xA;      # execution. The &#39;kind&#39; parameter must be either &#39;COUNTER&#39; or&#xA;      # &#39;GAUGE&#39;.&#xA;      self.metric_family = pb_utils.MetricFamily(&#xA;          name=&#34;preprocess_latency_ns&#34;,&#xA;          description=&#34;Cumulative time spent pre-processing requests&#34;,&#xA;          kind=pb_utils.MetricFamily.COUNTER # or pb_utils.MetricFamily.GAUGE&#xA;      )&#xA;&#xA;      # Create a Metric object under the MetricFamily object. The &#39;labels&#39;&#xA;      # is a dictionary of key-value pairs.&#xA;      self.metric = self.metric_family.Metric(&#xA;        labels={&#34;model&#34; : &#34;model_name&#34;, &#34;version&#34; : &#34;1&#34;}&#xA;      )&#xA;&#xA;    def execute(self, requests):&#xA;      responses = []&#xA;&#xA;      for request in requests:&#xA;        # Pre-processing - time it to capture latency&#xA;        start_ns = time.time_ns()&#xA;        self.preprocess(request)&#xA;        end_ns = time.time_ns()&#xA;&#xA;        # Update metric to track cumulative pre-processing latency&#xA;        self.metric.increment(end_ns - start_ns)&#xA;&#xA;      ...&#xA;&#xA;        print(&#34;Cumulative pre-processing latency:&#34;, self.metric.value())&#xA;&#xA;      return responses&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can look at the &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/custom_metrics/model.py&#34;&gt;custom_metrics example&lt;/a&gt; which contains a complete example of demonstrating the Custom Metrics API for a Python model.&lt;/p&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;For using the Triton Python client in these examples you need to install the &lt;a href=&#34;https://github.com/triton-inference-server/client#getting-the-client-libraries-and-examples&#34;&gt;Triton Python Client Library&lt;/a&gt;. The Python client for each of the examples is in the &lt;code&gt;client.py&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h2&gt;AddSub in NumPy&lt;/h2&gt; &#xA;&lt;p&gt;There is no dependencies required for the AddSub NumPy example. Instructions on how to use this model is explained in the quick start section. You can find the files in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/add_sub&#34;&gt;examples/add_sub&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;AddSubNet in PyTorch&lt;/h2&gt; &#xA;&lt;p&gt;In order to use this model, you need to install PyTorch. We recommend using &lt;code&gt;pip&lt;/code&gt; method mentioned in the &lt;a href=&#34;https://pytorch.org/get-started/locally/&#34;&gt;PyTorch website&lt;/a&gt;. Make sure that PyTorch is available in the same Python environment as other dependencies. Alternatively, you can create a &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#using-custom-python-execution-environments&#34;&gt;Python Execution Environment&lt;/a&gt;. You can find the files for this example in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/pytorch&#34;&gt;examples/pytorch&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;AddSub in JAX&lt;/h2&gt; &#xA;&lt;p&gt;The JAX example shows how to serve JAX in Triton using Python Backend. You can find the complete example instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/jax/README.md&#34;&gt;examples/jax&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Business Logic Scripting&lt;/h2&gt; &#xA;&lt;p&gt;The BLS example needs the dependencies required for both of the above examples. You can find the complete example instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/bls/README.md&#34;&gt;examples/bls&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/bls_decoupled/README.md&#34;&gt;examples/bls_decoupled&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Preprocessing&lt;/h2&gt; &#xA;&lt;p&gt;The Preprocessing example shows how to use Python Backend to do model preprocessing. You can find the complete example instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/preprocessing/README.md&#34;&gt;examples/preprocessing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Decoupled Models&lt;/h2&gt; &#xA;&lt;p&gt;The examples of decoupled models shows how to develop and serve &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/#decoupled-mode&#34;&gt;decoupled models&lt;/a&gt; in Triton using Python backend. You can find the complete example instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/decoupled/README.md&#34;&gt;examples/decoupled&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Model Instance Kind&lt;/h2&gt; &#xA;&lt;p&gt;Triton model configuration allows users to provide kind to &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#instance-groups&#34;&gt;instance group settings.&lt;/a&gt; A python backend model can be written to respect the kind setting to control the execution of a model instance either on CPU or GPU.&lt;/p&gt; &#xA;&lt;p&gt;In the &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/instance_kind/README.md&#34;&gt;model instance kind example&lt;/a&gt; we demonstrate how this can be achieved for your python model.&lt;/p&gt; &#xA;&lt;h2&gt;Auto-complete config&lt;/h2&gt; &#xA;&lt;p&gt;The auto-complete config example demonstrates how to use the &lt;code&gt;auto_complete_config&lt;/code&gt; function to define &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/user_guide/model_configuration.md#minimal-model-configuration&#34;&gt;minimal model configuration&lt;/a&gt; when a configuration file is not available. You can find the complete example instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/auto_complete/README.md&#34;&gt;examples/auto_complete&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Custom Metrics&lt;/h2&gt; &#xA;&lt;p&gt;The example shows how to use custom metrics API in Python Backend. You can find the complete example instructions in &lt;a href=&#34;https://raw.githubusercontent.com/triton-inference-server/python_backend/main/examples/custom_metrics/README.md&#34;&gt;examples/custom_metrics&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Running with Inferentia&lt;/h1&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://github.com/triton-inference-server/python_backend/tree/main/inferentia/README.md&#34;&gt;README.md&lt;/a&gt; located in the python_backend/inferentia sub folder.&lt;/p&gt; &#xA;&lt;h1&gt;Logging&lt;/h1&gt; &#xA;&lt;p&gt;Starting from 22.09 release, your Python model can log information using the following methods:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import triton_python_backend_utils as pb_utils&#xA;&#xA;class TritonPythonModel:&#xA;&#xA;  def execute(self, requests):&#xA;    ...&#xA;    logger = pb_utils.Logger&#xA;    logger.log_info(&#34;Info Msg!&#34;)&#xA;    logger.log_warn(&#34;Warning Msg!&#34;)&#xA;    logger.log_error(&#34;Error Msg!&#34;)&#xA;    logger.log_verbose(&#34;Verbose Msg!&#34;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; The logger can be defined and used in following class methods:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;initialize&lt;/li&gt; &#xA; &lt;li&gt;execute&lt;/li&gt; &#xA; &lt;li&gt;finalize&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Log messages can also be sent with their log-level explcitiy specified:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# log-level options: INFO, WARNING, ERROR, VERBOSE&#xA;logger.log(&#34;Specific Msg!&#34;, logger.INFO)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If no log-level is specified, this method will log INFO level messages.&lt;/p&gt; &#xA;&lt;p&gt;Note that the Triton server&#39;s settings determine which log messages appear within the server log. For example, if a model attempts to log a verbose-level message, but Triton is not set to log verbose-level messages, it will not appear in the server log. For more information on Triton&#39;s log settings and how to adjust them dynamically, please see Triton&#39;s &lt;a href=&#34;https://github.com/triton-inference-server/server/raw/main/docs/protocol/extension_logging.md&#34;&gt;logging extension&lt;/a&gt; documentation.&lt;/p&gt; &#xA;&lt;h1&gt;Reporting problems, asking questions&lt;/h1&gt; &#xA;&lt;p&gt;We appreciate any feedback, questions or bug reporting regarding this project. When help with code is needed, follow the process outlined in the Stack Overflow (&lt;a href=&#34;https://stackoverflow.com/help/mcve&#34;&gt;https://stackoverflow.com/help/mcve&lt;/a&gt;) document. Ensure posted examples are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;minimal – use as little code as possible that still produces the same problem&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;complete – provide all parts needed to reproduce the problem. Check if you can strip external dependency and still show the problem. The less time we spend on reproducing problems the more time we have to fix it&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;verifiable – test the code you&#39;re about to provide to make sure it reproduces the problem. Remove all other problems that are not related to your request/question.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>