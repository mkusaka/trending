<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub C++ Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-04-01T01:54:22Z</updated>
  <subtitle>Monthly Trending of C++ in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>LadybirdBrowser/ladybird</title>
    <updated>2025-04-01T01:54:22Z</updated>
    <id>tag:github.com,2025-04-01:/LadybirdBrowser/ladybird</id>
    <link href="https://github.com/LadybirdBrowser/ladybird" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Truly independent web browser&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ladybird&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://ladybird.org&#34;&gt;Ladybird&lt;/a&gt; is a truly independent web browser, using a novel engine based on web standards.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT] Ladybird is in a pre-alpha state, and only suitable for use by developers&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;We aim to build a complete, usable browser for the modern web.&lt;/p&gt; &#xA;&lt;p&gt;Ladybird uses a multi-process architecture with a main UI process, several WebContent renderer processes, an ImageDecoder process, and a RequestServer process.&lt;/p&gt; &#xA;&lt;p&gt;Image decoding and network connections are done out of process to be more robust against malicious content. Each tab has its own renderer process, which is sandboxed from the rest of the system.&lt;/p&gt; &#xA;&lt;p&gt;At the moment, many core library support components are inherited from SerenityOS:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LibWeb: Web rendering engine&lt;/li&gt; &#xA; &lt;li&gt;LibJS: JavaScript engine&lt;/li&gt; &#xA; &lt;li&gt;LibWasm: WebAssembly implementation&lt;/li&gt; &#xA; &lt;li&gt;LibCrypto/LibTLS: Cryptography primitives and Transport Layer Security&lt;/li&gt; &#xA; &lt;li&gt;LibHTTP: HTTP/1.1 client&lt;/li&gt; &#xA; &lt;li&gt;LibGfx: 2D Graphics Library, Image Decoding and Rendering&lt;/li&gt; &#xA; &lt;li&gt;LibUnicode: Unicode and locale support&lt;/li&gt; &#xA; &lt;li&gt;LibMedia: Audio and video playback&lt;/li&gt; &#xA; &lt;li&gt;LibCore: Event loop, OS abstraction layer&lt;/li&gt; &#xA; &lt;li&gt;LibIPC: Inter-process communication&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How do I build and run this?&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/LadybirdBrowser/ladybird/master/Documentation/BuildInstructionsLadybird.md&#34;&gt;build instructions&lt;/a&gt; for information on how to build Ladybird.&lt;/p&gt; &#xA;&lt;p&gt;Ladybird runs on Linux, macOS, Windows (with WSL2), and many other *Nixes.&lt;/p&gt; &#xA;&lt;h2&gt;How do I read the documentation?&lt;/h2&gt; &#xA;&lt;p&gt;Code-related documentation can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/LadybirdBrowser/ladybird/master/Documentation/&#34;&gt;documentation&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;Get in touch and participate!&lt;/h2&gt; &#xA;&lt;p&gt;Join &lt;a href=&#34;https://discord.gg/nvfjVJ4Svh&#34;&gt;our Discord server&lt;/a&gt; to participate in development discussion.&lt;/p&gt; &#xA;&lt;p&gt;Please read &lt;a href=&#34;https://raw.githubusercontent.com/LadybirdBrowser/ladybird/master/Documentation/GettingStartedContributing.md&#34;&gt;Getting started contributing&lt;/a&gt; if you plan to contribute to Ladybird for the first time.&lt;/p&gt; &#xA;&lt;p&gt;Before opening an issue, please see the &lt;a href=&#34;https://raw.githubusercontent.com/LadybirdBrowser/ladybird/master/CONTRIBUTING.md#issue-policy&#34;&gt;issue policy&lt;/a&gt; and the &lt;a href=&#34;https://raw.githubusercontent.com/LadybirdBrowser/ladybird/master/ISSUES.md&#34;&gt;detailed issue-reporting guidelines&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The full contribution guidelines can be found in &lt;a href=&#34;https://raw.githubusercontent.com/LadybirdBrowser/ladybird/master/CONTRIBUTING.md&#34;&gt;&lt;code&gt;CONTRIBUTING.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Ladybird is licensed under a 2-clause BSD license.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>praydog/REFramework</title>
    <updated>2025-04-01T01:54:22Z</updated>
    <id>tag:github.com,2025-04-01:/praydog/REFramework</id>
    <link href="https://github.com/praydog/REFramework" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scripting platform, modding framework and VR support for all RE Engine games&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;REFramework &lt;a href=&#34;https://github.com/praydog/REFramework-nightly/releases&#34;&gt;&lt;img src=&#34;https://github.com/praydog/reframework/actions/workflows/dev-release.yml/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;A mod framework, scripting platform, and modding tool for RE Engine games. Inspired by and uses code from &lt;a href=&#34;https://github.com/cursey/kanan-new&#34;&gt;Kanan&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;The last stable build can be downloaded from the &lt;a href=&#34;https://github.com/praydog/REFramework/releases&#34;&gt;Releases&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;p&gt;For newer builds, check out the &lt;a href=&#34;https://github.com/praydog/REFramework-nightly/releases&#34;&gt;Nightly Developer Builds&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Non-VR&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Extract only the &lt;code&gt;dinput8.dll&lt;/code&gt; from the zip file into your game folder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;VR&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install SteamVR (unless you&#39;re using OpenXR on a supported headset)&lt;/li&gt; &#xA; &lt;li&gt;Extract the whole zip file into your corresponding game folder.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/praydog/REFramework/wiki/VR-Troubleshooting&#34;&gt;VR Troubleshooting/FAQ&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Proton/Linux&lt;/h3&gt; &#xA;&lt;p&gt;Add the launch option &lt;code&gt;WINEDLLOVERRIDES=&#34;dinput8.dll=n,b&#34; %command%&lt;/code&gt; to your game through Steam&#39;s properties after extraction.&lt;/p&gt; &#xA;&lt;p&gt;Example game folder: G:\SteamLibrary\steamapps\common\RESIDENT EVIL 2 BIOHAZARD RE2&lt;/p&gt; &#xA;&lt;p&gt;Supports both DirectX 11 and DirectX 12.&lt;/p&gt; &#xA;&lt;h2&gt;Included Mods&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lua Scripting API &amp;amp; Plugin System (All games, check out the &lt;a href=&#34;https://cursey.github.io/reframework-book/&#34;&gt;Wiki&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;VR &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Generic 6DOF VR support for all games&lt;/li&gt; &#xA;   &lt;li&gt;Motion controls for RE2/RE3/RE7/RE8&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;First Person (RE2, RE3)&lt;/li&gt; &#xA; &lt;li&gt;Manual Flashlight (RE2, RE3, RE8)&lt;/li&gt; &#xA; &lt;li&gt;Free Camera (All games)&lt;/li&gt; &#xA; &lt;li&gt;Scene Timescale (All games)&lt;/li&gt; &#xA; &lt;li&gt;FOV Slider (All games)&lt;/li&gt; &#xA; &lt;li&gt;Vignette Disabler (All games)&lt;/li&gt; &#xA; &lt;li&gt;Ultrawide/Aspect Ratio fixes (All games)&lt;/li&gt; &#xA; &lt;li&gt;GUI Hider/Disabler (All games)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Included Fixes&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;RE8 Startup Crash&lt;/li&gt; &#xA; &lt;li&gt;RE8 Stutters (killing enemies, taking damage, etc...)&lt;/li&gt; &#xA; &lt;li&gt;MHRise/RE8 crashes related to third party DLLs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Included Tools (Developer Mode)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Game Objects Display&lt;/li&gt; &#xA; &lt;li&gt;Object Explorer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Supported Games&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Resident Evil 2&lt;/li&gt; &#xA; &lt;li&gt;Resident Evil 3&lt;/li&gt; &#xA; &lt;li&gt;Resident Evil 4&lt;/li&gt; &#xA; &lt;li&gt;Resident Evil 7&lt;/li&gt; &#xA; &lt;li&gt;Resident Evil Village&lt;/li&gt; &#xA; &lt;li&gt;Devil May Cry 5&lt;/li&gt; &#xA; &lt;li&gt;Street Fighter 6&lt;/li&gt; &#xA; &lt;li&gt;Monster Hunter Rise&lt;/li&gt; &#xA; &lt;li&gt;Monster Hunter Wilds&lt;/li&gt; &#xA; &lt;li&gt;Dragon&#39;s Dogma 2&lt;/li&gt; &#xA; &lt;li&gt;Ghosts &#39;n Goblins Resurrection (Using RE8 build)&lt;/li&gt; &#xA; &lt;li&gt;Apollo Justice: Ace Attorney Trilogy (Using DD2 build)&lt;/li&gt; &#xA; &lt;li&gt;Kunitsu-Gami: Path of the Goddess (Using DD2 build)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/SkacikPL&#34;&gt;SkacikPL&lt;/a&gt; for originally creating the Manual Flashlight mod.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cursey/&#34;&gt;cursey&lt;/a&gt; for helping develop the VR component and the scripting system.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/youwereeatenbyalid/&#34;&gt;The Hitchhiker&lt;/a&gt; and &lt;a href=&#34;https://github.com/alphazolam&#34;&gt;alphaZomega&lt;/a&gt; for the great help stress testing, creating scripts for the scripting system, and helpful suggestions.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hedge-dev/XenonRecomp</title>
    <updated>2025-04-01T01:54:22Z</updated>
    <id>tag:github.com,2025-04-01:/hedge-dev/XenonRecomp</id>
    <link href="https://github.com/hedge-dev/XenonRecomp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tool for recompiling Xbox 360 games to native executables.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;XenonRecomp&lt;/h1&gt; &#xA;&lt;p&gt;XenonRecomp is a tool that converts Xbox 360 executables into C++ code, which can then be recompiled for any platform. Currently, it only supports x86 platforms due to the use of x86 intrinsics.&lt;/p&gt; &#xA;&lt;p&gt;This project was heavily inspired by &lt;a href=&#34;https://github.com/N64Recomp/N64Recomp&#34;&gt;N64: Recompiled&lt;/a&gt;, a similar tool for N64 executables.&lt;/p&gt; &#xA;&lt;h2&gt;Implementation Details&lt;/h2&gt; &#xA;&lt;h3&gt;Instructions&lt;/h3&gt; &#xA;&lt;p&gt;The instructions are directly converted without any effort to make them resemble decompiled code, meaning the output is not very human-readable. The CPU state is passed as an argument to every PPC function, which includes definitions for every PPC register and their current values at the time of execution. The second argument is the base address pointer, as the Xbox 360 CPU uses 32-bit pointers.&lt;/p&gt; &#xA;&lt;p&gt;A good amount of PPC instructions are implemented, with missing ones primarily being variants of already implemented instructions. Some instructions, like the D3D unpack/pack instructions, do not support all operand types. When a missing case is encountered, a warning is generated, or a debug break is inserted into the converted C++ code.&lt;/p&gt; &#xA;&lt;p&gt;The instruction implementations operate on little-endian values. However, since the Xbox 360 is a big-endian machine, the memory load instructions swap endianness when reading values, and memory store instructions reverse it to big-endian before writing. All the memory loads and stores are marked volatile to prevent Clang from doing unsafe code reordering.&lt;/p&gt; &#xA;&lt;p&gt;Vector registers&#39; endianness handling is more complicated. Instead of swapping individual 32-bit elements, the recompiler chooses to reverse the entire 16-byte vector. Instructions must account for this reversed order, such as using the WZY components instead of XYZ in dot products or requiring reversed arguments for vector pack instructions.&lt;/p&gt; &#xA;&lt;p&gt;The FPU expects denormalized numbers to remain unmodified, while VMX instructions always flush them. This is managed by storing the current floating-point state in the CPU state struct and enabling or disabling denormal flushing as necessary before executing each instruction.&lt;/p&gt; &#xA;&lt;p&gt;Most VMX instructions are implemented using x86 intrinsics. Luckily, the number of AVX intrinsics used is relatively low, so adding support for other architectures using libraries like &lt;a href=&#34;https://github.com/simd-everywhere/simde&#34;&gt;SIMD Everywhere&lt;/a&gt; might be possible.&lt;/p&gt; &#xA;&lt;h3&gt;MMIO&lt;/h3&gt; &#xA;&lt;p&gt;MMIO, which is typically used for hardware operations such as XMA decoding, is currently unimplemented. There is an unfinished attempt to implement MMIO, but supporting it may be non-trivial and could require advanced analysis of instructions.&lt;/p&gt; &#xA;&lt;h3&gt;Indirect Functions&lt;/h3&gt; &#xA;&lt;p&gt;Virtual function calls are resolved by creating a &#34;perfect hash table&#34; at runtime, where dereferencing a 64-bit pointer (using the original instruction address multiplied by 2) gives the address of the recompiled function. This was previously implemented by creating an 8 GB virtual allocation, but it had too much memory pressure. Now it relies on function addresses being placed after the valid XEX memory region in the base memory pointer. These regions are exported as macros in the output &lt;code&gt;ppc_config.h&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;h3&gt;Jump Tables&lt;/h3&gt; &#xA;&lt;p&gt;Jump tables, at least in older Xbox 360 binaries, often have predictable assembly patterns, making them easy to detect statically without needing a virtual machine. XenonAnalyse has logic for detecting jump tables in Sonic Unleashed, though variations in other games (likely due to updates in the Xbox 360 compiler) may require modifications to the detection logic. Currently, there is no fully generic solution for handling jump tables, so updates to the detection logic may be needed for other games.&lt;/p&gt; &#xA;&lt;p&gt;The typical way to find jump tables is by searching for the &lt;code&gt;mtctr r0&lt;/code&gt; instruction. It will almost always be followed with a &lt;code&gt;bctr&lt;/code&gt;, with the previous instructions computing the jump address.&lt;/p&gt; &#xA;&lt;p&gt;XenonAnalyse generates a TOML file containing detected jump tables, which can be referenced in the main TOML config file. This allows the recompiler to generate real switch cases for these jump tables.&lt;/p&gt; &#xA;&lt;h3&gt;Function Boundary Analysis&lt;/h3&gt; &#xA;&lt;p&gt;XenonAnalyse includes a function boundary analyzer that works well in most cases. Functions with stack space have their boundaries defined in the &lt;code&gt;.pdata&lt;/code&gt; segment of the XEX. For functions not found in this segment, the analyzer detects the start of functions by searching for branch link instructions, and determines their length via static analysis.&lt;/p&gt; &#xA;&lt;p&gt;However, the analyzer struggles with functions containing jump tables, since they look like tail calls without enough information. While there is currently no solution for this, it might be relatively simple to extend the function analyzer to account for jump tables defined in the TOML file. As a workaround, the recompiler TOML file allows users to manually define function boundaries.&lt;/p&gt; &#xA;&lt;h3&gt;Exceptions&lt;/h3&gt; &#xA;&lt;p&gt;The recompiler currently does not support exceptions. This is challenging due to the use of the link register and the fact that exception handlers can jump to arbitrary code locations.&lt;/p&gt; &#xA;&lt;h3&gt;setjmp&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt; are implemented by redirecting them to native implementations. Thanks to the Xbox 360&#39;s large number of vector registers, the guest CPU state struct is large enough to hold the x86 CPU state and potentially states from other architectures.&lt;/p&gt; &#xA;&lt;h3&gt;Optimizations&lt;/h3&gt; &#xA;&lt;p&gt;Since Xbox 360 binaries typically follow a stable ABI, we can make certain assumptions about code structure, allowing the Clang compiler to generate better code. Several optimization options are available in the recompiler, but it&#39;s recommended to test them only after having a successfully functioning recompilation.&lt;/p&gt; &#xA;&lt;p&gt;The link register can be skipped assuming the game does not utilize exceptions, as the whole process of recompilation already takes care of function return behavior.&lt;/p&gt; &#xA;&lt;p&gt;The following registers, assuming the game doesn&#39;t violate the ABI, can be safely converted into local variables, as they never leave the function scope:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Count register&lt;/li&gt; &#xA; &lt;li&gt;XER&lt;/li&gt; &#xA; &lt;li&gt;Reserved register&lt;/li&gt; &#xA; &lt;li&gt;Condition registers&lt;/li&gt; &#xA; &lt;li&gt;Non argument registers&lt;/li&gt; &#xA; &lt;li&gt;Non volatile registers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The local variable optimization particularly introduces the most improvements, as the calls to the register restore/save functions can be completely removed, and the redundant stores to the PPC context struct can be eliminated. In &lt;a href=&#34;https://github.com/hedge-dev/UnleashedRecomp&#34;&gt;Unleashed Recompiled&lt;/a&gt;, the executable size decreases by around 20 MB with these optimizations, and frame times are reduced by several milliseconds.&lt;/p&gt; &#xA;&lt;h3&gt;Patch Mechanisms&lt;/h3&gt; &#xA;&lt;p&gt;XenonRecomp defines PPC functions in a way that makes them easy to hook, using techniques in the Clang compiler. By aliasing a PPC function to an &#34;implementation function&#34; and marking the original function as weakly linked, users can override it with a custom implementation while retaining access to the original function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;PPC_FUNC_IMPL(__imp__sub_XXXXXXXX);&#xA;PPC_FUNC(sub_XXXXXXXX)&#xA;{&#xA;    __imp__sub_XXXXXXXX(ctx, base);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, mid-asm hooks can be inserted directly into the translated C++ code at specific instruction addresses. The recompiler inserts these function calls, and users are responsible for implementing them in their recompilation project. The linker resolves them during compilation.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;XenonAnalyse&lt;/h3&gt; &#xA;&lt;p&gt;XenonAnalyse, when used as a command-line application, allows an XEX file to be passed as an input argument to output a TOML file containing all the detected jump tables in the executable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XenonAnalyse [input XEX file path] [output jump table TOML file path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;However, as explained in the earlier sections, due to variations between games, additional support may be needed to handle different patterns.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hedge-dev/UnleashedRecomp/raw/main/UnleashedRecompLib/config/SWA_switch_tables.toml&#34;&gt;An example jump table TOML file can be viewed in the Unleashed Recompiled repository.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;XenonRecomp&lt;/h3&gt; &#xA;&lt;p&gt;XenonRecomp accepts a TOML file with recompiler configurations and the path to the &lt;code&gt;ppc_context.h&lt;/code&gt; file located in the XenonUtils directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XenonRecomp [input TOML file path] [input PPC context header file path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/hedge-dev/UnleashedRecomp/raw/main/UnleashedRecompLib/config/SWA.toml&#34;&gt;An example recompiler TOML file can be viewed in the Unleashed Recompiled repository.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h4&gt;Main&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[main]&#xA;file_path = &#34;../private/default.xex&#34;&#xA;patch_file_path = &#34;../private/default.xexp&#34;&#xA;patched_file_path = &#34;../private/default_patched.xex&#34;&#xA;out_directory_path = &#34;../ppc&#34;&#xA;switch_table_file_path = &#34;SWA_switch_tables.toml&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the paths are relative to the directory where the TOML file is stored.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the XEX file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;patch_file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the XEXP file. This is not required if the game has no title updates.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;patched_file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the patched XEX file. XenonRecomp will create this file automatically if it is missing and reuse it in subsequent recompilations. It does nothing if no XEXP file is specified. You can pass this output file to XenonAnalyse.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;out_directory_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the directory that will contain the output C++ code. This directory must exist before running the recompiler.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;switch_table_file_path&lt;/td&gt; &#xA;   &lt;td&gt;Path to the TOML file containing the jump table definitions. The recompiler uses this file to convert jump tables to real switch cases.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Optimizations&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;skip_lr = false&#xA;skip_msr = false&#xA;ctr_as_local = false&#xA;xer_as_local = false&#xA;reserved_as_local = false&#xA;cr_as_local = false&#xA;non_argument_as_local = false&#xA;non_volatile_as_local = false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Enables or disables various optimizations explained earlier in the documentation. It is recommended not to enable these optimizations until you have a successfully running recompilation.&lt;/p&gt; &#xA;&lt;h4&gt;Register Restore &amp;amp; Save Functions&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;restgprlr_14_address = 0x831B0B40&#xA;savegprlr_14_address = 0x831B0AF0&#xA;restfpr_14_address = 0x831B144C&#xA;savefpr_14_address = 0x831B1400&#xA;restvmx_14_address = 0x831B36E8&#xA;savevmx_14_address = 0x831B3450&#xA;restvmx_64_address = 0x831B377C&#xA;savevmx_64_address = 0x831B34E4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Xbox 360 binaries feature specialized register restore &amp;amp; save functions that act similarly to switch case fallthroughs. Every function that utilizes non-volatile registers either has an inlined version of these functions or explicitly calls them. The recompiler requires the starting address of each restore/save function in the TOML file to recompile them correctly. These functions could likely be auto-detected, but there is currently no mechanism for it.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Byte Pattern&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restgprlr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restgprlr_14&lt;/code&gt; function. It starts with &lt;code&gt;ld r14, -0x98(r1)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile registers and restoring the link register at the end.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;e9 c1 ff 68&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savegprlr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savegprlr_14&lt;/code&gt; function. It starts with &lt;code&gt;std r14, -0x98(r1)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile registers and saving the link register at the end.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;f9 c1 ff 68&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restfpr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restfpr_14&lt;/code&gt; function. It starts with &lt;code&gt;lfd f14, -0x90(r12)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile FPU registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;c9 cc ff 70&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savefpr_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savefpr_14&lt;/code&gt; function. It starts with &lt;code&gt;stfd r14, -0x90(r12)&lt;/code&gt;, repeating the same operation for the rest of the non-volatile FPU registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;d9 cc ff 70&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restvmx_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restvmx_14&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x120&lt;/code&gt; and &lt;code&gt;lvx v14, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers until &lt;code&gt;v31&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fe e0 7d cb 60 ce&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savevmx_14_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savevmx_14&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x120&lt;/code&gt; and &lt;code&gt;stvx v14, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers until &lt;code&gt;v31&lt;/code&gt;.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fe e0 7d cb 61 ce&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;restvmx_64_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__restvmx_64&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x400&lt;/code&gt; and &lt;code&gt;lvx128 v64, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fc 00 10 0b 60 cb&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;savevmx_64_address&lt;/td&gt; &#xA;   &lt;td&gt;Start address of the &lt;code&gt;__savevmx_64&lt;/code&gt; function. It starts with &lt;code&gt;li r11, -0x400&lt;/code&gt; and &lt;code&gt;stvx128 v64, r11, r12&lt;/code&gt;, repeating the same operation for the rest of the non-volatile VMX registers.&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;39 60 fc 00 10 0b 61 cb&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;longjmp &amp;amp; setjmp&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;longjmp_address = 0x831B6790&#xA;setjmp_address = 0x831B6AB0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These are addresses for the &lt;code&gt;longjmp&lt;/code&gt; and &lt;code&gt;setjmp&lt;/code&gt; functions in the executable. The recompiler directly redirects these functions to native versions. The implementation of these functions might vary between games. In some cases, you might find &lt;code&gt;longjmp&lt;/code&gt; by looking for calls to &lt;code&gt;RtlUnwind&lt;/code&gt;, and &lt;code&gt;setjmp&lt;/code&gt; typically appears just after it.&lt;/p&gt; &#xA;&lt;p&gt;If the game does not use these functions, you can remove the properties from the TOML file.&lt;/p&gt; &#xA;&lt;h4&gt;Explicit Function Boundaries&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;functions = [&#xA;    { address = 0x824E7EF0, size = 0x98 },&#xA;    { address = 0x824E7F28, size = 0x60 },&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can define function boundaries explicitly using the &lt;code&gt;functions&lt;/code&gt; property if XenonAnalyse fails to analyze them correctly, for example, with functions containing jump tables.&lt;/p&gt; &#xA;&lt;h4&gt;Invalid Instruction Skips&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;invalid_instructions = [&#xA;    { data = 0x00000000, size = 4 }, # Padding&#xA;    { data = 0x831B1C90, size = 8 }, # C++ Frame Handler&#xA;    { data = 0x8324B3BC, size = 8 }, # C Specific Frame Handler&#xA;    { data = 0x831C8B50, size = 8 },&#xA;    { data = 0x00485645, size = 44 } # End of .text&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;invalid_instructions&lt;/code&gt; property, you can define 32-bit integer values that instruct the recompiler to skip over certain bytes when it encounters them. For example, in Unleashed Recompiled, these are used to skip over exception handling data, which is placed between functions but is not valid code.&lt;/p&gt; &#xA;&lt;h4&gt;Mid-asm Hooks&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[[midasm_hook]]&#xA;name = &#34;IndexBufferLengthMidAsmHook&#34;&#xA;address = 0x82E26244&#xA;registers = [&#34;r3&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void IndexBufferLengthMidAsmHook(PPCRegister&amp;amp; r3)&#xA;{&#xA;    // ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can define multiple mid-asm hooks in the TOML file, allowing the recompiler to insert function calls at specified addresses. When implementing them in your recompilation project, the linker will resolve the calls automatically.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Property&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;name&lt;/td&gt; &#xA;   &lt;td&gt;Function name of the mid-asm hook. You can reuse function names to place the same implementation at multiple addresses. Otherwise, unique implementations must have unique names.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;address&lt;/td&gt; &#xA;   &lt;td&gt;Address of the instruction where the function call will be placed. This does not overwrite the instruction at the specified address.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;registers&lt;/td&gt; &#xA;   &lt;td&gt;Registers to pass as arguments to the mid-asm hook. This is a list of registers because the local variable optimization does not keep optimized registers within the PPC context struct.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;return&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to indicate that the function where the hook was inserted should immediately return after calling the mid-asm hook.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;return_on_true&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to indicate that the function should return if the mid-asm hook call returns &lt;code&gt;true&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;return_on_false&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to indicate that the function should return if the mid-asm hook call returns &lt;code&gt;false&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jump_address&lt;/td&gt; &#xA;   &lt;td&gt;The address to jump to immediately after calling the mid-asm hook. The address must be within the same function where the hook was placed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jump_address_on_true&lt;/td&gt; &#xA;   &lt;td&gt;The address to jump to if the mid-asm hook returns &lt;code&gt;true&lt;/code&gt;. The address must be within the same function where the hook was placed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;jump_address_on_false&lt;/td&gt; &#xA;   &lt;td&gt;The address to jump to if the mid-asm hook returns &lt;code&gt;false&lt;/code&gt;. The address must be within the same function where the hook was placed.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;after_instruction&lt;/td&gt; &#xA;   &lt;td&gt;Set to &lt;code&gt;true&lt;/code&gt; to place the mid-asm hook immediately after the instruction, instead of before.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Certain properties are mutually exclusive. For example, you cannot use both &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;jump_address&lt;/code&gt;, and direct or conditional returns/jumps cannot be mixed. The recompiler is going to show warnings if this is not followed.&lt;/p&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;XenonRecomp can recompile Xenia&#39;s PPC tests and execute them through the XenonTests project in the repository. After building the tests using Xenia&#39;s build system, XenonRecomp can process the &lt;code&gt;src/xenia/cpu/ppc/testing/bin&lt;/code&gt; directory as input, generating C++ files in the specified output directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;XenonRecomp [input testing directory path] [input PPC context header file path] [output directory path]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the files are generated, refresh XenonTests&#39; CMake cache to make them appear in the project. The tests can then be executed to compare the results of instructions against the expected values.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;The project requires CMake 3.20 or later and Clang 18 or later to build. Since the repository includes submodules, ensure you clone it recursively.&lt;/p&gt; &#xA;&lt;p&gt;Compilers other than Clang have not been tested and are not recommended, including for recompilation output. The project relies on compiler-specific intrinsics and techniques that may not function correctly on other compilers, and many optimization methods depend on Clang&#39;s code generation.&lt;/p&gt; &#xA;&lt;p&gt;On Windows, you can use the clang-cl toolset and open the project in Visual Studio&#39;s CMake integration.&lt;/p&gt; &#xA;&lt;h2&gt;Special Thanks&lt;/h2&gt; &#xA;&lt;p&gt;This project could not have been possible without the &lt;a href=&#34;https://github.com/xenia-project/xenia&#34;&gt;Xenia&lt;/a&gt; emulator, as many parts of the CPU code conversion process has been implemented by heavily referencing its PPC code translator. The project also uses code from &lt;a href=&#34;https://github.com/xenia-canary/xenia-canary&#34;&gt;Xenia Canary&lt;/a&gt; to patch XEX binaries.&lt;/p&gt;</summary>
  </entry>
</feed>