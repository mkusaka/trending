<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Jupyter Notebook Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-07-01T01:45:07Z</updated>
  <subtitle>Daily Trending of Jupyter Notebook in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GokuMohandas/mlops-course</title>
    <updated>2022-07-01T01:45:07Z</updated>
    <id>tag:github.com,2022-07-01:/GokuMohandas/mlops-course</id>
    <link href="https://github.com/GokuMohandas/mlops-course" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A project-based course on the foundations of MLOps with a focus on intuition and application.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MLOps Course&lt;/h1&gt; &#xA;&lt;p&gt;Learn how to apply ML to build a production grade product to deliver value.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Lessons: &lt;a href=&#34;https://madewithml.com/#mlops&#34;&gt;https://madewithml.com/#mlops&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Code: &lt;a href=&#34;https://github.com/GokuMohandas/mlops-course&#34;&gt;GokuMohandas/mlops-course&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;üì¶&amp;nbsp; Purpose&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;üíª&amp;nbsp; Developing&lt;/strong&gt;&amp;nbsp;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;‚ôªÔ∏è&amp;nbsp; Reproducibility&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/purpose/&#34;&gt;Product&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/packaging/&#34;&gt;Packaging&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/git/&#34;&gt;Git&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/product/#system-design&#34;&gt;System design&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/organization/&#34;&gt;Organization&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/pre-commit/&#34;&gt;Pre-commit&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/purpose#project-management&#34;&gt;Project&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/logging/&#34;&gt;Logging&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/versioning/&#34;&gt;Versioning&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;üî¢&amp;nbsp; Data&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/documentation/&#34;&gt;Documentation&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/docker/&#34;&gt;Docker&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr style=&#34;height: 23.5px;&#34;&gt; &#xA;   &lt;td style=&#34;height: 23.5px;&#34;&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/exploratory-data-analysis/&#34;&gt;Exploration&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td style=&#34;height: 23.5px;&#34;&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/styling/&#34;&gt;Styling&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td style=&#34;height: 23.5px;&#34;&gt;&lt;strong&gt;üöÄ&amp;nbsp; Production&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/labeling/&#34;&gt;Labeling&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/makefile/&#34;&gt;Makefile&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/dashboard/&#34;&gt;Dashboard&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/preprocessing/&#34;&gt;Preprocessing&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;üì¶&amp;nbsp; Serving&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/cicd/&#34;&gt;CI/CD workflows&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/splitting/&#34;&gt;Splitting&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/cli/&#34;&gt;Command-line&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/infrastructure/&#34;&gt;Infrastructure&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/augmentation/&#34;&gt;Augmentation&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/api/&#34;&gt;RESTful API&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/monitoring/&#34;&gt;Monitoring&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;üìà&amp;nbsp; Modeling&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;‚úÖ&amp;nbsp; Testing&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/feature-store/&#34;&gt;Feature store&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;a href=&#34;https://madewithml.com/courses/mlops/baselines/&#34;&gt;Baselines&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/testing/&#34;&gt;Code&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a&gt;Data stack&lt;/a&gt;&amp;nbsp;&lt;small&gt;(Aug 2022)&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/evaluation/&#34;&gt;Evaluation&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/testing/#data&#34;&gt;Data&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a&gt;Orchestration&lt;/a&gt;&amp;nbsp;&lt;small&gt;(Aug 2022)&lt;/small&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/experiment-tracking/&#34;&gt;Experiment tracking&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/testing/#models&#34;&gt;Models&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://madewithml.com/courses/mlops/optimization/&#34;&gt;Optimization&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;   &lt;td&gt;&amp;nbsp;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;üìÜ&amp;nbsp; More content coming soon!&lt;br&gt; &lt;a href=&#34;https://newsletter.madewithml.com&#34; target=&#34;_blank&#34;&gt;Subscribe&lt;/a&gt; for our monthly updates on new content.&lt;/p&gt; &#xA;&lt;h3&gt;Instructions&lt;/h3&gt; &#xA;&lt;p&gt;We highly recommend going through the &lt;a href=&#34;https://madewithml.com/#mlops&#34;&gt;lessons&lt;/a&gt; one at a time and building the code base as we progress. For every concept, we focus on the fundamentals and then dive into the code, at which point we can refer to this repository as a guide.&lt;/p&gt; &#xA;&lt;h3&gt;Virtual environment&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python3 -m venv venv&#xA;source venv/bin/activate&#xA;python3 -m pip install --upgrade pip setuptools wheel&#xA;python3 -m pip install -e &#34;.[dev]&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If the commands above do not work, please refer to the &lt;a href=&#34;https://madewithml.com/courses/mlops/packaging/&#34;&gt;packaging&lt;/a&gt; lesson. We highly recommend using &lt;a href=&#34;https://madewithml.com/courses/mlops/packaging/#python&#34;&gt;Python version&lt;/a&gt; &lt;code&gt;3.7.10&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Directory&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tagifai/&#xA;‚îú‚îÄ‚îÄ data.py       - data processing utilities&#xA;‚îú‚îÄ‚îÄ evaluate.py   - evaluation components&#xA;‚îú‚îÄ‚îÄ main.py       - training/optimization operations&#xA;‚îú‚îÄ‚îÄ predict.py    - inference utilities&#xA;‚îú‚îÄ‚îÄ train.py      - training utilities&#xA;‚îî‚îÄ‚îÄ utils.py      - supplementary utilities&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Workflow&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python tagifai/main.py load-data&#xA;python tagifai/main.py label-data --args-fp=&#34;config/args.json&#34;&#xA;python tagifai/main.py optimize --args-fp=&#34;config/args.json&#34; --study-name=&#34;optimization&#34; --num-trials=10&#xA;python tagifai/main.py train-model --args-fp=&#34;config/args.json&#34; --experiment-name=&#34;baselines&#34; --run-name=&#34;sgd&#34;&#xA;python tagifai/main.py predict-tag --text=&#34;Transfer learning with transformers for text classification.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;API&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;uvicorn app.api:app --host 0.0.0.0 --port 8000 --reload --reload-dir tagifai --reload-dir app  # dev&#xA;gunicorn -c app/gunicorn.py -k uvicorn.workers.UvicornWorker app.api:app  # prod&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>facebookresearch/torchdim</title>
    <updated>2022-07-01T01:45:07Z</updated>
    <id>tag:github.com,2022-07-01:/facebookresearch/torchdim</id>
    <link href="https://github.com/facebookresearch/torchdim" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Named tensors with first-class dimensions for PyTorch&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Named Tensors using First-class Dimensions in PyTorch&lt;/h1&gt; &#xA;&lt;p&gt;-- Zachary DeVito &lt;a href=&#34;https://twitter.com/Zachary_DeVito&#34;&gt;@Zachary_DeVito&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;An implementation of &lt;a href=&#34;https://namedtensor.github.io&#34;&gt;named tensors&lt;/a&gt; with the functionality of &lt;a href=&#34;http://einops.rocks%5Dhttp://einops.rocks&#34;&gt;einsum&lt;/a&gt; , batching (&lt;a href=&#34;https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap&#34;&gt;vmap&lt;/a&gt;, &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/xmap_tutorial.html&#34;&gt;xmap&lt;/a&gt;), and tensor indexing by adding dimension objects to PyTorch&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The tensor input to a resnet might have the shape [8, 3, 224, 224] but informally we think of those dimensions as &#39;batch&#39;, &#39;channel&#39;, &#39;width&#39;, and &#39;height&#39;. Eventhough &#39;width&#39; and &#39;height&#39; have the same &lt;em&gt;size&lt;/em&gt; we still think of them as separate dimensions, and if we have two &lt;em&gt;different&lt;/em&gt; images, we think of both as sharing the &lt;em&gt;same&lt;/em&gt; &#39;channel&#39; dimension.&lt;/p&gt; &#xA;&lt;p&gt;Named tensors gives these dimensions names. &lt;a href=&#34;https://pytorch.org/docs/stable/named_tensor.html&#34;&gt;PyTorch&#39;s current implementation&lt;/a&gt; uses strings to name dimensions. Instead, this library introduces a Python object, a &lt;code&gt;Dim&lt;/code&gt;, to represent the concept. By expanding the semantics of tensors with dim objects, in addition to naming dimensions, we can get behavior equivalent to batching transforms (xmap, vmap), einops-style rearragement, and loop-style tensor indexing.&lt;/p&gt; &#xA;&lt;p&gt;A preview:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from torchdim import dims&#xA;&#xA;# einsum&#xA;def mm(A: torch.Tensor, B: torch.Tensor):&#xA;    i, j, k = dims(3)&#xA;    r = (A[i, k] * B[k, j]).sum(k)&#xA;    return r.order(i, j)&#xA;&#xA;# rearrange&#xA;def pixel_shuffle(img: torch.Tensor, upscale_factor=2):&#xA;    h2, w2, c, b, h, w = dims(6)&#xA;    h2.size = w2.size = upscale_factor&#xA;    return img[b, (c, h2, w2), h, w].order(b, c, (h, h2), (w, w2))&#xA;&#xA;# batching&#xA;def bmm(A: torch.Tensor, B: torch.Tensor):&#xA;    i = dims(1)&#xA;    return mm(A[i], B[i]).order(i)&#xA;&#xA;# indexing&#xA;def embedding_bag(input: torch.Tensor, embedding_weights: torch.Tensor):&#xA;    batch, sequence, features = dims(3)&#xA;    r = embedding_weights[input[batch, sequence], features].sum(sequence)&#xA;    return r.order(batch, features)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;torchdim is a preview release so that we can collect feedback on the API. It may have bugs, and there are known places where performance can be improved.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;First-class dims are a library that extends PyTorch, so they need to be installed separately. We may eventually upstream them into PyTorch itself along with &lt;code&gt;functorch&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We have to install a nightly build of PyTorch so first set up an environment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;conda create --name dim&#xA;conda activate dim&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;First-class dims requires a fairly recent nightly build of PyTorch so that functorch will work. You can install it using one of these commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# For CUDA 10.2&#xA;conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch-nightly&#xA;# For CUDA 11.3&#xA;conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch-nightly&#xA;# For CPU-only build&#xA;conda install pytorch torchvision torchaudio cpuonly -c pytorch-nightly&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install dim. You will be asked for github credentials to access the fairinternal organization.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip install ninja  # Makes the build go faster&#xA;pip install --user &#34;git+https://github.com/facebookresearch/torchdim&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Creating and Binding Dims&lt;/h1&gt; &#xA;&lt;p&gt;Python objects that represent dimension are created using the &lt;code&gt;dims&lt;/code&gt; operator.[^1]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import torch&#xA;from torchdim import dims&#xA;&#xA;batch, channel, width, height = dims(4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The existing implemention of &lt;a href=&#34;https://pytorch.org/docs/stable/named_tensor.html&#34;&gt;Named Tensors&lt;/a&gt; in PyTorch, or &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/xmap_tutorial.html&#34;&gt;JAX&#39;s xmap&lt;/a&gt; use strings to name dimensions. We call these dimensions &lt;em&gt;first class&lt;/em&gt; because they are Python objects.&lt;/p&gt; &#xA;&lt;p&gt;In addition to the normal &lt;em&gt;positional&lt;/em&gt; dimensions in a tensor, tensors can also have a separate set of first-class dimensions.&lt;/p&gt; &#xA;&lt;p&gt;You can create tensors with first-class dimensions by indexing the normal positional dimensions of a tensor with a dimension object. The &lt;code&gt;ndim&lt;/code&gt; property continues to list the number of positional dimesions, while the new &lt;code&gt;dims&lt;/code&gt; property lists all the bound first-class dimensions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;input = torch.rand(2, 3, 224, 224)&#xA;print(input.ndim)&#xA;&amp;gt; 4&#xA;&#xA;input_fc = input[batch, channel, width, height]&#xA;print(input_fc.dims) # first class dimensions&#xA;&amp;gt; (batch, channel, width, height)&#xA;&#xA;&#xA;# since we converted all the positional dimesions&#xA;# first class `input_fc` has 0 positional dimensions now.&#xA;print(input_fc.ndim)&#xA;&amp;gt; 0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice that indexing creates a &lt;em&gt;new&lt;/em&gt; Tensor, &lt;code&gt;input_fc&lt;/code&gt; with bound first-class dimensions. It does not modify the original tensor &lt;code&gt;input&lt;/code&gt;, which still has 4 positional dimensions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;print(input.ndim) # unchanged&#xA;&amp;gt; 4&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Importantly, indexing with square brackets &lt;em&gt;applies only to positional dimensions&lt;/em&gt;, so attempting to index a tensor with only first class dims will error[^2]:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;try:&#xA;    input_fc[0]&#xA;except ValueError as ve:&#xA;    print(ve)&#xA;&amp;gt; at least 1 indices were supplied but the tensor only has 0 dimensions&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Generally, it is possible to construct tensors with a mixture of positional and first class dimensions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;input_mixed = input[batch, :, :, height]&#xA;print(input_mixed.dims)&#xA;&amp;gt; (batch, height)&#xA;&#xA;print(input_mixed.ndim)&#xA;&amp;gt; 2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dimension Sizes&lt;/h2&gt; &#xA;&lt;p&gt;Dimensions will take on the size of the first thing they are bound to:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;input = torch.rand(3)&#xA;x = dims(1)&#xA;input_fc = input[x]&#xA;print(x.size)&#xA;&amp;gt; 3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;But you can also directly set the size of dimension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;i = dims(1)&#xA;&#xA;i.size = 5 # ok, i previously did not have a size&#xA;&#xA;i.size = 5 # ok, it already had the size 5&#xA;try:&#xA;    i.size = 3&#xA;except Exception as e:&#xA;    print(e)&#xA;&amp;gt; Dim &#39;i&#39; previously bound to a dimension of size 5 cannot bind to a dimension of size 3&#xA;&#xA;j = dims(sizes=[4]) # can also be set on construction&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[^1]: We use a bit of Python introspection to set the debug names for the dimensions based on the names of the variables they are assigned to. [^2]: Indexing of first-class dimensions can be done with the &lt;code&gt;index&lt;/code&gt; method by specifying the dimension to be index into (e.g. &lt;code&gt;input_fc.index(batch, 0)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Semantics of Dimensions&lt;/h1&gt; &#xA;&lt;p&gt;The power of named tensors arises from how the first-class dimensions in the Tensors composed with existing operations.&lt;/p&gt; &#xA;&lt;p&gt;Three rules define how dimension objects behave with existing Tensors.&lt;/p&gt; &#xA;&lt;h2&gt;Rule 1: Implicit Batching&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tensor operations (e.g. &lt;code&gt;input + bias&lt;/code&gt;) are implicitly batched over the union of the first-class dimensions in their inputs.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;input&lt;/code&gt; has dimensions &lt;code&gt;batch, channel&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt; has dimension &lt;code&gt;channel&lt;/code&gt;, the output will have the union of those dimensions (&lt;code&gt;batch, channel&lt;/code&gt;), and the result will computed as if there was a loop over all the first-class dimensions.[^3]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;input_positional = torch.rand(128, 32)&#xA;bias_positional = torch.rand(32)&#xA;&#xA;batch, channel = dims(2)&#xA;input = input_positional[batch, channel]&#xA;bias = bias_positional[channel]&#xA;&#xA;result = input + bias&#xA;print(result.dims)&#xA;&amp;gt; (batch, channel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is helpful think of operators on tensors with first-class dimensions by analogy to code with explicit loops over dimensions, with the first-class dimensions of the inputs acting as implicit &lt;code&gt;for&lt;/code&gt; loops, and the values in the tensor being scalars within the body of the loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# mental model: loop-level analogy&#xA;for batch in range(batch.size):&#xA;    for channel in range(channel.size):&#xA;        input = input_positional[batch, channels]&#xA;        bias = bias_positional[channels]&#xA;        result[batch, channels] =  input + bias # arithmetic on scalars&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Positional dimensions behave as they did before (e.g. for + they will broadcast), and can be thought of as being a standard tensor &lt;em&gt;used within the implicit loops&lt;/em&gt; defined by first-class dimensions.&lt;/p&gt; &#xA;&lt;p&gt;In this example, we broke down the expression into lines that bind the dimension to positional tensors and then another line to do the compute. In practice, we often combine these in one statement:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;result = input_positional[batch, channel] + bias_positional[channel]&#xA;result.dims&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[^3] This rule is similar to how named dimensions in xmap behave within a function, but instead of introducing the dimensions via a functional transform, they are bound on the objects using indexing.&lt;/p&gt; &#xA;&lt;h2&gt;Rule 2: Specifying dimensions&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Wherever an integer is used to specify a dimension in the existing torch operator, a first-class dimensions can be used instead to tell the operator to work over that dimension.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;batch, channel, width, height = dims(4)&#xA;input_positional = torch.rand(2, 3, 224, 224)&#xA;input = input_positional[batch, channel, width, height]&#xA;avg_pixel_color = input.mean((width, height))&#xA;&#xA;print(avg_pixel_color.dims)&#xA;&amp;gt; (batch, channel)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any other first-class dimensions (e.g. batch, channel) are still implicitly batched according to Rule #1.&lt;/p&gt; &#xA;&lt;h2&gt;Rule 3: Dims are Tensors&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;A first-class dimension &lt;code&gt;d&lt;/code&gt; can be used wherever a Tensor is expected. It will act as if it were a tensor whose only dimension is itself, &lt;code&gt;d&lt;/code&gt;, and the values along the dimension are the indices of each entry &lt;code&gt;(0, 1, 2, ..., d.size - 1)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;print(channel.dims)&#xA;&amp;gt; (channel,)&#xA;&#xA;print(channel + 1000)&#xA;&amp;gt; tensor([1000, 1001, 1002])&#xA;&amp;gt; with dims=(channel,) sizes=(3,)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that a dimension used as a tensor acts as an index into that dimension. Going back to our loop-level analogy, it is analogous to using the loop variable as a value:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# mental model: loop-level analogy&#xA;for channel in range(batch.size):&#xA;    result[channel] = channel + 1000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Arithmetic using dimension indices comes up a lot, such as the mask for an upper triangular part of a matrix. Using dims as tensors makes it easy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from torchdim import dims&#xA;i, j = dims(sizes=[4, 4])&#xA;print(i &amp;lt;= j)&#xA;&amp;gt; tensor([[ True,  True,  True,  True],&#xA;&amp;gt;         [False,  True,  True,  True],&#xA;&amp;gt;         [False, False,  True,  True],&#xA;&amp;gt;         [False, False, False,  True]])&#xA;&amp;gt; with dims=(i, j) sizes=(4, 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Because of the intentional similarity to loop-level code, using dimsions as tensors makes complicated indexing arithmetic easier to read.&lt;/p&gt; &#xA;&lt;p&gt;Here is code that lookups up features in an embedding table given a sequence of ids:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;sequence, features = dims(2)&#xA;embeddings = torch.rand(8, 128)&#xA;words = torch.tensor([5, 4, 0,])&#xA;&#xA;state = embeddings[words[sequence], features]&#xA;print(state.dims)&#xA;&amp;gt; (sequence, features)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the following analogy to loops:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# mental model: loop-level analogy&#xA;&#xA;for sequence in range(words.size(0)):&#xA;    for features in range(embeddings.size(1)):&#xA;        state = embeddings[words[sequence], features]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Earlier we showed how binding tensors dimension is done with indexing &lt;code&gt;A[i, j]&lt;/code&gt;. In fact, this binding is just the normal indexing operator. Its behavior follows directly from the behavior of indexing with tensor indices combined with Rule #3 and Rule #1. The expression &lt;code&gt;A[i + 1, j]&lt;/code&gt; also creates a tensor with dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; but with different indexing math. The implementation knows when simple indexing patterns are used and only actually runs a kernel to do indexing when needed.&lt;/p&gt; &#xA;&lt;h2&gt;Unbinding Dims&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;order&lt;/code&gt; method converts first-class dimensions in a tensor back to normal positional dimensions by specifying an order for those dimensions.[^4]&lt;/p&gt; &#xA;&lt;p&gt;By specifiying a different order from how things were originally bound, it is easy to do transpositions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;i, j = dims(2)&#xA;A = torch.rand(3, 4)&#xA;A_T = A[i, j].order(j, i)&#xA;assert torch.allclose(A.T, A_T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Indexing acts left-to-right, and &lt;code&gt;order&lt;/code&gt; also places the new dimensions back on the left, so it possible to work on tensors that have mixed positonal and first-class dimensions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;B = torch.rand(3, 4, 5)&#xA;B_T = B[i, j].order(j, i)&#xA;assert torch.allclose(B.permute(1, 0, 2), B_T)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;[^4] &lt;code&gt;order&lt;/code&gt; is actually just a synonym for the already-existing &lt;code&gt;permute&lt;/code&gt; method, which takes a list a dimension specifiers and puts the tensor in that order because rule #2 says that first-class dims can be passed as arguments to functions that previousely took only integers as dimensions. However, the name &lt;code&gt;permute&lt;/code&gt; is confusing in this context since it implies dim objects have an original order, so we prefer to use &lt;code&gt;order&lt;/code&gt; when writing code.&lt;/p&gt; &#xA;&lt;h2&gt;Flattening and Splitting Dims&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tuples of dimensions&lt;/strong&gt; can be passed to both indexing and &lt;code&gt;order&lt;/code&gt;. In indexing, this will split the dimension being indexed across the dimensions in the tuple. In &lt;code&gt;order&lt;/code&gt; it will flatten the dimensions in a single positional dimension:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;i, j, k = dims(3)&#xA;j.size = 2&#xA;A = torch.rand(6, 4)&#xA;a = A[(i, j), k] # split dim 0 into i,j&#xA;print(i.size, j.size, k.size)&#xA;&amp;gt; 3 2 4&#xA;&#xA;r = a.order(i, (j, k)) # flatten j and k&#xA;print(r.shape)&#xA;&amp;gt; torch.Size([3, 8])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The size of one unsized dimension in a tuple such as &lt;code&gt;i&lt;/code&gt; can be inferred if the other sizes are known.&lt;/p&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;The usefulness of dimension objects is best seen through examples. Let&#39;s look at some different ways they can be used.&lt;/p&gt; &#xA;&lt;h2&gt;Einsum-style Products&lt;/h2&gt; &#xA;&lt;p&gt;Rather than having &lt;a href=&#34;https://pytorch.org/docs/stable/generated/torch.einsum.html&#34;&gt;einsum&lt;/a&gt; as a custom operator, it is possible to express matrix products directly as a composition of multiplies and summations. The implementation will pattern match any multiplication followed by a sum to the right matrix-multiply operator.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def mm(A, B):&#xA;    i, j, k = dims(3)&#xA;    r = (A[i, k] * B[k, j]).sum(k)&#xA;    return r.order(i, j)&#xA;mm(torch.rand(3, 4), torch.rand(4, 5)).shape&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The implementation of named tensors delays the execution of multiply to see if a summation follows it as it does above. If so, it will turn this pattern into the correct &lt;em&gt;optimized matrix product&lt;/em&gt;, similar to how the &lt;code&gt;einsum&lt;/code&gt; function works.&lt;/p&gt; &#xA;&lt;p&gt;Since it is no longer necessary to manually match math to matrix functions, other tensor products are easier to express, like the Gram matrix used in style transfer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def gram_matrix_new(y):&#xA;    b, c, c2, h, w = dims()&#xA;    r = (y[b, c, h, w] * y[b, c2, h, w]).sum((h, w))&#xA;    r = r / (h.size * w.size)&#xA;    return r.order(b, c, c2)&#xA;&#xA;gram_matrix_new(torch.rand(1, 2, 3, 4))&#xA;# [example adapted from http://einops.rocks/pytorch-examples.html]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Attention is another example that has several matrix products embedded inside it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from torchdim import softmax&#xA;def attention(K, Q, V):&#xA;    batch, channel, key, query = dims(4)&#xA;    k = K[batch, channel, key]&#xA;    q = Q[batch, channel, query]&#xA;    v = V[batch, channel, key]&#xA;&#xA;    a = (k * q).sum(channel) # matrix multiply&#xA;    a = softmax(a * (channel.size ** -0.5), dim=key)&#xA;    r = (v * a).sum(key) # matrix multiply&#xA;    return torch.cat((r.order(batch, channel, query), Q), dim=1)&#xA;&#xA;inputs = (torch.rand(2, 3, 4) for _ in range(3))&#xA;attention(*inputs)&#xA;# [example adapted from http://einops.rocks/pytorch-examples.html]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Reshaping tensors (einops)&lt;/h2&gt; &#xA;&lt;p&gt;Lots of operations in deep learning are just different ways of reshaping, splitting, and joining dimensions, such as the pixel shuffle used to upscale an image by turning channels into pixels:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def pixel_shuffle(img, upscale_factor=2):&#xA;    h2, w2, c, b, h, w = dims(6)&#xA;    h2.size = w2.size = upscale_factor&#xA;    return img[b, (c, h2, w2), h, w].order(b, c, (h, h2), (w, w2))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://einops.rocks&#34;&gt;Einops&lt;/a&gt; is an extension to einsum that adds support for the manipulation of dimensions through a few custom operators such as &lt;code&gt;rearrange&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def pixel_shuffle_einops(img, upscale_factor=2):&#xA;    from einops import rearrange&#xA;    return rearrange(img, &#39;b (c h2 w2) h w -&amp;gt; b c (h h2) (w w2)&#39;, h2=upscale_factor, w2=upscale_factor)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Named tensors with first-class dimensions can accomplish the same goal, but using PyTorch&#39;s existing operator set.&lt;/p&gt; &#xA;&lt;h2&gt;Automatically batching Code (&lt;code&gt;vmap&lt;/code&gt;, &lt;code&gt;xmap&lt;/code&gt;)&lt;/h2&gt; &#xA;&lt;p&gt;The implicit batching of Rule #1 means it is easy to created batched versions of existing PyTorch code. Simply bind a dim to the dimensions that should act as a batch, and then pass the tensor to the unbatched function. Since the unbatched function does not know about the dim, the dim will be implicictly batched over:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;batch_size, feature_size = 3, 5&#xA;weights = torch.randn(feature_size)&#xA;&#xA;def model(feature_vec):&#xA;    # Very simple linear model with activation&#xA;    assert feature_vec.dim() == 1&#xA;    return feature_vec.dot(weights).relu()&#xA;&#xA;examples = torch.randn(batch_size, feature_size)&#xA;batch = dims(1)&#xA;r = model(examples[batch])&#xA;print(r)&#xA;# in functorch: result = functorch.vmap(model)(examples)&#xA;&amp;gt; tensor([0.4775, 0.0000, 0.3423])&#xA;&amp;gt; with dims=(batch,) sizes=(3,)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This pattern also composes well with other code that also uses first class dimensions. For instance, we can write batched matrix multiply &lt;code&gt;bmm&lt;/code&gt; by batching the &lt;code&gt;mm&lt;/code&gt; operator.&lt;/p&gt; &#xA;&lt;p&gt;It doesn&#39;t matter whether the implementation of the function uses dimension objects, it is also possible to add additional batch dimensions and then call a function:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def bmm(A, B):&#xA;    i = dims(1) # note: i here is a different value from i inside mm so it works&#xA;    return mm(A[i], B[i]).order(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The equivalent code in JAX, using &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/quickstart.html#auto-vectorization-with-vmap&#34;&gt;xmap or vmap&lt;/a&gt; are transforms over functions. So there is a lot of syntactic distance between the specification of the dimension mappings, and the values where those mappings apply. Dims express the mapping as indexing of the tensor, right at the place where the function is being applied.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/xmap_tutorial.html&#34;&gt;xmap examples&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;in_axes = [[&#39;inputs&#39;, &#39;hidden&#39;, ...],&#xA;           [&#39;hidden&#39;, &#39;classes&#39;, ...],&#xA;           [&#39;batch&#39;, &#39;inputs&#39;, ...],&#xA;           [&#39;batch&#39;, ...]]&#xA;&#xA;loss = xmap(named_loss, in_axes=in_axes, out_axes=[...])&#xA;print(loss(w1, w2, images, labels))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Equivalent with dimension objects:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;batch, inputs, hidden, classes = dims(4)&#xA;print(loss(w1[inputs, hidden], w2[hidden, classes], images[batch, inputs], labels[batch],&#xA;      batch, inputs, hidden, classes))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Composing matrix products, reshaping, and batching:&lt;/h2&gt; &#xA;&lt;p&gt;Multi-headed attention is a good example of how these different uses compose. It reshapes the inputs, splitting out different attention heads. It batches over those attention heads, and it uses matrix products to compute attention scores.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from torchdim import softmax&#xA;def multiheadattention(q, k, v, num_attention_heads, dropout_prob, use_positional_embedding):&#xA;    batch, query_sequence, key_sequence, heads, features = dims(5)&#xA;    heads.size = num_attention_heads&#xA;&#xA;    # binding dimensions, and unflattening the heads from the feature dimension&#xA;    q = q[batch, query_sequence, [heads, features]]&#xA;    k = k[batch, key_sequence, [heads, features]]&#xA;    v = v[batch, key_sequence, [heads, features]]&#xA;&#xA;    # einsum-style operators to calculate scores,&#xA;    attention_scores = (q*k).sum(features) * (features.size ** -0.5)&#xA;&#xA;    # use first-class dim to specify dimension for softmax&#xA;    attention_probs = softmax(attention_scores, dim=key_sequence)&#xA;&#xA;    # dropout work pointwise, following Rule #1&#xA;    attention_probs = torch.nn.functional.dropout(attention_probs, p=dropout_prob)&#xA;&#xA;    # another matrix product&#xA;    context_layer = (attention_probs*v).sum(key_sequence)&#xA;&#xA;    # flatten heads back into features&#xA;    return context_layer.order(batch, query_sequence, [heads, features])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Indexing&lt;/h2&gt; &#xA;&lt;p&gt;Rule #3 enables indexing because dimensions act as loop indices when used as a tensor. This allows for a lot of powerful behavior. The simplest might be using the dimensions to compute masks, such as extracing the upper triangular part of a matrix:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from torch import where&#xA;def triu(A):&#xA;    i,j = dims()&#xA;    a = A[i, j]&#xA;    return where(i &amp;lt;= j, a, 0).order(i, j)&#xA;triu(torch.rand(3, 4))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Embedding bag does an embedding table lookup followed by a sum, which can be expressed concisely:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def embedding_bag(input, embedding_weights):&#xA;    batch, sequence, features = dims(3)&#xA;    r = embedding_weights[input[batch, sequence], features].sum(sequence)&#xA;    return r.order(batch, features)&#xA;&#xA;input = torch.tensor([[1, 0, 4, 3]])&#xA;W = torch.rand(5,2)&#xA;embedding_bag(input, W)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Relative positional embeddings associate an embedding vector with the distance between the query and the key in the sequence. For instance, a key 3 and query 5 will have embedding ID &lt;code&gt;(5-3)=2&lt;/code&gt;. We can use first-class dimensions to do the indexing arithmetic, and the embedding lookup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def relative_positional_embedding(q, k, distance_embedding_weight):&#xA;    batch, query_sequence, key_sequence, heads, features = dims(5)&#xA;    q = q[batch, query_sequence, [heads, features]]&#xA;    k = k[batch, key_sequence, [heads, features]]&#xA;&#xA;    distance = query_sequence - key_sequence&#xA;    n_embeddings = distance_embedding_weight.size(0)&#xA;    index_bias = n_embeddings // 2&#xA;&#xA;    assert key_sequence.size + bias &amp;lt;= n_embeddings&#xA;&#xA;    # indexing with dims&#xA;    positional_embedding = distance_embedding_weight[distance + index_bias, features]&#xA;&#xA;    # matrix multiplies with dims&#xA;    relative_position_scores_query = (q*positional_embedding).sum(features)&#xA;    relative_position_scores_key = (k*positional_embedding).sum(features)&#xA;    return  (relative_position_scores_query + relative_position_scores_key).order(batch, heads, key_sequence, query_sequence)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Tensor Puzzlers&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/srush/Tensor-Puzzles&#34;&gt;Tensor Puzzlers&lt;/a&gt;, created by Sasha Rush, are a good exercise for learning the numpy and torch APIs by figuring out how to define common operations using a small set of primitive tensor operations.&lt;/p&gt; &#xA;&lt;p&gt;However, the difficulty of many of the puzzlers lies not in how to compute the answer but the awkwardness of the primitives themselves.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;With first class dimensions, these puzzlers are nearly the same as the spec that defines them&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Puzzle 3 - outer&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.outer.html&#34;&gt;outer&lt;/a&gt; - the outer product of two vectors.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def outer_spec(a, b, out):&#xA;    for i in range(len(out)):&#xA;        for j in range(len(out[0])):&#xA;            out[i][j] = a[i] * b[j]&#xA;&#xA;def outer(a, b):&#xA;    i, j = dims(2)&#xA;    return (a[i] * b[j]).order(i, j)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 4 - diag&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.diag.html&#34;&gt;diag&lt;/a&gt; - the diagonal vector of a square matrix.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def diag_spec(a, out):&#xA;    for i in range(len(a)):&#xA;        out[i] = a[i][i]&#xA;&#xA;def diag(a):&#xA;    i = dims(1)&#xA;    return a[i, i].order(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 5 - eye&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.eye.html&#34;&gt;eye&lt;/a&gt; - the identity matrix.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;from torch import where&#xA;def eye_spec(out):&#xA;    for i in range(len(out)):&#xA;        out[i][i] = 1&#xA;&#xA;def eye(j: int):&#xA;    i,j = dims(sizes=[j, j])&#xA;    return where(i == j, 1, 0).order(i, j)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 6 - triu&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.triu.html&#34;&gt;triu&lt;/a&gt; - the upper triangular matrix.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def triu_spec(out):&#xA;    for i in range(len(out)):&#xA;        for j in range(len(out)):&#xA;            if i &amp;lt;= j:&#xA;                out[i][j] = 1&#xA;            else:&#xA;                out[i][j] = 0&#xA;&#xA;def triu(j: int):&#xA;    i,j = dims(sizes=[j, j])&#xA;    return where(i &amp;lt;= j, 1, 0).order(i, j)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 8 - diff&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.diff.html&#34;&gt;diff&lt;/a&gt; - the running difference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def diff_spec(a, out):&#xA;    out[0] = a[0]&#xA;    for i in range(1, len(out)):&#xA;        out[i] = a[i] - a[i - 1]&#xA;def diff(a, i: int):&#xA;    i = dims(1)&#xA;    d = a[i] - a[i - 1]&#xA;    return where(i - 1 &amp;gt;= 0, d, a[i]).order(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 9 - vstack&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.vstack.html&#34;&gt;vstack&lt;/a&gt; - the matrix of two vectors&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def vstack_spec(a, b, out):&#xA;    for i in range(len(out[0])):&#xA;        out[0][i] = a[i]&#xA;        out[1][i] = b[i]&#xA;&#xA;def vstack(a, b):&#xA;    v, i = dims(sizes=[2, None])&#xA;    return where(v == 0,  a[i], b[i]).order(v, i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 10 - roll&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.roll.html&#34;&gt;roll&lt;/a&gt; - the vector shifted 1 circular position.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def roll_spec(a, out):&#xA;    for i in range(len(out)):&#xA;        if i + 1 &amp;lt; len(out):&#xA;            out[i] = a[i + 1]&#xA;        else:&#xA;            out[i] = a[i + 1 - len(out)]&#xA;&#xA;def roll(a, i: int):&#xA;    i = dims(sizes=[a.size(0)])&#xA;    return a[where(i + 1 &amp;lt; i.size, i + 1, 0)].order(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 11 - flip&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://numpy.org/doc/stable/reference/generated/numpy.flip.html&#34;&gt;flip&lt;/a&gt; - the reversed vector&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def flip_spec(a, out):&#xA;    for i in range(len(out)):&#xA;        out[i] = a[len(out) - i - 1]&#xA;&#xA;def flip(a, i: int):&#xA;    i = dims(sizes=[a.size(0)])&#xA;    return a[i.size - i - 1].order(i)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Puzzle 14 - sequence_mask&lt;/h3&gt; &#xA;&lt;p&gt;Compute &lt;a href=&#34;https://www.tensorflow.org/api_docs/python/tf/sequence_mask&#34;&gt;sequence_mask&lt;/a&gt; - pad out to length per batch.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def sequence_mask_spec(values, length, out):&#xA;    for i in range(len(out)):&#xA;        for j in range(len(out[0])):&#xA;            if j &amp;lt; length[i]:&#xA;                out[i][j] = values[i][j]&#xA;            else:&#xA;                out[i][j] = 0&#xA;&#xA;def sequence_mask(values, length):&#xA;    j, i = dims()&#xA;    v = values[i, j]&#xA;    return where(j &amp;lt; length[i], v, 0).order(i, j)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Advantages of First-class Dimensions over String Dimensions&lt;/h1&gt; &#xA;&lt;p&gt;The most prominent difference between named tensors using first-class dimensions and alternatives (einops, named tensors implemented in PyTorch today , &lt;a href=&#34;https://nlp.seas.harvard.edu/NamedTensor&#34;&gt;tensors considered harmful&lt;/a&gt;, or xmap) is that dimensions are objects rather than strings. Using objects has a number of nice properties.&lt;/p&gt; &#xA;&lt;h3&gt;Avoiding naming conflicts&lt;/h3&gt; &#xA;&lt;p&gt;Using strings for dimensions introduces the possibility that two unrelated dimensions are given the same name. Using objects instead makes it clear the same names are not the same dimension. It&#39;s like the difference between having only global variables, and having the ability to locally bind names in functions. For instance, we defined &lt;code&gt;bmm&lt;/code&gt; by batching a call to &lt;code&gt;mm&lt;/code&gt;, and even though they both use the name &lt;code&gt;i&lt;/code&gt; to identify a dimension. Because each &lt;code&gt;i&lt;/code&gt; is a different object, there is no naming conflict:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def mm(A, B):&#xA;    i, j, k = dims()&#xA;    r = (A[i, k] * B[k, j]).sum(k)&#xA;    return r.order(i, j)&#xA;&#xA;def bmm(A, B):&#xA;    i = dims() # note: doesn&#39;t matter than mm internally also uses i&#xA;    return mm(A[i], B[i])&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Einops avoids conflicts by ensuring names are all introduced and removed in a single expression, but this precludes using long-lived dimensions to present implicit batching similar to xmap. When nested, JAX&#39;s xmap seems to consider axes the same if the string name matches. In the above example it would consider the &lt;code&gt;i&lt;/code&gt; dimension to be the same dimension in both &lt;code&gt;bmm&lt;/code&gt; and &lt;code&gt;mm&lt;/code&gt; so the code would error.&lt;/p&gt; &#xA;&lt;h3&gt;Reuse the same operator set&lt;/h3&gt; &#xA;&lt;p&gt;Having a new object type allows us to extend the existing operator set of PyTorch rather than come up with new operators. For instance, binding dimensions using indexing follows semantically from Rules #1 and #3, so there is no need for a special operator to do binding. Even unbinding is just the &lt;code&gt;permute&lt;/code&gt; operator which follows from Rule #2, though we call it &lt;code&gt;order&lt;/code&gt; for clarity. In contrast, using strings requires coming up with new APIs such as &lt;code&gt;einsum&lt;/code&gt; for matrix multiplies, or &lt;code&gt;rearrange&lt;/code&gt; for doing permutations.&lt;/p&gt; &#xA;&lt;h3&gt;Allows dims to act as tensors&lt;/h3&gt; &#xA;&lt;p&gt;Rule #3 is not possible with strings since we cannot make strings behave as tensors. Without this rule, all of the indirect indexing that dims enable would not be easy to express.&lt;/p&gt; &#xA;&lt;h3&gt;Dims can have methods&lt;/h3&gt; &#xA;&lt;p&gt;For instance, as objects, dims can have a size, which allows us to do size inference of dimensions in various places in the API where string based APIs would have to take additional arguments specifying size.&lt;/p&gt; &#xA;&lt;h1&gt;Comparison to tensor compilers or languages (e.g. TVM or Dex)&lt;/h1&gt; &#xA;&lt;p&gt;The semantics and surface syntax of dimension objects resembles the kind of code written in tensor compilers such as &lt;a href=&#34;https://halide-lang.org&#34;&gt;Halide&lt;/a&gt;, &lt;a href=&#34;https://tvm.apache.org&#34;&gt;TVM&lt;/a&gt;, &lt;a href=&#34;https://github.com/facebookresearch/TensorComprehensions&#34;&gt;Tensor Comprehensions&lt;/a&gt;, or the language &lt;a href=&#34;https://github.com/google-research/dex-lang&#34;&gt;Dex&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;These compilers and language have syntax and semantics that resemble the loop-level analogy similar to first-class dimensions. However, as compilers or statically typed languages, they require some binding code to go from running deep learning framework code in Python to using the compiled language. This often at least requires refactoring the compiled parts into their own functions, and may require defining a gradient function. Similar to graph mode frameworks, this adds friction to using and debugging the code.&lt;/p&gt; &#xA;&lt;p&gt;Dimension objects are just an extension of the existing PyTorch tensors and eager sematics, so there is no friction switching between normal Python code and code that uses them. However, since loops over the dimensions are defined implicitly, they can still execute in Python with good performance compared to explicit loops. Furthermore, with dimension objects, a tensors containing dimensions can compute through code that is oblivous to the dimension such as batching examples. There is no need to separate code into &#39;compiled&#39; vs &#39;eager&#39;.&lt;/p&gt; &#xA;&lt;p&gt;In this way, first-class dims are a way of adapting the nicer syntax of these array compilers and languages to eager numpy-style libraries.&lt;/p&gt; &#xA;&lt;h1&gt;Performance Expectations&lt;/h1&gt; &#xA;&lt;p&gt;First-class dimensions are not a compiler. They provide syntax for existing PyTorch operations such as advanced indexing that is easier to read and write. For large sized tensors, the performance of any statements including them will be the same as using the already existing operations. An important exception is the pattern matching of products and summation, where performance will be improved by issuing to a matrix-multiply kernel. The C++ implementation of dimensions adds a small overhead of around 2us on top of PyTorch&#39;s normal overhead of 8us to each function that uses them. In the future, the implementation can encorporate more fusion optimization to further improve performance of this style of code.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Functorch has a BSD-style license, as found in the &lt;a href=&#34;https://raw.githubusercontent.com/facebookresearch/torchdim/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bentrevett/pytorch-seq2seq</title>
    <updated>2022-07-01T01:45:07Z</updated>
    <id>tag:github.com,2022-07-01:/bentrevett/pytorch-seq2seq</id>
    <link href="https://github.com/bentrevett/pytorch-seq2seq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tutorials on implementing a few sequence-to-sequence (seq2seq) models with PyTorch and TorchText.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PyTorch Seq2Seq&lt;/h1&gt; &#xA;&lt;h2&gt;Note: This repo only works with torchtext 0.9 or above which requires PyTorch 1.8 or above. If you are using torchtext 0.8 then please use &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/tree/torchtext08&#34;&gt;this&lt;/a&gt; branch&lt;/h2&gt; &#xA;&lt;p&gt;This repo contains tutorials covering understanding and implementing sequence-to-sequence (seq2seq) models using &lt;a href=&#34;https://github.com/pytorch/pytorch&#34;&gt;PyTorch&lt;/a&gt; 1.8, &lt;a href=&#34;https://github.com/pytorch/text&#34;&gt;torchtext&lt;/a&gt; 0.9 and &lt;a href=&#34;https://spacy.io/&#34;&gt;spaCy&lt;/a&gt; 3.0, using Python 3.8.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you find any mistakes or disagree with any of the explanations, please do not hesitate to &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/issues/new&#34;&gt;submit an issue&lt;/a&gt;. I welcome any feedback, positive or negative!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To install PyTorch, see installation instructions on the &lt;a href=&#34;https://raw.githubusercontent.com/bentrevett/pytorch-seq2seq/master/pytorch.org&#34;&gt;PyTorch website&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To install torchtext:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install torchtext&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;ll also make use of spaCy to tokenize our data. To install spaCy, follow the instructions &lt;a href=&#34;https://spacy.io/usage/&#34;&gt;here&lt;/a&gt; making sure to install both the English and German models with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python -m spacy download en_core_web_sm&#xA;python -m spacy download de_core_news_sm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Tutorials&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;1 - &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/raw/master/1%20-%20Sequence%20to%20Sequence%20Learning%20with%20Neural%20Networks.ipynb&#34;&gt;Sequence to Sequence Learning with Neural Networks&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/bentrevett/pytorch-seq2seq/blob/master/1%20-%20Sequence%20to%20Sequence%20Learning%20with%20Neural%20Networks.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;This first tutorial covers the workflow of a PyTorch with torchtext seq2seq project. We&#39;ll cover the basics of seq2seq networks using encoder-decoder models, how to implement these models in PyTorch, and how to use torchtext to do all of the heavy lifting with regards to text processing. The model itself will be based off an implementation of &lt;a href=&#34;https://arxiv.org/abs/1409.3215&#34;&gt;Sequence to Sequence Learning with Neural Networks&lt;/a&gt;, which uses multi-layer LSTMs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2 - &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/raw/master/2%20-%20Learning%20Phrase%20Representations%20using%20RNN%20Encoder-Decoder%20for%20Statistical%20Machine%20Translation.ipynb&#34;&gt;Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/bentrevett/pytorch-seq2seq/blob/master/2%20-%20Learning%20Phrase%20Representations%20using%20RNN%20Encoder-Decoder%20for%20Statistical%20Machine%20Translation.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Now we have the basic workflow covered, this tutorial will focus on improving our results. Building on our knowledge of PyTorch and torchtext gained from the previous tutorial, we&#39;ll cover a second second model, which helps with the information compression problem faced by encoder-decoder models. This model will be based off an implementation of &lt;a href=&#34;https://arxiv.org/abs/1406.1078&#34;&gt;Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation&lt;/a&gt;, which uses GRUs.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;3 - &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/raw/master/3%20-%20Neural%20Machine%20Translation%20by%20Jointly%20Learning%20to%20Align%20and%20Translate.ipynb&#34;&gt;Neural Machine Translation by Jointly Learning to Align and Translate&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/bentrevett/pytorch-seq2seq/blob/master/3%20-%20Neural%20Machine%20Translation%20by%20Jointly%20Learning%20to%20Align%20and%20Translate.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Next, we learn about attention by implementing &lt;a href=&#34;https://arxiv.org/abs/1409.0473&#34;&gt;Neural Machine Translation by Jointly Learning to Align and Translate&lt;/a&gt;. This further allievates the information compression problem by allowing the decoder to &#34;look back&#34; at the input sentence by creating context vectors that are weighted sums of the encoder hidden states. The weights for this weighted sum are calculated via an attention mechanism, where the decoder learns to pay attention to the most relevant words in the input sentence.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;4 - &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/raw/master/4%20-%20Packed%20Padded%20Sequences%2C%20Masking%2C%20Inference%20and%20BLEU.ipynb&#34;&gt;Packed Padded Sequences, Masking, Inference and BLEU&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/bentrevett/pytorch-seq2seq/blob/master/4%20-%20Packed%20Padded%20Sequences%2C%20Masking%2C%20Inference%20and%20BLEU.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;In this notebook, we will improve the previous model architecture by adding &lt;em&gt;packed padded sequences&lt;/em&gt; and &lt;em&gt;masking&lt;/em&gt;. These are two methods commonly used in NLP. Packed padded sequences allow us to only process the non-padded elements of our input sentence with our RNN. Masking is used to force the model to ignore certain elements we do not want it to look at, such as attention over padded elements. Together, these give us a small performance boost. We also cover a very basic way of using the model for inference, allowing us to get translations for any sentence we want to give to the model and how we can view the attention values over the source sequence for those translations. Finally, we show how to calculate the BLEU metric from our translations.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;5 - &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/raw/master/5%20-%20Convolutional%20Sequence%20to%20Sequence%20Learning.ipynb&#34;&gt;Convolutional Sequence to Sequence Learning&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/bentrevett/pytorch-seq2seq/blob/master/5%20-%20Convolutional%20Sequence%20to%20Sequence%20Learning.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;We finally move away from RNN based models and implement a fully convolutional model. One of the downsides of RNNs is that they are sequential. That is, before a word is processed by the RNN, all previous words must also be processed. Convolutional models can be fully parallelized, which allow them to be trained much quicker. We will be implementing the &lt;a href=&#34;https://arxiv.org/abs/1705.03122&#34;&gt;Convolutional Sequence to Sequence&lt;/a&gt; model, which uses multiple convolutional layers in both the encoder and decoder, with an attention mechanism between them.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;6 - &lt;a href=&#34;https://github.com/bentrevett/pytorch-seq2seq/raw/master/6%20-%20Attention%20is%20All%20You%20Need.ipynb&#34;&gt;Attention Is All You Need&lt;/a&gt; &lt;a href=&#34;https://colab.research.google.com/github/bentrevett/pytorch-seq2seq/blob/master/6%20-%20Attention%20is%20All%20You%20Need.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Continuing with the non-RNN based models, we implement the Transformer model from &lt;a href=&#34;https://arxiv.org/abs/1706.03762&#34;&gt;Attention Is All You Need&lt;/a&gt;. This model is based soley on attention mechanisms and introduces Multi-Head Attention. The encoder and decoder are made of multiple layers, with each layer consisting of Multi-Head Attention and Positionwise Feedforward sublayers. This model is currently used in many state-of-the-art sequence-to-sequence and transfer learning tasks.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;p&gt;Here are some things I looked at while making these tutorials. Some of it may be out of date.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/spro/practical-pytorch&#34;&gt;https://github.com/spro/practical-pytorch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/keon/seq2seq&#34;&gt;https://github.com/keon/seq2seq&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pengshuang/CNN-Seq2Seq&#34;&gt;https://github.com/pengshuang/CNN-Seq2Seq&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pytorch/fairseq&#34;&gt;https://github.com/pytorch/fairseq&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jadore801120/attention-is-all-you-need-pytorch&#34;&gt;https://github.com/jadore801120/attention-is-all-you-need-pytorch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nlp.seas.harvard.edu/2018/04/03/attention.html&#34;&gt;http://nlp.seas.harvard.edu/2018/04/03/attention.html&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.analyticsvidhya.com/blog/2019/06/understanding-transformers-nlp-state-of-the-art-models/&#34;&gt;https://www.analyticsvidhya.com/blog/2019/06/understanding-transformers-nlp-state-of-the-art-models/&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>