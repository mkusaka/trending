<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Jupyter Notebook Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-01-19T01:38:33Z</updated>
  <subtitle>Daily Trending of Jupyter Notebook in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>llSourcell/ChatGPT_Trading_Bot</title>
    <updated>2023-01-19T01:38:33Z</updated>
    <id>tag:github.com,2023-01-19:/llSourcell/ChatGPT_Trading_Bot</id>
    <link href="https://github.com/llSourcell/ChatGPT_Trading_Bot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This is the code for the &#34;ChatGPT Trading Bot&#34; Video by Siraj Raval on Youtube&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ChatGPT_Trading_Bot&lt;/h1&gt; &#xA;&lt;p&gt;This is the code for the &#34;ChatGPT Trading Bot&#34; Video by Siraj Raval on Youtube&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This is the code for this video on Youtube by Siraj Raval on building a ChatGPT trading bot. First, a disclaimer - Do NOT invest any money in any type of trading bot or algorithmic engine that you are not willing to lose. I gave this trading bot $2000 because I was willing to lose $2000 to make a great video for my AI Wizards out there. The entire codebase is contained in a single iPython notebook file, first published by the FinRL team as an example. Inside the notebook, 5 steps are performed.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Pull 30 days of trading data for (Insert your stock or crypto) with Yahoo Finance Downloader API&lt;/li&gt; &#xA; &lt;li&gt;Create a simulated trading environment using real trading data with FinRL&lt;/li&gt; &#xA; &lt;li&gt;Train an neural network to predict that Stock Price using reinforcement learning inside this simulation with FinRL&lt;/li&gt; &#xA; &lt;li&gt;Once trained, backtest the predictions on the past 30 days data to compute potential returns with FinRL&lt;/li&gt; &#xA; &lt;li&gt;If the expectd returns are above a certain threshold, buy, else hold. If they&#39;re below a certain threshold, sell. (using Alpaca API)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In order to have this Colab run automatically once a day, we can deploy it to a hosting platform like Vercel with a seperate file that repeatedly executes it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.ibb.co/4KJx9y0/Screen-Shot-2023-01-13-at-10-04-39-AM.png&#34; alt=&#34;alt text&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.python.org/downloads/&#34;&gt;Python 3.7&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://alpaca.markets/&#34;&gt;Alpaca SDK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/AI4Finance-Foundation/FinRL&#34;&gt;FinRL&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://vercel.com&#34;&gt;Vercel&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/llSourcell/firebase_react_startup_template&#34;&gt;Firebase Template&lt;/a&gt; &lt;em&gt;optional&lt;/em&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup Instructions&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the iPython notebook in this repository and upload it to &lt;a href=&#34;https://raw.githubusercontent.com/llSourcell/ChatGPT_Trading_Bot/main/colab.research.google.com&#34;&gt;Colab&lt;/a&gt; to try it out.&lt;/li&gt; &#xA; &lt;li&gt;Setup a simple &lt;a href=&#34;https://flask.palletsprojects.com/en/1.1.x/quickstart/&#34;&gt;flask&lt;/a&gt; app.&lt;/li&gt; &#xA; &lt;li&gt;To set up a cron job for a Flask app deployed on Vercel that executes a Google Colab notebook at a given link every hour, you can use the built-in Vercel cron feature. Here are the steps to follow:&lt;/li&gt; &#xA; &lt;li&gt;In your Flask app, import the necessary modules to run the Colab notebook, such as gdown or pyngrok&lt;/li&gt; &#xA; &lt;li&gt;Create a new endpoint in your Flask app that triggers the execution of the Colab notebook, using the link to the notebook file.&lt;/li&gt; &#xA; &lt;li&gt;Go to the Vercel project settings for your app and navigate to the &#34;Cron&#34; tab.&lt;/li&gt; &#xA; &lt;li&gt;Create a new cron job that runs every hour by adding the endpoint you created in step 2 to the &#34;Cron Job&#34; field and select the frequency you want to run the job.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Here is a sample code snippet for step 2:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#xA;from flask import Flask, jsonify&#xA;import gdown&#xA;app = Flask(__name__)&#xA;&#xA;@app.route(&#39;/run-colab&#39;)&#xA;def run_colab():&#xA;    gdown.download(&#39;https://drive.google.com/file/d/&amp;lt;colab_notebook_id&amp;gt;&#39;, &#39;colab.ipynb&#39;, quiet=False)&#xA;    return jsonify(message=&#39;colab notebook ran successfully&#39;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Credits &amp;amp; More Resources&lt;/h2&gt; &#xA;&lt;p&gt;Credits for the notebook go to the AI4FinanceFoundation, and for the API go to Alpaca.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cksystemsteaching/selfie</title>
    <updated>2023-01-19T01:38:33Z</updated>
    <id>tag:github.com,2023-01-19:/cksystemsteaching/selfie</id>
    <link href="https://github.com/cksystemsteaching/selfie" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An educational software system of a tiny self-compiling C compiler, a tiny self-executing RISC-V emulator, and a tiny self-hosting RISC-V hypervisor.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Selfie &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/actions&#34;&gt;&lt;img src=&#34;https://github.com/cksystemsteaching/selfie/actions/workflows/selfie.yml/badge.svg?sanitize=true&#34; alt=&#34;selfie&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://replit.com/new/github/cksystemsteaching/selfie&#34;&gt;&lt;img src=&#34;https://replit.com/badge/github/cksystemsteaching/selfie&#34; alt=&#34;Run on Repl.it&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Selfie is a project of the &lt;a href=&#34;http://www.cs.uni-salzburg.at/~ck&#34;&gt;Computational Systems Group&lt;/a&gt; at the Department of Computer Sciences of the University of Salzburg in Austria.&lt;/p&gt; &#xA;&lt;p&gt;The Selfie Project provides an educational platform for teaching undergraduate and graduate students the design and implementation of programming languages and runtime systems. The focus is on the construction of compilers, libraries, operating systems, and virtual machine monitors. The common theme is to identify and resolve self-reference in systems code which is seen as the key challenge when teaching systems engineering, hence the name.&lt;/p&gt; &#xA;&lt;p&gt;Selfie is a self-contained 64-bit, 12-KLOC C implementation of:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;a self-compiling compiler called starc that compiles a tiny but still fast &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/semantics.md&#34;&gt;subset of C&lt;/a&gt; called C Star (&lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/grammar.md&#34;&gt;C*&lt;/a&gt;) to a tiny and easy-to-teach subset of RISC-V called &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/riscu.md&#34;&gt;RISC-U&lt;/a&gt;,&lt;/li&gt; &#xA; &lt;li&gt;a self-executing emulator called mipster that executes RISC-U code including itself when compiled with starc,&lt;/li&gt; &#xA; &lt;li&gt;a self-hosting hypervisor called hypster that provides RISC-U virtual machines that can host all of selfie, that is, starc, mipster, and hypster itself, and&lt;/li&gt; &#xA; &lt;li&gt;a tiny C* library called libcstar utilized by selfie.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Selfie is implemented in a single (!) file and kept minimal for simplicity. There is also a simple in-memory linker, a RISC-U disassembler, a garbage collector, L1 instruction and data caches, a profiler, and a debugger with replay as well as minimal operating system support in the form of RISC-V system calls built into the emulator and hypervisor. The garbage collector is conservative and even self-collecting. It may operate as library in the same address space as the mutator and/or as part of the emulator in the address space of the kernel.&lt;/p&gt; &#xA;&lt;p&gt;Selfie generates ELF binaries that run on real &lt;a href=&#34;https://www.sifive.com/boards&#34;&gt;RISC-V hardware&lt;/a&gt; as well as on &lt;a href=&#34;https://www.qemu.org&#34;&gt;QEMU&lt;/a&gt; and are compatible with the official &lt;a href=&#34;https://riscv.org&#34;&gt;RISC-V&lt;/a&gt; toolchain, in particular the &lt;a href=&#34;https://github.com/riscv/riscv-isa-sim&#34;&gt;spike emulator&lt;/a&gt; and the &lt;a href=&#34;https://github.com/riscv/riscv-pk&#34;&gt;pk kernel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Selfie is designed as 64-bit system and requires as such a 64-bit system to run (LP64 data model). However, selfie also compiles on systems that support compiling and executing 32-bit binaries (ILP32 data model). In that case, selfie becomes a 32-bit system that generates and executes 32-bit binaries out-of-the-box. This is possible because the implementation of selfie carefully avoids 32-bit overflows throughout the system.&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Slack: Join the conversation in the #selfie channel at &lt;a href=&#34;https://join.slack.com/t/cksystemsteaching/shared_invite/zt-cp3kb9uq-ACUnAuI8DBdmULQXIjW15A&#34;&gt;cksystemsteaching.slack.com&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Slides: There are classroom &lt;a href=&#34;http://selfie.cs.uni-salzburg.at/slides&#34;&gt;slides&lt;/a&gt; that provide a comprehensive introduction to the design and implementation of selfie.&lt;/li&gt; &#xA; &lt;li&gt;Autograder: There is an &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/grader/README.md&#34;&gt;autograder&lt;/a&gt; with compiler and operating systems assignments.&lt;/li&gt; &#xA; &lt;li&gt;Paper: There is an &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3133850.3133857&#34;&gt;Onward! 2017 paper&lt;/a&gt; featuring selfie.&lt;/li&gt; &#xA; &lt;li&gt;Book: There is a free book in early draft form based on selfie called &lt;a href=&#34;https://github.com/ckirsch/book&#34;&gt;Elementary Computer Science: From Bits and Bytes to the Big Picture&lt;/a&gt; reaching out to everyone with an interest in learning about computer science.&lt;/li&gt; &#xA; &lt;li&gt;Code: The selfie code is open source and available at &lt;a href=&#34;https://github.com/cksystemsteaching/selfie&#34;&gt;github.com/cksystemsteaching/selfie&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Twitter: Follow us at &lt;a href=&#34;https://twitter.com/christophkirsch&#34;&gt;twitter.com/christophkirsch&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Web: The selfie homepage is at &lt;a href=&#34;http://selfie.cs.uni-salzburg.at&#34;&gt;selfie.cs.uni-salzburg.at&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Extras&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Garbage collection: In addition to the conservative but O(n^2) garbage collector in selfie, there is an implementation of an O(n) &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/tools/boehm-gc.c&#34;&gt;Boehm&lt;/a&gt; garbage collector for small memory blocks with fall-back to the garbage collector in selfie for large memory blocks.&lt;/li&gt; &#xA; &lt;li&gt;Fuzzing: There is a simple but self-fuzzing fuzzer called &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/tools/buzzr.c&#34;&gt;buzzr&lt;/a&gt; based on selfie that fuzzes RISC-U code including all of selfie and itself.&lt;/li&gt; &#xA; &lt;li&gt;Symbolic execution: There is a self-executing symbolic execution engine called &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/tools/monster.c&#34;&gt;monster&lt;/a&gt; based on selfie that translates RISC-U code including all of selfie and itself to SMT-LIB formulae that are satisfiable if and only if there is input to the code such that the code exits with non-zero exit codes or performs division by zero within a given number of machine instructions.&lt;/li&gt; &#xA; &lt;li&gt;Bounded model checking: There is a self-translating modeling engine called &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/tools/beator.c&#34;&gt;BEATOR&lt;/a&gt; based on selfie that translates RISC-U code including all of selfie and itself to BTOR2 formulae that are satisfiable if and only if there is input to the code such that the code exits with non-zero exit codes, performs division by zero, or accesses memory outside of allocated memory blocks.&lt;/li&gt; &#xA; &lt;li&gt;BTOR2 visualization: There is a visualization tool called &lt;a href=&#34;https://github.com/cksystemsgroup/beator-visualizer&#34;&gt;beatle&lt;/a&gt; that displays BTOR2 formulae generated from RISC-U binaries as directed acyclic graphs.&lt;/li&gt; &#xA; &lt;li&gt;SAT solving: There is a bruteforce SAT solver called &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/main/tools/babysat.c&#34;&gt;babysat&lt;/a&gt; based on selfie that computes satisfiability of SAT formulae in DIMACS CNF.&lt;/li&gt; &#xA; &lt;li&gt;Binary translation: There is a self-translating &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/raw/riscv-2-x86-unsupported/tools/riscv-2-x86.c&#34;&gt;binary translator&lt;/a&gt; based on selfie that translates RISC-U code including all of selfie and itself to x86 binary code.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installing Selfie&lt;/h2&gt; &#xA;&lt;p&gt;Selfie runs in the cloud and natively on Linux, macOS, and Windows machines and possibly other systems that have a terminal and a C compiler installed. However, even if there is no C compiler installed on your machine or you only have access to a web browser you can still run selfie.&lt;/p&gt; &#xA;&lt;p&gt;There are at least three ways to install and run selfie, from real simple to a bit more difficult:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;In the cloud: if you only have access to a web browser, just click &lt;a href=&#34;https://replit.com/new/github/cksystemsteaching/selfie&#34;&gt;here&lt;/a&gt;. Alternatively, create a &lt;a href=&#34;https://github.com&#34;&gt;github&lt;/a&gt; account, unless you already have one, and fork &lt;a href=&#34;https://github.com/cksystemsteaching/selfie&#34;&gt;selfie&lt;/a&gt; into your github account. Then, create a &lt;a href=&#34;https://c9.io&#34;&gt;cloud9&lt;/a&gt; student account, connect it to your github account, verify your email address and set a password (important!), and finally clone your fork of selfie into a new cloud9 workspace.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In docker on your machine: if you have access to a Linux, macOS, or Windows machine download and install &lt;a href=&#34;https://docker.com&#34;&gt;docker&lt;/a&gt;. Then, open a terminal window and type &lt;code&gt;docker run -it cksystemsteaching/selfie&lt;/code&gt;. Besides simplicity, the key advantage of using docker is that you can run selfie out of the box on your machine but also on QEMU as well as on spike. Both emulators and the SMT solver boolector are pre-installed in the &lt;a href=&#34;https://hub.docker.com/r/cksystemsteaching/selfie&#34;&gt;selfie docker image&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Natively on your machine: instead of using docker, you may also just download and unzip &lt;a href=&#34;https://github.com/cksystemsteaching/selfie/archive/main.zip&#34;&gt;selfie&lt;/a&gt;, and then open a terminal window to run selfie natively on your machine. However, for this to work you need to have a C compiler installed on your machine. We recommend using &lt;a href=&#34;https://clang.llvm.org&#34;&gt;clang&lt;/a&gt; or &lt;a href=&#34;https://gcc.gnu.org&#34;&gt;gcc&lt;/a&gt; (with &lt;a href=&#34;https://www.cygwin.com&#34;&gt;cygwin&lt;/a&gt; on Windows).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;At this point we assume that you have a system that supports running selfie. Below we use the &lt;code&gt;make&lt;/code&gt; command assuming it is installed on your system which is usually the case. However, we also show the command invoked by &lt;code&gt;make&lt;/code&gt; so that you can always invoke that command manually if your system does not have &lt;code&gt;make&lt;/code&gt; installed.&lt;/p&gt; &#xA;&lt;p&gt;The next step is to produce a selfie binary. To do that &lt;code&gt;cd&lt;/code&gt; to the selfie folder in your terminal and then type &lt;code&gt;make&lt;/code&gt;. With docker, the system will respond &lt;code&gt;make: &#39;selfie&#39; is up to date&lt;/code&gt; since there is already a selfie binary pre-installed. Without docker, &lt;code&gt;make&lt;/code&gt; will invoke the C compiler on your machine or in the cloud9 workspace:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cc -Wall -Wextra -O3 -D&#39;uint64_t=unsigned long&#39; selfie.c -o selfie&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then compile &lt;code&gt;selfie.c&lt;/code&gt; into an executable called &lt;code&gt;selfie&lt;/code&gt; as directed by the &lt;code&gt;-o&lt;/code&gt; option. The executable contains the C* compiler, the mipster emulator, and the hypster hypervisor. The &lt;code&gt;-Wall&lt;/code&gt; and &lt;code&gt;-Wextra&lt;/code&gt; options enable all compiler warnings which is useful during further development of selfie. The &lt;code&gt;-O3&lt;/code&gt; option instructs the compiler to generate optimized code. The &lt;code&gt;-D&#39;uint64_t=unsigned long&#39;&lt;/code&gt; option is needed to bootstrap the code. It defines the data type &lt;code&gt;uint64_t&lt;/code&gt; which would otherwise be undefined since C* does not include the necessary definitions. If your system supports compiling and executing 32-bit binaries you may also try &lt;code&gt;make selfie-32&lt;/code&gt; which will produce a 32-bit system that in turn generates and executes 32-bit binaries.&lt;/p&gt; &#xA;&lt;h2&gt;Running Selfie&lt;/h2&gt; &#xA;&lt;p&gt;Once you have successfully compiled &lt;code&gt;selfie.c&lt;/code&gt; you may invoke &lt;code&gt;selfie&lt;/code&gt; without any arguments as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie&#xA;./selfie { -c { source } | -o binary | [ -s | -S ] assembly | -l binary } [ ( -m | -d | -r | -y ) 0-4096 ... ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this case, &lt;code&gt;selfie&lt;/code&gt; responds with its usage pattern.&lt;/p&gt; &#xA;&lt;p&gt;The order in which the options are provided matters for taking full advantage of self-referentiality.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;-c&lt;/code&gt; option invokes the C* compiler on the given list of &lt;code&gt;source&lt;/code&gt; files compiling and linking them into RISC-U code that is stored internally. For example, &lt;code&gt;selfie&lt;/code&gt; may be used to compile its own source code &lt;code&gt;selfie.c&lt;/code&gt; as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-o&lt;/code&gt; option writes RISC-U code produced by the most recent compiler invocation to the given &lt;code&gt;binary&lt;/code&gt; file. For example, &lt;code&gt;selfie&lt;/code&gt; may be instructed to compile itself and then output the generated RISC-U code into a RISC-U binary file called &lt;code&gt;selfie.m&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -o selfie.m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-s&lt;/code&gt; option writes RISC-U assembly of the RISC-U code produced by the most recent compiler invocation to the given &lt;code&gt;assembly&lt;/code&gt; file while the &lt;code&gt;-S&lt;/code&gt; option additionally includes approximate line numbers and the binary representation of the instructions. Similarly as before, &lt;code&gt;selfie&lt;/code&gt; may be instructed to compile itself and then output the generated RISC-U code into a RISC-U assembly file called &lt;code&gt;selfie.s&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -s selfie.s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-l&lt;/code&gt; option loads RISC-U code from the given &lt;code&gt;binary&lt;/code&gt; file. The &lt;code&gt;-o&lt;/code&gt; and &lt;code&gt;-s&lt;/code&gt; options can also be used after the &lt;code&gt;-l&lt;/code&gt; option. However, in this case the &lt;code&gt;-s&lt;/code&gt; option does not generate approximate source line numbers. For example, the previously generated RISC-U binary file &lt;code&gt;selfie.m&lt;/code&gt; may be loaded as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -l selfie.m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-m&lt;/code&gt; option invokes the mipster emulator to execute RISC-U code most recently loaded or produced by a compiler invocation. The emulator creates a machine instance with &lt;code&gt;0-4096&lt;/code&gt; MB of memory. The &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;binary&lt;/code&gt; name of the RISC-U code and any remaining &lt;code&gt;...&lt;/code&gt; arguments are passed to the main function of the code. For example, the following invocation executes &lt;code&gt;selfie.m&lt;/code&gt; using mipster:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -l selfie.m -m 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This is in fact semantically equivalent to executing &lt;code&gt;selfie&lt;/code&gt; without any arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;-d&lt;/code&gt; option is similar to the &lt;code&gt;-m&lt;/code&gt; option except that mipster outputs each executed instruction, its approximate source line number, if available, and the relevant machine state. Alternatively, the &lt;code&gt;-r&lt;/code&gt; option limits the amount of output created with the &lt;code&gt;-d&lt;/code&gt; option by having mipster merely replay code execution when runtime errors such as division by zero occur. In this case, mipster outputs only the instructions that were executed right before the error occurred.&lt;/p&gt; &#xA;&lt;p&gt;If you are using docker you can also execute &lt;code&gt;selfie.m&lt;/code&gt; directly on spike and pk as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ spike pk selfie.m&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is again semantically equivalent to executing &lt;code&gt;selfie&lt;/code&gt; without any arguments.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;-y&lt;/code&gt; option invokes the hypster hypervisor to execute RISC-U code similar to the mipster emulator. The difference to mipster is that hypster creates RISC-U virtual machines rather than a RISC-U emulator to execute the code. See below for an example.&lt;/p&gt; &#xA;&lt;h3&gt;Self-compilation&lt;/h3&gt; &#xA;&lt;p&gt;Here is an example of how to perform self-compilation of &lt;code&gt;selfie.c&lt;/code&gt; and then check if the RISC-U code &lt;code&gt;selfie1.m&lt;/code&gt; generated for &lt;code&gt;selfie.c&lt;/code&gt; by executing the &lt;code&gt;./selfie&lt;/code&gt; binary is equivalent to the code &lt;code&gt;selfie2.m&lt;/code&gt; generated by executing the just generated &lt;code&gt;selfie1.m&lt;/code&gt; binary:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -o selfie1.m -m 2 -c selfie.c -o selfie2.m&#xA;$ diff -s selfie1.m selfie2.m&#xA;Files selfie1.m and selfie2.m are identical&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that at least 2MB of memory is required for this to work.&lt;/p&gt; &#xA;&lt;h3&gt;Self-execution&lt;/h3&gt; &#xA;&lt;p&gt;The following example shows how to perform self-execution of the mipster emulator. In this case we invoke mipster to invoke itself to execute &lt;code&gt;selfie&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -o selfie.m -m 2 -l selfie.m -m 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which is again semantically equivalent to executing &lt;code&gt;selfie&lt;/code&gt; without any arguments but this time with &lt;code&gt;selfie&lt;/code&gt; printing its usage pattern much slower since there is a mipster running on top of another mipster.&lt;/p&gt; &#xA;&lt;h3&gt;Self-hosting&lt;/h3&gt; &#xA;&lt;p&gt;The previous example can also be done by running hypster on mipster. This is significantly faster and requires less memory since hypster does not create a second emulator instance on top of the first emulator instance. Instead, hypster creates a virtual machine to execute selfie that runs concurrently to hypster on the first emulator instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -o selfie.m -m 1 -l selfie.m -y 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We may even run hypster on hypster on mipster which is still reasonably fast since there is still only one emulator instance involved and hypster itself does not add much overhead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -o selfie.m -m 2 -l selfie.m -y 1 -l selfie.m -y 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Workflow&lt;/h3&gt; &#xA;&lt;p&gt;To compile any C* source code and execute it right away in a single invocation of &lt;code&gt;selfie&lt;/code&gt; without generating a RISC-U binary use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c any-cstar-file.c -m 1 &#34;arguments for any-cstar-file.c&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Equivalently, you may also use a selfie-compiled version of &lt;code&gt;selfie&lt;/code&gt; and have the mipster emulator execute selfie to compile any C* source code and then execute it right away with hypster on the same emulator instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -m 1 -c any-cstar-file.c -y 1 &#34;arguments for any-cstar-file.c&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also generate RISC-U binaries both ways which will then be identical:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c any-cstar-file.c -o any-cstar-file1.m&#xA;$ ./selfie -c selfie.c -m 1 -c any-cstar-file.c -o any-cstar-file2.m&#xA;$ diff -s any-cstar-file1.m any-cstar-file2.m&#xA;Files any-cstar-file1.m and any-cstar-file2.m are identical&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This can also be done in a single invocation of &lt;code&gt;selfie&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c any-cstar-file.c -o any-cstar-file1.m -c selfie.c -m 1 -c any-cstar-file.c -o any-cstar-file2.m&#xA;$ diff -s any-cstar-file1.m any-cstar-file2.m&#xA;Files any-cstar-file1.m and any-cstar-file2.m are identical&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The generated RISC-U binaries can then be loaded and executed as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -l any-cstar-file1.m -m 1 &#34;arguments for any-cstar-file1.m&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Linking&lt;/h4&gt; &#xA;&lt;p&gt;To compile and link any C* source code from multiple source files use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c any-cstar-file1.c any-cstar-file2.c ... -m 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, to make the source code of &lt;code&gt;selfie.c&lt;/code&gt; available as library code in any C* source code use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c any-cstar-file.c selfie.c -m 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that multiple definitions of symbols are ignored by the compiler with a warning.&lt;/p&gt; &#xA;&lt;h4&gt;Debugging&lt;/h4&gt; &#xA;&lt;p&gt;Selfie&#39;s console messages always begin with the name of the source or binary file currently running. The mipster emulator also shows the amount of memory allocated for its machine instance and how execution terminated (exit code).&lt;/p&gt; &#xA;&lt;p&gt;As discussed before, RISC-U assembly for &lt;code&gt;selfie&lt;/code&gt; and any other C* file is generated as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -s selfie.s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the assembly code is generated from a binary generated by the compiler (and not loaded from a file) approximate source line numbers are included in the assembly file.&lt;/p&gt; &#xA;&lt;p&gt;Verbose debugging information is printed with the &lt;code&gt;-d&lt;/code&gt; option, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./selfie -c selfie.c -d 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, if the executed binary is generated by the compiler (and not loaded from a file) approximate source line numbers are included in the debug information.&lt;/p&gt;</summary>
  </entry>
</feed>