<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Jupyter Notebook Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-07-02T01:31:33Z</updated>
  <subtitle>Daily Trending of Jupyter Notebook in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Classiq/classiq-library</title>
    <updated>2024-07-02T01:31:33Z</updated>
    <id>tag:github.com,2024-07-02:/Classiq/classiq-library</id>
    <link href="https://github.com/Classiq/classiq-library" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Classiq Library is the largest collection of quantum algorithms, applications. It is the best way to explore quantum computing software. We welcome community contributions to our Library üôå&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://badge.fury.io/py/classiq&#34;&gt;&lt;img src=&#34;https://badge.fury.io/py/classiq.svg?sanitize=true&#34; alt=&#34;Version&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/pypi/pyversions/classiq&#34; alt=&#34;PyPI - Python Version&#34;&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/README_resources/classiq-logo.svg?sanitize=true&#34; width=&#34;300&#34; height=&#34;150&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;h1&gt;Classiq&lt;/h1&gt; &#xA;&lt;p&gt;Your entry-point for creating &amp;amp; running quantum programs.&lt;/p&gt; &#xA;&lt;p&gt;This repository holds a wide collection of quantum functions, algorithms, applications and tutorials built with Classiq.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; ‚ÄÉ &lt;a href=&#34;https://platform.classiq.io/&#34;&gt;‚öõÔ∏è Platform&lt;/a&gt; ‚ÄÉ|‚ÄÉ &lt;a href=&#34;https://short.classiq.io/join-slack&#34;&gt;üëã Join Slack&lt;/a&gt; ‚ÄÉ|‚ÄÉ &lt;a href=&#34;https://docs.classiq.io/latest/&#34;&gt;üìñ Documentation&lt;/a&gt; ‚ÄÉ | ‚ÄÉ &lt;a href=&#34;https://docs.classiq.io/latest/&#34;&gt;Getting Started&lt;/a&gt; ‚ÄÉ &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Working with Classiq&#39;s latest GUI requires no installations! Just head over to &lt;a href=&#34;https://platform.classiq.io/&#34;&gt;Classiq&#39;s platform&lt;/a&gt; and follow the examples below over there :)&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d rather work programmatically, using Python, Classiq also provides an SDK, which can be installed as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install classiq&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please note that the latest Classiq SDK for Python doesn&#39;t work in Python 3.12 yet. Please refer to &lt;a href=&#34;https://github.com/Classiq/classiq-library/issues/17&#34;&gt;Issue #17&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Running This Repository&#39;s Demos&lt;/h2&gt; &#xA;&lt;p&gt;This repository has 2 kinds of demos: &lt;code&gt;.qmod&lt;/code&gt; and &lt;code&gt;.ipynb&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;.qmod&lt;/code&gt; files are intended for usage with &lt;a href=&#34;https://platform.classiq.io/&#34;&gt;Classiq&#39;s platform&lt;/a&gt;. Upload those &lt;code&gt;.qmod&lt;/code&gt; files into the &lt;a href=&#34;https://platform.classiq.io/synthesis&#34;&gt;Synthesis tab&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;.ipynb&lt;/code&gt; files are intended to be viewed inside &lt;a href=&#34;https://jupyter.org/&#34;&gt;JupyterLab&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Create Quantum Programs with Classiq&lt;/h1&gt; &#xA;&lt;p&gt;The simplest quantum circuit has 1 qubit, and has a single &lt;code&gt;X&lt;/code&gt; gate.&lt;/p&gt; &#xA;&lt;p&gt;Using Classiq&#39;s SDK, it would like like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from classiq import *&#xA;&#xA;NUM_QUBITS = 1&#xA;&#xA;&#xA;@qfunc&#xA;def main(res: Output[QBit]):&#xA;    allocate(NUM_QUBITS, res)&#xA;    X(res)&#xA;&#xA;&#xA;model = create_model(main)&#xA;quantum_program = synthesize(model)&#xA;&#xA;show(quantum_program)&#xA;&#xA;result = execute(quantum_program).result()&#xA;print(result[0].value.parsed_counts)&#xA;# [{&#39;res&#39;: 1.0}: 1000]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s unravel the code above:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;def main&lt;/code&gt; : We define the logic of our quantum program. We&#39;ll expand on this point soon below.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;create_model&lt;/code&gt; : We convert the logic we defined into a Model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;synthesize&lt;/code&gt; : We synthesize the Model into a Quantum Program. From a logical definition of quantum operations, into a series of quantum gates.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;execute&lt;/code&gt; : Executing the quantum program. Can be executed on a physical quantum computer, or on simulations.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;1) Defining the Logic of Quantum Programs&lt;/h2&gt; &#xA;&lt;p&gt;The function above had 4 lines:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qfunc&#xA;def main(res: Output[QBit]):&#xA;    allocate(NUM_QUBITS, res)&#xA;    X(res)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The 1st line states that the function will be a quantum one. &lt;a href=&#34;https://docs.classiq.io/latest/reference-manual/platform/qmod/language-reference/functions/&#34;&gt;Further documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The 2nd line defines the type of the output. &lt;a href=&#34;https://docs.classiq.io/latest/reference-manual/platform/qmod/language-reference/classical-types/&#34;&gt;Further examples on types&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The 3rd line allocates several qubits (in this example, only 1) in this quantum variable. &lt;a href=&#34;https://docs.classiq.io/latest/reference-manual/platform/qmod/language-reference/quantum-variables/&#34;&gt;Further details on allocate&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The 4th line applies an &lt;code&gt;X&lt;/code&gt; operator on the quantum variable. &lt;a href=&#34;https://docs.classiq.io/latest/reference-manual/platform/qmod/language-reference/operators/&#34;&gt;Further details on quantum operators&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;More Examples&lt;/h3&gt; &#xA;&lt;p&gt;Initializing $\ket{-}$ state:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qfunc&#xA;def prep_minus(out: Output[QBit]) -&amp;gt; None:&#xA;    allocate(1, out)&#xA;    X(out)&#xA;    H(out)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A part of the Deutsch Jozsa algorithm (see the full algorithm &lt;a href=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/algorithms/deutsch_josza/deutsch_jozsa.ipynb&#34;&gt;here&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qfunc&#xA;def deutsch_jozsa(predicate: QCallable[QNum, QBit], x: QNum) -&amp;gt; None:&#xA;    hadamard_transform(x)&#xA;    my_oracle(predicate=lambda x, y: predicate(x, y), target=x)&#xA;    hadamard_transform(x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A part of a QML encoder (see the full algorithm &lt;a href=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/algorithms/qml/quantum_autoencoder/quantum_autoencoder.ipynb&#34;&gt;here&lt;/a&gt;)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@qfunc&#xA;def angle_encoding(exe_params: CArray[CReal], qbv: Output[QArray[QBit]]) -&amp;gt; None:&#xA;    allocate(exe_params.len, qbv)&#xA;    repeat(&#xA;        count=exe_params.len,&#xA;        iteration=lambda index: RY(pi * exe_params[index], qbv[index]),&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more, see this repository :)&lt;/p&gt; &#xA;&lt;h2&gt;2) Logic to Models&lt;/h2&gt; &#xA;&lt;p&gt;As we saw above, the &lt;code&gt;main&lt;/code&gt; function can be converted to a model using &lt;code&gt;model = create_model(main)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A model is built out of 2 parts: a &lt;code&gt;qmod&lt;/code&gt;, and &lt;code&gt;synthesis options&lt;/code&gt;. The former is a quantum language used for defining quantum programs, while the latter is a configuration for the execution of the program.&lt;/p&gt; &#xA;&lt;p&gt;The model can be saved via &lt;code&gt;write_qmod(model, &#34;file_name&#34;)&lt;/code&gt;, which will save 2 files: &lt;code&gt;file_name.qmod&lt;/code&gt; and &lt;code&gt;file_name.synthesis_options.json&lt;/code&gt;. You may encounter these files in this repository.&lt;/p&gt; &#xA;&lt;h2&gt;3) Synthesis : Models to Quantum Program&lt;/h2&gt; &#xA;&lt;p&gt;This is where the magic happens. Taking a model, which is a set of logical operations, and synthesizing it into physical qubits and the gates entangling them, is not an easy task.&lt;/p&gt; &#xA;&lt;p&gt;Classiq&#39;s synthesis engine is able to optimize this process, whether by requiring the minimal amount of physical qubits, thus reusing as many qubits as possible, or by requiring minimal circuit width, thus lowering execution time and possible errors.&lt;/p&gt; &#xA;&lt;h2&gt;4) Execution&lt;/h2&gt; &#xA;&lt;p&gt;Classiq provides an easy-to-use way to execute quantum programs, and provides various insights of the execution results.&lt;/p&gt; &#xA;&lt;h2&gt;Diagrams&lt;/h2&gt; &#xA;&lt;p&gt;1 diagram is worth a thousand words&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;flowchart&#xA;    IDEInput[&amp;lt;a href=&#39;https://platform.classiq.io/&#39;&amp;gt;Classiq IDE&amp;lt;/a&amp;gt;]&#xA;&#xA;    SDKInput[&amp;lt;a href=&#39;https://docs.classiq.io/latest/reference-manual/python-sdk/&#39;&amp;gt;Classiq python SDK&amp;lt;/a&amp;gt;]&#xA;&#xA;    Model[&amp;lt;a href=&#39;https://docs.classiq.io/latest/reference-manual/platform/qmod/&#39;&amp;gt;Quantum Model&amp;lt;/a&amp;gt;]&#xA;&#xA;    Synthesis[&amp;lt;a href=&#39;https://docs.classiq.io/latest/classiq_101/classiq_concepts/optimize/&#39;&amp;gt;Synthesis Engine&amp;lt;/a&amp;gt;]&#xA;&#xA;    QuantumProgram[Quantum Program]&#xA;&#xA;    Execution[&amp;lt;a href=&#39;https://docs.classiq.io/latest/classiq_101/classiq_concepts/execute/&#39;&amp;gt;Execution&amp;lt;/a&amp;gt;]&#xA;&#xA;    Analyze[&amp;lt;a href=&#39;https://docs.classiq.io/latest/classiq_101/classiq_concepts/analyze/&#39;&amp;gt;Analyze &amp;amp; Debug&amp;lt;/a&amp;gt;]&#xA;&#xA;    IBM[IBM]&#xA;    Amazon[Amazon Braket]&#xA;    Azure[Azure Quantum]&#xA;    Nvidia[Nvidia]&#xA;&#xA;&#xA;    IDEInput --&amp;gt; Model;&#xA;    SDKInput --&amp;gt; Model;&#xA;    Model --&amp;gt; Synthesis;&#xA;    Synthesis --&amp;gt; QuantumProgram;&#xA;    ExternalProgram &amp;lt;--&amp;gt; QuantumProgram;&#xA;    QuantumProgram --&amp;gt; Analyze;&#xA;    QuantumProgram --&amp;gt; Execution;&#xA;    Execution --&amp;gt; IBM&#xA;    Execution --&amp;gt; Amazon&#xA;    Execution --&amp;gt; Azure&#xA;    Execution --&amp;gt; Nvidia&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Build Your Own&lt;/h1&gt; &#xA;&lt;p&gt;With Classiq, you can build anything. Classiq provides a powerful modeling language to describe any quantum program, which can then be synthesized and executed on any hardware or simulator. Explore our &lt;a href=&#34;https://docs.classiq.io/latest/&#34;&gt;Documentation&lt;/a&gt; to learn everything.&lt;/p&gt; &#xA;&lt;h2&gt;SDK : Classiq&#39;s Python Interface&lt;/h2&gt; &#xA;&lt;h3&gt;Example: 3+5 with Classiq&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from classiq import (&#xA;    QArray,&#xA;    Output,&#xA;    allocate,&#xA;    qfunc,&#xA;    X,&#xA;    QNum,&#xA;    synthesize,&#xA;    create_model,&#xA;    show,&#xA;    execute,&#xA;)&#xA;&#xA;&#xA;@qfunc&#xA;def get_3(x: Output[QArray]) -&amp;gt; None:&#xA;    allocate(2, x)&#xA;    X(x[0])&#xA;    X(x[1])&#xA;&#xA;&#xA;@qfunc&#xA;def get_5(x: Output[QArray]) -&amp;gt; None:&#xA;    allocate(3, x)&#xA;    X(x[0])&#xA;    X(x[2])&#xA;&#xA;&#xA;@qfunc&#xA;def main(res: Output[QNum]) -&amp;gt; None:&#xA;    a = QNum(&#34;a&#34;)&#xA;    b = QNum(&#34;b&#34;)&#xA;    get_3(a)&#xA;    get_5(b)&#xA;    res |= a + b  # should be 8&#xA;&#xA;&#xA;model = create_model(main)&#xA;quantum_program = synthesize(model)&#xA;&#xA;show(quantum_program)&#xA;&#xA;result = execute(quantum_program).result()&#xA;print(result[0].value.parsed_counts)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;IDE : Classiq&#39;s Platform&lt;/h2&gt; &#xA;&lt;p&gt;The examples found in this repository can be accessed via &lt;a href=&#34;https://platform.classiq.io/&#34;&gt;Classiq&#39;s platform&lt;/a&gt;, in the &lt;a href=&#34;https://platform.classiq.io/dsl-synthesis&#34;&gt;&lt;code&gt;model&lt;/code&gt;&lt;/a&gt; tab, under the same folder structure.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, one may write his own model in the model editor (highlighted in green) or upload his own model (highlighted in red)&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/README_resources/writing_models.png&#34; alt=&#34;writing_models.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Example: 3+5 with Classiq&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Create a model (paste in the &lt;a href=&#34;https://platform.classiq.io/dsl-synthesis&#34;&gt;&lt;code&gt;model&lt;/code&gt;&lt;/a&gt; tab)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;qfunc get_3(output x: qnum){&#xA;allocate&amp;lt;2&amp;gt;(x);&#xA; X(x[0]);&#xA; X(x[1]);&#xA;}&#xA;&#xA;qfunc get_5(output x: qnum){&#xA; allocate&amp;lt;3&amp;gt;(x);&#xA; X(x[0]);&#xA; X(x[2]);&#xA;}&#xA;&#xA;qfunc main(output res: qnum){&#xA; a: qnum;&#xA; b: qnum;&#xA; get_3(a);&#xA; get_5(b);&#xA; res = a + b;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Press Synthesize:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;center&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/README_resources/Model_Screenshot_3_plus_5.png&#34; alt=&#34;Model_Screenshot_3_plus_5.png&#34;&gt;&lt;/p&gt; &#xA;&lt;/center&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Press Execute:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;center&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/README_resources/Program_Screenshot_3_plus_5.png&#34; alt=&#34;Program_Screenshot_3_plus_5.png&#34;&gt;&lt;/p&gt; &#xA;&lt;/center&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Press Run:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;center&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/README_resources/Execution_Screenshot_3_plus_5.png&#34; alt=&#34;Execution_Screenshot_3_plus_5.png&#34;&gt;&lt;/p&gt; &#xA;&lt;/center&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;View Results:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;center&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Classiq/classiq-library/main/README_resources/Jobs_Screenshot_3_plus_5.png&#34; alt=&#34;Jobs_Screenshot_3_plus_5.png&#34;&gt;&lt;/p&gt; &#xA;&lt;/center&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Have questions? Feedback? Something to share? Welcome to join our open &lt;a href=&#34;https://short.classiq.io/join-slack&#34;&gt;Slack Community&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>