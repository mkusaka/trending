<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Jupyter Notebook Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-12-23T01:33:18Z</updated>
  <subtitle>Daily Trending of Jupyter Notebook in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cvg/DeepLSD</title>
    <updated>2022-12-23T01:33:18Z</updated>
    <id>tag:github.com,2022-12-23:/cvg/DeepLSD</id>
    <link href="https://github.com/cvg/DeepLSD" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Implementation of the paper &#34;DeepLSD: Line Segment Detection and Refinement with Deep Image Gradients&#34;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;DeepLSD&lt;/h1&gt; &#xA;&lt;p&gt;Implementation of the paper &lt;a href=&#34;https://arxiv.org/abs/2212.07766&#34;&gt;DeepLSD: Line Segment Detection and Refinement with Deep Image Gradients&lt;/a&gt;. &lt;strong&gt;DeepLSD is a generic line detector that combines the robustness of deep learning with the accuracy of handcrafted detectors&lt;/strong&gt;. It can be used to extract &lt;strong&gt;generic line segments from images in-the-wild&lt;/strong&gt;, and is &lt;strong&gt;suitable for any task requiring high precision&lt;/strong&gt;, such as homography estimation, visual localization, and 3D reconstruction. By predicting a line distance and angle fields, &lt;strong&gt;it can furthermore refine any existing line segments&lt;/strong&gt; through an optimization.&lt;/p&gt; &#xA;&lt;p&gt;Demo of the lines detected by DeepLSD, its line distance field, and line angle field:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cvg/DeepLSD/main/assets/videos/demo_deeplsd.gif&#34; alt=&#34;demo_deeplsd&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;First clone the repository and its submodules:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;git clone --recurse-submodules git@github.com:cvg/DeepLSD.git&#xA;cd DeepLSD&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure that the &lt;a href=&#34;http://ceres-solver.org/&#34;&gt;Ceres&lt;/a&gt; library is installed, then install the necessary requirements and third party libraries:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bash install.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This repo uses a base experiment folder (EXPER_PATH) containing the output of all trainings, and a base dataset path (DATA_PATH) containing all the evaluation and training datasets. You can set the path to these two folders in the file &lt;code&gt;deeplsd/settings.py&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;We provide two pre-trained models for DeepLSD: &lt;a href=&#34;https://www.polybox.ethz.ch/index.php/s/FQWGkH57UNTqlJZ&#34;&gt;deeplsd_wireframe.tar&lt;/a&gt; and &lt;a href=&#34;https://www.polybox.ethz.ch/index.php/s/XVb30sUyuJttFys&#34;&gt;deeplsd_md.tar&lt;/a&gt;, trained respectively on the Wireframe and MegaDepth datasets. The former can be used for easy indoor datasets, while the latter is more generic and works outdoors and on more challenging scenes. The example notebook &lt;code&gt;notebooks/demo_line_detection.ipynb&lt;/code&gt; showcases how to use DeepLSD in practice. Please refer to the comments on the config of this notebook to understand the usage of each hyperparameter.&lt;/p&gt; &#xA;&lt;h2&gt;Ground truth (GT) generation&lt;/h2&gt; &#xA;&lt;p&gt;DeepLSD requires generating a ground truth for line distance and angle field, through homography adaptation. We provide a Python script to do it for any list of images, leveraging CUDA:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.homography_adaptation_df &amp;lt;path to a txt file containing the image paths&amp;gt; &amp;lt;output folder&amp;gt; --num_H &amp;lt;number of homographies (e.g. 100)&amp;gt; --n_jobs &amp;lt;number of parallel jobs&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the GT generation can take a long time, from hours to days depending on the number of images, number of homographies and computation power of your machine. The output folder can then be specified in the training config of the corresponding dataset. For example, after generating the GT for the wireframe dataset in the folder &lt;code&gt;DATA_PATH/export_datasets/wireframe_ha5&lt;/code&gt;, the field &#39;gt_dir&#39; of the config file &lt;code&gt;deeplsd/configs/train_wireframe.yaml&lt;/code&gt; can be updated with the value &lt;code&gt;export_datasets/wireframe_ha5&lt;/code&gt; (paths are given relative to DATA_PATH).&lt;/p&gt; &#xA;&lt;h2&gt;Training&lt;/h2&gt; &#xA;&lt;p&gt;To train the network, simply run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.train &amp;lt;model name&amp;gt; --conf &amp;lt;path to config file&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We provide data loaders for the &lt;a href=&#34;https://github.com/huangkuns/wireframe&#34;&gt;Wireframe dataset&lt;/a&gt; and &lt;a href=&#34;https://www.cs.cornell.edu/projects/megadepth/&#34;&gt;MegaDepth&lt;/a&gt;, using the config files &lt;code&gt;deeplsd/configs/train_wireframe.yaml&lt;/code&gt; and &lt;code&gt;deeplsd/configs/train_minidepth.yaml&lt;/code&gt;, or &lt;code&gt;deeplsd/configs/train_merged_datasets.yaml&lt;/code&gt; to train on both at the same time. Note that due to the sheer size of the MegaDepth dataset, we only sampled 50 images per scene (hence the name &#34;Minidepth&#34;) and used the train/val split available in &lt;code&gt;deeplsd/datasets/utils/&lt;/code&gt;. To train on the wireframe dataset, the command would typically look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.train deeplsd_wireframe --conf deeplsd/configs/train_wireframe.yaml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A model can be restored or fine-tuned by adding the &#39;--restore&#39; option.&lt;/p&gt; &#xA;&lt;h2&gt;Line refinement&lt;/h2&gt; &#xA;&lt;p&gt;The backbone extractor of DeepLSD can also be used to generate a distance and angle field from an image, and to refine existing line segments (from any existsing line detector). This can be done given a folder of images and pre-extracted lines as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.line_refinement &amp;lt;path to the image folder&amp;gt; &amp;lt;path to the line detections&amp;gt; &amp;lt;path to the checkpoint of DeepLSD&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please refer to the help tool of this function for more details on the format of the line detections.&lt;/p&gt; &#xA;&lt;h2&gt;Evaluation&lt;/h2&gt; &#xA;&lt;p&gt;Similarly as in the paper, we provide code for the evaluation of low-level line detection metrics, as well as vanishing point (VP) estimation. In both cases, the lines and VPs need to be extracted with the script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.export_features &amp;lt;config file&amp;gt; &amp;lt;path to the DeepLSD checkpoint&amp;gt; &amp;lt;output_folder&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add the option &#39;--pred_vps&#39; to predict the vanishing points in addition to the line segments.&lt;/p&gt; &#xA;&lt;h3&gt;Low-level line detection metrics&lt;/h3&gt; &#xA;&lt;p&gt;We provide dataloaders for the following datasets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/huangkuns/wireframe&#34;&gt;Wireframe&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/hpatches/hpatches-dataset&#34;&gt;HPatches&lt;/a&gt; (with the full image sequences)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.polybox.ethz.ch/index.php/s/P89YkZyOfdhmdPN&#34;&gt;RDNIM&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.elderlab.yorku.ca/resources/york-urban-line-segment-database-information/&#34;&gt;York Urban DB&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The corresponding config files (to export the features) are located in the &lt;code&gt;deeplsd/configs&lt;/code&gt; folder. For example, exporting line detections on HPatches would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.export_features deeplsd/configs/export_hpatches.yaml weights/deeplsd_md.tar hpatches_outputs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The evaluation can then be run with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.evaluate_line_detection &amp;lt;dataset name (&#39;wireframe&#39;, &#39;hpatches&#39;, &#39;rdnim&#39; or &#39;york_urban&#39;)&amp;gt; &amp;lt;folder containing the pre-extracted line segments&amp;gt; &amp;lt;output folder&amp;gt; &amp;lt;method name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On HPatches, this could look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.evaluate_line_detection hpatches hpatches_outputs hpatches_evaluation deeplsd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;VP estimation metrics&lt;/h3&gt; &#xA;&lt;p&gt;We provide dataloaders for the following datasets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.elderlab.yorku.ca/resources/york-urban-line-segment-database-information/&#34;&gt;York Urban DB&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/fkluger/nyu_vp&#34;&gt;NYU-VP&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;First, the VP needs to be exported. For example, exporting line detections on York Urban would look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.export_features deeplsd/configs/export_york_urban.yaml weights/deeplsd_md.tar yud_outputs --pred_vps&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The evaluation can then be run with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.evaluate_vp_estimation &amp;lt;dataset name (&#39;york_urban&#39; or &#39;nyu&#39;)&amp;gt; &amp;lt;folder containing the pre-extracted VPs&amp;gt; &amp;lt;output folder&amp;gt; &amp;lt;method name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On York Urban, this could look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python -m deeplsd.scripts.evaluate_vp_estimation york_urban yud_outputs yud_evaluation deeplsd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the 3D line reconstruction and visual localization applications of the paper will be released in a separate repository.&lt;/p&gt; &#xA;&lt;h2&gt;Bibtex&lt;/h2&gt; &#xA;&lt;p&gt;If you use this code in your project, please consider citing the following paper:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@InProceedings{Pautrat_2022_DeepLSD,&#xA;    author = {Pautrat, Rémi and Barath, Daniel and Larsson, Viktor and Oswald, Martin R. and Pollefeys, Marc},&#xA;    title = {DeepLSD: Line Segment Detection and Refinement with Deep Image Gradients},&#xA;    booktitle = {arXiv},&#xA;    year = {2022},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>barbagroup/CFDPython</title>
    <updated>2022-12-23T01:33:18Z</updated>
    <id>tag:github.com,2022-12-23:/barbagroup/CFDPython</id>
    <link href="https://github.com/barbagroup/CFDPython" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A sequence of Jupyter notebooks featuring the &#34;12 Steps to Navier-Stokes&#34; http://lorenabarba.com/&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;CFD Python&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Please cite as: Barba, Lorena A., and Forsyth, Gilbert F. (2018). CFD Python: the 12 steps to Navier-Stokes equations. &lt;em&gt;Journal of Open Source Education&lt;/em&gt;, &lt;strong&gt;1&lt;/strong&gt;(9), 21, &lt;a href=&#34;https://doi.org/10.21105/jose.00021&#34;&gt;https://doi.org/10.21105/jose.00021&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://doi.org/10.21105/jose.00021&#34;&gt;&lt;img src=&#34;https://jose.theoj.org/papers/10.21105/jose.00021/status.svg?sanitize=true&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;CFD Python&lt;/strong&gt;, a.k.a. the &lt;strong&gt;12 steps to Navier-Stokes&lt;/strong&gt;, is a practical module for learning the foundations of Computational Fluid Dynamics (CFD) by coding solutions to the basic partial differential equations that describe the physics of fluid flow. The module was part of a course taught by &lt;a href=&#34;http://lorenabarba.com&#34;&gt;Prof. Lorena Barba&lt;/a&gt; between 2009 and 2013 in the Mechanical Engineering department at Boston University (Prof. Barba since moved to the George Washington University).&lt;/p&gt; &#xA;&lt;p&gt;The module assumes only basic programming knowledge (in any language) and some background in partial differential equations and fluid mechanics. The &#34;steps&#34; were inspired by ideas of Dr. Rio Yokota, who was a post-doc in Prof. Barba&#39;s lab until 2011, and the lessons were refined by Prof. Barba and her students over several semesters teaching the CFD course. We wrote this set of Jupyter notebooks in 2013 to teach an intensive two-day course in Mendoza, Argentina.&lt;/p&gt; &#xA;&lt;p&gt;Guiding students through these steps (without skipping any!), they learn many valuable lessons. The incremental nature of the exercises means they get a sense of achievement at the end of each assignment, and they feel they are learning with low effort. As they progress, they naturally practice code re-use and they incrementally learn programming and plotting techniques. As they analyze their results, they learn about numerical diffusion, accuracy and convergence. In about four weeks of a regularly scheduled course, they become moderately proficient programmers and are motivated to start discussing more theoretical matters.&lt;/p&gt; &#xA;&lt;h2&gt;How to use this module&lt;/h2&gt; &#xA;&lt;p&gt;In a regular-session university course, students can complete the &lt;strong&gt;CFD Python&lt;/strong&gt; lessons in 4 to 5 weeks. As an intensive tutorial, the module can be completed in two or three full days, depending on the learner&#39;s prior experience. The lessons can also be used for self study. In all cases, learners should follow along the worked examples in each lesson by re-typing the code in a fresh Jupyter notebook, maybe taking original notes as they try things out.&lt;/p&gt; &#xA;&lt;h2&gt;Lessons&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Launch an interactive session with this module using the Binder service: &lt;a href=&#34;https://mybinder.org/v2/gh/barbagroup/CFDPython/master&#34;&gt;&lt;img src=&#34;https://mybinder.org/badge.svg?sanitize=true&#34; alt=&#34;Binder&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Steps 1–4 are in one spatial dimension. Steps 5–10 are in two dimensions (2D). Steps 11–12 solve the Navier-Stokes equation in 2D. Three &#34;bonus&#34; notebooks cover the CFL condition for numerical stability, array operations with NumPy, and defining functions in Python.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/00_Quick_Python_Intro.ipynb&#34;&gt;Quick Python Intro&lt;/a&gt; —For Python novices, this lesson introduces the numerical libraries (NumPy and Matplotlib), Python variables, use of whitespace, and slicing arrays.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/01_Step_1.ipynb&#34;&gt;Step 1&lt;/a&gt; —Linear convection with a step-function initial condition (IC) and appropriate boundary conditions (BCs).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/02_Step_2.ipynb&#34;&gt;Step 2&lt;/a&gt; —With the same IC/BCs, &lt;em&gt;nonlinear&lt;/em&gt; convection.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/03_CFL_Condition.ipynb&#34;&gt;CFL Condition&lt;/a&gt; —Exploring numerical stability and the Courant-Friedrichs-Lewy (CFL) condition.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/04_Step_3.ipynb&#34;&gt;Step 3&lt;/a&gt; —With the same IC/BCs, &lt;em&gt;diffusion&lt;/em&gt; only.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/05_Step_4.ipynb&#34;&gt;Step 4&lt;/a&gt; —Burgers’ equation, with a saw-tooth IC and periodic BCs (with an introduction to Sympy).&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/06_Array_Operations_with_NumPy.ipynb&#34;&gt;Array Operations with NumPy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/07_Step_5.ipynb&#34;&gt;Step 5&lt;/a&gt; —Linear convection in 2D with a square-function IC and appropriate BCs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/08_Step_6.ipynb&#34;&gt;Step 6&lt;/a&gt; —With the same IC/BCs, &lt;em&gt;nonlinear&lt;/em&gt; convection in 2D.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/09_Step_7.ipynb&#34;&gt;Step 7&lt;/a&gt; —With the same IC/BCs, &lt;em&gt;diffusion&lt;/em&gt; in 2D.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/10_Step_8.ipynb&#34;&gt;Step 8&lt;/a&gt; —Burgers’ equation in 2D&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/11_Defining_Function_in_Python.ipynb&#34;&gt;Defining Functions in Python&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/12_Step_9.ipynb&#34;&gt;Step 9&lt;/a&gt; —Laplace equation with zero IC and both Neumann and Dirichlet BCs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/13_Step_10.ipynb&#34;&gt;Step 10&lt;/a&gt; —Poisson equation in 2D.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/14_Step_11.ipynb&#34;&gt;Step 11&lt;/a&gt; —Solves the Navier-Stokes equation for 2D cavity flow.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/barbagroup/CFDPython/blob/master/lessons/15_Step_12.ipynb&#34;&gt;Step 12&lt;/a&gt; —Solves the Navier-Stokes equation for 2D channel flow.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;To use these lessons, you need Python 3, and the standard stack of scientific Python: NumPy, Matplotlib, SciPy, Sympy. And of course, you need &lt;a href=&#34;http://jupyter.org&#34;&gt;Jupyter&lt;/a&gt;—an interactive computational environment that runs on a web browser.&lt;/p&gt; &#xA;&lt;p&gt;This mini-course is built as a set of &lt;a href=&#34;https://jupyter-notebook.readthedocs.org/en/latest/notebook.html&#34;&gt;Jupyter notebooks&lt;/a&gt; containing the written materials and worked-out solutions on Python code. To work with the material, we recommend that you start each lesson with a fresh new notebook, and follow along, typing each line of code (don&#39;t copy-and-paste!), and exploring by changing parameters and seeing what happens.&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Installing via Anaconda &lt;/summary&gt; &#xA; &lt;br&gt; We *highly* recommend that you install the [Anaconda Python Distribution](http://docs.continuum.io/anaconda/install). It will make your life so much easier. You can download and install Anaconda on Windows, OSX and Linux. &#xA; &lt;p&gt;After installing, to ensure that your packages are up to date, run the following commands in a terminal:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;conda update conda&#xA;conda update jupyter numpy sympy scipy matplotlib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you prefer Miniconda (a mini version of Anaconda that saves you disk space), install all the necessary libraries to follow this course by running the following commands in a terminal:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;conda update conda&#xA;conda install jupyter&#xA;conda install numpy scipy sympy matplotlib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt; Without Anaconda &lt;/summary&gt; &#xA; &lt;br&gt; If you already have Python installed on your machine, you can install Jupyter using pip: &#xA; &lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;pip install jupyter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Please also make sure that you have the necessary libraries installed by running&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;pip install numpy scipy sympy matplotlib&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;How to contribute to CFD Python&lt;/h2&gt; &#xA;&lt;p&gt;We accept contributions via pull request—in fact, several users have already submitted pull requests making corrections or small improvements. You can also open an issue if you find a bug, or have a suggestion.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright and License&lt;/h2&gt; &#xA;&lt;p&gt;(c) 2017 Lorena A. Barba, Gilbert F. Forsyth. All content is under Creative Commons Attribution &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/legalcode.txt&#34;&gt;CC-BY 4.0&lt;/a&gt;, and all &lt;a href=&#34;https://github.com/engineersCode/EngComp/raw/master/LICENSE&#34;&gt;code is under BSD-3 clause&lt;/a&gt; (previously under MIT, and changed on March 8, 2018).&lt;/p&gt; &#xA;&lt;p&gt;We are happy if you re-use the content in any way!&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/BSD-3-Clause&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-BSD%203--Clause-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg?sanitize=true&#34; alt=&#34;License: CC BY 4.0&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>srush/raspy</title>
    <updated>2022-12-23T01:33:18Z</updated>
    <id>tag:github.com,2022-12-23:/srush/raspy</id>
    <link href="https://github.com/srush/raspy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An interactive exploration of Transformer programming.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;RASPy&lt;/h1&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/35882/208687068-66d07246-c9ac-45ea-8638-5357ccba178e.png&#34; width=&#34;600&#34;&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://srush.github.io/raspy/&#34;&gt;Blog&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://colab.research.google.com/github/srush/raspy/blob/main/Blog.ipynb&#34;&gt;Colab&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;This repo is a reimplementation for &lt;a href=&#34;https://github.com/tech-srl/RASP&#34;&gt;RASP&lt;/a&gt; as really neat language for thinking about transformer calculations.&lt;/p&gt; &#xA;&lt;p&gt;This version is done completely in Python as an &lt;a href=&#34;http://wiki.c2.com/?EmbeddedDomainSpecificLanguage&#34;&gt;embedded domain specific language&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>