<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Jupyter Notebook Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-21T01:31:52Z</updated>
  <subtitle>Daily Trending of Jupyter Notebook in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>run-llama/modal_finetune_sql</title>
    <updated>2023-08-21T01:31:52Z</updated>
    <id>tag:github.com,2023-08-21:/run-llama/modal_finetune_sql</id>
    <link href="https://github.com/run-llama/modal_finetune_sql" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Finetuning LLaMa + Text-to-SQL&lt;/h1&gt; &#xA;&lt;p&gt;This walkthrough shows you how to fine-tune LLaMa 2 7B on a Text-to-SQL dataset, and then use it for inference against any database of structured data using LlamaIndex.&lt;/p&gt; &#xA;&lt;p&gt;Check out our full blog here: &lt;a href=&#34;https://medium.com/llamaindex-blog/easily-finetune-llama-2-for-your-text-to-sql-applications-ecd53640e10d&#34;&gt;https://medium.com/llamaindex-blog/easily-finetune-llama-2-for-your-text-to-sql-applications-ecd53640e10d&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This code is taken and adapted from the Modal &lt;code&gt;doppel-bot&lt;/code&gt; repo: &lt;a href=&#34;https://github.com/modal-labs/doppel-bot&#34;&gt;https://github.com/modal-labs/doppel-bot&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Stack&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LlamaIndex&lt;/li&gt; &#xA; &lt;li&gt;Modal&lt;/li&gt; &#xA; &lt;li&gt;Hugging Face datasets&lt;/li&gt; &#xA; &lt;li&gt;OpenLLaMa&lt;/li&gt; &#xA; &lt;li&gt;Peft&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;To get started, clone or fork this repo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/run-llama/modal_finetune_sql.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Steps for Running&lt;/h3&gt; &#xA;&lt;p&gt;Please load the notebook &lt;code&gt;tutorial.ipynb&lt;/code&gt; for full instructions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modal_finetune_sql&#xA;jupyter notebook tutorial.ipynb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the meantime you can run each step individually as below:&lt;/p&gt; &#xA;&lt;p&gt;Loading data: &lt;code&gt;modal run src.load_data_sql&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Finetuning: &lt;code&gt;modal run --detach src.finetune_sql&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inference: &lt;code&gt;modal run src.inference_sql_llamaindex::main --query &#34;Which city has the highest population?&#34; --sqlite-file-path &#34;nbs/cities.db&#34;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;(Optional) Downloading model weights: &lt;code&gt;modal run src.download_weights --output-dir out_model&lt;/code&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>IbrahimSobh/llms</title>
    <updated>2023-08-21T01:31:52Z</updated>
    <id>tag:github.com,2023-08-21:/IbrahimSobh/llms</id>
    <link href="https://github.com/IbrahimSobh/llms" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Large Language Models: In this repository Language models are introduced covering both theoretical and practical aspects.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Large Language Models (llms)&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/lms.png&#34; alt=&#34;lms.png&#34;&gt; &lt;em&gt;Source&lt;/em&gt; &lt;a href=&#34;https://arxiv.org/pdf/2303.18223.pdf&#34;&gt;A Survey of Large Language Models&lt;/a&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Introduction: What is a language model?&lt;/h2&gt; &#xA;&lt;p&gt;Simple definition: Language Modeling is the task of predicting what word comes next.&lt;/p&gt; &#xA;&lt;p&gt;&#34;The dog is playing in the ...&#34;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;park&lt;/li&gt; &#xA; &lt;li&gt;woods&lt;/li&gt; &#xA; &lt;li&gt;snow&lt;/li&gt; &#xA; &lt;li&gt;office&lt;/li&gt; &#xA; &lt;li&gt;university&lt;/li&gt; &#xA; &lt;li&gt;Neural network&lt;/li&gt; &#xA; &lt;li&gt;?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The main purpose of &lt;strong&gt;Language Models&lt;/strong&gt; is to assign a probability to a sentence, to distinguish between the more likely and the less likely sentences.&lt;/p&gt; &#xA;&lt;h3&gt;Applications of language models:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Machine Translation: P(high winds tonight) &amp;gt; P(large winds tonight)&lt;/li&gt; &#xA; &lt;li&gt;Spelling correction: P(about fifteen minutes from) &amp;gt; P(about fifteen minuets from)&lt;/li&gt; &#xA; &lt;li&gt;Speech Recognition: P(I saw a van) &amp;gt; P(eyes awe of an)&lt;/li&gt; &#xA; &lt;li&gt;Authorship identification: who wrote some sample text&lt;/li&gt; &#xA; &lt;li&gt;Summarization, question answering, dialogue bots, etc.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;For Speech Recognition, we use not only the acoustics model (the speech signal), but also a language model. Similarly, for Optical Character Recognition (OCR), we use both a vision model and a language model. Language models are very important for such recognition systems.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Sometimes, you hear or read a sentence that is not clear, but using your language model, you still can recognize it at a high accuracy despite the noisy vision/speech input.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The language model computes either of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The probability of an upcoming word: $P(w_5 | w_1, w_2, w_3, w_4)$&lt;/li&gt; &#xA; &lt;li&gt;The probability of a sentence or sequence of words (according to the Language Model): $P(w_1, w_2, w_3, ..., w_n)$&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Language Modeling is a subcomponent of many NLP tasks, especially those involving generating text or estimating the probability of text.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The Chain Rule: $P(x_1, x_2, x_3, ‚Ä¶, x_n) = P(x_1)P(x_2|x_1)P(x_3|x_1,x_2)‚Ä¶P(x_n|x_1,‚Ä¶,x_{n-1})$&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;$P(The, water, is, so, clear) = P(The) √ó P(water|The) √ó P(is|The, water) √ó P(so|The, water, is) √ó P(clear | The, water, is, so)$&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;What just happened? The Chain Rule is applied to compute the joint probability of words in a sentence.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Statistical Language Modeling:&lt;/h2&gt; &#xA;&lt;h3&gt;n-gram Language Models&lt;/h3&gt; &#xA;&lt;p&gt;Using a large amount of text (corpus such as Wikipedia), we collect statistics about how frequently different words are, and use these to predict the next word. For example, the probability that a word &lt;em&gt;w&lt;/em&gt; comes after these three words &lt;em&gt;students opened their&lt;/em&gt; can be estimated as follows:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;P(w | students opened their) = count(students opened their w) / count(students opened their)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The above example is a 4-gram model. And we may get:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;P(books | students opened their) = 0.4&lt;/li&gt; &#xA; &lt;li&gt;P(cars | students, opened, their) = 0.05&lt;/li&gt; &#xA; &lt;li&gt;P(... | students, opened, their) = ...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;We can conclude that the word ‚Äúbooks‚Äù is more probable than ‚Äúcars‚Äù in this context.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We ignored the previous context before &#34;students opened their&#34;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Accordingly, arbitrary text can be generated from a language model given starting word(s), by sampling from the output probability distribution of the next word, and so on.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;We can train an LM on any kind of text, then generate text in that style (Harry Potter, etc.).&lt;/p&gt; &#xA;&lt;!--&#xA;### How to estimate these probabilities?&#xA;&#xA;Amusing we have a large text corpus (data set like Wikipedia), we can count and divide as follows:&#xA;&#xA;- $P(clear |The, water, is, so) = Count (The, water, is, so, clear) / Count (The, water, is, so)$&#xA;--&gt; &#xA;&lt;!--&#xA;Sparsity: Sometimes we do not have enough data to estimate the following: &#xA;- $P(clear |The, water, is, so) = Count (The, water, is, so, clear) / Count (The, water, is, so)$&#xA;&#xA;Markov Assumption (Simplifying assumption):&#xA;- $P(clear |The, water, is, so) ‚âà P(clear | so)$&#xA;- Or $P(clear |The, water, is, so) ‚âà P(clear | is, so)$&#xA;&#xA;&#xA;Formally:&#xA;- $P(w_1 w_2 ‚Ä¶ w_n ) ‚âà ‚àèi P(w_i | w_{i‚àík} ‚Ä¶ w_{i‚àí1})$&#xA;- $P(w_i | w_1 w_2 ‚Ä¶ w_{i‚àí1}) ‚âà P(w_i | w_{i‚àík} ‚Ä¶ w_{i‚àí1})$&#xA;- Unigram model: $P(w_1 w_2 ‚Ä¶ w_n ) ‚âà ‚àèi P(w_i)$&#xA;- Bigram model: $P(w_i | w_1 w_2 ‚Ä¶ w{i‚àí1}) ‚âà P(w_i | w_{i‚àí1})$&#xA;--&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;We can extend to trigrams, 4-grams, 5-grams, and N-grams.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;In general, this is an insufficient model of language because the language has long-distance dependencies. However, in practice, these 3,4 grams work well for most of the applications.&lt;/p&gt; &#xA;&lt;!--&#xA;### Estimating bigram probabilities:&#xA;The Maximum Likelihood Estimate (MLE): of all the times we saw the word wi-1, how many times it was followed by the word wi&#xA;&#xA;$P(w_i | w_{i‚àí1}) = count(w_{i‚àí1}, w_i) / count(w_{i‚àí1})$&#xA;Practical Issue: We do everything in log space to avoid underflow&#xA;$log(p1 √ó p2 √ó p3 √ó p4 ) = log p1 + log p2 + log p3 + log p4$&#xA;--&gt; &#xA;&lt;h3&gt;Building Statistical Language Models:&lt;/h3&gt; &#xA;&lt;h4&gt;Toolkits&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.speech.sri.com/projects/srilm/&#34;&gt;SRILM&lt;/a&gt; is a toolkit for building and applying statistical language models, primarily for use in speech recognition, statistical tagging and segmentation, and machine translation. It has been under development in the SRI Speech Technology and Research Laboratory since 1995.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kheafield.com/code/kenlm/&#34;&gt;KenLM&lt;/a&gt; is a fast and scalable toolkit that builds and queries language models.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;N-gram Models&lt;/h4&gt; &#xA;&lt;p&gt;Google&#39;s N-gram Models Belong to You: Google Research has been using word n-gram models for a variety of R&amp;amp;D projects. &lt;a href=&#34;https://ai.googleblog.com/2006/08/all-our-n-gram-are-belong-to-you.html&#34;&gt;Google N-Gram&lt;/a&gt; processed 1,024,908,267,229 words of running text and published the counts for all 1,176,470,663 five-word sequences that appear at least 40 times.&lt;/p&gt; &#xA;&lt;p&gt;The counts of text from the Linguistics Data Consortium &lt;a href=&#34;https://www.ldc.upenn.edu/&#34;&gt;LDC&lt;/a&gt; are as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;File sizes: approx. 24 GB compressed (gzip&#39;ed) text files&#xA;&#xA;Number of tokens:    1,024,908,267,229&#xA;Number of sentences:    95,119,665,584&#xA;Number of unigrams:         13,588,391&#xA;Number of bigrams:         314,843,401&#xA;Number of trigrams:        977,069,902&#xA;Number of fourgrams:     1,313,818,354&#xA;Number of fivegrams:     1,176,470,663&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following is an example of the &lt;strong&gt;4-gram&lt;/strong&gt; data in this corpus:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;serve as the incoming 92&#xA;serve as the incubator 99&#xA;serve as the independent 794&#xA;serve as the index 223&#xA;serve as the indication 72&#xA;serve as the indicator 120&#xA;serve as the indicators 45&#xA;serve as the indispensable 111&#xA;serve as the indispensible 40&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, the sequence of the four words &#34;serve as the indication&#34; has been seen in the corpus 72 times.&lt;/p&gt; &#xA;&lt;!--&#xA;Try some examples of your own using [Google Books Ngram Viewer](https://books.google.com/ngrams/) and see the frequency of likely and unlikely N-grams.&#xA;&#xA;![ngramviewer.png](images/ngramviewer.png)&#xA;--&gt; &#xA;&lt;h3&gt;Limitations of Statistical Language models&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes we do not have enough data to estimate. Increasing n makes sparsity problems worse. Typically we can‚Äôt have n bigger than 5.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sparsity problem 1: count(students opened their w) = 0? Smoothing Solution: Add small ùõø to the count for every &lt;em&gt;w&lt;/em&gt; in the vocabulary.&lt;/li&gt; &#xA; &lt;li&gt;Sparsity problem 2: count(students opened their) = 0? Backoff Solution: condition on (opened their) instead.&lt;/li&gt; &#xA; &lt;li&gt;Storage issue: Need to store the count for all n-grams you saw in the corpus. Increasing n or increasing corpus increases storage size.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Neural Language Models (NLM)&lt;/h2&gt; &#xA;&lt;p&gt;NLM usually (but not always) uses an RNN to learn sequences of words (sentences, paragraphs, ‚Ä¶ etc) and hence can predict the next word.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Advantages:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Can process variable-length input as the computations for step t use information from many steps back (eg: RNN)&lt;/li&gt; &#xA; &lt;li&gt;No sparsity problem (can feed any n-gram not seen in the training data)&lt;/li&gt; &#xA; &lt;li&gt;Model size doesn‚Äôt increase for longer input ($W_h, W_e, $), the same weights are applied on every timestep and need to store only the vocabulary word vectors.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/nlm01.png&#34; alt=&#34;nlm01.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;As depicted, At each step, we have a probability distribution of the next word over the vocabulary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Training an NLM:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Use a big corpus of text (a sequence of words such as Wikipedia)&lt;/li&gt; &#xA; &lt;li&gt;Feed into the NLM (a batch of sentences); compute output distribution for every step. (predict probability dist of every word, given words so far)&lt;/li&gt; &#xA; &lt;li&gt;Loss function on each step t cross-entropy between predicted probability distribution, and the true next word (one-hot)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;Example of long sequence learning:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The writer of the books (&lt;em&gt;is&lt;/em&gt; or &lt;em&gt;are&lt;/em&gt;)?&lt;/li&gt; &#xA; &lt;li&gt;Correct answer: The writer of the books &lt;em&gt;is&lt;/em&gt; planning a sequel&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Syntactic recency&lt;/strong&gt;: The writer of the books is (&lt;em&gt;correct&lt;/em&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Sequential recency&lt;/strong&gt;: The writer of the books are (&lt;em&gt;incorrect&lt;/em&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Disadvantages:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Recurrent computation is &lt;em&gt;slow&lt;/em&gt; (sequential, one step at a time)&lt;/li&gt; &#xA; &lt;li&gt;In practice, for long sequences, difficult_ to access information_ from many steps back&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Conditional language model&lt;/h3&gt; &#xA;&lt;p&gt;LM can be used to generate text conditions on input (speech, image (OCR), text, etc.) across different applications such as: speech recognition, machine translation, summarization, etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/clm.png&#34; alt=&#34;clm.png&#34;&gt;&lt;/p&gt; &#xA;&lt;!--&#xA;- to do [beam search](https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1194/slides/cs224n-2019-lecture08-nmt.pdf)&#xA;--&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Greedy decoding&lt;/em&gt;: take the most probable word on each step. Has no way to undo decisions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Beam search decoding&lt;/em&gt;: On each step of the decoder, keep track of the k most probable partial &lt;em&gt;hypotheses&lt;/em&gt; outputs (eg: translations) where k is the beam size (in practice around 5 to 10), then Backtrack to obtain the full hypothesis.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Decoding: stopping criterion:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;Greedy decoding&lt;/em&gt;: Usually we decode until the model produces a &lt;em&gt;END&lt;/em&gt; token.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Beam search decoding&lt;/em&gt;: different hypotheses may produce &lt;em&gt;END&lt;/em&gt; tokens on different timesteps, When a hypothesis produces &lt;em&gt;END&lt;/em&gt;, that hypothesis is complete, Place it aside and continue exploring other hypotheses via beam search. Usually, we continue beam search until:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We reach timestep T (where T is some pre-defined cutoff), or&lt;/li&gt; &#xA; &lt;li&gt;We have at least n completed hypotheses (where n is pre-defined cutoff)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;After we have our list of completed hypotheses, we select the top one with the highest (length normalized) score.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Evaluation: How good is our model?&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Does our language model prefer good (likely) sentences to bad ones?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Extrinsic evaluation:&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;For comparing models A and B, put each model in a task (spelling, corrector, speech recognizer, machine translation)&lt;/li&gt; &#xA; &lt;li&gt;Run the task and compare the accuracy for A and for B&lt;/li&gt; &#xA; &lt;li&gt;Best evaluation but not practical and time consuming!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Intrinsic evaluation:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Intuition&lt;/strong&gt;: The best language model is one that best predicts an unseen test set (assigns high probability to sentences).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Perplexity&lt;/strong&gt; is the standard evaluation metric for Language Models.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Perplexity&lt;/strong&gt; is defined as the inverse probability of a text, according to the Language Model.&lt;/li&gt; &#xA; &lt;li&gt;A good language model should give a lower Perplexity for a test text. Specifically, a lower perplexity for a given text means that text has a high probability in the eyes of that Language Model.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The standard evaluation metric for Language Models is perplexity Perplexity is the inverse probability of the test set, normalized by the number of words&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/preplexity02.png&#34; alt=&#34;preplexity02.png&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Lower perplexity = Better model&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Perplexity is related to branch factor: On average, how many things could occur next.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Transformer-based Language models&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Instead of RNN, let&#39;s use attention Let&#39;s use large pre-trained models&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;What is the problem?&lt;/strong&gt; One of the biggest challenges in natural language processing (NLP) is the shortage of training data for many distinct tasks. However, modern deep learning-based NLP models improve when trained on millions, or billions, of annotated training examples.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Pre-training is the solution:&lt;/strong&gt; To help close this gap, a variety of techniques have been developed for training general-purpose language representation models using the enormous amount of unannotated text. The pre-trained model can then be fine-tuned on small data for different tasks like question answering and sentiment analysis, resulting in substantial accuracy improvements compared to training on these datasets from scratch.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The Transformer architecture was proposed in the paper &lt;a href=&#34;https://arxiv.org/abs/1706.03762&#34;&gt;Attention is All You Need&lt;/a&gt;, used for the Neural Machine Translation task (NMT), consisting of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Encoder&lt;/strong&gt;: Network that encodes the input sequence.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Decoder&lt;/strong&gt;: Network that generates the output sequences conditioned on the input.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As mentioned in the paper:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;&lt;em&gt;We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely&lt;/em&gt;&#34;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The main idea of &lt;strong&gt;attention&lt;/strong&gt; can be summarized as mentioned in the OpenAi&#39;s &lt;a href=&#34;https://openai.com/blog/sparse-transformer/&#34;&gt;article&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;&lt;em&gt;... every output element is connected to every input element, and the weightings between them are &lt;strong&gt;dynamically calculated based upon the circumstances&lt;/strong&gt;, a process called attention.&lt;/em&gt;&#34;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Based on this architecture (the vanilla Transformers!), &lt;strong&gt;encoder or decoder&lt;/strong&gt; components can be used alone to enable massive pre-trained generic models that can be fine-tuned for downstream tasks such as text classification, translation, summarization, question answering, etc. For Example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#34;Pre-training of Deep Bidirectional Transformers for Language Understanding&#34; &lt;a href=&#34;https://arxiv.org/abs/1810.04805&#34;&gt;BERT&lt;/a&gt; is mainly based on the encoder architecture trained on massive text datasets to predict randomly masked words and &#34;is-next sentence&#34; classification tasks.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://arxiv.org/pdf/2005.14165.pdf&#34;&gt;GPT&lt;/a&gt;, on the other hand, is an auto-regressive generative model that is mainly based on the decoder architecture, trained on massive text datasets to predict the next word (unlike BERT, GPT can generate sequences).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;These models, BERT and GPT for instance, can be considered as the NLP&#39;s ImageNET.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/bertvsgpt.png&#34; alt=&#34;bertvsgpt.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;As shown, BERT is deeply bidirectional, OpenAI GPT is unidirectional, and ELMo is shallowly bidirectional.&lt;/p&gt; &#xA;&lt;p&gt;Pre-trained representations can be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Context-free&lt;/strong&gt;: such as word2vec or GloVe that generates a single/fixed word embedding (vector) representation for each word in the vocabulary (independent of the context of that word at test time)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Contextual&lt;/strong&gt;: generates a representation of each word based on the other words in the sentence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Contextual Language models can be:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Causal language model (CML)&lt;/strong&gt;: Predict the next token passed on previous ones. (GPT)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Masked language model (MLM)&lt;/strong&gt;: Predict the masked token based on the surrounding contextual tokens (BERT)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!--&#xA;#### To do&#xA;- Code Bert https://colab.research.google.com/drive/17sJR6JwoQ7Trr5WsUUIpHLZBElf8WrVq?usp=sharing#scrollTo=-u2Feyk5Gg7o&#xA;- Code GPT&#xA;- Code Falcon&#xA;- Code GPT4ALL&#xA;- Code CodeTF&#xA;- Chat with my docs&#xA;- etc.&#xA;--&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;üí• Practical LLMs&lt;/h2&gt; &#xA;&lt;p&gt;In this part, we are going to use different large language models&lt;/p&gt; &#xA;&lt;h3&gt;üöÄ Hello GPT2&lt;/h3&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://colab.research.google.com/drive/1eBcoHjJ2S4G_64sBvYS8G8B-1WSRLQAF?usp=sharing&#34;&gt; &lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://d4mucfpksywv.cloudfront.net/better-language-models/language_models_are_unsupervised_multitask_learners.pdf&#34;&gt;GPT2&lt;/a&gt; (a successor to GPT) is a pre-trained model on English language using a causal language modeling (&lt;strong&gt;CLM&lt;/strong&gt;) objective, trained simply to predict the next word in 40GB of Internet text. It was first released on this &lt;a href=&#34;https://openai.com/research/better-language-models&#34;&gt;page&lt;/a&gt;. GPT2 displays a broad set of capabilities, including the ability to generate conditional synthetic text samples. On language tasks like question answering, reading comprehension, summarization, and translation, GPT2 &lt;em&gt;begins&lt;/em&gt; to learn these tasks from the raw text, using no task-specific training data. DistilGPT2 is a distilled version of GPT2, it is intended to be used for similar use cases with the increased functionality of being smaller and easier to run than the base model.&lt;/p&gt; &#xA;&lt;p&gt;Here we load a pre-trained &lt;strong&gt;GPT2&lt;/strong&gt; model, ask the GPT2 model to continue our input text (prompt), and finally, extract embedded features from the DistilGPT2 model.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from transformers import pipeline&#xA;generator = pipeline(&#39;text-generation&#39;, model=&#39;gpt2&#39;)&#xA;generator(&#34;The capital of Japan is Tokyo, The capital of Egypt is&#34;, max_length=13, num_return_sequences=2)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;[{&#39;generated_text&#39;: &#39;The capital of Japan is Tokyo, The capital of Egypt is Cairo&#39;},&#xA;{&#39;generated_text&#39;: &#39;The capital of Japan is Tokyo, The capital of Egypt is Alexandria&#39;}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üöÄ Hello BERT&lt;/h3&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://colab.research.google.com/drive/1n8fd41Bi8yaWp0__eVCe9T4ctWVwSxvC?usp=sharing&#34;&gt; &lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/1810.04805&#34;&gt;BERT&lt;/a&gt; is a transformers model pre-trained on a large corpus of English data in a self-supervised fashion. This means it was pre-trained on the raw texts only, with no humans labeling them in any way with an automatic process to generate inputs and labels from those texts. More precisely, it was pretrained with two objectives:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Masked language modeling (&lt;strong&gt;MLM&lt;/strong&gt;): taking a sentence, the model randomly masks 15% of the words in the input then run the entire masked sentence through the model and has to predict the masked words. This is different from traditional recurrent neural networks (RNNs) that usually see the words one after the other, or from autoregressive models like GPT which internally masks the future tokens. It allows the model to learn a bidirectional representation of the sentence.&lt;/li&gt; &#xA; &lt;li&gt;Next sentence prediction (&lt;strong&gt;NSP&lt;/strong&gt;): the model concatenates two masked sentences as inputs during pretraining. Sometimes they correspond to sentences that were next to each other in the original text, sometimes not. The model then has to predict if the two sentences were following each other or not.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In this example, we are going to use a pre-trained &lt;strong&gt;BERT&lt;/strong&gt; model for the sentiment analysis task.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Baseline bidirectional LSTM model (accuracy = 65%)&lt;/li&gt; &#xA; &lt;li&gt;Use BERT as a feature extractor using only [CLS] feature (accuracy = 81%)&lt;/li&gt; &#xA; &lt;li&gt;Use BERT as a feature extractor for the sequence representation (accuracy = 85%)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;import transformers as ppb&#xA;&#xA;model_class, tokenizer_class, pretrained_weights = (ppb.BertModel, ppb.BertTokenizer, &#39;bert-base-uncased&#39;)&#xA;bert_tokenizer = tokenizer_class.from_pretrained(pretrained_weights)&#xA;bert_model = model_class.from_pretrained(pretrained_weights)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üöÄ GPT4ALL&lt;/h3&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://colab.research.google.com/drive/1AONl_3F8C6fB2NKaQsuAHio0sdjulIRk?usp=sharing&#34;&gt; &lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.gpt4all.io/&#34;&gt;GPT4All&lt;/a&gt; is an ecosystem to train and deploy powerful and customized large language models that run locally on consumer grade CPUs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;import gpt4all&#xA;gptj = gpt4all.GPT4All(&#34;ggml-gpt4all-j-v1.3-groovy.bin&#34;)&#xA;&#xA;with gptj.chat_session():&#xA;    response = gptj.generate(prompt=&#39;hello&#39;, top_k=1)&#xA;    response = gptj.generate(prompt=&#39;My name is Ibrahim, what is your name?&#39;, top_k=1)&#xA;    response = gptj.generate(prompt=&#39;What is the capital of Egypt?&#39;, top_k=1)&#xA;    response = gptj.generate(prompt=&#39;What is my name?&#39;, top_k=1)&#xA;    print(gptj.current_chat_session) &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;[{&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: &#39;hello&#39;}, &#xA;{&#39;role&#39;: &#39;assistant&#39;, &#39;content&#39;: &#39;Hello! How can I assist you today?&#39;}, &#xA;&#xA;{&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: &#39;My name is Ibrahim, what is your name?&#39;}, &#xA;{&#39;role&#39;: &#39;assistant&#39;, &#39;content&#39;: &#39;I am an artificial intelligence assistant. My name is AI-Assistant.&#39;}, &#xA;&#xA;{&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: &#39;What is the capital of Egypt?&#39;}, &#xA;{&#39;role&#39;: &#39;assistant&#39;, &#39;content&#39;: &#39;The capital city of Egypt is Cairo.&#39;}, &#xA;&#xA;{&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: &#39;What is my name?&#39;}, &#xA;{&#39;role&#39;: &#39;assistant&#39;, &#39;content&#39;: &#39;Your name is Ibrahim, what a beautiful name!&#39;}]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Try the following models:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Vicuna&lt;/strong&gt;: a chat assistant fine-tuned from LLaMA on user-shared conversations by LMSYS&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;WizardLM&lt;/strong&gt;: an instruction-following LLM using evol-instruct by Microsoft&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;MPT-Chat&lt;/strong&gt;: a chatbot fine-tuned from MPT-7B by MosaicML&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Orca&lt;/strong&gt;: a model, by Microsoft, that learns to imitate the reasoning process of large foundation models (GPT-4), guided by teacher assistance from ChatGPT.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;import gpt4all&#xA;model = gpt4all.GPT4All(&#34;ggml-vicuna-7b-1.1-q4_2.bin&#34;)&#xA;model = gpt4all.GPT4All(&#34;ggml-vicuna-13b-1.1-q4_2.bin&#34;)&#xA;model = gpt4all.GPT4All(&#34;ggml-wizardLM-7B.q4_2.bin&#34;)&#xA;model = gpt4all.GPT4All(&#34;ggml-mpt-7b-chat.bin&#34;)&#xA;model = gpt4all.GPT4All(&#34;orca-mini-3b.ggmlv3.q4_0.bin&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üöÄ Falcon&lt;/h3&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://colab.research.google.com/drive/1bkBWa38-kO9T-8mvI1iXAQCIdOO19Uv2?usp=sharing&#34;&gt; &lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://huggingface.co/tiiuae&#34;&gt;Falcon&lt;/a&gt; LLM is TII&#39;s flagship series of large language models, built from scratch using a custom data pipeline and distributed training. Falcon-7B/40B models are state-of-the-art for their size, outperforming most other models on NLP benchmarks. Open-sourced a number of artefacts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The Falcon-7/40B pretrained and instruct models, under the Apache 2.0 software license.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;from transformers import AutoTokenizer, AutoModelForCausalLM&#xA;import transformers&#xA;import torch&#xA;&#xA;model = &#34;tiiuae/falcon-7b-instruct&#34;&#xA;&#xA;tokenizer = AutoTokenizer.from_pretrained(model)&#xA;pipeline = transformers.pipeline(&#xA;    &#34;text-generation&#34;,&#xA;    model=model,&#xA;    tokenizer=tokenizer,&#xA;    torch_dtype=torch.bfloat16,&#xA;    trust_remote_code=True,&#xA;    device_map=&#34;auto&#34;,&#xA;)&#xA;sequences = pipeline(&#xA;   &#34;Girafatron is obsessed with giraffes, the most glorious animal on the face of this Earth. Giraftron believes all other animals are irrelevant when compared to the glorious majesty of the giraffe.\nDaniel: Hello, Girafatron!\nGirafatron:&#34;,&#xA;    max_length=200,&#xA;    do_sample=True,&#xA;    top_k=10,&#xA;    num_return_sequences=1,&#xA;    eos_token_id=tokenizer.eos_token_id,&#xA;)&#xA;for seq in sequences:&#xA;    print(f&#34;Result: {seq[&#39;generated_text&#39;]}&#34;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Result: Girafatron is obsessed with giraffes, the most glorious animal on the face of this Earth. Giraftron believes all other animals are irrelevant when compared to the glorious majesty of the giraffe.&#xA;Daniel: Hello, Girafatron!&#xA;Girafatron: Hi Daniel! I am Girafatron, the world&#39;s first Giraffe. How can I be of assistance to you, human boy?&#xA;Daniel: I&#39;d like to ask you questions about yourself, like how your day is going and how you feel about your job and everything. Would you like to talk about that?&#xA;Girafatron: Sure, my day is going great. I&#39;m feeling fantastic. As for my job, I&#39;m enjoying it!&#xA;Daniel: What do you like most about your job?&#xA;Girafatron: I love being the tallest animal in the universe! It&#39;s really fulfilling.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;ü¶ô Llama 2&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://huggingface.co/blog/llama2&#34;&gt;Llama2&lt;/a&gt; is a family of state-of-the-art open-access large language models released by Meta today, and we‚Äôre excited to fully support the launch with comprehensive integration in Hugging Face. Llama 2 is being released with a very permissive community license and is available for commercial use. The code, pretrained models, and fine-tuned models are all being released today üî•&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install transformers&#xA;huggingface-cli login&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;from transformers import AutoTokenizer&#xA;import transformers&#xA;import torch&#xA;&#xA;model = &#34;meta-llama/Llama-2-7b-chat-hf&#34;&#xA;&#xA;tokenizer = AutoTokenizer.from_pretrained(model)&#xA;pipeline = transformers.pipeline(&#xA;    &#34;text-generation&#34;,&#xA;    model=model,&#xA;    torch_dtype=torch.float16,&#xA;    device_map=&#34;auto&#34;,&#xA;)&#xA;&#xA;sequences = pipeline(&#xA;    &#39;I liked &#34;Breaking Bad&#34; and &#34;Band of Brothers&#34;. Do you have any recommendations of other shows I might like?\n&#39;,&#xA;    do_sample=True,&#xA;    top_k=10,&#xA;    num_return_sequences=1,&#xA;    eos_token_id=tokenizer.eos_token_id,&#xA;    max_length=200,&#xA;)&#xA;for seq in sequences:&#xA;    print(f&#34;Result: {seq[&#39;generated_text&#39;]}&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;Result: I liked &#34;Breaking Bad&#34; and &#34;Band of Brothers&#34;. Do you have any recommendations of other shows I might like?&#xA;Answer:&#xA;Of course! If you enjoyed &#34;Breaking Bad&#34; and &#34;Band of Brothers,&#34; here are some other TV shows you might enjoy:&#xA;1. &#34;The Sopranos&#34; - This HBO series is a crime drama that explores the life of a New Jersey mob boss, Tony Soprano, as he navigates the criminal underworld and deals with personal and family issues.&#xA;2. &#34;The Wire&#34; - This HBO series is a gritty and realistic portrayal of the drug trade in Baltimore, exploring the impact of drugs on individuals, communities, and the criminal justice system.&#xA;3. &#34;Mad Men&#34; - Set in the 1960s, this AMC series follows the lives of advertising executives on Madison Avenue, expl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üöÄ CodeT5+&lt;/h3&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://colab.research.google.com/drive/1Ik8w6BgHazuf45E5GrZd0vyx6SV3EOzG?usp=sharing&#34;&gt; &lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/salesforce/CodeT5/tree/main/CodeT5+&#34;&gt;CodeT5+&lt;/a&gt; is a new family of open code large language models with an encoder-decoder architecture that can flexibly operate in different modes (i.e. encoder-only, decoder-only, and encoder-decoder) to support a wide range of code understanding and generation tasks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from transformers import T5ForConditionalGeneration, AutoTokenizer&#xA;&#xA;checkpoint = &#34;Salesforce/codet5p-770m-py&#34;&#xA;device = &#34;cuda&#34; # for GPU usage or &#34;cpu&#34; for CPU usage&#xA;&#xA;tokenizer = AutoTokenizer.from_pretrained(checkpoint)&#xA;model = T5ForConditionalGeneration.from_pretrained(checkpoint).to(device)&#xA;&#xA;inputs = tokenizer.encode(&#34;def factorial(n):&#34;, return_tensors=&#34;pt&#34;).to(device)&#xA;outputs = model.generate(inputs, max_length=150)&#xA;print(tokenizer.decode(outputs[0], skip_special_tokens=True))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;def factorial(n):&#xA;&#39;&#39;&#39;&#xA;Returns the factorial of a given number.&#xA;&#39;&#39;&#39;&#xA;if n == 0:&#xA;    return 1&#xA;return n * factorial(n - 1)&#xA;&#xA;def main():&#xA;    &#39;&#39;&#39;&#xA;    Tests the factorial function.&#xA;    &#39;&#39;&#39;&#xA;    assert factorial(0) == 1&#xA;    assert factorial(1) == 1&#xA;    assert factorial(2) == 2&#xA;    assert factorial(3) == 6&#xA;    assert factorial(4) == 120&#xA;    assert factorial(5) == 720&#xA;    assert factorial(6) == 5040&#xA;    assert factorial(7) == 5040&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more models, check &lt;a href=&#34;https://github.com/salesforce/CodeTF&#34;&gt;CodeTF&lt;/a&gt; from Salesforce, a Python transformer-based library for code large language models (Code LLMs) and code intelligence, providing a seamless interface for training and inferencing on code intelligence tasks like code summarization, translation, code generation, and so on.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;üí• More LLMs&lt;/h2&gt; &#xA;&lt;p&gt;üèîÔ∏è &lt;a href=&#34;https://chat.lmsys.org/&#34;&gt;Chat with Open Large Language Models&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Vicuna&lt;/strong&gt;: a chat assistant fine-tuned from LLaMA on user-shared conversations by LMSYS&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;WizardLM&lt;/strong&gt;: an instruction-following LLM using evol-instruct by Microsoft&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Guanaco&lt;/strong&gt;: a model fine-tuned with QLoRA by UW&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;MPT-Chat&lt;/strong&gt;: a chatbot fine-tuned from MPT-7B by MosaicML&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Koala&lt;/strong&gt;: a dialogue model for academic research by BAIR&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;RWKV-4-Raven&lt;/strong&gt;: an RNN with transformer-level LLM performance&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Alpaca&lt;/strong&gt;: a model fine-tuned from LLaMA on instruction-following demonstrations by Stanford&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;ChatGLM&lt;/strong&gt;: an open bilingual dialogue language model by Tsinghua University&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;OpenAssistant&lt;/strong&gt; (oasst): an Open Assistant for everyone by LAION&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;LLaMA&lt;/strong&gt;: open and efficient foundation language models by Meta&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Dolly&lt;/strong&gt;: an instruction-tuned open large language model by Databricks&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;FastChat-T5&lt;/strong&gt;: a chat assistant fine-tuned from FLAN-T5 by LMSYS&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;üßë üìù Prompt Engineering&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;üëâ &lt;strong&gt;Prompt engineering&lt;/strong&gt; is the process of designing the prompts (text input) for a language model to generate the required output. Prompt engineering involves selecting appropriate keywords, providing context, being clear and specific in a way that directs the language model behavior achieving desired responses. Through prompt engineering, we can control a model‚Äôs tone, style, length, etc. without fine-tuning.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;üëâ &lt;strong&gt;Zero-shot learning&lt;/strong&gt; involves asking the model to make predictions without providing any examples (zero shot), for example:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Classify the text into neutral, negative or positive. &#xA;Text: I think the vacation is excellent.&#xA;Sentiment:&#xA;&#xA;Answer: Positive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When zero-shot is not good enough, it&#39;s recommended to help the model by providing examples in the prompt which leads to few-shot prompting.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üëâ &lt;strong&gt;Few-shot learning&lt;/strong&gt; involves asking the model while providing a few examples in the prompt, for example:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;Text: This is awesome!&#xA;Sentiment: Positive &#xA;&#xA;Text: This is bad!&#xA;Sentiment: Negative&#xA;&#xA;Text: Wow that movie was rad!&#xA;Sentiment: Positive&#xA;&#xA;Text: What a horrible show!&#xA;Sentiment:  &#xA;&#xA;Answer: Negative&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;üëâ &lt;strong&gt;Chain-of-thought (&lt;a href=&#34;https://arxiv.org/abs/2201.11903&#34;&gt;CoT&lt;/a&gt;)&lt;/strong&gt; prompting enables complex reasoning capabilities through intermediate reasoning steps. We can combine it with few-shot prompting to get better results on complex tasks that require step by step reasoning before responding.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/cot.png&#34; alt=&#34;cot.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In addition to &lt;strong&gt;prompt engineering&lt;/strong&gt;, we may consider more options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Fine-tuning the model on additional data.&lt;/li&gt; &#xA; &lt;li&gt;Retrieval Augmented Generation (RAG) to provide additional external data to the prompt to form enhanced context from archived knowledge sources.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;üëâ For more prompt engineering information, see the &lt;a href=&#34;https://github.com/dair-ai/Prompt-Engineering-Guide&#34;&gt;Prompt Engineering Guide&lt;/a&gt; that contains all the latest papers, learning guides, lectures, references, and tools.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;üöÄ Fine-tuning LLMs&lt;/h2&gt; &#xA;&lt;p&gt;Fine-tuning LLMs on downstream datasets results in huge performance gains when compared to using the pretrained LLMs out-of-the-box (zero-shot inference, for example). However, as models get larger and larger, full fine-tuning becomes infeasible to train on consumer hardware. In addition, storing and deploying fine-tuned models independently for each downstream task becomes very expensive, because fine-tuned models are the same size as the original pretrained model. Parameter-Efficient Fine-tuning (&lt;a href=&#34;https://huggingface.co/blog/peft&#34;&gt;PEFT&lt;/a&gt;) approaches are meant to address both problems! PEFT approaches enable you to get performance comparable to full fine-tuning while only having a small number of trainable parameters. For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;üëâ &lt;a href=&#34;https://arxiv.org/pdf/2104.08691.pdf&#34;&gt;Prompt Tuning&lt;/a&gt;: a simple yet effective mechanism for learning ‚Äúsoft prompts‚Äù to condition frozen language models to perform specific downstream tasks. Just like engineered text prompts, soft prompts are concatenated to the input text. But rather than selecting from existing vocabulary items, the ‚Äútokens‚Äù of the soft prompt are learnable vectors. This means a soft prompt can be optimized end-to-end over a training dataset, as &lt;a href=&#34;https://ai.googleblog.com/2022/02/guiding-frozen-language-models-with.html&#34;&gt;shown&lt;/a&gt; below: &lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/pt.png&#34; alt=&#34;pt.png&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;üëâ &lt;strong&gt;&lt;a href=&#34;https://arxiv.org/pdf/2106.09685.pdf&#34;&gt;LoRA&lt;/a&gt;&lt;/strong&gt; Low-Rank Adaptation of llms is a method that freezes the pretrained model weights and injects trainable rank decomposition matrices into each layer of the Transformer architecture. Greatly reducing the number of trainable parameters for downstream tasks. The figure below, from this &lt;a href=&#34;https://youtu.be/PXWYUTMt-AU&#34;&gt;video&lt;/a&gt;, explians the main idea: &lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/lora.png&#34; alt=&#34;lora.png&#34;&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;üöÄ Retrieval Augmented Generation (RAG)&lt;/h2&gt; &#xA;&lt;p&gt;Large language models are usually general purpose, less effective for domain-specific tasks. However, they can be fine-tuned on some tasks such as sentiment analysis. For more complex taks that require external knowledge, it&#39;s possible to build a language model-based system that accesses external knowledge sources to complete the required tasks. This enables more factual accuracy, and helps to mitigate the problem of &#34;hallucination&#34;. As shown in the &lt;a href=&#34;https://neo4j.com/developer-blog/fine-tuning-retrieval-augmented-generation/&#34;&gt;figuer&lt;/a&gt; below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/rag.png&#34; alt=&#34;rag.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In this case, instead of using LLMs to access its internal knowledge, we use the LLM as a natural language interface to our external knowledge. The first step is to convert the documents and any user queries into a compatible format to perform relevancy search (convert text into vectors, or embeddings). The original user prompt is then appended with relevant / similar documents within the external knowledge source (as a context). The model then answers the questions based on the provided external context.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;ü¶úÔ∏èüîó LangChain&lt;/h2&gt; &#xA;&lt;p&gt;Large language models (LLMs) are emerging as a transformative technology. However, using these LLMs in isolation is often insufficient for creating a truly powerful applications. &lt;a href=&#34;https://github.com/langchain-ai/langchain&#34;&gt;LangChain&lt;/a&gt; aims to assist in the development of such applications.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/lc02.png&#34; alt=&#34;lc02.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;There are six main areas that LangChain is designed to help with. These are, in increasing order of complexity:&lt;/p&gt; &#xA;&lt;h3&gt;üëâ üìÉ LLMs and Prompts:&lt;/h3&gt; &#xA;&lt;p&gt;This includes prompt management, prompt optimization, a generic interface for all LLMs, and common utilities for working with LLMs. &lt;strong&gt;LLMs and Chat&lt;/strong&gt; Models are subtly but importantly different. LLMs in LangChain refer to pure text completion models. The APIs they wrap take a string prompt as input and output a string completion. OpenAI&#39;s GPT-3 is implemented as an LLM. Chat models are often backed by LLMs but tuned specifically for having conversations.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;LLM:&lt;/strong&gt; There are lots of LLM providers (OpenAI, Cohere, Hugging Face, etc) - the LLM class is designed to provide a standard interface for all of them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;pip install openai&#xA;export OPENAI_API_KEY=&#34;...&#34;&#xA;from langchain.llms import OpenAI&#xA;&#xA;llm = OpenAI(openai_api_key=&#34;...&#34;)&#xA;&#xA;llm(&#34;Tell me a joke&#34;)&#xA;# &#39;Why did the chicken cross the road?\n\nTo get to the other side.&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also access provider specific information that is returned. This information is NOT standardized across providers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;llm_result.llm_output&#xA;&#xA;    {&#39;token_usage&#39;: {&#39;completion_tokens&#39;: 3903,&#xA;      &#39;total_tokens&#39;: 4023,&#xA;      &#39;prompt_tokens&#39;: 120}}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Chat models&lt;/strong&gt;: Rather than expose a &#34;text in, text out&#34; API, Chat models expose an interface where &#34;chat messages&#34; are the inputs and outputs. Most of the time, you&#39;ll just be dealing with HumanMessage, AIMessage, and SystemMessage.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.chat_models import ChatOpenAI&#xA;&#xA;chat = ChatOpenAI()&#xA;&#xA;messages = [&#xA;    SystemMessage(content=&#34;You are a helpful assistant that translates English to French.&#34;),&#xA;    HumanMessage(content=&#34;I love programming.&#34;)&#xA;]&#xA;chat(messages)&#xA;&#xA;# AIMessage(content=&#34;J&#39;aime programmer.&#34;, additional_kwargs={})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Prompt templates&lt;/strong&gt; are pre-defined recipes for generating prompts for language models. A template may include instructions, few shot examples, and specific context and questions appropriate for a given task.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain import PromptTemplate&#xA;&#xA;prompt_template = PromptTemplate.from_template(&#xA;    &#34;Tell me a {adjective} joke about {content}.&#34;&#xA;)&#xA;prompt_template.format(adjective=&#34;funny&#34;, content=&#34;chickens&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The prompt to Chat Models is a list of chat messages. Each chat message is associated with content, and an additional parameter called role. For example, in the OpenAI Chat Completions API, a chat message can be associated with an AI assistant, a human or a system role.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.prompts import ChatPromptTemplate&#xA;&#xA;template = ChatPromptTemplate.from_messages([&#xA;    (&#34;system&#34;, &#34;You are a helpful AI bot. Your name is {name}.&#34;),&#xA;    (&#34;human&#34;, &#34;Hello, how are you doing?&#34;),&#xA;    (&#34;ai&#34;, &#34;I&#39;m doing well, thanks!&#34;),&#xA;    (&#34;human&#34;, &#34;{user_input}&#34;),&#xA;])&#xA;&#xA;messages = template.format_messages(&#xA;    name=&#34;Bob&#34;,&#xA;    user_input=&#34;What is your name?&#34;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üëâ üîó Chains&lt;/h3&gt; &#xA;&lt;p&gt;Chains go beyond a single LLM call and involve sequences of calls (whether to an LLM or a different utility). LangChain provides a standard interface for chains, lots of integrations with other tools, and end-to-end chains for common applications. Chain very generically can be defined as a sequence of calls to components, which can include other chains.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.llms import OpenAI&#xA;from langchain.prompts import PromptTemplate&#xA;# To use the LLMChain, first create a prompt template.&#xA;llm = OpenAI(temperature=0.9)&#xA;prompt = PromptTemplate(&#xA;    input_variables=[&#34;product&#34;],&#xA;    template=&#34;What is a good name for a company that makes {product}?&#34;,)&#xA;&#xA;# We can now create a very simple chain that will take user input, format the prompt with it, and then send it to the LLM.&#xA;from langchain.chains import LLMChain&#xA;chain = LLMChain(llm=llm, prompt=prompt)&#xA;&#xA;# Run the chain only specifying the input variable.&#xA;print(chain.run(&#34;colorful socks&#34;))&#xA;&#xA;# Result&#xA;Colorful Toes Co.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üëâ üìö Data Augmented Generation:&lt;/h3&gt; &#xA;&lt;p&gt;Data Augmented Generation involves specific types of chains that first interact with an external data source to fetch data for use in the generation step. Examples include question/answering over specific data sources.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Document loaders: Load documents from many different sources. For example, there are document loaders for loading a simple .txt file, for loading the text contents of any web page, or even for loading a transcript of a YouTube video.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.document_loaders import TextLoader&#xA;&#xA;loader = TextLoader(&#34;./index.md&#34;)&#xA;loader.load()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Document transformers: Split documents, convert documents into Q&amp;amp;A format, drop redundant documents, and more&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;# This is a long document we can split up.&#xA;with open(&#39;../../state_of_the_union.txt&#39;) as f:&#xA;    state_of_the_union = f.read()&#xA;&#xA;from langchain.text_splitter import RecursiveCharacterTextSplitter&#xA;&#xA;text_splitter = RecursiveCharacterTextSplitter(&#xA;    # Set a really small chunk size, just to show.&#xA;    chunk_size = 100,&#xA;    chunk_overlap  = 20,&#xA;    length_function = len,&#xA;    add_start_index = True,&#xA;)&#xA;&#xA;texts = text_splitter.create_documents([state_of_the_union])&#xA;print(texts[0])&#xA;print(texts[1])&#xA;&#xA;&#xA;# page_content=&#39;Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and&#39; metadata={&#39;start_index&#39;: 0}&#xA;#page_content=&#39;of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.&#39; metadata={&#39;start_index&#39;: 82}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Text embedding models: Take text and turn it into a list of floating point numbers (vectrors). There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.embeddings import OpenAIEmbeddings&#xA;embeddings_model = OpenAIEmbeddings(openai_api_key=&#34;...&#34;)&#xA;&#xA;embeddings = embeddings_model.embed_documents(&#xA;    [&#xA;        &#34;Hi there!&#34;,&#xA;        &#34;Oh, hello!&#34;,&#xA;        &#34;What&#39;s your name?&#34;,&#xA;        &#34;My friends call me World&#34;,&#xA;        &#34;Hello World!&#34;&#xA;    ]&#xA;)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Vector stores: Store and search over embedded data. One of the most common ways to store and search over unstructured data is to embed it and store the resulting embedding vectors, and then at query time to embed the unstructured query and retrieve the embedding vectors that are &#39;most similar&#39; to the embedded query. A vector store takes care of storing embedded data and performing vector search for you.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.document_loaders import TextLoader&#xA;from langchain.embeddings.openai import OpenAIEmbeddings&#xA;from langchain.text_splitter import CharacterTextSplitter&#xA;from langchain.vectorstores import Chroma&#xA;&#xA;# Load the document, split it into chunks, embed each chunk and load it into the vector store.&#xA;raw_documents = TextLoader(&#39;../../../state_of_the_union.txt&#39;).load()&#xA;text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)&#xA;documents = text_splitter.split_documents(raw_documents)&#xA;db = Chroma.from_documents(documents, OpenAIEmbeddings())&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarity search&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;query = &#34;What did the president say about Ketanji Brown Jackson&#34;&#xA;docs = db.similarity_search(query)&#xA;print(docs[0].page_content)&#xA;&#xA;#    Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you‚Äôre at it, pass the Disclose Act so Americans can know who is funding our elections.&#xA;#    One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.&#xA;#    And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation‚Äôs top legal minds, who will continue Justice Breyer‚Äôs legacy of excellence.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Retrievers: Query your data. A retriever is an interface that returns documents given an unstructured query. It is more general than a vector store. A retriever does not need to be able to store documents, only to return (or retrieve) it. Vector stores can be used as the backbone of a retriever, but there are other types of retrievers as well.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Let&#39;s walk through this in code&#xA;documents = loader.load()&#xA;&#xA;#Next, we will split the documents into chunks.&#xA;from langchain.text_splitter import CharacterTextSplitter&#xA;text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)&#xA;texts = text_splitter.split_documents(documents)&#xA;&#xA;# We will then select which embeddings we want to use.&#xA;from langchain.embeddings import OpenAIEmbeddings&#xA;embeddings = OpenAIEmbeddings()&#xA;&#xA;# We now create the vectorstore to use as the index.&#xA;from langchain.vectorstores import Chroma&#xA;db = Chroma.from_documents(texts, embeddings)&#xA;&#xA;# So that&#39;s creating the index. Then, we expose this index in a retriever interface.&#xA;retriever = db.as_retriever()&#xA;&#xA;# Then, as before, we create a chain and use it to answer questions!&#xA;qa = RetrievalQA.from_chain_type(llm=OpenAI(), chain_type=&#34;stuff&#34;, retriever=retriever)&#xA;query = &#34;What did the president say about Ketanji Brown Jackson&#34;&#xA;qa.run(query)&#xA;&#xA;#     &#34; The President said that Judge Ketanji Brown Jackson is one of the nation&#39;s top legal minds, a former top litigator in private practice, a former federal public defender, and from a family of public school educators and police officers. He said she is a consensus builder and has received a broad range of support from organizations such as the Fraternal Order of Police and former judges appointed by Democrats and Republicans.&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üëâ ü§ñ Agents:&lt;/h3&gt; &#xA;&lt;p&gt;Agents involve an LLM making decisions about which Actions to take, taking that Action, seeing an Observation, and repeating that until done. LangChain provides a standard interface for agents, a selection of agents to choose from, and examples of end-to-end agents. The core idea of agents is to use an LLM to choose a sequence of actions to take. In chains, a sequence of actions is hardcoded (in code). In agents, a language model is used as a reasoning engine to determine which actions to take and in which order.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.agents import tool&#xA;&#xA;@tool&#xA;def get_word_length(word: str) -&amp;gt; int:&#xA;    &#34;&#34;&#34;Returns the length of a word.&#34;&#34;&#34;&#xA;    return len(word)&#xA;&#xA;tools = [get_word_length]&#xA;&#xA;&#xA;from langchain.agents import AgentExecutor&#xA;agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üëâ üß† Memory:&lt;/h3&gt; &#xA;&lt;p&gt;Memory refers to persisting state between calls of a chain/agent. LangChain provides a standard interface for memory, a collection of memory implementations, and examples of chains/agents that use memory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;from langchain.chat_models import ChatOpenAI&#xA;from langchain.prompts import (&#xA;    ChatPromptTemplate,&#xA;    MessagesPlaceholder,&#xA;    SystemMessagePromptTemplate,&#xA;    HumanMessagePromptTemplate,&#xA;)&#xA;from langchain.chains import LLMChain&#xA;from langchain.memory import ConversationBufferMemory&#xA;&#xA;&#xA;llm = ChatOpenAI()&#xA;prompt = ChatPromptTemplate(&#xA;    messages=[&#xA;        SystemMessagePromptTemplate.from_template(&#xA;            &#34;You are a nice chatbot having a conversation with a human.&#34;&#xA;        ),&#xA;        # The `variable_name` here is what must align with memory&#xA;        MessagesPlaceholder(variable_name=&#34;chat_history&#34;),&#xA;        HumanMessagePromptTemplate.from_template(&#34;{question}&#34;)&#xA;    ]&#xA;)&#xA;# Notice that we `return_messages=True` to fit into the MessagesPlaceholder&#xA;# Notice that `&#34;chat_history&#34;` aligns with the MessagesPlaceholder name.&#xA;memory = ConversationBufferMemory(memory_key=&#34;chat_history&#34;, return_messages=True)&#xA;conversation = LLMChain(&#xA;    llm=llm,&#xA;    prompt=prompt,&#xA;    verbose=True,&#xA;    memory=memory&#xA;)&#xA;&#xA;# Notice that we just pass in the `question` variables - `chat_history` gets populated by memory&#xA;conversation({&#34;question&#34;: &#34;hi&#34;})&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üëâ üßê Evaluation:&lt;/h3&gt; &#xA;&lt;p&gt;Generative models are notoriously hard to evaluate with traditional metrics. One new way of evaluating them is using language models themselves to do the evaluation. LangChain provides some prompts/chains for assisting in this.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;üßë ü§ñ Ask your documents&lt;/h2&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://colab.research.google.com/drive/1DDPhjMiffvWs4gqqD9KyNO-yAp26HavK?usp=sharing&#34;&gt; &lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg?sanitize=true&#34; alt=&#34;Open In Colab&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;We can use different methods to chat with our documents. No need to fine-tune the whole LLM, instead we can provide the right context along with our question to the pre-trained model and simply get the answers based on our provided documents.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Index phase:&lt;/strong&gt; Our documents are divided into chunks, extract embeddings per chunk, and save into an embedding database such as &lt;a href=&#34;https://www.trychroma.com/&#34;&gt;Chroma&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Question answering phase:&lt;/strong&gt; Given a question, we use the embedding database to get similar chunks, construct a prompt consisting of the question and the context, and feed this to the LLMs and get our answers.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Here, We chat with this nice article titled &lt;a href=&#34;https://www.linkedin.com/pulse/transformers-without-pain-ibrahim-sobh-phd/&#34;&gt;Transformers without pain ü§ó&lt;/a&gt; asking questions related to transformers, attention, encoder-decoder, etc. while utilizing the powerful &lt;a href=&#34;https://python.langchain.com/docs/get_started/introduction.html&#34;&gt;Palm&lt;/a&gt; Model by google and the &lt;a href=&#34;https://python.langchain.com/docs/get_started/introduction.html&#34;&gt;LangChain&lt;/a&gt; framework for developing applications powered by language models.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# load docs and construct the index&#xA;urls = [&#39;https://www.linkedin.com/pulse/transformers-without-pain-ibrahim-sobh-phd/&#39;,]&#xA;loader = WebBaseLoader(urls)&#xA;index = VectorstoreIndexCreator(&#xA;        embedding=GooglePalmEmbeddings(),&#xA;        text_splitter=RecursiveCharacterTextSplitter(chunk_size=1000,&#xA;                                 chunk_overlap=0, separators=[&#34; &#34;, &#34;,&#34;, &#34;\n&#34;])).from_loaders([loader])&#xA;&#xA;# QA Retrieval&#xA;qa_retriever = RetrievalQA.from_chain_type(llm=Palm_llm, chain_type=&#34;stuff&#34;,&#xA;                                    retriever=index.vectorstore.as_retriever(),&#xA;                                    input_key=&#34;question&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: üßë &#39;What these documents are about?&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: ü§ñ &#39;The documents are about transformers, which are a type of neural network that has been used successfully in natural language processing and computer vision tasks.&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: üßë &#39;What is the main idea of transformers?&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: ü§ñ &#39;The main idea of transformers is to use attention mechanisms to model long-range dependencies in sequences.&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: üßë &#39;What is positional encoding?&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: ü§ñ &#39;Positional encoding is a technique used to represent the order of words in a sequence.&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: üßë &#39;How query, key, and value vectors are used?&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: ü§ñ &#39;The query vector is used to compute a weighted sum of the values through the keys. Specifically: q dot product all the keys, then softmax to get weights and finally use these weights to compute a weighted sum of the values.&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: üßë &#39;How to start using transformers?&#39;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: ü§ñ &#39;To start using transformers, you can use the huggingface transformers library. This library provides thousands of pretrained models to perform tasks on texts such as classification, information extraction, question answering, summarization, translation, text generation, etc in 100+ languages.&#39;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can try your own documents and questions!&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;üì¢ Ask almost everything (txt, pdf, video, etc.)&lt;/h3&gt; &#xA;&lt;p&gt;In these simple tutorials: How to get answers from &lt;strong&gt;text&lt;/strong&gt; documents, &lt;strong&gt;pdf&lt;/strong&gt; files, and even &lt;strong&gt;YouTube&lt;/strong&gt; videos using &lt;a href=&#34;https://www.trychroma.com/&#34;&gt;Chroma&lt;/a&gt; vector database, &lt;a href=&#34;https://blog.google/technology/ai/google-palm-2-ai-large-language-model/&#34;&gt;PaLM&lt;/a&gt; llm by Google, and a question answering chain from &lt;a href=&#34;https://python.langchain.com/docs/get_started/introduction.html&#34;&gt;LangChain&lt;/a&gt;. Finally, use &lt;a href=&#34;https://streamlit.io/&#34;&gt;Streamlit&lt;/a&gt; to develop and host the web application. You will need to use your google_api_key (you can get one from Google). Ths system &lt;a href=&#34;https://blog.streamlit.io/langchain-tutorial-4-build-an-ask-the-doc-app/&#34;&gt;architecture&lt;/a&gt; is as follows:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/lc01.png&#34; alt=&#34;lc01.png&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://askyoutube-djl4xfut5yj.streamlit.app/&#34;&gt;Ask YouTube&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/askyoutube.png&#34; alt=&#34;askyoutube.png&#34;&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://askpdf-6ybdiy0fj3h.streamlit.app/&#34;&gt;Ask Pdf&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/IbrahimSobh/llms/main/images/askpdf.png&#34; alt=&#34;askpdf.png&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Further readings:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Speech-Language-Processing-Daniel-Jurafsky/dp/0131873210&#34;&gt;Book: Speech and Language Processing; Daniel Jurafsky&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://youtu.be/iWea12EAu6U?list=PLoROMvodv4rOhcuXMZkNm7j3fVwBBY42z&#34;&gt;Video: Natural Language Processing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://machinelearningmastery.com/statistical-language-modeling-and-neural-language-models/&#34;&gt;Gentle Introduction to Statistical Language Modeling and Neural Language Models&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>