<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Jupyter Notebook Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-20T01:29:52Z</updated>
  <subtitle>Daily Trending of Jupyter Notebook in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>dedwards25/Python_Option_Pricing</title>
    <updated>2024-02-20T01:29:52Z</updated>
    <id>tag:github.com,2024-02-20:/dedwards25/Python_Option_Pricing</id>
    <link href="https://github.com/dedwards25/Python_Option_Pricing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An libary to price financial options written in Python. Includes: Black Scholes, Black 76, Implied Volatility, American, European, Asian, Spread Options&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Python_Option_Pricing&lt;/h1&gt; &#xA;&lt;p&gt;A libary to price financial options using closed-form solutions written in Python. MIT License.&lt;/p&gt; &#xA;&lt;h2&gt;Includes&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;European Options: Black-Scholes, Black76, Merton, Garman-Kohlhagan;&lt;/li&gt; &#xA; &lt;li&gt;Spread Options: Kirk&#39;s Approximation, Heat Rate Options;&lt;/li&gt; &#xA; &lt;li&gt;American Options: Bjerksund-Stensland&lt;/li&gt; &#xA; &lt;li&gt;Implied Volatility&lt;/li&gt; &#xA; &lt;li&gt;Asian Options&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>ContextualAI/gritlm</title>
    <updated>2024-02-20T01:29:52Z</updated>
    <id>tag:github.com,2024-02-20:/ContextualAI/gritlm</id>
    <link href="https://github.com/ContextualAI/gritlm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Generative Representational Instruction Tuning&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;GRIT&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/visuals/octopus.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository provides all materials for the paper &lt;a href=&#34;https://arxiv.org/abs/2402.09906&#34;&gt;Generative Representational Instruction Tuning&lt;/a&gt;. We continue developing the repository and welcome any contributions. If you want to use the code in the exact same way as in the paper, please use the 1.0.0 release at commit hash &lt;code&gt;3ac39052ef878371a658a060e69f9c0124bfd59b&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#inference&#34;&gt;Inference&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#script&#34;&gt;Script&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#models&#34;&gt;Models&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#training&#34;&gt;Training&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#data&#34;&gt;Data&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#run&#34;&gt;Run&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#evaluation&#34;&gt;Evaluation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#embedding&#34;&gt;Embedding&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#generative&#34;&gt;Generative&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#known-issues&#34;&gt;Known issues&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#visuals&#34;&gt;Visuals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#acknowledgements&#34;&gt;Acknowledgements&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ContextualAI/gritlm/main/#citation&#34;&gt;Citation&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Inference&lt;/h3&gt; &#xA;&lt;h4&gt;Script&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;pip install gritlm&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from gritlm import GritLM&#xA;&#xA;# Loads the model for both capabilities; If you only need embedding pass `mode=&#34;embedding&#34;` to save memory (no lm head)&#xA;model = GritLM(&#34;GritLM/GritLM-7B&#34;, torch_dtype=&#34;auto&#34;)&#xA;# To load the 8x7B you will likely need multiple GPUs.&#xA;# All the kwargs are passed to HF from_pretrained so you can just do the below to load on multiple GPUs:&#xA;# model = GritLM(&#34;GritLM/GritLM-8x7B&#34;, torch_dtype=&#34;auto&#34;, device_map=&#34;auto&#34;)&#xA;# You can also load other models e.g.&#xA;# model = GritLM(&#34;Muennighoff/SGPT-125M-weightedmean-nli-bitfit&#34;, pooling_method=&#34;weighted_mean&#34;, attn=None)&#xA;# model = GritLM(&#34;hkunlp/instructor-base&#34;, pooling_method=&#34;mean&#34;, attn=None)&#xA;&#xA;### Embedding/Representation ###&#xA;instruction = &#34;Given a scientific paper title, retrieve the paper&#39;s abstract&#34;&#xA;queries = [&#39;Bitcoin: A Peer-to-Peer Electronic Cash System&#39;, &#39;Generative Representational Instruction Tuning&#39;]&#xA;documents = [&#xA;    &#34;A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they&#39;ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone.&#34;,&#xA;    &#34;All text-based language problems can be reduced to either generation or embedding. Current models only perform well at one or the other. We introduce generative representational instruction tuning (GRIT) whereby a large language model is trained to handle both generative and embedding tasks by distinguishing between them through instructions. Compared to other open models, our resulting GritLM 7B sets a new state of the art on the Massive Text Embedding Benchmark (MTEB) and outperforms all models up to its size on a range of generative tasks. By scaling up further, GritLM 8X7B outperforms all open generative language models that we tried while still being among the best embedding models. Notably, we find that GRIT matches training on only generative or embedding data, thus we can unify both at no performance loss. Among other benefits, the unification via GRIT speeds up Retrieval-Augmented Generation (RAG) by &amp;gt; 60% for long documents, by no longer requiring separate retrieval and generation models. Models, code, etc. are freely available at https://github.com/ContextualAI/gritlm.&#34;&#xA;]&#xA;&#xA;def gritlm_instruction(instruction):&#xA;    return &#34;&amp;lt;|user|&amp;gt;\n&#34; + instruction + &#34;\n&amp;lt;|embed|&amp;gt;\n&#34; if instruction else &#34;&amp;lt;|embed|&amp;gt;\n&#34;&#xA;&#xA;# No need to add instruction for retrieval documents&#xA;d_rep = model.encode(documents, instruction=gritlm_instruction(&#34;&#34;))&#xA;q_rep = model.encode(queries, instruction=gritlm_instruction(instruction))&#xA;&#xA;from scipy.spatial.distance import cosine&#xA;cosine_sim_q0_d0 = 1 - cosine(q_rep[0], d_rep[0])&#xA;cosine_sim_q0_d1 = 1 - cosine(q_rep[0], d_rep[1])&#xA;cosine_sim_q1_d0 = 1 - cosine(q_rep[1], d_rep[0])&#xA;cosine_sim_q1_d1 = 1 - cosine(q_rep[1], d_rep[1])&#xA;&#xA;print(&#34;Cosine similarity between \&#34;%s\&#34; and \&#34;%s\&#34; is: %.3f&#34; % (queries[0][:15], documents[0][:15], cosine_sim_q0_d0))&#xA;# Cosine similarity between &#34;Bitcoin: A Peer&#34; and &#34;A purely peer-t&#34; is: 0.608&#xA;print(&#34;Cosine similarity between \&#34;%s\&#34; and \&#34;%s\&#34; is: %.3f&#34; % (queries[0][:15], documents[1][:15], cosine_sim_q0_d1))&#xA;# Cosine similarity between &#34;Bitcoin: A Peer&#34; and &#34;All text-based &#34; is: 0.101&#xA;print(&#34;Cosine similarity between \&#34;%s\&#34; and \&#34;%s\&#34; is: %.3f&#34; % (queries[1][:15], documents[0][:15], cosine_sim_q1_d0))&#xA;# Cosine similarity between &#34;Generative Repr&#34; and &#34;A purely peer-t&#34; is: 0.120&#xA;print(&#34;Cosine similarity between \&#34;%s\&#34; and \&#34;%s\&#34; is: %.3f&#34; % (queries[1][:15], documents[1][:15], cosine_sim_q1_d1))&#xA;# Cosine similarity between &#34;Generative Repr&#34; and &#34;All text-based &#34; is: 0.533&#xA;&#xA;### Generation ###&#xA;# We did not finetune GritLM models with system prompts, as you can just include system-like instructions together with your user instruction&#xA;messages = [&#xA;    {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Please write me a poem about my recent hike of Mt. Fuji at midnight in the style of Shakespeare.&#34;},&#xA;]&#xA;encoded = model.tokenizer.apply_chat_template(messages, add_generation_prompt=True, return_tensors=&#34;pt&#34;)&#xA;encoded = encoded.to(model.device)&#xA;gen = model.generate(encoded, max_new_tokens=256, do_sample=False)&#xA;decoded = model.tokenizer.batch_decode(gen)&#xA;print(decoded[0])&#xA;&#34;&#34;&#34;&#xA;&amp;lt;s&amp;gt; &amp;lt;|user|&amp;gt;&#xA;Please write me a poem about my recent hike of Mt. Fuji at midnight in the style of Shakespeare.&#xA;&amp;lt;|assistant|&amp;gt;&#xA;Oh, Mt. Fuji, mountain grand,&#xA;A sight to see, a climb to command,&#xA;At midnight, in the dark of night,&#xA;I climbed your slopes, with all my might.&#xA;&#xA;The stars above, they shone so bright,&#xA;A beacon in the darkness, guiding light,&#xA;The wind did blow, with a gentle sigh,&#xA;As I climbed higher, with a steady eye.&#xA;&#xA;The path was steep, the climb was tough,&#xA;But I pressed on, with a steadfast rough,&#xA;For the summit, I longed to see,&#xA;The view from the top, a sight to be.&#xA;&#xA;At last, I reached the peak, and stood,&#xA;With awe and wonder, I gazed aloud,&#xA;The world below, a sight to see,&#xA;A view that&#39;s worth the climb, you&#39;ll agree.&#xA;&#xA;Mt. Fuji, mountain grand,&#xA;A sight to see, a climb to command,&#xA;At midnight, in the dark of night,&#xA;I climbed your slopes, with all my might.&amp;lt;/s&amp;gt;&#xA;&#34;&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Models&lt;/h4&gt; &#xA;&lt;p&gt;The weights and logs of all models from the paper are freely available:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Weights: &lt;a href=&#34;https://huggingface.co/GritLM&#34;&gt;https://huggingface.co/GritLM&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Logs: &lt;a href=&#34;https://wandb.ai/muennighoff/gritlm/overview?workspace=user-muennighoff&#34;&gt;https://wandb.ai/muennighoff/gritlm/overview?workspace=user-muennighoff&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The names will not always match across HF &amp;amp; WandB, but you can usually figure out which belongs to which via the &lt;code&gt;--output_dir&lt;/code&gt; in the command. Note that we renamed all models from &lt;code&gt;sgpt2&lt;/code&gt; to &lt;code&gt;gritlm&lt;/code&gt; at some point, so some names/logs/commands contain the old name.&lt;/p&gt; &#xA;&lt;p&gt;Shortcuts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;sq = sequence length; sq2048 is 2048 tokens&lt;/li&gt; &#xA; &lt;li&gt;ep = epochs; ep1 is 1 epoch&lt;/li&gt; &#xA; &lt;li&gt;st = steps; st100 is 100 steps&lt;/li&gt; &#xA; &lt;li&gt;m7/m8x7/l7/g6 = base model is Mistral 7B/Mistral 8x7B/Llama 2 7B/GPT-J 6B&lt;/li&gt; &#xA; &lt;li&gt;emb/gen/gritlm = embedding, generative, unified&lt;/li&gt; &#xA; &lt;li&gt;bf16c = embeddings are cast back to bf16 after pooling and similarity computation is also done in bf16 (simulating how cached embeddings would operate)&lt;/li&gt; &#xA; &lt;li&gt;bb/cc/bbcc... = order of bidirectional vs causal attention&lt;/li&gt; &#xA; &lt;li&gt;gendups = not using &lt;code&gt;--use_unique_indices&lt;/code&gt; during training. If not used and training is unified, then data is duplicated worsening performance&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The most important ones are:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Model&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Emb performance (MTEB)&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Gen performance&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://huggingface.co/GritLM/gritlm-7b&#34;&gt;GritLM-7B&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;7B parameter model that uses bidirectional attention for embedding and causal attention for generation. It is finetuned from Mistral-7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;66.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;55.5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://huggingface.co/GritLM/gritlm-8x7b&#34;&gt;GritLM-8x7B&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;8x7B parameter model that uses bidirectional attention for embedding and causal attention for generation. It is finetuned from Mistral-8x7B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;65.7&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;65.7&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://hf.co/GritLM/gen_m7_sq2048_tulu2_ep1&#34;&gt;Generative-only variant&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;7B parameter model generative-only equivalent of GritLM-7B.&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;41.2&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;55.2&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://hf.co/GritLM/emb_m7_nodes16_fast&#34;&gt;Embedding-only variant&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;7B parameter model embedding-only equivalent of GritLM-7B.&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;66.8&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;7.6&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;For &lt;code&gt;GritLM-7B&lt;/code&gt; and &lt;code&gt;GritLM-8x7B&lt;/code&gt;, the folder contains a custom modeling file (&lt;code&gt;modeling_gritlm*.py&lt;/code&gt;) which adds bidirectional attention via the keyword argument &lt;code&gt;is_causal&lt;/code&gt;, such that if you load them with &lt;code&gt;from_pretrained&lt;/code&gt; in transformers, it is automatically available. We did not add this for any other models uploaded to the organization, thus for those, you need to either add it yourself or simply replace the &lt;code&gt;modeling_mistral.py&lt;/code&gt; &amp;amp; &lt;code&gt;modeling_mixtral.py&lt;/code&gt; files in your transformers installation with &lt;code&gt;scripts/modeling_mistral_gritlm.py&lt;/code&gt; &amp;amp; &lt;code&gt;scripts/modeling_mixtral_gritlm.py&lt;/code&gt;. Note that for models that do not use bidirectional attention or when you do not intend to use the bidirectional attention (e.g. for generation), you don&#39;t need to do anything.&lt;/p&gt; &#xA;&lt;h3&gt;Training&lt;/h3&gt; &#xA;&lt;h4&gt;Data&lt;/h4&gt; &#xA;&lt;p&gt;The repo uses the below format. See &lt;code&gt;training/toy_data.jsonl&lt;/code&gt; for an example.&lt;/p&gt; &#xA;&lt;p&gt;Format:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Embedding data: &lt;code&gt;{&#34;query&#34;: str, &#34;pos&#34;: List[str], &#34;neg&#34;: List[str]}&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Embedding data with instructions that are excluded from the embedding &amp;amp; loss: &lt;code&gt;{&#34;query&#34;: List[str, str], &#34;pos&#34;: List[List[str, str]], &#34;neg&#34;: List[List[str, str]]}&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The 1st element in the inner list is the instruction and the 2nd is the text to embed.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Generative data: &lt;code&gt;{&#34;text&#34;: str}&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Generative data with instructions that are excluded from the loss: &lt;code&gt;{&#34;text&#34;: List[str]}&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;The 1st/3rd/5th.. element is the instruction and the 2nd/4th/6th.. is the response. If you only want single-turn chat then just put two elements, for multi-turn put more.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We release the below datasets:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Embedding: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;MEDI (&lt;a href=&#34;https://hf.co/datasets/GritLM/MEDI&#34;&gt;https://hf.co/datasets/GritLM/MEDI&lt;/a&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;MEDI2 (&lt;a href=&#34;https://hf.co/datasets/GritLM/MEDI2&#34;&gt;https://hf.co/datasets/GritLM/MEDI2&lt;/a&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;MEDI2BGE (&lt;a href=&#34;https://hf.co/datasets/GritLM/MEDI2BGE&#34;&gt;https://hf.co/datasets/GritLM/MEDI2BGE&lt;/a&gt;)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Generative: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://hf.co/datasets/GritLM/tulu2&#34;&gt;https://hf.co/datasets/GritLM/tulu2&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;They are explained in more detail in the paper and its appendix. So to e.g. train a GRIT model on MEDI2 &amp;amp; Tulu2, simply download both via &lt;code&gt;git clone https...&lt;/code&gt; and then place them in the same directory and follow the instructions below to run. Unfortunately, we cannot release the E5S data used for our final models.&lt;/p&gt; &#xA;&lt;h4&gt;Run&lt;/h4&gt; &#xA;&lt;p&gt;Setup:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/ContextualAI/gritlm`&#xA;cd gritlm&#xA;pip install -e .&#xA;cd gritlm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Below are easy examples for getting started:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Embedding model&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;torchrun --nproc_per_node 1 \&#xA;-m training.run \&#xA;--output_dir test_path \&#xA;--model_name_or_path openaccess-ai-collective/tiny-mistral \&#xA;--train_data training/toy_data/toy_data_embedding.jsonl \&#xA;--learning_rate 1e-5 \&#xA;--num_train_epochs 5 \&#xA;--per_device_train_batch_size 2 \&#xA;--dataloader_drop_last True \&#xA;--normalized True \&#xA;--temperature 0.02 \&#xA;--query_max_len 32 \&#xA;--passage_max_len 128 \&#xA;--train_group_size 2 \&#xA;--negatives_cross_device \&#xA;--mode embedding&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Generative model&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;torchrun --nproc_per_node 1 \&#xA;-m training.run \&#xA;--output_dir test_path \&#xA;--model_name_or_path openaccess-ai-collective/tiny-mistral \&#xA;--train_data training/toy_data/toy_data_generative.jsonl \&#xA;--learning_rate 1e-5 \&#xA;--num_train_epochs 5 \&#xA;--per_device_train_batch_size 2 \&#xA;--dataloader_drop_last True \&#xA;--passage_max_len 128 \&#xA;--mode generative&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Unified model (GRIT)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;torchrun --nproc_per_node 1 \&#xA;-m training.run \&#xA;--output_dir test_path \&#xA;--model_name_or_path openaccess-ai-collective/tiny-mistral \&#xA;--train_data training/toy_data \&#xA;--learning_rate 1e-5 \&#xA;--num_train_epochs 5 \&#xA;--per_device_train_batch_size 2 \&#xA;--dataloader_drop_last True \&#xA;--normalized True \&#xA;--temperature 0.02 \&#xA;--query_max_len 32 \&#xA;--passage_max_len 128 \&#xA;--train_group_size 2 \&#xA;--negatives_cross_device \&#xA;--mode unified&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All arguments are explained in &lt;code&gt;training/arguments.py&lt;/code&gt; or the &lt;a href=&#34;https://hf.co/docs/transformers/main/en/main_classes/trainer#transformers.TrainingArguments&#34;&gt;HF TrainingArguments documentation&lt;/a&gt; except for &lt;code&gt;nproc_per_node&lt;/code&gt; which is the number of GPUs per node. For our actual training runs, we use accelerate to easily use multiple nodes and GPUs. The scripts are all in &lt;code&gt;scripts/training&lt;/code&gt;, for example &lt;code&gt;scripts/training/train_gritlm_8x7b.sh&lt;/code&gt; was used for GritLM-8x7B. For models from the ablations, you can check their folder on the huggingface hub which contains a &lt;code&gt;training_args.bin&lt;/code&gt; file with the arguments. You can also check all their arguments on the WandB: &lt;a href=&#34;https://wandb.ai/muennighoff/gritlm&#34;&gt;https://wandb.ai/muennighoff/gritlm&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Evaluation&lt;/h3&gt; &#xA;&lt;h4&gt;Embedding&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd gritlm&#xA;python evaluation/eval_mteb.py \&#xA;--model_name_or_path GritLM/GritLM-7B \&#xA;--task_types Classification,Clustering,PairClassification,Reranking,Retrieval,STS,Summarization \&#xA;--batch_size 32&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a faster way, check &lt;code&gt;scripts/eval_mteb.sh&lt;/code&gt; which submits jobs across multiple GPUs for each dataset.&lt;/p&gt; &#xA;&lt;h4&gt;Generative&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Setup&#xA;# Setup eval for MMLU/GSM8K/BBH/TyDi QA/Alpaca&#xA;git clone https://github.com/Muennighoff/open-instruct.git&#xA;cd open-instruct&#xA;pip install -r requirements.txt&#xA;bash ./scripts/prepare_eval_data.sh&#xA;cd ..&#xA;# Setup eval for HumanEvalPack&#xA;git clone https://github.com/bigcode-project/bigcode-evaluation-harness&#xA;cd bigcode-evaluation-harness&#xA;pip install -e .&#xA;cd ..&#xA;MODEL_PATH=GritLM/gritlm-7b&#xA;# Run all evals except for Alpaca; You may have to change some paths etc.&#xA;bash scripts/generative_eval.sh {path to model}&#xA;# Run Alpaca 1.0&#xA;export OPENAI_API_KEY=YOUR_API_KEY&#xA;python -m eval.alpaca_farm.run_eval \&#xA;--use_vllm \&#xA;--model_name_or_path $MODEL_PATH \&#xA;--tokenizer_name_or_path $MODEL_PATH \&#xA;--save_dir ./ \&#xA;--use_chat_format \&#xA;--chat_formatting_function eval.templates.create_prompt_with_gritlm_chat_format&#xA;# Alpaca 2.0 (not used in the paper)&#xA;python -m eval.alpaca_farm.run_eval \&#xA;--use_vllm \&#xA;--model_name_or_path $MODEL_PATH \&#xA;--tokenizer_name_or_path $MODEL_PATH \&#xA;--save_dir $MODEL_PATH \&#xA;--use_chat_format \&#xA;--chat_formatting_function eval.templates.create_prompt_with_gritlm_chat_format \&#xA;--alpaca2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Known issues&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you train on many nodes + a large model + fsdp, you may encounter timeouts upon checkpoint saving with &lt;code&gt;FULL_STATE_DICT&lt;/code&gt;. For example, training Mixtral on 32 nodes with 8 GPUs each, fails with the below. Usually the main node will finish the saving unless they are all in the same job manager who kills it. Unfortunately increasing the timeout limit seems not possibe? (&lt;a href=&#34;https://discuss.pytorch.org/t/how-to-set-nccl-timeout-to-infinity/146006&#34;&gt;https://discuss.pytorch.org/t/how-to-set-nccl-timeout-to-infinity/146006&lt;/a&gt; ; &lt;a href=&#34;https://github.com/huggingface/accelerate/issues/2236#issuecomment-1864809701&#34;&gt;https://github.com/huggingface/accelerate/issues/2236#issuecomment-1864809701&lt;/a&gt;) So the current solution is just to use less nodes or ensure the saving process does not get killed. Please let us know if you have a better solution.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[dojo-a3-ghpc-9:1]:  what():  [Rank 1] NCCL watchdog thread terminated with exception: [Rank 1] Watchdog caught collective operation timeout: WorkNCCL(SeqNum=683, OpType=_ALLGATHER_BASE, NumelIn=32768512, NumelOut=262148096, Timeout(ms)=600000) ran for 600032 milliseconds before timing out.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add Packing at least for gen, maybe also possible for emb; Need to be careful with the NextTokenLoss&lt;/li&gt; &#xA; &lt;li&gt;QLoRa / LoRa integration is not well-tested&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.LongTensor [20, 2048]] is at version 21; expected version 0 instead. Hint: enable anomaly detection to find the operation that failed to compute its gradient, with torch.autograd.set_detect_anomaly(True).&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you run into the below error when doing multi-node training, try this &lt;a href=&#34;https://github.com/huggingface/transformers/issues/26971#issuecomment-1868137087&#34;&gt;https://github.com/huggingface/transformers/issues/26971#issuecomment-1868137087&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;load_state_dict_into_meta_model&#xA;    set_module_tensor_to_device(model, param_name, param_device, **set_module_kwargs)&#xA;  File &#34;/env/lib/conda/gritlm/lib/python3.9/site-packages/accelerate/utils/modeling.py&#34;, line 317, in set_module_tensor_to_device&#xA;    new_value = value.to(device)&#xA;NotImplementedError: Cannot copy out of meta tensor; no data!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DeepSpeed does not work with &lt;code&gt;--mode unified&lt;/code&gt; and &lt;code&gt;--gradient_accumulation_steps&lt;/code&gt; bigger than 1 (i.e. GradCache) (FSDP is ~equivalent so this is not high prio)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fsdp_use_orig_params: true&lt;/code&gt; in the accelerate config is critical for performance, else it may not converge at all (see comparisons in the wandb runs)&lt;/li&gt; &#xA; &lt;li&gt;If you get the below error where training fails on saving, then upgrade accelerate &amp;amp; transformers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;508 01/06/2024 08:28:40 - INFO - accelerate.utils.fsdp_utils -   Model saved to /data/niklas/gritlm/gritlm_mist_sq2048_medibgetuluv2_tuluformat_8nodes_oldtracc/tmp-checkpoint-500/pytorch_model.bin&#xA;509 01/06/2024 08:30:24 - INFO - accelerate.utils.fsdp_utils -   Saving Optimizer state to /data/niklas/gritlm/gritlm_mist_sq2048_medibgetuluv2_tuluformat_8nodes_oldtracc/tmp-checkpoint-500/optimizer.bin&#xA;510 Traceback (most recent call last):&#xA;511   File &#34;/env/lib/conda/gritlmold/lib/python3.9/runpy.py&#34;, line 197, in _run_module_as_main&#xA;512     return _run_code(code, main_globals, None,&#xA;513   File &#34;/env/lib/conda/gritlmold/lib/python3.9/runpy.py&#34;, line 87, in _run_code&#xA;514     exec(code, run_globals)&#xA;515   File &#34;/home/niklas/gritlm/training/run.py&#34;, line 421, in &amp;lt;module&amp;gt;&#xA;516     main()&#xA;517   File &#34;/home/niklas/gritlm/training/run.py&#34;, line 411, in main&#xA;518     trainer.train()&#xA;519   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/transformers/trainer.py&#34;, line 1537, in train&#xA;520     return inner_training_loop(&#xA;521   File &#34;/home/niklas/gritlm/training/gradcache_trainer.py&#34;, line 962, in _inner_training_loop&#xA;522     self._maybe_log_save_evaluate(tr_loss, model, trial, epoch, ignore_keys_for_eval)&#xA;523   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/transformers/trainer.py&#34;, line 2274, in _maybe_log_save_evaluate&#xA;524     self._save_checkpoint(model, trial, metrics=metrics)&#xA;525   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/transformers/trainer.py&#34;, line 2354, in _save_checkpoint&#xA;526     self._save_optimizer_and_scheduler(staging_output_dir)&#xA;527   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/transformers/trainer.py&#34;, line 2445, in _save_optimizer_and_scheduler&#xA;528     save_fsdp_optimizer(&#xA;529   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/accelerate/utils/fsdp_utils.py&#34;, line 146, in save_fsdp_optimizer&#xA;530     torch.save(optim_state, output_optimizer_file)&#xA;531   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/torch/serialization.py&#34;, line 618, in save&#xA;532     with _open_zipfile_writer(f) as opened_zipfile:&#xA;533   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/torch/serialization.py&#34;, line 492, in _open_zipfile_writer&#xA;534     return container(name_or_buffer)&#xA;535   File &#34;/env/lib/conda/gritlmold/lib/python3.9/site-packages/torch/serialization.py&#34;, line 463, in __init__&#xA;536     super().__init__(torch._C.PyTorchFileWriter(self.name))&#xA;537 RuntimeError: Parent directory /data/niklas/gritlm/gritlm_mist_sq2048_medibgetuluv2_tuluformat_8nodes_oldtracc/tmp-checkpoint-500 does not exist.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If loss is slightly different when changing the number of gradient accumulation steps, this is expected because torch uses weighted mean averaging in its CrossEntropyLoss by default. As the language modeling objective occasionally has the same token being predicted multiple times in one batch, this will result in a different loss when splitting up batches. Meanwhile, for the embedding loss every class id is only predicted once, thus weighted mean is equivalent to mean for embedding (&lt;a href=&#34;https://github.com/pytorch/pytorch/issues/72047&#34;&gt;https://github.com/pytorch/pytorch/issues/72047&lt;/a&gt;; &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/40560&#34;&gt;https://github.com/pytorch/pytorch/issues/40560&lt;/a&gt;; &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/107680&#34;&gt;https://github.com/pytorch/pytorch/issues/107680&lt;/a&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Another reason loss is different when changing the number of processes is that the data order may be different. While all seeds are being set, accelerate.prepare of the data loader in the trainer, sets up the dataloader such that it iterates one sample ahead of time. Thus, on the first iteration it gets two batches for each process instead of one. Somehow, this causes one sample in the first batch to land in the subsequent batch when going from 0 to 8 gpus. I could not figure out why exactly, but investigations are appreciated.&lt;/li&gt; &#xA; &lt;li&gt;Training with fp32 generally converges much faster than with bf16. Changing the allreduce and buffer dtypes to fp32 does not change this (&lt;a href=&#34;https://github.com/NVIDIA/Megatron-LM/issues/502&#34;&gt;https://github.com/NVIDIA/Megatron-LM/issues/502&lt;/a&gt;; &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/106395&#34;&gt;https://github.com/pytorch/pytorch/issues/106395&lt;/a&gt;). However, in the ablations of the paper it actually did not perform better to do fully fp32.&lt;/li&gt; &#xA; &lt;li&gt;torch.compile fails with the below in unified mode (also see &lt;a href=&#34;https://github.com/pytorch/pytorch/issues/111317&#34;&gt;https://github.com/pytorch/pytorch/issues/111317&lt;/a&gt;):&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;from user code:                                                                              &#xA;   File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/transformers/models/mistral/mode&#xA;ling_mistral.py&#34;, line 757, in forward                                                       &#xA;    hidden_states = self.input_layernorm(hidden_states)                                      &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/nn/modules/module.py&#34;, line&#xA; 1527, in _call_impl                                                                         &#xA;    return forward_call(*args, **kwargs)                                                     &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/transformers/models/mistral/model&#xA;ing_mistral.py&#34;, line 89, in forward                                                         &#xA;    return self.weight * hidden_states.to(input_dtype)                                       &#xA;                                                                                             &#xA;Set TORCH_LOGS=&#34;+dynamo&#34; and TORCHDYNAMO_VERBOSE=1 for more information                       &#xA;                                                                                             &#xA;                                                                                             &#xA;You can suppress this exception and fall back to eager by setting:                           &#xA;    import torch._dynamo                                                                     &#xA;    torch._dynamo.config.suppress_errors = True                                              &#xA;                                                                                             &#xA;    example_value = wrap_to_fake_tensor_and_record(                                          &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_dynamo/variables/builder.p&#xA;y&#34;, line 1587, in wrap_to_fake_tensor_and_record                                             &#xA;    fake_e = wrap_fake_exception(                                                            &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_dynamo/utils.py&#34;, line 916&#xA;, in wrap_fake_exception                                                                     &#xA;    return fn()                                                                              &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_dynamo/variables/builder.p&#xA;y&#34;, line 1588, in &amp;lt;lambda&amp;gt;                                                                   &#xA;    lambda: tx.fake_mode.from_tensor(                                                        &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_subclasses/fake_tensor.py&#34;&#xA;, line 1721, in from_tensor                                                                  &#xA;    return self.fake_tensor_converter(                                                       &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_subclasses/fake_tensor.py&#34;&#xA;, line 371, in __call__                                                                      &#xA;    return self.from_real_tensor(                                                            &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_subclasses/fake_tensor.py&#34;&#xA;, line 324, in from_real_tensor                                                              &#xA;    out = self.meta_converter(                                                               &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_subclasses/meta_utils.py&#34;,&#xA; line 591, in __call__                                                                       &#xA;    r = self.meta_tensor(                                                                    &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_subclasses/meta_utils.py&#34;,&#xA; line 307, in meta_tensor                                                                    &#xA;    base = self.meta_tensor(                                                                 &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_subclasses/meta_utils.py&#34;,&#xA; line 478, in meta_tensor                                                                    &#xA;    r.grad = self.meta_tensor(                                                               &#xA;torch._dynamo.exc.InternalTorchDynamoError: attempting to assign a gradient of size &#39;[2726400&#xA;0]&#39; to a tensor of size &#39;[218112000]&#39;. Please ensure that the gradient and the tensor are the&#xA; same size&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;DeepSpeed + FlashAttention2 + Optim &amp;amp; Params offloaded to CPU + DeepSpeed ZeRo3 init fails:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;s. (Triggered internally at /opt/conda/conda-bld/pytorch_1702400412039/work/torch/csrc/t&#xA;ensor/python_tensor.cpp:83.)                                                            &#xA;  total_norm_cuda = get_accelerator().FloatTensor([float(total_norm)])                  &#xA;Invalidate trace cache @ step 1: expected module 1, but got module 2                    &#xA;[E ProcessGroupNCCL.cpp:475] [Rank 1] Watchdog caught collective operation timeout: Work&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If implementing full splitting + GC you may run into&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  File &#34;/home/niklas/gritlm/training/gradcache_trainer.py&#34;, line 630, in _inner_training_loop                     &#xA;    self.accelerator.backward(loss)                                                                              &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/accelerate/accelerator.py&#34;, line 1964, in backward   &#xA;    loss.backward(**kwargs)                                                                                      &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/_tensor.py&#34;, line 492, in backward             &#xA;    torch.autograd.backward(                                                                                     &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/autograd/__init__.py&#34;, line 251, in backward   &#xA;    Variable._execution_engine.run_backward(  # Calls into the C++ engine to run the backward pass               &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/utils/checkpoint.py&#34;, line 1075, in unpack_hook&#xA;    frame.check_recomputed_tensors_match(gid)                                                                    &#xA;  File &#34;/env/lib/conda/gritlmnew/lib/python3.9/site-packages/torch/utils/checkpoint.py&#34;, line 812, in check_recomp&#xA;uted_tensors_match                                                                                               &#xA;    raise CheckpointError(                                                                                       &#xA;torch.utils.checkpoint.CheckpointError: torch.utils.checkpoint: A different number of tensors was saved during th&#xA;e original forward and recomputation.                                                                            &#xA;Number of tensors saved during forward: 47                                                                       &#xA;Number of tensors saved during recomputation: 45                                                                 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Visuals&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Figure 1: &lt;code&gt;visuals/performance.pdf&lt;/code&gt;; &lt;code&gt;visuals/grit_plots.ipynb&lt;/code&gt; / &lt;a href=&#34;https://colab.research.google.com/drive/13MY11ZRtkDjBMWYEXoaDF1nxyRxis7o7?usp=sharing&#34;&gt;colab&lt;/a&gt; &amp;amp; then add in logos via &lt;code&gt;visuals/performance.drawio&lt;/code&gt; that can be opened with &lt;a href=&#34;https://app.diagrams.net/&#34;&gt;https://app.diagrams.net/&lt;/a&gt;, then add blurbs in via &lt;code&gt;visuals/performance.key&lt;/code&gt; that can be opened in Keynote.&lt;/li&gt; &#xA; &lt;li&gt;Figure 2: &lt;code&gt;visuals/octopus.pdf&lt;/code&gt; ; &lt;a href=&#34;https://docs.google.com/drawings/d/1ZAzaX4h2JfJR1ahan0R5nk3Xm17SMquGjhshnBNJOzY/edit?usp=sharing&#34;&gt;https://docs.google.com/drawings/d/1ZAzaX4h2JfJR1ahan0R5nk3Xm17SMquGjhshnBNJOzY/edit?usp=sharing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Figure 3: &lt;code&gt;visuals/format.pdf&lt;/code&gt; ; &lt;a href=&#34;https://docs.google.com/drawings/d/1vaSNvDWy6xBBuC70rI22qdOmymksxqoTYiplGPH22ys/edit?usp=sharing&#34;&gt;https://docs.google.com/drawings/d/1vaSNvDWy6xBBuC70rI22qdOmymksxqoTYiplGPH22ys/edit?usp=sharing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Figure 4: &lt;code&gt;visuals/rag.pdf&lt;/code&gt; ; &lt;a href=&#34;https://docs.google.com/drawings/d/1rv916zpYvBbaS6QxpFP4_6fc4gABcPWc2qZC3NUpz8s/edit?usp=sharing&#34;&gt;https://docs.google.com/drawings/d/1rv916zpYvBbaS6QxpFP4_6fc4gABcPWc2qZC3NUpz8s/edit?usp=sharing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Figure 5/6/7/8: &lt;code&gt;visuals/latency.pdf&lt;/code&gt;/&lt;code&gt;visuals/loss7.pdf&lt;/code&gt;/&lt;code&gt;visuals/loss8x7.pdf&lt;/code&gt;/&lt;code&gt;visuals/embmem.pdf&lt;/code&gt; ; &lt;code&gt;visuals/grit_plots.ipynb&lt;/code&gt; / &lt;a href=&#34;https://colab.research.google.com/drive/13MY11ZRtkDjBMWYEXoaDF1nxyRxis7o7?usp=sharing&#34;&gt;colab&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Other figures &amp;amp; tables are manual, but there are helper scripts, such as &lt;code&gt;scripts/mteb_to_tex.py&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Acknowledgements&lt;/h3&gt; &#xA;&lt;p&gt;The code is inspired by:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Muennighoff/sgpt&#34;&gt;https://github.com/Muennighoff/sgpt&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/FlagOpen/FlagEmbedding&#34;&gt;https://github.com/FlagOpen/FlagEmbedding&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/embeddings-benchmark/mteb&#34;&gt;https://github.com/embeddings-benchmark/mteb&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Citation&lt;/h3&gt; &#xA;&lt;p&gt;If useful please consider citing ðŸ˜Š&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@misc{muennighoff2024generative,&#xA;      title={Generative Representational Instruction Tuning}, &#xA;      author={Niklas Muennighoff and Hongjin Su and Liang Wang and Nan Yang and Furu Wei and Tao Yu and Amanpreet Singh and Douwe Kiela},&#xA;      year={2024},&#xA;      eprint={2402.09906},&#xA;      archivePrefix={arXiv},&#xA;      primaryClass={cs.CL}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>