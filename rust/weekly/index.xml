<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-01T02:03:36Z</updated>
  <subtitle>Weekly Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>influxdata/influxdb</title>
    <updated>2023-10-01T02:03:36Z</updated>
    <id>tag:github.com,2023-10-01:/influxdata/influxdb</id>
    <link href="https://github.com/influxdata/influxdb" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scalable datastore for metrics, events, and real-time analytics&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;InfluxDB Edge&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] On 2023-09-21 this repo changed the default branch from master to main. At the same time, we moved all InfluxDB 2.x development into the main-2.x branch. If you relied on the 2.x codebase in the former master branch, update your tooling to point to main-2.x, which is the new home for any future InfluxDB 2.x development. This branch (main) is now the default branch for this repo and is for development of InfluxDB 3.x.&lt;/p&gt; &#xA; &lt;p&gt;For now, this means that InfluxDB 3.0 and its upstream dependencies are the focus of our open source efforts. We continue to support both the 1.x and 2.x versions of InfluxDB for our customers, but our new development efforts are now focused on 3.x. The remainder of this readme has more details on 3.0 and what you can expect.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;InfluxDB is an open source time series database written in Rust, using Apache Arrow, Apache Parquet, and Apache DataFusion as its foundational building blocks. This latest version (3.x) of InfluxDB focuses on providing a real-time buffer for observational data of all kinds (metrics, events, logs, traces, etc.) that is queryable via SQL or InfluxQL, and persisted in bulk to object storage as Parquet files, which other third-party systems can then use. It is able to run either with a write ahead log or completely off object storage if the write ahead log is disabled (in this mode of operation there is a potential window of data loss for any data buffered that has not yet been persisted to object store).&lt;/p&gt; &#xA;&lt;p&gt;The open source project runs as a standalone system in a single process. If you&#39;re looking for a clustered, distributed time series database with a bunch of enterprise security features, we have a commercial offering available as a managed hosted service or as on-premise software designed to run inside Kubernetes. The distributed version also includes functionality to reorganize the files in object storage for optimal query performance. In the future, we intend to have a commercial version of the single server software that adds fine-grained security, federated query capabilities, file reorganization for query optimization and deletes, and integration with other systems.&lt;/p&gt; &#xA;&lt;h2&gt;Project Status&lt;/h2&gt; &#xA;&lt;p&gt;Currently this project is under active prototype development without documentation or official builds. This README will be updated with getting started details and links to docs when the time comes.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;The scope of this open source InfluxDB 3.0 is different from either InfluxDB 1.x or 2.x. This may change over time, but for now here are the basics of what we have planned:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;InfluxDB 1.x and 2.x HTTP write API (supporting Line Protocol)&lt;/li&gt; &#xA; &lt;li&gt;InfluxDB 1.x HTTP query API (InfluxQL)&lt;/li&gt; &#xA; &lt;li&gt;Flight SQL (query API using SQL)&lt;/li&gt; &#xA; &lt;li&gt;InfluxQL over Flight&lt;/li&gt; &#xA; &lt;li&gt;Data migration tooling for InfluxDB 1.x &amp;amp; 2.x to 3.0&lt;/li&gt; &#xA; &lt;li&gt;InfluxDB 3.0 HTTP write API (a new way to write data with a more expressive data model than 1.x or 2.x)&lt;/li&gt; &#xA; &lt;li&gt;InfluxDB 3.0 HTTP query API (send InfluxQL or SQL queries as an HTTP GET and get back JSON lines, CSV, or pretty print response)&lt;/li&gt; &#xA; &lt;li&gt;Persist event stream (subscribe to the Parquet file persist events, useful for downstream clients to pick up files from object store)&lt;/li&gt; &#xA; &lt;li&gt;Embedded VM (either Python, Javascript, WASM, or some combination thereof) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Individual queries&lt;/li&gt; &#xA;   &lt;li&gt;Triggers on write&lt;/li&gt; &#xA;   &lt;li&gt;On persist (run whatever is being persisted through script)&lt;/li&gt; &#xA;   &lt;li&gt;On schedule&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Bearer token authentication (all or nothing, token is set at startup through env variable, more fine-grained security is outside the scope of the open source effort)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;What this means is that InfluxDB 3.0 can be pointed to as though it is an InfluxDB 1.x server with most of the functionality present. For InfluxDB 2.x users that primarily interact with the database through the InfluxQL query capability, they will also be able to use this database in a similar way. Version 3.0 will not be implementing the rest of the 2.x API natively, although there could be separate processes that could be added on at some later date that would provide that functionality.&lt;/p&gt; &#xA;&lt;h2&gt;Flux&lt;/h2&gt; &#xA;&lt;p&gt;Flux is the custom scripting and query language we developed as part of our effort on InfluxDB 2.0. While we will continue to support Flux for our customers, it is noticeably absent from the description of InfluxDB 3.0. Written in Go, we built Flux hoping it would get broad adoption and empower users to do things with the database that were previously impossible. While we delivered a powerful new way to work with time series data, many users found Flux to be an adoption blocker for the database.&lt;/p&gt; &#xA;&lt;p&gt;We spent years of developer effort on Flux starting in 2018 with a small team of developers. However, the size of the effort, including creating a new language, VM, query planner, parser, optimizer and execution engine, was significant. We ultimately weren’t able to devote the kind of attention we would have liked to more language features, tooling, and overall usability and developer experience. We worked constantly on performance, but because we were building everything from scratch, all the effort was solely on the shoulders of our small team. We think this ultimately kept us from working on the kinds of usability improvements that would have helped Flux get broader adoption.&lt;/p&gt; &#xA;&lt;p&gt;For InfluxDB 3.0 we adopted Apache Arrow DataFusion, an existing query parser, planner, and executor as our core engine. That was in mid-2020, and over the course of the last three years, there have been significant contributions from an active and growing community. While we remain major contributors to the project, it is continuously getting feature enhancements and performance improvements from a worldwide pool of developers. Our efforts on the Flux implementation would simply not be able to keep pace with the much larger group of DataFusion developers.&lt;/p&gt; &#xA;&lt;p&gt;With InfluxDB 3.0 being a ground-up rewrite of the database in a new language (from Go to Rust), we weren’t able to bring the Flux implementation along. For InfluxQL we were able to support it natively by writing a language parser in Rust and then converting InfluxQL queries into logical plans that our new native query engine, Apache Arrow DataFusion, can understand and process. We also had to add new capabilities to the query engine to support some of the time series queries that InfluxQL enables. This is an effort that took a little over a year and is still ongoing. This approach means that the contributions to DataFusion become improvements to InfluxQL as well given it is the underlying engine.&lt;/p&gt; &#xA;&lt;p&gt;Initially, our plan to support Flux in 3.0 was to do so through a lower level API that the database would provide. In our Cloud2 product, Flux processes connect to the InfluxDB 1 &amp;amp; 2 TSM storage engine through a gRPC API. We built support for this in InfluxDB 3.0 and started testing with mirrored production workloads. We quickly found that this interface performed poorly and had unforeseen bugs, eliminating it as a viable option for Flux users to bring their scripts over to 3.0. This is due to the API being designed around the TSM storage engine’s very specific format, which the 3.0 engine is unable to serve up as quickly.&lt;/p&gt; &#xA;&lt;p&gt;We’ll continue to support Flux for our users and customers. But given Flux is a scripting language in addition to being a query language, planner, optimizer, and execution engine, a Rust-native version of it is likely out of reach. And because the surface area of the language is so large, such an effort would be unlikely to yield a version that is compatible enough to run existing Flux queries without modification or rewrites, which would eliminate the point of the effort to begin with.&lt;/p&gt; &#xA;&lt;p&gt;For Flux to have a path forward, we believe the best plan is to update the core engine so that it can use Flight SQL to talk to InfluxDB 3.0. This would make an architecture where independent processes that serve the InfluxDB 2.x query API (i.e. Flux) would be able to convert whatever portion of a Flux script that is a query into a SQL query that gets sent to the InfluxDB 3.0 process with the result being post-processed by the Flux engine.&lt;/p&gt; &#xA;&lt;p&gt;This is likely not a small effort as the Flux engine is built around InfluxDB 2.0&#39;s TSM storage engine and the representation of all data as individual time series. InfluxDB 3.0 doesn&#39;t keep a concept of series so the SQL query would either have to do a bunch of work to return individual series, or the Flux engine would do work with the resulting query response to construct the series. For the moment, we’re focused on improvements to the core SQL and (and by extension InfluxQL) query engine and experience both in InfluxDB 3.0 and DataFusion.&lt;/p&gt; &#xA;&lt;p&gt;We may come back to this effort in the future, but we don’t want to stop the community from self-organizing an effort to bring Flux forward. The Flux runtime and language exists as permissively licensed open source &lt;a href=&#34;https://github.com/InfluxCommunity/flux&#34;&gt;here&lt;/a&gt;. We&#39;ve also created a community fork of Flux where the community can self-organize and move development forward without requiring our code review process. There are already a few community members working on this potential path forward. If you&#39;re interested in helping with this effort, please speak up on this tracked issue.&lt;/p&gt; &#xA;&lt;p&gt;We realize that Flux still has an enthusiastic, if small, user base and we’d like to figure out the best path forward for these users. For now, with our limited resources, we think focusing our efforts on improvements to Apache Arrow DataFusion and InfluxDB 3.0’s usage of it is the best way to serve our users that are willing to convert to either InfluxQL or SQL. In the meantime, we’ll continue to maintain Flux with security and critical fixes for our users and customers.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jaytaph/gosub-browser</title>
    <updated>2023-10-01T02:03:36Z</updated>
    <id>tag:github.com,2023-10-01:/jaytaph/gosub-browser</id>
    <link href="https://github.com/jaytaph/gosub-browser" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A html5 tokenizer / parser that hopefully grow up to be a browser. Discussions at https://github.com/jaytaph/gosub-browser/discussions&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GoSub: Gateway to Optimized Searching and Unlimited Browsing&lt;/h1&gt; &#xA;&lt;p&gt;A feeble attempt on writing a browser and learning rust.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note: code in the main branch is currently not stable and might not even compile.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;                       _     &#xA;                      | |    &#xA;  __ _  ___  ___ _   _| |__  &#xA; / _` |/ _ \/ __| | | | &#39;_ \ &#xA;| (_| | (_) \__ \ |_| | |_) |&#xA; \__, |\___/|___/\__,_|_.__/ &#xA;  __/ |  The Gateway to                    &#xA; |___/   Optimized Searching and &#xA;         Unlimited Browsing                    &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;This repository is part of the GoSub browser project. Currently there is only a single component/repository (this one), but the idea will be that there are many other components that as a whole make up a full-fledged browser. Each of the components can probably function as something standalone (ie: html5 parser, css parser, etc).&lt;/p&gt; &#xA;&lt;p&gt;In the future, this component (html5 parser) will receive through an API a stream of bytes and will output a stream of events. The events will be consumed by the next component and so on, until we can display something in a window/user agent. This could very well be a text-mode browser, but the idea is to have a graphical browser.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;This is a work in progress. The current status is that the parser can parse a few html5 documents, but it is far from ready. The main goal is to be able to parse correctly all the tests in the html5lib-tests repository (&lt;a href=&#34;https://github.com/html5lib/html5lib-tests&#34;&gt;https://github.com/html5lib/html5lib-tests&lt;/a&gt;). As soon as we can do this, we can try and see if we can generate a DOM tree and then we can start thinking about the next component (css parser).&lt;/p&gt; &#xA;&lt;h2&gt;How to build&lt;/h2&gt; &#xA;&lt;p&gt;This project uses cargo (&lt;a href=&#34;https://doc.rust-lang.org/cargo/&#34;&gt;https://doc.rust-lang.org/cargo/&lt;/a&gt;). To build the project, simply run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create the following binaries and libs:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;File&lt;/th&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gosub-engine&lt;/td&gt; &#xA;   &lt;td&gt;lib&lt;/td&gt; &#xA;   &lt;td&gt;The actual html5 parser/tokenizer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gosub-browser&lt;/td&gt; &#xA;   &lt;td&gt;bin&lt;/td&gt; &#xA;   &lt;td&gt;Dummy browser (see below)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;parser_test&lt;/td&gt; &#xA;   &lt;td&gt;bin&lt;/td&gt; &#xA;   &lt;td&gt;A test suite for the parser&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;tokenizer_test&lt;/td&gt; &#xA;   &lt;td&gt;bin&lt;/td&gt; &#xA;   &lt;td&gt;A test suite for the tokenizer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Gosub-engine&lt;/h3&gt; &#xA;&lt;p&gt;This is the actual html5 parser/tokenizer. It is a library that can be used by other projects. It is not a standalone project. It is used by the gosub-browser project.&lt;/p&gt; &#xA;&lt;h3&gt;Gosub-browser&lt;/h3&gt; &#xA;&lt;p&gt;This is a dummy browser. It is not a real browser, it is just a test project to see if the parser/tokenizer is working and tries to parse the given url on the command line:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ gosub-browser https://www.google.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Parser_test&lt;/h3&gt; &#xA;&lt;p&gt;This is a test suite for the parser. It is not a standalone project. It is used by the gosub-engine project. You need to specify the directory to the html5lib-test in order to run, or it will use the default one (./html5lib-tests).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ parser_test /path/to/html5lib-tests&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/windows-drivers-rs</title>
    <updated>2023-10-01T02:03:36Z</updated>
    <id>tag:github.com,2023-10-01:/microsoft/windows-drivers-rs</id>
    <link href="https://github.com/microsoft/windows-drivers-rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Platform that enables Windows driver development in Rust. Developed by Surface.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;windows-drivers-rs&lt;/h1&gt; &#xA;&lt;p&gt;This repo is a collection of Rust crates that enable developers to develop Windows Drivers in Rust. It is the intention to support both WDM and WDF driver development models. This repo contains the following crates:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk-build&#34;&gt;wdk-build&lt;/a&gt;: A library to configure a Cargo build script for binding generation and downstream linking of the WDK (Windows Developer Kit). While this crate is written to be flexible with different WDK releases and different WDF version, it is currently only tested for NI eWDK, KMDF 1.33, UMDF 2.33, and WDM Drivers. There may be missing linker options for older DDKs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk-sys&#34;&gt;wdk-sys&lt;/a&gt;: Direct FFI bindings to APIs available in the Windows Development Kit (WDK). This includes both autogenerated ffi bindings from &lt;code&gt;bindgen&lt;/code&gt;, and also manual re-implementations of macros that bindgen fails to generate.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk&#34;&gt;wdk&lt;/a&gt;: Safe idiomatic bindings to APIs available in the Windows Development Kit (WDK)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk-panic/&#34;&gt;wdk-panic&lt;/a&gt;: Default panic handler implementations for programs built with WDK&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk-alloc&#34;&gt;wdk-alloc&lt;/a&gt;: alloc support for binaries compiled with the Windows Development Kit (WDK)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk-macros&#34;&gt;wdk-macros&lt;/a&gt;: A collection of macros that help make it easier to interact with wdk-sys&#39;s direct bindings. This crate is re-exported via &lt;code&gt;wdk-sys&lt;/code&gt; and crates should typically never need to directly depend on &lt;code&gt;wdk-macros&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To see an example of this repo used to create drivers, see &lt;a href=&#34;https://github.com/microsoft/Windows-rust-driver-samples&#34;&gt;Windows-rust-driver-samples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note: This project is still in early stages of development and is not yet recommended for commercial use. We encourage community experimentation, suggestions and discussions! We will be using our &lt;a href=&#34;https://github.com/microsoft/windows-drivers-rs/discussions&#34;&gt;GitHub Discussions forum&lt;/a&gt; as the main form of engagement with the community!&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a name=&#34;supported-configs&#34;&gt;Supported Configurations&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;a name=&#34;supported-configs&#34;&gt; &lt;/a&gt;&#xA;&lt;p&gt;&lt;a name=&#34;supported-configs&#34;&gt;This project was built with support of WDM, KMDF, and UMDF drivers in mind, as well as Win32 Services. This includes support for all versions of WDF included in WDK 22H2 and newer. Currently, the crates available on &lt;/a&gt;&lt;a href=&#34;https://crates.io&#34;&gt;&lt;code&gt;crates.io&lt;/code&gt;&lt;/a&gt; only support KMDF v1.33, but bindings can be generated for everything else by cloning &lt;code&gt;windows-drivers-rs&lt;/code&gt; and modifying the config specified in &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/crates/wdk-sys/build.rs&#34;&gt;&lt;code&gt;build.rs&lt;/code&gt; of &lt;code&gt;wdk-sys&lt;/code&gt;&lt;/a&gt;. Crates.io support for other WDK configurations is planned in the near future.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Build Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Binding generation via &lt;code&gt;bindgen&lt;/code&gt; requires &lt;code&gt;libclang&lt;/code&gt;. The easiest way to acquire this is via &lt;code&gt;winget&lt;/code&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;winget install LLVM.LLVM&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To execute post-build tasks (ie. &lt;code&gt;inf2cat&lt;/code&gt;, &lt;code&gt;infverif&lt;/code&gt;, etc.), &lt;code&gt;cargo make&lt;/code&gt; is used&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;cargo install --locked cargo-make --no-default-features --features tls-native&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Building programs with the WDK also requires being in a valid WDK environment. The recommended way to do this is to &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/using-the-enterprise-wdk#getting-started&#34;&gt;enter an eWDK developer prompt&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adding windows-drivers-rs to Your Driver Package&lt;/h2&gt; &#xA;&lt;p&gt;The crates in this repository are available from &lt;a href=&#34;https://crates.io&#34;&gt;&lt;code&gt;crates.io&lt;/code&gt;&lt;/a&gt;, but take into account the current limitations outlined in &lt;a href=&#34;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/#supported-configs&#34;&gt;Supported Configurations&lt;/a&gt;. If you need to support a different config, try cloning this repo and using &lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies&#34;&gt;path dependencies&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a new Cargo package with a lib crate:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;cargo new &amp;lt;driver_name&amp;gt; --lib --config&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add dependencies on &lt;code&gt;windows-drivers-rs&lt;/code&gt; crates:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;cd &amp;lt;driver_name&amp;gt;&#xA;cargo add --build wdk-build&#xA;cargo add wdk wdk-sys wdk-alloc wdk-panic&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set the crate type to &lt;code&gt;cdylib&lt;/code&gt; by adding the following snippet to &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]&#xA;crate-type = [&#34;cdylib&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Set crate panic strategy to &lt;code&gt;abort&lt;/code&gt; in &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[profile.dev]&#xA;panic = &#34;abort&#34;&#xA;lto = true # optional setting to enable Link Time Optimizations&#xA;&#xA;[profile.release]&#xA;panic = &#34;abort&#34;&#xA;lto = true # optional setting to enable Link Time Optimizations&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Create a &lt;code&gt;build.rs&lt;/code&gt; and add the following snippet:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn main() -&amp;gt; Result&amp;lt;(), wdk_build::ConfigError&amp;gt; {&#xA;   wdk_build::Config::from_env_auto()?.configure_binary_build();&#xA;   Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Mark your driver as &lt;code&gt;no_std&lt;/code&gt; in &lt;code&gt;lib.rs&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![no_std]&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a panic handler in &lt;code&gt;lib.rs&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(test))]&#xA;extern crate wdk_panic;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a global allocator in &lt;code&gt;lib.rs&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(not(test))]&#xA;use wdk_alloc::WDKAllocator;&#xA;&#xA;#[cfg(not(test))]&#xA;#[global_allocator]&#xA;static GLOBAL_ALLOCATOR: WDKAllocator = WDKAllocator;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a DriverEntry in &lt;code&gt;lib.rs&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use wdk_sys::{&#xA;   DRIVER_OBJECT,&#xA;   NTSTATUS,&#xA;   PCUNICODE_STRING,&#xA;};&#xA;&#xA;#[export_name = &#34;DriverEntry&#34;] // WDF expects a symbol with the name DriverEntry&#xA;pub unsafe extern &#34;system&#34; fn driver_entry(&#xA;   driver: &amp;amp;mut DRIVER_OBJECT,&#xA;   registry_path: PCUNICODE_STRING,&#xA;) -&amp;gt; NTSTATUS {&#xA;   0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Add a &lt;code&gt;Makefile.toml&lt;/code&gt;:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;extend = &#34;.cargo-make-loadscripts/rust-driver-makefile.toml&#34;&#xA;&#xA;[env]&#xA;CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true&#xA;&#xA;[config]&#xA;load_script = &#34;&#34;&#34;&#xA;pwsh.exe -Command &#34;\&#xA;if ($env:CARGO_MAKE_CRATE_IS_WORKSPACE) { return };\&#xA;$cargoMakeURI = &#39;https://raw.githubusercontent.com/microsoft/windows-drivers-rs/main/rust-driver-makefile.toml&#39;;\&#xA;New-Item -ItemType Directory .cargo-make-loadscripts -Force;\&#xA;Invoke-RestMethod -Method GET -Uri $CargoMakeURI -OutFile $env:CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY/.cargo-make-loadscripts/rust-driver-makefile.toml\&#xA;&#34;&#xA;&#34;&#34;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;11&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Add an inx file that matches the name of your &lt;code&gt;cdylib&lt;/code&gt; crate.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the driver:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-pwsh&#34;&gt;cargo make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;A &lt;code&gt;DriverCertificate.cer&lt;/code&gt; file will be generated, and a signed driver package will be available at &lt;code&gt;target/&amp;lt;Cargo profile&amp;gt;/package&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Trademark Notice&lt;/h2&gt; &#xA;&lt;p&gt;Trademarks This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow Microsoft’s Trademark &amp;amp; Brand Guidelines. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party’s policies.&lt;/p&gt;</summary>
  </entry>
</feed>