<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Weekly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-28T01:59:17Z</updated>
  <subtitle>Weekly Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>erebe/wstunnel</title>
    <updated>2024-01-28T01:59:17Z</updated>
    <id>tag:github.com,2024-01-28:/erebe/wstunnel</id>
    <link href="https://github.com/erebe/wstunnel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Tunnel all your traffic over Websocket or HTTP2 - Bypass firewalls/DPI - Static binary available&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/erebe/wstunnel/raw/main/logo_wstunnel.png&#34; alt=&#34;wstunnel logo&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;right&#34;&gt; &lt;a href=&#34;https://ko-fi.com/P5P4QCHMO&#34;&gt;&lt;img src=&#34;https://ko-fi.com/img/githubbutton_sm.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;br&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Summary&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#description&#34;&gt;Description&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#cmd&#34;&gt;Command line&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#release&#34;&gt;Release&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#note&#34;&gt;Note&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#bench&#34;&gt;Benchmark&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#build&#34;&gt;How to build&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Description &lt;a name=&#34;description&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Most of the time when you are using a public network, you are behind some kind of firewall or proxy. One of their purpose is to constrain you to only use certain kind of protocols and consult only a subset of the web. Nowadays, the most widespread protocol is http and is de facto allowed by third party equipment.&lt;/p&gt; &#xA;&lt;p&gt;Wstunnel uses the websocket protocol which is compatible with http in order to bypass firewalls and proxies. Wstunnel allows you to tunnel whatever traffic you want and access whatever resources/site you need.&lt;/p&gt; &#xA;&lt;p&gt;My inspiration came from &lt;a href=&#34;https://www.npmjs.com/package/wstunnel&#34;&gt;this project&lt;/a&gt; but as I don&#39;t want to install npm and nodejs to use this tool, I remade it in &lt;del&gt;Haskell&lt;/del&gt; Rust and improved it.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What to expect:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Good error messages and debug information&lt;/li&gt; &#xA; &lt;li&gt;Static forward and reverse tunneling (TCP, UDP, Unix socket)&lt;/li&gt; &#xA; &lt;li&gt;Dynamic tunneling (TCP, UDP Socks5 proxy and Transparent Proxy)&lt;/li&gt; &#xA; &lt;li&gt;Support for http proxy (when behind one)&lt;/li&gt; &#xA; &lt;li&gt;Support for tls/https server with certificates auto-reload (with embedded self-signed certificate, or your own)&lt;/li&gt; &#xA; &lt;li&gt;Support IPv6&lt;/li&gt; &#xA; &lt;li&gt;Support for Websocket and HTTP2 as transport protocol (websocket is more performant)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Standalone binaries&lt;/strong&gt; (so just cp it where you want) &lt;a href=&#34;https://github.com/erebe/wstunnel/releases&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Note &lt;a name=&#34;note&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;v7.0.0 is a complete rewrite of wstunnel in Rust and is not compatible with previous version. Previous code in Haskell can be found on branch &lt;a href=&#34;https://github.com/erebe/wstunnel/tree/haskell&#34;&gt;https://github.com/erebe/wstunnel/tree/haskell&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;What to expect from previous version:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;More throughput and less jitter due to Haskell GC. Most of you will not care, as it was performant enough already. But you can now saturate a gigabit ethernet card with a single connection&lt;/li&gt; &#xA; &lt;li&gt;Command line is more homogeneous/has better UX. All tunnel can be specified multiple times&lt;/li&gt; &#xA; &lt;li&gt;Tunnel protocol tries to look like normal traffic, to avoid being flagged&lt;/li&gt; &#xA; &lt;li&gt;Support of reverse tunneling&lt;/li&gt; &#xA; &lt;li&gt;New bug, it is a rewrite (╯&#39;□&#39;)╯︵ ┻━┻ ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯&lt;/li&gt; &#xA; &lt;li&gt;Mainly for me to ease the maintenance of the project. I don&#39;t do a lot of haskell nowadays and it was harder for me to keep maintening the project over time, as I get lost in touch of the Haskell ecosystem and new release.&lt;/li&gt; &#xA; &lt;li&gt;Armv7 build (aka raspberry pi), as new version of GHC (Haskell compiler) dropped its support&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Command line &lt;a name=&#34;cmd&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Use the websockets protocol to tunnel {TCP,UDP} traffic&#xA;wsTunnelClient &amp;lt;---&amp;gt; wsTunnelServer &amp;lt;---&amp;gt; RemoteHost&#xA;Use secure connection (wss://) to bypass proxies&#xA;&#xA;Client:&#xA;Usage: wstunnel client [OPTIONS] &amp;lt;ws[s]://wstunnel.server.com[:port]&amp;gt;&#xA;&#xA;Arguments:&#xA;  &amp;lt;ws[s]|http[s]://wstunnel.server.com[:port]&amp;gt;&#xA;          Address of the wstunnel server&#xA;          You can either use websocket or http2 as transport protocol. Use websocket if you are unsure.&#xA;          Example: For websocket with TLS wss://wstunnel.example.com or without ws://wstunnel.example.com&#xA;                   For http2 with TLS https://wstunnel.example.com or without http://wstunnel.example.com&#xA;&#xA;          *WARNING* HTTP2 as transport protocol is harder to make it works because:&#xA;            - If you are behind a (reverse) proxy/CDN they are going to buffer the whole request before forwarding it to the server&#xA;              Obviously, this is not going to work for tunneling traffic&#xA;            - if you have wstunnel behind a reverse proxy, most of them (i.e: nginx) are going to turn http2 request into http1&#xA;              This is not going to work, because http1 does not support streaming naturally&#xA;          The only way to make it works with http2 is to have wstunnel directly exposed to the internet without any reverse proxy in front of it&#xA;&#xA;Options:&#xA;  -L, --local-to-remote &amp;lt;{tcp,udp,socks5,stdio,unix}://[BIND:]PORT:HOST:PORT&amp;gt;&#xA;          Listen on local and forwards traffic from remote. Can be specified multiple times&#xA;          examples:&#xA;          &#39;tcp://1212:google.com:443&#39;      =&amp;gt;       listen locally on tcp on port 1212 and forward to google.com on port 443&#xA;&#xA;          &#39;udp://1212:1.1.1.1:53&#39;          =&amp;gt;       listen locally on udp on port 1212 and forward to cloudflare dns 1.1.1.1 on port 53&#xA;          &#39;udp://1212:1.1.1.1:53?timeout_sec=10&#39;    timeout_sec on udp force close the tunnel after 10sec. Set it to 0 to disable the timeout [default: 30]&#xA;&#xA;          &#39;socks5://[::1]:1212&#39;            =&amp;gt;       listen locally with socks5 on port 1212 and forward dynamically requested tunnel&#xA;&#xA;          &#39;tproxy+tcp://[::1]:1212&#39;        =&amp;gt;       listen locally on tcp on port 1212 as a *transparent proxy* and forward dynamically requested tunnel&#xA;          &#39;tproxy+udp://[::1]:1212?timeout_sec=10&#39;  listen locally on udp on port 1212 as a *transparent proxy* and forward dynamically requested tunnel&#xA;                                                    linux only and requires sudo/CAP_NET_ADMIN&#xA;&#xA;          &#39;stdio://google.com:443&#39;         =&amp;gt;       listen for data from stdio, mainly for `ssh -o ProxyCommand=&#34;wstunnel client -L stdio://%h:%p&#xA;&#xA;          &#39;unix:///tmp/wstunnel.sock:g.com:443&#39; =&amp;gt;  listen for data from unix socket of path /tmp/wstunnel.sock and forward to g.com:443&#xA;ws://localhost:8080&#34; my-server`&#xA;  -R, --remote-to-local &amp;lt;{tcp,udp,socks5,unix}://[BIND:]PORT:HOST:PORT&amp;gt;&#xA;          Listen on remote and forwards traffic from local. Can be specified multiple times.&#xA;          examples:&#xA;          &#39;tcp://1212:google.com:443&#39;      =&amp;gt;     listen on server for incoming tcp cnx on port 1212 and forward to google.com on port 443 from local machine&#xA;          &#39;udp://1212:1.1.1.1:53&#39;          =&amp;gt;     listen on server for incoming udp on port 1212 and forward to cloudflare dns 1.1.1.1 on port 53 from local machine&#xA;          &#39;socks5://[::1]:1212&#39;            =&amp;gt;     listen on server for incoming socks5 request on port 1212 and forward dynamically request from local machine&#xA;          &#39;unix://wstunnel.sock:g.com:443&#39; =&amp;gt;     listen on server for incoming data from unix socket of path wstunnel.sock and forward to g.com:443 from local machine&#xA;      --socket-so-mark &amp;lt;INT&amp;gt;&#xA;          (linux only) Mark network packet with SO_MARK sockoption with the specified value.&#xA;          You need to use {root, sudo, capabilities} to run wstunnel when using this option&#xA;  -c, --connection-min-idle &amp;lt;INT&amp;gt;&#xA;          Client will maintain a pool of open connection to the server, in order to speed up the connection process.&#xA;          This option set the maximum number of connection that will be kept open.&#xA;          This is useful if you plan to create/destroy a lot of tunnel (i.e: with socks5 to navigate with a browser)&#xA;          It will avoid the latency of doing tcp + tls handshake with the server [default: 0] &#xA;      --tls-sni-override &amp;lt;DOMAIN_NAME&amp;gt;&#xA;          Domain name that will be use as SNI during TLS handshake&#xA;          Warning: If you are behind a CDN (i.e: Cloudflare) you must set this domain also in the http HOST header.&#xA;                   or it will be flagged as fishy and your request rejected&#xA;      --tls-verify-certificate&#xA;          Enable TLS certificate verification.&#xA;          Disabled by default. The client will happily connect to any server with self signed certificate.&#xA;  -p, --http-proxy &amp;lt;USER:PASS@HOST:PORT&amp;gt;&#xA;          If set, will use this http proxy to connect to the server&#xA;          [env: HTTP_PROXY=]&#xA;      --http-proxy-login &amp;lt;LOGIN&amp;gt;&#xA;          If set, will use this login to connect to the http proxy. Override the one from --http-proxy&#xA;          [env: WSTUNNEL_HTTP_PROXY_LOGIN=]&#xA;      --http-proxy-password &amp;lt;PASSWORD&amp;gt;&#xA;          If set, will use this password to connect to the http proxy. Override the one from --http-proxy&#xA;          [env: WSTUNNEL_HTTP_PROXY_PASSWORD=]&#xA;  -P, --http-upgrade-path-prefix &amp;lt;HTTP_UPGRADE_PATH_PREFIX&amp;gt;&#xA;          Use a specific prefix that will show up in the http path during the upgrade request.&#xA;          Useful if you need to route requests server side but don&#39;t have vhosts&#xA;&#xA;          [env: WSTUNNEL_HTTP_UPGRADE_PATH_PREFIX=]&#xA;          [default: v1]&#xA;      --http-upgrade-credentials &amp;lt;USER[:PASS]&amp;gt;&#xA;          Pass authorization header with basic auth credentials during the upgrade request.&#xA;          If you need more customization, you can use the http_headers option.&#xA;      --websocket-ping-frequency-sec &amp;lt;seconds&amp;gt;&#xA;          Frequency at which the client will send websocket ping to the server. [default: 30]&#xA;      --websocket-mask-frame&#xA;          Enable the masking of websocket frames. Default is false&#xA;          Enable this option only if you use unsecure (non TLS) websocket server and you see some issues. Otherwise, it is just overhead.&#xA;  -H, --http-headers &amp;lt;HEADER_NAME: HEADER_VALUE&amp;gt;&#xA;          Send custom headers in the upgrade request&#xA;          Can be specified multiple time&#xA;      --http-headers-file &amp;lt;FILE_PATH&amp;gt;&#xA;          Send custom headers in the upgrade request reading them from a file.&#xA;          It overrides http_headers specified from command line.&#xA;          File is read everytime and file format must contains lines with `HEADER_NAME: HEADER_VALUE`&#xA;  -h, --help&#xA;          Print help&#xA;&#xA;Server:&#xA;Usage: wstunnel server [OPTIONS] &amp;lt;ws[s]://0.0.0.0[:port]&amp;gt;&#xA;&#xA;Arguments:&#xA;  &amp;lt;ws[s]://0.0.0.0[:port]&amp;gt;  Address of the wstunnel server to bind to&#xA;                            Example: With TLS wss://0.0.0.0:8080 or without ws://[::]:8080&#xA;                            The server is capable of detecting by itself if the request is Websocket or Http2. So you don&#39;t need to specify it.&#xA;&#xA;Options:&#xA;      --socket-so-mark &amp;lt;INT&amp;gt;&#xA;          (linux only) Mark network packet with SO_MARK sockoption with the specified value.&#xA;          You need to use {root, sudo, capabilities} to run wstunnel when using this option&#xA;      --websocket-ping-frequency-sec &amp;lt;seconds&amp;gt;&#xA;          Frequency at which the server will send websocket ping to client.&#xA;      --websocket-mask-frame&#xA;          Enable the masking of websocket frames. Default is false&#xA;          Enable this option only if you use unsecure (non TLS) websocket server and you see some issues. Otherwise, it is just overhead.&#xA;      --restrict-to &amp;lt;DEST:PORT&amp;gt;&#xA;          Server will only accept connection from the specified tunnel information.&#xA;          Can be specified multiple time&#xA;          Example: --restrict-to &#34;google.com:443&#34; --restrict-to &#34;localhost:22&#34;&#xA;      --dns-resolver &amp;lt;DNS_RESOLVER&amp;gt;&#xA;          Dns resolver to use to lookup ips of domain name&#xA;          This option is not going to work if you use transparent proxy&#xA;          Can be specified multiple time&#xA;          Example:&#xA;           dns://1.1.1.1 for using udp&#xA;           dns+https://1.1.1.1 for using dns over HTTPS&#xA;           dns+tls://8.8.8.8 for using dns over TLS&#xA;          To use libc resolver, use&#xA;           system://0.0.0.0&#xA;  -r, --restrict-http-upgrade-path-prefix &amp;lt;RESTRICT_HTTP_UPGRADE_PATH_PREFIX&amp;gt;&#xA;          Server will only accept connection from if this specific path prefix is used during websocket upgrade.&#xA;          Useful if you specify in the client a custom path prefix and you want the server to only allow this one.&#xA;          The path prefix act as a secret to authenticate clients&#xA;          Disabled by default. Accept all path prefix. Can be specified multiple time&#xA;      --tls-certificate &amp;lt;FILE_PATH&amp;gt;&#xA;          [Optional] Use custom certificate (pem) instead of the default embedded self signed certificate.&#xA;          The certificate will be automatically reloaded if it changes &#xA;      --tls-private-key &amp;lt;FILE_PATH&amp;gt;&#xA;          [Optional] Use a custom tls key (pem, ec, rsa) that the server will use instead of the default embedded one&#xA;          The private key will be automatically reloaded if it changes&#xA;  -h, --help&#xA;          Print help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Release &lt;a name=&#34;release&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Static binaries are available in &lt;a href=&#34;https://github.com/erebe/wstunnel/releases&#34;&gt;release section&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;docker image are available at &lt;a href=&#34;https://github.com/erebe/wstunnel/pkgs/container/wstunnel&#34;&gt;https://github.com/erebe/wstunnel/pkgs/container/wstunnel&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull ghcr.io/erebe/wstunnel:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples &lt;a name=&#34;examples&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#syntax&#34;&gt;Understand command line syntax&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#simple&#34;&gt;Simplest one with socks5 - Good for browsing internet&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#ssh&#34;&gt;Proxy SSH&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#corporate&#34;&gt;Bypass a corporate proxy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#wireguard&#34;&gt;Proxy Wireguard traffic&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#tproxy&#34;&gt;Proxy easily any traffic with transparent proxy (linux only)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#reverse&#34;&gt;Reverse tunneling&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#secure&#34;&gt;How to secure access of your wstunnel server&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#http2&#34;&gt;Use HTTP2 instead of websocket for transport protocol&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/erebe/wstunnel/main/#stealth&#34;&gt;Maximize your stealthiness/Make your traffic discrete&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Understand command line syntax &lt;a name=&#34;syntax&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Wstunnel command line mimic ssh tunnel syntax. You can take reference to &lt;a href=&#34;https://iximiuz.com/en/posts/ssh-tunnels/&#34;&gt;this article&lt;/a&gt;, or this diagram to understand &lt;img src=&#34;https://iximiuz.com/ssh-tunnels/ssh-tunnels.png&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Simplest one &lt;a name=&#34;simple&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;On your remote host, start the wstunnel&#39;s server by typing this command in your terminal&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel server wss://[::]:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a websocket server listening on any interface on port 8080. On the client side use this command to forward traffic through the websocket tunnel&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel client -L socks5://127.0.0.1:8888 --connection-min-idle 5 wss://myRemoteHost:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This command will create a socks5 server listening on port 8888 of the loopback interface and will forward traffic dynamically. &lt;code&gt;connection-min-idle 10&lt;/code&gt; is going an optimization to create a pool of 10 connection connected to the server, to speed-up the establishement of new tunnels.&lt;/p&gt; &#xA;&lt;p&gt;With firefox you can setup a proxy using this tunnel, by setting in networking preferences 127.0.0.1:8888 and selecting socks5 proxy. Be sure to check the option &lt;code&gt;Proxy DNS when using SOCKS v5&lt;/code&gt; for the server to resolve DNS name and not your local machine.&lt;/p&gt; &#xA;&lt;p&gt;or with curl&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -x socks5h://127.0.0.1:8888 http://google.com/&#xA;#Please note h after the 5, it is to avoid curl resolving DNS name locally&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;As proxy command for SSH &lt;a name=&#34;ssh&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You can specify &lt;code&gt;stdio&lt;/code&gt; as source port on the client side if you wish to use wstunnel as part of a proxy command for ssh&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh -o ProxyCommand=&#34;wstunnel client -L stdio://%h:%p ws://myRemoteHost:8080&#34; my-server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;When behind a corporate proxy &lt;a name=&#34;corporate&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;An other useful example is when you want to bypass an http proxy (a corporate proxy for example) The most reliable way to do it is to use wstunnel as described below&lt;/p&gt; &#xA;&lt;p&gt;Start your wstunnel server with tls activated&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel server wss://[::]:443 --restrict-to 127.0.0.1:22&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The server will listen on any interface using port 443 (https) and restrict traffic to be forwarded only to the ssh daemon.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Be aware that the server will use self signed certificate with weak cryptographic algorithm. It was made in order to add the least possible overhead while still being compliant with tls.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Do not rely on wstunnel to protect your privacy, if it is one of your concerns, you should only forwards traffic that is already secure by design (ie: https or vpn traffic)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now on the client side start the client with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel client -L tcp://9999:127.0.0.1:22 -p http://mycorporateproxy:8080 wss://myRemoteHost:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It will start a tcp server on port 9999 that will contact the corporate proxy, negotiate a tls connection with the remote host and forward traffic to the ssh daemon on the remote host.&lt;/p&gt; &#xA;&lt;p&gt;You may now access your server from your local machine on ssh by using&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh -p 9999 login@127.0.0.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Wireguard and wstunnel &lt;a name=&#34;wireguard&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;You have a working wireguard client configuration called &lt;code&gt;wg0.conf&lt;/code&gt;. Let&#39;s say&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Interface]&#xA;Address = 10.200.0.2/32, fd00:cafe::2/128&#xA;PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=&#xA;&#xA;[Peer]&#xA;PublicKey = 9iicV7Stdl/U0RH1BNf3VvlVjaa4Eus6QPEfEz6cR0c=&#xA;AllowedIPs = 0.0.0.0/0, ::/0&#xA;Endpoint = my.server.com:51820&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Start wstunnel server on my.server.com like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wstunnel server --restrict-to localhost:51820 wss://[::]:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;on your local machine start the client like this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wstunnel client -L &#39;udp://51280:localhost:51280?timeout_sec=0&#39; wss://my.server.com:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;change your wireguard client config to something&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Interface]&#xA;Address = 10.200.0.2/32, fd00:cafe::2/128&#xA;PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=&#xA;# Replace by a dns your server has access to&#xA;dns = 8.8.8.8&#xA;# https://github.com/nitred/nr-wg-mtu-finder to find best mtu for you&#xA;MTU = 1400 &#xA;&#xA;[Peer]&#xA;PublicKey = 9iicV7Stdl/U0RH1BNf3VvlVjaa4Eus6QPEfEz6cR0c=&#xA;AllowedIPs = 0.0.0.0/0, ::/0&#xA;# Should target port where wstunnel client is listenning to&#xA;Endpoint = localhost:51820&#xA;# Should not be necessary if you enable wstunnel client websocket ping&#xA;PersistentKeepalive = 20&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add a default route to your server, as your AllowedIps are catch-all, it is to avoid the traffic looping.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo ip route add ip.of.my.server.com dev eth0 via 192.168.0.1&#xA;# replace eth0 (interface) and 192.168.0.1 (router gateway) by the one given by `ip route get ip.of.my.server.com` &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;start your wireguard, and it should be working&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo wg-quick up wg0&#xA;ping 10.200.0.1 # ping another ip of your vpn network&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;FAQ&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Disable default udp tunnel timeout that will auto-close it after 30sec. &lt;code&gt;i.e: udp://1212:127.0.0.1:5201?timeout_sec=0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you see some throughput issue, be sure to lower the MTU of your wireguard interface (you can do it via config file) to something like 1300 or you will endup fragmenting udp packet (due to overhead of other layer) which is always causing issues&lt;/li&gt; &#xA; &lt;li&gt;If wstunnel cannot connect to server while wireguard is on, be sure you have added a static route via your main gateway for the ip of wstunnel server. Else if you forward all the traffic without putting a static route, you will endup looping your traffic wireguard interface -&amp;gt; wstunnel client -&amp;gt; wireguard interface&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Transparent proxy (linux only) &lt;a name=&#34;tproxy&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Transparent proxy allows to easily proxy any program. Start wstunnel with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo wstunnel client -L &#39;tproxy+tcp://1080&#39; -L &#39;tproxy+udp://1080&#39; wss://my.server.com:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;use this project to route traffic seamlessly &lt;a href=&#34;https://github.com/NOBLES5E/cproxy&#34;&gt;https://github.com/NOBLES5E/cproxy&lt;/a&gt;. It works with any program&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cproxy --port 1080 --mode tproxy -- curl https://google.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can even start a new shell, were all your commands will be proxyfied&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cproxy --port 1080 --mode tproxy -- bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Reverse tunneling &lt;a name=&#34;reverse&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Start wstunnel with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo wstunnel client -R &#39;tcp://[::]:8000:localhost:8000&#39; wss://my.server.com:443&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In another terminal, start a simple webserver on your local machine&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 -m http.server&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;From your my.server.com machine/network you can now do&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl http://localhost:8000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;How to secure the access of your wstunnel server &lt;a name=&#34;secure&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Generate a secret, let&#39;s say &lt;code&gt;h3GywpDrP6gJEdZ6xbJbZZVFmvFZDCa4KcRd&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now start you server with the following command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel server --restrict-http-upgrade-path-prefix h3GywpDrP6gJEdZ6xbJbZZVFmvFZDCa4KcRd  wss://[::]:443 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And start your client with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel client --http-upgrade-path-prefix h3GywpDrP6gJEdZ6xbJbZZVFmvFZDCa4KcRd ... wss://myRemoteHost&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now your wstunnel server, will only accept connection if the client specify the correct path prefix during the upgrade request.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Use HTTP2 instead of websocket for the transport protocol &lt;a name=&#34;http2&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Use this only if websocket is blocked by your firewall/proxy. Otherwise, it is less performant than websocket.&lt;/p&gt; &#xA;&lt;p&gt;Start your wstunnel server as usual with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel server wss://[::]:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On the client the only difference is to specify https:// instead of wss://&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wstunnel client -L socks5://127.0.0.1:8888 https://myRemoteHost:8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt; HTTP2 as transport protocol is harder to make it works because:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you are behind a (reverse) proxy/CDN they may buffer the whole request before forwarding it to the server. Cloudflare is doing that, and obviously, this is not going to work for tunneling traffic&lt;/li&gt; &#xA; &lt;li&gt;if you have wstunnel behind a reverse proxy, most of them (i.e: nginx) are going to turn http2 request into http1 This is not going to work, because http1 does not support streaming naturally&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The only way to make it works with HTTP2 is to have wstunnel server directly exposed to the internet without any reverse proxy in front of it&lt;/p&gt; &#xA;&lt;p&gt;In addition, you may also want to play with the request headers (i.e: content-length and content-type) to make it looks like normal traffic to bypass your firewall/proxy. Some firewall may not like to see request with content-length not set, or with content-type set to application/octet-stream&lt;/p&gt; &#xA;&lt;h3&gt;Maximize your stealthiness/Make your traffic discrete &lt;a name=&#34;stealth&#34;&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use wstunnel with TLS activated (wss://) and use your own certificate &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Embedded certificate is self-signed and are the same for everyone, so can be easily fingerprinted/flagged&lt;/li&gt; &#xA;   &lt;li&gt;Use valid certificate (i.e: with Let&#39;s Encrypt), self-signed certificate are suspicious&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Use a custom http path prefix (see &lt;code&gt;--http-upgrade-path-prefix&lt;/code&gt; option) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;To avoid having the same url than every other wstunnel user&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Change your tls-sni-override to a domain is known to be allowed (i.e: google.com, baidu.com, etc...) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;this will not work if your wstunnel server is behind a reverse proxy (i.e: Nginx, Cloudflare, HAProxy, ...)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Benchmark &lt;a name=&#34;bench&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/erebe/wstunnel/assets/854278/6e3580b0-c4f8-449e-881e-64d1df56b0ce&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to Build &lt;a name=&#34;build&#34;&gt;&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Install the Rust &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;https://www.rust-lang.org/tools/install&lt;/a&gt; or if you are a believer&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and run those commands at the root of the project&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo build&#xA;target/debug/wstunnel ...&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>bestinslot-xyz/OPI</title>
    <updated>2024-01-28T01:59:17Z</updated>
    <id>tag:github.com,2024-01-28:/bestinslot-xyz/OPI</id>
    <link href="https://github.com/bestinslot-xyz/OPI" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Open Protocol Indexer, OPI, is the best-in-slot open-source indexing client for meta-protocols on Bitcoin.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;OPI - Open Protocol Indexer&lt;/h1&gt; &#xA;&lt;p&gt;Open Protocol Indexer, OPI, is the &lt;strong&gt;best-in-slot open-source indexing client&lt;/strong&gt; for &lt;strong&gt;meta-protocols&lt;/strong&gt; on Bitcoin. OPI uses a fork of &lt;strong&gt;ord 0.14.0&lt;/strong&gt; with minimal changes to maintain compatibility with base layer rules. Also, OPI is built with &lt;strong&gt;modularity&lt;/strong&gt; in mind. The main indexer indexes all text/json inscriptions and modules can extend it with different meta-protocols. All modules in OPI have been built with &lt;strong&gt;reorg protection&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently OPI has modules for &lt;strong&gt;BRC-20&lt;/strong&gt;, &lt;strong&gt;Bitmap&lt;/strong&gt; and &lt;strong&gt;SNS&lt;/strong&gt;, we&#39;ll add new modules over time. Pull Requests are welcomed for other meta-protocols.&lt;/p&gt; &#xA;&lt;h2&gt;Main Meta-Protocol Indexer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Meta-Protocol indexer&lt;/strong&gt; sits in the core of OPI. It indexes &lt;strong&gt;all json/text inscriptions&lt;/strong&gt; and their &lt;strong&gt;first 2 transfers&lt;/strong&gt;. Transfer limit can be changed via &lt;code&gt;INDEX_TX_LIMIT&lt;/code&gt; variable in ord fork. This limit has been added since there are some UTXO&#39;s with a lot of inscription content and their movement floods transfers tables. Also, base indexing of most protocols only needs the first two transfers. BRC-20 becomes invalid after 2 hops, bitmap and SNS validity is calculated at inscription time.&lt;/p&gt; &#xA;&lt;h2&gt;BRC-20 Indexer / API&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;BRC-20 Indexer&lt;/strong&gt; is the first module of OPI. It follows the official protocol rules hosted &lt;a href=&#34;https://layer1.gitbook.io/layer1-foundation/protocols/brc-20/indexing&#34;&gt;here&lt;/a&gt;. BRC-20 Indexer saves all historical balance changes and all BRC-20 events.&lt;/p&gt; &#xA;&lt;p&gt;In addition to indexing all events, it also calculates a block hash and cumulative hash of all events for easier db comparison. Here&#39;s the pseudocode for hash calculation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## Calculation starts at block 767430 which is the first inscription block&#xA;&#xA;EVENT_SEPARATOR = &#39;|&#39;&#xA;## max_supply, limit_per_mint, amount decimal count is the same as ticker&#39;s decimals (no trailing dot if decimals is 0)&#xA;## tickers are lowercase&#xA;for event in block_events:&#xA;  if event is &#39;deploy-inscribe&#39;:&#xA;    block_str += &#39;deploy-inscribe;&amp;lt;inscr_id&amp;gt;;&amp;lt;deployer_pkscript&amp;gt;;&amp;lt;ticker&amp;gt;;&amp;lt;max_supply&amp;gt;;&amp;lt;decimals&amp;gt;;&amp;lt;limit_per_mint&amp;gt;&#39; + EVENT_SEPARATOR&#xA;  if event is &#39;mint-inscribe&#39;:&#xA;    block_str += &#39;mint-inscribe;&amp;lt;inscr_id&amp;gt;;&amp;lt;minter_pkscript&amp;gt;;&amp;lt;ticker&amp;gt;;&amp;lt;amount&amp;gt;&#39; + EVENT_SEPARATOR&#xA;  if event is &#39;transfer-inscribe&#39;:&#xA;    block_str += &#39;transfer-inscribe;&amp;lt;inscr_id&amp;gt;;&amp;lt;source_pkscript&amp;gt;;&amp;lt;ticker&amp;gt;;&amp;lt;amount&amp;gt;&#39; + EVENT_SEPARATOR&#xA;  if event is &#39;transfer-transfer&#39;:&#xA;    ## if sent as fee, sent_pkscript is empty&#xA;    block_str += &#39;transfer-transfer;&amp;lt;inscr_id&amp;gt;;&amp;lt;source_pkscript&amp;gt;;&amp;lt;sent_pkscript&amp;gt;;&amp;lt;ticker&amp;gt;;&amp;lt;amount&amp;gt;&#39; + EVENT_SEPARATOR&#xA;&#xA;if block_str.last is EVENT_SEPARATOR: block_str.remove_last()&#xA;block_hash = sha256_hex(block_str)&#xA;## for first block last_cumulative_hash is empty&#xA;cumulative_hash = sha256_hex(last_cumulative_hash + block_hash)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There is an optional block event hash reporting system pointed at &lt;a href=&#34;https://api.opi.network/report_block&#34;&gt;https://api.opi.network/report_block&lt;/a&gt;. If you want to exclude your node from this, just change &lt;code&gt;REPORT_TO_INDEXER&lt;/code&gt; variable in &lt;code&gt;brc20_index/.env&lt;/code&gt;. Also change &lt;code&gt;REPORT_NAME&lt;/code&gt; to differentiate your node from others.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;BRC-20 API&lt;/strong&gt; exposes activity on block (block events), balance of a wallet at the start of a given height, current balance of a wallet, block hash and cumulative hash at a given block and hash of all current balances.&lt;/p&gt; &#xA;&lt;h2&gt;Bitmap Indexer / API&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bitmap Indexer&lt;/strong&gt; is the second module of OPI. It follows the official protocol rules hosted &lt;a href=&#34;https://gitbook.bitmap.land/ruleset/district-ruleset&#34;&gt;here&lt;/a&gt;. Bitmap Indexer saves all bitmap-number inscription-id pairs.&lt;/p&gt; &#xA;&lt;p&gt;In addition to indexing all pairs, it also calculates a block hash and cumulative hash of all events for easier db comparison. Here&#39;s the pseudocode for hash calculation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## Calculation starts at block 767430 which is the first inscription block&#xA;&#xA;EVENT_SEPARATOR = &#39;|&#39;&#xA;for bitmap in new_bitmaps_in_block:&#xA;  block_str += &#39;inscribe;&amp;lt;inscr_id&amp;gt;;&amp;lt;bitmap_number&amp;gt;&#39; + EVENT_SEPARATOR&#xA;&#xA;if block_str.last is EVENT_SEPARATOR: block_str.remove_last()&#xA;block_hash = sha256_hex(block_str)&#xA;## for first block last_cumulative_hash is empty&#xA;cumulative_hash = sha256_hex(last_cumulative_hash + block_hash)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bitmap API&lt;/strong&gt; exposes block hash and cumulative hash at a given block, hash of all bitmaps and inscription_id of a given bitmap.&lt;/p&gt; &#xA;&lt;h2&gt;SNS Indexer / API&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;SNS Indexer&lt;/strong&gt; is the third module of OPI. It follows the official protocol rules hosted &lt;a href=&#34;https://docs.satsnames.org/sats-names/sns-spec/index-names&#34;&gt;here&lt;/a&gt;. SNS Indexer saves all name, domain, inscription-id and namespace, inscription-id tuples.&lt;/p&gt; &#xA;&lt;p&gt;In addition to indexing all tuples, it also calculates a block hash and cumulative hash of all events for easier db comparison. Here&#39;s the pseudocode for hash calculation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## Calculation starts at block 767430 which is the first inscription block&#xA;&#xA;EVENT_SEPARATOR = &#39;|&#39;&#xA;for event in new_events_in_block:&#xA;  if event is &#39;name-registration&#39;:&#xA;    ## name is the full name, domain is the part afler dot&#xA;    block_str += &#39;register;&amp;lt;inscr_id&amp;gt;;&amp;lt;name&amp;gt;;&amp;lt;domain&amp;gt;&#39; + EVENT_SEPARATOR&#xA;  elif event is &#39;namespace-registration&#39;:&#xA;    block_str += &#39;ns_register;&amp;lt;inscr_id&amp;gt;;&amp;lt;namespace&amp;gt;&#39; + EVENT_SEPARATOR&#xA;&#xA;if block_str.last is EVENT_SEPARATOR: block_str.remove_last()&#xA;block_hash = sha256_hex(block_str)&#xA;## for first block last_cumulative_hash is empty&#xA;cumulative_hash = sha256_hex(last_cumulative_hash + block_hash)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;SNS API&lt;/strong&gt; exposes block hash and cumulative hash at a given block, hash of all registered names, id number and domain of a given name, id number and name tuples of a domain, and all registered namespaces endpoints.&lt;/p&gt; &#xA;&lt;h1&gt;Setup&lt;/h1&gt; &#xA;&lt;p&gt;For detailed installation guides:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ubuntu: &lt;a href=&#34;https://raw.githubusercontent.com/bestinslot-xyz/OPI/main/INSTALL.ubuntu.md&#34;&gt;installation guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Windows: &lt;a href=&#34;https://raw.githubusercontent.com/bestinslot-xyz/OPI/main/INSTALL.windows.md&#34;&gt;installation guide&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;OPI uses PostgreSQL as DB. Before running the indexer, setup a PostgreSQL DB (all modules can write into different databases as well as use a single database).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Build ord:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ord; cargo build --release;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Install node modules&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/main_index; npm install;&#xA;cd ../brc20_api; npm install;&#xA;cd ../bitmap_api; npm install;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Optional:&lt;/em&gt; Remove the following from &lt;code&gt;modules/main_index/node_modules/bitcoinjs-lib/src/payments/p2tr.js&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (pubkey &amp;amp;&amp;amp; pubkey.length) {&#xA;  if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))&#xA;    throw new TypeError(&#39;Invalid pubkey for p2tr&#39;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, it cannot decode some addresses such as &lt;code&gt;512057cd4cfa03f27f7b18c2fe45fe2c2e0f7b5ccb034af4dec098977c28562be7a2&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Install python libraries&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip3 install python-dotenv;&#xA;pip3 install psycopg2-binary;&#xA;python3 -m pip install json5 stdiomask;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Setup .env files and DBs&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;reset_init.py&lt;/code&gt; in each module folder (preferrably start from main_index) to initialise .env file, databases and set other necessary files.&lt;/p&gt; &#xA;&lt;h1&gt;(Optional) Restore from an online backup for faster initial sync&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install dependencies: (pbzip2 is optional but greatly impoves decompress speed)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update&#xA;sudo apt install postgresql-client-common&#xA;sudo apt install postgresql-client-14&#xA;sudo apt install pbzip2&#xA;&#xA;python3 -m pip install boto3&#xA;python3 -m pip install tqdm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Run &lt;code&gt;restore.py&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/;&#xA;python3 restore.py;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Run&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Main Meta-Protocol Indexer&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/main_index;&#xA;node index.js;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;BRC-20 Indexer&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/brc20_index;&#xA;python3 brc20_index.py;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;BRC-20 API&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/brc20_api;&#xA;node api.js;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bitmap Indexer&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/bitmap_index;&#xA;python3 bitmap_index.py;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Bitmap API&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/bitmap_api;&#xA;node api.js;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;SNS Indexer&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/sns_index;&#xA;python3 sns_index.py;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;SNS API&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd modules/sns_api;&#xA;node api.js;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Update&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Stop all indexers and apis (preferably starting from main indexer but actually the order shouldn&#39;t matter)&lt;/li&gt; &#xA; &lt;li&gt;Update the repo (&lt;code&gt;git pull&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Recompile ord (&lt;code&gt;cd ord; cargo build --release;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Re-run all indexers and apis&lt;/li&gt; &#xA; &lt;li&gt;If rebuild is needed, you can run &lt;code&gt;restore.py&lt;/code&gt; for faster initial sync&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>yuezk/GlobalProtect-openconnect</title>
    <updated>2024-01-28T01:59:17Z</updated>
    <id>tag:github.com,2024-01-28:/yuezk/GlobalProtect-openconnect</id>
    <link href="https://github.com/yuezk/GlobalProtect-openconnect" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A GlobalProtect VPN client for Linux, written in Rust, based on OpenConnect and Tauri, supports SSO with MFA, Yubikey, etc.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GlobalProtect-openconnect&lt;/h1&gt; &#xA;&lt;p&gt;A GUI for GlobalProtect VPN, based on OpenConnect, supports the SSO authentication method. Inspired by &lt;a href=&#34;https://github.com/dlenski/gp-saml-gui&#34;&gt;gp-saml-gui&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;300&#34; src=&#34;https://github.com/yuezk/GlobalProtect-openconnect/assets/3297602/9242df9c-217d-42ab-8c21-8f9f69cd4eb5&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Better Linux support&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support both CLI and GUI&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support both SSO and non-SSO authentication&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support the FIDO2 authentication (e.g., YubiKey)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support authentication using default browser&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support multiple portals&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support gateway selection&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support auto-connect on startup&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Support system tray icon&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;CLI&lt;/h3&gt; &#xA;&lt;p&gt;The CLI version is always free and open source in this repo. It has almost the same features as the GUI version.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Usage: gpclient [OPTIONS] &amp;lt;COMMAND&amp;gt;&#xA;&#xA;Commands:&#xA;  connect     Connect to a portal server&#xA;  disconnect  Disconnect from the server&#xA;  launch-gui  Launch the GUI&#xA;  help        Print this message or the help of the given subcommand(s)&#xA;&#xA;Options:&#xA;      --fix-openssl        Get around the OpenSSL `unsafe legacy renegotiation` error&#xA;      --ignore-tls-errors  Ignore the TLS errors&#xA;  -h, --help               Print help&#xA;  -V, --version            Print version&#xA;&#xA;See &#39;gpclient help &amp;lt;command&amp;gt;&#39; for more information on a specific command.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;GUI&lt;/h3&gt; &#xA;&lt;p&gt;The GUI version is also available after you installed it. You can launch it from the application menu or run &lt;code&gt;gpclient launch-gui&lt;/code&gt; in the terminal.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Note]&lt;/p&gt; &#xA; &lt;p&gt;The GUI version is partially open source. Its background service is open sourced in this repo as &lt;a href=&#34;https://raw.githubusercontent.com/yuezk/GlobalProtect-openconnect/main/apps/gpservice/&#34;&gt;gpservice&lt;/a&gt;. The GUI part is a wrapper of the background service, which is not open sourced.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Note]&lt;/p&gt; &#xA; &lt;p&gt;This instruction is for the 2.x version. The 1.x version is still available on the &lt;a href=&#34;https://github.com/yuezk/GlobalProtect-openconnect/tree/1.x&#34;&gt;1.x&lt;/a&gt; branch, you can build it from the source code by following the instructions in the &lt;code&gt;README.md&lt;/code&gt; file.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Warning]&lt;/p&gt; &#xA; &lt;p&gt;The client requires &lt;code&gt;openconnect &amp;gt;= 8.20&lt;/code&gt;, please make sure you have it installed, you can check it with &lt;code&gt;openconnect --version&lt;/code&gt;. Installing the client from PPA will automatically install the required version of &lt;code&gt;openconnect&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Debian/Ubuntu based distributions&lt;/h3&gt; &#xA;&lt;h4&gt;Install from PPA&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:yuezk/globalprotect-openconnect&#xA;sudo apt-get update&#xA;sudo apt-get install globalprotect-openconnect&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!Note]&lt;/p&gt; &#xA; &lt;p&gt;For Linux Mint, you might need to import the GPG key with: &lt;code&gt;sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 7937C393082992E5D6E4A60453FC26B43838D761&lt;/code&gt; if you encountered an error &lt;code&gt;gpg: keyserver receive failed: General error&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h4&gt;Install from deb package&lt;/h4&gt; &#xA;&lt;p&gt;Download the latest deb package from &lt;a href=&#34;https://github.com/yuezk/GlobalProtect-openconnect/releases&#34;&gt;releases&lt;/a&gt; page. Then install it with &lt;code&gt;dpkg&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo dpkg -i globalprotect-openconnect_*.deb&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Arch Linux / Manjaro&lt;/h3&gt; &#xA;&lt;h4&gt;Install from AUR&lt;/h4&gt; &#xA;&lt;p&gt;Install from AUR: &lt;a href=&#34;https://aur.archlinux.org/packages/globalprotect-openconnect-git/&#34;&gt;globalprotect-openconnect-git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yay -S globalprotect-openconnect-git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install from package&lt;/h4&gt; &#xA;&lt;p&gt;Download the latest package from &lt;a href=&#34;https://github.com/yuezk/GlobalProtect-openconnect/releases&#34;&gt;releases&lt;/a&gt; page. Then install it with &lt;code&gt;pacman&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pacman -U globalprotect-openconnect-*.pkg.tar.zst&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fedora/OpenSUSE/CentOS/RHEL&lt;/h3&gt; &#xA;&lt;h4&gt;Install from COPR&lt;/h4&gt; &#xA;&lt;p&gt;The package is available on &lt;a href=&#34;https://copr.fedorainfracloud.org/coprs/yuezk/globalprotect-openconnect/&#34;&gt;COPR&lt;/a&gt; for various RPM-based distributions. You can install it with the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;sudo dnf copr enable yuezk/globalprotect-openconnect&#xA;sudo dnf install globalprotect-openconnect&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Install from OBS&lt;/h4&gt; &#xA;&lt;p&gt;The package is also available on &lt;a href=&#34;https://build.opensuse.org/package/show/home:yuezk/globalprotect-openconnect&#34;&gt;OBS&lt;/a&gt; for various RPM-based distributions. You can follow the instructions &lt;a href=&#34;https://software.opensuse.org//download.html?project=home%3Ayuezk&amp;amp;package=globalprotect-openconnect&#34;&gt;on this page&lt;/a&gt; to install it.&lt;/p&gt; &#xA;&lt;h4&gt;Install from RPM package&lt;/h4&gt; &#xA;&lt;p&gt;Download the latest RPM package from &lt;a href=&#34;https://github.com/yuezk/GlobalProtect-openconnect/releases&#34;&gt;releases&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h3&gt;Other distributions&lt;/h3&gt; &#xA;&lt;p&gt;The project depends on &lt;code&gt;openconnect &amp;gt;= 8.20&lt;/code&gt;, &lt;code&gt;webkit2gtk&lt;/code&gt;, &lt;code&gt;libsecret&lt;/code&gt;, &lt;code&gt;libayatana-appindicator&lt;/code&gt; or &lt;code&gt;libappindicator-gtk3&lt;/code&gt;. You can install them first and then download the latest binary release (i.e., &lt;code&gt;*.bin.tar.gz&lt;/code&gt;) from &lt;a href=&#34;https://github.com/yuezk/GlobalProtect-openconnect/releases&#34;&gt;releases&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yuezk/GlobalProtect-openconnect/main/LICENSE&#34;&gt;License&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;GPLv3&lt;/p&gt;</summary>
  </entry>
</feed>