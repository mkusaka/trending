<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Monthly Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-01T02:08:38Z</updated>
  <subtitle>Monthly Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>uutils/coreutils</title>
    <updated>2023-11-01T02:08:38Z</updated>
    <id>tag:github.com,2023-11-01:/uutils/coreutils</id>
    <link href="https://github.com/uutils/coreutils" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Cross-platform Rust rewrite of the GNU coreutils&lt;/p&gt;&lt;hr&gt;&lt;div class=&#34;oranda-hide&#34;&gt; &#xA; &lt;div align=&#34;center&#34;&gt; &#xA;  &lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/uutils/coreutils/main/docs/src/logo.svg?sanitize=true&#34; alt=&#34;uutils logo&#34;&gt;&lt;/p&gt; &#xA;  &lt;h1&gt;uutils coreutils&lt;/h1&gt; &#xA;  &lt;p&gt;&lt;a href=&#34;https://crates.io/crates/coreutils&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/coreutils.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/wQVJbvJ&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/discord-join-7289DA.svg?logo=discord&amp;amp;longCache=true&amp;amp;style=flat&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/uutils/coreutils/raw/main/LICENSE&#34;&gt;&lt;img src=&#34;http://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://deps.rs/repo/github/uutils/coreutils&#34;&gt;&lt;img src=&#34;https://deps.rs/repo/github/uutils/coreutils/status.svg?sanitize=true&#34; alt=&#34;dependency status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;  &lt;p&gt;&lt;a href=&#34;https://codecov.io/gh/uutils/coreutils&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/uutils/coreutils/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;CodeCov&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/MSRV-1.70.0-brightgreen&#34; alt=&#34;MSRV&#34;&gt;&lt;/p&gt; &#xA; &lt;/div&gt; &#xA; &lt;hr&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;uutils coreutils is a cross-platform reimplementation of the GNU coreutils in &lt;a href=&#34;http://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;. While all programs have been implemented, some options might be missing or different behavior might be experienced.&lt;/p&gt; &#xA;&lt;div class=&#34;oranda-hide&#34;&gt; &#xA; &lt;p&gt;To install it:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo install coreutils&#xA;~/.cargo/bin/coreutils&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/div&gt; &#xA;&lt;!-- markdownlint-disable-next-line MD026 --&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;p&gt;uutils aims to be a drop-in replacement for the GNU utils. Differences with GNU are treated as bugs.&lt;/p&gt; &#xA;&lt;p&gt;uutils aims to work on as many platforms as possible, to be able to use the same utils on Linux, Mac, Windows and other platforms. This ensures, for example, that scripts can be easily transferred between platforms.&lt;/p&gt; &#xA;&lt;div class=&#34;oranda-hide&#34;&gt; &#xA; &lt;h2&gt;Documentation&lt;/h2&gt; &#xA; &lt;p&gt;uutils has both user and developer documentation available:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://uutils.github.io/coreutils/book/&#34;&gt;User Manual&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;a href=&#34;https://uutils.github.io/dev/coreutils/&#34;&gt;Developer Documentation&lt;/a&gt; (currently offline, you can use docs.rs in the meantime)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Both can also be generated locally, the instructions for that can be found in the &lt;a href=&#34;https://github.com/uutils/uutils.github.io&#34;&gt;coreutils docs&lt;/a&gt; repository.&lt;/p&gt; &#xA; &lt;!-- ANCHOR: build (this mark is needed for mdbook) --&gt; &#xA; &lt;h2&gt;Requirements&lt;/h2&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Rust (&lt;code&gt;cargo&lt;/code&gt;, &lt;code&gt;rustc&lt;/code&gt;)&lt;/li&gt; &#xA;  &lt;li&gt;GNU Make (optional)&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;h3&gt;Rust Version&lt;/h3&gt; &#xA; &lt;p&gt;uutils follows Rust&#39;s release channels and is tested against stable, beta and nightly. The current Minimum Supported Rust Version (MSRV) is &lt;code&gt;1.70.0&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;h2&gt;Building&lt;/h2&gt; &#xA; &lt;p&gt;There are currently two methods to build the uutils binaries: either Cargo or GNU Make.&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;Building the full package, including all documentation, requires both Cargo and Gnu Make on a Unix platform.&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;For either method, we first need to fetch the repository:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/uutils/coreutils&#xA;cd coreutils&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h3&gt;Cargo&lt;/h3&gt; &#xA; &lt;p&gt;Building uutils using Cargo is easy because the process is the same as for every other Rust program:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This command builds the most portable common core set of uutils into a multicall (BusyBox-type) binary, named &#39;coreutils&#39;, on most Rust-supported platforms.&lt;/p&gt; &#xA; &lt;p&gt;Additional platform-specific uutils are often available. Building these expanded sets of uutils for a platform (on that platform) is as simple as specifying it as a feature:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo build --release --features macos&#xA;# or ...&#xA;cargo build --release --features windows&#xA;# or ...&#xA;cargo build --release --features unix&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you don&#39;t want to build every utility available on your platform into the final binary, you can also specify which ones you want to build manually. For example:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo build --features &#34;base32 cat echo rm&#34; --no-default-features&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;If you don&#39;t want to build the multicall binary and would prefer to build the utilities as individual binaries, that is also possible. Each utility is contained in its own package within the main repository, named &#34;uu_UTILNAME&#34;. To build individual utilities, use cargo to build just the specific packages (using the &lt;code&gt;--package&lt;/code&gt; [aka &lt;code&gt;-p&lt;/code&gt;] option). For example:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo build -p uu_base32 -p uu_cat -p uu_echo -p uu_rm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h3&gt;GNU Make&lt;/h3&gt; &#xA; &lt;p&gt;Building using &lt;code&gt;make&lt;/code&gt; is a simple process as well.&lt;/p&gt; &#xA; &lt;p&gt;To simply build all available utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;In release mode:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make PROFILE=release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To build all but a few of the available utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make SKIP_UTILS=&#39;UTILITY_1 UTILITY_2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To build only a few of the available utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make UTILS=&#39;UTILITY_1 UTILITY_2&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h2&gt;Installation&lt;/h2&gt; &#xA; &lt;h3&gt;Install with Cargo&lt;/h3&gt; &#xA; &lt;p&gt;Likewise, installing can simply be done using:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo install --path . --locked&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;This command will install uutils into Cargo&#39;s &lt;em&gt;bin&lt;/em&gt; folder (&lt;em&gt;e.g.&lt;/em&gt; &lt;code&gt;$HOME/.cargo/bin&lt;/code&gt;).&lt;/p&gt; &#xA; &lt;p&gt;This does not install files necessary for shell completion or manpages. For manpages or shell completion to work, use &lt;code&gt;GNU Make&lt;/code&gt; or see &lt;code&gt;Manually install shell completions&lt;/code&gt;/&lt;code&gt;Manually install manpages&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;h3&gt;Install with GNU Make&lt;/h3&gt; &#xA; &lt;p&gt;To install all available utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To install using &lt;code&gt;sudo&lt;/code&gt; switch &lt;code&gt;-E&lt;/code&gt; must be used:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo -E make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To install all but a few of the available utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make SKIP_UTILS=&#39;UTILITY_1 UTILITY_2&#39; install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To install only a few of the available utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make UTILS=&#39;UTILITY_1 UTILITY_2&#39; install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To install every program with a prefix (e.g. uu-echo uu-cat):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make PROG_PREFIX=PREFIX_GOES_HERE install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To install the multicall binary:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make MULTICALL=y install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Set install parent directory (default value is /usr/local):&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# DESTDIR is also supported&#xA;make PREFIX=/my/path install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;Installing with &lt;code&gt;make&lt;/code&gt; installs shell completions for all installed utilities for &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt;. Completions for &lt;code&gt;elvish&lt;/code&gt; and &lt;code&gt;powershell&lt;/code&gt; can also be generated; See &lt;code&gt;Manually install shell completions&lt;/code&gt;.&lt;/p&gt; &#xA; &lt;h3&gt;Manually install shell completions&lt;/h3&gt; &#xA; &lt;p&gt;The &lt;code&gt;coreutils&lt;/code&gt; binary can generate completions for the &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;elvish&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt;, &lt;code&gt;powershell&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt; shells. It prints the result to stdout.&lt;/p&gt; &#xA; &lt;p&gt;The syntax is:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo run completion &amp;lt;utility&amp;gt; &amp;lt;shell&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;So, to install completions for &lt;code&gt;ls&lt;/code&gt; on &lt;code&gt;bash&lt;/code&gt; to &lt;code&gt;/usr/local/share/bash-completion/completions/ls&lt;/code&gt;, run:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo run completion ls bash &amp;gt; /usr/local/share/bash-completion/completions/ls&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h3&gt;Manually install manpages&lt;/h3&gt; &#xA; &lt;p&gt;To generate manpages, the syntax is:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo run manpage &amp;lt;utility&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;So, to install the manpage for &lt;code&gt;ls&lt;/code&gt; to &lt;code&gt;/usr/local/share/man/man1/ls.1&lt;/code&gt; run:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo run manpage ls &amp;gt; /usr/local/share/man/man1/ls.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h2&gt;Un-installation&lt;/h2&gt; &#xA; &lt;p&gt;Un-installation differs depending on how you have installed uutils. If you used Cargo to install, use Cargo to uninstall. If you used GNU Make to install, use Make to uninstall.&lt;/p&gt; &#xA; &lt;h3&gt;Uninstall with Cargo&lt;/h3&gt; &#xA; &lt;p&gt;To uninstall uutils:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo uninstall uutils&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;h3&gt;Uninstall with GNU Make&lt;/h3&gt; &#xA; &lt;p&gt;To uninstall all utilities:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To uninstall every program with a set prefix:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make PROG_PREFIX=PREFIX_GOES_HERE uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To uninstall the multicall binary:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make MULTICALL=y uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;To uninstall from a custom parent directory:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# DESTDIR is also supported&#xA;make PREFIX=/my/path uninstall&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;!-- ANCHOR_END: build (this mark is needed for mdbook) --&gt; &#xA; &lt;h2&gt;GNU test suite compatibility&lt;/h2&gt; &#xA; &lt;p&gt;Below is the evolution of how many GNU tests uutils passes. A more detailed breakdown of the GNU test results of the main branch can be found &lt;a href=&#34;https://uutils.github.io/coreutils/book/test_coverage.html&#34;&gt;in the user manual&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;See &lt;a href=&#34;https://github.com/uutils/coreutils/issues/3336&#34;&gt;https://github.com/uutils/coreutils/issues/3336&lt;/a&gt; for the main meta bugs (many are missing).&lt;/p&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/uutils/coreutils-tracking/raw/main/gnu-results.png?raw=true&#34; alt=&#34;Evolution over time&#34;&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;!-- close oranda-hide div --&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;To contribute to uutils, please see &lt;a href=&#34;https://raw.githubusercontent.com/uutils/coreutils/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;uutils is licensed under the MIT License - see the &lt;code&gt;LICENSE&lt;/code&gt; file for details&lt;/p&gt; &#xA;&lt;p&gt;GNU Coreutils is licensed under the GPL 3.0 or later.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>matter-labs/zksync-era</title>
    <updated>2023-11-01T02:08:38Z</updated>
    <id>tag:github.com,2023-11-01:/matter-labs/zksync-era</id>
    <link href="https://github.com/matter-labs/zksync-era" rel="alternate"></link>
    <summary type="html">&lt;p&gt;zkSync era&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;zkSync Era: A ZK Rollup For Scaling Ethereum&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://zksync.io/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/eraLogo.png&#34; alt=&#34;Logo&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;zkSync Era is a layer 2 rollup that uses zero-knowledge proofs to scale Ethereum without compromising on security or decentralization. Since it&#39;s EVM compatible (Solidity/Vyper), 99% of Ethereum projects can redeploy without refactoring or re-auditing a single line of code. zkSync Era also uses an LLVM-based compiler that will eventually let developers write smart contracts in C++, Rust and other popular languages.&lt;/p&gt; &#xA;&lt;h2&gt;Knowledge Index&lt;/h2&gt; &#xA;&lt;p&gt;The following questions will be answered by the following resources:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Question&lt;/th&gt; &#xA;   &lt;th&gt;Resource&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;What do I need to develop the project locally?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/docs/development.md&#34;&gt;development.md&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;How can I set up my dev environment?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/docs/setup-dev.md&#34;&gt;setup-dev.md&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;How can I run the project?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/docs/launch.md&#34;&gt;launch.md&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;What is the logical project structure and architecture?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/docs/architecture.md&#34;&gt;architecture.md&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Where can I find developer docs?&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://v2-docs.zksync.io/dev/&#34;&gt;docs&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Policies&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/SECURITY.md&#34;&gt;Security policy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/CONTRIBUTING.md&#34;&gt;Contribution policy&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;zkSync Era is distributed under the terms of either&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apache License, Version 2.0, (&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; or &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;MIT license (&lt;a href=&#34;https://raw.githubusercontent.com/matter-labs/zksync-era/main/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; or &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your option.&lt;/p&gt; &#xA;&lt;h2&gt;Official Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://zksync.io/&#34;&gt;Website&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/matter-labs&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/zksync/credo&#34;&gt;ZK Credo&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/zksync&#34;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://twitter.com/zkSyncDevs&#34;&gt;Twitter for Devs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://join.zksync.dev/&#34;&gt;Discord&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://zksync.mirror.xyz/&#34;&gt;Mirror&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;zkSync Era has been through lots of testing and audits. Although it is live, it is still in alpha state and will go through more audits and bug bounty programs. We would love to hear our community&#39;s thoughts and suggestions about it! It is important to state that forking it now can potentially lead to missing important security updates, critical features, and performance improvements.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>cloudflare/quiche</title>
    <updated>2023-11-01T02:08:38Z</updated>
    <id>tag:github.com,2023-11-01:/cloudflare/quiche</id>
    <link href="https://github.com/cloudflare/quiche" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ðŸ¥§ Savoury implementation of the QUIC transport protocol and HTTP/3&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cloudflare/quiche/master/quiche.svg?sanitize=true&#34; alt=&#34;quiche&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/quiche&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/quiche.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/quiche&#34;&gt;&lt;img src=&#34;https://docs.rs/quiche/badge.svg?sanitize=true&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/BSD-2-Clause&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/license/cloudflare/quiche.svg?sanitize=true&#34; alt=&#34;license&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/cloudflare/quiche/stable.yml?branch=master&#34; alt=&#34;build&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.quic.tech/quiche/&#34;&gt;quiche&lt;/a&gt; is an implementation of the QUIC transport protocol and HTTP/3 as specified by the &lt;a href=&#34;https://quicwg.org/&#34;&gt;IETF&lt;/a&gt;. It provides a low level API for processing QUIC packets and handling connection state. The application is responsible for providing I/O (e.g. sockets handling) as well as an event loop with support for timers.&lt;/p&gt; &#xA;&lt;p&gt;For more information on how quiche came about and some insights into its design you can read a &lt;a href=&#34;https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/&#34;&gt;post&lt;/a&gt; on Cloudflare&#39;s blog that goes into some more detail.&lt;/p&gt; &#xA;&lt;h2&gt;Who uses quiche?&lt;/h2&gt; &#xA;&lt;h3&gt;Cloudflare&lt;/h3&gt; &#xA;&lt;p&gt;quiche powers Cloudflare edge network&#39;s &lt;a href=&#34;https://blog.cloudflare.com/http3-the-past-present-and-future/&#34;&gt;HTTP/3 support&lt;/a&gt;. The &lt;a href=&#34;https://cloudflare-quic.com&#34;&gt;cloudflare-quic.com&lt;/a&gt; website can be used for testing and experimentation.&lt;/p&gt; &#xA;&lt;h3&gt;Android&lt;/h3&gt; &#xA;&lt;p&gt;Android&#39;s DNS resolver uses quiche to &lt;a href=&#34;https://security.googleblog.com/2022/07/dns-over-http3-in-android.html&#34;&gt;implement DNS over HTTP/3&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;curl&lt;/h3&gt; &#xA;&lt;p&gt;quiche can be &lt;a href=&#34;https://github.com/curl/curl/raw/master/docs/HTTP3.md#quiche-version&#34;&gt;integrated into curl&lt;/a&gt; to provide support for HTTP/3.&lt;/p&gt; &#xA;&lt;h3&gt;NGINX (unofficial)&lt;/h3&gt; &#xA;&lt;p&gt;quiche can be &lt;a href=&#34;https://raw.githubusercontent.com/cloudflare/quiche/master/nginx/&#34;&gt;integrated into NGINX&lt;/a&gt; using an unofficial patch to provide support for HTTP/3.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Command-line apps&lt;/h3&gt; &#xA;&lt;p&gt;Before diving into the quiche API, here are a few examples on how to use the quiche tools provided as part of the &lt;a href=&#34;https://raw.githubusercontent.com/cloudflare/quiche/master/apps/&#34;&gt;quiche-apps&lt;/a&gt; crate.&lt;/p&gt; &#xA;&lt;p&gt;After cloning the project according to the command mentioned in the &lt;a href=&#34;https://raw.githubusercontent.com/cloudflare/quiche/master/#building&#34;&gt;building&lt;/a&gt; section, the client can be run as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo run --bin quiche-client -- https://cloudflare-quic.com/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;while the server can be run as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo run --bin quiche-server -- --cert apps/src/bin/cert.crt --key apps/src/bin/cert.key&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(note that the certificate provided is self-signed and should not be used in production)&lt;/p&gt; &#xA;&lt;p&gt;Use the &lt;code&gt;--help&lt;/code&gt; command-line flag to get a more detailed description of each tool&#39;s options.&lt;/p&gt; &#xA;&lt;h3&gt;Configuring connections&lt;/h3&gt; &#xA;&lt;p&gt;The first step in establishing a QUIC connection using quiche is creating a &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Config.html&#34;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; object:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut config = quiche::Config::new(quiche::PROTOCOL_VERSION)?;&#xA;config.set_application_protos(&amp;amp;[b&#34;example-proto&#34;]);&#xA;&#xA;// Additional configuration specific to application and use case...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Config.html&#34;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; object controls important aspects of the QUIC connection such as QUIC version, ALPN IDs, flow control, congestion control, idle timeout and other properties or features.&lt;/p&gt; &#xA;&lt;p&gt;QUIC is a general-purpose transport protocol and there are several configuration properties where there is no reasonable default value. For example, the permitted number of concurrent streams of any particular type is dependent on the application running over QUIC, and other use-case specific concerns.&lt;/p&gt; &#xA;&lt;p&gt;quiche defaults several properties to zero, applications most likely need to set these to something else to satisfy their needs using the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_streams_bidi&#34;&gt;&lt;code&gt;set_initial_max_streams_bidi()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_streams_uni&#34;&gt;&lt;code&gt;set_initial_max_streams_uni()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_data&#34;&gt;&lt;code&gt;set_initial_max_data()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_bidi_local&#34;&gt;&lt;code&gt;set_initial_max_stream_data_bidi_local()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_bidi_remote&#34;&gt;&lt;code&gt;set_initial_max_stream_data_bidi_remote()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/quiche/latest/quiche/struct.Config.html#method.set_initial_max_stream_data_uni&#34;&gt;&lt;code&gt;set_initial_max_stream_data_uni()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.quic.tech/quiche/struct.Config.html&#34;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; also holds TLS configuration. This can be changed by mutators on the an existing object, or by constructing a TLS context manually and creating a configuration using &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Config.html#method.with_boring_ssl_ctx_builder&#34;&gt;&lt;code&gt;with_boring_ssl_ctx_builder()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;A configuration object can be shared among multiple connections.&lt;/p&gt; &#xA;&lt;h3&gt;Connection setup&lt;/h3&gt; &#xA;&lt;p&gt;On the client-side the &lt;a href=&#34;https://docs.quic.tech/quiche/fn.connect.html&#34;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; utility function can be used to create a new connection, while &lt;a href=&#34;https://docs.quic.tech/quiche/fn.accept.html&#34;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; is for servers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Client connection.&#xA;let conn = quiche::connect(Some(&amp;amp;server_name), &amp;amp;scid, local, peer, &amp;amp;mut config)?;&#xA;&#xA;// Server connection.&#xA;let conn = quiche::accept(&amp;amp;scid, None, local, peer, &amp;amp;mut config)?;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Handling incoming packets&lt;/h3&gt; &#xA;&lt;p&gt;Using the connection&#39;s &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.recv&#34;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; method the application can process incoming packets that belong to that connection from the network:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let to = socket.local_addr().unwrap();&#xA;&#xA;loop {&#xA;    let (read, from) = socket.recv_from(&amp;amp;mut buf).unwrap();&#xA;&#xA;    let recv_info = quiche::RecvInfo { from, to };&#xA;&#xA;    let read = match conn.recv(&amp;amp;mut buf[..read], recv_info) {&#xA;        Ok(v) =&amp;gt; v,&#xA;&#xA;        Err(e) =&amp;gt; {&#xA;            // An error occurred, handle it.&#xA;            break;&#xA;        },&#xA;    };&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generating outgoing packets&lt;/h3&gt; &#xA;&lt;p&gt;Outgoing packet are generated using the connection&#39;s &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.send&#34;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; method instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;loop {&#xA;    let (write, send_info) = match conn.send(&amp;amp;mut out) {&#xA;        Ok(v) =&amp;gt; v,&#xA;&#xA;        Err(quiche::Error::Done) =&amp;gt; {&#xA;            // Done writing.&#xA;            break;&#xA;        },&#xA;&#xA;        Err(e) =&amp;gt; {&#xA;            // An error occurred, handle it.&#xA;            break;&#xA;        },&#xA;    };&#xA;&#xA;    socket.send_to(&amp;amp;out[..write], &amp;amp;send_info.to).unwrap();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When packets are sent, the application is responsible for maintaining a timer to react to time-based connection events. The timer expiration can be obtained using the connection&#39;s &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.timeout&#34;&gt;&lt;code&gt;timeout()&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let timeout = conn.timeout();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The application is responsible for providing a timer implementation, which can be specific to the operating system or networking framework used. When a timer expires, the connection&#39;s &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.on_timeout&#34;&gt;&lt;code&gt;on_timeout()&lt;/code&gt;&lt;/a&gt; method should be called, after which additional packets might need to be sent on the network:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Timeout expired, handle it.&#xA;conn.on_timeout();&#xA;&#xA;// Send more packets as needed after timeout.&#xA;loop {&#xA;    let (write, send_info) = match conn.send(&amp;amp;mut out) {&#xA;        Ok(v) =&amp;gt; v,&#xA;&#xA;        Err(quiche::Error::Done) =&amp;gt; {&#xA;            // Done writing.&#xA;            break;&#xA;        },&#xA;&#xA;        Err(e) =&amp;gt; {&#xA;            // An error occurred, handle it.&#xA;            break;&#xA;        },&#xA;    };&#xA;&#xA;    socket.send_to(&amp;amp;out[..write], &amp;amp;send_info.to).unwrap();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Pacing&lt;/h4&gt; &#xA;&lt;p&gt;It is recommended that applications &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9002#section-7.7&#34;&gt;pace&lt;/a&gt; sending of outgoing packets to avoid creating packet bursts that could cause short-term congestion and losses in the network.&lt;/p&gt; &#xA;&lt;p&gt;quiche exposes pacing hints for outgoing packets through the [&lt;code&gt;at&lt;/code&gt;] field of the [&lt;code&gt;SendInfo&lt;/code&gt;] structure that is returned by the &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.send&#34;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; method. This field represents the time when a specific packet should be sent into the network.&lt;/p&gt; &#xA;&lt;p&gt;Applications can use these hints by artificially delaying the sending of packets through platform-specific mechanisms (such as the &lt;a href=&#34;https://man7.org/linux/man-pages/man8/tc-etf.8.html&#34;&gt;&lt;code&gt;SO_TXTIME&lt;/code&gt;&lt;/a&gt; socket option on Linux), or custom methods (for example by using user-space timers).&lt;/p&gt; &#xA;&lt;h3&gt;Sending and receiving stream data&lt;/h3&gt; &#xA;&lt;p&gt;After some back and forth, the connection will complete its handshake and will be ready for sending or receiving application data.&lt;/p&gt; &#xA;&lt;p&gt;Data can be sent on a stream by using the &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.stream_send&#34;&gt;&lt;code&gt;stream_send()&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;if conn.is_established() {&#xA;    // Handshake completed, send some data on stream 0.&#xA;    conn.stream_send(0, b&#34;hello&#34;, true)?;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The application can check whether there are any readable streams by using the connection&#39;s &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.readable&#34;&gt;&lt;code&gt;readable()&lt;/code&gt;&lt;/a&gt; method, which returns an iterator over all the streams that have outstanding data to read.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://docs.quic.tech/quiche/struct.Connection.html#method.stream_recv&#34;&gt;&lt;code&gt;stream_recv()&lt;/code&gt;&lt;/a&gt; method can then be used to retrieve the application data from the readable stream:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;if conn.is_established() {&#xA;    // Iterate over readable streams.&#xA;    for stream_id in conn.readable() {&#xA;        // Stream is readable, read until there&#39;s no more data.&#xA;        while let Ok((read, fin)) = conn.stream_recv(stream_id, &amp;amp;mut buf) {&#xA;            println!(&#34;Got {} bytes on stream {}&#34;, read, stream_id);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;HTTP/3&lt;/h3&gt; &#xA;&lt;p&gt;The quiche &lt;a href=&#34;https://docs.quic.tech/quiche/h3/index.html&#34;&gt;HTTP/3 module&lt;/a&gt; provides a high level API for sending and receiving HTTP requests and responses on top of the QUIC transport protocol.&lt;/p&gt; &#xA;&lt;p&gt;Have a look at the [quiche/examples/] directory for more complete examples on how to use the quiche API, including examples on how to use quiche in C/C++ applications (see below for more information).&lt;/p&gt; &#xA;&lt;h2&gt;Calling quiche from C/C++&lt;/h2&gt; &#xA;&lt;p&gt;quiche exposes a &lt;a href=&#34;https://github.com/cloudflare/quiche/raw/master/quiche/include/quiche.h&#34;&gt;thin C API&lt;/a&gt; on top of the Rust API that can be used to more easily integrate quiche into C/C++ applications (as well as in other languages that allow calling C APIs via some form of FFI). The C API follows the same design of the Rust one, modulo the constraints imposed by the C language itself.&lt;/p&gt; &#xA;&lt;p&gt;When running &lt;code&gt;cargo build&lt;/code&gt;, a static library called &lt;code&gt;libquiche.a&lt;/code&gt; will be built automatically alongside the Rust one. This is fully stand-alone and can be linked directly into C/C++ applications.&lt;/p&gt; &#xA;&lt;p&gt;Note that in order to enable the FFI API, the &lt;code&gt;ffi&lt;/code&gt; feature must be enabled (it is disabled by default), by passing &lt;code&gt;--features ffi&lt;/code&gt; to &lt;code&gt;cargo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;quiche requires Rust 1.66 or later to build. The latest stable Rust release can be installed using &lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Once the Rust build environment is setup, the quiche source code can be fetched using git:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ git clone --recursive https://github.com/cloudflare/quiche&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and then built using cargo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo build --examples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;cargo can also be used to run the testsuite:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;a href=&#34;https://boringssl.googlesource.com/boringssl/&#34;&gt;BoringSSL&lt;/a&gt;, which is used to implement QUIC&#39;s cryptographic handshake based on TLS, needs to be built and linked to quiche. This is done automatically when building quiche using cargo, but requires the &lt;code&gt;cmake&lt;/code&gt; command to be available during the build process. On Windows you also need &lt;a href=&#34;https://www.nasm.us/&#34;&gt;NASM&lt;/a&gt;. The &lt;a href=&#34;https://github.com/google/boringssl/raw/master/BUILDING.md&#34;&gt;official BoringSSL documentation&lt;/a&gt; has more details.&lt;/p&gt; &#xA;&lt;p&gt;In alternative you can use your own custom build of BoringSSL by configuring the BoringSSL directory with the &lt;code&gt;QUICHE_BSSL_PATH&lt;/code&gt; environment variable:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ QUICHE_BSSL_PATH=&#34;/path/to/boringssl&#34; cargo build --examples&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building for Android&lt;/h3&gt; &#xA;&lt;p&gt;Building quiche for Android (NDK version 19 or higher, 21 recommended), can be done using &lt;a href=&#34;https://docs.rs/crate/cargo-ndk&#34;&gt;cargo-ndk&lt;/a&gt; (v2.0 or later).&lt;/p&gt; &#xA;&lt;p&gt;First the &lt;a href=&#34;https://developer.android.com/ndk&#34;&gt;Android NDK&lt;/a&gt; needs to be installed, either using Android Studio or directly, and the &lt;code&gt;ANDROID_NDK_HOME&lt;/code&gt; environment variable needs to be set to the NDK installation path, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ export ANDROID_NDK_HOME=/usr/local/share/android-ndk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then the Rust toolchain for the Android architectures needed can be installed as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that the minimum API level is 21 for all target architectures.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.rs/crate/cargo-ndk&#34;&gt;cargo-ndk&lt;/a&gt; (v2.0 or later) also needs to be installed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo install cargo-ndk&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally the quiche library can be built using the following procedure. Note that the &lt;code&gt;-t &amp;lt;architecture&amp;gt;&lt;/code&gt; and &lt;code&gt;-p &amp;lt;NDK version&amp;gt;&lt;/code&gt; options are mandatory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo ndk -t arm64-v8a -p 21 -- build --features ffi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/cloudflare/quiche/raw/master/tools/android/build_android_ndk19.sh&#34;&gt;build_android_ndk19.sh&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;Building for iOS&lt;/h3&gt; &#xA;&lt;p&gt;To build quiche for iOS, you need the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install Xcode command-line tools. You can install them with Xcode or with the following command:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ xcode-select --install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the Rust toolchain for iOS architectures:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ rustup target add aarch64-apple-ios x86_64-apple-ios&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install &lt;code&gt;cargo-lipo&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo install cargo-lipo&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To build libquiche, run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo lipo --features ffi&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ cargo lipo --features ffi --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;iOS build is tested in Xcode 10.1 and Xcode 11.2.&lt;/p&gt; &#xA;&lt;h3&gt;Building Docker images&lt;/h3&gt; &#xA;&lt;p&gt;In order to build the Docker images, simply run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ make docker-build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can find the quiche Docker images on the following Docker Hub repositories:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/repository/docker/cloudflare/quiche&#34;&gt;cloudflare/quiche&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://hub.docker.com/repository/docker/cloudflare/quiche-qns&#34;&gt;cloudflare/quiche-qns&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;latest&lt;/code&gt; tag will be updated whenever quiche master branch updates.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;cloudflare/quiche&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Provides a server and client installed in /usr/local/bin.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;cloudflare/quiche-qns&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Provides the script to test quiche within the &lt;a href=&#34;https://github.com/marten-seemann/quic-interop-runner&#34;&gt;quic-interop-runner&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Copyright&lt;/h2&gt; &#xA;&lt;p&gt;Copyright (C) 2018-2019, Cloudflare, Inc.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/cloudflare/quiche/tree/master/COPYING&#34;&gt;COPYING&lt;/a&gt; for the license.&lt;/p&gt;</summary>
  </entry>
</feed>