<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-28T01:39:12Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>darthdeus/comfy</title>
    <updated>2023-09-28T01:39:12Z</updated>
    <id>tag:github.com,2023-09-28:/darthdeus/comfy</id>
    <link href="https://github.com/darthdeus/comfy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Comfy is a fun 2D game engine built in Rust. It&#39;s designed to be opinionated, productive, and easy to use.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://comfyengine.org&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/darthdeus/comfy/master/assets/comfy-mid.png&#34; alt=&#34;Comfy&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/comfy&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/comfy.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/darthdeus/comfy#license&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT%2FApache-blue.svg?sanitize=true&#34; alt=&#34;MIT/Apache 2.0&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/comfy&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/d/comfy.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/darthdeus/comfy/actions&#34;&gt;&lt;img src=&#34;https://github.com/darthdeus/comfy/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Rust&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/M8hySjuG48&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/720719762031771680.svg?label=&amp;amp;logo=discord&amp;amp;logoColor=ffffff&amp;amp;color=7389D8&amp;amp;labelColor=6A7EC2&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;What is &lt;code&gt;comfy&lt;/code&gt;?&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;If you&#39;re new here, check out the &lt;a href=&#34;https://comfyengine.org/blog/first/&#34;&gt;comfy announcement on our blog&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;NOTE: The &lt;code&gt;master&lt;/code&gt; branch now has breaking changes, and a &lt;code&gt;v0.2.0&lt;/code&gt; release will happen relatively soon. In order to not delay this too much more things will break on &lt;code&gt;master&lt;/code&gt; before that happens. The changes should be for the better, and the book will be fully updated with a changelog &amp;amp; migration tips. Most should remain unaffected, unless you relied on some undocumented features :)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Comfy is a fun 2D game engine built in Rust. It&#39;s designed to be opinionated, productive, and easy to use. It uses &lt;a href=&#34;https://wgpu.rs/&#34;&gt;wgpu&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/winit/latest/winit/&#34;&gt;winit&lt;/a&gt;, which makes it cross-platform, currently supporting Windows, Linux, MacOS and WASM. Inspired by macroquad, Raylib, Love2D and many others, it is designed to just work and fill most of the common use cases.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: comfy is currently under heavy development. While there are games already being made using comfy, the API is not yet stable and breaking changes will happen. If you want to use comfy for your game you may be forced to dig into the source code and possibly tweak things manually. That being said, the source code is designed to be simple and modifiable. If you want to make a game jam game comfy is definitely mature enough.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;comfy&lt;/code&gt; is named comfy, because it is very comfy to use.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use comfy::*;&#xA;&#xA;simple_game!(&#34;Nice red circle&#34;, update);&#xA;&#xA;fn update(_c: &amp;amp;mut EngineContext) {&#xA;    draw_circle(vec2(0.0, 0.0), 0.5, RED, 0);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The ultimate goal of comfy is to do the obvious thing as simply as possible without unnecessray ceremony. If something is annoying to use, it is a bug that should be fixed. We&#39;re not necessarily aiming at beginner friendliness, but rather productive and ergonomic APIs. If you&#39;re a beginner, comfy should be easy to pick up, but it might not be as polished as some of the other alternatives. The goal of comfy is ultimately not polish, cleanliness of API, clean design, type safety, extensibility, or maximum features. It&#39;s an engine that gets out of your way so you can make your game.&lt;/p&gt; &#xA;&lt;p&gt;There is nothing that fundamentally prevents comfy from becoming a 3D engine, but the last thing we want is to try to fight rend3 or bevy in terms of PBR accuracy or skeletal animations. Comfy is not fighting against Unreal Engine 5. It would be nice if &lt;a href=&#34;https://store.steampowered.com/app/824600/HROT/&#34;&gt;simple&lt;/a&gt; &lt;a href=&#34;https://store.steampowered.com/app/1055540/A_Short_Hike/&#34;&gt;stylized&lt;/a&gt; &lt;a href=&#34;https://store.steampowered.com/app/219890/Antichamber/&#34;&gt;3D&lt;/a&gt; &lt;a href=&#34;https://store.steampowered.com/app/219890/Antichamber/&#34;&gt;games&lt;/a&gt; were ultimately possible, but we want to get all of the basic building blocks for 2D first. Some internals of comfy (batching and z-sorting) will need to be re-implemented to allow for this and ultimately more performant rendering techniques, but this should not happen at the cost of API clarity and ergonomics for most games.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simple and productive API.&lt;/li&gt; &#xA; &lt;li&gt;Immediate mode rendering for sprites, text and shapes with automatic batching. If you want to draw a circle, you call a function &lt;code&gt;draw_circle&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;2D lighting with HDR, tonemapping and bloom.&lt;/li&gt; &#xA; &lt;li&gt;Built-in support for z-index, meaning you don&#39;t have to worry about the order of your draw calls.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://egui.rs/&#34;&gt;egui&lt;/a&gt; support built in.&lt;/li&gt; &#xA; &lt;li&gt;Parallel asset loading with support for most image and audio formats.&lt;/li&gt; &#xA; &lt;li&gt;No complex ECS or abstractions to learn. Just build your game and let comfy get out of your way.&lt;/li&gt; &#xA; &lt;li&gt;Simple audio using &lt;a href=&#34;https://docs.rs/kira/latest/kira/&#34;&gt;kira&lt;/a&gt;. If you want to play a sound, you call a function &lt;code&gt;play_sound&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Simple 2D camera.&lt;/li&gt; &#xA; &lt;li&gt;Particles, both simple API for individual particles &amp;amp; systems with lots of options.&lt;/li&gt; &#xA; &lt;li&gt;Trails with a custom mesh &amp;amp; scrolling texture.&lt;/li&gt; &#xA; &lt;li&gt;Text rendering (currently using egui).&lt;/li&gt; &#xA; &lt;li&gt;Lots of utilities for common tasks.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Design goals &amp;amp; philosophy&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Heavy focus on ergonomics and productivity.&lt;/li&gt; &#xA; &lt;li&gt;No magic. The code does what it looks like it does.&lt;/li&gt; &#xA; &lt;li&gt;Targeted at simple games, currently only 2D.&lt;/li&gt; &#xA; &lt;li&gt;Opinionated and useful defaults.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Simple&lt;/strong&gt; immediate mode APIs for almost everything.&lt;/li&gt; &#xA; &lt;li&gt;Exposed internals for when you need more. Almost all struct fields are public, comfy doesn&#39;t keep things away from its user.&lt;/li&gt; &#xA; &lt;li&gt;Reasonable compile times. Comfy is slower to compile than macroquad, but we want to avoid things getting out of hand. End users are not going to be required to use any proc macros to use comfy.&lt;/li&gt; &#xA; &lt;li&gt;Global variables are nice. Comfy uses a lot of them.&lt;/li&gt; &#xA; &lt;li&gt;Typing less is nice. Comfy has a single context object that gets passed around everywhere.&lt;/li&gt; &#xA; &lt;li&gt;Constraints are nice. Comfy wants to be used for a lot of games, but not all of them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RefCell&lt;/code&gt;&#39;s are nice. Comfy uses them a lot to work around partial borrows. We tried doing things without them multiple times, it was more painful.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Non-goals&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;AAA 3D support. While it&#39;s entirely possible to extend the renderer to handle 3D, this was intentionally not done yet. There is a lot of complexity that comes with 3d models, materials, skeletal animations, etc. Comfy may grow to support simple 3d games in the future, but it is extremely unlikely it&#39;ll ever attempt to be competitive with big 3D engines. We want to make sure that the stuff we have works well and is usable before adding lots more complex features.&lt;/li&gt; &#xA; &lt;li&gt;ECS based engine. While comfy does embed &lt;a href=&#34;https://docs.rs/hecs&#34;&gt;hecs&lt;/a&gt; and provides some helpers for using it, it is by no means required or even optimal for most cases.&lt;/li&gt; &#xA; &lt;li&gt;Modularity. Comfy is not a modular engine. It&#39;s an opinionated toolkit with defaults that make sense for most games. There is no intention of having a plugin system or the ability to replace wgpu with something else.&lt;/li&gt; &#xA; &lt;li&gt;Maximum performance. Comfy is not designed to be the fastest engine out there. There are many tradeoffs made for the sake of ergonomics and ease of use, some of which affect performance. If you&#39;re looking for the fastest way to draw a million quads, comfy is not for you. If however you have a legitimate use case where the performance is not good enough, please open an issue. There is a lot of low hanging fruit with respect to performance, but as the development is driven by real world usage, unless something shows up in a profiler in a game, it&#39;s unlikely to be optimized further.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Getting started&lt;/h1&gt; &#xA;&lt;p&gt;The repository contains many examples under the &lt;code&gt;comfy/examples&lt;/code&gt; folder. While there is currently no documentation, the API is simple enough that just reading the examples should explain things.&lt;/p&gt; &#xA;&lt;h1&gt;Why use comfy and not X?&lt;/h1&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://macroquad.rs/&#34;&gt;macroquad&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Before I started working on comfy I was using &lt;a href=&#34;https://macroquad.rs/&#34;&gt;macroquad&lt;/a&gt; for my games. It works great, but a few things were missing, most notably RGBA16F textures, which are a feature of OpenGL 3.x, and without which HDR is not really possible. This is because macroquad targets older versions of GLES to achieve better cross-platform support. While this is great for many use cases, at the time I really wanted to play with HDR, bloom and tonemapping, which lead me down the &lt;a href=&#34;https://wgpu.rs/&#34;&gt;wgpu&lt;/a&gt; path.&lt;/p&gt; &#xA;&lt;p&gt;The first version of comfy actually had an API almost identical to macroquad, where I basically copy pasted function definitions and implemented most of the functionality on top of wgpu instead. Over time I realized I wanted a few more things, namely built-in z-index so that my game code wouldn&#39;t have to worry about draw order.&lt;/p&gt; &#xA;&lt;p&gt;If you like the idea of comfy but it&#39;s not stable enough for your use case I very highly recommend giving macroquad a try. While it is not perfect it has helped me build a bunch of small games, and most importantly I had fun while making them.&lt;/p&gt; &#xA;&lt;h3&gt;Differences between &lt;code&gt;comfy&lt;/code&gt; and &lt;code&gt;macroquad&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Macroquad is the biggest inspiration to comfy, and as such there are many things which are similar, but there are quite a few differences.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Coordinate systems:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Macroquad&#39;s coordinate system is &lt;code&gt;[0, 0]&lt;/code&gt; in top left, &lt;code&gt;y&lt;/code&gt;-down, measured in pixels.&lt;/li&gt; &#xA; &lt;li&gt;Comfy&#39;s coordinate system is &lt;code&gt;[0, 0]&lt;/code&gt; in the center, &lt;code&gt;y&lt;/code&gt;-up, measured in world units. Default camera has zoom set to &lt;code&gt;30&lt;/code&gt;, which means you can see roughly &lt;code&gt;30&lt;/code&gt; world units. In a pixel-art game with 16x16 sprites, you would ideally set your camera&#39;s zoom so each sprite is &lt;code&gt;1&lt;/code&gt; world unit.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Z-index built in&lt;/strong&gt;. In macroquad, draw calls happen in the order you call them. In comfy, almost everything (excluding text and UI) accepts a &lt;code&gt;z_index: i32&lt;/code&gt;. This means you don&#39;t need to sort the calls yourself, comfy will do it for you while still batching the draw calls as best it can.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;HDR render textures&lt;/strong&gt;: Macroquad targets GLES2/3 to support as many platforms as possible, and as such it can&#39;t support RGBA16F textures. Comfy targets desktop and WASM through WebGL 2, both of which allow &lt;code&gt;f16&lt;/code&gt; textures, and thus all rendering is done with HDR and tonemapped accordingly. This allows our bloom implementation to work off of HDR colors and greatly simplify working with lights, as the light intensity can go well beyond 1.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Batteries included&lt;/strong&gt;: Comfy includes many extra things that macroquad does not, for example egui itself is part of comfy and likely will remain this way until a better alternative comes along. Macroquad and miniquad provide small flexible building blocks, while comfy aims to be a full and relatively opinionated way of making games.&lt;/p&gt; &#xA;&lt;p&gt;There are many more subtle differences, but in principle you can think of as comfy as &#34;macroquad with more batteries included, built on top of wgpu, with less cross platform capabilities&#34;. Note that because comfy builds on wgpu and not OpenGL we don&#39;t have the same immediate mode interactions with GL. This makes some things more difficult, e.g. render targets, changing shader uniforms, etc.&lt;/p&gt; &#xA;&lt;p&gt;Comfy intends to support all of these features, but it will take a bit more development. Many engines (e.g. bevy and rend3) end up using render graphs in order to expose the rendering logic to users. While these are very flexible and offer high performance their APIs are anything but simple.&lt;/p&gt; &#xA;&lt;p&gt;Since our intention is not to support AAA graphics the goal should be to find some form of middle ground, where we could achieve something similar to macroquad in terms of API simplicity, expressivity, and fun, while utilizing all of the power wgpu has to offer.&lt;/p&gt; &#xA;&lt;p&gt;The ultimate design goal of comfy is that most of its API should be understandable from just looking at the type signatures, without needing to study documentation in depth, and without excessive footguns.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://rend3.rs/&#34;&gt;rend3&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;I don&#39;t have much experience with rend3 apart from digging a bit through its code, but as a 3d renderer it fills a very different niche than comfy. If you&#39;re building a 3d game and don&#39;t want to do PBR rendering, rend3 is probably something you want to consider.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://fyrox.rs/&#34;&gt;Fyrox&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Fyrox seems like it is trying to fight Unity, Godot and Unreal head on by currently being the only fully featured Rust game engine, notably also including a full 3D scene editor. Its 3D demos are very impressive in particular, and if you&#39;re looking for a fully featured 3D engine it&#39;s definitely something to consider.&lt;/p&gt; &#xA;&lt;p&gt;That being said, comfy is unapologetically focused on simple games, and as such fills a very different niche than Fyrox.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://bevyengine.org/&#34;&gt;bevy&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;Bevy is another contender for the &#34;big Rust game engine&#34; spot. In terms of its 2D features Bevy definitely wins on the size of community and overall crate support and modularity, but this is something where comfy is not even attempting to compete. comfy is designed to be opinionated, simple and pragmatic, while Bevy&#39;s goal is to be modular, extensible and build on top of its all-encompasing ECS.&lt;/p&gt; &#xA;&lt;p&gt;Due to its modularity Bevy offers many more features through community asset crates which greatly extend it, but also has a rather distributed and unstable ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;Comfy&#39;s goal is opposite in many ways. The goal is to provide a simple, stable and pragmatic foundation. comfy is not a platform for experimenting with Rust&#39;s type system, ECS, or other abstractions. It&#39;s a toolkit designed for making small games.&lt;/p&gt; &#xA;&lt;p&gt;The only features you&#39;ll find in comfy are those which can be immediately used, understood, and that work from day 1. If a feature is not being used in a real game it won&#39;t appear in the engine source code.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://godot-rust.github.io/&#34;&gt;godot-rust&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;If the goal is to &#34;actually make a game&#34;, especially in 3D, then godot-rust is very likely the winner. No rust engine can match what Godot offers, and having used godot-rust to make &lt;a href=&#34;https://store.steampowered.com/app/1673940/BITGUN/&#34;&gt;BITGUN&lt;/a&gt; over the course of a year we can say that it is very mature, stable and well maintained.&lt;/p&gt; &#xA;&lt;p&gt;However, the main benefit (Godot) is also its greatest downside for us. We&#39;ve found that code-based frameworks are much more fun to use. Many people consider GDScript to be the problematic part in Godot, but when working on BITGUN it actually helped us quite a bit, as there are many things which &#34;only need a few lines of code&#34; and don&#39;t really benefit from using Rust.&lt;/p&gt; &#xA;&lt;p&gt;Especially if you&#39;re considering making a 3D game, godot-rust is probably the best option of helping you ship something.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://ggez.rs/&#34;&gt;ggez&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;p&gt;ggez is one of those libraries that have been around for a while, but I&#39;ve never really got a chance to use it. It does seem to have a bit of a history with losing maintainers, which is why I never got to use it, as both times when I was switching frameworks/engines in Rust it was unmaintained. Although in the current version it did get upgraded to a wgpu-based backend, but I can&#39;t speak to its quality. I would imagine it&#39;s a great alternative to macroquad.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;There are many other frameworks/engines in Rust, but I haven&#39;t had a chance to interact with those in any significant way, hence why they&#39;re not in this comparison.&lt;/p&gt; &#xA;&lt;h1&gt;Roadmap&lt;/h1&gt; &#xA;&lt;p&gt;The following goals are not in any particular order, but should come reasonably soon. Comfy is not an aetheral project that will only materialize in 2 years. Only features that require maximum few weeks of work are listed here.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improved lighting. Right now we do have 2d lights, but they&#39;re basic, ugly in some scenarios, and not very flexible.&lt;/li&gt; &#xA; &lt;li&gt;Configurable bloom. Currently bloom is hard-coded to simplify a few things and always enabled. We don&#39;t want to delay the release to fix this since it does make games look better by default, but it is one of the first few things that will get fixed after v0.1 release.&lt;/li&gt; &#xA; &lt;li&gt;Configurable post processing.&lt;/li&gt; &#xA; &lt;li&gt;Custom shaders/materials.&lt;/li&gt; &#xA; &lt;li&gt;Render targets.&lt;/li&gt; &#xA; &lt;li&gt;Gamepad &amp;amp; touchpad support.&lt;/li&gt; &#xA; &lt;li&gt;Antialiasing.&lt;/li&gt; &#xA; &lt;li&gt;2D shadowcasters with soft shadows.&lt;/li&gt; &#xA; &lt;li&gt;Asset packing without &lt;code&gt;include_dir&lt;/code&gt;. Right now comfy relies on either its builtin use of &lt;a href=&#34;https://github.com/darthdeus/include_dir&#34;&gt;include_dir&lt;/a&gt; (a small fork with a few extra features), or the user handling asset loading manually. There are many other ways of packing assets, and it would be cool to support those, but we don&#39;t currently because for reasonably (&amp;lt;1GB) sized assets &lt;code&gt;include_dir&lt;/code&gt; works well enough.&lt;/li&gt; &#xA; &lt;li&gt;Text rendering without egui. Right now all text (drawn with &lt;code&gt;draw_text&lt;/code&gt; and friends) is rendered using &lt;code&gt;egui&lt;/code&gt;&#39;s painter on a separate layer. This gives us a lot of features in terms of text rendering, but also comes with some limitations. The goal is to implement text rendering on top of just wgpu. We&#39;ve tried a few different approaches (e.g. &lt;code&gt;glyphon&lt;/code&gt;) but ultimately found none to be easy enough to just replace what we have in &lt;code&gt;egui&lt;/code&gt;, and since no games were yet blocked on more flexible rendering this remains a relatively low priority problem.&lt;/li&gt; &#xA; &lt;li&gt;Overall engine/renderer code cleanup. The code in comfy is not beautiful as it developed organically while building multiple games. There are some features that could be better exposed, and some remains of what our games needed. The provided examples should serve as a foundation to make sure comfy is flexible enough, but it is an ongoing effort to improve the codebase. That being said, almost everything you find in comfy should work to a reasonable extent.&lt;/li&gt; &#xA; &lt;li&gt;Reduce re-borrows &amp;amp; &lt;code&gt;RefCell&lt;/code&gt;s. Right now we use &lt;em&gt;a lot&lt;/em&gt; of &lt;code&gt;RefCell&lt;/code&gt; for almost everything. While this helps in a few places there are many places where it is not necessary, and where we also excessively borrow and re-borrow multiple times per frame. Currently we haven&#39;t noticed any of this impacting performance, but it is something that should be cleaned up. There&#39;s also a few things which use a &lt;code&gt;Mutex&lt;/code&gt; unnecessarily.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;While comfy is ready to use, the codebase is far from clean. The engine evolves rapidly as we work on our games, and there are many parts that can and will be improved. Comfy is being released before it is 100% perfect, because even in its current state it can be very well used to make 2D games.&lt;/p&gt; &#xA;&lt;p&gt;There may be a few oddities you may run into, and some internals are planned to be re-done, but anything covered by the examples should 100% work. We have been using comfy internally for over 6 months, and a large part of its codebase has been ported from our previous OpenGL based engine. This doesn&#39;t mean the engine is mature, but we have had real players play our games made with comfy.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Comfy is still very early in its lifecycle. While it has been used to make games, only a few people have used it or even seen the source code so far. The best way to contribute is to use comfy and report any issues you find.&lt;/p&gt; &#xA;&lt;p&gt;The codebase is not clean by any means. It is not the goal of comfy to be the most beautiful codebase out there. Many things may be suboptimal, and for some of them it makes a lot of sense to have an open discussion about it. But pull requests which just reformat the code or move things around or do some kind of re-organization will likely be rejected unless there was a prior discussion.&lt;/p&gt; &#xA;&lt;p&gt;If you find anything that does not work as expected please do open an issue. Comfy is meant to be a productive and ergonomic companion for those who want to make games.&lt;/p&gt; &#xA;&lt;p&gt;If something is not ergonomic or you have an idea for how it could be more ergonomic without sacrificing too much, please open an issue.&lt;/p&gt; &#xA;&lt;p&gt;If you really just want to make a pull request to contribute &lt;em&gt;something&lt;/em&gt; without a prior discussion, the best place are the examples. Both simple and advanced examples, as well as small example games, are welcome.&lt;/p&gt; &#xA;&lt;p&gt;Comfy is not currently aiming for heavy documentation coverage due to the rapid pace of development. Examples are preferred to documentation as they&#39;re easier to fix when APIs change. Most things should be self-explanatory.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;d like to chat about anything comfy related, &lt;a href=&#34;https://discord.gg/M8hySjuG48&#34;&gt;join our discord server&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;comfy is free and open source and dual licensed under MIT and Apache 2.0 licenses.&lt;/p&gt; &#xA;&lt;h1&gt;Games using comfy&lt;/h1&gt; &#xA;&lt;p&gt;Comfy is being used by &lt;a href=&#34;https://loglog.games/&#34;&gt;LogLog Games&lt;/a&gt;, and currently used in a few of our games, two of which you can check out on Steam.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.steampowered.com/app/2326430/NANOVOID&#34;&gt;NANOVOID&lt;/a&gt; - 2d top down tactical space shooter.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://store.steampowered.com/app/2081500/BITGUN_Survivors&#34;&gt;BITGUN Survivors&lt;/a&gt; - open world take on the vampire survivors genre, a spiritual successor to our last big Rust game &lt;a href=&#34;https://store.steampowered.com/app/1673940/BITGUN&#34;&gt;BITGUN&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We&#39;ve also used comfy in a few smaller games, e.g. our &lt;a href=&#34;https://logloggames.itch.io/bitmob-1-bit-jam&#34;&gt;1-bit jam entry&lt;/a&gt; where we experimented with CPU textures and 2D raytracing.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>sunfishcode/eyra</title>
    <updated>2023-09-28T01:39:12Z</updated>
    <id>tag:github.com,2023-09-28:/sunfishcode/eyra</id>
    <link href="https://github.com/sunfishcode/eyra" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust programs written entirely in Rust&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Eyra&lt;/h1&gt; &#xA; &lt;p&gt; &lt;strong&gt;Rust programs written entirely in Rust&lt;/strong&gt; &lt;/p&gt; &#xA; &lt;p&gt; &lt;a href=&#34;https://github.com/sunfishcode/eyra/actions?query=workflow%3ACI&#34;&gt;&lt;img src=&#34;https://github.com/sunfishcode/eyra/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Github Actions CI Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bytecodealliance.zulipchat.com/#narrow/stream/206238-general&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/zulip-join_chat-brightgreen.svg?sanitize=true&#34; alt=&#34;zulip chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/eyra&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/eyra.svg?sanitize=true&#34; alt=&#34;crates.io page&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/eyra&#34;&gt;&lt;img src=&#34;https://docs.rs/eyra/badge.svg?sanitize=true&#34; alt=&#34;docs.rs docs&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Eyra is a package that supports building Rust programs implemented entirely in Rust.&lt;/p&gt; &#xA;&lt;p&gt;It uses &lt;a href=&#34;https://github.com/sunfishcode/origin#readme&#34;&gt;Origin&lt;/a&gt; for program and thread startup and shutdown, and &lt;a href=&#34;https://github.com/sunfishcode/c-ward/tree/main/c-gull#readme&#34;&gt;c-gull&lt;/a&gt; for ABI-compatible libc function implementations.&lt;/p&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://github.com/sunfishcode/eyra/tree/main/example-crates/hello-world/&#34;&gt;this hello world example&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;In detail&lt;/h2&gt; &#xA;&lt;p&gt;Eyra needs three things. First, a Cargo.toml dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;eyra = &#34;&amp;lt;current-version&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The next step is to add an &lt;code&gt;extern crate&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate eyra;&#xA;&#xA;fn main() {&#xA;    println!(&#34;Hello, world!&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This tells Rust that Eyra is actually used and the libraries should actually be linked in.&lt;/p&gt; &#xA;&lt;p&gt;And finally, a build.rs file to add &lt;code&gt;-nostartfiles&lt;/code&gt; to the link flags to disable the host startup code, so that Eyra can provide its own. build.rs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;fn main() {&#xA;    println!(&#34;cargo:rustc-link-arg=-nostartfiles&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With these three steps, this crate prints &#34;Hello, world!&#34;. And under the covers, it uses &lt;a href=&#34;https://github.com/sunfishcode/origin#readme&#34;&gt;Origin&lt;/a&gt; to start and stop the program, &lt;a href=&#34;https://github.com/sunfishcode/c-ward#readme&#34;&gt;c-ward&lt;/a&gt; to handle libc calls from &lt;code&gt;std&lt;/code&gt;, and &lt;a href=&#34;https://github.com/bytecodealliance/rustix#readme&#34;&gt;rustix&lt;/a&gt; to do the printing, so it&#39;s completely implemented in Rust.&lt;/p&gt; &#xA;&lt;h2&gt;Optional logging&lt;/h2&gt; &#xA;&lt;p&gt;Eyra has a &lt;code&gt;log&lt;/code&gt; feature to enable Rust &lt;code&gt;log&lt;/code&gt; tracing of program and thread startup and shutdown, and an &lt;code&gt;env_logger&lt;/code&gt; feature to install &lt;code&gt;env_logger&lt;/code&gt; as the logger, which can be enabled in Cargo.toml:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;eyra = { version = &#34;&amp;lt;current-version&amp;gt;&#34;, features = [&#34;log&#34;, &#34;env_logger&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With this, and setting the &lt;code&gt;RUST_LOG&lt;/code&gt; environment variable to &#34;trace&#34;, the hello world program output like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;[TRACE origin::program] Program started&#xA;[TRACE origin::thread] Main Thread[51383] initialized&#xA;[TRACE origin::program] Calling `.init_array`-registered function `0x55e86306bb80(1, 0x7ffd0f76aad8, 0x7ffd0f76aae8)`&#xA;[TRACE origin::program] Calling `origin_main(1, 0x7ffd0f76aad8, 0x7ffd0f76aae8)`&#xA;Hello, world!&#xA;[TRACE origin::program] `origin_main` returned `0`&#xA;[TRACE origin::thread] Thread[51383] calling `at_thread_exit`-registered function&#xA;[TRACE origin::thread] Thread[51383] calling `at_thread_exit`-registered function&#xA;[TRACE origin::program] Program exiting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Eyra is similar to &lt;a href=&#34;https://github.com/sunfishcode/mustang#readme&#34;&gt;Mustang&lt;/a&gt; and uses the same underlying code, but instead of using a custom target and -Z build-std, Eyra just needs users to add &lt;code&gt;-nostartfiles&lt;/code&gt; to their link line, such as via build.rs in the example.&lt;/p&gt; &#xA;&lt;p&gt;Like Mustang, Eyra currently runs on Rust Nightly on Linux on x86-64, x86, aarch64, and riscv64. It aims to support all Linux versions &lt;a href=&#34;https://doc.rust-lang.org/nightly/rustc/platform-support.html&#34;&gt;supported by Rust&lt;/a&gt;, though at this time it&#39;s only tested on relatively recent versions. It&#39;s complete enough to run:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sunfishcode/ripgrep/tree/eyra&#34;&gt;ripgrep&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sunfishcode/coreutils/tree/eyra&#34;&gt;coreutils&lt;/a&gt;, including the &#34;unix&#34; feature set&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sunfishcode/tide/tree/eyra&#34;&gt;async-std&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sunfishcode/tokio/tree/eyra&#34;&gt;tokio&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sunfishcode/bat/tree/eyra&#34;&gt;bat&lt;/a&gt;, including git support with libgit2&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/sunfishcode/cargo-watch/tree/eyra&#34;&gt;cargo-watch&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Eyra isn&#39;t about making anything safer, for the foreseeable future. The major libc implementations are extraordinarily well tested and mature. Eyra for its part is experimental and contains lots of &lt;code&gt;unsafe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Design philosophy&lt;/h2&gt; &#xA;&lt;p&gt;Eyra and the libraries it uses have some design goals.&lt;/p&gt; &#xA;&lt;h3&gt;Normal Rust, all the way down&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes in libc implementation code, there&#39;s a temptation to say &#34;it&#39;s ok if some things are technically Undefined Behavior, because this is Low Level Code and We Know What We&#39;re Doing&#34;.&lt;/p&gt; &#xA;&lt;p&gt;Origin, c-scape, c-gull, rustix, and the others strive to resist this temptation, and follow the Rust rules, including strict provenance, I/O safety, and all the rest, all the way down to the syscalls.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s just normal Rust code, as far down as we can go in userspace, and when we eventually do have to switch to inline asm, we do as little of it as we can.&lt;/p&gt; &#xA;&lt;p&gt;Currently there is only one known place where this goal is not achieved. In a &#34;static PIE&#34; executable (eg. built with &lt;code&gt;RUSTFLAGS=&#34;-C target-feature=+crt-static&#34;&lt;/code&gt;), the dynamic linker isn&#39;t used, so the executable has to handle all its relocations itself. However, that means storing to memory locations that wouldn&#39;t otherwise be considered mutable. Origin&#39;s code for doing this is currently disabled by default, and can be enabled with the &#34;experimental-relocate&#34; cargo feature.&lt;/p&gt; &#xA;&lt;h3&gt;C compatibility as a layer on top of Rust, not vice versa&lt;/h3&gt; &#xA;&lt;p&gt;Eyra is built on a collection of Rust crates with idiomatic Rust APIs, and two crates, c-scape and c-gull, which are relatively thin layers on top that implement the libc-compatible C ABI.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s sometimes more work to write the code as separate layers like this, but it has the advantage of clearly separating out the &lt;code&gt;unsafe&lt;/code&gt; associated with things like C pointers and strings in libc APIs from the essential &lt;code&gt;unsafe&lt;/code&gt; needed to implement things like system calls, thread primitives, and other features. And it means that Rust programs that don&#39;t want to go through the C compatibility layer can use the underlying crates directly.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>microsoft/Windows-rust-driver-samples</title>
    <updated>2023-09-28T01:39:12Z</updated>
    <id>tag:github.com,2023-09-28:/microsoft/Windows-rust-driver-samples</id>
    <link href="https://github.com/microsoft/Windows-rust-driver-samples" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust port of the official Windows Driver Samples on Github. Leverages windows-drivers-rs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rust Driver Samples&lt;/h1&gt; &#xA;&lt;p&gt;This is a Rust port of the driver samples from the original &lt;a href=&#34;https://github.com/microsoft/Windows-driver-samples&#34;&gt;Windows Driver Samples on Github.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The repository provides examples and best practices for Windows driver development in Rust using crates from &lt;a href=&#34;https://github.com/microsoft/windows-drivers-rs&#34;&gt;windows-drivers-rs.&lt;/a&gt; &lt;span style=&#34;background-color: #FFFF00&#34;&gt;&lt;/span&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Pre-requisites&lt;/h3&gt; &#xA;&lt;h4&gt;Required&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Set up &lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/develop/using-the-enterprise-wdk&#34;&gt;EWDK Build Environment.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://clang.llvm.org/get_started.html&#34;&gt;Clang.&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Rust.&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Rust Setup&lt;/h4&gt; &#xA;&lt;p&gt;Run the following commands after setting up Rust.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rustup toolchain add nightly-msvc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo install cargo-make --no-default-features --features tls-native&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note on arm64: ARM64 support for ring is &lt;a href=&#34;https://github.com/briansmith/ring/issues/1167&#34;&gt;not released yet&lt;/a&gt;, so TLS features must be disabled until arm64 is officially supported by ring (probably in 0.17.0 release)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h5&gt;Optional&lt;/h5&gt; &#xA;&lt;p&gt;These are not-required, but may make it easier to work in a rust environment:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo install cargo-expand&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo install cargo-edit&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo install cargo-workspaces&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;code&gt;cargo doc --document-private-items --open&lt;/code&gt; to compile and open documentation&lt;/p&gt; &#xA;&lt;h2&gt;Build and Test&lt;/h2&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;p&gt;From an EWDK development command prompt, run:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo make&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;If build is successful, this will stamp the INF and create a CAT file placed with driver binary and INF in &lt;code&gt;Package&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;h3&gt;Install&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Copy the following to the DUT (Device Under Test: the computer you want to test the driver on): &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;.\target\..configuration..\package&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;Path\To\Driver\DriverCertificate.cer&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;The version of &lt;code&gt;devgen.exe&lt;/code&gt; from the WDK Developer Tools that matches the archtecture of your DUT&lt;/li&gt; &#xA;  &lt;/ol&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Ex. &lt;code&gt;C:\Program Files\Windows Kits\10\Tools\10.0.22621.0\x64\devgen.exe&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Install the Certificate on the DUT: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Double click the certificate&lt;/li&gt; &#xA;   &lt;li&gt;Click Install Certificate&lt;/li&gt; &#xA;   &lt;li&gt;Select a Store Location &lt;strong&gt;(Either Store Location is Fine)&lt;/strong&gt; -&amp;gt; Next&lt;/li&gt; &#xA;   &lt;li&gt;Place all certificates in the following Store -&amp;gt; Browse -&amp;gt; Trusted Root Certification Authorities -&amp;gt; Ok -&amp;gt; Next&lt;/li&gt; &#xA;   &lt;li&gt;Finish&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Install the driver: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In the package directory, run: &lt;code&gt;pnputil.exe /add-driver echo_2.inf /install&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Create a software device: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;In the directory that &lt;code&gt;devgen.exe&lt;/code&gt; was copied to, run: &lt;code&gt;devgen.exe /add /hardwareid &#34;root\ECHO_2&#34;&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To capture prints: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Start &lt;a href=&#34;https://learn.microsoft.com/en-us/sysinternals/downloads/debugview&#34;&gt;DebugView&lt;/a&gt; &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt;Enable &lt;code&gt;Capture Kernel&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;Enable &lt;code&gt;Enable Verbose Kernel Output&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;   &lt;li&gt;Alternatively, you can see prints in an active Windbg session. &#xA;    &lt;ol&gt; &#xA;     &lt;li&gt;Attach WinDBG&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;ed nt!Kd_DEFAULT_Mask 0xFFFFFFFF&lt;/code&gt;&lt;/li&gt; &#xA;    &lt;/ol&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;The echo driver can be tested by using the &lt;a href=&#34;https://github.com/microsoft/Windows-driver-samples/tree/main/general/echo/kmdf/exe&#34;&gt;echo executable&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Echoapp.exe --- Send single write and read request synchronously&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Echoapp.exe -Async --- Send 100 reads and writes asynchronously&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Exit the app anytime by pressing Ctrl-C&lt;/p&gt; &#xA;&lt;h2&gt;Windows driver development&lt;/h2&gt; &#xA;&lt;h3&gt;Windows Driver Kit (WDK)&lt;/h3&gt; &#xA;&lt;p&gt;Take a look at the compilation of the new and changed driver-related content for Windows 11. Areas of improvement include camera, print, display, Near Field Communication (NFC), WLAN, Bluetooth, and more.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/windows-hardware/drivers/what-s-new-in-driver-development&#34;&gt;Find out what&#39;s new in the WDK&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Windows Driver Frameworks&lt;/h3&gt; &#xA;&lt;p&gt;The Windows Driver Frameworks (WDF) are a set of libraries that make it simple to write high-quality device drivers.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/windows-hardware/drivers/wdf/&#34;&gt;WDF driver development guide&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Samples&lt;/h3&gt; &#xA;&lt;p&gt;Use the samples in this repo to guide your Windows driver development. Whether you&#39;re just getting started or porting an older driver to the newest version of Windows, code samples are valuable guides on how to write drivers.&lt;/p&gt; &#xA;&lt;p&gt;For information about important changes that need to be made to the WDK sample drivers before releasing device drivers based on the sample code, see the following topic:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/from-sample-code-to-production-driver&#34;&gt;From Sample Code to Production Driver - What to Change in the Samples&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Trademarks&lt;/h2&gt; &#xA;&lt;p&gt;This project may contain trademarks or logos for projects, products, or services. Authorized use of Microsoft trademarks or logos is subject to and must follow &lt;a href=&#34;https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general&#34;&gt;Microsoft&#39;s Trademark &amp;amp; Brand Guidelines&lt;/a&gt;. Use of Microsoft trademarks or logos in modified versions of this project must not cause confusion or imply Microsoft sponsorship. Any use of third-party trademarks or logos are subject to those third-party&#39;s policies.&lt;/p&gt;</summary>
  </entry>
</feed>