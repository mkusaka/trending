<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-05-20T01:37:31Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>facebook/pyrefly</title>
    <updated>2025-05-20T01:37:31Z</updated>
    <id>tag:github.com,2025-05-20:/facebook/pyrefly</id>
    <link href="https://github.com/facebook/pyrefly" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A fast type checker and IDE for Python&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-MIT-yellow.svg?sanitize=true&#34; alt=&#34;License: MIT&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Pyrefly: A fast type checker and IDE for Python&lt;/h1&gt; &#xA;&lt;p&gt;Currently under active development with known issues. Please open an issue if you find bugs.&lt;/p&gt; &#xA;&lt;p&gt;Pyrefly is a fast type checker for Python. It&#39;s designed to replace the existing Pyre type checker at Meta by the end of 2025. This README describes basic usage. See the &lt;a href=&#34;https://pyrefly.org&#34;&gt;Pyrefly website&lt;/a&gt; for full documentation and a tool for checking code.&lt;/p&gt; &#xA;&lt;h3&gt;Getting Started&lt;/h3&gt; &#xA;&lt;p&gt;Pyrefly aims to increase development velocity with IDE features and by checking your Python code.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Try out pyrefly in your browser: &lt;a href=&#34;https://pyrefly.org/sandbox/&#34;&gt;Sandbox&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Get the command-line tool: &lt;code&gt;pip install pyrefly&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Get the VSCode extension: &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=meta.pyrefly&#34;&gt;Link&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Key Features:&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Type Inference: Pyrefly infers types in most locations, apart from function parameters. It can infer types of variables and return types.&lt;/li&gt; &#xA; &lt;li&gt;Flow Types: Pyrefly can understand your program&#39;s control flow to refine static types.&lt;/li&gt; &#xA; &lt;li&gt;Incrementality: Pyrefly aims for large-scale incrementality at the module level, with optimized checking and parallelism.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Involved&lt;/h2&gt; &#xA;&lt;p&gt;If you have questions or would like to report a bug, please &lt;a href=&#34;https://github.com/facebook/pyrefly/issues&#34;&gt;create an issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://github.com/facebook/pyrefly/raw/main/CONTRIBUTING.md&#34;&gt;contributing guide&lt;/a&gt; for information on how to contribute to Pyrefly.&lt;/p&gt; &#xA;&lt;h2&gt;Choices&lt;/h2&gt; &#xA;&lt;p&gt;There are a number of choices when writing a Python type checker. We are take inspiration from &lt;a href=&#34;https://pyre-check.org/&#34;&gt;Pyre1&lt;/a&gt;, &lt;a href=&#34;https://github.com/microsoft/pyright&#34;&gt;Pyright&lt;/a&gt; and &lt;a href=&#34;https://mypy.readthedocs.io/en/stable/&#34;&gt;MyPy&lt;/a&gt;. Some notable choices:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We infer types in most locations, apart from parameters to functions. We do infer types of variables and return types. As an example, &lt;code&gt;def foo(x): return True&lt;/code&gt; would result in something equivalent to had you written &lt;code&gt;def foo(x: Any) -&amp;gt; bool: ...&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;We attempt to infer the type of &lt;code&gt;[]&lt;/code&gt; to however it is used first, then fix it after. For example &lt;code&gt;xs = []; xs.append(1); xs.append(&#34;&#34;)&lt;/code&gt; will infer that &lt;code&gt;xs: List[int]&lt;/code&gt; and then error on the final statement.&lt;/li&gt; &#xA; &lt;li&gt;We use flow types which refine static types, e.g. &lt;code&gt;x: int = 4&lt;/code&gt; will both know that &lt;code&gt;x&lt;/code&gt; has type &lt;code&gt;int&lt;/code&gt;, but also that the immediately next usage of &lt;code&gt;x&lt;/code&gt; will be aware the type is &lt;code&gt;Literal[4]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;We aim for large-scale incrementality (at the module level) and optimised checking with parallelism, aiming to use the advantages of Rust to keep the code a bit simpler.&lt;/li&gt; &#xA; &lt;li&gt;We expect large strongly connected components of modules, and do not attempt to take advantage of a DAG-shape in the source code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Design&lt;/h2&gt; &#xA;&lt;p&gt;There are many nuances of design that change on a regular basis. But the basic substrate on which the checker is built involves three steps:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Figure out what each module exports. That requires solving all &lt;code&gt;import *&lt;/code&gt; statements transitively.&lt;/li&gt; &#xA; &lt;li&gt;For each module in isolation, convert it to bindings, dealing with all statements and scope information (both static and flow).&lt;/li&gt; &#xA; &lt;li&gt;Solve those bindings, which may require the solutions of bindings in other modules.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If we encounter unknowable information (e.g. recursion) we use &lt;code&gt;Type::Var&lt;/code&gt; to insert placeholders which are filled in later.&lt;/p&gt; &#xA;&lt;p&gt;For each module, we solve the steps sequentially and completely. In particular, we do not try and solve a specific identifier first (like &lt;a href=&#34;https://github.com/dotnet/roslyn&#34;&gt;Rosyln&lt;/a&gt; or &lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;), and do not used fine-grained incrementality (like &lt;a href=&#34;https://github.com/rust-lang/rust-analyzer&#34;&gt;Rust Analyzer&lt;/a&gt; using &lt;a href=&#34;https://github.com/salsa-rs/salsa&#34;&gt;Salsa&lt;/a&gt;). Instead, we aim for raw performance and a simpler module-centric design - there&#39;s no need to solve a single binding in isolation if solving all bindings in a module is fast enough.&lt;/p&gt; &#xA;&lt;h3&gt;Example of bindings&lt;/h3&gt; &#xA;&lt;p&gt;Given the program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;1: x: int = 4&#xA;2: print(x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We might produce the bindings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;define int@0&lt;/code&gt; = &lt;code&gt;from builtins import int&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;define x@1&lt;/code&gt; = &lt;code&gt;4: int@0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;use x@2&lt;/code&gt; = &lt;code&gt;x@1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;anon @2&lt;/code&gt; = &lt;code&gt;print(x@2)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;export x&lt;/code&gt; = &lt;code&gt;x@2&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Of note:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The keys are things like &lt;code&gt;define&lt;/code&gt; (the definition of something), &lt;code&gt;use&lt;/code&gt; (a usage of a thing) and &lt;code&gt;anon&lt;/code&gt; (a statement we need to type check, but don&#39;t care about the result of).&lt;/li&gt; &#xA; &lt;li&gt;In many cases the value of a key refers to other keys.&lt;/li&gt; &#xA; &lt;li&gt;Some keys are imported from other modules, via &lt;code&gt;export&lt;/code&gt; keys and &lt;code&gt;import&lt;/code&gt; values.&lt;/li&gt; &#xA; &lt;li&gt;In order to disamiguate identifiers we use the textual position at which they occur (in the example I&#39;ve used &lt;code&gt;@line&lt;/code&gt;, but in reality its the byte offset in the file).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Example of &lt;code&gt;Var&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Given the program:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;1: x = 1&#xA;2: while test():&#xA;3:     x = x&#xA;4: print(x)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We end up with the bindings:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;x@1&lt;/code&gt; = &lt;code&gt;1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;x@3&lt;/code&gt; = &lt;code&gt;phi(x@1, x@3)&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;x@4&lt;/code&gt; = &lt;code&gt;phi(x@1, x@3)&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The expression &lt;code&gt;phi&lt;/code&gt; is the join point of the two values, e.g. &lt;code&gt;phi(int, str)&lt;/code&gt; would be &lt;code&gt;int | str&lt;/code&gt;. We skip the distinction between &lt;code&gt;define&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;, since it is not necessary for this example.&lt;/p&gt; &#xA;&lt;p&gt;When solving &lt;code&gt;x@3&lt;/code&gt; we encounter recursion. Operationally:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We start solving &lt;code&gt;x@3&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;That requires us to solve &lt;code&gt;x@1&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;We solve &lt;code&gt;x@1&lt;/code&gt; to be &lt;code&gt;Literal[1]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;We start solving &lt;code&gt;x@3&lt;/code&gt;. But we are currently solving &lt;code&gt;x@3&lt;/code&gt;, so we invent a fresh &lt;code&gt;Var&lt;/code&gt; (let&#39;s call it &lt;code&gt;?1&lt;/code&gt;) and return that.&lt;/li&gt; &#xA; &lt;li&gt;We conclude that &lt;code&gt;x@3&lt;/code&gt; must be &lt;code&gt;Literal[1] | ?1&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Since &lt;code&gt;?1&lt;/code&gt; was introduced by &lt;code&gt;x@3&lt;/code&gt; we record that &lt;code&gt;?1 = Literal[1] | ?1&lt;/code&gt;. We can take the upper reachable bound of that and conclude that &lt;code&gt;?1 = Literal[1]&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;We simplify &lt;code&gt;x@3&lt;/code&gt; to just &lt;code&gt;Literal[1]&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>