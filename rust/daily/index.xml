<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-22T01:44:51Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>DvorakDwarf/Infinite-Storage-Glitch</title>
    <updated>2023-02-22T01:44:51Z</updated>
    <id>tag:github.com,2023-02-22:/DvorakDwarf/Infinite-Storage-Glitch</id>
    <link href="https://github.com/DvorakDwarf/Infinite-Storage-Glitch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;ISG lets you use YouTube as cloud storage for ANY files, not just video&lt;/p&gt;&lt;hr&gt;&lt;h4&gt;I was working on this instead of my finals, hope you appreciate it.&lt;/h4&gt; &#xA;&lt;h1&gt;Infinite-Storage-Glitch&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/96934612/219563410-7728447d-5482-41ae-a3ff-cf8446e16ab7.gif&#34; alt=&#34;ezgif com-gif-maker&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;AKA ISG (written entirely in Rust my beloved) lets you embed files into video and upload them to youtube as storage.&lt;/p&gt; &#xA;&lt;p&gt;YouTube has no limit on amount of video that you can upload. This means that it is effectively infinite cloud storage if you were able to embed files into video with some kind of tool. ISG is the tool.&lt;/p&gt; &#xA;&lt;p&gt;This has been quite heavily inspired by suckerpinch&#39;s &lt;a href=&#34;https://www.youtube.com/watch?v=JcJSW7Rprio&#34;&gt;Harder Drive&lt;/a&gt; video and &lt;a href=&#34;https://github.com/pixelomer/discord-fs&#34;&gt;discord as a filesystem&lt;/a&gt;. Unfortunately no filesystem functionality as of right now.&lt;/p&gt; &#xA;&lt;p&gt;If you are having trouble with the program please dm me.&lt;/p&gt; &#xA;&lt;h1&gt;Now, you might be asking yourself:&lt;/h1&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;b&gt;But is this against TOS ?&lt;/b&gt;&lt;/summary&gt; &#xA; &lt;b&gt;Answer is:&lt;/b&gt; maybe? &#xA; &lt;p&gt;I doubt there is any part of the TOS saying that you can&#39;t upload videos containing files, but I also did not want to shovel through all the legalese. I still don&#39;t condone using this tool for anything serious/large. YouTube might understandably get mad.&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Recommended way (building from source):&lt;/strong&gt;&lt;br&gt; === &lt;em&gt;Please note: building from source takes &lt;strong&gt;a lot of CPU and RAM&lt;/strong&gt; usage.&lt;/em&gt; ===&lt;br&gt; You need to have installed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Rust&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/twistedfall/opencv-rust&#34;&gt;opencv&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If having any issues also try installing &lt;a href=&#34;https://ffmpeg.org/&#34;&gt;ffmpeg&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to or already have went through the hassle of installing Rust, you can &lt;code&gt;git clone&lt;/code&gt; this repository, then &lt;code&gt;cargo build --release&lt;/code&gt;. Cd to &lt;code&gt;/target/release&lt;/code&gt; directory and run the program &lt;code&gt;./isg_4real&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;b&gt;The easier way:&lt;/b&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the executable from the releases&lt;/li&gt; &#xA; &lt;li&gt;Place the executable inside a folder&lt;/li&gt; &#xA; &lt;li&gt;Open terminal inside the directory&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chmod +x isg_4real&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run the executable: &lt;code&gt;./isg_4real&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enjoy!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Note that the binary &lt;strong&gt;is not an exe file&lt;/strong&gt;, it will not work on windows, try following the first method instead.&lt;br&gt; I might add an .exe if this somehow gets popular&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Archive to zip all the files you will be uploading&lt;/li&gt; &#xA; &lt;li&gt;Run the executable&lt;/li&gt; &#xA; &lt;li&gt;Use the embed option on the archive (&lt;strong&gt;THE VIDEO WILL BE SEVERAL TIMES LARGER THAN THE FILE&lt;/strong&gt;, 4x in case of optimal compression resistance preset)&lt;/li&gt; &#xA; &lt;li&gt;Upload the video to your YouTube channel. You probably want to keep it up as unlisted&lt;/li&gt; &#xA; &lt;li&gt;Use the download option to get the video back&lt;/li&gt; &#xA; &lt;li&gt;Use the dislodge option to get your files back from the downloaded video&lt;/li&gt; &#xA; &lt;li&gt;PROFIT&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/96934612/219563769-c05370e9-3f40-406a-85b8-eca14a118be8.png&#34; alt=&#34;2023-02-16_22-12&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Demo&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Flashing lights warning !!!1!1&lt;/strong&gt; - &lt;a href=&#34;https://www.youtube.com/watch?v=8I4fd_Sap-g&#34;&gt;YouTube Link&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Try to use the program on this video and find the files hidden inside.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;No it&#39;s not just a rick roll.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Explanation 4 nerds&lt;/h2&gt; &#xA;&lt;p&gt;The principle behind this is pretty simple. All files are made of bytes and bytes can be interpreted as numbers ranging from 1-255. This number can be represented with pixels using one of two modes: RGB or binary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;RGB&lt;/strong&gt;: The cooler mode. Every byte perfectly fits inside one of the colors of an rgb pixel. One rgb pixel can contain 3 bytes at a time. You just keep adding pixels like this until you run out of data. It is leagues more efficient and quick than binary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Binary&lt;/strong&gt;: Born from YouTube compression being absolutely brutal. RGB mode is very sensitive to compression as a change in even one point of one of the colors of one of the pixels dooms the file to corruption. Black and white pixels are a lot harder to mess up. Every pixel is either bright representing a 1 or dark representing a 0. We string these bits together to get bytes and continue until we run out of data.&lt;/p&gt; &#xA;&lt;p&gt;Both of these modes can be corrupted by compression, so we need to increase the size of the pixels to make it less compressable. 2x2 blocks of pixels seem to be good enough in binary mode.&lt;/p&gt; &#xA;&lt;p&gt;To make it easier on the user, we also include all the relevant settings used to create the video on the first frame of the video. This allows the program to know what mode the video is in and what size to use in order to avoid making the user remember.&lt;/p&gt; &#xA;&lt;h1&gt;Final comments&lt;/h1&gt; &#xA;&lt;p&gt;I will come back to this project a bit later after I work on something else&lt;/p&gt; &#xA;&lt;p&gt;I appreciate any and all roasting of the code so I can improve.&lt;/p&gt; &#xA;&lt;p&gt;Do what you want with the code, but credit would be much appreciated and if you have any trouble with ISG, please contact me over discord.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Kudaes/Split</title>
    <updated>2023-02-22T01:44:51Z</updated>
    <id>tag:github.com,2023-02-22:/Kudaes/Split</id>
    <link href="https://github.com/Kudaes/Split" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Apply a divide and conquer approach to bypass EDRs&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;Divide and Conquer is an algorithm that is commonly applied in programming to solve a complex problem by dividing it into many simpler sub-problems. We can apply this approach to offensive security with a different goal: consufe EDRs so they lose track of our activities, preventing them from raising any alert. This is something similar of what can be seen lately on almost any phishing campaing in the wild: long infection chains, running multiple files step by step (e.g. .url -&amp;gt; .one -&amp;gt; .js -&amp;gt; .bat -&amp;gt; .dll) instead of running directly the final payload. Each one of the files executed performs a simple task (download another file, make any change in the registry, move files between directories or change their names/extensions and so on) that is hard to tag as malicious by itself, preparing the environment for the final execution.&lt;/p&gt; &#xA;&lt;p&gt;I decided to test this simple idea but applied to something different, in this case, a remote process injection. The code presented in this repository is nothing new, on the contrary, it is probably one of the most common and straightfoward ways to inject a shellcode in a remote process: to make use of NtOpenProcess, NtAllocateVirtualMemory, NtWriteVirtualMemory, NtProtectVirtualMemory and NtCreateThreadEx. The only difference is that I&#39;m forking the process using NtCreateUserProcess after each one of those calls. Since the forked process continues with the execution from RIP + 1 and the memory is entirely copied from the parent, we can perform the remote process injection but using 5 different processes, we just need to make sure that any handle required for the subsequent API calls is properly inherited.&lt;/p&gt; &#xA;&lt;p&gt;This way, we break the shellcode injection procedure into simpler tasks, and run each one of them on a separated context (process).&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve test this PoC against three of the most common EDRs nowadays: MDE, CrowdStrike and SentinelOne. The results speak for themselves: 2 out 3 EDRs raised a Remote Process Injection alert when running the PoC without the forks; on the contrary, none of them raised any alert once I introduced the forking mechanism.&lt;/p&gt; &#xA;&lt;p&gt;Of course, even with the fork mechanism we can see in the raw telemetry the events corresponding to process creation, thread creation and also all the cross process behavior, but it seems it is not enough for the EDRs to tag the activity as malicious, proving the point of this PoC. By spliting the malicious behaviour into simpler tasks and running each one of them from a different process we can confuse and prevent the EDRs from raising any alert.&lt;/p&gt; &#xA;&lt;p&gt;This same result could be achieved in different ways, I just used the fork mechanism to simplify my code and reduce the cross process activity.&lt;/p&gt; &#xA;&lt;p&gt;If you want to test this by yourself, compile the code with and without the calls to the function fork(), and then run both payloads in an environment with the desired EDR.&lt;/p&gt; &#xA;&lt;h1&gt;Compilation&lt;/h1&gt; &#xA;&lt;p&gt;Since we are using &lt;a href=&#34;https://github.com/anvie/litcrypt.rs&#34;&gt;LITCRYPT&lt;/a&gt; plugin to obfuscate string literals (just for the Dinvoke_rs code), it is required to set up the environment variable LITCRYPT_ENCRYPT_KEY before compiling the code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\Users\User\Desktop\Split&amp;gt; set LITCRYPT_ENCRYPT_KEY=&#34;yoursupersecretkey&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After that, simply compile the code and run the tool:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;C:\Users\User\Desktop\Split&amp;gt; cargo build --release&#xA;C:\Users\User\Desktop\Split\target\release&amp;gt; split.exe -h&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Limitations&lt;/h1&gt; &#xA;&lt;p&gt;This technique by its own is not enough to bypass a EDR; if your code is none opsec at all, it is very probably that you will get caught anyway. This is not a golden bullet, just another layer of evasion that you can add to your tools. Nonetheless, the code presented in this repository is not opsec at all for the following reasons among others:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Plain text shellcode. Moreover, the shellcode spawns a cmd once it is executed.&lt;/li&gt; &#xA; &lt;li&gt;No use of syscalls.&lt;/li&gt; &#xA; &lt;li&gt;No unhooking.&lt;/li&gt; &#xA; &lt;li&gt;Etw not pached.&lt;/li&gt; &#xA; &lt;li&gt;Others.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;On the other hand, I just have tested this approach against the mentioned EDRs, and I don&#39;t know if other EDRs will be bypassed as well. You can test it and let me know how it went ;)&lt;/p&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/deepinstinct&#34;&gt;Deep Instinct&lt;/a&gt; for their &lt;a href=&#34;https://github.com/deepinstinct/Dirty-Vanity&#34;&gt;Dirty-Vanity&lt;/a&gt; tool and research and for the shellcode template.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>containerd/runwasi</title>
    <updated>2023-02-22T01:44:51Z</updated>
    <id>tag:github.com,2023-02-22:/containerd/runwasi</id>
    <link href="https://github.com/containerd/runwasi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Facilitates running Wasm / WASI workloads managed by containerd&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;runwasi&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; Alpha quality software, do not use in production.&lt;/p&gt; &#xA;&lt;p&gt;This is a project to facilitate running wasm workloads managed by containerd either directly (ie. through ctr) or as directed by Kubelet via the CRI plugin. It is intended to be a (rust) library that you can take and integrate with your wasm host. Included in the repository is a PoC for running a plain wasi host (ie. no extra host functions except to support wasi system calls).&lt;/p&gt; &#xA;&lt;h3&gt;Community&lt;/h3&gt; &#xA;&lt;p&gt;Come join us on our &lt;a href=&#34;https://cloud-native.slack.com/archives/C04LTPB6Z0V&#34;&gt;slack channel #runwasi&lt;/a&gt; on the CNCF slack.&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;p&gt;runwasi is intended to be consumed as a library to be linked to from your own wasm host implementation.&lt;/p&gt; &#xA;&lt;p&gt;There are two modes of operation supported:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&#34;Normal&#34; mode where there is 1 shim process per container or k8s pod.&lt;/li&gt; &#xA; &lt;li&gt;&#34;Shared&#34; mode where there is a single manager service running all shims in process.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;In either case you need to implement the &lt;code&gt;Instance&lt;/code&gt; trait:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub trait Instance {&#xA;    // Create a new instance&#xA;    fn new(id: String, cfg: Option&amp;lt;&amp;amp;InstanceConfig&amp;lt;Self::E&amp;gt;&amp;gt;) -&amp;gt; Self;&#xA;    // Start the instance and return the pid&#xA;    fn start(&amp;amp;self) -&amp;gt; Result&amp;lt;u32, Error&amp;gt;;&#xA;    // Send the specified signal to the instance&#xA;    fn kill(&amp;amp;self, signal: u32) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;&#xA;    // Delete the instance&#xA;    fn delete(&amp;amp;self) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;&#xA;    // wait for the instance to exit and send the exit code and exit timestamp to the provided sender.&#xA;    fn wait(&amp;amp;self, send: Sender&amp;lt;(u32, DateTime&amp;lt;Utc&amp;gt;)&amp;gt;) -&amp;gt; Result&amp;lt;(), Error&amp;gt;;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To use your implementation in &#34;normal&#34; mode, you&#39;ll need to create a binary which has a main that looks something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use containerd_shim as shim;&#xA;use containerd_shim_wasm::sandbox::{ShimCli, Instance}&#xA;&#xA;struct MyInstance {&#xA; // ...&#xA;}&#xA;&#xA;impl Instance for MyInstance {&#xA;    // ...&#xA;}&#xA;&#xA;fn main() {&#xA;    shim::run::&amp;lt;ShimCli&amp;lt;MyInstance&amp;gt;&amp;gt;(&#34;io.containerd.myshim.v1&#34;, opts);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note you can implement your own ShimCli if you like and customize your wasm engine and other things. I encourage you to checkout how that is implemented.&lt;/p&gt; &#xA;&lt;p&gt;The shim binary just needs to be installed into &lt;code&gt;$PATH&lt;/code&gt; (as seen by the containerd process) with a binary name like &lt;code&gt;containerd-shim-myshim-v1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For the shared mode:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use containerd_shim_wasm::sandbox::{Local, ManagerService, Instance};&#xA;use containerd_shim_wasm::services::sandbox_ttrpc::{create_manager, Manager};&#xA;use std::sync::Arc;&#xA;use ttrpc::{self, Server};&#xA;/// ...&#xA;&#xA;struct MyInstance {&#xA;    /// ...&#xA;}&#xA;&#xA;impl Instance for MyInstance {&#xA;    // ...&#xA;}&#xA;&#xA;fn main() {&#xA;    let s: ManagerService&amp;lt;Local&amp;lt;MyInstance&amp;gt;&amp;gt; =&#xA;        ManagerService::new(Engine::new(Config::new().interruptable(true)).unwrap());&#xA;    let s = Arc::new(Box::new(s) as Box&amp;lt;dyn Manager + Send + Sync&amp;gt;);&#xA;    let service = create_manager(s);&#xA;&#xA;    let mut server = Server::new()&#xA;        .bind(&#34;unix:///run/io.containerd.myshim.v1/manager.sock&#34;)&#xA;        .unwrap()&#xA;        .register_service(service);&#xA;&#xA;    server.start().unwrap();&#xA;    let (_tx, rx) = std::sync::mpsc::channel::&amp;lt;()&amp;gt;();&#xA;    rx.recv().unwrap();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will be the host daemon that you startup and manage on your own. You can use the provided &lt;code&gt;containerd-shim-myshim-v1&lt;/code&gt; binary as the shim to specify in containerd.&lt;/p&gt; &#xA;&lt;p&gt;Shared mode requires precise control over real threads and as such should not be used with an async runtime.&lt;/p&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;h4&gt;Components&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;containerd-shim-[ wasmedge | wasmtime ]-v1&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a containerd shim which runs wasm workloads in &lt;a href=&#34;https://github.com/WasmEdge/WasmEdge&#34;&gt;WasmEdge&lt;/a&gt; or &lt;a href=&#34;https://github.com/bytecodealliance/wasmtime&#34;&gt;Wasmtime&lt;/a&gt;. You can use it with containerd&#39;s &lt;code&gt;ctr&lt;/code&gt; by specifying &lt;code&gt;--runtime=io.containerd.[ wasmedge | wasmtime ].v1&lt;/code&gt; when creating the container. And make sure the shim binary must be in $PATH (that is the $PATH that containerd sees). Usually you just run &lt;code&gt;make install&lt;/code&gt; after &lt;code&gt;make build&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;build shim with wasmedge we need install library first&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;This shim runs one per pod.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;containerd-shim-[ wasmedge | wasmtime ]d-v1&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A cli used to connect containerd to the &lt;code&gt;containerd-[ wasmedge | wasmtime ]d&lt;/code&gt; sandbox daemon. When containerd requests for a container to be created, it fires up this shim binary which will connect to the &lt;code&gt;containerd-[ wasmedge | wasmtime ]d&lt;/code&gt; service running on the host. The service will return a path to a unix socket which this shim binary will write back to containerd which containerd will use to connect to for shim requests. This binary does not serve requests, it is only responsible for sending requests to the &lt;code&gt;contianerd-[ wasmedge | wasmtime ]d&lt;/code&gt; daemon to create or destroy sandboxes.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;containerd-[ wasmedge | wasmtime ]d&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a sandbox manager that enables running 1 wasm host for the entire node instead of one per pod (or container). When a container is created, a request is sent to this service to create a sandbox. The &#34;sandbox&#34; is a containerd task service that runs in a new thread on its own unix socket, which we return back to containerd to connect to.&lt;/p&gt; &#xA;&lt;p&gt;The Wasmedge / Wasmtime engine is shared between all sandboxes in the service.&lt;/p&gt; &#xA;&lt;p&gt;To use this shim, specify &lt;code&gt;io.containerd.[ wasmedge | wasmtime ]d.v1&lt;/code&gt; as the runtime to use. You will need to make sure the &lt;code&gt;containerd-[ wasmedge | wasmtime ]d&lt;/code&gt; daemon has already been started.&lt;/p&gt; &#xA;&lt;h4&gt;Test and demo with containerd&lt;/h4&gt; &#xA;&lt;p&gt;&lt;strong&gt;Attention&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Instead of enabling docker-desktop official released feature &lt;code&gt;use containerd for pulling and storing images&lt;/code&gt;, you can build a local image and interact with the container locally.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Install WasmEdge first (If you choose Wasmedge as your wasm runtime)&lt;/strong&gt;&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Install WasmEdge&lt;/li&gt; &#xA;   &lt;li&gt;Make sure the library is in the search path.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;$ curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash&#xA;$ sudo -E sh -c &#39;echo &#34;$HOME/.wasmedge/lib&#34; &amp;gt; /etc/ld.so.conf.d/libwasmedge.conf&#39;&#xA;$ sudo ldconfig&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Run unit test&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;$ cargo test -- --nocapture&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see some output like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;running 3 tests&#xA;test instance::tests::test_maybe_open_stdio ... ok&#xA;test instance::wasitest::test_delete_after_create ... ok&#xA;test instance::wasitest::test_wasi ... ok&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Build and install shim components&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;$ make build&#xA;$ sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now you can use the test image provided in this repo to have test with, use &lt;code&gt;make load&lt;/code&gt; to load it into containerd.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Case 1.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Run it with &lt;code&gt;sudo ctr run --rm --runtime=io.containerd.[ wasmedge | wasmtime ].v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo &#39;hello&#39;&lt;/code&gt;. You should see some output repeated like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;$ sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 ghcr.io/containerd/runwasi/wasi-demo-app:latest testwasm /wasi-demo-app.wasm echo &#39;hello&#39;&#xA;&#xA;hello&#xA;exiting&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Case 2.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Run it with &lt;code&gt;sudo ctr run --rm --runtime=io.containerd.[ wasmedge | wasmtime ].v1 docker.io/library/wasmtest:latest testwasm&lt;/code&gt;. You should see some output repeated like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;$ sudo ctr run --rm --runtime=io.containerd.wasmedge.v1 docker.io/library/wasmtest:latest testwasm&#xA;&#xA;This is a song that never ends.&#xA;Yes, it goes on and on my friends.&#xA;Some people started singing it not knowing what it was,&#xA;So they&#39;ll continue singing it forever just because...&#xA;&#xA;This is a song that never ends.&#xA;Yes, it goes on and on my friends.&#xA;Some people started singing it not knowing what it was,&#xA;So they&#39;ll continue singing it forever just because...&#xA;&#xA;(...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To kill the process from the case 2. demo, you can run in other session: &lt;code&gt;sudo ctr task kill -s SIGKILL testwasm&lt;/code&gt;. And the test binary supports full commands, check &lt;a href=&#34;https://raw.githubusercontent.com/containerd/runwasi/main/test/image/src/main.rs&#34;&gt;test/image/src/main.rs&lt;/a&gt; to play around more.&lt;/p&gt;</summary>
  </entry>
</feed>