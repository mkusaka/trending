<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-09T01:46:37Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zama-ai/tfhe-rs</title>
    <updated>2023-05-09T01:46:37Z</updated>
    <id>tag:github.com,2023-05-09:/zama-ai/tfhe-rs</id>
    <link href="https://github.com/zama-ai/tfhe-rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;TFHE-rs: Pure Rust implementation of the TFHE scheme for boolean and integers FHE arithmetics.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;!-- product name logo --&gt; &lt;img width=&#34;600&#34; src=&#34;https://user-images.githubusercontent.com/5758427/231206749-8f146b97-3c5a-4201-8388-3ffa88580415.png&#34;&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://docs.zama.ai/tfhe-rs&#34;&gt; ðŸ“’ Read documentation&lt;/a&gt; | &lt;a href=&#34;https://zama.ai/community&#34;&gt; ðŸ’› Community support&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &#xA; &lt;!-- Version badge using shields.io --&gt; &lt;a href=&#34;https://github.com/zama-ai/tfhe-rs/releases&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/v/release/zama-ai/tfhe-rs?style=flat-square&#34;&gt; &lt;/a&gt; &#xA; &lt;!-- Zama Bounty Program --&gt; &lt;a href=&#34;https://github.com/zama-ai/bounty-program&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Contribute-Zama%20Bounty%20Program-yellow?style=flat-square&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;strong&gt;TFHE-rs&lt;/strong&gt; is a pure Rust implementation of TFHE for boolean and integer arithmetics over encrypted data. It includes:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a &lt;strong&gt;Rust&lt;/strong&gt; API&lt;/li&gt; &#xA; &lt;li&gt;a &lt;strong&gt;C&lt;/strong&gt; API&lt;/li&gt; &#xA; &lt;li&gt;and a &lt;strong&gt;client-side WASM&lt;/strong&gt; API&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;TFHE-rs&lt;/strong&gt; is meant for developers and researchers who want full control over what they can do with TFHE, while not having to worry about the low level implementation. The goal is to have a stable, simple, high-performance, and production-ready library for all the advanced features of TFHE.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;To use the latest version of &lt;code&gt;TFHE-rs&lt;/code&gt; in your project, you first need to add it as a dependency in your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For x86_64-based machines running Unix-like OSes:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;tfhe = { version = &#34;*&#34;, features = [&#34;boolean&#34;, &#34;shortint&#34;, &#34;integer&#34;, &#34;x86_64-unix&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For Apple Silicon or aarch64-based machines running Unix-like OSes:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;tfhe = { version = &#34;*&#34;, features = [&#34;boolean&#34;, &#34;shortint&#34;, &#34;integer&#34;, &#34;aarch64-unix&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: users with ARM devices must use &lt;code&gt;TFHE-rs&lt;/code&gt; by compiling using the &lt;code&gt;nightly&lt;/code&gt; toolchain.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For x86_64-based machines with the &lt;a href=&#34;https://en.wikipedia.org/wiki/RDRAND&#34;&gt;&lt;code&gt;rdseed instruction&lt;/code&gt;&lt;/a&gt; running Windows:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;tfhe = { version = &#34;*&#34;, features = [&#34;boolean&#34;, &#34;shortint&#34;, &#34;integer&#34;, &#34;x86_64&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note: aarch64-based machines are not yet supported for Windows as it&#39;s currently missing an entropy source to be able to seed the &lt;a href=&#34;https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator&#34;&gt;CSPRNGs&lt;/a&gt; used in TFHE-rs&lt;/p&gt; &#xA;&lt;p&gt;Note that when running code that uses &lt;code&gt;tfhe-rs&lt;/code&gt;, it is highly recommended to run in release mode with cargo&#39;s &lt;code&gt;--release&lt;/code&gt; flag to have the best performances possible, eg: &lt;code&gt;cargo run --release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Here is a full example evaluating a Boolean circuit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use tfhe::boolean::prelude::*;&#xA;&#xA;fn main() {&#xA;    // We generate a set of client/server keys, using the default parameters:&#xA;    let (mut client_key, mut server_key) = gen_keys();&#xA;&#xA;    // We use the client secret key to encrypt two messages:&#xA;    let ct_1 = client_key.encrypt(true);&#xA;    let ct_2 = client_key.encrypt(false);&#xA;&#xA;    // We use the server public key to execute a boolean circuit:&#xA;    // if ((NOT ct_2) NAND (ct_1 AND ct_2)) then (NOT ct_2) else (ct_1 AND ct_2)&#xA;    let ct_3 = server_key.not(&amp;amp;ct_2);&#xA;    let ct_4 = server_key.and(&amp;amp;ct_1, &amp;amp;ct_2);&#xA;    let ct_5 = server_key.nand(&amp;amp;ct_3, &amp;amp;ct_4);&#xA;    let ct_6 = server_key.mux(&amp;amp;ct_5, &amp;amp;ct_3, &amp;amp;ct_4);&#xA;&#xA;    // We use the client key to decrypt the output of the circuit:&#xA;    let output = client_key.decrypt(&amp;amp;ct_6);&#xA;    assert_eq!(output, true);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Another example of how the library can be used with shortints:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use tfhe::shortint::prelude::*;&#xA;&#xA;fn main() {&#xA;    // Generate a set of client/server keys&#xA;    // with 2 bits of message and 2 bits of carry&#xA;    let (client_key, server_key) = gen_keys(PARAM_MESSAGE_2_CARRY_2);&#xA;&#xA;    let msg1 = 3;&#xA;    let msg2 = 2;&#xA;&#xA;    // Encrypt two messages using the (private) client key:&#xA;    let ct_1 = client_key.encrypt(msg1);&#xA;    let ct_2 = client_key.encrypt(msg2);&#xA;&#xA;    // Homomorphically compute an addition&#xA;    let ct_add = server_key.unchecked_add(&amp;amp;ct_1, &amp;amp;ct_2);&#xA;&#xA;    // Define the Hamming weight function&#xA;    // f: x -&amp;gt; sum of the bits of x&#xA;    let f = |x:u64| x.count_ones() as u64;&#xA;&#xA;    // Generate the accumulator for the function&#xA;    let acc = server_key.generate_accumulator(f);&#xA;&#xA;    // Compute the function over the ciphertext using the PBS&#xA;    let ct_res = server_key.apply_lookup_table(&amp;amp;ct_add, &amp;amp;acc);&#xA;&#xA;    // Decrypt the ciphertext using the (private) client key&#xA;    let output = client_key.decrypt(&amp;amp;ct_res);&#xA;    assert_eq!(output, f(msg1 + msg2));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example using integer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use tfhe::integer::gen_keys_radix;&#xA;use tfhe::shortint::parameters::PARAM_MESSAGE_2_CARRY_2;&#xA;&#xA;fn main() {&#xA;    // We create keys to create 16 bits integers&#xA;    // using 8 blocks of 2 bits&#xA;    let (cks, sks) = gen_keys_radix(&amp;amp;PARAM_MESSAGE_2_CARRY_2, 8);&#xA;&#xA;    let clear_a = 2382u16;&#xA;    let clear_b = 29374u16;&#xA;&#xA;    let mut a = cks.encrypt(clear_a as u64);&#xA;    let mut b = cks.encrypt(clear_b as u64);&#xA;&#xA;    let encrypted_max = sks.smart_max_parallelized(&amp;amp;mut a, &amp;amp;mut b);&#xA;    let decrypted_max: u64 = cks.decrypt(&amp;amp;encrypted_max);&#xA;&#xA;    assert_eq!(decrypted_max as u16, clear_a.max(clear_b))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways to contribute to TFHE-rs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;you can open issues to report bugs or typos, or to suggest new ideas&lt;/li&gt; &#xA; &lt;li&gt;you can ask to become an official contributor by emailing &lt;a href=&#34;mailto:hello@zama.ai&#34;&gt;hello@zama.ai&lt;/a&gt;. (becoming an approved contributor involves signing our Contributor License Agreement (CLA))&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Only approved contributors can send pull requests, so please make sure to get in touch before you do!&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This library uses several dependencies and we would like to thank the contributors of those libraries.&lt;/p&gt; &#xA;&lt;h2&gt;Need support?&lt;/h2&gt; &#xA;&lt;a target=&#34;_blank&#34; href=&#34;https://community.zama.ai&#34;&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/5758427/231115030-21195b55-2629-4c01-9809-be5059243999.png&#34;&gt; &lt;/a&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This software is distributed under the BSD-3-Clause-Clear license. If you have any questions, please contact us at &lt;code&gt;hello@zama.ai&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimers&lt;/h2&gt; &#xA;&lt;h3&gt;Security Estimation&lt;/h3&gt; &#xA;&lt;p&gt;Security estimations are done using the &lt;a href=&#34;https://github.com/malb/lattice-estimator&#34;&gt;Lattice Estimator&lt;/a&gt; with &lt;code&gt;red_cost_model = reduction.RC.BDGL16&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When a new update is published in the Lattice Estimator, we update parameters accordingly.&lt;/p&gt; &#xA;&lt;h3&gt;Side-Channel Attacks&lt;/h3&gt; &#xA;&lt;p&gt;Mitigation for side channel attacks have not yet been implemented in TFHE-rs, and will be released in upcoming versions.&lt;/p&gt;</summary>
  </entry>
</feed>