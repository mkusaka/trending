<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-20T01:49:02Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>postgresml/pgcat</title>
    <updated>2023-06-20T01:49:02Z</updated>
    <id>tag:github.com,2023-06-20:/postgresml/pgcat</id>
    <link href="https://github.com/postgresml/pgcat" rel="alternate"></link>
    <summary type="html">&lt;p&gt;PostgreSQL pooler with sharding, load balancing and failover support.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;PgCat: Nextgen PostgreSQL Pooler&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com/gh/postgresml/pgcat/tree/main&#34;&gt;&lt;img src=&#34;https://circleci.com/gh/postgresml/pgcat/tree/main.svg?style=svg&#34; alt=&#34;CircleCI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/DmyJP3qJ7U&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;https://img.shields.io/discord/1013868243036930099&#34; alt=&#34;Join our Discord!&#34;&gt; &lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;PostgreSQL pooler and proxy (like PgBouncer) with support for sharding, load balancing, failover and mirroring.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Feature&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Status&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Comments&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Transaction pooling&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Identical to PgBouncer with notable improvements for handling bad clients and abandoned transactions.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Session pooling&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Identical to PgBouncer.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Multi-threaded runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Using Tokio asynchronous runtime, the pooler takes advantage of multicore machines.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Load balancing of read queries&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Queries are automatically load balanced between replicas and the primary.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Failover&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Queries are automatically rerouted around broken replicas, validated by regular health checks.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Admin database statistics&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Pooler statistics and administration via the &lt;code&gt;pgbouncer&lt;/code&gt; and &lt;code&gt;pgcat&lt;/code&gt; databases.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Prometheus statistics&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Statistics are reported via a HTTP endpoint for Prometheus.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SSL/TLS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Clients can connect to the pooler using TLS. Pooler can connect to Postgres servers using TLS.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Client/Server authentication&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Clients can connect using MD5 authentication, supported by &lt;code&gt;libpq&lt;/code&gt; and all Postgres client drivers. PgCat can connect to Postgres using MD5 and SCRAM-SHA-256.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Live configuration reloading&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Identical to PgBouncer; all settings can be reloaded dynamically (except &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Auth passthrough&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Stable&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;MD5 password authentication can be configured to use an &lt;code&gt;auth_query&lt;/code&gt; so no cleartext passwords are needed in the config file.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Sharding using extended SQL syntax&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Clients can dynamically configure the pooler to route queries to specific shards.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Sharding using comments parsing/Regex&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Clients can include shard information (sharding key, shard ID) in the query comments.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Automatic sharding&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;PgCat can parse queries, detect sharding keys automatically, and route queries to the correct shard.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Mirroring&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;Experimental&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Mirror queries between multiple databases in order to test servers with realistic production traffic.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;PgCat is stable and used in production to serve hundreds of thousands of queries per second.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://tech.instacart.com/adopting-pgcat-a-nextgen-postgres-proxy-3cf284e68c2f&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/postgresml/pgcat/main/images/instacart.webp&#34; height=&#34;70&#34; width=&#34;auto&#34;&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://postgresml.org/blog/scaling-postgresml-to-one-million-requests-per-second&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/postgresml/pgcat/main/images/postgresml.webp&#34; height=&#34;70&#34; width=&#34;auto&#34;&gt; &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://onesignal.com&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/postgresml/pgcat/main/images/one_signal.webp&#34; height=&#34;70&#34; width=&#34;auto&#34;&gt; &lt;/a&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://tech.instacart.com/adopting-pgcat-a-nextgen-postgres-proxy-3cf284e68c2f&#34;&gt; Instacart &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;a href=&#34;https://postgresml.org/blog/scaling-postgresml-to-one-million-requests-per-second&#34;&gt; PostgresML &lt;/a&gt; &lt;/td&gt; &#xA;   &lt;td&gt; OneSignal &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;p&gt;Some features remain experimental and are being actively developed. They are optional and can be enabled through configuration.&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;code&gt;Dockerfile&lt;/code&gt; for example deployment using Docker. The pooler is configured to spawn 4 workers so 4 CPUs are recommended for optimal performance. That setting can be adjusted to spawn as many (or as little) workers as needed.&lt;/p&gt; &#xA;&lt;p&gt;A Docker image is available from &lt;code&gt;docker pull ghcr.io/postgresml/pgcat:latest&lt;/code&gt;. See our &lt;a href=&#34;https://github.com/postgresml/pgcat/pkgs/container/pgcat&#34;&gt;Github packages repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For quick local example, use the Docker Compose environment provided:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-compose up&#xA;&#xA;# In a new terminal:&#xA;PGPASSWORD=postgres psql -h 127.0.0.1 -p 6432 -U postgres -c &#39;SELECT 1&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Config&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;strong&gt;&lt;a href=&#34;https://github.com/levkk/pgcat/raw/main/CONFIG.md&#34;&gt;Configuration&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;The project is being actively developed and looking for additional contributors and production deployments.&lt;/p&gt; &#xA;&lt;h3&gt;Local development&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Rust (latest stable will work great).&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo build --release&lt;/code&gt; (to get better benchmarks).&lt;/li&gt; &#xA; &lt;li&gt;Change the config in &lt;code&gt;pgcat.toml&lt;/code&gt; to fit your setup (optional given next step).&lt;/li&gt; &#xA; &lt;li&gt;Install Postgres and run &lt;code&gt;psql -f tests/sharding/query_routing_setup.sql&lt;/code&gt; (user/password may be required depending on your setup)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;RUST_LOG=info cargo run --release&lt;/code&gt; You&#39;re ready to go!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Tests&lt;/h3&gt; &#xA;&lt;p&gt;When making substantial modifications to the protocol implementation, make sure to test them with pgbench:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pgbench -i -h 127.0.0.1 -p 6432 &amp;amp;&amp;amp; \&#xA;pgbench -t 1000 -p 6432 -h 127.0.0.1 --protocol simple &amp;amp;&amp;amp; \&#xA;pgbench -t 1000 -p 6432 -h 127.0.0.1 --protocol extended&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/postgresml/pgcat/main/tests/sharding/README.md&#34;&gt;sharding README&lt;/a&gt; for sharding logic testing.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, all features are tested with Ruby, Python, and Rust unit and integration tests.&lt;/p&gt; &#xA;&lt;p&gt;Run &lt;code&gt;cargo test&lt;/code&gt; to run Rust unit tests.&lt;/p&gt; &#xA;&lt;p&gt;Run the following commands to run Ruby and Python integration tests:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd tests/docker/&#xA;docker compose up --exit-code-from main # This will also produce coverage report under ./cov/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Docker-based local development&lt;/h3&gt; &#xA;&lt;p&gt;You can open a Docker development environment where you can debug tests easier. Run the following command to spin it up:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;./dev/script/console&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will open a terminal in an environment similar to that used in tests. In there, you can compile the pooler, run tests, do some debugging with the test environment, etc. Objects compiled inside the container (and bundled gems) will be placed in &lt;code&gt;dev/cache&lt;/code&gt; so they don&#39;t interfere with what you have on your machine.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Session mode&lt;/h3&gt; &#xA;&lt;p&gt;In session mode, a client talks to one server for the duration of the connection. Prepared statements, &lt;code&gt;SET&lt;/code&gt;, and advisory locks are supported. In terms of supported features, there is very little if any difference between session mode and talking directly to the server.&lt;/p&gt; &#xA;&lt;p&gt;To use session mode, change &lt;code&gt;pool_mode = &#34;session&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Transaction mode&lt;/h3&gt; &#xA;&lt;p&gt;In transaction mode, a client talks to one server for the duration of a single transaction; once it&#39;s over, the server is returned to the pool. Prepared statements, &lt;code&gt;SET&lt;/code&gt;, and advisory locks are not supported; alternatives are to use &lt;code&gt;SET LOCAL&lt;/code&gt; and &lt;code&gt;pg_advisory_xact_lock&lt;/code&gt; which are scoped to the transaction.&lt;/p&gt; &#xA;&lt;p&gt;This mode is enabled by default.&lt;/p&gt; &#xA;&lt;h3&gt;Load balancing of read queries&lt;/h3&gt; &#xA;&lt;p&gt;All queries are load balanced against the configured servers using either the random or least open connections algorithms. The most straightforward configuration example would be to put this pooler in front of several replicas and let it load balance all queries.&lt;/p&gt; &#xA;&lt;p&gt;If the configuration includes a primary and replicas, the queries can be separated with the built-in query parser. The query parser, implemented with the &lt;code&gt;sqlparser&lt;/code&gt; crate, will interpret the query and route all &lt;code&gt;SELECT&lt;/code&gt; queries to a replica, while all other queries including explicit transactions will be routed to the primary.&lt;/p&gt; &#xA;&lt;h4&gt;Query parser&lt;/h4&gt; &#xA;&lt;p&gt;The query parser will do its best to determine where the query should go, but sometimes that&#39;s not possible. In that case, the client can select which server it wants using this custom SQL syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- To talk to the primary for the duration of the next transaction:&#xA;SET SERVER ROLE TO &#39;primary&#39;;&#xA;&#xA;-- To talk to the replica for the duration of the next transaction:&#xA;SET SERVER ROLE TO &#39;replica&#39;;&#xA;&#xA;-- Let the query parser decide&#xA;SET SERVER ROLE TO &#39;auto&#39;;&#xA;&#xA;-- Pick any server at random&#xA;SET SERVER ROLE TO &#39;any&#39;;&#xA;&#xA;-- Reset to default configured settings&#xA;SET SERVER ROLE TO &#39;default&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The setting will persist until it&#39;s changed again or the client disconnects.&lt;/p&gt; &#xA;&lt;p&gt;By default, all queries are routed to the first available server; &lt;code&gt;default_role&lt;/code&gt; setting controls this behavior.&lt;/p&gt; &#xA;&lt;h3&gt;Failover&lt;/h3&gt; &#xA;&lt;p&gt;All servers are checked with a &lt;code&gt;;&lt;/code&gt; (very fast) query before being given to a client. Additionally, the server health is monitored with every client query that it processes. If the server is not reachable, it will be banned and cannot serve any more transactions for the duration of the ban. The queries are routed to the remaining servers. If all servers become banned, the ban list is cleared: this is a safety precaution against false positives. The primary can never be banned.&lt;/p&gt; &#xA;&lt;p&gt;The ban time can be changed with &lt;code&gt;ban_time&lt;/code&gt;. The default is 60 seconds.&lt;/p&gt; &#xA;&lt;h3&gt;Sharding&lt;/h3&gt; &#xA;&lt;p&gt;We use the &lt;code&gt;PARTITION BY HASH&lt;/code&gt; hashing function, the same as used by Postgres for declarative partitioning. This allows to shard the database using Postgres partitions and place the partitions on different servers (shards). Both read and write queries can be routed to the shards using this pooler.&lt;/p&gt; &#xA;&lt;h4&gt;Extended syntax&lt;/h4&gt; &#xA;&lt;p&gt;To route queries to a particular shard, we use this custom SQL syntax:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- To talk to a shard explicitly&#xA;SET SHARD TO &#39;1&#39;;&#xA;&#xA;-- To let the pooler choose based on a value&#xA;SET SHARDING KEY TO &#39;1234&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The active shard will last until it&#39;s changed again or the client disconnects. By default, the queries are routed to shard 0.&lt;/p&gt; &#xA;&lt;p&gt;For hash function implementation, see &lt;code&gt;src/sharding.rs&lt;/code&gt; and &lt;code&gt;tests/sharding/partition_hash_test_setup.sql&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;ActiveRecord/Rails&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class User &amp;lt; ActiveRecord::Base&#xA;end&#xA;&#xA;# Metadata will be fetched from shard 0&#xA;ActiveRecord::Base.establish_connection&#xA;&#xA;# Grab a bunch of users from shard 1&#xA;User.connection.execute &#34;SET SHARD TO &#39;1&#39;&#34;&#xA;User.take(10)&#xA;&#xA;# Using id as the sharding key&#xA;User.connection.execute &#34;SET SHARDING KEY TO &#39;1234&#39;&#34;&#xA;User.find_by_id(1234)&#xA;&#xA;# Using geographical sharding&#xA;User.connection.execute &#34;SET SERVER ROLE TO &#39;primary&#39;&#34;&#xA;User.connection.execute &#34;SET SHARDING KEY TO &#39;85&#39;&#34;&#xA;User.create(name: &#34;test user&#34;, email: &#34;test@example.com&#34;, zone_id: 85)&#xA;&#xA;# Let the query parser figure out where the query should go.&#xA;# We are still on shard = hash(85) % shards.&#xA;User.connection.execute &#34;SET SERVER ROLE TO &#39;auto&#39;&#34;&#xA;User.find_by_email(&#34;test@example.com&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Raw SQL&lt;/h5&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- Grab a bunch of users from shard 1&#xA;SET SHARD TO &#39;1&#39;;&#xA;SELECT * FROM users LIMT 10;&#xA;&#xA;-- Find by id&#xA;SET SHARDING KEY TO &#39;1234&#39;;&#xA;SELECT * FROM USERS WHERE id = 1234;&#xA;&#xA;-- Writing in a primary/replicas configuration.&#xA;SET SHARDING ROLE TO &#39;primary&#39;;&#xA;SET SHARDING KEY TO &#39;85&#39;;&#xA;INSERT INTO users (name, email, zome_id) VALUES (&#39;test user&#39;, &#39;test@example.com&#39;, 85);&#xA;&#xA;SET SERVER ROLE TO &#39;auto&#39;; -- let the query router figure out where the query should go&#xA;SELECT * FROM users WHERE email = &#39;test@example.com&#39;; -- shard setting lasts until set again; we are reading from the primary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;With comments&lt;/h4&gt; &#xA;&lt;p&gt;Issuing queries to the pooler can cause additional latency. To reduce its impact, it&#39;s possible to include sharding information inside SQL comments sent via the query. This is reasonably easy to implement with ORMs like &lt;a href=&#34;https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-annotate&#34;&gt;ActiveRecord&lt;/a&gt; and &lt;a href=&#34;https://docs.sqlalchemy.org/en/20/core/events.html#sql-execution-and-connection-events&#34;&gt;SQLAlchemy&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/* shard_id: 5 */ SELECT * FROM foo WHERE id = 1234;&#xA;&#xA;/* sharding_key: 1234 */ SELECT * FROM foo WHERE id = 1234;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Automatic query parsing&lt;/h4&gt; &#xA;&lt;p&gt;PgCat can use the &lt;code&gt;sqlparser&lt;/code&gt; crate to parse SQL queries and extract the sharding key. This is configurable with the &lt;code&gt;automatic_sharding_key&lt;/code&gt; setting. This feature is still experimental, but it&#39;s the ideal implementation for sharding, requiring no client modifications.&lt;/p&gt; &#xA;&lt;h3&gt;Statistics reporting&lt;/h3&gt; &#xA;&lt;p&gt;The stats are very similar to what PgBouncer reports and the names are kept to be comparable. They are accessible by querying the admin database &lt;code&gt;pgcat&lt;/code&gt;, and &lt;code&gt;pgbouncer&lt;/code&gt; for compatibility.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;psql -h 127.0.0.1 -p 6432 -d pgbouncer -c &#39;SHOW DATABASES&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, Prometheus statistics are available at &lt;code&gt;/metrics&lt;/code&gt; via HTTP.&lt;/p&gt; &#xA;&lt;h3&gt;Live configuration reloading&lt;/h3&gt; &#xA;&lt;p&gt;The config can be reloaded by sending a &lt;code&gt;kill -s SIGHUP&lt;/code&gt; to the process or by querying &lt;code&gt;RELOAD&lt;/code&gt; to the admin database. All settings except the &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; can be reloaded without restarting the pooler, including sharding and replicas configurations.&lt;/p&gt; &#xA;&lt;h3&gt;Mirroring&lt;/h3&gt; &#xA;&lt;p&gt;Mirroring allows to route queries to multiple databases at the same time. This is useful for prewarning replicas before placing them into the active configuration, or for testing different versions of Postgres with live traffic.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;PgCat is free and open source, released under the MIT license.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Many thanks to our amazing contributors!&lt;/p&gt; &#xA;&lt;a href=&#34;https://github.com/postgresml/pgcat/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=postgresml/pgcat&#34;&gt; &lt;/a&gt;</summary>
  </entry>
  <entry>
    <title>dragonflyoss/image-service</title>
    <updated>2023-06-20T01:49:02Z</updated>
    <id>tag:github.com,2023-06-20:/dragonflyoss/image-service</id>
    <link href="https://github.com/dragonflyoss/image-service" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nydus - the Dragonfly image service, providing fast, secure and easy access to container images.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/releases&#34;&gt;&lt;strong&gt;[⬇️ Download]&lt;/strong&gt;&lt;/a&gt; &lt;a href=&#34;https://nydus.dev/&#34;&gt;&lt;strong&gt;[📖 Website]&lt;/strong&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/containerd/nydus-snapshotter/raw/main/docs/run_nydus_in_kubernetes.md&#34;&gt;&lt;strong&gt;[☸ Quick Start (Kubernetes)&lt;/strong&gt;]&lt;/a&gt; &lt;a href=&#34;https://github.com/containerd/nerdctl/raw/master/docs/nydus.md&#34;&gt;&lt;strong&gt;[🤓 Quick Start (nerdctl)&lt;/strong&gt;]&lt;/a&gt; &lt;a href=&#34;https://github.com/dragonflyoss/image-service/wiki/FAQ&#34;&gt;&lt;strong&gt;[❓ FAQs &amp;amp; Troubleshooting]&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Nydus: Dragonfly Container Image Service&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/misc/logo.svg?sanitize=true&#34; width=&#34;170&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/dragonflyoss/image-service?style=flat&#34; alt=&#34;Release Version&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/nydus-rs&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/l/nydus-rs&#34; alt=&#34;License&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/dragonfly_oss&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/url?style=social&amp;amp;url=https%3A%2F%2Ftwitter.com%2Fdragonfly_oss&#34; alt=&#34;Twitter&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dragonflyoss/image-service&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/dragonflyoss/image-service?label=Nydus%20Stars&amp;amp;style=social&#34; alt=&#34;Nydus Stars&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/smoke.yml&#34;&gt;&lt;img src=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/smoke.yml/badge.svg?event=schedule&#34; alt=&#34;Smoke Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/convert.yml&#34;&gt;&lt;img src=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/convert.yml/badge.svg?event=schedule&#34; alt=&#34;Image Conversion&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/integration.yml&#34;&gt;&lt;img src=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/integration.yml/badge.svg?event=schedule&#34; alt=&#34;Integration Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/release.yml&#34;&gt;&lt;img src=&#34;https://github.com/dragonflyoss/image-service/actions/workflows/release.yml/badge.svg?event=schedule&#34; alt=&#34;Release Test Daily&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/dragonflyoss/image-service&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/dragonflyoss/image-service/branch/master/graph/badge.svg?sanitize=true&#34; alt=&#34;Coverage&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Nydus implements a content-addressable file system on the RAFS format, which enhances the current OCI image specification by improving container launch speed, image space and network bandwidth efficiency, and data integrity.&lt;/p&gt; &#xA;&lt;p&gt;The following Benchmarking results demonstrate that Nydus images significantly outperform OCI images in terms of container cold startup elapsed time on Containerd, particularly as the OCI image size increases.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/misc/perf.jpg&#34; alt=&#34;Container Cold Startup&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Principles&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Provide Fast, Secure And Easy Access to Data Distribution&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt;: Second-level container startup speed, millisecond-level function computation code package loading speed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Low Cost&lt;/strong&gt;: Written in memory-safed language &lt;code&gt;Rust&lt;/code&gt;, numerous optimizations help improve memory, CPU, and network consumption.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Flexible&lt;/strong&gt;: Supports container runtimes such as &lt;a href=&#34;https://github.com/opencontainers/runc&#34;&gt;runC&lt;/a&gt; and &lt;a href=&#34;https://github.com/kata-containers&#34;&gt;Kata&lt;/a&gt;, and provides &lt;a href=&#34;https://github.com/confidential-containers&#34;&gt;Confidential Containers&lt;/a&gt; and vulnerability scanning capabilities&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt;: End to end data integrity check, Supply Chain Attack can be detected and avoided at runtime.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Key features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;On-demand Load&lt;/strong&gt;: Container images/packages are downloaded on-demand in chunk unit to boost startup.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Chunk Deduplication&lt;/strong&gt;: Chunk level data de-duplication cross-layer or cross-image to reduce storage, transport, and memory cost.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Compatible with Ecosystem&lt;/strong&gt;: Storage backend support with Registry, OSS, NAS, Shared Disk, and &lt;a href=&#34;https://d7y.io/&#34;&gt;P2P service&lt;/a&gt;. Compatible with the &lt;a href=&#34;https://github.com/dragonflyoss/image-service/raw/master/docs/nydus-zran.md&#34;&gt;OCI images&lt;/a&gt;, and provide native &lt;a href=&#34;https://github.com/containerd/stargz-snapshotter&#34;&gt;eStargz images&lt;/a&gt; support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Data Analyzability&lt;/strong&gt;: Record accesses, data layout optimization, prefetch, IO amplification, abnormal behavior detection.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;POSIX Compatibility&lt;/strong&gt;: In-Kernel EROFS or FUSE filesystems together with overlayfs provide full POSIX compatibility&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;I/O optimization&lt;/strong&gt;: Use merged filesystem tree, data prefetching and User I/O amplification to reduce read latency and improve user I/O performance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Ecosystem&lt;/h2&gt; &#xA;&lt;h3&gt;Nydus tools&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Tool&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/raw/master/docs/nydusd.md&#34;&gt;nydusd&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Nydus user-space daemon, it processes all fscache/FUSE messages from the kernel and parses Nydus images to fullfil those requests&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/raw/master/docs/nydus-image.md&#34;&gt;nydus-image&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Convert a single layer of OCI format container image into a nydus format container image generating meta part file and data part file respectively&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/raw/master/docs/nydusify.md&#34;&gt;nydusify&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;It pulls OCI image down and unpack it, invokes &lt;code&gt;nydus-image create&lt;/code&gt; to convert image and then pushes the converted image back to registry and data storage&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/raw/master/docs/nydus-image.md&#34;&gt;nydusctl&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Nydusd CLI client (&lt;code&gt;nydus-image inspect&lt;/code&gt;), query daemon&#39;s working status/metrics and configure it&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/tree/master/contrib/ctr-remote&#34;&gt;ctr-remote&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An enhanced &lt;code&gt;containerd&lt;/code&gt; CLI tool enable nydus support with &lt;code&gt;containerd&lt;/code&gt; ctr&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/nydusaccelerator/docker-nydus-graphdriver&#34;&gt;nydus-docker-graphdriver&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;[Experimental] Works as a &lt;code&gt;docker&lt;/code&gt; remote graph driver to control how images and containers are stored and managed&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/tree/master/contrib/nydus-overlayfs&#34;&gt;nydus-overlayfs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Containerd&lt;/code&gt; mount helper to invoke overlayfs mount with tweaking mount options a bit. So nydus prerequisites can be passed to vm-based runtime&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/contrib/nydus-backend-proxy/README.md&#34;&gt;nydus-backend-proxy&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;A simple HTTP server to serve local directory as a blob backend for nydusd&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Supported platforms&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th&gt;Platform&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Status&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Storage&lt;/td&gt; &#xA;   &lt;td&gt;Registry/OSS/S3/NAS&lt;/td&gt; &#xA;   &lt;td&gt;Support for OCI-compatible distribution implementations such as Docker Hub, Harbor, Github GHCR, Aliyun ACR, NAS, and Aliyun OSS-like object storage service&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Storage/Build&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/goharbor/acceleration-service&#34;&gt;Harbor&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Provides a general service for Harbor to support acceleration image conversion based on kinds of accelerator like Nydus and eStargz etc&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Distribution&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/Dragonfly2&#34;&gt;Dragonfly&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Improve the runtime performance of Nydus image even further with the Dragonfly P2P data distribution system&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Build&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/moby/buildkit/raw/master/docs/nydus.md&#34;&gt;Buildkit&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Provides the ability to build and export Nydus images directly from Dockerfile&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Build/Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/containerd/nerdctl/raw/master/docs/nydus.md&#34;&gt;Nerdctl&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The containerd client to build or run (requires nydus snapshotter) Nydus image&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/dragonflyoss/image-service/raw/master/docs/docker-env-setup.md&#34;&gt;Docker / Moby&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Run Nydus image in Docker container with containerd and nydus-snapshotter&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/containerd/nydus-snapshotter/raw/main/docs/run_nydus_in_kubernetes.md&#34;&gt;Kubernetes&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Run Nydus image using CRI interface&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/containerd/nydus-snapshotter&#34;&gt;Containerd&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Nydus Snapshotter, a containerd remote plugin to run Nydus image&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/containers/nydus-storage-plugin&#34;&gt;CRI-O / Podman&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Run Nydus image with CRI-O or Podman&lt;/td&gt; &#xA;   &lt;td&gt;🚧&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/kata-containers/kata-containers/raw/main/docs/design/kata-nydus-design.md&#34;&gt;KataContainers&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Run Nydus image in KataContainers as a native solution&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Runtime&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/latest/filesystems/erofs.html&#34;&gt;EROFS&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Run Nydus image directly in-kernel EROFS for even greater performance improvement&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;h3&gt;Build Binary&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# build debug binary&#xA;make&#xA;# build release binary&#xA;make release&#xA;# build static binary with docker&#xA;make docker-static&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Build Nydus Image&lt;/h3&gt; &#xA;&lt;p&gt;Convert OCIv1 image to Nydus image: &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/nydusify.md&#34;&gt;Nydusify&lt;/a&gt;, &lt;a href=&#34;https://github.com/goharbor/acceleration-service&#34;&gt;Acceld&lt;/a&gt; or &lt;a href=&#34;https://github.com/containerd/nerdctl/raw/master/docs/nydus.md#build-nydus-image-using-nerdctl-image-convert&#34;&gt;Nerdctl&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Build Nydus image from Dockerfile directly: &lt;a href=&#34;https://github.com/moby/buildkit/raw/master/docs/nydus.md&#34;&gt;Buildkit&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Build Nydus layer from various sources: &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/nydus-image.md&#34;&gt;Nydus Image Builder&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Image prefetch optimization&lt;/h4&gt; &#xA;&lt;p&gt;To further reduce container startup time, a nydus image with a prefetch list can be built using the NRI plugin (containerd &amp;gt;=1.7): &lt;a href=&#34;https://github.com/containerd/nydus-snapshotter/raw/main/docs/optimize_nydus_image.md&#34;&gt;Container Image Optimizer&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Run&lt;/h2&gt; &#xA;&lt;h3&gt;Quick Start&lt;/h3&gt; &#xA;&lt;p&gt;For more details on how to lazily start a container with &lt;code&gt;nydus-snapshotter&lt;/code&gt; and nydus image on Kubernetes nodes or locally use &lt;code&gt;nerdctl&lt;/code&gt; rather than CRI, please refer to &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/containerd-env-setup.md&#34;&gt;Nydus Setup&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Run Nydus Snapshotter&lt;/h3&gt; &#xA;&lt;p&gt;Nydus-snapshotter is a non-core sub-project of containerd.&lt;/p&gt; &#xA;&lt;p&gt;Check out its code and tutorial from &lt;a href=&#34;https://github.com/containerd/nydus-snapshotter&#34;&gt;Nydus-snapshotter repository&lt;/a&gt;. It works as a &lt;code&gt;containerd&lt;/code&gt; remote snapshotter to help setup container rootfs with nydus images, which handles nydus image format when necessary. When running without nydus images, it is identical to the containerd&#39;s builtin overlayfs snapshotter.&lt;/p&gt; &#xA;&lt;h3&gt;Run Nydusd Daemon&lt;/h3&gt; &#xA;&lt;p&gt;Normally, users do not need to start &lt;code&gt;nydusd&lt;/code&gt; by hand. It is started by &lt;code&gt;nydus-snapshotter&lt;/code&gt; when a container rootfs is prepared.&lt;/p&gt; &#xA;&lt;p&gt;Run Nydusd Daemon to serve Nydus image: &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/nydusd.md&#34;&gt;Nydusd&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Run Nydus with in-kernel EROFS filesystem&lt;/h3&gt; &#xA;&lt;p&gt;In-kernel EROFS has been fully compatible with RAFS v6 image format since Linux 5.16. In other words, uncompressed RAFS v6 images can be mounted over block devices since then.&lt;/p&gt; &#xA;&lt;p&gt;Since &lt;a href=&#34;https://lwn.net/Articles/896140&#34;&gt;Linux 5.19&lt;/a&gt;, EROFS has added a new file-based caching (fscache) backend. In this way, compressed RAFS v6 images can be mounted directly with fscache subsystem, even such images are partially available. &lt;code&gt;estargz&lt;/code&gt; can be converted on the fly and mounted in this way too.&lt;/p&gt; &#xA;&lt;p&gt;Guide to running Nydus with fscache: &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/nydus-fscache.md&#34;&gt;Nydus-fscache&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Run Nydus with Dragonfly P2P system&lt;/h3&gt; &#xA;&lt;p&gt;Nydus is deeply integrated with &lt;a href=&#34;https://d7y.io/&#34;&gt;Dragonfly&lt;/a&gt; P2P system, which can greatly reduce the network latency and the single point pressure of the registry server. Benchmarking results in the production environment demonstrate that using Dragonfly can reduce network latency by more than 80%, to understand the performance results and integration steps, please refer to the &lt;a href=&#34;https://d7y.io/docs/setup/integration/nydus&#34;&gt;nydus integration&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to deploy Dragonfly and Nydus at the same time through Helm, please refer to the &lt;strong&gt;&lt;a href=&#34;https://github.com/dragonflyoss/helm-charts/raw/main/INSTALL.md&#34;&gt;Quick Start&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Run OCI image directly with Nydus&lt;/h3&gt; &#xA;&lt;p&gt;Nydus is able to generate a tiny artifact called a &lt;code&gt;nydus zran&lt;/code&gt; from an existing OCI image in the short time. This artifact can be used to accelerate the container boot time without the need for a full image conversion. For more information, please see the &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/nydus-zran.md&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Run with Docker(Moby)&lt;/h3&gt; &#xA;&lt;p&gt;Nydus provides a variety of methods to support running on docker(Moby), please refer to &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/docker-env-setup.md&#34;&gt;Nydus Setup for Docker(Moby) Environment&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Run with macOS&lt;/h3&gt; &#xA;&lt;p&gt;Nydus can also run with macfuse(a.k.a osxfuse). For more details please read &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs/nydus_with_macos.md&#34;&gt;nydus with macOS&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Run eStargz image (with lazy pulling)&lt;/h3&gt; &#xA;&lt;p&gt;The containerd remote snapshotter plugin &lt;a href=&#34;https://github.com/containerd/nydus-snapshotter&#34;&gt;nydus-snapshotter&lt;/a&gt; can be used to run nydus images, or to run &lt;a href=&#34;https://github.com/containerd/stargz-snapshotter&#34;&gt;eStargz&lt;/a&gt; images directly by appending &lt;code&gt;--enable-stargz&lt;/code&gt; command line option.&lt;/p&gt; &#xA;&lt;p&gt;In the future, &lt;code&gt;zstd::chunked&lt;/code&gt; can work in this way as well.&lt;/p&gt; &#xA;&lt;h3&gt;Run Nydus Service&lt;/h3&gt; &#xA;&lt;p&gt;Using the key features of nydus as native in your project without preparing and invoking &lt;code&gt;nydusd&lt;/code&gt; deliberately, &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/service/README.md&#34;&gt;nydus-service&lt;/a&gt; helps to reuse the core services of nyuds.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Please visit &lt;a href=&#34;https://github.com/dragonflyoss/image-service/wiki&#34;&gt;&lt;strong&gt;Wiki&lt;/strong&gt;&lt;/a&gt;, or &lt;a href=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/docs&#34;&gt;&lt;strong&gt;docs&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;Nydus aims to form a &lt;strong&gt;vendor-neutral opensource&lt;/strong&gt; image distribution solution to all communities. Questions, bug reports, technical discussion, feature requests and contribution are always welcomed!&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re very pleased to hear your use cases any time. Feel free to reach us via Slack or Dingtalk.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Slack:&lt;/strong&gt; &lt;a href=&#34;https://join.slack.com/t/nydusimageservice/shared_invite/zt-pz4qvl4y-WIh4itPNILGhPS8JqdFm_w&#34;&gt;Nydus Workspace&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Twitter:&lt;/strong&gt; &lt;a href=&#34;https://twitter.com/dragonfly_oss&#34;&gt;@dragonfly_oss&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Dingtalk:&lt;/strong&gt; &lt;a href=&#34;https://qr.dingtalk.com/action/joingroup?code=v1,k1,ioWGzuDZEIO10Bf+/ohz4RcQqAkW0MtOwoG1nbbMxQg=&amp;amp;_dt_no_comment=1&amp;amp;origin=11&#34;&gt;34971767&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/dragonflyoss/image-service/master/misc/dingtalk.jpg&#34; width=&#34;250&#34; height=&#34;300&#34;&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Technical Meeting:&lt;/strong&gt; Every Wednesday at 06:00 UTC (Beijing, Shanghai 14:00), please see our &lt;a href=&#34;https://hackmd.io/@Nydus/Bk8u2X0p9&#34;&gt;HackMD&lt;/a&gt; page for more information.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>