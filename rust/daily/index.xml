<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-13T01:43:32Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>flows-network/github-pr-summary</title>
    <updated>2023-04-13T01:43:32Z</updated>
    <id>tag:github.com,2023-04-13:/flows-network/github-pr-summary</id>
    <link href="https://github.com/flows-network/github-pr-summary" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Use ChatGPT to summarize &amp; review GitHub Pull Requests&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;p align=&#34;center&#34;&gt;GPT Nitro for Github PR&lt;/p&gt;&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://discord.gg/ccZn9ZMfFf&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/chat-Discord-7289DA?logo=discord&#34; alt=&#34;flows.network Discord&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://twitter.com/flows_network&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/Twitter-1DA1F2?logo=twitter&amp;amp;logoColor=white&#34; alt=&#34;flows.network Twitter&#34;&gt; &lt;/a&gt; &lt;a href=&#34;https://flows.network/flow/new&#34;&gt; &lt;img src=&#34;https://img.shields.io/website?up_message=deploy&amp;amp;url=https%3A%2F%2Fflows.network%2Fflow%2Fnew&#34; alt=&#34;Create a flow&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/flows-network/github-pr-summary/main/#deploy-the-pr-summary-app-for-your-github-repo&#34;&gt;Deploy this function on flows.network&lt;/a&gt;, and you will get a GitHub ðŸ¤– to review and summarize Pull Requests. It helps busy open source contributors understand and make decisions on PRs faster! A few examples below!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WasmEdge/WasmEdge/pull/2394#issuecomment-1497819842&#34;&gt;[Rust] Improve support for host functions in the WasmEdge Rust SDK&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WasmEdge/WasmEdge/pull/1084#issuecomment-1497830324&#34;&gt;[bash] Support ARM architecture in the WasmEdge installer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/WasmEdge/WasmEdge/pull/2314#issuecomment-1497861516&#34;&gt;[C++] Add an eBPF plugin for WasmEdge&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Still not convinced? &lt;a href=&#34;https://github.com/second-state/wasmedge-quickjs/pull/82#issuecomment-1498299630&#34;&gt;See &#34;potential problems 1&#34; in this review&lt;/a&gt;, it identified an inefficient Rust implementation of an algorithm. ðŸ¤¯&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;How it works&lt;/h2&gt; &#xA;&lt;p&gt;This flow function (or ðŸ¤–) will be triggered and executed when a new PR is raised in the designated GitHub repo. It can also be triggered again when someone says a magic &#34;trigger phrase&#34; in the PR&#39;s comments section. Once triggered, the flow function collects the content in the PR, and asks ChatGPT/4 to review and summarize it. The result is then posted back to the PR as a comment. The flow functions are written in Rust and runs in hosted &lt;a href=&#34;https://github.com/wasmedge&#34;&gt;WasmEdge Runtimes&lt;/a&gt; on &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The GitHub repo is connected to the flow function via the &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt; platform. The &#34;trigger phrase&#34; can also be configured in &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://youtu.be/kvBhNBXmBaE&#34; taregt=&#34;_blank&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/kvBhNBXmBaE/hqdefault.jpg&#34;&gt;&lt;/a&gt;&lt;br&gt; &lt;i&gt;Click on the picture above to watch a 3-min tutorial video&lt;/i&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;p&gt;You will need to bring your own &lt;a href=&#34;https://openai.com/blog/openai-api&#34;&gt;OpenAI API key&lt;/a&gt;. If you do not already have one, &lt;a href=&#34;https://platform.openai.com/signup&#34;&gt;sign up here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You will also need to sign into &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt; from your GitHub account. It is free.&lt;/p&gt; &#xA;&lt;h2&gt;Deploy the PR review ðŸ¤– onto your GitHub repos&lt;/h2&gt; &#xA;&lt;p&gt;The ðŸ¤– is designed to run on &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt;, a serverless platform for SaaS and AI automation.&lt;/p&gt; &#xA;&lt;h3&gt;1 Fork this repo&lt;/h3&gt; &#xA;&lt;p&gt;Fork &lt;a href=&#34;https://github.com/flows-network/github-pr-summary/&#34;&gt;this repo&lt;/a&gt; into your own GitHub account.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;If your OpenAI API key has GPT4 access, you can change &lt;code&gt;GPT35Turbo&lt;/code&gt; to &lt;code&gt;GPT4&lt;/code&gt; in your fork of the source code. GPT4 provides substantially better code reviews, but it is also 10x more expensive.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;2 Deploy the bot&#39;s source code on flow.network&lt;/h3&gt; &#xA;&lt;p&gt;Go to &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt; to deploy your own flow function (ðŸ¤–) from the forked source code.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Click on the &#34;Create a Flow&#34; button to start.&lt;/li&gt; &#xA; &lt;li&gt;Authenticate the &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt; to access the &lt;code&gt;github-pr-summary&lt;/code&gt; repo you just forked. &lt;strong&gt;NOTE: This is NOT the repo you want to install the bot on.&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;img width=&#34;950&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/45785633/229329081-93728947-ad9f-44fb-85b1-067e6a0eb8ac.png&#34;&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Click on the &#34;Advanced&#34; link to see more settings. Fill in the following environment variables.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The 4 variables below are defined in the flow function&#39;s Rust source code. You can assign their values in the source code in your fork directly and skip the steps below.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;login&lt;/code&gt;: Your personal GitHub id. The GitHub app will act as you when posting reviews.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;owner&lt;/code&gt;: GitHub org for the repo you want to deploy the ðŸ¤– on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;repo&lt;/code&gt; : GitHub repo you want to deploy the ðŸ¤– on.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;trigger_phrase&lt;/code&gt;: The magic phrase to trigger a review from a PR comment.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Let&#39;s see an example. You forked the flow function source code to &lt;code&gt;my-name/github-pr-summary&lt;/code&gt; and would like to deploy the bot to summarize PRs on &lt;code&gt;my-company/work-project&lt;/code&gt; repo. Here &lt;code&gt;login = my-name&lt;/code&gt;, &lt;code&gt;owner = my-company&lt;/code&gt; and &lt;code&gt;repo = work-project&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;img width=&#34;886&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/45785633/229329142-b7d77e53-4f3a-4d87-9136-4216191b18fc.png&#34;&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Click on the Deploy button.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;3 Configure integrations&lt;/h3&gt; &#xA;&lt;p&gt;After that, &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt; will direct you to configure the external services required by your flow function ðŸ¤–.&lt;/p&gt; &#xA;&lt;img width=&#34;927&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/45785633/229329158-5ba162a6-1f06-4851-ad46-583840dd6891.png&#34;&gt; &#xA;&lt;p&gt;For this flow function, we need to configue two integrations.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Click on the &#34;Connect&#34; or &#34;+ Add new authentication&#34; button to add your OpenAI API key.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;img width=&#34;758&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/45785633/222973214-ecd052dc-72c2-4711-90ec-db1ec9d5f24e.png&#34;&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Click on the &#34;Connect&#34; or &#34;+ Add new authentication&#34; button to give the function access to the GitHub repo to deploy the ðŸ¤–. That is to give access to the &lt;code&gt;owner/repo&lt;/code&gt; in the environment variables. You&#39;ll be redirected to a new page where you must grant &lt;a href=&#34;https://flows.network/&#34;&gt;flows.network&lt;/a&gt; permission to the repo.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;After that, click on the &#34;Check&#34; button to go to the flow details page. As soon as the flow&#39;s status became &lt;code&gt;running&lt;/code&gt;, the PR summary GitHub bot is ready to give code reviews! The bot is summoned by every new PR or magic words (i.e., &lt;code&gt;trigger_phrase&lt;/code&gt;) in PR comments.&lt;/p&gt; &#xA;&lt;img width=&#34;1148&#34; alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/45785633/229329247-16273aec-f89b-4375-bf2b-4ffce5e35a33.png&#34;&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;This flow function is originally created by &lt;a href=&#34;https://github.com/jaykchen&#34;&gt;Jay Chen&lt;/a&gt;, and &lt;a href=&#34;https://github.com/jetjinser&#34;&gt;jinser&lt;/a&gt; made significant contributions to optimize the event triggers from GitHub.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.producthunt.com/posts/gpt-nitro-for-github-pr?utm_source=badge-featured&amp;amp;utm_medium=badge&amp;amp;utm_souce=badge-gpt-nitro-for-github-pr&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=387993&amp;amp;theme=light&#34; alt=&#34;GPT Nitro for Github PR - A ChatGPT-based reviewer for your GitHub pull requests | Product Hunt&#34; style=&#34;width: 250px; height: 54px;&#34; width=&#34;250&#34; height=&#34;54&#34;&gt;&lt;/a&gt; &lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>maciejhirsz/logos</title>
    <updated>2023-04-13T01:43:32Z</updated>
    <id>tag:github.com,2023-04-13:/maciejhirsz/logos</id>
    <link href="https://github.com/maciejhirsz/logos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Create ridiculously fast Lexers&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/maciejhirsz/logos/master/logos.svg?sanitize=true&#34; alt=&#34;Logos logo&#34; width=&#34;250&#34; align=&#34;right&#34;&gt; &#xA;&lt;h1&gt;Logos&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/maciejhirsz/logos/workflows/Test/badge.svg?branch=master&#34; alt=&#34;Test&#34;&gt; &lt;a href=&#34;https://crates.io/crates/logos&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/logos.svg?sanitize=true&#34; alt=&#34;Crates.io version shield&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/logos&#34;&gt;&lt;img src=&#34;https://docs.rs/logos/badge.svg?sanitize=true&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/logos&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/l/logos.svg?sanitize=true&#34; alt=&#34;Crates.io license shield&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Create ridiculously fast Lexers.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Logos&lt;/strong&gt; has two goals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;To make it easy to create a Lexer, so you can focus on more complex problems.&lt;/li&gt; &#xA; &lt;li&gt;To make the generated Lexer faster than anything you&#39;d write by hand.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To achieve those, &lt;strong&gt;Logos&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Combines all token definitions into a single &lt;a href=&#34;https://en.wikipedia.org/wiki/Deterministic_finite_automaton&#34;&gt;deterministic state machine&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Optimizes branches into &lt;a href=&#34;https://en.wikipedia.org/wiki/Lookup_table&#34;&gt;lookup tables&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Branch_table&#34;&gt;jump tables&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Prevents &lt;a href=&#34;https://en.wikipedia.org/wiki/ReDoS&#34;&gt;backtracking&lt;/a&gt; inside token definitions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Loop_unrolling&#34;&gt;Unwinds loops&lt;/a&gt;, and batches reads to minimize bounds checking.&lt;/li&gt; &#xA; &lt;li&gt;Does all of that heavy lifting at compile time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt; use logos::Logos;&#xA;&#xA; #[derive(Logos, Debug, PartialEq)]&#xA; #[logos(skip r&#34;[ \t\n\f]+&#34;)] // Ignore this regex pattern between tokens&#xA; enum Token {&#xA;     // Tokens can be literal strings, of any length.&#xA;     #[token(&#34;fast&#34;)]&#xA;     Fast,&#xA;&#xA;     #[token(&#34;.&#34;)]&#xA;     Period,&#xA;&#xA;     // Or regular expressions.&#xA;     #[regex(&#34;[a-zA-Z]+&#34;)]&#xA;     Text,&#xA; }&#xA;&#xA; fn main() {&#xA;     let mut lex = Token::lexer(&#34;Create ridiculously fast Lexers.&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Text)));&#xA;     assert_eq!(lex.span(), 0..6);&#xA;     assert_eq!(lex.slice(), &#34;Create&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Text)));&#xA;     assert_eq!(lex.span(), 7..19);&#xA;     assert_eq!(lex.slice(), &#34;ridiculously&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Fast)));&#xA;     assert_eq!(lex.span(), 20..24);&#xA;     assert_eq!(lex.slice(), &#34;fast&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Text)));&#xA;     assert_eq!(lex.slice(), &#34;Lexers&#34;);&#xA;     assert_eq!(lex.span(), 25..31);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Period)));&#xA;     assert_eq!(lex.span(), 31..32);&#xA;     assert_eq!(lex.slice(), &#34;.&#34;);&#xA;&#xA;     assert_eq!(lex.next(), None);&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Callbacks&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Logos&lt;/strong&gt; can also call arbitrary functions whenever a pattern is matched, which can be used to put data into a variant:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt; use logos::{Logos, Lexer};&#xA;&#xA; // Note: callbacks can return `Option` or `Result`&#xA; fn kilo(lex: &amp;amp;mut Lexer&amp;lt;Token&amp;gt;) -&amp;gt; Option&amp;lt;u64&amp;gt; {&#xA;     let slice = lex.slice();&#xA;     let n: u64 = slice[..slice.len() - 1].parse().ok()?; // skip &#39;k&#39;&#xA;     Some(n * 1_000)&#xA; }&#xA;&#xA; fn mega(lex: &amp;amp;mut Lexer&amp;lt;Token&amp;gt;) -&amp;gt; Option&amp;lt;u64&amp;gt; {&#xA;     let slice = lex.slice();&#xA;     let n: u64 = slice[..slice.len() - 1].parse().ok()?; // skip &#39;m&#39;&#xA;     Some(n * 1_000_000)&#xA; }&#xA;&#xA; #[derive(Logos, Debug, PartialEq)]&#xA; #[logos(skip r&#34;[ \t\n\f]+&#34;)]&#xA; enum Token {&#xA;     // Callbacks can use closure syntax, or refer&#xA;     // to a function defined elsewhere.&#xA;     //&#xA;     // Each pattern can have it&#39;s own callback.&#xA;     #[regex(&#34;[0-9]+&#34;, |lex| lex.slice().parse().ok())]&#xA;     #[regex(&#34;[0-9]+k&#34;, kilo)]&#xA;     #[regex(&#34;[0-9]+m&#34;, mega)]&#xA;     Number(u64),&#xA; }&#xA;&#xA; fn main() {&#xA;     let mut lex = Token::lexer(&#34;5 42k 75m&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Number(5))));&#xA;     assert_eq!(lex.slice(), &#34;5&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Number(42_000))));&#xA;     assert_eq!(lex.slice(), &#34;42k&#34;);&#xA;&#xA;     assert_eq!(lex.next(), Some(Ok(Token::Number(75_000_000))));&#xA;     assert_eq!(lex.slice(), &#34;75m&#34;);&#xA;&#xA;     assert_eq!(lex.next(), None);&#xA; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Logos can handle callbacks with following return types:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Return type&lt;/th&gt; &#xA;   &lt;th&gt;Produces&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Unit)&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Unit)&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;code&gt;Err(&amp;lt;Token as Logos&amp;gt;::Error::default())&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Unit)&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;code&gt;Err(&amp;lt;Token as Logos&amp;gt;::Error::from(err))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;T&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Value(T))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Value(T))&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;code&gt;Err(&amp;lt;Token as Logos&amp;gt;::Error::default())&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Value(T))&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;code&gt;Err(&amp;lt;Token as Logos&amp;gt;::Error::from(err))&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;[&lt;code&gt;Skip&lt;/code&gt;]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;em&gt;skips matched input&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;[&lt;code&gt;Filter&amp;lt;T&amp;gt;&lt;/code&gt;]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Value(T))&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;em&gt;skips matched input&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;[&lt;code&gt;FilterResult&amp;lt;T, E&amp;gt;&lt;/code&gt;]&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Ok(Token::Value(T))&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;code&gt;Err(&amp;lt;Token as Logos&amp;gt;::Error::from(err))&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;em&gt;skips matched input&lt;/em&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Callbacks can be also used to do perform more specialized lexing in place where regular expressions are too limiting. For specifics look at &lt;code&gt;Lexer::remainder&lt;/code&gt; and &lt;code&gt;Lexer::bump&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Errors&lt;/h2&gt; &#xA;&lt;p&gt;By default, &lt;strong&gt;Logos&lt;/strong&gt; uses &lt;code&gt;()&lt;/code&gt; as the error type, which means that it doesn&#39;t store any information about the error. This can be changed by using &lt;code&gt;#[logos(error = T)]&lt;/code&gt; attribute on the enum. The type &lt;code&gt;T&lt;/code&gt; can be any type that implements &lt;code&gt;Clone&lt;/code&gt;, &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;Default&lt;/code&gt; and &lt;code&gt;From&amp;lt;E&amp;gt;&lt;/code&gt; for each callback&#39;s error type &lt;code&gt;E&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Token disambiguation&lt;/h2&gt; &#xA;&lt;p&gt;Rule of thumb is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Longer beats shorter.&lt;/li&gt; &#xA; &lt;li&gt;Specific beats generic.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If any two definitions could match the same input, like &lt;code&gt;fast&lt;/code&gt; and &lt;code&gt;[a-zA-Z]+&lt;/code&gt; in the example above, it&#39;s the longer and more specific definition of &lt;code&gt;Token::Fast&lt;/code&gt; that will be the result.&lt;/p&gt; &#xA;&lt;p&gt;This is done by comparing numeric priority attached to each definition. Every consecutive, non-repeating single byte adds 2 to the priority, while every range or regex class adds 1. Loops or optional blocks are ignored, while alternations count the shortest alternative:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;[a-zA-Z]+&lt;/code&gt; has a priority of 1 (lowest possible), because at minimum it can match a single byte to a class.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;foobar&lt;/code&gt; has a priority of 12.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;(foo|hello)(bar)?&lt;/code&gt; has a priority of 6, &lt;code&gt;foo&lt;/code&gt; being it&#39;s shortest possible match.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If two definitions compute to the same priority and can match the same input &lt;strong&gt;Logos&lt;/strong&gt; will fail to compile, point out the problematic definitions, and ask you to specify a manual priority for either of them.&lt;/p&gt; &#xA;&lt;p&gt;For example: &lt;code&gt;[abc]+&lt;/code&gt; and &lt;code&gt;[cde]+&lt;/code&gt; both can match sequences of &lt;code&gt;c&lt;/code&gt;, and both have priority of 1. Turning the first definition to &lt;code&gt;#[regex(&#34;[abc]+&#34;, priority = 2)]&lt;/code&gt; will allow for tokens to be disambiguated again, in this case all sequences of &lt;code&gt;c&lt;/code&gt; will match &lt;code&gt;[abc]+&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How fast?&lt;/h2&gt; &#xA;&lt;p&gt;Ridiculously fast!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-norust&#34;&gt;test identifiers                       ... bench:         647 ns/iter (+/- 27) = 1204 MB/s&#xA;test keywords_operators_and_punctators ... bench:       2,054 ns/iter (+/- 78) = 1037 MB/s&#xA;test strings                           ... bench:         553 ns/iter (+/- 34) = 1575 MB/s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://pedrors.pt/&#34;&gt;Pedrors&lt;/a&gt; for the &lt;strong&gt;Logos&lt;/strong&gt; logo.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Thank you&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Logos&lt;/strong&gt; is very much a labor of love. If you find it useful, consider &lt;a href=&#34;https://github.com/sponsors/maciejhirsz&#34;&gt;getting me some coffee&lt;/a&gt;. â˜•&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This code is distributed under the terms of both the MIT license and the Apache License (Version 2.0), choose whatever works for you.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/maciejhirsz/logos/master/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/maciejhirsz/logos/master/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
</feed>