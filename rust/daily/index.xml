<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-02-22T01:38:05Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>oxidecomputer/typify</title>
    <updated>2025-02-22T01:38:05Z</updated>
    <id>tag:github.com,2025-02-22:/oxidecomputer/typify</id>
    <link href="https://github.com/oxidecomputer/typify" rel="alternate"></link>
    <summary type="html">&lt;p&gt;compiler from JSON Schema into idiomatic Rust types&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Typify&lt;/h1&gt; &#xA;&lt;p&gt;Typify compiles JSON Schema documents into Rust types. It can be used in one of several ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;using the &lt;a href=&#34;https://raw.githubusercontent.com/oxidecomputer/typify/main/cargo-typify/README.md&#34;&gt;&lt;code&gt;cargo typify&lt;/code&gt;&lt;/a&gt; command&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;via the macro &lt;code&gt;import_types!(&#34;types.json&#34;)&lt;/code&gt; to generate Rust types directly in your program&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;via a builder interface to generate Rust types in &lt;code&gt;build.rs&lt;/code&gt; or &lt;code&gt;xtask&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;via the builder functions to generate persistent files e.g. when building API bindings&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;If generation fails, doesn&#39;t compile or is generally lousy&lt;/strong&gt;: Please file an issue and include the JSON Schema and Rust output (if there is any). Use &lt;code&gt;cargo typify&lt;/code&gt; command to generate code from the command-line. It&#39;s even more helpful if you can articulate the output you&#39;d ideally like to see.&lt;/p&gt; &#xA;&lt;h2&gt;JSON Schema â†’ Rust types&lt;/h2&gt; &#xA;&lt;p&gt;JSON Schema is a constraint language designed for validation. As a result, it is not well-suited--and is often seemingly hostile--to translation into constructive type systems. It allows for expressions of arbitrary complexity with an infinity of ways to articulate a given set of constraints. As such, typify does its best to discern an appropriate interpretation, but it is far from perfect!&lt;/p&gt; &#xA;&lt;p&gt;Typify translates JSON Schema types in a few different ways depending on some basic properties of the schema:&lt;/p&gt; &#xA;&lt;h3&gt;Built-in types&lt;/h3&gt; &#xA;&lt;p&gt;Integers, floating-point numbers, strings, etc. Those all have straightforward representations in Rust. The only significant nuance is how to select the appropriate built-in type based on type attributes. For example, a JSON Schema might specify a maximum and/or minimum that indicates the appropriate integral type to use.&lt;/p&gt; &#xA;&lt;p&gt;String schemas that include a known &lt;code&gt;format&lt;/code&gt; are represented with the appropriate Rust type. For example &lt;code&gt;{ &#34;type&#34;: &#34;string&#34;, &#34;format&#34;: &#34;uuid&#34; }&lt;/code&gt; is represented as a &lt;code&gt;uuid::Uuid&lt;/code&gt; (which requires the &lt;code&gt;uuid&lt;/code&gt; crate be included as a dependency).&lt;/p&gt; &#xA;&lt;h3&gt;Arrays&lt;/h3&gt; &#xA;&lt;p&gt;JSON Schema arrays can turn into one of three Rust types &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt;, and tuples depending on the schema properties. An array may have a fixed length that matches a fixed list of item types; this is well represented by a Rust tuple. The distinction between &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt; is only if the schema&#39;s &lt;code&gt;uniqueItems&lt;/code&gt; field is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt; respectively.&lt;/p&gt; &#xA;&lt;h3&gt;Objects&lt;/h3&gt; &#xA;&lt;p&gt;In general, objects turn into Rust structs. If, however, the schema defines no properties, Typify emits a &lt;code&gt;HashMap&amp;lt;String, T&amp;gt;&lt;/code&gt; if the &lt;code&gt;additionalProperties&lt;/code&gt; schema specifies &lt;code&gt;T&lt;/code&gt; or a &lt;code&gt;HashMap&amp;lt;String, serde_json::Value&amp;gt;&lt;/code&gt; otherwise.&lt;/p&gt; &#xA;&lt;p&gt;Properties of generated &lt;code&gt;struct&lt;/code&gt; that are not in the &lt;code&gt;required&lt;/code&gt; set are typically represented as an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; with the &lt;code&gt;#[serde(default)]&lt;/code&gt; attribute applied. Non-required properties with types that already have a default value (such as a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;) simply get the &lt;code&gt;#[serde(default)]&lt;/code&gt; attribute (so you won&#39;t see e.g. &lt;code&gt;Option&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h4&gt;Alternate Map types&lt;/h4&gt; &#xA;&lt;p&gt;By default, Typify uses &lt;code&gt;std::collections::HashMap&lt;/code&gt; as described above.&lt;/p&gt; &#xA;&lt;p&gt;If you prefer to use &lt;code&gt;std::collections::BTreeMap&lt;/code&gt; or a map type from a crate such as &lt;code&gt;indexmap::IndexMap&lt;/code&gt;, you can specify this by calling &lt;code&gt;with_map_type&lt;/code&gt; on the &lt;code&gt;TypeSpaceSettings&lt;/code&gt; object, and providing the full path to the type you want to use. E.g. &lt;code&gt;::std::collections::BTreeMap&lt;/code&gt; or &lt;code&gt;::indexmap::IndexMap&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that for a custom map type to work you must have &lt;code&gt;T&lt;/code&gt; defined to generate a struct as described in &lt;a href=&#34;https://raw.githubusercontent.com/oxidecomputer/typify/main/#objects&#34;&gt;Objects&lt;/a&gt;. If &lt;code&gt;T&lt;/code&gt; is not defined, typify will generate code using a &lt;code&gt;serde_json::Map&amp;lt;String, serde_json::Value&amp;gt;&lt;/code&gt; instead.&lt;/p&gt; &#xA;&lt;p&gt;See the documentation for &lt;code&gt;TypeSpaceSettings::with_map_type&lt;/code&gt; for the requirements for a map type.&lt;/p&gt; &#xA;&lt;h3&gt;OneOf&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;oneOf&lt;/code&gt; construct maps to a Rust enum. Typify maps this to the various &lt;a href=&#34;https://serde.rs/enum-representations.html&#34;&gt;serde enum types&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;AllOf&lt;/h3&gt; &#xA;&lt;p&gt;The &#39;allOf&#39; construct is handled by merging schemas. While most of the time, typify tries to preserve and share type names, it can&#39;t always do this when merging schemas. You may end up with fields replicated across type; optimizing this generation is an area of active work.&lt;/p&gt; &#xA;&lt;h3&gt;AnyOf&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;anyOf&lt;/code&gt; construct is much trickier. If can be close to an &lt;code&gt;enum&lt;/code&gt; (&lt;code&gt;oneOf&lt;/code&gt;), but where no particular variant might be canonical or unique for particular data. While today we (imprecisely) model these as structs with optional, flattened members, this is one of the weaker areas of code generation.&lt;/p&gt; &#xA;&lt;p&gt;Issues describing example schemas and desired output are welcome and helpful.&lt;/p&gt; &#xA;&lt;h3&gt;AdditionalProperties&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;additionalProperties&lt;/code&gt; constraint lets a schema define what &lt;em&gt;non-specified&lt;/em&gt; properties are permitted. A value of &lt;code&gt;false&lt;/code&gt; means that no other properties are permitted (this is expressed in Rust with the &lt;code&gt;#[serde(deny_unknown_fields)]&lt;/code&gt; annotation). The absence of &lt;code&gt;additionalProperties&lt;/code&gt; or a value of &lt;code&gt;true&lt;/code&gt; are equivalent constructions that mean that any other property is permitted.&lt;/p&gt; &#xA;&lt;p&gt;Without other properties, an object that permits additional properties will be represented as a map type. In conjunction with other properties, typify employs a heuristic interpretation. Absent or with a value of &lt;code&gt;true&lt;/code&gt;, additional properties are ignored. If, however, &lt;code&gt;additionalProperties&lt;/code&gt; has another value (i.e. a schema), the generated type will have a map field annotated with &lt;code&gt;#[serde(flatten)]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that this is true of &lt;strong&gt;any&lt;/strong&gt; schema value for &lt;code&gt;additionalProperties&lt;/code&gt; that is not a boolean. This includes values that would be equivalent with regard to validation such as the schema &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{ &#34;not&#34;: false }&lt;/code&gt; or any of the other infinity of equivalent schemas. One can therefore construct a &lt;code&gt;struct&lt;/code&gt; with named properties &lt;strong&gt;and&lt;/strong&gt; a flattened map of additional properties by using a value for &lt;code&gt;additionalProperties&lt;/code&gt; that is equivalent to &lt;code&gt;true&lt;/code&gt; or absent with regard to validation, by using some e.g. &lt;code&gt;{}&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Rust -&amp;gt; Schema -&amp;gt; Rust&lt;/h2&gt; &#xA;&lt;p&gt;Schemas derived from Rust types may include an extension that provides information about the original type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;type&#34;: &#34;object&#34;,&#xA;  &#34;properties&#34;: { .. },&#xA;  &#34;x-rust-type&#34;: {&#xA;    &#34;crate&#34;: &#34;crate-o-types&#34;,&#xA;    &#34;version&#34;: &#34;1.0.0&#34;,&#xA;    &#34;path&#34;: &#34;crate_o_types::some_mod::SomeType&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The extension includes the name of the crate, a Cargo-style version requirements spec, and the full path (that must start with ident-converted name of the crate).&lt;/p&gt; &#xA;&lt;p&gt;Each of the modes of using typify allow for a list of crates and versions to be specified. In this case, if the user specifies &#34;crate-o-types@1.0.1&#34; for example, then typify would use its &lt;code&gt;SomeType&lt;/code&gt; type rather than generating one according to the schema.&lt;/p&gt; &#xA;&lt;h3&gt;Using types from other crates&lt;/h3&gt; &#xA;&lt;p&gt;Each mode of using typify has a method for controlling the use of types with &lt;code&gt;x-rust-type&lt;/code&gt; annotations. The default is to ignore them. The recommended method is to specify each crate and version you intend to use. You can additionally supply the &lt;code&gt;*&lt;/code&gt; version for crates (which may result in incompatibilities) or you can define a policy to allow the use of all &#34;unknown&#34; crates (which may require that addition of dependencies for those crates).&lt;/p&gt; &#xA;&lt;p&gt;For the CLI:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo typify --unknown-crates allow --crate oxnet@1.0.0 ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the builder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut settings = typify::TypeSpaceSettings::default();&#xA;settings.with_unknown_crates(typify::UnknownPolicy::Allow)&#xA;    .with_crate(&#34;oxnet&#34;, typify::CrateVers::Version(&#34;1.0.0&#34;.parse().unwrap()));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;typify::import_types!(&#xA;  schema = &#34;schema.json&#34;,&#xA;  unknown_crates = Allow,&#xA;  crates = {&#xA;    &#34;oxnet&#34; = &#34;1.0.0&#34;&#xA;  }&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Version requirements&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;version&lt;/code&gt; field within the &lt;code&gt;x-rust-type&lt;/code&gt; extension follows the Cargo version requirements specification. If the extension specifies &lt;code&gt;0.1.0&lt;/code&gt; of a crate and the user states that they&#39;re using &lt;code&gt;0.1.1&lt;/code&gt;, then the type is used; conversely, if the extension specifies &lt;code&gt;0.2.2&lt;/code&gt; and the user is only using &lt;code&gt;0.2.0&lt;/code&gt; the type is not used.&lt;/p&gt; &#xA;&lt;p&gt;Crate authors may choose to adhere to greater stability than otherwise provided by semver. If the extension version is &lt;code&gt;&amp;gt;=0.1.0, &amp;lt;1.0.0&lt;/code&gt; then the crate author is committing to the schema compatibility of the given type on all releases until &lt;code&gt;1.0.0&lt;/code&gt;. It is important that crate authors populate the &lt;code&gt;version&lt;/code&gt; field in a way that upholds type availability. For example, while &lt;code&gt;*&lt;/code&gt; is a valid value, it is only conceivably valid if the type in question were available in the first ever version of a crate published and never changed incompatibly in any subsequent version.&lt;/p&gt; &#xA;&lt;h3&gt;Type parameters&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;x-rust-type&lt;/code&gt; extension may also specify type parameters:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;$defs&#34;: {&#xA;    &#34;Sprocket&#34;: {&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: { .. },&#xA;      &#34;x-rust-type&#34;: {&#xA;        &#34;crate&#34;: &#34;util&#34;,&#xA;        &#34;version&#34;: &#34;0.1.0&#34;,&#xA;        &#34;path&#34;: &#34;util::Sprocket&#34;,&#xA;        &#34;parameters&#34;: [&#xA;          {&#xA;            &#34;$ref&#34;: &#34;#/$defs/Gizmo&#34;&#xA;          }&#xA;        ]&#xA;      }&#xA;    },&#xA;    &#34;Gizmo&#34;: {&#xA;      &#34;type&#34;: &#34;object&#34;,&#xA;      &#34;properties&#34;: { .. },&#xA;      &#34;x-rust-type&#34;: {&#xA;        &#34;crate&#34;: &#34;util&#34;,&#xA;        &#34;version&#34;: &#34;0.1.0&#34;,&#xA;        &#34;path&#34;: &#34;util::Gizmo&#34;&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the &lt;code&gt;util@0.1.0&lt;/code&gt; crate specified during type generation, schemas referencing &lt;code&gt;#/$defs/Sprocket&lt;/code&gt; would use the (non-generated) type &lt;code&gt;util::Sprocket&amp;lt;util::Gizmo&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;parameters&lt;/code&gt; field is an array of schemas. They may be inline schemas or referenced schemas.&lt;/p&gt; &#xA;&lt;h3&gt;Including &lt;code&gt;x-rust-type&lt;/code&gt; in your library&lt;/h3&gt; &#xA;&lt;p&gt;The schema for the expected value is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;description&#34;: &#34;schema for the x-rust-type extension&#34;,&#xA;  &#34;type&#34;: &#34;object&#34;,&#xA;  &#34;properties&#34;: {&#xA;    &#34;crate&#34;: {&#xA;      &#34;type&#34;: &#34;string&#34;,&#xA;      &#34;pattern&#34;: &#34;^[a-zA-Z0-9_-]+$&#34;&#xA;    },&#xA;    &#34;version&#34;: {&#xA;      &#34;description&#34;: &#34;semver requirements per a Cargo.toml dependencies entry&#34;,&#xA;      &#34;type&#34;: &#34;string&#34;&#xA;    },&#xA;    &#34;path&#34;: {&#xA;      &#34;type&#34;: &#34;string&#34;,&#xA;      &#34;pattern&#34;: &#34;^[a-zA-Z0-9_]+(::[a-zA-Z0-9+]+)*$&#34;&#xA;    },&#xA;    &#34;parameters&#34;: {&#xA;      &#34;type&#34;: &#34;array&#34;,&#xA;      &#34;items&#34;: {&#xA;        &#34;$ref&#34;: &#34;#/definitions/Schema&#34;&#xA;      }&#xA;    }&#xA;  },&#xA;  &#34;required&#34;: [&#xA;    &#34;crate&#34;,&#xA;    &#34;path&#34;,&#xA;    &#34;version&#34;&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;version&lt;/code&gt; field expresses the stability of your type. For example, if &lt;code&gt;0.1.0&lt;/code&gt; indicates that &lt;code&gt;0.1.1&lt;/code&gt; users would be fine whereas &lt;code&gt;0.2.0&lt;/code&gt; users would not use the type (instead generating it). You can communicate a future commitment beyond what semver implies by using the &lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#version-requirement-syntax&#34;&gt;Cargo version requirement syntax&lt;/a&gt;. For example &lt;code&gt;&amp;gt;=0.1.0, &amp;lt;1.0.0&lt;/code&gt; says that the type will remain structurally compatible from version &lt;code&gt;0.1.0&lt;/code&gt; until &lt;code&gt;1.0.0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Formatting&lt;/h2&gt; &#xA;&lt;p&gt;You can format generated code using crates such as &lt;a href=&#34;https://docs.rs/rustfmt-wrapper&#34;&gt;rustfmt-wrapper&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/prettyplease&#34;&gt;prettyplease&lt;/a&gt;. This can be particularly useful when checking in code or emitting code from a &lt;code&gt;build.rs&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The examples below show different ways to convert a &lt;code&gt;TypeSpace&lt;/code&gt; to a string (&lt;code&gt;typespace&lt;/code&gt; is a &lt;code&gt;typify::TypeSpace&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;rustfmt&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Best for generation of code that might be checked in alongside hand-written code such as in the case of an &lt;code&gt;xtask&lt;/code&gt; or stand-alone code generator (such as &lt;code&gt;cargo-typify&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;rustfmt_wrapper::rustfmt(typespace.to_stream().to_string())?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;prettyplease&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Best for &lt;code&gt;build.rs&lt;/code&gt; scripts where transitive dependencies might not have &lt;code&gt;rustfmt&lt;/code&gt; installed so should be self-contained.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;prettyplease::unparse(&amp;amp;syn::parse2::&amp;lt;syn::File&amp;gt;(typespace.to_stream())?)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;No formatting&lt;/h3&gt; &#xA;&lt;p&gt;If no human will ever see the code (and this is almost never the case).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;typespace.to_stream().to_string()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;WIP&lt;/h2&gt; &#xA;&lt;p&gt;Typify is a work in progress. Changes that affect output will be indicated with a breaking change to the crate version number.&lt;/p&gt; &#xA;&lt;p&gt;In general, if you have a JSON Schema that causes Typify to fail or if the generated type isn&#39;t what you expect, please file an issue.&lt;/p&gt; &#xA;&lt;p&gt;There are some known areas where we&#39;d like to improve:&lt;/p&gt; &#xA;&lt;h3&gt;Complex JSON Schema types&lt;/h3&gt; &#xA;&lt;p&gt;JSON schema can express a wide variety of types. Some of them are easy to model in Rust; others aren&#39;t. There&#39;s a lot of work to be done to handle esoteric types. Examples from users are very helpful in this regard.&lt;/p&gt; &#xA;&lt;h3&gt;Bounded numbers&lt;/h3&gt; &#xA;&lt;p&gt;Bounded numbers aren&#39;t very well handled. Consider, for example, the schema:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;type&#34;: &#34;integer&#34;,&#xA;  &#34;minimum&#34;: 1,&#xA;  &#34;maximum&#34;: 6&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The resulting types won&#39;t enforce those value constraints.&lt;/p&gt; &#xA;&lt;h3&gt;Configurable dependencies&lt;/h3&gt; &#xA;&lt;p&gt;A string schema with &lt;code&gt;format&lt;/code&gt; set to &lt;code&gt;uuid&lt;/code&gt; will result in the &lt;code&gt;uuid::Uuid&lt;/code&gt; type; similarly, a &lt;code&gt;format&lt;/code&gt; of &lt;code&gt;date&lt;/code&gt; translates to &lt;code&gt;chrono::naive::NaiveDate&lt;/code&gt;. For users that don&#39;t want dependencies on &lt;code&gt;uuid&lt;/code&gt; or &lt;code&gt;chrono&lt;/code&gt; it would be useful for Typify to optionally represent those as &lt;code&gt;String&lt;/code&gt; (or as some other, consumer-specified type).&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kunai-project/kunai</title>
    <updated>2025-02-22T01:38:05Z</updated>
    <id>tag:github.com,2025-02-22:/kunai-project/kunai</id>
    <link href="https://github.com/kunai-project/kunai" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Threat-hunting tool for Linux&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt;&#xA; &lt;img src=&#34;https://raw.githubusercontent.com/kunai-project/kunai/main/assets/logo.svg?sanitize=true&#34; width=&#34;500&#34;&gt;&#xA;&lt;/div&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/0xrawsec/kunai/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/0xrawsec/kunai/ci.yml?style=for-the-badge&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/0xrawsec/kunai/total.svg?style=for-the-badge&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.com/invite/AUMaBvHvNU&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Discord-chat-5865F2?style=for-the-badge&amp;amp;logo=discord&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/0xrawsec/kunai/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/0xrawsec/kunai?style=for-the-badge&amp;amp;label=stable&amp;amp;color=green&#34; alt=&#34;GitHub release (with filter)&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://why.kunai.rocks&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docs-stable-blue.svg?style=for-the-badge&amp;amp;logo=docsdotrs&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!--&#xA;[![GitHub Latest Release](https://img.shields.io/github/v/release/kunai-project/kunai?include_prereleases&amp;style=for-the-badge&amp;label=unstable&#xA;)](https://github.com/kunai-project/kunai/releases)&#xA;[![Documentation](https://img.shields.io/badge/docs-unstable-orange.svg?style=for-the-badge&amp;logo=docsdotrs)](https://why.kunai.rocks/docs/next/quickstart)&#xA;--&gt; &#xA;&lt;h1&gt;Leitmotiv&lt;/h1&gt; &#xA;&lt;p&gt;Kunai is a powerful tool designed to bring actionable insights for tasks such as &lt;strong&gt;security monitoring&lt;/strong&gt; and &lt;strong&gt;threat hunting&lt;/strong&gt; on &lt;strong&gt;Linux&lt;/strong&gt; systems. Think of it as the Linux counterpart to Sysmon on Windows, tailored for comprehensive and precise event monitoring.&lt;/p&gt; &#xA;&lt;h2&gt;Why Kunai Stands Out&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Chronologically Ordered Events:&lt;/strong&gt; Events are processed and delivered in the exact order they occur.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;On-Host Correlation:&lt;/strong&gt; Built-in capabilities for event enrichment and correlation to provide deeper context.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Container-Aware:&lt;/strong&gt; Fully compatible with Linux namespaces and container technologies, enabling complete tracing of container activities.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How It Works&lt;/h2&gt; &#xA;&lt;p&gt;Kunai leverages eBPF (Extended Berkeley Packet Filter) technology, with kernel-level probes that capture critical events. These probes send data to a userland program, responsible for tasks like reordering, enriching, and correlating the collected events.&lt;/p&gt; &#xA;&lt;p&gt;On the implementation side, Kunai is predominantly written in Rust, using the robust &lt;a href=&#34;https://github.com/aya-rs/aya&#34;&gt;Aya library&lt;/a&gt;. This design ensures a self-contained standalone binary, embedding both the eBPF probes and the userland processing logic for ease of deployment.&lt;/p&gt; &#xA;&lt;h1&gt;FAQ&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Is it compatible with my OS/Kernel ?&lt;/strong&gt; : Check out &lt;a href=&#34;https://why.kunai.rocks/docs/compatibility&#34;&gt;the compatibility page&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;What kind of events can I&amp;nbsp;get ?&lt;/strong&gt; : Please take a read to &lt;a href=&#34;https://why.kunai.rocks/docs/events/&#34;&gt;events documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Which version should I&amp;nbsp;use ?&lt;/strong&gt;: If it is just to test the tool, use the latest build as it is always the best in terms of features and bug fix. However keep in mind that events in &lt;strong&gt;non stable&lt;/strong&gt; releases &lt;strong&gt;are subject to change&lt;/strong&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;How to Build the Project?&lt;/h1&gt; &#xA;&lt;p&gt;Before proceeding, please note that a distribution-agnostic, pre-compiled version of Kunai is available on the &lt;a href=&#34;https://github.com/kunai-project/kunai/releases/latest&#34;&gt;release page&lt;/a&gt;. If you simply want to try Kunai, you likely donâ€™t need to build the project yourself.&lt;/p&gt; &#xA;&lt;h2&gt;With a Docker image&lt;/h2&gt; &#xA;&lt;p&gt;You can use a Docker image that includes everything needed to build the project easily: &lt;a href=&#34;https://github.com/kunai-project/kunai-build-docker/&#34;&gt;Kunai build docker image&lt;/a&gt;.&lt;br&gt; This one-size-fits-all solution should work on any Linux distribution.&lt;/p&gt; &#xA;&lt;h2&gt;Doing everything by hand&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;p&gt;Before being able to build everything, you need to install a couple of tools.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;to build many Rust projects (this one included), you need &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;to build kunai you need: &lt;code&gt;clang&lt;/code&gt;, &lt;code&gt;libbpf-dev&lt;/code&gt; and &lt;a href=&#34;https://github.com/aya-rs/bpf-linker&#34;&gt;&lt;code&gt;bpf-linker&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Example of commands to install requirements on Ubuntu/Debian:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt update&#xA;sudo apt install -y clang libbpf-dev&#xA;&#xA;# assuming you have rustup and cargo installed&#xA;cargo install bpf-linker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building Kunai&lt;/h3&gt; &#xA;&lt;p&gt;Once you have the &lt;strong&gt;requirements&lt;/strong&gt; installed, you are good to go. You can now build the project with &lt;strong&gt;xtask&lt;/strong&gt;, a cargo command (specific to this project) to make your life easier.&lt;/p&gt; &#xA;&lt;p&gt;Building debug version&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo xtask build&#xA;# find your executable in:&amp;nbsp;./target/x86_64-unknown-linux-musl/debug/kunai&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Building release version (harder, better, faster, stronger)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo xtask build --release&#xA;# find your executable in: ./target/x86_64-unknown-linux-musl/release/kunai&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cross-compiling&lt;/h3&gt; &#xA;&lt;h4&gt;aarch64&lt;/h4&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install the proper target using rustup &lt;code&gt;rustup install target aarch64-unknown-linux-gnu&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;You need to install appropriate compiler and linker to cross-compile&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# example on ubuntu&#xA;sudo apt install gcc-aarch64-linux-gnu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Cross-compile the project&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# compile the project for with release profile&#xA;CC=aarch64-linux-gnu-gcc  cargo xbuild --release --target aarch64-unknown-linux-gnu --linker aarch64-linux-gnu-gcc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;You should find your cross-compiled binary at &lt;code&gt;./target/aarch64-unknown-linux-gnu/release/kunai&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;strong&gt;NB:&lt;/strong&gt; specifying &lt;code&gt;--linker&lt;/code&gt; option is just a shortcut for setting appropriate RUSTFLAGS env variable when building userland application.&lt;/p&gt; &#xA;&lt;h1&gt;Memory Profiling&lt;/h1&gt; &#xA;&lt;p&gt;If one believes Kunai has an issue with memory, here is a way to profile it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# compile kunai with debug information for all packages&#xA;RUSTFLAGS=&#34;-g&#34; cargo xbuild&#xA;&#xA;# use heaptrack&#xA;sudo heaptrack kunai&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Related Work&lt;/h1&gt; &#xA;&lt;p&gt;Sysmon For Linux:&amp;nbsp;&lt;a href=&#34;https://github.com/Sysinternals/SysmonForLinux&#34;&gt;https://github.com/Sysinternals/SysmonForLinux&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgements&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Thanks to all the people behind &lt;a href=&#34;https://github.com/aya-rs&#34;&gt;Aya&lt;/a&gt;, this stuff is just awesome&lt;/li&gt; &#xA; &lt;li&gt;Special thanks to &lt;a href=&#34;https://github.com/alessandrod&#34;&gt;@alessandrod&lt;/a&gt; and &lt;a href=&#34;https://github.com/vadorovsky&#34;&gt;@vadorovsky&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Thanks to all the usual guys always supporting my crazy ideas&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Funding&lt;/h1&gt; &#xA;&lt;p&gt;The NGSOTI project is dedicated to training the next generation of Security Operation Center (SOC) operators, focusing on the human aspect of cybersecurity. It underscores the significance of providing SOC operators with the necessary skills and open-source tools to address challenges such as detection engineering, incident response, and threat intelligence analysis. Involving key partners such as CIRCL, Restena, Tenzir, and the University of Luxembourg, the project aims to establish a real operational infrastructure for practical training. This initiative integrates academic curricula with industry insights, offering hands-on experience in cyber ranges.&lt;/p&gt; &#xA;&lt;p&gt;NGSOTI is co-funded under Digital Europe Programme (DEP) via the ECCC (European cybersecurity competence network and competence centre).&lt;/p&gt;</summary>
  </entry>
</feed>