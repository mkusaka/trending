<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-12T01:38:06Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>singaraiona/hyperbridge</title>
    <updated>2024-02-12T01:38:06Z</updated>
    <id>tag:github.com,2024-02-12:/singaraiona/hyperbridge</id>
    <link href="https://github.com/singaraiona/hyperbridge" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast multi-producer, multi-consumer unbounded channel with async support.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hyperbridge&lt;/h1&gt; &#xA;&lt;p&gt;Fast multi-producer, multi-consumer unbounded channel with async support. Inspired by &lt;a href=&#34;https://github.com/crossbeam-rs/crossbeam&#34;&gt;crossbeam unbounded channel&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/hyperbridge&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/hyperbridge.svg?sanitize=true&#34; alt=&#34;Cargo&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/hyperbridge&#34;&gt;&lt;img src=&#34;https://docs.rs/hyperbridge/badge.svg?sanitize=true&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/zesterer/hyperbridge&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT%2FApache--2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;Hyperbridge::channel&lt;/code&gt;: mpsc&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use hyperbridge::channel;&#xA;use std::thread;&#xA;&#xA;let (sender, receiver) = hyperbridge::channel::new();&#xA;let mut counter = 0;&#xA;let threads = 10;&#xA;let values = 10000;&#xA;&#xA;let mut handles = vec![];&#xA;&#xA;for i in 0..threads {&#xA;    let ch = sender.clone();&#xA;    let jh = thread::spawn(move || {&#xA;        for _ in 0..values {&#xA;            ch.send(i).unwrap();&#xA;        }&#xA;    });&#xA;    handles.push(jh);&#xA;}&#xA;&#xA;let mut iters = threads * values;&#xA;&#xA;while iters &amp;gt; 0 {&#xA;    match receiver.try_recv() {&#xA;        Ok(Some(v)) =&amp;gt; {&#xA;            counter += v as usize;&#xA;            iters -= 1;&#xA;        }&#xA;        _ =&amp;gt; {}&#xA;    }&#xA;}&#xA;&#xA;let total = (0..threads).map(|i| i * values).sum();&#xA;&#xA;for jh in handles.drain(..) {&#xA;    let _ = jh.join();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;Hyperbridge::channel&lt;/code&gt;: mpmc&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use hyperbridge::channel;&#xA;use std::thread;&#xA;&#xA;const VALUES: usize = 10000;&#xA;const THREADS: usize = 16;&#xA;&#xA;let (sender, receiver) = channel::new();&#xA;let counter = Arc::new(AtomicUsize::new(0));&#xA;&#xA;let mut handles = vec![];&#xA;&#xA;for i in 0..THREADS {&#xA;    let ch = sender.clone();&#xA;    let jh = thread::spawn(move || {&#xA;        for _ in 0..VALUES {&#xA;            ch.send(i).unwrap();&#xA;        }&#xA;    });&#xA;    handles.push(jh);&#xA;}&#xA;&#xA;for _ in 0..THREADS {&#xA;    let ch = receiver.clone();&#xA;    let local_counter = counter.clone();&#xA;    let jh = thread::spawn(move || {&#xA;        let mut iters = VALUES;&#xA;        while iters &amp;gt; 0 {&#xA;            if let Ok(Some(v)) = ch.try_recv() {&#xA;                local_counter.fetch_add(v as usize, Relaxed);&#xA;                iters -= 1;&#xA;            }&#xA;        }&#xA;    });&#xA;    handles.push(jh);&#xA;}&#xA;&#xA;for jh in handles.drain(..) {&#xA;    let _ = jh.join();&#xA;}&#xA;&#xA;let total = (0..THREADS).map(|i| i * VALUES).sum();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Dependencies&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# Cargo.toml&#xA;[dependencies]&#xA;hyperbridge = &#34;0.1.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Feature with-futures&lt;/h2&gt; &#xA;&lt;p&gt;Turns on support for futures Sink, Stream:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# Cargo.toml&#xA;[dependencies]&#xA;hyperbridge = { version = &#34;0.1.0&#34;, features = [&#34;with-futures&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT/Apache-2.0&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>shadow3aaa/fas-rs</title>
    <updated>2024-02-12T01:38:06Z</updated>
    <id>tag:github.com,2024-02-12:/shadow3aaa/fas-rs</id>
    <link href="https://github.com/shadow3aaa/fas-rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;fas-rs是运行在用户态的FAS(Frame Aware Scheduling)实现, 对比核心思路一致但是在内核态的MI FEAS有着近乎在任何设备通用的兼容性和灵活性方面的优势&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;strong&gt;fas-rs&lt;/strong&gt;&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/shadow3aaa/fas-rs/master/README_EN.md&#34;&gt;English&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shadow3aaa/fas-rs&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/shadow3aaa/fas-rs&#34; alt=&#34;Stars&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shadow3aaa/fas-rs/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/shadow3aaa/fas-rs/ci.yml&#34; alt=&#34;CI Build&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shadow3aaa/fas-rs/releases/latest&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/shadow3aaa/fas-rs&#34; alt=&#34;Release&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/shadow3aaa/fas-rs/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/shadow3aaa/fas-rs/total&#34; alt=&#34;Download Total&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;假如肉眼看到的画面能直接反映在调度上, 也就是说以把调度器放在观看者的角度来决定性能, 是否就能实现完美的性能控制和最大化体验? &lt;code&gt;FAS (Frame Aware Scheduling)&lt;/code&gt;就是这种调度概念, 通过监视画面渲染来尽量控制性能以在保证渲染时间的同时实现最小化开销&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;strong&gt;什么是&lt;code&gt;fas-rs&lt;/code&gt;?&lt;/strong&gt;&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;fas-rs&lt;/code&gt;是运行在用户态的&lt;code&gt;FAS(Frame Aware Scheduling)&lt;/code&gt;实现, 对比核心思路一致但是在内核态的&lt;code&gt;MI FEAS&lt;/code&gt;有着近乎在任何设备通用的兼容性和灵活性方面的优势&lt;/li&gt; &#xA;   &lt;li&gt;对比其它用户态&lt;code&gt;FAS&lt;/code&gt;实现(如&lt;code&gt;scene fas&lt;/code&gt;), &lt;code&gt;fas-rs&lt;/code&gt;采用了侵入性更强的inline hook方法获取渲染时间, 这带来了更准确的数据和更小的开销, 然而这本质上是注入, 可能被反作弊系统误判断, 虽然我还没遇到过&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;strong&gt;插件系统&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;为了最大化用户态的灵活性, &lt;code&gt;fas-rs&lt;/code&gt;有自己的一套插件系统, 开发说明详见&lt;a href=&#34;https://github.com/shadow3aaa/fas-rs-extension-module-template&#34;&gt;插件的模板仓库&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;strong&gt;自定义(配置)&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;strong&gt;配置路径 : &lt;code&gt;/sdcard/Android/fas-rs/games.toml&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;strong&gt;参数(&lt;code&gt;config&lt;/code&gt;)说明 :&lt;/strong&gt;&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;keep_std&lt;/strong&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;类型 : &lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;true&lt;/code&gt; : 永远在配置合并时保持标准配置的profile, 保留本地配置的应用列表, 其它地方和false相同 *&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;false&lt;/code&gt; : 见&lt;a href=&#34;https://raw.githubusercontent.com/shadow3aaa/fas-rs/master/#%E9%85%8D%E7%BD%AE%E5%90%88%E5%B9%B6&#34;&gt;配置合并的默认行为&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;code&gt;*&lt;/code&gt; : 默认配置&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;strong&gt;游戏列表(&lt;code&gt;game_list&lt;/code&gt;)说明 :&lt;/strong&gt;&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;code&gt;&#34;package&#34;&lt;/code&gt; = &lt;code&gt;target_fps&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;code&gt;package&lt;/code&gt; : 字符串, 应用包名&lt;/li&gt; &#xA;     &lt;li&gt;&lt;code&gt;target_fps&lt;/code&gt; : 一个数组(如&lt;code&gt;[30, 60, 120, 144]&lt;/code&gt;)或者单个整数, 表示游戏会渲染到的目标帧率, &lt;code&gt;fas-rs&lt;/code&gt;会在运行时动态匹配&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;strong&gt;&lt;code&gt;powersave&lt;/code&gt; / &lt;code&gt;balance&lt;/code&gt; / &lt;code&gt;performance&lt;/code&gt; / &lt;code&gt;fast&lt;/code&gt; 说明 :&lt;/strong&gt;&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;mode :&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;目前&lt;code&gt;fas-rs&lt;/code&gt;还没有官方的切换模式的管理器, 而是接入了&lt;a href=&#34;https://www.coolapk.com/apk/com.omarea.vtools&#34;&gt;&lt;code&gt;scene&lt;/code&gt;&lt;/a&gt;的配置接口, 如果你不用scene则默认使用&lt;code&gt;balance&lt;/code&gt;的配置&lt;/li&gt; &#xA;     &lt;li&gt;如果你有在linux上编程的一些了解, 向&lt;code&gt;/dev/fas_rs/mode&lt;/code&gt;节点写入4模式中的任意一个即可切换到对应模式, 同时读取它也可以知道现在&lt;code&gt;fas-rs&lt;/code&gt;所处的模式&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;参数说明 :&lt;/strong&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;fas_boost(bool): &lt;code&gt;fas-rs&lt;/code&gt;的目的是限制功耗还是减少游戏掉帧, true时为减少掉帧模式&lt;/li&gt; &#xA;     &lt;li&gt;scale(f64): &lt;code&gt;fas-rs&lt;/code&gt;可以容忍的掉帧数&lt;/li&gt; &#xA;     &lt;li&gt;jank_scale(f64): &lt;code&gt;fas-rs&lt;/code&gt;判定小卡顿的掉帧数&lt;/li&gt; &#xA;     &lt;li&gt;big_jank_scale(f64): &lt;code&gt;fas-rs&lt;/code&gt;判定大卡顿的掉帧数&lt;/li&gt; &#xA;     &lt;li&gt;use_performance_governor(bool): &lt;code&gt;fas-rs&lt;/code&gt;是否在工作时使用performance内核cpufreq策略(fas_boost开启时此配置无效)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;strong&gt;&lt;code&gt;games.toml&lt;/code&gt;配置标准例 :&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;[config]&#xA;keep_std = true&#xA;&#xA;[game_list]&#xA;&#34;com.hypergryph.arknights&#34; = [30, 60]&#xA;&#34;com.miHoYo.Yuanshen&#34; = [30, 60]&#xA;&#34;com.miHoYo.enterprise.NGHSoD&#34; = [30, 60, 90]&#xA;&#34;com.miHoYo.hkrpg&#34; = [30, 60]&#xA;&#34;com.mojang.minecraftpe&#34; = [60, 120]&#xA;&#34;com.netease.party&#34; = [30, 60]&#xA;&#34;com.shangyoo.neon&#34; = 60&#xA;&#34;com.tencent.tmgp.pubgmhd&#34; = [60, 90, 120]&#xA;&#34;com.tencent.tmgp.sgame&#34; = [30, 60, 90, 120]&#xA;&#xA;[powersave]&#xA;fas_boost = false&#xA;scale = 0.5&#xA;jank_scale = 3.0&#xA;big_jank_scale = 5.0&#xA;use_performance_governor = false&#xA;&#xA;[balance]&#xA;fas_boost = false&#xA;scale = 0.25&#xA;jank_scale= 3.0&#xA;big_jank_scale = 5.0&#xA;use_performance_governor = true&#xA;&#xA;[performance]&#xA;fas_boost = false&#xA;scale = 0.2&#xA;jank_scale= 1.5&#xA;big_jank_scale = 3.0&#xA;use_performance_governor = true&#xA;&#xA;[fast]&#xA;fas_boost = true&#xA;scale = 0.1&#xA;jank_scale= 1.5&#xA;big_jank_scale = 3.0&#xA;use_performance_governor = false&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;&lt;strong&gt;配置合并&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h3&gt;&lt;code&gt;fas-rs&lt;/code&gt;内置配置合并系统, 来解决未来的配置功能变动问题。它的行为如下&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;删除本地配置中, 标准配置不存在的配置&lt;/li&gt; &#xA;   &lt;li&gt;插入本地配置缺少, 标准配置存在的配置&lt;/li&gt; &#xA;   &lt;li&gt;保留标准配置和本地配置都存在的配置&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;注意&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;使用自动序列化和反序列化实现, 无法保存注释等非序列化必须信息&lt;/li&gt; &#xA;   &lt;li&gt;安装时的自动合并配置不会马上应用，不然可能会影响现版本运行，而是会在下一次重启时用合并后的新配置替换掉本地的&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;h3&gt;手动合并&lt;/h3&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;模块每次安装都会自动调用一次&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;手动例&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fas-rs merge /path/to/std/profile&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;&lt;strong&gt;编译&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Termux&#xA;apt install rust zip ndk* clang binutils-is-llvm shfmt git-lfs&#xA;&#xA;# Ubuntu(NDK is required)&#xA;apt install gcc-multilib git-lfs clang&#xA;# Rust&#xA;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh&#xA;rustup target add aarch64-linux-android armv7-linux-androideabi x86_64-linux-android i686-linux-android&#xA;# Cargo-ndk&#xA;cargo install cargo-ndk&#xA;&#xA;# Clone&#xA;git clone https://github.com/shadow3aaa/fas-rs&#xA;cd fas-rs&#xA;&#xA;# Compile&#xA;chmod +x ./make.sh&#xA;./make.sh build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;h2&gt;&lt;strong&gt;💩&lt;/strong&gt;&lt;/h2&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I&#39;m here to introduce you the greatest thief @tryigitx !&lt;br&gt; So, what did he do?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;He kept stealing fas-rs module from me without any permission, and pretended to be co-developed with me.&lt;br&gt; In fact, he hasn&#39;t developed any kind of project, just because he is not able to. From his homepage (&lt;a href=&#34;https://linktr.ee/tryigitx&#34;&gt;https://linktr.ee/tryigitx&lt;/a&gt;), we can see he is an eXpErT! lmfao🤣🤣&lt;br&gt; I just can&#39;t imagine how can a real expert do these things. If @tryigitx is a real expert, pLeAsE fOrGiVe Me😭😭&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt; &#xA;  &lt;ol start=&#34;2&#34;&gt; &#xA;   &lt;li&gt;He also stole other modules, like &#34;Play Integrity Fix&#34;.&lt;br&gt; He copied it and changed the author to his own, but that&#39;s not all.&lt;br&gt; Maybe it&#39;s some kind of self-deception, he also changed the name to &#34;China Play Integrity Fix&#34;.&lt;br&gt; He seemed to want to express that this is for China Version ROMs, but everyone can see what he really wanted to do. Now that you&#39;ve all seen these, make your own judgment based on your own values.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>