<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-05-28T01:48:22Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>IgnisDa/ryot</title>
    <updated>2023-05-28T01:48:22Z</updated>
    <id>tag:github.com,2023-05-28:/IgnisDa/ryot</id>
    <link href="https://github.com/IgnisDa/ryot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Roll your own tracker!&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/apps/frontend/public/ryot-logo.png&#34; alt=&#34;Ryot Logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt; A self hosted platform for tracking various facets of your life - media, fitness etc. &lt;/h2&gt; &#xA;&lt;p&gt;Ryot (&lt;strong&gt;R&lt;/strong&gt;oll &lt;strong&gt;Y&lt;/strong&gt;our &lt;strong&gt;O&lt;/strong&gt;wn &lt;strong&gt;T&lt;/strong&gt;racker), pronounced &#34;riot&#34;, aims to be the only self hosted tracker you will ever need!&lt;/p&gt; &#xA;&lt;h2&gt;üíª Demo&lt;/h2&gt; &#xA;&lt;p&gt;You can use the demo instance hosted on &lt;a href=&#34;https://ryot.fly.dev&#34;&gt;Fly.io&lt;/a&gt;. Login and register with the username &lt;code&gt;demo&lt;/code&gt; and password &lt;code&gt;demo-password&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The data in this instance can be deleted randomly.&lt;/p&gt; &#xA;&lt;h2&gt;üìù ELI5&lt;/h2&gt; &#xA;&lt;p&gt;Imagine you have a special notebook where you can write down all the media you have consumed, like books you&#39;ve read, shows you have watched, video games you have played or workouts you have done. Now, imagine that instead of a physical notebook, you have a special tool on your computer or phone that lets you keep track of all these digitally.&lt;/p&gt; &#xA;&lt;h2&gt;üß™ Why?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Existing solutions do not have very good UI.&lt;/li&gt; &#xA; &lt;li&gt;Pretty graphs and summaries make everyone happy. Ryot aims to have a lot of them.&lt;/li&gt; &#xA; &lt;li&gt;There is a lack of a good selfhosted fitness and health tracking solution.&lt;/li&gt; &#xA; &lt;li&gt;Ryot consumes very little memory (around 8MB idle eyeballing &lt;code&gt;docker stats&lt;/code&gt;), something that is significantly useful in RAM constrained environments.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üöÄ Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;‚úÖ &lt;a href=&#34;https://github.com/IgnisDa/ryot/discussions/4&#34;&gt;Supports&lt;/a&gt; tracking media and fitness.&lt;/li&gt; &#xA; &lt;li&gt;‚úÖ Import data &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Goodreads&lt;/li&gt; &#xA;   &lt;li&gt;MediaTracker&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;‚úÖ Self-hosted&lt;/li&gt; &#xA; &lt;li&gt;‚úÖ Documented GraphQL API&lt;/li&gt; &#xA; &lt;li&gt;‚úÖ Easy to understand UI&lt;/li&gt; &#xA; &lt;li&gt;‚úÖ Lightning fast (written in Rust BTW)&lt;/li&gt; &#xA; &lt;li&gt;‚úÖ Free and open-source&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìñ Guides&lt;/h2&gt; &#xA;&lt;p&gt;Some things might not be obvious on how to setup or get working. I have written a number of guides to make thing easier.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/docs/guides/deployment.md&#34;&gt;Deployment&lt;/a&gt;: Deploy Ryot to various platforms&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/docs/guides/importing.md&#34;&gt;Importing&lt;/a&gt;: Import data from various sources&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/docs/guides/video-games.md&#34;&gt;Video Games&lt;/a&gt;: Get video games tracking working&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;‚å®Ô∏è How to use?&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The first user you register is automatically set as admin of the instance.&lt;/p&gt; &#xA;&lt;h3&gt;üê≥ Option 1: Use Docker&lt;/h3&gt; &#xA;&lt;p&gt;To get a demo server running, use the docker image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run --pull always \&#xA;  --detach \&#xA;  --publish 8000:8000 \&#xA;  --volume ./ryot-data:/data \&#xA;  --volume ./config/ryot.example.json:/data/config/ryot.json \&#xA;  --name ryot \&#xA;  ghcr.io/ignisda/ryot:latest&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;üßë‚ÄçüíªOption 2: Compile and run from source&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://moonrepo.dev/&#34;&gt;moonrepo&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Build the frontend&#xA;$ moon run frontend:build&#xA;&#xA;# Run it&#xA;$ cargo run --bin ryot --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;üîß Configuration options&lt;/h2&gt; &#xA;&lt;p&gt;You can specify configuration options via files (loaded from &lt;code&gt;config/ryot.json&lt;/code&gt;, &lt;code&gt;config/ryot.toml&lt;/code&gt;, &lt;code&gt;config/ryot.yaml&lt;/code&gt;). or via environment variables.&lt;/p&gt; &#xA;&lt;p&gt;Environment config variables are split by the &lt;code&gt;__&lt;/code&gt; delimiter. For example, the key &lt;code&gt;audio_books.audible.url&lt;/code&gt; corresponds to the environment variable &lt;code&gt;AUDIO_BOOKS__AUDIBLE__URL&lt;/code&gt;. The only exception to the &lt;code&gt;__&lt;/code&gt; delimiter rule is the &lt;code&gt;DATABASE_URL&lt;/code&gt; environment variable which will be loaded directly.&lt;/p&gt; &#xA;&lt;p&gt;Ryot writes the final configuration loaded at runtime to &lt;code&gt;computed-config.ron&lt;/code&gt; for debugging purposes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: You can see the defaults in the &lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/apps/backend/src/config.rs&#34;&gt;config&lt;/a&gt; builder. You can see a minimal example configuration in &lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/config/ryot.example.json&#34;&gt;&lt;code&gt;ryot.example.json&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Key&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;audio_books.audible.url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url to make requests for getting metadata from Audible.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;books.openlibrary.url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url to make requests for getting metadata from Openlibrary.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;books.openlibrary.cover_image_url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url for getting images from Openlibrary.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;books.openlibrary.cover_image_size&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The image sizes to fetch from Openlibrary.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;database.url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The database connection string. Supports SQLite, MySQL and Postgres.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{movies,shows}.tmdb.url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url to make requests for getting metadata about shows/movies.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;{movies,shows}.tmdb.access_token&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The access token for the TMDB API.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;podcasts.listennotes.url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url to make requests for getting metadata about podcasts.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;podcasts.listennotes.api_token&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The access token for the Listennotes API.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;podcasts.listennotes.user_agent&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The user agent used for the Listennotes API.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;scheduler.database_url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url to the SQLite database where job related data needs to be stored.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;scheduler.user_cleanup_every&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Deploy a job every x minutes that performs user cleanup and summary calculation.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;video_games.twitch.client_id&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The client ID issues by Twitch. &lt;strong&gt;Required&lt;/strong&gt; to enable video games tracking. &lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/docs/guides/video-games.md&#34;&gt;More information&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;video_games.twitch.client_secret&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The client secret issued by Twitch.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;video_games.twitch.access_token_url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The endpoint that issues access keys for IGDB.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;video_games.igdb.url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url to make requests for getting metadata about video games.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;video_games.igdb.image_url&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The url for getting images from IGDB.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;video_games.igdb.image_size&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The image sizes to fetch from IGDB.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;web.cors_origins&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;An array of URLs for CORS.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;web.insecure_cookie&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;This will make auth cookies insecure and should be set to &lt;code&gt;true&lt;/code&gt; if you are running the server on &lt;code&gt;localhost&lt;/code&gt;. &lt;a href=&#34;https://github.com/IgnisDa/ryot/issues/23#&#34;&gt;More information&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;ü§ì Developer notes&lt;/h2&gt; &#xA;&lt;p&gt;In production, the frontend is a pre-rendered Nextjs app served statically by the Axum backend server.&lt;/p&gt; &#xA;&lt;p&gt;In development, both servers are started independently running on &lt;code&gt;:3000&lt;/code&gt; and &lt;code&gt;:8000&lt;/code&gt; respectively. To get them running, install &lt;a href=&#34;https://github.com/pvolok/mprocs&#34;&gt;mprocs&lt;/a&gt;, and run &lt;code&gt;mprocs&lt;/code&gt; in the project root. If you do not want to install &lt;code&gt;mprocs&lt;/code&gt;, take a look at &lt;a href=&#34;https://raw.githubusercontent.com/IgnisDa/ryot/main/mprocs.yaml&#34;&gt;&lt;code&gt;mproc.yaml&lt;/code&gt;&lt;/a&gt; to see what all commands are needed to get it working.&lt;/p&gt; &#xA;&lt;h2&gt;üôè Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;It is highly inspired by &lt;a href=&#34;https://github.com/bonukai/MediaTracker&#34;&gt;MediaTracker&lt;/a&gt;. Moreover thanks to all those people whose stuff I have used.&lt;/p&gt; &#xA;&lt;p&gt;The logo is taken from &lt;a href=&#34;https://www.flaticon.com/free-icon/mess_4789882?term=chaos&amp;amp;page=1&amp;amp;position=2&amp;amp;origin=tag&amp;amp;related_id=4789882&#34;&gt;Flaticon&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>alexpusch/rust-magic-function-params</title>
    <updated>2023-05-28T01:48:22Z</updated>
    <id>tag:github.com,2023-05-28:/alexpusch/rust-magic-function-params</id>
    <link href="https://github.com/alexpusch/rust-magic-function-params" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Example for Axum style magic function parameter passing&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rusts Axum style magic function params example&lt;/h1&gt; &#xA;&lt;p&gt;Learning Rust I met a rigid, statically typed language. Specifically it has no function overloading or optional function parameters.&lt;/p&gt; &#xA;&lt;p&gt;Coming across &lt;a href=&#34;https://github.com/tokio-rs/axum&#34;&gt;Axum&lt;/a&gt; I was amazed to see stuff like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let app = Router::new()&#xA;  .route(&#34;/users&#34;, get(get_users))&#xA;  .route(&#34;/products&#34;, get(get_product));&#xA;&#xA;async fn get_users(Query(params): Query&amp;lt;Params&amp;gt;) -&amp;gt; impl IntoResponse {&#xA;    let users = /* ... */&#xA;&#xA;    Json(users)&#xA;}&#xA;&#xA;async fn get_product(State(db): State&amp;lt;Db&amp;gt;, Json(payload): Json&amp;lt;Payload&amp;gt;) -&amp;gt; String {&#xA;  let product = /* ... */&#xA;&#xA;  product.to_string()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; method can receive a function pointer to various types of functions! What kind of black magic is this? ü§Ø&lt;/p&gt; &#xA;&lt;p&gt;I had to create a simplified version of this to figure this out.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn print_id(id: Id) {&#xA;    println!(&#34;id is {}&#34;, id.0);&#xA;}&#xA;&#xA;// Param(param) is just pattern matching&#xA;fn print_all(Param(param): Param, Id(id): Id) {&#xA;    println!(&#34;param is {param}, id is {id}&#34;);&#xA;}&#xA;&#xA;pub fn main() {&#xA;    let context = Context::new(&#34;magic&#34;.into(), 33);&#xA;&#xA;    trigger(context.clone(), print_id);&#xA;    trigger(context.clone(), print_all);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the example we have a &lt;code&gt;trigger&lt;/code&gt; method that receives a &lt;code&gt;Context&lt;/code&gt; object and a function pointer. The function pointer might receive 1 or 2 parameters of the &lt;code&gt;Id&lt;/code&gt; or &lt;code&gt;Param&lt;/code&gt; types. Magic?&lt;/p&gt; &#xA;&lt;h2&gt;Moving parts&lt;/h2&gt; &#xA;&lt;p&gt;Lets look at the moving parts to achieve this&lt;/p&gt; &#xA;&lt;h3&gt;The context&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Context {&#xA;    param: String,&#xA;    id: u32,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Context&lt;/code&gt; is the received state, &lt;code&gt;Request&lt;/code&gt; in Axums case. This is the source of the &#34;parts&#34; our functions want to receive. In this simplified example it contains two data fields&lt;/p&gt; &#xA;&lt;h3&gt;The FromContext trait&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait FromContext {&#xA;    fn from_context(context: &amp;amp;Context) -&amp;gt; Self;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first trick is the &lt;code&gt;FromContext&lt;/code&gt; trait. It will allow us to create &#34;Extractors&#34; that extract the necessary data from the context object. For example&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct Param(pub String);&#xA;&#xA;impl FromContext for Param {&#xA;    fn from_context(context: &amp;amp;Context) -&amp;gt; Self {&#xA;        Param(context.param.clone())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This trait will allow us to hold a &lt;code&gt;Context&lt;/code&gt; but call a function that expects &lt;code&gt;Param&lt;/code&gt;. More on this later&lt;/p&gt; &#xA;&lt;h3&gt;The Handler trait&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;trait Handler&amp;lt;T&amp;gt; {&#xA;    fn call(self, context: Context);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The second trick is the Handler trait. We will implement the trait for the &lt;a href=&#34;https://doc.rust-lang.org/reference/types/closure.html&#34;&gt;closure type&lt;/a&gt; &lt;code&gt;Fn(T)&lt;/code&gt;. Yeah we can implement traits for closure types. This implementation will allow us to have a &#34;middleware&#34; between the function call and its arguments. Here we will call the &lt;code&gt;FromContext::from_context&lt;/code&gt; method, converting the context to the expected function argument i.e &lt;code&gt;Param&lt;/code&gt; or &lt;code&gt;Id&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;F, T&amp;gt; Handler&amp;lt;T&amp;gt; for F&#xA;where&#xA;    F: Fn(T),&#xA;    T: FromContext,&#xA;{&#xA;    fn call(self, context: Context) {&#xA;        (self)(T::from_context(&amp;amp;context));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To Support multiple function parameters we&#39;ll go ahead and implement &lt;code&gt;Handler&lt;/code&gt; for closure types with 2, 3, 4 and so on parameters. An interesting point here is that this implementation is agnostic to the order of the parameters - it will support both &lt;code&gt;fn foo(p: Param, id: Id)&lt;/code&gt; and &lt;code&gt;fn foo(id: Id, p: Param)&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;impl&amp;lt;T1, T2, F&amp;gt; Handler&amp;lt;(T1, T2)&amp;gt; for F&#xA;where&#xA;    F: Fn(T1, T2),&#xA;    T1: FromContext,&#xA;    T2: FromContext,&#xA;{&#xA;    fn call(self, context: Context) {&#xA;        (self)(T1::from_context(&amp;amp;context), T2::from_context(&amp;amp;context));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Putting it all together&lt;/h3&gt; &#xA;&lt;p&gt;The implementation of the &lt;code&gt;trigger&lt;/code&gt; function is now straight forward&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub fn trigger&amp;lt;T, H&amp;gt;(context: Context, handler: H)&#xA;where&#xA;    H: Handler&amp;lt;T&amp;gt;,&#xA;{&#xA;    handler.call(context);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lets examine what happens for this call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;  let context = Context::new(&#34;magic&#34;.into(), 33);&#xA;&#xA;  trigger(context.clone(), print_id);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;print_id&lt;/code&gt; is of type &lt;code&gt;Fn(Id)&lt;/code&gt; which has an implementation for &lt;code&gt;Handler&amp;lt;Id&amp;gt;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;Handler::call&lt;/code&gt; method is called from which we &lt;code&gt;Id::from_context(context)&lt;/code&gt; which returns an instance of &lt;code&gt;Id&lt;/code&gt; struct.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;print_id&lt;/code&gt; is called with the parameter it expects.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Magic demystified.&lt;/p&gt;</summary>
  </entry>
</feed>