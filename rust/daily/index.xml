<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-14T01:42:20Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mufanc/z-loader</title>
    <updated>2024-04-14T01:42:20Z</updated>
    <id>tag:github.com,2024-04-14:/Mufanc/z-loader</id>
    <link href="https://github.com/Mufanc/z-loader" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Inject into processes specialized from Zygote&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>mathematic-inc/unfmt</title>
    <updated>2024-04-14T01:42:20Z</updated>
    <id>tag:github.com,2024-04-14:/mathematic-inc/unfmt</id>
    <link href="https://github.com/mathematic-inc/unfmt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A compile-time pattern matching library that reverses the interpolation process of `format!`.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;unfmt&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/unfmt&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/unfmt?style=flat-square&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mathematic-inc/unfmt&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/l/unfmt?style=flat-square&#34; alt=&#34;license&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/mathematic-inc/unfmt/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/mathematic-inc/unfmt/ci.yaml?label=ci&amp;amp;style=flat-square&#34; alt=&#34;ci&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/unfmt/latest/unfmt/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/unfmt?style=flat-square&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;unfmt&lt;/code&gt; is a compile-time pattern matching library that reverses the interpolation process of &lt;code&gt;format!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can think of it as an extremely lightweight regular expression engine without the runtime pattern-compilation cost.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo add -D unfmt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rs&#34;&gt;let value = &#34;My name is Rho.&#34;;&#xA;&#xA;// Unnamed captures are returned as tuples.&#xA;assert_eq!(&#xA;    unformat!(&#34;My {} is {}.&#34;, value),&#xA;    Some((&#34;name&#34;, &#34;Rho&#34;))&#xA;);&#xA;&#xA;// You can put indices as well; just make sure ALL captures use indices&#xA;// otherwise it&#39;s not well defined.&#xA;assert_eq!(&#xA;    unformat!(&#34;My {1} is {0}.&#34;, value),&#xA;    Some((&#34;Rho&#34;, &#34;name&#34;))&#xA;);&#xA;&#xA;// You can also name captures using variables, but make sure you check the&#xA;// return is not None.&#xA;let subject;&#xA;let value;&#xA;assert_eq!(&#xA;    unformat!(&#34;My {subject} is {value}.&#34;, value),&#xA;    Some(())&#xA;);&#xA;assert_eq!((subject, value), (Some(&#34;name&#34;), Some(&#34;Rho&#34;)));&#xA;&#xA;// If a type implements `FromStr`, you can use it as a type argument. This&#xA;// is written as `{:Type}`.&#xA;assert_eq!(&#xA;    unformat!(&#34;Listening on {:url::Url}&#34;, &#34;Listening on http://localhost:3000&#34;),&#xA;    Some((url::Url::from_str(&#34;http://localhost:3000&#34;).unwrap(),))&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In general, captures are written as &lt;code&gt;{&amp;lt;index-or-variable&amp;gt;:&amp;lt;type&amp;gt;}&lt;/code&gt;. Multiple captures in a row (i.e. &lt;code&gt;{}{}&lt;/code&gt;) are not supported as they aren&#39;t well-defined.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;There is no backtracking.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>