<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-29T01:36:34Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nkaz001/hftbacktest</title>
    <updated>2024-03-29T01:36:34Z</updated>
    <id>tag:github.com,2024-03-29:/nkaz001/hftbacktest</id>
    <link href="https://github.com/nkaz001/hftbacktest" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A high-frequency trading and market-making backtesting tool in Python and Rust, which accounts for limit orders, queue positions, and latencies, utilizing full tick data for trades and order books.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;=========== HftBacktest&lt;/h1&gt; &#xA;&lt;p&gt;|codacy| |codeql| |pypi| |downloads| |license| |docs| |github|&lt;/p&gt; &#xA;&lt;h1&gt;High-Frequency Trading Backtesting Tool in Python&lt;/h1&gt; &#xA;&lt;p&gt;This Python framework is designed for developing high-frequency trading and market-making strategies. It focuses on accounting for both feed and order latencies, as well as the order queue position for order fill simulation. The framework aims to provide more accurate market replay-based backtesting, based on full order book and trade tick feed data.&lt;/p&gt; &#xA;&lt;h1&gt;Key Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Working in &lt;code&gt;Numba &amp;lt;https://numba.pydata.org/&amp;gt;&lt;/code&gt;_ JIT function.&lt;/li&gt; &#xA; &lt;li&gt;Complete tick-by-tick simulation with a variable time interval.&lt;/li&gt; &#xA; &lt;li&gt;Full order book reconstruction based on L2 feeds(Market-By-Price).&lt;/li&gt; &#xA; &lt;li&gt;Backtest accounting for both feed and order latency, using provided models or your own custom model.&lt;/li&gt; &#xA; &lt;li&gt;Order fill simulation that takes into account the order queue position, using provided models or your own custom model.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;See &lt;code&gt;full document here &amp;lt;https://hftbacktest.readthedocs.io/&amp;gt;&lt;/code&gt;_.&lt;/p&gt; &#xA;&lt;h1&gt;Getting started&lt;/h1&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;hftbacktest supports Python 3.8+. You can install hftbacktest using &lt;code&gt;pip&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: console&lt;/p&gt; &#xA;&lt;p&gt;pip install hftbacktest&lt;/p&gt; &#xA;&lt;p&gt;Or you can clone the latest development version from the Git repository with:&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: console&lt;/p&gt; &#xA;&lt;p&gt;git clone &lt;a href=&#34;https://github.com/nkaz001/hftbacktest&#34;&gt;https://github.com/nkaz001/hftbacktest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Data Source &amp;amp; Format&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;code&gt;Data &amp;lt;https://hftbacktest.readthedocs.io/en/latest/data.html&amp;gt;&lt;/code&gt;_ or &lt;code&gt;Data Preparation &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Data%20Preparation.html&amp;gt;&lt;/code&gt;_.&lt;/p&gt; &#xA;&lt;h2&gt;A Quick Example&lt;/h2&gt; &#xA;&lt;p&gt;Get a glimpse of what backtesting with hftbacktest looks like with these code snippets:&lt;/p&gt; &#xA;&lt;p&gt;.. code-block:: python&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@njit&#xA;def simple_two_sided_quote(hbt, stat):&#xA;    max_position = 5&#xA;    half_spread = hbt.tick_size * 20&#xA;    skew = 1&#xA;    order_qty = 0.1&#xA;    last_order_id = -1&#xA;    order_id = 0&#xA;&#xA;    # Checks every 0.1s&#xA;    while hbt.elapse(100_000):&#xA;        # Clears cancelled, filled or expired orders.&#xA;        hbt.clear_inactive_orders()&#xA;&#xA;        # Obtains the current mid-price and computes the reservation price.&#xA;        mid_price = (hbt.best_bid + hbt.best_ask) / 2.0&#xA;        reservation_price = mid_price - skew * hbt.position * hbt.tick_size&#xA;&#xA;        buy_order_price = reservation_price - half_spread&#xA;        sell_order_price = reservation_price + half_spread&#xA;&#xA;        last_order_id = -1&#xA;        # Cancel all outstanding orders&#xA;        for order in hbt.orders.values():&#xA;            if order.cancellable:&#xA;                hbt.cancel(order.order_id)&#xA;                last_order_id = order.order_id&#xA;&#xA;        # All order requests are considered to be requested at the same time.&#xA;        # Waits until one of the order cancellation responses is received.&#xA;        if last_order_id &amp;gt;= 0:&#xA;            hbt.wait_order_response(last_order_id)&#xA;&#xA;        # Clears cancelled, filled or expired orders.&#xA;        hbt.clear_inactive_orders()&#xA;&#xA;        last_order_id = -1&#xA;        if hbt.position &amp;lt; max_position:&#xA;            # Submits a new post-only limit bid order.&#xA;            order_id += 1&#xA;            hbt.submit_buy_order(&#xA;                order_id,&#xA;                buy_order_price,&#xA;                order_qty,&#xA;                GTX&#xA;            )&#xA;            last_order_id = order_id&#xA;&#xA;        if hbt.position &amp;gt; -max_position:&#xA;            # Submits a new post-only limit ask order.&#xA;            order_id += 1&#xA;            hbt.submit_sell_order(&#xA;                order_id,&#xA;                sell_order_price,&#xA;                order_qty,&#xA;                GTX&#xA;            )&#xA;            last_order_id = order_id&#xA;&#xA;        # All order requests are considered to be requested at the same time.&#xA;        # Waits until one of the order responses is received.&#xA;        if last_order_id &amp;gt;= 0:&#xA;            hbt.wait_order_response(last_order_id)&#xA;&#xA;        # Records the current state for stat calculation.&#xA;        stat.record(hbt)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Tutorials&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Data Preparation &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Data%20Preparation.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Getting Started &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Getting%20Started.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Working with Market Depth and Trades &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Working%20with%20Market%20Depth%20and%20Trades.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Integrating Custom Data &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Integrating%20Custom%20Data.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;High-Frequency Grid Trading &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/High-Frequency%20Grid%20Trading.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Impact of Order Latency &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Impact%20of%20Order%20Latency.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Guéant–Lehalle–Fernandez-Tapia Market Making Model and Grid Trading &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/GLFT%20Market%20Making%20Model%20and%20Grid%20Trading.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Making Multiple Markets &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Making%20Multiple%20Markets.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Risk Mitigation through Price Protection in Extreme Market Conditions &amp;lt;https://hftbacktest.readthedocs.io/en/latest/tutorials/Risk%20Mitigation%20through%20Price%20Protection%20in%20Extreme%20Market%20Conditions.html&amp;gt;&lt;/code&gt;_&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;You can find more examples in &lt;code&gt;examples &amp;lt;https://github.com/nkaz001/hftbacktest/tree/master/examples&amp;gt;&lt;/code&gt;_ directory.&lt;/p&gt; &#xA;&lt;h1&gt;Experimental features&lt;/h1&gt; &#xA;&lt;p&gt;The experimental features are currently in the early stages of development, having been completely rewritten in Rust to support the following features.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Backtesting of multi-asset and multi-exchange models&lt;/li&gt; &#xA; &lt;li&gt;Deployment of a live trading bot using the same algo code.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please see &lt;code&gt;rust &amp;lt;https://github.com/nkaz001/hftbacktest/tree/master/rust&amp;gt;&lt;/code&gt;_ directory.&lt;/p&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Thank you for considering contributing to hftbacktest! Welcome any and all help to improve the project. If you have an idea for an enhancement or a bug fix, please open an issue or discussion on GitHub to discuss it.&lt;/p&gt; &#xA;&lt;p&gt;The following items are examples of contributions you can make to this project:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Improve performance statistics reporting&lt;/li&gt; &#xA; &lt;li&gt;Implement test code&lt;/li&gt; &#xA; &lt;li&gt;Add additional queue or exchange models&lt;/li&gt; &#xA; &lt;li&gt;Update documentation and examples&lt;/li&gt; &#xA; &lt;li&gt;Implement a live bot connector&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;.. |python| image:: &lt;a href=&#34;https://img.shields.io/pypi/pyversions/hftbacktest.svg?style=plastic&#34;&gt;https://img.shields.io/pypi/pyversions/hftbacktest.svg?style=plastic&lt;/a&gt; :alt: Python Version :target: &lt;a href=&#34;https://badge.fury.io/py/hftbacktest&#34;&gt;https://badge.fury.io/py/hftbacktest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |codacy| image:: &lt;a href=&#34;https://app.codacy.com/project/badge/Grade/e2cef673757a45b18abfc361779feada&#34;&gt;https://app.codacy.com/project/badge/Grade/e2cef673757a45b18abfc361779feada&lt;/a&gt; :alt: Codacy :target: &lt;a href=&#34;https://www.codacy.com/gh/nkaz001/hftbacktest/dashboard?utm_source=github.com&amp;amp;amp;utm_medium=referral&amp;amp;amp;utm_content=nkaz001/hftbacktest&amp;amp;amp;utm_campaign=Badge_Grade&#34;&gt;https://www.codacy.com/gh/nkaz001/hftbacktest/dashboard?utm_source=github.com&amp;amp;amp;utm_medium=referral&amp;amp;amp;utm_content=nkaz001/hftbacktest&amp;amp;amp;utm_campaign=Badge_Grade&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |codeql| image:: &lt;a href=&#34;https://github.com/nkaz001/hftbacktest/actions/workflows/codeql.yml/badge.svg?branch=master&amp;amp;event=push&#34;&gt;https://github.com/nkaz001/hftbacktest/actions/workflows/codeql.yml/badge.svg?branch=master&amp;amp;event=push&lt;/a&gt; :alt: CodeQL :target: &lt;a href=&#34;https://github.com/nkaz001/hftbacktest/actions/workflows/codeql.yml&#34;&gt;https://github.com/nkaz001/hftbacktest/actions/workflows/codeql.yml&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |pypi| image:: &lt;a href=&#34;https://badge.fury.io/py/hftbacktest.svg&#34;&gt;https://badge.fury.io/py/hftbacktest.svg&lt;/a&gt; :alt: Package Version :target: &lt;a href=&#34;https://pypi.org/project/hftbacktest&#34;&gt;https://pypi.org/project/hftbacktest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |downloads| image:: &lt;a href=&#34;https://static.pepy.tech/badge/hftbacktest&#34;&gt;https://static.pepy.tech/badge/hftbacktest&lt;/a&gt; :alt: Downloads :target: &lt;a href=&#34;https://pepy.tech/project/hftbacktest&#34;&gt;https://pepy.tech/project/hftbacktest&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |license| image:: &lt;a href=&#34;https://img.shields.io/badge/License-MIT-green.svg&#34;&gt;https://img.shields.io/badge/License-MIT-green.svg&lt;/a&gt; :alt: License :target: &lt;a href=&#34;https://github.com/nkaz001/hftbacktest/raw/master/LICENSE&#34;&gt;https://github.com/nkaz001/hftbacktest/blob/master/LICENSE&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;.. |docs| image:: &lt;a href=&#34;https://readthedocs.org/projects/hftbacktest/badge/?version=latest&#34;&gt;https://readthedocs.org/projects/hftbacktest/badge/?version=latest&lt;/a&gt; :target: &lt;a href=&#34;https://hftbacktest.readthedocs.io/en/latest/?badge=latest&#34;&gt;https://hftbacktest.readthedocs.io/en/latest/?badge=latest&lt;/a&gt; :alt: Documentation Status&lt;/p&gt; &#xA;&lt;p&gt;.. |github| image:: &lt;a href=&#34;https://img.shields.io/github/stars/nkaz001/hftbacktest?style=social&#34;&gt;https://img.shields.io/github/stars/nkaz001/hftbacktest?style=social&lt;/a&gt; :target: &lt;a href=&#34;https://github.com/nkaz001/hftbacktest&#34;&gt;https://github.com/nkaz001/hftbacktest&lt;/a&gt; :alt: Github&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>helius-labs/atlas-txn-sender</title>
    <updated>2024-03-29T01:36:34Z</updated>
    <id>tag:github.com,2024-03-29:/helius-labs/atlas-txn-sender</id>
    <link href="https://github.com/helius-labs/atlas-txn-sender" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Atlas Txn Sender&lt;/h2&gt; &#xA;&lt;p&gt;This package uses the min required dependencies to send transactions to Solana leaders.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This service does not handle preflight checks, and also doesn&#39;t validate blockhashes before sending to leader&lt;/p&gt; &#xA;&lt;p&gt;The service has the following envs:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;RPC_URL&lt;/code&gt; - RPC url used to fetch next leaders with &lt;code&gt;getSlotLeaders&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;GRPC_URL&lt;/code&gt; - Yellowstone GRPC Geyser url used to stream latest slots and blocks. Slots tell us what to call &lt;code&gt;getSlotLeaders&lt;/code&gt; with, blocks tell us if the txns we&#39;ve sent were sent successfully.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;X_TOKEN&lt;/code&gt; - token used to authenticate with the grpc url&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;TPU_CONNECTION_POOL_SIZE&lt;/code&gt; - Number of leaders to cache connections to, and send transactions to. The default in the solana client is 4.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;NUM_LEADERS&lt;/code&gt; - Number of leaders to send transactions to&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;LEADER_OFFSET&lt;/code&gt; - Offset of the leader schedule. Default is 0.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;IDENTITY_KEYPAIR_FILE&lt;/code&gt; - Path to the keypair file. If this is a validator key it will use a staked connection to connect to leaders.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;PORT&lt;/code&gt; - Port to run the service on. Default is 4040.&lt;/p&gt; &#xA;&lt;h3&gt;Install Dependencies&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo apt-get install libssl-dev libudev-dev pkg-config zlib1g-dev llvm clang cmake make libprotobuf-dev protobuf-compiler&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Running&lt;/h3&gt; &#xA;&lt;p&gt;set the above envs and install dependencies, then run &lt;code&gt;cargo run --release&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Deploying service with ansible&lt;/h3&gt; &#xA;&lt;p&gt;Deploying the service with ansible will setup a systemd service with haproxy so that you can access the service over port 80. It will also install datadog for metrics.&lt;/p&gt; &#xA;&lt;p&gt;First you need to install the datadog role with the following command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ansible-galaxy install datadog.datadog&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you need to update the file &lt;code&gt;ansible/inventory/hosts.yml&lt;/code&gt; with the name/ip address/user of the server you want to deploy to.&lt;/p&gt; &#xA;&lt;p&gt;Then you need to set these in the &lt;code&gt;ansible/deploy_atlas_txn_sender.yml&lt;/code&gt; file&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rpc_url&#xA;grpc_url&#xA;x_token&#xA;datadog_api_key&#xA;datadog_site&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then you can run the following command to deploy the service&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ansible-playbook -i ansible/inventory/hosts.yml ansible/deploy_atlas_txn_sender.yml&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>snowfoxsh/nestify</title>
    <updated>2024-03-29T01:36:34Z</updated>
    <id>tag:github.com,2024-03-29:/snowfoxsh/nestify</id>
    <link href="https://github.com/snowfoxsh/nestify" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Nestify offers a macro to simplify and beautify nested struct definitions in Rust, enabling cleaner, more readable code structures with less verbosity. It&#39;s especially valuable for handling API responses&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nestify&lt;/h1&gt; &#xA;&lt;p&gt;Nestify is a Rust library offering a powerful macro to streamline the definition of nested structs and enums. Designed to improve code readability and maintainability&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/nestify&#34;&gt;&lt;img alt=&#34;crates.io&#34; src=&#34;https://img.shields.io/crates/v/nestify.svg?style=for-the-badge&amp;amp;color=fc8d62&amp;amp;logo=rust&#34; height=&#34;20&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/snowfoxsh/nestify&#34;&gt;&lt;img alt=&#34;github&#34; src=&#34;https://img.shields.io/badge/snowfoxsh/nestify-8da0cb?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=github&#34; height=&#34;20&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/snowfoxsh/nestify/master/LICENSE&#34;&gt;&lt;img alt=&#34;License&#34; src=&#34;https://img.shields.io/crates/l/nestify?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Abstract&lt;/h2&gt; &#xA;&lt;p&gt;Nestify re-imagines Rust struct and enum definitions with its &#34;Type is Definition&#34; approach, streamlining the way you handle nested structures. Gone are the days of flipping back and forth between type definitions—Nestify Unifies your codebase, making your code cleaner and far more readable.&lt;/p&gt; &#xA;&lt;p&gt;Nestify is crafted for ease of learning, with its syntax tailored to be comfortable for Rust developers. The aim is for anyone, even those unfamiliar with the Nest macro, to quickly grasp its concept upon first glance.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Simplify nested struct and enum definitions in Rust.&lt;/li&gt; &#xA; &lt;li&gt;Make your codebase more readable and less verbose.&lt;/li&gt; &#xA; &lt;li&gt;Ideal for modeling complex API responses.&lt;/li&gt; &#xA; &lt;li&gt;Advanced attribute modifiers.&lt;/li&gt; &#xA; &lt;li&gt;Works well with Serde.&lt;/li&gt; &#xA; &lt;li&gt;Intuitive syntax&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Add this to your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;nestify = &#34;0.3.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use the macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use nestify::nest;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE] A nightly toolchain might provide better error diagnostics&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Quick Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Simple Nested Structures&lt;/h3&gt; &#xA;&lt;p&gt;Here&#39;s a quick example to show how Nestify simplifies nested struct definitions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Define a user profile with nested address and preferences structures&#xA;nest! {&#xA;    struct UserProfile {&#xA;        name: String,&#xA;        address: struct Address {&#xA;            street: String,&#xA;            city: String,&#xA;        },&#xA;        preferences: struct Preferences {&#xA;            newsletter: bool,&#xA;        },&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct UserProfile {&#xA;    name: String,&#xA;    address: Address,&#xA;    preferences: Preferences,&#xA;}&#xA;&#xA;struct Address {&#xA;    street: String,&#xA;    city: String,&#xA;}&#xA;&#xA;struct Preferences {&#xA;    newsletter: bool,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Simple Nested Enums&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Define a task with a nested status enum&#xA;nest! {&#xA;    struct Task {&#xA;        id: i32,&#xA;        description: String,&#xA;        status: enum Status {&#xA;            Pending,&#xA;            InProgress,&#xA;            Completed,&#xA;        },&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Task {&#xA;    id: i32,&#xA;    description: String,&#xA;    status: Status,&#xA;}&#xA;&#xA;enum Status {&#xA;    Pending,&#xA;    InProgress,&#xA;    Completed,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Supported definitions&lt;/h2&gt; &#xA;&lt;p&gt;Nestify supports both &lt;a href=&#34;https://doc.rust-lang.org/reference/expressions/struct-expr.html&#34;&gt;structs&lt;/a&gt; and &lt;a href=&#34;https://doc.rust-lang.org/reference/items/enumerations.html&#34;&gt;enums&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// field structs (named)&#xA;nest! {&#xA;    struct Named {&#xA;        f: struct Nested {}&#xA;    }&#xA;}&#xA;&#xA;// tuple structs (unnamed)&#xA;nest! {&#xA;    struct Unnamed(struct Nested())&#xA;}&#xA;&#xA;// unit structs&#xA;nest! {&#xA;    struct Unit {&#xA;        unit: struct UnitStruct&#xA;    }&#xA;}&#xA;&#xA;&#xA;// enums&#xA;nest! {&#xA;    enum EnumVariants {&#xA;        Unit,&#xA;        Tuple(i32, struct TupleNested),&#xA;        Struct {&#xA;            f1: i32,&#xA;&#xA;        }&#xA;        DiscriminantVariant = 1,&#xA;    }&#xA;}&#xA;// note: any variant can have a discriminant&#xA;// just as in normal rust&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// field structs (named)&#xA;struct Named {&#xA;    f: Nested,&#xA;}&#xA;struct Nested {}&#xA;&#xA;// tuple structs (unnamed)&#xA;struct Unnamed(Nested,);&#xA;struct Nested();&#xA;&#xA;// unit structs&#xA;struct Unit {&#xA;    unit: UnitStruct,&#xA;}&#xA;struct UnitStruct;&#xA;&#xA;&#xA;// enums&#xA;enum EnumVariants {&#xA;    Unit,&#xA;    Tuple(i32, TupleNested),&#xA;    Struct { &#xA;        f1: i32 &#xA;    },&#xA;    DiscriminantVariant = 1,&#xA;}&#xA;struct TupleNested;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Generics&lt;/h2&gt; &#xA;&lt;p&gt;Nestify fully supports Rust&#39;s generic parameters. This compatibility ensures that you can incorporate both lifetime and type parameters within your nested struct definitions, just as you would in standard Rust code.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    struct Example&amp;lt;&#39;a, T&amp;gt; {&#xA;        s: &amp;amp;&#39;a str,&#xA;        t: T&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Example&amp;lt;&#39;a, T&amp;gt; { &#xA;    s: &amp;amp;&#39;a str, &#xA;    t: T, &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Nested Generics&lt;/h3&gt; &#xA;&lt;p&gt;When defining nested generics, you need to add generics to types. Enter &#34;FishHook&#34; syntax. To define generics on the field use &lt;code&gt;||&amp;lt;...&amp;gt;&lt;/code&gt;. This will let you specify the nested generic types. It also works with lifetimes if needed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    struct Parent&amp;lt;&#39;a&amp;gt; {&#xA;        child : struct Child&amp;lt;&#39;c, C&amp;gt; {&#xA;            s: &amp;amp;&#39;c str,&#xA;            f: C&#xA;        } ||&amp;lt;&#39;a, i32&amp;gt;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Parent&amp;lt;&#39;a&amp;gt; {&#xA;    child: Child&amp;lt;&#39;a, i32&amp;gt;,&#xA;    //           ^^^^^^^^ FishHook expands to this part&#xA;}&#xA;&#xA;struct Child&amp;lt;&#39;c, C&amp;gt; {&#xA;    s: &amp;amp;&#39;c str,&#xA;    f: C,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Attributes&lt;/h2&gt; &#xA;&lt;p&gt;You can apply attributes just like you would with a normal struct.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    #[derive(Clone)]&#xA;    struct CloneMe {}&#xA;}&#xA;&#xA;let x = CloneMe {};&#xA;let cl = x.clone();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Recursive Attributes &lt;strong&gt;&lt;code&gt;#[meta]*&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;code&gt;*&lt;/code&gt; syntax you can inherit attributes to child structures easily. The attribute will propagate to each nested structure or enum.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    #[apply_all]*&#xA;    struct One {&#xA;        two: struct Two {&#xA;            three: struct Three {&#xA;                payload: ()&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[apply_all]&#xA;struct One {&#xA;    two: Tow,&#xA;}&#xA;&#xA;#[apply_all]&#xA;struct Two {&#xA;    three: Three,&#xA;}&#xA;&#xA;#[apply_all]&#xA;struct Three {&#xA;    payload: (),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Removal Syntax&lt;/h3&gt; &#xA;&lt;h4&gt;Disable Propagation &lt;strong&gt;&lt;code&gt;#[meta]/&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;You can end the recursion of an attribute with a &lt;code&gt;/&lt;/code&gt; attribute modifier. It will remove a recursive attribute from the current structure and all nested structures&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    #[nest]*&#xA;    struct One {&#xA;        two: struct Two {&#xA;            three: #[nest]/ &#xA;            struct Three {&#xA;                four: struct Four { }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[nest]&#xA;struct One {&#xA;    two: Two,&#xA;}&#xA;&#xA;#[nest]&#xA;struct Two {&#xA;    three: Three,&#xA;}&#xA;&#xA;struct Three {&#xA;    four: Four,&#xA;}&#xA;&#xA;struct Four {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Disable Single &lt;strong&gt;&lt;code&gt;#[meta]-&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Using the &lt;code&gt;-&lt;/code&gt; modifier will remove a recursive attribute from a single structure To use the previous example using &lt;code&gt;-&lt;/code&gt; instead of &lt;code&gt;/&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    #[nest]*&#xA;    struct One {&#xA;        two: struct Two {&#xA;            three: #[nest]- &#xA;            struct Three {&#xA;                four: struct Four { }&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[nest]&#xA;struct One {&#xA;    two: Two,&#xA;}&#xA;&#xA;#[nest]&#xA;struct Two {&#xA;    three: Three,&#xA;}&#xA;&#xA;struct Three {&#xA;    four: Four,&#xA;}&#xA;&#xA;#[nest]&#xA;struct Four {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h3&gt;Field Attributes &lt;strong&gt;&lt;code&gt;#&amp;gt;[meta]&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt; &#xA;&lt;p&gt;If you structure has many defined attributes, it can become awkward to define attributes before the nested structure. To combat this, you can define attributes that apply to nested objects before fields and enum variants. This can be accomplished by using &lt;code&gt;#&amp;gt;[meta]&lt;/code&gt; syntax. &lt;code&gt;#&amp;gt;&lt;/code&gt; will apply the attribute to the next struct.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    struct MyStruct {&#xA;        #&amp;gt;[derive(Debug)]&#xA;        f: struct DebugableStruct { } &#xA;        // equivlent to: &#xA;        // f: #[derive(Debug)]&#xA;        // struct DebugableStruct { }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyStruct {&#xA;    f: DebugableStruct,&#xA;}&#xA;&#xA;#[derive(Debug)]&#xA;//       ^^^^^ applied to structure and not field `f`&#xA;struct DebugableStruct {}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h4&gt;Enum Variant Attributes&lt;/h4&gt; &#xA;&lt;p&gt;Field attributes can also be applied to an enum variant. If there are multiple items defined in a single variant then the attribute will be applied to each.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;nest! {&#xA;    enum MyEnum {&#xA;        #&amp;gt;[derive(Debug)]&#xA;        Variant {&#xA;            // #[derive(Debug)&#xA;            one: struct One,&#xA;            // #[derive(Debug)&#xA;            two: struct Two&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;enum MyEnum {&#xA;    Variant {&#xA;        one: One,&#xA;        two: Two,&#xA;    }&#xA;}&#xA;&#xA;#[derive(Debug)]&#xA;struct One;&#xA;&#xA;#[derive(Debug)]&#xA;struct Two;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Semicolons&lt;/h2&gt; &#xA;&lt;p&gt;Rust mandates semicolons to mark the end of tuple struct and unit struct declarations. Nestify, however, introduces flexibility by making this semicolon optional.&lt;/p&gt; &#xA;&lt;h3&gt;Rust Standard&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tuple struct: &lt;code&gt;struct MyTuple(i32, String);&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Unit struct: &lt;code&gt;struct MyUnit;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Nestify Flexibility&lt;/h3&gt; &#xA;&lt;p&gt;With Nestify, you can omit the semicolon without any impact:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Unit struct without a semicolon&#xA;nest! {&#xA;    struct MyUnit&#xA;}&#xA;&#xA;// Tuple struct without a semicolon&#xA;nest! {&#xA;    struct MyTuple(i32, String)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details class=&#34;expand&#34;&gt; &#xA; &lt;summary&gt; Expand &lt;/summary&gt; &#xA; &lt;br&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct MyUnit;&#xA;//           ^ automaticly added&#xA;&#xA;struct MyTuple(i32, String);&#xA;//                         ^ automaticly added&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;This adjustment simplifies syntax, particularly in the context of defining nested structures, aligning with Nestify&#39;s goal of enhancing code readability and maintenance. Whether you include the semicolon or not, Nestify processes the definitions correctly, thanks to its domain-specific optimizations.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;In Nestify, while you can work with a wide range of complex types to structure your data effectively, there&#39;s a specific limitation regarding the definition of new types directly within the generics of other types. This limitation affects scenarios where you might want to dynamically define a struct or enum inside a generic container like &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; as part of the type declaration.&lt;/p&gt; &#xA;&lt;p&gt;The limitation is specifically around embedding a new type definition within the generic parameters of another type. For instance:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// This pattern is not supported:&#xA;struct One(Vec&amp;lt;struct Two { field: i32 }&amp;gt;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here, &lt;code&gt;struct Two&lt;/code&gt; is being defined directly within the generic parameter of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which is not currently possible with Nestify.&lt;/p&gt; &#xA;&lt;h3&gt;Another Example&lt;/h3&gt; &#xA;&lt;p&gt;To further illustrate, consider a scenario where you want to include an optional configuration struct within another struct:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// This pattern is also not supported:&#xA;struct AppConfig(Option&amp;lt;struct DatabaseConfig { url: String }&amp;gt;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, &lt;code&gt;struct DatabaseConfig&lt;/code&gt; is defined directly within the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; generic type in the declaration of &lt;code&gt;AppConfig&lt;/code&gt;. This specific way of defining &lt;code&gt;DatabaseConfig&lt;/code&gt; inline as part of the &lt;code&gt;AppConfig&lt;/code&gt; declaration is not supported by Nestify at the moment.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;I love contributors. I&#39;m a bad writer, so I would love community support to improve this guide!&lt;/p&gt; &#xA;&lt;p&gt;To make code changes:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Fork the repository.&lt;/li&gt; &#xA; &lt;li&gt;Create a new branch for your features or bug fixes.&lt;/li&gt; &#xA; &lt;li&gt;Write tests for your changes.&lt;/li&gt; &#xA; &lt;li&gt;Make sure all tests pass.&lt;/li&gt; &#xA; &lt;li&gt;Submit a pull request.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Standard stuff!&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the MIT License. If you need it under a different license &lt;em&gt;Contact Me&lt;/em&gt;. MIT license support will always be maintained. Don&#39;t fear!&lt;/p&gt; &#xA;&lt;h2&gt;Contact me&lt;/h2&gt; &#xA;&lt;p&gt;Check github for information @snowfoxsh&lt;/p&gt;</summary>
  </entry>
</feed>