<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-02T01:37:42Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>OwshenNetwork/owshen</title>
    <updated>2024-01-02T01:37:42Z</updated>
    <id>tag:github.com,2024-01-02:/OwshenNetwork/owshen</id>
    <link href="https://github.com/OwshenNetwork/owshen" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The Deep Sea&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Owshen ðŸŒŠ&lt;/h1&gt; &#xA;&lt;p&gt;Owshen is a privacy platform built for EVM-based blockchains. Owshen gathers multiple ideas around cryptocurrency privacy solutions in a single place to provide ultimate privacy.&lt;/p&gt; &#xA;&lt;p&gt;Using Owshen you can get a &lt;em&gt;&lt;strong&gt;fixed&lt;/strong&gt;&lt;/em&gt; Owshen address and start transacting with users inside/outside of the platform, without exposing:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Source&lt;/strong&gt; (Spend your coins using Zcash/TornadoCash-style merkle inclusion proofs, along with nullifiers)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Destination&lt;/strong&gt; (Monero-style stealth-addresses are generated each time you send your coins to someone)&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Token/Amount&lt;/strong&gt; (These values are obfuscated and only the sender and receiver, who know a shared-secret, will be able to decode them)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Join our Discord: &lt;a href=&#34;https://discord.com/invite/brczTyZXbS&#34;&gt;https://discord.com/invite/brczTyZXbS&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone the project &lt;code&gt;git clone https://github.com/OwshenNetwork/owshen --recurse-submodules&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;If you already cloned the project without the cloning submodules first running: &lt;code&gt;git submodule update --init --recursive&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;The option &lt;code&gt;--remote&lt;/code&gt; was added to support updating to latest tips of remote branches: &lt;code&gt;git submodule update --recursive --remote&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install Rust language: &lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install Foundry: &lt;code&gt;https://book.getfoundry.sh/getting-started/installation&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install dependencies: &lt;code&gt;apt-get install nodejs npm libgmp3-dev nasm nlohmann-json3-dev&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install Circom/SnarkJS: &lt;code&gt;npm i -g snarkjs circom&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install Owshen: &lt;code&gt;cd owshen &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For installing client dependencies we need to go to client route and: &lt;code&gt;yarn&lt;/code&gt; or &lt;code&gt;npm install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Running proper Ganache localhost network: &lt;code&gt;ganache-cli -d --db chain&lt;/code&gt; (We need to import first account from Ganache to metamask for local testing)&lt;/li&gt; &#xA; &lt;li&gt;Initialize your pub/priv keys and deploying dependencies by running &lt;code&gt;cargo run -- init --endpoint http://127.0.0.1:8545 --db test.json&lt;/code&gt; (Your keys will be saved in &lt;code&gt;~/.owshen-wallet.json&lt;/code&gt; - also you can running this command multiple times for testing purpose)&lt;/li&gt; &#xA; &lt;li&gt;Run the wallet (GUI): &lt;code&gt;cargo run -- wallet --port 9000 --db test.json&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How? ðŸ¤”&lt;/h2&gt; &#xA;&lt;p&gt;Owshen Platform is basically a smart-contract maintaining a Sparse-Merkle-Tree, very similar to TornadoCash, with one big difference. Instead of commitments (Which are hashes of secret values), elliptic-curve points (Public-keys) are stored in the leaves, and one can only spend a coin in case he proves that he knows a private-key $s$, where $s \times G$ ($G$ is a commonly agreed generator point) is a point that exists in the tree (Through a merkle-proof fed in a Zero-Knowledge proof circuit).&lt;/p&gt; &#xA;&lt;p&gt;Fixed addresses are bad for the destination&#39;s privacy, a TornadoCash-style pool will only allow you to hide the sender, but everyone watching from outside can see that money is being sent to the receiver. We may solve this problem by requiring the receiver to generate a new address whenever he wants to receive a coin, but this would require the receiver to be online all the time. In case the receiver is someone accepting donations, it&#39;s easiest for him to announce a fixed address for receiving the donations.&lt;/p&gt; &#xA;&lt;p&gt;Stealth-addresses solve this problem already: instead of requiring the receiver to generate a new address everytime he wants to receive the coin, we will let the sender derive stealth public-keys, from the receiver&#39;s master public key!&lt;/p&gt; &#xA;&lt;p&gt;The sender will generate a random scalar $r$, and will broadcast the point $r \times G$ publicly. In this case, $s \times r \times G$ is a shared-secret between the sender and the receiver (Very similar to Diffie-Hellman key-exchange algorithm). $s \times r \times G$ is an elliptic curve point, we can convert it to a scalar using a hash function, so that it can be used a private-key. The sender will send the coin to $(hash(s \times r \times G) + s)\times G$ instead of $s \times G$, and then the receiver would be able to detect incoming transactions and derive the corresponding private-keys of stealth-addresses: $hash(s \times r \times G) + s$.&lt;/p&gt; &#xA;&lt;h3&gt;Owshen&#39;s merkle-tree structure &lt;span&gt;ðŸŒ²&lt;/span&gt;&lt;/h3&gt; &#xA;&lt;p&gt;As previosuly said, a Sparse-Merkle-Tree is being maintained in Owshen platform&#39;s smart-contract, where each leaf is:&lt;/p&gt; &#xA;&lt;p&gt;$hash({pub}_x,{pub}_y,token,amount)$&lt;/p&gt; &#xA;&lt;p&gt;One can spend/withdraw a coin in the merkle-tree by proving:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;I know a private key $s$ (Private), where there exists a leaf in tree with public-key $s \times G$, holding $amount$ of $token$.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;After each send, an event will be emitted, providing the data needed for the receiver to recognize his incoming transactions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-solidity=&#34;&gt;event Sent(&#xA;    Point pub_key, // g^(hash(g^sr) + s)&#xA;    Point ephemeral, // g^r&#xA;    uint256 encoded_token, // token + hash(g^sr)&#xA;    uint256 encoded_amount // amount + hash(g^sr)&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The shared secret between the sender and receiver is $hash(g^{sr})$. We can add the shared-secret to the token-id and amount in order to obfuscate them. ($p$ is the field-size)&lt;/p&gt; &#xA;&lt;p&gt;${token}_{encoded} = ({token} + hash(g^{sr})) \mod p$&lt;/p&gt; &#xA;&lt;p&gt;${amount}_{encoded} = ({amount} + hash(g^{sr})) \mod p$&lt;/p&gt; &#xA;&lt;p&gt;The receiver may subtract the shared secret from token/amount to calculate the leaf&#39;s actual token/amount and try to calculate the commitment. If the commitment he has calculated is equal with the commitment submitted on-chain, then the coin is for him and he can derive the private-key needed for spending that coin.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>acrlabs/simkube</title>
    <updated>2024-01-02T01:37:42Z</updated>
    <id>tag:github.com,2024-01-02:/acrlabs/simkube</id>
    <link href="https://github.com/acrlabs/simkube" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Virtual Kubelet provider for Kubernetes scheduling simulations&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://github.com/acrlabs/simkube/actions/workflows/verify.yml/badge.svg?sanitize=true&#34; alt=&#34;build status&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;simkube&lt;/h1&gt; &#xA;&lt;p&gt;A collection of tools for simulating Kubernetes scheduling and autoscaling behaviour&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This package provides the following components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;sk-cloudprov&lt;/code&gt;: an &lt;a href=&#34;https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider/externalgrpc&#34;&gt;external gRPC-based cloud provider&lt;/a&gt; for Cluster Autoscaler that can communicate with and scale the &lt;code&gt;sk-vnode&lt;/code&gt; &#34;node group&#34;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;skctl&lt;/code&gt;: a CLI utility for interacting with various other SimKube components&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sk-ctrl&lt;/code&gt;: a Kubernetes Controller that watches for Simulation custom resources and runs a simulation based on the provided trace file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sk-driver&lt;/code&gt;: the actual runner for a specific simulation, created as a Kubernetes Job by &lt;code&gt;sk-ctrl&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sk-tracer&lt;/code&gt;: a watcher for Kubernetes pod creation and deletion events, saves these events in a replayable trace format.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sk-vnode&lt;/code&gt;: a &lt;a href=&#34;https://virtual-kubelet.io&#34;&gt;Virtual Kubelet&lt;/a&gt;-based &#34;hollow node&#34; that allows customization based off a &#34;skeleton&#34; node file (see the example in &lt;code&gt;simkube/k8s/sk_vnode.py&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Architecture Diagram&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/acrlabs/simkube/master/docs/images/sk-overview.png&#34; alt=&#34;architecture diagram of SimKube&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Demo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Q1XpH1H4It8&#34;&gt;&lt;img src=&#34;https://img.youtube.com/vi/Q1XpH1H4It8/hqdefault.jpg&#34; alt=&#34;Watch the video&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go &amp;gt;= 1.20&lt;/li&gt; &#xA; &lt;li&gt;Rust &amp;gt;= 1.71 (needed if you want to build outside of Docker)&lt;/li&gt; &#xA; &lt;li&gt;Docker&lt;/li&gt; &#xA; &lt;li&gt;kubectl &amp;gt;= 1.27&lt;/li&gt; &#xA; &lt;li&gt;Kubernetes &amp;gt;= 1.27&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cert-manager.io&#34;&gt;CertManager&lt;/a&gt; for setting up mutating webhook certificates&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Optional Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;SimKube uses &lt;a href=&#34;https://github.com/acrlabs/fireconfig&#34;&gt;ðŸ”¥Config&lt;/a&gt; to generate Kubernetes manifests from definitions located in &lt;code&gt;./k8s/&lt;/code&gt;. If you want to use this mechanism for generating Kubernetes manifests, you will need to install the following additional dependencies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Python 3.10&lt;/li&gt; &#xA; &lt;li&gt;Python Poetry (&lt;a href=&#34;https://python-poetry.org/docs/&#34;&gt;https://python-poetry.org/docs/&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Additionally, if you want to run SimKube on a local development cluster, &lt;a href=&#34;https://kind.sigs.k8s.io&#34;&gt;kind&lt;/a&gt; &amp;gt;= 0.19 is the supported tooling for doing so.&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;To build all SimKube artifacts for the first time run:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;git submodule init &amp;amp;&amp;amp; git submodule update&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;make build&lt;/code&gt; and &lt;code&gt;make skctl&lt;/code&gt; from the root of this repository.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For all subsequent builds of SimKube artifacts, run only &lt;code&gt;make build&lt;/code&gt; and &lt;code&gt;make skctl&lt;/code&gt; from the root of this repository.&lt;/p&gt; &#xA;&lt;h3&gt;Docker images&lt;/h3&gt; &#xA;&lt;p&gt;To build and push Docker images for all the artifacts, run &lt;code&gt;DOCKER_REGISTRY=path_to_your_registry:5000 make image&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Deploying&lt;/h3&gt; &#xA;&lt;p&gt;You will need a KUBECONFIG file with cluster admin permissions; &lt;code&gt;make run&lt;/code&gt; will use ðŸ”¥Config to generate the Kubernetes manifests and deploy all SimKube artifacts to the specified cluster.&lt;/p&gt; &#xA;&lt;h3&gt;Cleaning up&lt;/h3&gt; &#xA;&lt;p&gt;All build artifacts are placed in the &lt;code&gt;.build/&lt;/code&gt; directory. You can remove this directory or run &lt;code&gt;make clean&lt;/code&gt; to clean up.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome any and all contributions to the SimKube project! Please open a pull request.&lt;/p&gt; &#xA;&lt;p&gt;If you have a feature request, please start a &lt;a href=&#34;https://github.com/acrlabs/simkube/discussions&#34;&gt;discussion&lt;/a&gt;. Members of the SimKube team will determine whether the feature should become planned work and how it will be prioritized.&lt;/p&gt; &#xA;&lt;p&gt;If you&#39;ve found a bug or are working on a planned improvement, please &lt;a href=&#34;https://github.com/acrlabs/simkube/issues&#34;&gt;open an issue&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h3&gt;Code of Conduct&lt;/h3&gt; &#xA;&lt;p&gt;Applied Computing Research Labs has a strict code of conduct we expect all contributors to adhere to. Please read the &lt;a href=&#34;https://github.com/acrlabs/simkube/raw/master/CODE_OF_CONDUCT.md&#34;&gt;full text&lt;/a&gt; so that you understand the expectations upon you as a contributor.&lt;/p&gt; &#xA;&lt;h3&gt;Copyright and Licensing&lt;/h3&gt; &#xA;&lt;p&gt;SimKube is licensed under the &lt;a href=&#34;https://github.com/acrlabs/simkube/raw/master/LICENSE&#34;&gt;MIT License&lt;/a&gt;. Contributors to this project agree that they own the copyrights to all contributed material, and agree to license your contributions under the same terms. This is &#34;inbound=outbound&#34;, and is the &lt;a href=&#34;https://docs.github.com/en/site-policy/github-terms/github-terms-of-service#6-contributions-under-repository-license&#34;&gt;GitHub default&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!WARNING] Due to the uncertain nature of copyright and IP law, this repository does not accept contributions that have been all or partially generated with GitHub Copilot or other LLM-based code generation tools. Please disable any such tools before authoring changes to this project.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Contributor&#39;s Guide&lt;/h3&gt; &#xA;&lt;p&gt;Please see the &lt;a href=&#34;https://raw.githubusercontent.com/acrlabs/simkube/master/docs/contributing.md&#34;&gt;Contributor&#39;s Guide&lt;/a&gt; for more information on setting up and building SimKube.&lt;/p&gt;</summary>
  </entry>
</feed>