<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-10T01:39:12Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fuzzland/ityfuzz</title>
    <updated>2023-10-10T01:39:12Z</updated>
    <id>tag:github.com,2023-10-10:/fuzzland/ityfuzz</id>
    <link href="https://github.com/fuzzland/ityfuzz" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Blazing Fast Bytecode-Level Hybrid Fuzzer for Smart Contracts&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ItyFuzz üç¶&lt;/h1&gt; &#xA;&lt;p&gt;Fast hybrid fuzzer for EVM &amp;amp; MoveVM (WIP) smart contracts.&lt;/p&gt; &#xA;&lt;p&gt;You can generate exploits &lt;strong&gt;instantly&lt;/strong&gt; by just providing the contract address: &lt;img src=&#34;https://ityfuzz.assets.fuzz.land/demo2.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fuzzland/ityfuzz/&#34;&gt;Tool&lt;/a&gt; / &lt;a href=&#34;https://scf.so/ityfuzz.pdf&#34;&gt;Research Paper&lt;/a&gt; / &lt;a href=&#34;https://raw.githubusercontent.com/fuzzland/ityfuzz/master/#building-evm&#34;&gt;Fuzzing EVM Contracts&lt;/a&gt; / &lt;a href=&#34;https://raw.githubusercontent.com/fuzzland/ityfuzz/master/#building-with-move-sui-support&#34;&gt;Fuzzing Move Contracts&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Statistics &amp;amp; Comparison&lt;/h1&gt; &#xA;&lt;p&gt;Time taken for finding vulnerabilities / generating exploits:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Project Name&lt;/th&gt; &#xA;   &lt;th&gt;Vulnerability&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Mythril&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;SMARTIAN&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Slither&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;ItyFuzz&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;AES&lt;/td&gt; &#xA;   &lt;td&gt;Business Logic&lt;/td&gt; &#xA;   &lt;td&gt;Inf&lt;/td&gt; &#xA;   &lt;td&gt;Unsupported&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;4hrs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Carrot&lt;/td&gt; &#xA;   &lt;td&gt;Arbitrary External Call&lt;/td&gt; &#xA;   &lt;td&gt;17s&lt;/td&gt; &#xA;   &lt;td&gt;11s&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;1s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Olympus&lt;/td&gt; &#xA;   &lt;td&gt;Access Control&lt;/td&gt; &#xA;   &lt;td&gt;36s&lt;/td&gt; &#xA;   &lt;td&gt;Inf&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;1s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;MUMUG&lt;/td&gt; &#xA;   &lt;td&gt;Price Manipulation&lt;/td&gt; &#xA;   &lt;td&gt;Inf&lt;/td&gt; &#xA;   &lt;td&gt;Unsupported&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;18hrs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Omni&lt;/td&gt; &#xA;   &lt;td&gt;Reentrancy&lt;/td&gt; &#xA;   &lt;td&gt;Inf&lt;/td&gt; &#xA;   &lt;td&gt;Unsupported&lt;/td&gt; &#xA;   &lt;td&gt;Yes*&lt;/td&gt; &#xA;   &lt;td&gt;22hrs&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Verilog CTF-2&lt;/td&gt; &#xA;   &lt;td&gt;Reentrancy&lt;/td&gt; &#xA;   &lt;td&gt;Inf&lt;/td&gt; &#xA;   &lt;td&gt;Unsupported&lt;/td&gt; &#xA;   &lt;td&gt;Yes*&lt;/td&gt; &#xA;   &lt;td&gt;3s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sub&gt;* Slither only finds the reentrancy location, but not how to leverage reentrancy to trigger final buggy code. The output also contains significant amount of false positives. &lt;/sub&gt;&lt;/p&gt; &#xA;&lt;p&gt;Test Coverage:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Dataset&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;SMARTIAN&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;Echidna&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th&gt;&lt;strong&gt;ItyFuzz&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;B1&lt;/td&gt; &#xA;   &lt;td&gt;97.1%&lt;/td&gt; &#xA;   &lt;td&gt;47.1%&lt;/td&gt; &#xA;   &lt;td&gt;99.2%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;B2&lt;/td&gt; &#xA;   &lt;td&gt;86.2%&lt;/td&gt; &#xA;   &lt;td&gt;82.9%&lt;/td&gt; &#xA;   &lt;td&gt;95.4%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Tests&lt;/td&gt; &#xA;   &lt;td&gt;Unsupported&lt;/td&gt; &#xA;   &lt;td&gt;52.9%&lt;/td&gt; &#xA;   &lt;td&gt;100%&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;sub&gt;* B1 and B2 contain 72 single-contract projects from SMARTIAN artifacts. Tests are the projects in &lt;code&gt;tests&lt;/code&gt; directory. The coverage is calculated as &lt;code&gt;(instruction covered) / (total instruction - dead code)&lt;/code&gt;. &lt;/sub&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;ityfuzzup &lt;strong&gt;(Recommended)&lt;/strong&gt;&lt;/h2&gt; &#xA;&lt;p&gt;ityfuzzup is a script that automatically installs all dependencies and builds ItyFuzz.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -L https://ity.fuzz.land/ | bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Docker&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; and run docker image suitable for your system architecture:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker pull fuzzland/ityfuzz:stable&#xA;docker run -p 8000:8000 fuzzland/ityfuzz:stable&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can visit the interface at &lt;a href=&#34;http://localhost:8000&#34;&gt;http://localhost:8000&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;sub&gt;Note: The container uses public ETH RPC, may time out / be slow&lt;/sub&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Build from Source&lt;/h2&gt; &#xA;&lt;p&gt;You first need to install Rust through &lt;a href=&#34;https://rustup.rs/&#34;&gt;https://rustup.rs/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You need to have &lt;code&gt;libssl-dev&lt;/code&gt; (OpenSSL) and &lt;code&gt;libz3-dev&lt;/code&gt; (refer to &lt;a href=&#34;https://raw.githubusercontent.com/fuzzland/ityfuzz/master/#z3-installation&#34;&gt;Z3 Installation&lt;/a&gt; section for instruction) installed.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/fuzzland/ityfuzz.git &amp;amp;&amp;amp; cd ityfuzz&#xA;git submodule update --recursive --init&#xA;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can enable certain debug gates in &lt;code&gt;Cargo.toml&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;solc&lt;/code&gt; is needed for compiling smart contracts. You can use &lt;code&gt;solc-select&lt;/code&gt; tool to manage the version of &lt;code&gt;solc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Run (EVM)&lt;/h1&gt; &#xA;&lt;p&gt;Compile Smart Contracts:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ./tests/evm/multi-contract/&#xA;# include the library from ./solidity_utils for example&#xA;solc *.sol -o . --bin --abi --overwrite --base-path ../../../&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Run Fuzzer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t &#39;../tests/evm/multi-contract/*&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Demo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Verilog CTF Challenge 2&lt;/strong&gt; &lt;code&gt;tests/verilog-2/&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Flashloan attack + Reentrancy. The target is to reach line 34 in &lt;code&gt;Bounty.sol&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Exact Exploit:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;0. Borrow k MATIC such that k &amp;gt; balance() / 10&#xA;1. depositMATIC() with k MATIC&#xA;2. redeem(k * 1e18) -- reentrancy contract --&amp;gt; getBounty()&#xA;3. Return k MATIC&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use fuzzer to detect the vulnerability and generate the exploit (takes 0 - 200s):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# build contracts in tests/evm/verilog-2/&#xA;solc *.sol -o . --bin --abi --overwrite --base-path ../../../&#xA;# run fuzzer &#xA;ityfuzz evm -f -t &#34;../tests/evm/verilog-2/*&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; flag enables automated flashloan, which hooks all ERC20 external calls and make any users to have infinite balance.&lt;/p&gt; &#xA;&lt;h3&gt;Fuzz a Project (Offline)&lt;/h3&gt; &#xA;&lt;p&gt;You can fuzz a project by providing a path to the project directory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t &#39;[DIR_PATH]/*&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ItyFuzz would attempt to deploy all artifacts in the directory to a blockchain with no other smart contracts.&lt;/p&gt; &#xA;&lt;p&gt;Specifically, the project directory should contain a few &lt;code&gt;[X].abi&lt;/code&gt; and &lt;code&gt;[X].bin&lt;/code&gt; files. For example, to fuzz a contract named &lt;code&gt;main.sol&lt;/code&gt;, you should ensure &lt;code&gt;main.abi&lt;/code&gt; and &lt;code&gt;main.bin&lt;/code&gt; exist in the project directory. The fuzzer will automatically detect the contracts in directory, the correlation between them (see &lt;code&gt;tests/evm/multi-contract&lt;/code&gt;), and fuzz them.&lt;/p&gt; &#xA;&lt;p&gt;Optionally, if ItyFuzz fails to infer the correlation between contracts, you can add a &lt;code&gt;[X].address&lt;/code&gt;, where &lt;code&gt;[X]&lt;/code&gt; is the contract name, to specify the address of the contract.&lt;/p&gt; &#xA;&lt;p&gt;Caveats:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keep in mind that ItyFuzz is fuzzing on a clean blockchain, so you should ensure all related contracts (e.g., ERC20 token, Uniswap, etc.) are deployed to the blockchain before fuzzing.&lt;/li&gt; &#xA; &lt;li&gt;If your smart contract requires constructor arguments, please refer to below &lt;a href=&#34;https://raw.githubusercontent.com/fuzzland/ityfuzz/master/#constructor-arguments&#34;&gt;Constructor Arguments&lt;/a&gt; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Fuzz a Project (Online)&lt;/h3&gt; &#xA;&lt;p&gt;Ityfuzz will prioritize the use of environment variables &lt;code&gt;ETH_RPC_URL&lt;/code&gt; as the RPC endpoint, otherwise it will use built-in public RPCs.&lt;/p&gt; &#xA;&lt;p&gt;Rebuild with &lt;code&gt;flashloan_v2&lt;/code&gt; (only supported in onchain) enabled to get better result.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python3 -c &#39;content=open(&#34;Cargo.toml&#34;).read().replace(&#34;default = [&#34;, &#34;default = [\&#34;flashloan_v2\&#34;,&#34;);open(&#34;Cargo.toml&#34;,&#34;w&#34;).write(content);&#39;&#xA;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can fuzz a project by providing an address, a block, and a chain type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -o -t [TARGET_ADDR] --onchain-block-number [BLOCK] -c [CHAIN_TYPE] --onchain-etherscan-api-key [Etherscan API Key]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example: Fuzzing WETH contract (&lt;code&gt;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&lt;/code&gt;) on Ethereum mainnet at latest block.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -o -t 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 --onchain-block-number 0 -c ETH --onchain-etherscan-api-key PXUUKVEQ7Y4VCQYPQC2CEK4CAKF8SG7MVF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Fuzzing with flashloan and oracles enabled:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -o -t 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 --onchain-block-number 0 -c ETH -f -i -p --onchain-etherscan-api-key PXUUKVEQ7Y4VCQYPQC2CEK4CAKF8SG7MVF&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ItyFuzz would pull the ABI of the contract from Etherscan and fuzz it. If ItyFuzz encounters an unknown slot in the memory, it would pull the slot from chain RPC. If ItyFuzz encounters calls to external unknown contract, it would pull the bytecode and ABI of that contract. If its ABI is not available, ItyFuzz would not send any transaction to that contract.&lt;/p&gt; &#xA;&lt;h3&gt;Constructor Arguments&lt;/h3&gt; &#xA;&lt;p&gt;ItyFuzz provides two methods to pass in constructor arguments. These arguments are necessary for initializing the state of the contract when deployed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Method 1: CLI Arguments&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The first method is to pass in the constructor arguments directly as CLI arguments.&lt;/p&gt; &#xA;&lt;p&gt;When you run ItyFuzz using the CLI, you can include the &lt;code&gt;--constructor-args&lt;/code&gt; flag followed by a string that specifies the arguments for each constructor.&lt;/p&gt; &#xA;&lt;p&gt;The format is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ityfuzz evm -t &#39;tests/evm/multi-contract/*&#39; --constructor-args &#34;ContractName:arg1,arg2,...;AnotherContract:arg1,arg2,..;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For example, if you have two contracts, &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;main2&lt;/code&gt;, both having a &lt;code&gt;bytes32&lt;/code&gt; and a &lt;code&gt;uint256&lt;/code&gt; as constructor arguments, you would pass them in like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t &#39;tests/evm/multi-contract/*&#39; --constructor-args &#34;main:1,0x6100000000000000000000000000000000000000000000000000000000000000;main2:2,0x6200000000000000000000000000000000000000000000000000000000000000;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Method 2: Server Forwarding&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;The second method is to use our server to forward requests to a user-specified RPC, and cli will fetch the constructor arguments from the transactions sent to the RPC.&lt;/p&gt; &#xA;&lt;p&gt;Firstly, go to the &lt;code&gt;/server&lt;/code&gt; directory, and install the necessary packages:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /server&#xA;npm install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, start the server using the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node app.js&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, the server will forward requests to &lt;code&gt;http://localhost:8545&lt;/code&gt;, which is the default address for &lt;a href=&#34;https://github.com/trufflesuite/ganache&#34;&gt;Ganache&lt;/a&gt;, if you do not have a local blockchain running, you can use Ganache to start one. If you wish to forward requests to another location, you can specify the address as a command-line argument like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;node app.js http://localhost:8546&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Once the server is running, you can deploy your contract to &lt;code&gt;localhost:5001&lt;/code&gt; using a tool of your choice.&lt;/p&gt; &#xA;&lt;p&gt;For example, you can use Foundry to deploy your contract through the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;forge create src/flashloan.sol:main2 --rpc-url http://127.0.0.1:5001 --private-key 0x0000000000000000000000000000000000000000000000000000000000000000 --constructor-args &#34;1&#34; &#34;0x6100000000000000000000000000000000000000000000000000000000000000&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, you can fetch the constructor arguments using the &lt;code&gt;--fetch-tx-data&lt;/code&gt; flag:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t &#39;tests/evm/multi-contract/*&#39; --fetch-tx-data&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;ItyFuzz will fetch the constructor arguments from the transactions forwarded to the RPC through the server.&lt;/p&gt; &#xA;&lt;h3&gt;Concolic Execution Support (Experimental)&lt;/h3&gt; &#xA;&lt;p&gt;Concolic execution can be performed on certain testcases on the fly during fuzzing. It is particularly useful for fuzzing code with complex if-conditions. You can add &lt;code&gt;--concolic&lt;/code&gt; to args to make fuzzer conduct concolic execution. You can also add &lt;code&gt;--concolic-caller&lt;/code&gt; to args to make fuzzer solve for callers.&lt;/p&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd tests/evm/concolic-1/ &amp;amp;&amp;amp; solc *.sol -o . --bin --abi --overwrite --base-path ../../../ &amp;amp;&amp;amp; ../../../&#xA;ityfuzz evm -t &#39;tests/evm/concolic-1/*&#39; --concolic --concolic-caller&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Finding Custom Bugs (EVM)&lt;/h1&gt; &#xA;&lt;p&gt;You can simply insert &lt;code&gt;bug()&lt;/code&gt; or &lt;code&gt;typed_bug(string message)&lt;/code&gt; in your contract to report a condition when bug is found.&lt;/p&gt; &#xA;&lt;p&gt;For instance, a simple case can be written as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;function buy_token() public {&#xA;    if (msg.sender != owner) {&#xA;        bug();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The implementation of &lt;code&gt;bug()&lt;/code&gt; is as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;library FuzzLand {&#xA;    event AssertionFailed(string message);&#xA;  &#xA;    function bug() internal {&#xA;        emit AssertionFailed(&#34;Bug&#34;);&#xA;    }&#xA;  &#xA;    function typed_bug(string memory data) internal {&#xA;        emit AssertionFailed(data);&#xA;    }&#xA;&#xA;}&#xA;&#xA;function bug()  {&#xA;    FuzzLand.bug();&#xA;}&#xA;&#xA;function typed_bug(string memory data)  {&#xA;    FuzzLand.typed_bug(data);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can either paste the code above into your contract or import it from &lt;code&gt;solidity_utils/lib.sol&lt;/code&gt;, if you are using &lt;code&gt;bug&lt;/code&gt; or &lt;code&gt;typed_bug&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Echidna Support&lt;/h3&gt; &#xA;&lt;p&gt;Any contracts bearing functions starting with &lt;code&gt;echidna_&lt;/code&gt; will be treated as invariants and will be tested by ItyFuzz. If it returns &lt;code&gt;false&lt;/code&gt;, the fuzzer will report a bug.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-solidity&#34;&gt;function echidna_test() public {&#xA;    assert(false);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Scribble Support&lt;/h3&gt; &#xA;&lt;p&gt;Scribble is a tool for writing specifications for Solidity contracts. ItyFuzz supports Scribble annotations after it is compiled by &lt;code&gt;scribble&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following contract has a Scribble annotation that specifies the return value of &lt;code&gt;inc&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;contract Foo {&#xA;    /// #if_succeeds {:msg &#34;P1&#34;} y == x + 2;&#xA;    function inc(uint x) public pure returns (uint y) {&#xA;        return x+1;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You need to compile the contract using &lt;code&gt;scribble&lt;/code&gt; and pass the compiled contract to ItyFuzz&lt;/p&gt; &#xA;&lt;p&gt;Note that you must add &lt;code&gt;--no-assert&lt;/code&gt; to the &lt;code&gt;scribble&lt;/code&gt; command. Otherwise, ItyFuzz will not detect any bugs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;scribble test.sol --output-mode flat --output compiled.sol --no-assert&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then compile with &lt;code&gt;solc&lt;/code&gt; and run ItyFuzz:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;solc compiled.sol --bin --abi --overwrite -o build&#xA;ityfuzz evm -t &#34;build/*&#34; [More Arguments]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Test Coverage&lt;/h1&gt; &#xA;&lt;p&gt;ItyFuzz can collect instruction and branch coverage information for all the contracts it fuzzes. You simply need to append &lt;code&gt;--replay-file [WORKDIR]/corpus/*_replayable&lt;/code&gt; to collect all these information.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t [Targets] [Options Used During Fuzzing] --replay-file &#39;[WORKDIR]/corpus/*_replayable&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t &#39;tests/evm/multi-contract/*&#39; --replay-file &#39;work_dir/corpus/*_replayable&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may add source map information to the targets to get more accurate coverage information and uncovered source code. To get source map information, you simply need to append &lt;code&gt;--combined-json bin-runtime,srcmap-runtime&lt;/code&gt; to the solc command when building the targets.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# run in your target building directory (where you run solc)&#xA;solc [Options Used During Building] --combined-json bin-runtime,srcmap-runtime &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# build contracts in tests/evm/verilog-2/&#xA;solc *.sol -o . --bin --abi --overwrite --base-path ../../ --combined-json bin-runtime,srcmap-runtime&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Rarely, ItyFuzz has trouble to figure out the source code location. You may supply the &lt;strong&gt;absolute&lt;/strong&gt; path to the base location (what you passed to solc&#39;s --base-path or if you didn&#39;t pass anything, it is the building directory) to ItyFuzz.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ityfuzz evm -t [Targets] [Options Used During Fuzzing] --replay-file &#39;[WORKDIR]/corpus/*_replayable&#39; --base-path [ABSOLUTE PATH TO BASE LOCATION]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# note that we used --base-path ../../ when building the targets so it is /home/user/ityfuzz/tests/evm/verilog-2/../../&#xA;ityfuzz evm -t &#39;tests/evm/multi-contract/*&#39; --replay-file &#39;work_dir/corpus/*_replayable&#39; --base-path /home/user/ityfuzz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We do not track coverage of static calls (view, pure functions) by default!&lt;/p&gt; &#xA;&lt;h1&gt;Building With Move (Sui) Support&lt;/h1&gt; &#xA;&lt;p&gt;Build with feature &lt;code&gt;sui_support&lt;/code&gt; in &lt;code&gt;./Cargo.toml&lt;/code&gt; to enable Move support.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# add sui_support feature to Cargo.toml&#xA;python3 -c &#39;content=open(&#34;Cargo.toml&#34;).read().replace(&#34;default = [&#34;, &#34;default = [\&#34;sui_support\&#34;,&#34;);open(&#34;Cargo.toml&#34;,&#34;w&#34;).write(content);&#39;&#xA;&#xA;# build ItyFuzz with sui_support feature&#xA;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You may also want to install &lt;code&gt;sui-cli&lt;/code&gt; to build Move contracts.&lt;/p&gt; &#xA;&lt;h1&gt;Run (Move)&lt;/h1&gt; &#xA;&lt;p&gt;Compile the contracts with &lt;code&gt;sui move build&lt;/code&gt; and run ItyFuzz:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# build example contract that contains a bug&#xA;cd ./tests/move/share_object&#xA;sui move build&#xA;&#xA;# get back to ItyFuzz and run fuzzing on the built contract&#xA;cd ../../../&#xA;ityfuzz move -t &#34;./tests/move/share_object/build&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Reporting Bugs (Move)&lt;/h1&gt; &#xA;&lt;p&gt;You can emit an event of `` in your contract to report a condition when bug is found.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-move&#34;&gt;// define the event struct&#xA;use sui::event;&#xA;&#xA;struct AAAA__fuzzland_move_bug has drop, copy, store {&#xA;    info: u64&#xA;}&#xA;&#xA;... &#xA;    // inside function&#xA;    event::emit(AAAA__fuzzland_move_bug { info: 1 });&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;An example contract that report a bug can be found in &lt;code&gt;tests/move/share_object/sources/test.move&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Troubleshooting&lt;/h1&gt; &#xA;&lt;h3&gt;Z3 Installation&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;macOS&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/Z3Prover/z3 &amp;amp;&amp;amp; cd z3&#xA;python scripts/mk_make.py --prefix=/usr/local&#xA;cd build &amp;amp;&amp;amp; make -j64 &amp;amp;&amp;amp; sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the build command still fails for not finding &lt;code&gt;z3.h&lt;/code&gt;, do &lt;code&gt;export Z3_SYS_Z3_HEADER=/usr/local/include/z3.h&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Or you can use&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install z3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;apt install libz3-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Onchain Fetching&lt;/h3&gt; &#xA;&lt;p&gt;ItyFuzz attempts to fetch storage from blockchain nodes when SLOAD is encountered and the target is uninitialized. There are three ways of fetching:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;OneByOne: fetch one slot at a time. This is the default mode. It is slow but never fails.&lt;/li&gt; &#xA; &lt;li&gt;All: fetch all slots at once using custom API &lt;code&gt;eth_getStorageAll&lt;/code&gt; on our nodes. This is the fastest mode, but it may fail if the contract is too large.&lt;/li&gt; &#xA; &lt;li&gt;Dump: dump storage using debug API &lt;code&gt;debug_storageRangeAt&lt;/code&gt;. This only works for ETH (for now) and fails most of the time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Citation&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inproceedings{10.1145/3597926.3598059,&#xA;  author = {Shou, Chaofan and Tan, Shangyin and Sen, Koushik},&#xA;  title = {ItyFuzz: Snapshot-Based Fuzzer for Smart Contract},&#xA;  year = {2023},&#xA;  isbn = {9798400702211},&#xA;  publisher = {Association for Computing Machinery},&#xA;  address = {New York, NY, USA},&#xA;  url = {https://doi.org/10.1145/3597926.3598059},&#xA;  doi = {10.1145/3597926.3598059},&#xA;  booktitle = {Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis},&#xA;  pages = {322‚Äì333},&#xA;  numpages = {12},&#xA;  location = {Seattle, WA, USA},&#xA;  series = {ISSTA 2023}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Acknowledgement&lt;/h1&gt; &#xA;&lt;p&gt;This work was supported in part by NSF grants CCF-1900968, CCF1908870, and CNS1817122 and SKY Lab industrial sponsors and affiliates Astronomer, Google, IBM, Intel, Lacework, Microsoft, Mohamed Bin Zayed University of Artificial Intelligence, Nexla, Samsung SDS, Uber, and VMware. Any opinions, findings, conclusions, or recommendations in this repo do not necessarily reflect the position or the policy of the sponsors.&lt;/p&gt; &#xA;&lt;p&gt;Grants:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Grants&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://ityfuzz.assets.fuzz.land/sui.jpg&#34; width=&#34;100px/&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Grants from Sui Foundation for building Move and chain-specific support&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;img src=&#34;https://ityfuzz.assets.fuzz.land/web3.png&#34; width=&#34;100px/&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Grants from Web3 Foundation for building Substrate pallets and Ink! support&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>