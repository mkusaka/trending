<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-21T01:36:46Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bincode-org/bincode</title>
    <updated>2023-09-21T01:36:46Z</updated>
    <id>tag:github.com,2023-09-21:/bincode-org/bincode</id>
    <link href="https://github.com/bincode-org/bincode" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A binary encoder / decoder implementation in Rust.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Bincode&lt;/h1&gt; &#xA;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/bincode-org/bincode/trunk/logo.svg?sanitize=true&#34;&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bincode-org/bincode/actions&#34;&gt;&lt;img src=&#34;https://github.com/bincode-org/bincode/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/bincode&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/bincode.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- [![](https://img.shields.io/badge/bincode-rustc_1.41.1+-lightgray.svg)](https://blog.rust-lang.org/2020/02/27/Rust-1.41.1.html) --&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://matrix.to/#/#bincode:matrix.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/matrix/bincode:matrix.org?label=Matrix%20Chat&#34; alt=&#34;Matrix&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A compact encoder / decoder pair that uses a binary zero-fluff encoding scheme. The size of the encoded object will be the same or smaller than the size that the object takes up in memory in a running Rust program.&lt;/p&gt; &#xA;&lt;p&gt;In addition to exposing two simple functions (one that encodes to &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;, and one that decodes from &lt;code&gt;&amp;amp;[u8]&lt;/code&gt;), binary-encode exposes a Reader/Writer API that makes it work perfectly with other stream-based APIs such as Rust files, network streams, and the &lt;a href=&#34;https://github.com/rust-lang/flate2-rs&#34;&gt;flate2-rs&lt;/a&gt; compression library.&lt;/p&gt; &#xA;&lt;h2&gt;&lt;a href=&#34;https://docs.rs/bincode/&#34;&gt;API Documentation&lt;/a&gt;&lt;/h2&gt; &#xA;&lt;h2&gt;Bincode in the Wild&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/google/tarpc&#34;&gt;google/tarpc&lt;/a&gt;: Bincode is used to serialize and deserialize networked RPC messages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/servo/webrender&#34;&gt;servo/webrender&lt;/a&gt;: Bincode records WebRender API calls for record/replay-style graphics debugging.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/servo/ipc-channel&#34;&gt;servo/ipc-channel&lt;/a&gt;: IPC-Channel uses Bincode to send structs between processes using a channel-like API.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/ajeetdsouza/zoxide&#34;&gt;ajeetdsouza/zoxide&lt;/a&gt;: zoxide uses Bincode to store a database of directories and their access frequencies on disk.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use bincode::{config, Decode, Encode};&#xA;&#xA;#[derive(Encode, Decode, PartialEq, Debug)]&#xA;struct Entity {&#xA;    x: f32,&#xA;    y: f32,&#xA;}&#xA;&#xA;#[derive(Encode, Decode, PartialEq, Debug)]&#xA;struct World(Vec&amp;lt;Entity&amp;gt;);&#xA;&#xA;fn main() {&#xA;    let config = config::standard();&#xA;&#xA;    let world = World(vec![Entity { x: 0.0, y: 4.0 }, Entity { x: 10.0, y: 20.5 }]);&#xA;&#xA;    let encoded: Vec&amp;lt;u8&amp;gt; = bincode::encode_to_vec(&amp;amp;world, config).unwrap();&#xA;&#xA;    // The length of the vector is encoded as a varint u64, which in this case gets collapsed to a single byte&#xA;    // See the documentation on varint for more info for that.&#xA;    // The 4 floats are encoded in 4 bytes each.&#xA;    assert_eq!(encoded.len(), 1 + 4 * 4);&#xA;&#xA;    let (decoded, len): (World, usize) = bincode::decode_from_slice(&amp;amp;encoded[..], config).unwrap();&#xA;&#xA;    assert_eq!(world, decoded);&#xA;    assert_eq!(len, encoded.len()); // read all bytes&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Specification&lt;/h2&gt; &#xA;&lt;p&gt;Bincode&#39;s format is specified in &lt;a href=&#34;https://github.com/bincode-org/bincode/raw/trunk/docs/spec.md&#34;&gt;docs/spec.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Is Bincode suitable for storage?&lt;/h3&gt; &#xA;&lt;p&gt;The encoding format is stable, provided the same configuration is used. This should ensure that later versions can still read data produced by a previous versions of the library if no major version change has occurred.&lt;/p&gt; &#xA;&lt;p&gt;Bincode 1 and 2 are completely compatible if the same configuration is used.&lt;/p&gt; &#xA;&lt;p&gt;Bincode is invariant over byte-order, making an exchange between different architectures possible. It is also rather space efficient, as it stores no metadata like struct field names in the output format and writes long streams of binary data without needing any potentially size-increasing encoding.&lt;/p&gt; &#xA;&lt;p&gt;As a result, Bincode is suitable for storing data. Be aware that it does not implement any sort of data versioning scheme or file headers, as these features are outside the scope of this crate.&lt;/p&gt; &#xA;&lt;h3&gt;Is Bincode suitable for untrusted inputs?&lt;/h3&gt; &#xA;&lt;p&gt;Bincode attempts to protect against hostile data. There is a maximum size configuration available (&lt;code&gt;Configuration::with_limit&lt;/code&gt;), but not enabled in the default configuration. Enabling it causes pre-allocation size to be limited to prevent against memory exhaustion attacks.&lt;/p&gt; &#xA;&lt;p&gt;Deserializing any incoming data will not cause undefined behavior or memory issues, assuming that the deserialization code for the struct is safe itself.&lt;/p&gt; &#xA;&lt;p&gt;Bincode can be used for untrusted inputs in the sense that it will not create a security issues in your application, provided the configuration is changed to enable a maximum size limit. Malicious inputs will fail upon deserialization.&lt;/p&gt; &#xA;&lt;h3&gt;What is Bincode&#39;s MSRV (minimum supported Rust version)?&lt;/h3&gt; &#xA;&lt;p&gt;Bincode 2.0 is still in development and does not yet have a targeted MSRV. Once 2.0 is fully released the MSRV will be locked. After this point any changes to the MSRV are considered a breaking change for semver purposes.&lt;/p&gt; &#xA;&lt;h3&gt;Why does bincode not respect &lt;code&gt;#[repr(u8)]&lt;/code&gt;?&lt;/h3&gt; &#xA;&lt;p&gt;Bincode will encode enum variants as a &lt;code&gt;u32&lt;/code&gt;. If you&#39;re worried about storage size, we can recommend enabling &lt;code&gt;Configuration::with_variable_int_encoding()&lt;/code&gt;. This option is enabled by default with the &lt;code&gt;standard&lt;/code&gt; configuration. In this case enum variants will almost always be encoded as a &lt;code&gt;u8&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Currently we have not found a compelling case to respect &lt;code&gt;#[repr(...)]&lt;/code&gt;. You&#39;re most likely trying to interop with a format that is similar-but-not-quite-bincode. We only support our own protocol (&lt;a href=&#34;https://github.com/bincode-org/bincode/raw/trunk/docs/spec.md&#34;&gt;spec&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If you really want to use bincode to encode/decode a different protocol, consider implementing &lt;code&gt;Encode&lt;/code&gt; and &lt;code&gt;Decode&lt;/code&gt; yourself. &lt;code&gt;bincode-derive&lt;/code&gt; will output the generated implementation in &lt;code&gt;target/generated/bincode/&amp;lt;name&amp;gt;_Encode.rs&lt;/code&gt; and &lt;code&gt;target/generated/bincode/&amp;lt;name&amp;gt;_Decode.rs&lt;/code&gt; which should get you started.&lt;/p&gt;</summary>
  </entry>
</feed>