<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-03-30T01:37:44Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hyperlight-dev/hyperlight</title>
    <updated>2025-03-30T01:37:44Z</updated>
    <id>tag:github.com,2025-03-30:/hyperlight-dev/hyperlight</id>
    <link href="https://github.com/hyperlight-dev/hyperlight" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Hyperlight is a lightweight Virtual Machine Manager (VMM) designed to be embedded within applications. It enables safe execution of untrusted code within micro virtual machines with very low latency and minimal overhead.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;Hyperlight&lt;/h1&gt; &#xA; &lt;img src=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/refs/heads/main/docs/assets/hyperlight-logo.png&#34; width=&#34;150px&#34; alt=&#34;hyperlight logo&#34;&gt; &#xA; &lt;p&gt;&lt;strong&gt;Hyperlight is a lightweight Virtual Machine Manager (VMM) designed to be embedded within applications. It enables safe execution of untrusted code within &lt;i&gt;micro virtual machines&lt;/i&gt; with very low latency and minimal overhead.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Hyperlight is a nascent project with an evolving API and no guaranteed support. Assistance is provided on a best-effort basis by the developers.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Hyperlight is a library for creating &lt;em&gt;micro virtual machines&lt;/em&gt; — or &lt;em&gt;sandboxes&lt;/em&gt; — specifically optimized for securely running untrusted code with minimal impact. It supports both Windows and Linux, utilizing &lt;a href=&#34;https://docs.microsoft.com/en-us/virtualization/api/#windows-hypervisor-platform&#34;&gt;Windows Hypervisor Platform&lt;/a&gt; on Windows, and either Microsoft Hypervisor (mshv) or &lt;a href=&#34;https://linux-kvm.org/page/Main_Page&#34;&gt;KVM&lt;/a&gt; on Linux.&lt;/p&gt; &#xA;&lt;p&gt;These micro VMs operate without a kernel or operating system, keeping overhead low. Instead, guests are built specifically for Hyperlight using the Hyperlight Guest library, which provides a controlled set of APIs that facilitate interaction between host and guest:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The host can call functions implemented and exposed by the guest (known as &lt;em&gt;guest functions&lt;/em&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Once running, the guest can call functions implemented and exposed by the host (known as &lt;em&gt;host functions&lt;/em&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;By default, Hyperlight restricts guest access to a minimal API. The only &lt;em&gt;host function&lt;/em&gt; available by default allows the guest to print messages, which are displayed on the host console or redirected to stdout, as configured. Hosts can choose to expose additional host functions, expanding the guest’s capabilities as needed.&lt;/p&gt; &#xA;&lt;p&gt;Below is an example demonstrating the use of the Hyperlight host library in Rust to execute a simple guest application and an example of a simple guest application using the Hyperlight guest library in also written in Rust.&lt;/p&gt; &#xA;&lt;h3&gt;Host&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::{thread, sync::{Arc, Mutex}};&#xA;&#xA;use hyperlight_common::flatbuffer_wrappers::function_types::{ParameterValue, ReturnType};&#xA;use hyperlight_host::{UninitializedSandbox, MultiUseSandbox, func::HostFunction0, sandbox_state::transition::Noop, sandbox_state::sandbox::EvolvableSandbox};&#xA;&#xA;fn main() -&amp;gt; hyperlight_host::Result&amp;lt;()&amp;gt; {&#xA;    // Create an uninitialized sandbox with a guest binary&#xA;    let mut uninitialized_sandbox = UninitializedSandbox::new(&#xA;        hyperlight_host::GuestBinary::FilePath(hyperlight_testing::simple_guest_as_string().unwrap()),&#xA;        None, // default configuration&#xA;        None, // default run options&#xA;        None, // default host print function&#xA;    )?;&#xA;&#xA;    // Register a host function&#xA;    fn sleep_5_secs() -&amp;gt; hyperlight_host::Result&amp;lt;()&amp;gt; {&#xA;        thread::sleep(std::time::Duration::from_secs(5));&#xA;        Ok(())&#xA;    }&#xA;&#xA;    let host_function = Arc::new(Mutex::new(sleep_5_secs));&#xA;&#xA;    // Registering a host function makes it available to be called by the guest&#xA;    host_function.register(&amp;amp;mut uninitialized_sandbox, &#34;Sleep5Secs&#34;)?;&#xA;    // Note: This function is unused by the guest code below, it&#39;s just here for demonstration purposes&#xA;&#xA;    // Initialize sandbox to be able to call host functions&#xA;    let mut multi_use_sandbox: MultiUseSandbox = uninitialized_sandbox.evolve(Noop::default())?;&#xA;&#xA;    // Call a function in the guest&#xA;    let message = &#34;Hello, World! I am executing inside of a VM :)\n&#34;.to_string();&#xA;    // in order to call a function it first must be defined in the guest and exposed so that &#xA;    // the host can call it&#xA;    let result = multi_use_sandbox.call_guest_function_by_name(&#xA;        &#34;PrintOutput&#34;,&#xA;        ReturnType::Int,&#xA;        Some(vec![ParameterValue::String(message.clone())]),&#xA;    );&#xA;&#xA;    assert!(result.is_ok());&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Guest&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![no_std]&#xA;#![no_main]&#xA;extern crate alloc;&#xA;&#xA;use alloc::string::ToString;&#xA;use alloc::vec::Vec;&#xA;use hyperlight_common::flatbuffer_wrappers::function_call::FunctionCall;&#xA;use hyperlight_common::flatbuffer_wrappers::function_types::{&#xA;    ParameterType, ParameterValue, ReturnType,&#xA;};&#xA;use hyperlight_common::flatbuffer_wrappers::guest_error::ErrorCode;&#xA;use hyperlight_common::flatbuffer_wrappers::util::get_flatbuffer_result_from_int;&#xA;&#xA;use hyperlight_guest::error::{HyperlightGuestError, Result};&#xA;use hyperlight_guest::guest_function_definition::GuestFunctionDefinition;&#xA;use hyperlight_guest::guest_function_register::register_function;&#xA;use hyperlight_guest::host_function_call::{&#xA;    call_host_function, get_host_value_return_as_int,&#xA;};&#xA;&#xA;fn print_output(function_call: &amp;amp;FunctionCall) -&amp;gt; Result&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt; {&#xA;    if let ParameterValue::String(message) = function_call.parameters.clone().unwrap()[0].clone() {&#xA;        call_host_function(&#xA;            &#34;HostPrint&#34;,&#xA;            Some(Vec::from(&amp;amp;[ParameterValue::String(message.to_string())])),&#xA;            ReturnType::Int,&#xA;        )?;&#xA;        let result = get_host_value_return_as_int()?;&#xA;        Ok(get_flatbuffer_result_from_int(result))&#xA;    } else {&#xA;        Err(HyperlightGuestError::new(&#xA;            ErrorCode::GuestFunctionParameterTypeMismatch,&#xA;            &#34;Invalid parameters passed to simple_print_output&#34;.to_string(),&#xA;        ))&#xA;    }&#xA;}&#xA;&#xA;#[no_mangle]&#xA;pub extern &#34;C&#34; fn hyperlight_main() {&#xA;    let print_output_def = GuestFunctionDefinition::new(&#xA;        &#34;PrintOutput&#34;.to_string(),&#xA;        Vec::from(&amp;amp;[ParameterType::String]),&#xA;        ReturnType::Int,&#xA;        print_output as i64,&#xA;    );&#xA;    register_function(print_output_def);&#xA;}&#xA;&#xA;#[no_mangle]&#xA;pub fn guest_dispatch_function(function_call: FunctionCall) -&amp;gt; Result&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt; {&#xA;    let function_name = function_call.function_name.clone();&#xA;    return Err(HyperlightGuestError::new(&#xA;        ErrorCode::GuestFunctionNotFound,&#xA;        function_name,&#xA;    ));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For additional examples of using the Hyperlight host Rust library, see the &lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/hyperlight_host/examples&#34;&gt;./src/hyperlight_host/examples&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;For examples of guest applications, see the &lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/tests/c_guests&#34;&gt;./src/tests/c_guests&lt;/a&gt; directory for C guests and the &lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/tests/rust_guests&#34;&gt;./src/tests/rust_guests&lt;/a&gt; directory for Rust guests.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Hyperlight guests can be written using the Hyperlight Rust or C Guest libraries.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Repository Structure&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Hyperlight Host Libraries (i.e., the ones that create and manage the VMs)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/hyperlight_host&#34;&gt;src/hyperlight_host&lt;/a&gt; - This is the Rust Hyperlight host library.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Hyperlight Guest Libraries (i.e., the ones to make it easier to create guests that run inside the VMs)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/hyperlight_guest&#34;&gt;src/hyperlight_guest&lt;/a&gt; - This is the Rust Hyperlight guest library.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/hyperlight_guest_capi&#34;&gt;src/hyperlight_guest_capi&lt;/a&gt; - This is the C compatible wrapper for the Hyperlight guest library.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Hyperlight Common (functionality used by both the host and the guest)&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/hyperlight_common&#34;&gt;src/hyperlight_common&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Test Guest Applications:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/tests/rust_guests&#34;&gt;src/tests/rust_guests&lt;/a&gt; - This directory contains three Hyperlight Guest programs written in Rust, which are intended to be launched within partitions as &#34;guests&#34;.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/tests/c_guests&#34;&gt;src/tests/c_guests&lt;/a&gt; - This directory contains two Hyperlight Guest programs written in C, which are intended to be launched within partitions as &#34;guests&#34;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Tests:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/src/hyperlight_testing&#34;&gt;src/hyperlight-testing&lt;/a&gt; - Shared testing code for Hyperlight projects built in Rust.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Try it yourself!&lt;/h2&gt; &#xA;&lt;p&gt;You can run Hyperlight on:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://help.ubuntu.com/community/KVM/Installation&#34;&gt;Linux with KVM&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://devblogs.microsoft.com/visualstudio/hyper-v-android-emulator-support/#1-enable-hyper-v-and-the-windows-hypervisor-platform&#34;&gt;Windows with Windows Hypervisor Platform (WHP).&lt;/a&gt; - Note that you need Windows 11 / Windows Server 2022 or later to use hyperlight, if you are running on earlier versions of Windows then you should consider using our devcontainer on &lt;a href=&#34;(https://codespaces.new/hyperlight-dev/hyperlight)&#34;&gt;GitHub codespaces&lt;/a&gt; or WSL2.&lt;/li&gt; &#xA; &lt;li&gt;Windows Subsystem for Linux 2 (see instructions &lt;a href=&#34;https://learn.microsoft.com/en-us/windows/wsl/install&#34;&gt;here&lt;/a&gt; for Windows client and &lt;a href=&#34;https://learn.microsoft.com/en-us/windows/wsl/install-on-server&#34;&gt;here&lt;/a&gt; for Windows Server) with KVM.&lt;/li&gt; &#xA; &lt;li&gt;Azure Linux with mshv (note that you need mshv to be installed to use Hyperlight)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;After having an environment with a hypervisor setup, running the example has the following pre-requisites:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;On Linux or WSL, you&#39;ll most likely need build essential. For Ubuntu, run &lt;code&gt;sudo apt install build-essential&lt;/code&gt;. For Azure Linux, run &lt;code&gt;sudo dnf install build-essential&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Rust&lt;/a&gt;. Install toolchain v1.81 or later.&lt;/p&gt; &lt;p&gt;Also, install the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-none&lt;/code&gt; targets, these are needed to build the test guest binaries. (Note: install both targets on either Linux or Windows: Hyperlight can load ELF or PE files on either OS, and the tests/examples are built for both):&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rustup target add x86_64-unknown-none&#xA;rustup target add x86_64-pc-windows-msvc&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/casey/just&#34;&gt;just&lt;/a&gt;. &lt;code&gt;cargo install just&lt;/code&gt; On Windows you also need &lt;a href=&#34;https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.4&#34;&gt;pwsh&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://clang.llvm.org/get_started.html&#34;&gt;clang and LLVM&lt;/a&gt;.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;On Ubuntu, run:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://apt.llvm.org/llvm.sh&#xA;chmod +x ./llvm.sh&#xA;sudo ./llvm.sh 17 all&#xA;sudo ln -s /usr/lib/llvm-17/bin/clang-cl /usr/bin/clang-cl&#xA;sudo ln -s /usr/lib/llvm-17/bin/llvm-lib /usr/bin/llvm-lib&#xA;sudo ln -s /usr/lib/llvm-17/bin/lld-link /usr/bin/lld-link&#xA;sudo ln -s /usr/lib/llvm-17/bin/llvm-ml /usr/bin/llvm-ml&#xA;sudo ln -s /usr/lib/llvm-17/bin/ld.lld /usr/bin/ld.lld&#xA;sudo ln -s /usr/lib/llvm-17/bin/clang /usr/bin/clang&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;On Windows, see &lt;a href=&#34;https://learn.microsoft.com/en-us/cpp/build/clang-support-msbuild?view=msvc-170&#34;&gt;this&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;On Azure Linux, run:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo dnf remove clang -y || true&#xA;sudo dnf install clang17 -y&#xA;sudo dnf install clang17-tools-extra -y&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Then, we are ready to build and run the example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;just build  # build the Hyperlight library&#xA;just rg     # build the rust test guest binaries&#xA;cargo run --example hello-world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If all worked as expected, you should see the following message in your console:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Hello, World! I am executing inside of a VM :)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you get the error &lt;code&gt;Error: NoHypervisorFound&lt;/code&gt; and KVM or mshv is set up then this may be a permissions issue. In bash, you can use &lt;code&gt;ls -l /dev/kvm&lt;/code&gt; or &lt;code&gt;ls -l /dev/mshv&lt;/code&gt; to check which group owns that device and then &lt;code&gt;groups&lt;/code&gt; to make sure your user is a member of that group.&lt;/p&gt; &#xA;&lt;p&gt;For more details on how to verify that KVM is correctly installed and permissions are correct, follow the guide &lt;a href=&#34;https://help.ubuntu.com/community/KVM/Installation&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Or you can use a codespace&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://codespaces.new/hyperlight-dev/hyperlight&#34;&gt;&lt;img src=&#34;https://github.com/codespaces/badge.svg?sanitize=true&#34; alt=&#34;Open in GitHub Codespaces&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing to Hyperlight&lt;/h2&gt; &#xA;&lt;p&gt;If you are interested in contributing to Hyperlight, running the entire test-suite is a good way to get started. To do so, on your console, run the following commands:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;just guests  # build the c and rust test guests&#xA;just build  # build the Hyperlight library&#xA;just test # runs the tests&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Also , please review the &lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; file for more information on how to contribute to Hyperlight.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: For general Hyperlight development, you may also need flatc (Flatbuffer compiler): for instructions, see &lt;a href=&#34;https://github.com/google/flatbuffers&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Join our Community Meetings&lt;/h2&gt; &#xA;&lt;p&gt;This project holds fortnightly community meetings to discuss the project&#39;s progress, roadmap, and any other topics of interest. The meetings are open to everyone, and we encourage you to join us.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;When&lt;/strong&gt;: Every other Wednesday 09:00 (PST/PDT) &lt;a href=&#34;https://dateful.com/convert/pst-pdt-pacific-time?t=09&#34;&gt;Convert to your local time&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Where&lt;/strong&gt;: Zoom! - Agenda and information on how to join can be found in the &lt;a href=&#34;https://hackmd.io/blCrncfOSEuqSbRVT9KYkg#Agenda&#34;&gt;Hyperlight Community Meeting Notes&lt;/a&gt;. Please log into hackmd to edit!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Chat with us on the CNCF Slack&lt;/h2&gt; &#xA;&lt;p&gt;The Hyperlight project Slack is hosted in the CNCF Slack #hyperlight. To join the Slack, &lt;a href=&#34;https://www.cncf.io/membership-faq/#how-do-i-join-cncfs-slack&#34;&gt;join the CNCF Slack&lt;/a&gt;, and join the #hyperlight channel.&lt;/p&gt; &#xA;&lt;h2&gt;More Information&lt;/h2&gt; &#xA;&lt;p&gt;For more information, please refer to our compilation of documents in the &lt;a href=&#34;https://raw.githubusercontent.com/hyperlight-dev/hyperlight/main/docs/README.md&#34;&gt;&lt;code&gt;docs/&lt;/code&gt; directory&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Code of Conduct&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/cncf/foundation/raw/main/code-of-conduct.md&#34;&gt;CNCF Code of Conduct&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>MystenLabs/walrus</title>
    <updated>2025-03-30T01:37:44Z</updated>
    <id>tag:github.com,2025-03-30:/MystenLabs/walrus</id>
    <link href="https://github.com/MystenLabs/walrus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A decentralized blob store using Sui for coordination and governance.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Walrus&lt;/h1&gt; &#xA;&lt;p&gt;A decentralized blob store using &lt;a href=&#34;https://github.com/MystenLabs/sui&#34;&gt;Sui&lt;/a&gt; for coordination and governance.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Our main documentation is available &lt;a href=&#34;https://docs.wal.app&#34;&gt;as a Walrus Site&lt;/a&gt; (see &lt;a href=&#34;https://docs.wal.app/walrus-sites/intro.html&#34;&gt;the documentation&lt;/a&gt; for further information on what this means) and on &lt;a href=&#34;https://mystenlabs.github.io/walrus&#34;&gt;GitHub Pages&lt;/a&gt;; it is generated using &lt;a href=&#34;https://rust-lang.github.io/mdBook/&#34;&gt;mdBook&lt;/a&gt; from source files in the &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/docs/book&#34;&gt;&lt;code&gt;docs/book&lt;/code&gt;&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;You can also build the documentation locally (assuming you have Rust installed):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo install mdbook mdbook-admonish mdbook-katex mdbook-linkcheck mdbook-tabs mdbook-templates --locked&#xA;mdbook serve&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After this, you can browse the documentation at &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There are some additional documentation resources:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Usage examples are available under &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/docs/examples/&#34;&gt;docs/examples&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Our encoding system, which we call &lt;em&gt;Red Stuff&lt;/em&gt;, is described in detail in &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/docs/red-stuff.md&#34;&gt;docs/red-stuff.md&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;All our code is covered by Rust docs. You can build these and open them in your web browser by running the following:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo doc --workspace --open # add `--no-deps` to prevent building docs of all dependencies&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Repository structure&lt;/h2&gt; &#xA;&lt;p&gt;This repository contains all Walrus-related code, tools, and documentation:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/contracts&#34;&gt;&lt;code&gt;contracts&lt;/code&gt;&lt;/a&gt; contains all smart contracts used by Walrus for coordination and governance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates&#34;&gt;&lt;code&gt;crates&lt;/code&gt;&lt;/a&gt; contains all Rust crates related to Walrus including binaries for storage nodes and clients. See &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/#rust-crates&#34;&gt;below&lt;/a&gt; for further information about those.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/docker&#34;&gt;&lt;code&gt;docker&lt;/code&gt;&lt;/a&gt; contains Dockerfiles and docker-compose setups for building and running Walrus.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/docs&#34;&gt;&lt;code&gt;docs&lt;/code&gt;&lt;/a&gt; contains high-level technical and design documentation about Walrus.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/scripts&#34;&gt;&lt;code&gt;scripts&lt;/code&gt;&lt;/a&gt; contains tools used for evaluating and testing the code. In particular, this contains a script to run a local testbed, see &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/CONTRIBUTING.md#run-a-local-walrus-testbed&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/setup&#34;&gt;&lt;code&gt;setup&lt;/code&gt;&lt;/a&gt; contains setup scripts and configuration files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/testnet-contracts&#34;&gt;&lt;code&gt;testnet-contracts&lt;/code&gt;&lt;/a&gt; contains the Walrus contracts deployed for Walrus Testnet. The object IDs of the published contracts are included in the &lt;code&gt;Move.lock&lt;/code&gt; files.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Rust crates&lt;/h3&gt; &#xA;&lt;p&gt;Our Rust code is split into several crates with different responsibilities. The main code for Walrus is contained in the following crates:&lt;/p&gt; &#xA;&lt;!-- markdownlint-disable proper-names --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-core/&#34;&gt;walrus-core&lt;/a&gt; contains core types and functionality, including encoding and authentication mechanisms.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-sdk/&#34;&gt;walrus-sdk&lt;/a&gt; contains (client) interactions with storage nodes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-service/&#34;&gt;walrus-service&lt;/a&gt; contains client and server functionality including the storage backend. This crate also contains all main binaries, in particular &lt;code&gt;walrus&lt;/code&gt; and &lt;code&gt;walrus-node&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-sui/&#34;&gt;walrus-sui&lt;/a&gt; contains all types and interactions with the Sui smart contracts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-utils/&#34;&gt;walrus-utils&lt;/a&gt; contains utility functions used in multiple crates.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The following crates contain additional tools that are not part of the main functionality of Walrus and more extensive tests:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/checkpoint-downloader/&#34;&gt;checkpoint-downloader&lt;/a&gt; contains code to download checkpoints from Sui RPC nodes and checkpoint buckets.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-e2e-tests/&#34;&gt;walrus-e2e-tests&lt;/a&gt; contains end-to-end tests, some of which are also run as simulation tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-orchestrator/&#34;&gt;walrus-orchestrator&lt;/a&gt; contains tools to deploy and benchmark distributed Walrus networks. This crate is not a default member of the workspace and therefore needs to be built explicitly by adding &lt;code&gt;-p walrus-orchestrator&lt;/code&gt; or &lt;code&gt;--workspace&lt;/code&gt; to the cargo commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-proc-macros/&#34;&gt;walrus-proc-macros&lt;/a&gt; contains procedural macros used in the other crates, notably to define simulation tests.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-proxy/&#34;&gt;walrus-proxy&lt;/a&gt; contains a metrics proxy that authenticates storage nodes and collects metrics from them. This crate is not a default member of the workspace and therefore needs to be built explicitly by adding &lt;code&gt;-p walrus-proxy&lt;/code&gt; or &lt;code&gt;--workspace&lt;/code&gt; to the cargo commands.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-simtest/&#34;&gt;walrus-simtest&lt;/a&gt; contains simulation tests to ensure that Walrus works correctly for all interleavings of concurrent operations and in the presence of crashes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-stress/&#34;&gt;walrus-stress&lt;/a&gt; contains a stress client, which is used to put load on storage nodes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/crates/walrus-test-utils/&#34;&gt;walrus-test-utils&lt;/a&gt; contains test macros and other utilities used in the other crates.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- markdownlint-enable proper-names --&gt; &#xA;&lt;h2&gt;Using the Walrus client&lt;/h2&gt; &#xA;&lt;p&gt;If you just want to use the Walrus Mainnet or Testnet, please follow the &lt;a href=&#34;https://docs.wal.app/usage/setup.html&#34;&gt;setup instructions in our documentation&lt;/a&gt;. Further information about the usage is also available in the &lt;a href=&#34;https://docs.wal.app/usage/interacting.html&#34;&gt;public documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you want to build the binary from source or run local tests, see the instructions &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/#building-from-source-and-testing&#34;&gt;below&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Hardware requirements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We assume that this code is executed on at least 32-bit hardware; concretely, we assume that a &lt;code&gt;u32&lt;/code&gt; can be converted safely into a &lt;code&gt;usize&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Servers are assumed to use a 64-bit architecture (or higher); concretely, &lt;code&gt;usize&lt;/code&gt; has at least 64 bits.&lt;/li&gt; &#xA; &lt;li&gt;Our encoding relies on vector instructions to be efficient. Our default builds assume AVX2 and SSSE3 support on x86 CPUs and Neon support on ARM CPUs. Walrus binaries can be built for CPUs without these features, but will be much slower.&lt;/li&gt; &#xA; &lt;li&gt;When a client is executed on a 32-bit architecture, it may panic for blobs above a certain size. Given sufficient physical memory (4 GiB), it is generally possible to encode or decode blobs smaller than 500 MiB on 32-bit architectures.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building from source and testing&lt;/h2&gt; &#xA;&lt;p&gt;To build Walrus you need to install Rust as described in the &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Rust documentation&lt;/a&gt;, and the correct Rust toolchain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rustup update &amp;amp;&amp;amp; rustup toolchain install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can build Walrus using Cargo:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo build # add `--release` for optimized builds&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can directly run a local build of the &lt;code&gt;walrus&lt;/code&gt; binary as &lt;code&gt;cargo run --bin walrus&lt;/code&gt;. Arguments and options can be specified after a &lt;code&gt;--&lt;/code&gt;, for example &lt;code&gt;cargo run --bin walrus -- store README.md --epochs 1&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can run our test suite by installing &lt;a href=&#34;https://nexte.st/&#34;&gt;nextest&lt;/a&gt;, and then calling &lt;code&gt;cargo nextest run&lt;/code&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/CONTRIBUTING.md#tests&#34;&gt;CONTRIBUTING.md&lt;/a&gt; for further details on our tests and instructions on how to run a local Walrus testbed.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;If you observe a bug or want to request a feature, please search for an existing &lt;a href=&#34;https://github.com/MystenLabs/walrus/issues&#34;&gt;issue&lt;/a&gt; on this topic and, if none exists, create a new one. If you would like to contribute code directly (which we highly appreciate), please familiarize yourself with our &lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/CONTRIBUTING.md&#34;&gt;contributing workflow&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the Apache License, Version 2.0 (&lt;a href=&#34;https://raw.githubusercontent.com/MystenLabs/walrus/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; or &lt;a href=&#34;https://www.apache.org/licenses/LICENSE-2.0&#34;&gt;https://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;).&lt;/p&gt;</summary>
  </entry>
</feed>