<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-12T01:35:38Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>anza-xyz/pinocchio</title>
    <updated>2025-07-12T01:35:38Z</updated>
    <id>tag:github.com,2025-07-12:/anza-xyz/pinocchio</id>
    <link href="https://github.com/anza-xyz/pinocchio" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Create Solana programs with no dependencies attached&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt; &lt;code&gt;pinocchio&lt;/code&gt; &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;400&#34; alt=&#34;Limestone&#34; src=&#34;https://github.com/user-attachments/assets/3a1894b4-403f-4c35-90aa-548e7672fe90&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; Create Solana programs with no dependencies attached. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/anza-xyz/pinocchio/actions/workflows/main.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/anza-xyz/pinocchio/main.yml?logo=GitHub&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/pinocchio&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/pinocchio?logo=rust&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;right&#34;&gt; &lt;i&gt;I&#39;ve got no dependencies&lt;/i&gt;&lt;br&gt; &lt;i&gt;To hold me down&lt;/i&gt;&lt;br&gt; &lt;i&gt;To make me fret&lt;/i&gt;&lt;br&gt; &lt;i&gt;Or make me frown&lt;/i&gt;&lt;br&gt; &lt;i&gt;I had dependencies&lt;/i&gt;&lt;br&gt; &lt;i&gt;But now I&#39;m free&lt;/i&gt;&lt;br&gt; &lt;i&gt;There are no dependencies on me&lt;/i&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;Pinocchio is a zero-dependency library to create Solana programs in Rust. It takes advantage of the way SVM loaders serialize the program input parameters into a byte array that is then passed to the program&#39;s entrypoint to define zero-copy types to read the input. Since the communication between a program and SVM loader — either at the first time the program is called or when one program invokes the instructions of another program — is done via a byte array, a program can define its own types. This completely eliminates the dependency on the &lt;code&gt;solana-program&lt;/code&gt; crate, which in turn mitigates dependency issues by having a crate specifically designed to create on-chain programs.&lt;/p&gt; &#xA;&lt;p&gt;As a result, Pinocchio can be used as a replacement for &lt;a href=&#34;https://crates.io/crates/solana-program&#34;&gt;&lt;code&gt;solana-program&lt;/code&gt;&lt;/a&gt; to write on-chain programs, which are optimized in terms of both compute units consumption and binary size.&lt;/p&gt; &#xA;&lt;p&gt;The library defines:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;program entrypoint&lt;/li&gt; &#xA; &lt;li&gt;core data types&lt;/li&gt; &#xA; &lt;li&gt;logging macros&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;syscall&lt;/code&gt; functions&lt;/li&gt; &#xA; &lt;li&gt;access to system accounts (&lt;code&gt;sysvars&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;cross-program invocation&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Zero dependencies and &lt;code&gt;no_std&lt;/code&gt; crate&lt;/li&gt; &#xA; &lt;li&gt;Efficient &lt;code&gt;entrypoint!&lt;/code&gt; macro – no copies or allocations&lt;/li&gt; &#xA; &lt;li&gt;Improved CU consumption of cross-program invocations&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;From your project folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo add pinocchio&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will add &lt;code&gt;pinocchio&lt;/code&gt; as a dependency to your project.&lt;/p&gt; &#xA;&lt;h2&gt;Defining the program entrypoint&lt;/h2&gt; &#xA;&lt;p&gt;A Solana program needs to define an entrypoint, which will be called by the runtime to begin the program execution. The &lt;code&gt;entrypoint!&lt;/code&gt; macro emits the common boilerplate to set up the program entrypoint. The macro will also set up &lt;a href=&#34;https://doc.rust-lang.org/stable/core/alloc/trait.GlobalAlloc.html&#34;&gt;global allocator&lt;/a&gt; and &lt;a href=&#34;https://github.com/anza-xyz/rust/raw/2830febbc59d44bdd7ad2c3b81731f1d08b96eba/library/std/src/sys/pal/sbf/mod.rs#L49&#34;&gt;custom panic hook&lt;/a&gt; using the &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.default_allocator.html&#34;&gt;default_allocator!&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.default_panic_handler.html&#34;&gt;default_panic_handler!&lt;/a&gt; macros.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.entrypoint.html&#34;&gt;&lt;code&gt;entrypoint!&lt;/code&gt;&lt;/a&gt; is a convenience macro that invokes three other macros to set all symbols required for a program execution:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.program_entrypoint.html&#34;&gt;&lt;code&gt;program_entrypoint!&lt;/code&gt;&lt;/a&gt;: declares the program entrypoint&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.default_allocator.html&#34;&gt;&lt;code&gt;default_allocator!&lt;/code&gt;&lt;/a&gt;: declares the default (bump) global allocator&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.default_panic_handler.html&#34;&gt;&lt;code&gt;default_panic_handler!&lt;/code&gt;&lt;/a&gt;: declares the default panic handler&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;If all dependencies are &lt;code&gt;no_std&lt;/code&gt;, you should append &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.nostd_panic_handler.html&#34;&gt;&lt;code&gt;nostd_panic_handler!&lt;/code&gt;&lt;/a&gt; to declare a rust runtime panic handler. There&#39;s no need to do this if any dependency is &lt;code&gt;std&lt;/code&gt; since rust compiler will emit std panic handler.&lt;/p&gt; &#xA;&lt;p&gt;To use the &lt;code&gt;entrypoint!&lt;/code&gt; macro, use the following in your entrypoint definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use pinocchio::{&#xA;  account_info::AccountInfo,&#xA;  entrypoint,&#xA;  msg,&#xA;  ProgramResult,&#xA;  pubkey::Pubkey&#xA;};&#xA;&#xA;entrypoint!(process_instruction);&#xA;&#xA;pub fn process_instruction(&#xA;  program_id: &amp;amp;Pubkey,&#xA;  accounts: &amp;amp;[AccountInfo],&#xA;  instruction_data: &amp;amp;[u8],&#xA;) -&amp;gt; ProgramResult {&#xA;  msg!(&#34;Hello from my program!&#34;);&#xA;  Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The information from the input is parsed into their own entities:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;program_id&lt;/code&gt;: the &lt;code&gt;ID&lt;/code&gt; of the program being called&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;accounts&lt;/code&gt;: the accounts received&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;instruction_data&lt;/code&gt;: data for the instruction&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;code&gt;pinocchio&lt;/code&gt; also offers variations of the program entrypoint (&lt;code&gt;lazy_program_allocator&lt;/code&gt;) and global allocator (&lt;code&gt;no_allocator&lt;/code&gt;). In order to use these, the program needs to specify the program entrypoint, global allocator and panic handler individually. The &lt;code&gt;entrypoint!&lt;/code&gt; macro is equivalent to writing:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;program_entrypoint!(process_instruction);&#xA;default_allocator!();&#xA;default_panic_handler!();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Any of these macros can be replaced by other implementations and &lt;code&gt;pinocchio&lt;/code&gt; offers a couple of variants for this.&lt;/p&gt; &#xA;&lt;p&gt;📌 &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.lazy_program_entrypoint.html&#34;&gt;&lt;code&gt;lazy_program_entrypoint!&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;entrypoint!&lt;/code&gt; macro looks similar to the &#34;standard&#34; one found in &lt;code&gt;solana-program&lt;/code&gt;. It parses the whole input and provides the &lt;code&gt;program_id&lt;/code&gt;, &lt;code&gt;accounts&lt;/code&gt; and &lt;code&gt;instruction_data&lt;/code&gt; separately. This consumes compute units before the program begins its execution. In some cases, it is beneficial for a program to have more control when the input parsing is happening, even whether the parsing is needed or not — this is the purpose of the &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.lazy_program_entrypoint.html&#34;&gt;&lt;code&gt;lazy_program_entrypoint!&lt;/code&gt;&lt;/a&gt; macro. This macro only wraps the program input and provides methods to parse the input on demand.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;lazy_entrypoint&lt;/code&gt; is suitable for programs that have a single or very few instructions, since it requires the program to handle the parsing, which can become complex as the number of instructions increases. For &lt;em&gt;larger&lt;/em&gt; programs, the &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.program_entrypoint.html&#34;&gt;&lt;code&gt;program_entrypoint!&lt;/code&gt;&lt;/a&gt; will likely be easier and more efficient to use.&lt;/p&gt; &#xA;&lt;p&gt;To use the &lt;code&gt;lazy_program_entrypoint!&lt;/code&gt; macro, use the following in your entrypoint definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use pinocchio::{&#xA;  default_allocator,&#xA;  default_panic_handler,&#xA;  entrypoint::InstructionContext,&#xA;  lazy_program_entrypoint,&#xA;  msg,&#xA;  ProgramResult&#xA;};&#xA;&#xA;lazy_program_entrypoint!(process_instruction);&#xA;default_allocator!();&#xA;default_panic_handler!();&#xA;&#xA;pub fn process_instruction(&#xA;  mut context: InstructionContext&#xA;) -&amp;gt; ProgramResult {&#xA;    msg!(&#34;Hello from my lazy program!&#34;);&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;InstructionContext&lt;/code&gt; provides on-demand access to the information of the input:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;remaining()&lt;/code&gt;: number of remaining accounts to be parsed&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;next_account()&lt;/code&gt;: parsers the next available account (can be used as many times as accounts remaining)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;instruction_data()&lt;/code&gt;: parsers the instruction data&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;program_id()&lt;/code&gt;: parsers the program id&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ &lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;lazy_program_entrypoint!&lt;/code&gt; does not set up a global allocator nor a panic handler. A program should explicitly use one of the provided macros to set them up or include its own implementation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;📌 &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.no_allocator.html&#34;&gt;&lt;code&gt;no_allocator!&lt;/code&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;When writing programs, it can be useful to make sure the program does not attempt to make any allocations. For this cases, &lt;code&gt;pinocchio&lt;/code&gt; includes a &lt;a href=&#34;https://docs.rs/pinocchio/latest/pinocchio/macro.no_allocator.html&#34;&gt;&lt;code&gt;no_allocator!&lt;/code&gt;&lt;/a&gt; macro that sets a global allocator just panics at any attempt to allocate memory.&lt;/p&gt; &#xA;&lt;p&gt;To use the &lt;code&gt;no_allocator!&lt;/code&gt; macro, use the following in your entrypoint definition:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use pinocchio::{&#xA;  account_info::AccountInfo,&#xA;  default_panic_handler,&#xA;  msg,&#xA;  no_allocator,&#xA;  program_entrypoint,&#xA;  ProgramResult,&#xA;  pubkey::Pubkey&#xA;};&#xA;&#xA;program_entrypoint!(process_instruction);&#xA;default_panic_handler!();&#xA;no_allocator!();&#xA;&#xA;pub fn process_instruction(&#xA;  program_id: &amp;amp;Pubkey,&#xA;  accounts: &amp;amp;[AccountInfo],&#xA;  instruction_data: &amp;amp;[u8],&#xA;) -&amp;gt; ProgramResult {&#xA;  msg!(&#34;Hello from `no_std` program!&#34;);&#xA;  Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;⚠️ &lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;no_allocator!&lt;/code&gt; macro can also be used in combination with the &lt;code&gt;lazy_program_entrypoint!&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Crate feature: &lt;code&gt;std&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;pinocchio&lt;/code&gt; is a &lt;code&gt;no_std&lt;/code&gt; crate. This means that it does not use any code from the standard (&lt;code&gt;std&lt;/code&gt;) library. While this does not affect how &lt;code&gt;pinocchio&lt;/code&gt; is used, there is one particular apparent difference. In a &lt;code&gt;no_std&lt;/code&gt; environment, the &lt;code&gt;msg!&lt;/code&gt; macro does not provide any formatting options since the &lt;code&gt;format!&lt;/code&gt; macro requires the &lt;code&gt;std&lt;/code&gt; library. In order to use &lt;code&gt;msg!&lt;/code&gt; with formatting, the &lt;code&gt;std&lt;/code&gt; feature should be enabled when adding &lt;code&gt;pinocchio&lt;/code&gt; as a dependency:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pinocchio = { version = &#34;0.7.0&#34;, features = [&#34;std&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Instead of enabling the &lt;code&gt;std&lt;/code&gt; feature to be able to format log messages with &lt;code&gt;msg!&lt;/code&gt;, it is recommended to use the &lt;a href=&#34;https://crates.io/crates/pinocchio-log&#34;&gt;&lt;code&gt;pinocchio-log&lt;/code&gt;&lt;/a&gt; crate. This crate provides a lightweight &lt;code&gt;log!&lt;/code&gt; macro with better compute units consumption than the standard &lt;code&gt;format!&lt;/code&gt; macro without requiring the &lt;code&gt;std&lt;/code&gt; library.&lt;/p&gt; &#xA;&lt;h2&gt;Advance entrypoint configuration&lt;/h2&gt; &#xA;&lt;p&gt;The symbols emitted by the entrypoint macros — program entrypoint, global allocator and default panic handler — can only be defined once globally. If the program crate is also intended to be used as a library, it is common practice to define a Cargo &lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/features.html&#34;&gt;feature&lt;/a&gt; in your program crate to conditionally enable the module that includes the &lt;code&gt;entrypoint!&lt;/code&gt; macro invocation. The convention is to name the feature &lt;code&gt;bpf-entrypoint&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[cfg(feature = &#34;bpf-entrypoint&#34;)]&#xA;mod entrypoint {&#xA;  use pinocchio::{&#xA;    account_info::AccountInfo,&#xA;    entrypoint,&#xA;    msg,&#xA;    ProgramResult,&#xA;    pubkey::Pubkey&#xA;  };&#xA;&#xA;  entrypoint!(process_instruction);&#xA;&#xA;  pub fn process_instruction(&#xA;    program_id: &amp;amp;Pubkey,&#xA;    accounts: &amp;amp;[AccountInfo],&#xA;    instruction_data: &amp;amp;[u8],&#xA;  ) -&amp;gt; ProgramResult {&#xA;    msg!(&#34;Hello from my program!&#34;);&#xA;    Ok(())&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When building the program binary, you must enable the &lt;code&gt;bpf-entrypoint&lt;/code&gt; feature:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo build-sbf --features bpf-entrypoint&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;The code is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/anza-xyz/pinocchio/main/LICENSE&#34;&gt;Apache License Version 2.0&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The library in this repository is based/includes code from:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nifty-oss/nitrate&#34;&gt;&lt;code&gt;nitrate&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/cavemanloverboy/solana-nostd-entrypoint/tree/main&#34;&gt;&lt;code&gt;solana-nostd-entrypoint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/anza-xyz/solana-sdk&#34;&gt;&lt;code&gt;solana-sdk&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>