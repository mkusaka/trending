<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-10-15T01:36:51Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>katanemo/arch</title>
    <updated>2024-10-15T01:36:51Z</updated>
    <id>tag:github.com,2024-10-15:/katanemo/arch</id>
    <link href="https://github.com/katanemo/arch" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Arch is an intelligent prompt gateway. Engineered with (fast) LLMs for the secure handling, robust observability, and seamless integration of prompts with APIs - all outside business logic. Built by the core contributors of Envoy proxy, on Envoy.&lt;/p&gt;&lt;hr&gt;&lt;p&gt; &lt;img src=&#34;https://raw.githubusercontent.com/katanemo/arch/main/docs/source/_static/img/arch-logo.png&#34; alt=&#34;Arch Gateway Logo&#34; title=&#34;Arch Gateway Logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Build fast, robust, and personalized AI agents.&lt;/h2&gt; &#xA;&lt;p&gt;Arch is an intelligent &lt;a href=&#34;https://www.cloudflare.com/learning/ddos/what-is-layer-7/&#34;&gt;Layer 7&lt;/a&gt; gateway designed to protect, observe, and personalize LLM applications (agents, assistants, co-pilots) with your APIs.&lt;/p&gt; &#xA;&lt;p&gt;Engineered with purpose-built LLMs, Arch handles the critical but undifferentiated tasks related to the handling and processing of prompts, including detecting and rejecting &lt;a href=&#34;https://github.com/verazuo/jailbreak_llms&#34;&gt;jailbreak&lt;/a&gt; attempts, intelligently calling &#34;backend&#34; APIs to fulfill the user&#39;s request represented in a prompt, routing to and offering disaster recovery between upstream LLMs, and managing the observability of prompts and LLM interactions in a centralized way.&lt;/p&gt; &#xA;&lt;p&gt;Arch is built on (and by the core contributors of) &lt;a href=&#34;https://www.envoyproxy.io/&#34;&gt;Envoy Proxy&lt;/a&gt; with the belief that:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Prompts are nuanced and opaque user requests, which require the same capabilities as traditional HTTP requests including secure handling, intelligent routing, robust observability, and integration with backend (API) systems for personalization â€“ all outside business logic.*&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;strong&gt;Core Features&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Built on &lt;a href=&#34;https://envoyproxy.io&#34;&gt;Envoy&lt;/a&gt;: Arch runs alongside application servers, and builds on top of Envoy&#39;s proven HTTP management and scalability features to handle ingress and egress traffic related to prompts and LLMs.&lt;/li&gt; &#xA; &lt;li&gt;Function Calling for fast Agentic and RAG apps. Engineered with purpose-built &lt;a href=&#34;https://huggingface.co/collections/katanemo/arch-function-66f209a693ea8df14317ad68&#34;&gt;LLMs&lt;/a&gt; to handle fast, cost-effective, and accurate prompt-based tasks like function/API calling, and parameter extraction from prompts.&lt;/li&gt; &#xA; &lt;li&gt;Prompt &lt;a href=&#34;https://huggingface.co/collections/katanemo/arch-guard-6702bdc08b889e4bce8f446d&#34;&gt;Guard&lt;/a&gt;: Arch centralizes prompt guardrails to prevent jailbreak attempts and ensure safe user interactions without writing a single line of code.&lt;/li&gt; &#xA; &lt;li&gt;Traffic Management: Arch manages LLM calls, offering smart retries, automatic cutover, and resilient upstream connections for continuous availability.&lt;/li&gt; &#xA; &lt;li&gt;Standards-based Observability: Arch uses the W3C Trace Context standard to enable complete request tracing across applications, ensuring compatibility with observability tools, and provides metrics to monitor latency, token usage, and error rates, helping optimize AI application performance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Jump to our &lt;a href=&#34;https://docs.archgw.com&#34;&gt;docs&lt;/a&gt;&lt;/strong&gt; to learn how you can use Arch to improve the speed, security and personalization of your GenAI apps.&lt;/p&gt; &#xA;&lt;h2&gt;Contact&lt;/h2&gt; &#xA;&lt;p&gt;To get in touch with us, please join our &lt;a href=&#34;https://discord.gg/rSRQ9fv7&#34;&gt;discord server&lt;/a&gt;. We will be monitoring that actively and offering support there.&lt;/p&gt; &#xA;&lt;h2&gt;Demos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/katanemo/arch/main/demos/function_calling/README.md&#34;&gt;Function Calling&lt;/a&gt; - Walk through of critical function calling capabilities&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/katanemo/arch/main/demos/insurance_agent/README.md&#34;&gt;Insurance Agent&lt;/a&gt; - Build a full insurance agent with arch&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/katanemo/arch/main/demos/network_agent/README.md&#34;&gt;Network Agent&lt;/a&gt; - Build a networking co-pilot/agent agent with arch&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Follow this guide to learn how to quickly set up Arch and integrate it into your generative AI applications.&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;p&gt;Before you begin, ensure you have the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;Docker&lt;/code&gt; &amp;amp; &lt;code&gt;Python&lt;/code&gt; installed on your system&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;API Keys&lt;/code&gt; for LLM providers (if using external LLMs)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Step 1: Install Arch&lt;/h3&gt; &#xA;&lt;p&gt;Arch&#39;s CLI allows you to manage and interact with the Arch gateway efficiently. To install the CLI, simply run the following command: Tip: We recommend that developers create a new Python virtual environment to isolate dependencies before installing Arch. This ensures that archgw and its dependencies do not interfere with other packages on your system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ python -m venv venv&#xA;$ source venv/bin/activate   # On Windows, use: venv\Scripts\activate&#xA;$ pip install archgw&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 2: Configure Arch with your application&lt;/h3&gt; &#xA;&lt;p&gt;Arch operates based on a configuration file where you can define LLM providers, prompt targets, guardrails, etc. Below is an example configuration to get you started:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: v0.1&#xA;&#xA;listen:&#xA;  address: 0.0.0.0 # or 127.0.0.1&#xA;  port: 10000&#xA;  # Defines how Arch should parse the content from application/json or text/pain Content-type in the http request&#xA;  message_format: huggingface&#xA;&#xA;# Centralized way to manage LLMs, manage keys, retry logic, failover and limits in a central way&#xA;llm_providers:&#xA;  - name: OpenAI&#xA;    provider: openai&#xA;    access_key: OPENAI_API_KEY&#xA;    model: gpt-4o&#xA;    default: true&#xA;    stream: true&#xA;&#xA;# default system prompt used by all prompt targets&#xA;system_prompt: You are a network assistant that just offers facts; not advice on manufacturers or purchasing decisions.&#xA;&#xA;prompt_targets:&#xA;  - name: reboot_devices&#xA;    description: Reboot specific devices or device groups&#xA;&#xA;    path: /agent/device_reboot&#xA;    parameters:&#xA;      - name: device_ids&#xA;        type: list&#xA;        description: A list of device identifiers (IDs) to reboot.&#xA;        required: false&#xA;      - name: device_group&#xA;        type: str&#xA;        description: The name of the device group to reboot&#xA;        required: false&#xA;&#xA;# Arch creates a round-robin load balancing between different endpoints, managed via the cluster subsystem.&#xA;endpoints:&#xA;  app_server:&#xA;    # value could be ip address or a hostname with port&#xA;    # this could also be a list of endpoints for load balancing&#xA;    # for example endpoint: [ ip1:port, ip2:port ]&#xA;    endpoint: 127.0.0.1:80&#xA;    # max time to wait for a connection to be established&#xA;    connect_timeout: 0.005s&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 3: Using OpenAI Client with Arch as an Egress Gateway&lt;/h3&gt; &#xA;&lt;p&gt;Make outbound calls via Arch&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import openai&#xA;&#xA;# Set the OpenAI API base URL to the Arch gateway endpoint&#xA;openai.api_base = &#34;http://127.0.0.1:51001/v1&#34;&#xA;&#xA;# No need to set openai.api_key since it&#39;s configured in Arch&#39;s gateway&#xA;&#xA;# Use the OpenAI client as usual&#xA;response = openai.Completion.create(&#xA;   model=&#34;text-davinci-003&#34;,&#xA;   prompt=&#34;What is the capital of France?&#34;&#xA;)&#xA;&#xA;print(&#34;OpenAI Response:&#34;, response.choices[0].text.strip())&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://docs.archgw.com/guides/observability/observability.html&#34;&gt;Observability&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Arch is designed to support best-in class observability by supporting open standards. Please read our &lt;a href=&#34;https://docs.archgw.com/guides/observability/observability.html&#34;&gt;docs&lt;/a&gt; on observability for more details on tracing, metrics, and logs&lt;/p&gt; &#xA;&lt;h3&gt;Contribution&lt;/h3&gt; &#xA;&lt;p&gt;We would love feedback on our &lt;a href=&#34;https://github.com/orgs/katanemo/projects/1&#34;&gt;Roadmap&lt;/a&gt; and we welcome contributions to &lt;strong&gt;Arch&lt;/strong&gt;! Whether you&#39;re fixing bugs, adding new features, improving documentation, or creating tutorials, your help is much appreciated. Please vist our &lt;a href=&#34;https://raw.githubusercontent.com/katanemo/arch/main/arch/CONTRIBUTING.md&#34;&gt;Contribution Guide&lt;/a&gt; for more details&lt;/p&gt;</summary>
  </entry>
</feed>