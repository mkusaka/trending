<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-01-11T01:41:58Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>blahgeek/emacs-lsp-booster</title>
    <updated>2024-01-11T01:41:58Z</updated>
    <id>tag:github.com,2024-01-11:/blahgeek/emacs-lsp-booster</id>
    <link href="https://github.com/blahgeek/emacs-lsp-booster" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Emacs LSP performance booster&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Emacs LSP performance booster&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/blahgeek/emacs-lsp-booster/actions/workflows/build-test.yml/badge.svg?sanitize=true&#34; alt=&#34;Build and test status&#34;&gt; &lt;img src=&#34;https://github.com/blahgeek/emacs-lsp-booster/actions/workflows/release.yml/badge.svg?sanitize=true&#34; alt=&#34;Release status&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Improve the performance of &lt;a href=&#34;https://github.com/emacs-lsp/lsp-mode&#34;&gt;lsp-mode&lt;/a&gt; or &lt;a href=&#34;https://github.com/joaotavora/eglot&#34;&gt;eglot&lt;/a&gt; using a wrapper executable.&lt;/p&gt; &#xA;&lt;h2&gt;Background &amp;amp; Prior work&lt;/h2&gt; &#xA;&lt;p&gt;(Huge thanks to @yyoncho for both maintaining lsp-mode and giving me the inspiration of this project).&lt;/p&gt; &#xA;&lt;p&gt;According to &lt;a href=&#34;https://www.reddit.com/r/emacs/comments/ymrkyn/comment/iv90q4i/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3&#34;&gt;yyoncho&lt;/a&gt;, the are several performance issues related to lsp-mode (mostly the same for eglot):&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Json parsing in Emacs is slow&lt;/li&gt; &#xA; &lt;li&gt;The server may block on sending data to emacs when the buffer is full, because Emacs is consuming the data too slowly&lt;/li&gt; &#xA; &lt;li&gt;Similarly, Emacs may block while attempting to send data to the server (hence blocking the Emacs UI), because the server may be busy&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;@yyoncho tried to solve these issues by implementing a &lt;a href=&#34;https://github.com/emacs-lsp/emacs&#34;&gt;native async non-blocking jsonrpc&lt;/a&gt; fork of emacs. The result is very good regarding performance. However, it requires modifications in the Emacs source code and it seems unlikely that those changes could be merged upstream. Also, it could prove difficult to maintain, since it also requires a separate code path in lsp-mode (I myself encountered some &lt;a href=&#34;https://github.com/emacs-lsp/emacs/issues/12&#34;&gt;issues&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;h2&gt;How this project works&lt;/h2&gt; &#xA;&lt;p&gt;This project provides a wrapper-executable around lsp server programs, to work around the above-mentioned issues:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It converts json messages from the server at high speed directly into &lt;strong&gt;elisp bytecode&lt;/strong&gt; (in text representation) for Emacs to read. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;e.g. &lt;code&gt;{&#34;objs&#34;:[{&#34;a&#34;:1},{&#34;a&#34;:2}]}&lt;/code&gt; would be converted to &lt;code&gt;#[0 &#34;\301\302\300\303D\300\304D\&#34;D\207&#34; [:a :objs vector 1 2] 13]&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;This improves the message parsing performance in Emacs by ~4x for large json objects; see benchmark result &lt;a href=&#34;https://github.com/blahgeek/emacs-lsp-booster/actions/runs/7416840025/job/20182439682#step:5:142&#34;&gt;here&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Although Emacs still needs to parse the text representation and interpret it into elisp objects, the performance gain mainly comes from the following: &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Parsing (&lt;code&gt;read&lt;/code&gt;ing) elisp object is apparently better optimized and simpler in Emacs&lt;/li&gt; &#xA;     &lt;li&gt;By using bytecode to construct objects, we can eliminate duplicated objects (e.g. the &#34;a&#34; json key in above example)&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;It separates reading and writing into different threads and keeps pending messages in internal buffers within each thread, to avoid blocking on IO. This solves issues (2) and (3) mentioned above.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Overall, this &lt;em&gt;lsp server wrapper&lt;/em&gt; strategy achieves similar result as the native async non-blocking jsonrpc approach without requiring modifications in Emacs source code.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!IMPORTANT]&lt;br&gt; At present only local lsp server programs which communicate by standard input/output can be wrapped, not servers communicating over network ports (local or remote).&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;Generally, what you need to do is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Wrap your lsp server command with this &lt;code&gt;emacs-lsp-booster&lt;/code&gt; executable. For example, if the original lsp server command is &lt;code&gt;pyright-langserver --stdio&lt;/code&gt;, configure lsp-mode or eglot to run &lt;code&gt;emacs-lsp-booster [flags --] pyright-langserver --stdio&lt;/code&gt; instead.&lt;/li&gt; &#xA; &lt;li&gt;Advise or update the json parsing function in &lt;code&gt;lsp-mode&lt;/code&gt; or &lt;code&gt;eglot&lt;/code&gt; to parse any bytecode input seen, prior to parsing it as json.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;See more detailed configuration steps below.&lt;/p&gt; &#xA;&lt;h3&gt;Obtain or build &lt;code&gt;emacs-lsp-booster&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;For linux users, you may download the prebuilt binary from &lt;a href=&#34;https://github.com/blahgeek/emacs-lsp-booster/releases&#34;&gt;release&lt;/a&gt;. &lt;em&gt;(The macOS binary in the release page lacks proper code signing for now.)&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you may build the target locally:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Setup &lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Rust toolchain&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;cargo build --release&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Find the built binary in &lt;code&gt;target/release/emacs-lsp-booster&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Then, put the &lt;code&gt;emacs-lsp-booster&lt;/code&gt; binary in your $PATH (e.g. &lt;code&gt;~/.local/bin&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;h3&gt;Configure &lt;code&gt;lsp-mode&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;[!NOTE]&lt;br&gt; Make sure NOT to use the &lt;a href=&#34;https://github.com/emacs-lsp/emacs&#34;&gt;native-jsonrpc custom version&lt;/a&gt; of Emacs&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Use &lt;a href=&#34;https://emacs-lsp.github.io/lsp-mode/page/performance/#use-plists-for-deserialization&#34;&gt;plist for deserialization&lt;/a&gt; for lsp-mode&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;Add the following code to your &lt;code&gt;init.el&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-elisp&#34;&gt;(defun lsp-booster--advice-json-parse (old-fn &amp;amp;rest args)&#xA;  &#34;Try to parse bytecode instead of json.&#34;&#xA;  (or&#xA;   (when (equal (following-char) ?#)&#xA;     (let ((bytecode (read (current-buffer))))&#xA;       (when (byte-code-function-p bytecode)&#xA;         (funcall bytecode))))&#xA;   (apply old-fn args)))&#xA;(advice-add (if (progn (require &#39;json)&#xA;                       (fboundp &#39;json-parse-buffer))&#xA;                &#39;json-parse-buffer&#xA;              &#39;json-read)&#xA;            :around&#xA;            #&#39;lsp-booster--advice-json-parse)&#xA;&#xA;(defun lsp-booster--advice-final-command (old-fn cmd &amp;amp;optional test?)&#xA;  &#34;Prepend emacs-lsp-booster command to lsp CMD.&#34;&#xA;  (let ((orig-result (funcall old-fn cmd test?)))&#xA;    (if (and (not test?)                             ;; for check lsp-server-present?&#xA;             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper&#xA;             lsp-use-plists&#xA;             (not (functionp &#39;json-rpc-connection))  ;; native json-rpc&#xA;             (executable-find &#34;emacs-lsp-booster&#34;))&#xA;        (progn&#xA;          (message &#34;Using emacs-lsp-booster for %s!&#34; orig-result)&#xA;          (cons &#34;emacs-lsp-booster&#34; orig-result))&#xA;      orig-result)))&#xA;(advice-add &#39;lsp-resolve-final-command :around #&#39;lsp-booster--advice-final-command)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Done! Now try to use lsp-mode as usual.&lt;/p&gt; &#xA;&lt;h3&gt;Configure &lt;code&gt;eglot&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/blahgeek/emacs-lsp-booster/issues/1&#34;&gt;https://github.com/blahgeek/emacs-lsp-booster/issues/1&lt;/a&gt; for information on configuring &lt;code&gt;eglot&lt;/code&gt;. Huge thanks to @jdtsmith&lt;/p&gt; &#xA;&lt;h3&gt;How to verify it&#39;s working&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Check that &lt;code&gt;emacs-lsp-booster&lt;/code&gt; process is running&lt;/li&gt; &#xA; &lt;li&gt;Check the stderr buffer (e.g. for lsp-mode, &lt;code&gt;*pyright::stderr*&lt;/code&gt; buffer; for eglot, the &lt;code&gt; EGLOT (...) stderr*&lt;/code&gt; buffer, note the leading space); it should contain &lt;code&gt;emacs_lsp_booster&lt;/code&gt; related log.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Advanced usage&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;emacs-lsp-booster --help&lt;/code&gt; for more options.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>moturus/motor-os</title>
    <updated>2024-01-11T01:41:58Z</updated>
    <id>tag:github.com,2024-01-11:/moturus/motor-os</id>
    <link href="https://github.com/moturus/motor-os" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;MotÅ«rus OS&lt;/h1&gt; &#xA;&lt;p&gt;MotÅ«rus project builds a simple, fast, and secure operating system (MotÅ«rus OS) for the cloud.&lt;/p&gt; &#xA;&lt;p&gt;In more specific terms, MotÅ«rus OS (sometimes called Motor OS), is a new operating system targeting virtual machine-based workloads such as web serving, &#34;serverless&#34;, edge caching, etc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/moturus/motor-os/main/docs/screenshot.md&#34;&gt;Screenshot&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why?&lt;/h2&gt; &#xA;&lt;p&gt;At the moment, most virtualized production workloads run Linux. While Linux has many advanced features that in many situations mean it is the only reasonable OS choice, there are several complications that make it not ideal, in theory, for some virtualized workloads:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux is optimized for baremetal, which leads to inefficiencies when it is used inside a VM that is running on a Linux host: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;duplicate block caches&lt;/li&gt; &#xA;   &lt;li&gt;duplicate page table walks&lt;/li&gt; &#xA;   &lt;li&gt;the host scheduler can preempt the VCPU holding a spinlock in the VM&#39;s kernel&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Linux is difficult to use: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Docker, Nix OS, &#34;serverless&#34;, etc. all exist because of Linux&#39;s complexity&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Linux has, historically, not been very secure&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A new operating system built from ground-up with the focus on virtualized workloads can be made much simpler and more secure than Linux, while matching or exceeding its performance and/or efficiency.&lt;/p&gt; &#xA;&lt;h2&gt;What?&lt;/h2&gt; &#xA;&lt;p&gt;MotÅ«rus OS is a microkernel-based operating system, built in Rust, that targets virtualized workloads exclusively. It currently supports x64 KVM-based virtual machines, and can run in either Qemu or Cloud Hypervisor.&lt;/p&gt; &#xA;&lt;p&gt;Rust is &lt;em&gt;the&lt;/em&gt; language of MotÅ«rus OS: not only it is implemented in Rust, it also exposes its ABI in Rust, not C.&lt;/p&gt; &#xA;&lt;h3&gt;What works&lt;/h3&gt; &#xA;&lt;p&gt;While at the moment most of the subsystems are working in only POC/MVP mode, they &lt;strong&gt;are&lt;/strong&gt; working, and you can run, say, a web server.&lt;/p&gt; &#xA;&lt;p&gt;More specifically, these things work:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;boots via MBR (Qemu) or PVH (Cloud Hypervisor) in about 200ms&lt;/li&gt; &#xA; &lt;li&gt;himem micro-kernel&lt;/li&gt; &#xA; &lt;li&gt;scheduling: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;a simple multi-processor round robin (SMP)&lt;/li&gt; &#xA;   &lt;li&gt;in-kernel scheduling is cooperative &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;the kernel is very small and does not block, so does not need to be preemptible&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;the userspace is preemptible&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;memory management: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;only 4K pages at the moment&lt;/li&gt; &#xA;   &lt;li&gt;stacks are guarded&lt;/li&gt; &#xA;   &lt;li&gt;page faults in the userspace work and are properly handled (only stack memory allocations are currently lazy)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;I/O subsystem (in the userspace) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;VirtIO-BLK and VirtIO-NET &lt;a href=&#34;https://github.com/moturus/motor-os/tree/main/src/lib/virtio&#34;&gt;drivers&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;two simple filesystems (&lt;a href=&#34;https://crates.io/crates/srfs&#34;&gt;srfs&lt;/a&gt; and &lt;a href=&#34;https://crates.io/crates/flatfs&#34;&gt;flatfs&lt;/a&gt;)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://crates.io/crates/smoltcp&#34;&gt;smoltcp&lt;/a&gt;-based networking (TCP only at the moment) &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;a simple &lt;a href=&#34;https://github.com/moturus/motor-os/tree/main/src/bin/httpd&#34;&gt;httpd&lt;/a&gt; is provided&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;the userspace: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;multiple processes, with preemption&lt;/li&gt; &#xA;   &lt;li&gt;threads, TLS&lt;/li&gt; &#xA;   &lt;li&gt;Rust&#39;s standard library &lt;a href=&#34;https://github.com/moturus/rust/tree/moturus-2023-12-16&#34;&gt;mostly ported&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Rust programs that use Rust standard library and do not depend, directly or indirectly, on Unix or Windows FFI, will cross-compile for MotÅ«rus OS and run, subject to &#34;what does not work&#34; below&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;a simple &lt;a href=&#34;https://github.com/moturus/rush&#34;&gt;unix-like shell&lt;/a&gt; in the serial console&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;What does not work&lt;/h3&gt; &#xA;&lt;p&gt;Most pieces are not yet ready for production use. No security audit has been made. It is very easy to hit a &#34;not implemented&#34; panic in sys-io (the userspace I/O subsystem).&lt;/p&gt; &#xA;&lt;p&gt;More specifically:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Filesystem: most Rust std::fs APIs have been implemented as proof-of-concept, but are slow (synchronous) and will have to be reimplemented using MotÅ«rus async I/O&lt;/li&gt; &#xA; &lt;li&gt;Networking: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;std::net::TcpStream is mostly implemented, but there are todo! panics&lt;/li&gt; &#xA;   &lt;li&gt;other protocols are not implemented yet&lt;/li&gt; &#xA;   &lt;li&gt;performance can (and will) be better&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;The ecosystem outside Rust std: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;crates like rand or rustls can be compiled and used with minor tweaks&lt;/li&gt; &#xA;   &lt;li&gt;crates depending on async runtimes (e.g. &lt;a href=&#34;https://tokio.rs/&#34;&gt;Tokio&lt;/a&gt;) will not compile at the moment &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://github.com/tokio-rs/mio&#34;&gt;Tokio Mio&lt;/a&gt; should be not too difficult to port&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;crates that are wrappers around native Linux or Windows APIs will not work, obviously&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How can I build/run it?&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/moturus/motor-os/main/docs/build.md&#34;&gt;docs/build.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Thanks&lt;/h2&gt; &#xA;&lt;p&gt;Big thanks to Philipp Oppermann for his great &lt;a href=&#34;https://os.phil-opp.com/&#34;&gt;Writing an OS in Rust&lt;/a&gt; blog series - it has inspired a lot of people to experiment in this space.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>jerryshell/ac-esp</title>
    <updated>2024-01-11T01:41:58Z</updated>
    <id>tag:github.com,2024-01-11:/jerryshell/ac-esp</id>
    <link href="https://github.com/jerryshell/ac-esp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;AssaultCube ESP DLL with Rust ðŸ¦€&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/jerryshell/ac-esp/master/img/logo.png&#34; alt=&#34;logo&#34;&gt; &lt;/p&gt; &#xA;&lt;h1&gt;AssaultCube ESP DLL with Rust ðŸ¦€&lt;/h1&gt; &#xA;&lt;p&gt;Bilibili Video: &lt;a href=&#34;https://www.bilibili.com/video/BV1dN4y1e7Me&#34;&gt;https://www.bilibili.com/video/BV1dN4y1e7Me&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Applicable Game Version: &lt;strong&gt;1.3.0.2&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download &lt;code&gt;ac_esp.dll&lt;/code&gt; from &lt;a href=&#34;https://github.com/jerryshell/ac-esp/releases&#34;&gt;releases&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run AssaultCube&lt;/li&gt; &#xA; &lt;li&gt;Inject &lt;code&gt;ac_esp.dll&lt;/code&gt; into AssaultCube ( You can do this with &lt;a href=&#34;https://processhacker.sourceforge.io&#34;&gt;Process Hacker&lt;/a&gt; )&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Build DLL&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo build --release --target=i686-pc-windows-msvc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cross build --release --target=i686-pc-windows-gnu&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Screenshot&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/jerryshell/ac-esp/master/img/screenshot.jpg&#34; alt=&#34;screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Related&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/jerryshell/windows-ez-overlay&#34;&gt;windows-ez-overlay&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;References&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows/win32/winmsg/about-windows&#34;&gt;About Windows&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kennykerr.ca/rust-getting-started&#34;&gt;Rust for Windows&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows/win32/gdi/windows-gdi&#34;&gt;Windows GDI&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;LICENSE&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://choosealicense.com/licenses/agpl-3.0/&#34;&gt;GNU Affero General Public License v3.0&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
</feed>