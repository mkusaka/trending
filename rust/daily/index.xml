<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-05-03T01:32:20Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>borgo-lang/borgo</title>
    <updated>2024-05-03T01:32:20Z</updated>
    <id>tag:github.com,2024-05-03:/borgo-lang/borgo</id>
    <link href="https://github.com/borgo-lang/borgo" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Borgo is a statically typed language that compiles to Go.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;The Borgo Programming Language&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/borgo-lang/borgo-lang.github.io/main/borgo.jpg&#34; alt=&#34;Borgo sits between Go and Rust&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/borgo-lang/borgo/actions/workflows/ci.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;I want a language for writing applications that is more expressive than Go but less complex than Rust.&lt;/p&gt; &#xA;&lt;p&gt;Go is simple and straightforward, but I often wish it offered more type safety. Rust is very nice to work with (at least for single threaded code) but it&#39;s too broad and complex, sometimes painfully so.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Borgo is a new language that transpiles to Go&lt;/strong&gt;. It&#39;s fully compatible with existing Go packages.&lt;/p&gt; &#xA;&lt;p&gt;Borgo syntax is similar to Rust, with optional semi-colons.&lt;/p&gt; &#xA;&lt;h1&gt;Tutorial&lt;/h1&gt; &#xA;&lt;p&gt;Check out the &lt;strong&gt;&lt;a href=&#34;https://borgo-lang.github.io/&#34;&gt;online playground&lt;/a&gt;&lt;/strong&gt; for a tour of the language.&lt;/p&gt; &#xA;&lt;p&gt;You can also take a look at test files for working Borgo code:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/borgo-lang/borgo/main/compiler/test/codegen-emit.md&#34;&gt;codegen-emit.md&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/borgo-lang/borgo/main/compiler/test/infer-expr.md&#34;&gt;infer-expr.md&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/borgo-lang/borgo/main/compiler/test/infer-file.md&#34;&gt;infer-file.md&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;h2&gt;Algebraic data types and pattern matching&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use fmt&#xA;&#xA;enum NetworkState {&#xA;    Loading,&#xA;    Failed(int),&#xA;    Success(string),&#xA;}&#xA;&#xA;let msg = match state {&#xA;    NetworkState.Loading =&amp;gt; &#34;still loading&#34;,&#xA;    NetworkState.Failed(code) =&amp;gt; fmt.Sprintf(&#34;Got error code: %d&#34;, code),&#xA;    NetworkState.Success(res) =&amp;gt; res,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instad of &lt;code&gt;nil&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// import packages from Go stdlib&#xA;use fmt&#xA;use os&#xA;&#xA;let key = os.LookupEnv(&#34;HOME&#34;)&#xA;&#xA;match key {&#xA;    Some(s) =&amp;gt; fmt.Println(&#34;home dir:&#34;, s),&#xA;    None =&amp;gt; fmt.Println(&#34;Not found in env&#34;),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; instad of multiple return values&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use fmt&#xA;use net.http&#xA;&#xA;fn makeRequest() -&amp;gt; Result&amp;lt;int, error&amp;gt; {&#xA;    let request = http.Get(&#34;http://example.com&#34;)&#xA;&#xA;    match request {&#xA;        Ok(resp) =&amp;gt; Ok(resp.StatusCode),&#xA;        Err(err) =&amp;gt; Err(fmt.Errorf(&#34;failed http request %w&#34;, err))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Error handling with &lt;code&gt;?&lt;/code&gt; operator&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use fmt&#xA;use io&#xA;use os&#xA;&#xA;fn copyFile(src: string, dst: string) -&amp;gt; Result&amp;lt;(), error&amp;gt; {&#xA;    let stat = os.Stat(src)?&#xA;&#xA;    if !stat.Mode().IsRegular() {&#xA;        return Err(fmt.Errorf(&#34;%s is not a regular file&#34;, src))&#xA;    }&#xA;&#xA;    let source = os.Open(src)?&#xA;    defer source.Close()&#xA;&#xA;    let destination = os.Create(dst)?&#xA;    defer destination.Close()&#xA;&#xA;    // ignore number of bytes copied&#xA;    let _ = io.Copy(destination, source)?&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Guessing game example&lt;/h2&gt; &#xA;&lt;p&gt;Small game from the Rust book, implemented in Borgo.&lt;/p&gt; &#xA;&lt;p&gt;Things to note:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;import packages from Go stdlib&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;strconv.Atoi&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;int&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;Reader.ReadString&lt;/code&gt; returns a &lt;code&gt;Result&amp;lt;string, error&amp;gt;&lt;/code&gt; (which can be unwrapped)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use bufio&#xA;use fmt&#xA;use math.rand&#xA;use os&#xA;use strconv&#xA;use strings&#xA;use time&#xA;&#xA;fn main() {&#xA;    let reader = bufio.NewReader(os.Stdin)&#xA;&#xA;    rand.Seed(time.Now().UnixNano())&#xA;    let secret = rand.Intn(100) + 1&#xA;&#xA;    loop {&#xA;        fmt.Println(&#34;Please input your guess.&#34;)&#xA;&#xA;        let text = reader.ReadString(&#39;\n&#39;).Unwrap()&#xA;        let text = strings.TrimSpace(text)&#xA;&#xA;        let guess = match strconv.Atoi(text) {&#xA;            Ok(n) =&amp;gt; n,&#xA;            Err(_) =&amp;gt; continue,&#xA;        }&#xA;&#xA;        fmt.Println(&#34;You guessed: &#34;, guess)&#xA;&#xA;        if guess &amp;lt; secret {&#xA;            fmt.Println(&#34;Too small!&#34;)&#xA;        } else if guess &amp;gt; secret {&#xA;            fmt.Println(&#34;Too big!&#34;)&#xA;        } else {&#xA;            fmt.Println(&#34;Correct!&#34;)&#xA;            break&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running locally&lt;/h2&gt; &#xA;&lt;p&gt;Borgo is written in Rust, so you&#39;ll need &lt;code&gt;cargo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To compile all &lt;code&gt;.brg&lt;/code&gt; files in the current folder:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cargo run -- build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The compiler will generate &lt;code&gt;.go&lt;/code&gt; files, which you can run as normal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# generate a go.mod file if needed&#xA;# $ go mod init foo&#xA;$ go run .&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>