<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-27T01:33:54Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>candy-lang/candy</title>
    <updated>2024-02-27T01:33:54Z</updated>
    <id>tag:github.com,2024-02-27:/candy-lang/candy</id>
    <link href="https://github.com/candy-lang/candy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üç≠ A sweet, functional programming language that is robust, minimalistic, and expressive.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;üç≠ Candy&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;üöß Work in Progress!&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;Candy is still in its early stages. We are actively working on it, but it&#39;s not ready for production use yet. If you want to help, please join our &lt;a href=&#34;https://discord.gg/5Vr4eAJ7gU&#34;&gt;Discord server&lt;/a&gt;. See also: &lt;a href=&#34;https://raw.githubusercontent.com/candy-lang/candy/main/#the-current-state&#34;&gt;The current state&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;A sweet, functional programming language that is robust, minimalistic, and expressive.&lt;/p&gt; &#xA;&lt;p&gt;Many programming languages have a strict separation between compile-time and runtime errors. Sometimes, this border can seem arbitrary: Dividing by a string fails during compilation with a type error, while dividing by zero only fails during runtime. In the mathematical sense, there&#39;s no fundamental difference between these cases‚ÄØ‚Äì‚Äâdivision is only defined for divisors that are non-zero numbers. That&#39;s why we eliminate the border between compile-time and runtime errors‚ÄØ‚Äì‚Äâall errors are runtime errors. By crafting high-quality tooling with dynamic analyses such as fuzzing, we try to still be able to show most errors while you&#39;re editing the code. In fact, we try to show more errors than typical statically typed languages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/candy-lang/candy/main/screenshot.png&#34; alt=&#34;Candy in VS Code&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Quick introduction&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Values are at the center of your computations.&lt;/strong&gt; Only a handful of predefined types of values exist:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-candy&#34;&gt;3                   # int&#xA;&#34;Candy&#34;             # text&#xA;Green               # tag (uppercase)&#xA;Error ListIsEmpty   # tag with a value&#xA;(Foo, Bar)          # list&#xA;[Name: &#34;Candy&#34;]     # struct&#xA;{ it -&amp;gt; add it 2 }  # function&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Minimalistic syntax.&lt;/strong&gt; Defining variables and functions works without braces or keywords cluttering up your code. The syntax is indentation-aware.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-candy&#34;&gt;# I&#39;m a comment&#xA;foo = 42                # variable (lowercase)&#xA;println message =       # function&#xA;  print message         # function call&#xA;  print &#34;\n&#34;&#xA;println &#34;Hello, world!&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Extensive compile-time evaluation.&lt;/strong&gt; Many values can already be computed at compile-time. In your editor, you&#39;ll see the results on the right side:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-candy&#34;&gt;foo = double 2  # foo = 4&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Fuzzing instead of traditional types.&lt;/strong&gt; In Candy, functions have to specify their needs &lt;em&gt;exactly.&lt;/em&gt; As you type, the tooling automatically tests your code with many inputs to see if one breaks the code:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-candy&#34;&gt;foo a =             # If you pass a = 0,&#xA;  needs (isInt a)&#xA;  math.logarithm a  # then this panics: The `input` must be a positive number.&#xA;&#xA;efficientTextReverse text =&#xA;  needs (isText text)&#xA;  needs (isPalindrome text) &#34;Only palindromes can be efficiently reversed.&#34;&#xA;  text&#xA;&#xA;greetBackwards name =                   # If you pass name = &#34;Test&#34;,&#xA;  &#34;Hello, {efficientTextReverse name}&#34;  # then this panics: Only palindromes can be efficiently reversed.&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;For more info, read:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Marcel&#39;s blog post about Candy: &lt;a href=&#34;https://marcelgarus.dev/candy&#34;&gt;https://marcelgarus.dev/candy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;the &lt;a href=&#34;https://raw.githubusercontent.com/candy-lang/candy/main/language.md&#34;&gt;language documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Marcel&#39;s blog post about Candy&#39;s compiler pipeline: &lt;a href=&#34;https://marcelgarus.dev/candy-compiler-pipeline&#34;&gt;https://marcelgarus.dev/candy-compiler-pipeline&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;The current state&lt;/h2&gt; &#xA;&lt;p&gt;We are currently implementing a first version of Candy in Rust. We already have a CLI, language server, and Visual Studio Code extension that provide some tooling.&lt;/p&gt; &#xA;&lt;p&gt;The language is still in its early stages, and we are actively working on it. There are still compiler bugs and performance improvements that need work before this language is ready for production use.&lt;/p&gt; &#xA;&lt;h2&gt;Discussion&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/5Vr4eAJ7gU&#34;&gt;Join our &lt;img height=&#34;12&#34; src=&#34;https://github.com/candy-lang/candy/assets/19330937/baf90ce0-1d0a-4279-92fa-1c360cd28b38&#34;&gt; Discord server.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;How to use Candy&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://rust-lang.org&#34;&gt;&lt;img height=&#34;16&#34; src=&#34;https://rust-lang.org/static/images/favicon.svg?sanitize=true&#34;&gt;&amp;nbsp;Rust&lt;/a&gt;: &lt;a href=&#34;https://rust-lang.org/tools/install&#34;&gt;rust-lang.org/tools/install&lt;/a&gt; (use Rustup since we use nightly features).&lt;/li&gt; &#xA; &lt;li&gt;Clone this repo.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Then, you can use Candy in two ways:&lt;/p&gt; &#xA;&lt;h3&gt;Use the VS Code Extension&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install &lt;a href=&#34;https://code.visualstudio.com&#34;&gt;&lt;img height=&#34;16&#34; src=&#34;https://code.visualstudio.com/favicon.ico&#34;&gt;&amp;nbsp;Visual Studio Code (VS Code)&lt;/a&gt;: &lt;a href=&#34;https://code.visualstudio.com/download&#34;&gt;code.visualstudio.com/download&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Open the workspace (&lt;code&gt;compiler.code-workspace&lt;/code&gt;) in VS&amp;nbsp;Code.&lt;/li&gt; &#xA; &lt;li&gt;Install the recommended VS Code extensions.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;npm install&lt;/code&gt; inside &lt;code&gt;vscode_extension/&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run the launch config ‚ÄúRun Extension (VS&amp;nbsp;Code Extension)‚Äù.&lt;/li&gt; &#xA; &lt;li&gt;In the new VS&amp;nbsp;Code window that opens, you can enjoy üç≠&amp;nbsp;Candy :)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;If you are working on the Rust code itself, you might want to disable release mode for quicker compilation: In &lt;code&gt;packages/candy.code-workspace&lt;/code&gt;, in the &lt;code&gt;candy.languageServerCommand&lt;/code&gt; setting, remove &lt;code&gt;--release&lt;/code&gt;. (But don&#39;t commit that change.)&lt;/p&gt; &#xA;&lt;h3&gt;Use the CLI&lt;/h3&gt; &#xA;&lt;p&gt;From the root of this repository, you can run the Candy CLI by starting the Candy commands with &lt;code&gt;cargo run --release --&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Run a Candy file:&#xA;cargo run --release -- run ./packages/Examples/helloWorld.candy&#xA;&#xA;# View all available commands:&#xA;cargo run --release -- help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Everything after &lt;code&gt;--&lt;/code&gt; is passed to Candy, everything before it to Cargo.)&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ashvardanian/memchr_vs_stringzilla</title>
    <updated>2024-02-27T01:33:54Z</updated>
    <id>tag:github.com,2024-02-27:/ashvardanian/memchr_vs_stringzilla</id>
    <link href="https://github.com/ashvardanian/memchr_vs_stringzilla" rel="alternate"></link>
    <summary type="html">&lt;p&gt;memchr vs stringzilla - up to 7x throughput difference between two SIMD-accelerated substring search libraries in Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://github.com/BurntSushi/memchr&#34;&gt;&lt;code&gt;memchr&lt;/code&gt;&lt;/a&gt; vs &lt;a href=&#34;https://github.com/ashvardanian/StringZilla&#34;&gt;&lt;code&gt;stringzilla&lt;/code&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;h2&gt;Rust Substring Search Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;Substring search is one of the most common operations in text processing, and one of the slowest. StringZilla was designed to supersede LibC and implement those core operations in CPU-friendly manner, using branchless operations, SWAR, and SIMD assembly instructions. Notably, Rust has a &lt;code&gt;memchr&lt;/code&gt; crate that provides a similar functionality, and it&#39;s used in many popular libraries. This repository provides basic benchmarking scripts for comparing the throughput of &lt;a href=&#34;https://github.com/ashvardanian/StringZilla&#34;&gt;&lt;code&gt;stringzilla&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/BurntSushi/memchr&#34;&gt;&lt;code&gt;memchr&lt;/code&gt;&lt;/a&gt;. For normal order and reverse order search, over ASCII and UTF8 input data, the following numbers can be expected.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;ASCII ‚è©&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;ASCII ‚è™&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;UTF8 ‚è©&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;UTF8 ‚è™&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Intel:&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;memchr&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;5.89 GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1.08 GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;8.73 GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.35 GB/s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;stringzilla&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;8.37&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;8.21&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;11.21&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;11.20&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Arm:&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;memchr&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6.38 GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1.12 GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;13.20&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;3.56 GB/s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;stringzilla&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;6.56&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;5.56&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;9.41 GB/s&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;8.17&lt;/strong&gt; GB/s&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Average&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;1.2x&lt;/strong&gt; faster&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;6.2x&lt;/strong&gt; faster&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;-&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;2.8x&lt;/strong&gt; faster&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;For Intel the benchmark was run on AWS &lt;code&gt;r7iz&lt;/code&gt; instances with Sapphire Rapids cores. For Arm the benchmark was run on AWS &lt;code&gt;r7g&lt;/code&gt; instances with Graviton 3 cores. The ‚è© signifies forward search, and ‚è™ signifies reverse order search. At the time of writing, the latest versions of &lt;code&gt;memchr&lt;/code&gt; and &lt;code&gt;stringzilla&lt;/code&gt; were used - 2.7.1 and 3.3.0, respectively.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Replicating the Results&lt;/h2&gt; &#xA;&lt;p&gt;Before running benchmarks, you can test your Rust environment running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo install cargo-criterion --locked&#xA;HAYSTACK_PATH=README.md cargo criterion --jobs 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As part of the benchmark, the input &#34;haystack&#34; file is whitespace-tokenized into an array of strings. In every benchmark iteration, a new &#34;needle&#34; is taken from that array of tokens. All inclusions of that token in the haystack are counted, and the throughput is calculated. This generally results in very stable and predictable results. The benchmark also includes a warm-up, to ensure that the CPU caches are filled and the results are not affected by cold start or SIMD-related frequency scaling.&lt;/p&gt; &#xA;&lt;h3&gt;ASCII Corpus&lt;/h3&gt; &#xA;&lt;p&gt;For benchmarks on ASCII data I&#39;ve used the English Leipzig Corpora Collection. It&#39;s 124 MB in size, 1&#39;000&#39;000 lines long, and contains 8&#39;388&#39;608 tokens of mean length 5.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget --no-clobber -O leipzig1M.txt https://introcs.cs.princeton.edu/python/42sort/leipzig1m.txt &#xA;HAYSTACK_PATH=leipzig1M.txt cargo criterion --jobs 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;UTF8 Corpus&lt;/h3&gt; &#xA;&lt;p&gt;For richer mixed UTF data, I&#39;ve used the XL Sum dataset for multilingual extractive summarization. It&#39;s 4.7 GB in size (1.7 GB compressed), 1&#39;004&#39;598 lines long, and contains 268&#39;435&#39;456 tokens of mean length 8. To download, unpack, and run the benchmarks, execute the following bash script in your terminal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget --no-clobber -O xlsum.csv.gz https://github.com/ashvardanian/xl-sum/releases/download/v1.0.0/xlsum.csv.gz&#xA;gzip -d xlsum.csv.gz&#xA;HAYSTACK_PATH=xlsum.csv cargo criterion --jobs 8&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>inlinedio/ikv-store</title>
    <updated>2024-02-27T01:33:54Z</updated>
    <id>tag:github.com,2024-02-27:/inlinedio/ikv-store</id>
    <link href="https://github.com/inlinedio/ikv-store" rel="alternate"></link>
    <summary type="html">&lt;p&gt;High-performance key-value store for ML inference. 100x faster than Redis.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/readme-img/inlined-logo.png&#34; alt=&#34;IKV Logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;IKV | Inlined Key-Value Store&lt;/h1&gt; &#xA;&lt;p&gt;IKV is a high performance &lt;strong&gt;fully-managed embedded database&lt;/strong&gt;, for powering modern ML inference. It&#39;s unique design makes it perfect for accessing large key-value datasets with very low latency in a production setting.&lt;/p&gt; &#xA;&lt;p&gt;An &lt;a href=&#34;https://en.wikipedia.org/wiki/Embedded_database&#34;&gt;embedded database&lt;/a&gt; provides much better performance (response-time and throughput) as compared to standalone services (ex. Redis or DynamoDB), by integrating directly into the user application and avoiding any remote network calls. IKV is -&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Blazing Fast&lt;/strong&gt;: IKV provides &lt;strong&gt;single-digit microsecond&lt;/strong&gt; P99 read latency from client‚Äôs point-of-view. This is 100x faster than existing solutions like Redis.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Persistent Storage&lt;/strong&gt;: Write once and read forever. IKV embedded database is built on top of a reliable data layer (i.e. IKV cloud).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Environment Agnostic&lt;/strong&gt;: Run in the public-cloud (AWS/Azure/GCP, etc) or on-prem with no differences in read-performance or configuration.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Horizontally Scalable&lt;/strong&gt;: Handles large datasets (with partitions) and high read/write traffic (with replication). Built for streaming and batch ingestion of data.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Benchmarks | 100x faster than Redis&lt;/h2&gt; &#xA;&lt;p&gt;IKV is eventually-consistent, in-memory (with option to spill to disk) and trades-off write performance for reads. These design choices enable extremely low-latency read access to key value data. IKV provides &lt;strong&gt;single-digit microsecond response-time at P99&lt;/strong&gt; and is &lt;strong&gt;100x faster than Redis&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Read our full benchmarking setup and report &lt;a href=&#34;https://docs.google.com/document/d/1aDsS0V-AybpvXEwblBlahGLpKH5NmUmi6mTWGsbABGk/edit#heading=h.ey4ngxmm384e&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;| Read-Only Load (QPS) | IKV (Inlined Key Value Store)   | Redis Cluster (AWS ElastiCache) |&#xA;|----------------------|---------------------------------|---------------------------------|&#xA;|                      | Response Time (micro-seconds)   | Response Time (micro-seconds)   |&#xA;|                      |                                 |                                 |&#xA;| 25K                  | avg: 2.77, p50: 2.58, p99: 5.34 | avg: 317, p50: 306, p99: 527    |&#xA;| 50K                  | avg: 3.05, p50: 2.91, p99: 5.97 | avg: 321, p50: 308, p99: 533    |&#xA;| 100K                 | avg: 3.13, p50: 2.89, p99: 5.65 | avg: 319, p50: 305, p99: 514    |&#xA;| 1M                   | avg: 2.93, p50: 2.56, p99: 4.92 | Not Achievable                  |&#xA;| 3M                   | avg: 4.09, p50: 2.43, p99: 3.83 | Not Achievable                  |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;These benchmarks were performed by a multi-threaded client machine which made blocking calls to the underlying database. For a constant load (queries-per-second), we note down the response-time of both databases (avg/P99/etc). We tested &#34;get&#34; performance i.e. given a primary-key and a field/attribute name - fetch the field&#39;s value. IKV is inherently built for multithreaded use, for Redis we used a 16 shard, single-node Redis Cluster to ensure fairness. The report linked above has details about hardware and testing methodology.&lt;/p&gt; &#xA;&lt;h2&gt;Quick Links&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting Started &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#provisioning&#34;&gt;Provisioning&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#getting-started-with-java&#34;&gt;Java&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;Python &amp;amp; Go (upcoming - July 2024)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#apis&#34;&gt;APIs&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#architecture&#34;&gt;Architecture&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#technical-support&#34;&gt;Technical Support&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Provisioning&lt;/h2&gt; &#xA;&lt;p&gt;You need an IKV account and a provisioned key-value store to start using IKV in production. Why? IKV is an embedded database which is built on top of a persistent stand-alone data layer (which needs resource allocation). To provision (provisioning time is usually less than 12 hrs), reach out to to - &lt;strong&gt;&lt;a href=&#34;mailto:onboarding@inlined.io&#34;&gt;onboarding@inlined.io&lt;/a&gt;&lt;/strong&gt;, with the following -&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Existing &lt;strong&gt;account-id&lt;/strong&gt; (if exists, else mention you want a new account-id and account-passkey).&lt;/li&gt; &#xA; &lt;li&gt;For store provisioning: &lt;strong&gt;store-name, primary-key, partitioning key (optional)&lt;/strong&gt;. See &lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#apis&#34;&gt;APIs&lt;/a&gt; to familiarize yourself with some of these terms.&lt;/li&gt; &#xA; &lt;li&gt;Once you have an account-id, account-passkey and have provisioned a new store, you&#39;re all set to start using IKV.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started with Java&lt;/h2&gt; &#xA;&lt;p&gt;In this section we go over some code samples about how to use IKV&#39;s client library in your Java project. Please reach out to &lt;em&gt;&lt;a href=&#34;mailto:onboarding@inlined.io&#34;&gt;onboarding@inlined.io&lt;/a&gt;&lt;/em&gt; for any support/questions related to usage.&lt;/p&gt; &#xA;&lt;h4&gt;Installation&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;ikv-java-client&lt;/code&gt; dependency is hosted on &lt;a href=&#34;https://jitpack.io/#io.inlined/ikv-java-client&#34;&gt;Jitpack&lt;/a&gt;, add dependency to your Gradle/Maven Java project. Make sure to use the latest version from &lt;a href=&#34;https://jitpack.io/#io.inlined/ikv-java-client&#34;&gt;release list&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;repositories {&#xA;  maven { url &#39;https://jitpack.io&#39; }&#xA;}&#xA;&#xA;dependencies {&#xA;  implementation &#39;io.inlined:ikv-java-client:0.0.7&#39;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;repositories&amp;gt;&#xA;  &amp;lt;repository&amp;gt;&#xA;    &amp;lt;id&amp;gt;jitpack.io&amp;lt;/id&amp;gt;&#xA;    &amp;lt;url&amp;gt;https://jitpack.io&amp;lt;/url&amp;gt;&#xA;  &amp;lt;/repository&amp;gt;&#xA;&amp;lt;/repositories&amp;gt;&#xA;&#xA;&amp;lt;dependency&amp;gt;&#xA;  &amp;lt;groupId&amp;gt;io.inlined&amp;lt;/groupId&amp;gt;&#xA;  &amp;lt;artifactId&amp;gt;ikv-java-client&amp;lt;/artifactId&amp;gt;&#xA;  &amp;lt;version&amp;gt;0.0.7&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Java Usage&lt;/h4&gt; &#xA;&lt;p&gt;Prerequisites - (1) &lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#provisioning&#34;&gt;Provisioned&lt;/a&gt; IKV store (2) Basic familiarity with &lt;a href=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/#apis&#34;&gt;IKV APIs and concepts&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;// Instantiate reader and writer clients using IKVClientFactory.&#xA;// In this example we will upsert and read &#34;user&#34; profile data - the same example&#xA;// which was discussed in IKV APIs section linked above.&#xA;&#xA;import io.inlined.clients.ClientOptions;  &#xA;import io.inlined.clients.IKVClientFactory;  &#xA;import io.inlined.clients.IKVDocument;  &#xA;import io.inlined.clients.InlineKVReader;  &#xA;import io.inlined.clients.InlineKVWriter;&#xA;&#xA;IKVClientFactory factory = new IKVClientFactory();&#xA;&#xA;// Create client options - for Writer&#xA;ClientOptions writerClientOptions = new ClientOptions.Builder()&#xA;  .withStoreName(&#34;user-profile&#34;)  &#xA;  .withAccountId(&#34;--account-id--&#34;)  &#xA;  .withAccountPassKey(&#34;--account-passkey--&#34;)&#xA;  .build();&#xA;&#xA;// Create Writer instance&#xA;InlineKVWriter writer = factory.createNewWriterInstance(writerClientOptions);&#xA;writer.startupWriter();&#xA;&#xA;// create documents and invoke upsert() operations&#xA;IKVDocument doc1 =  new IKVDocument.Builder()&#xA;  .putStringField(&#34;firstname&#34;, &#34;Alice&#34;)&#xA;  .putIntField(&#34;age&#34;, 22)&#xA;  .build();  &#xA;writer.upsertFieldValues(doc1);&#xA;&#xA;IKVDocument doc2 =  new IKVDocument.Builder()&#xA;  .putStringField(&#34;firstname&#34;, &#34;Alice&#34;)&#xA;  .putStringField(&#34;city&#34;, &#34;San Francisco&#34;)&#xA;  .build();  &#xA;writer.upsertFieldValues(doc2);&#xA;&#xA;IKVDocument doc3 =  new IKVDocument.Builder()&#xA;  .putStringField(&#34;firstname&#34;, &#34;Bob&#34;)&#xA;  .putIntField(&#34;age&#34;, 25)&#xA;  .build();  &#xA;writer.upsertFieldValues(doc3);&#xA;&#xA;// Create client options - for Reader&#xA;ClientOptions readerClientOptions = new ClientOptions.Builder()&#xA;  .withMountDirectory(&#34;/tmp/UserProfiles)  &#xA;  .withStoreName(&#34;user-profile&#34;)  &#xA;  .withAccountId(&#34;--account-id--&#34;)  &#xA;  .withAccountPassKey(&#34;--account-passkey--&#34;)  &#xA;  .useStringPrimaryKey()  &#xA;  .build();&#xA;&#xA;// Create Reader instance&#xA;InlineKVReader reader = factory.createNewReaderInstance(readerClientOptions);  &#xA;reader.startupReader();&#xA;&#xA;// read documents&#xA;// Due to eventual-consistent nature of IKV, you might need to add a small delay (or retries)&#xA;// before reading your writes.&#xA;Thread.sleep(1000);&#xA;&#xA;Assertions.assertEquals(reader.getStringValue(&#34;Alice&#34;, &#34;firstname&#34;), &#34;Alice&#34;);&#xA;Assertions.assertEquals(reader.getIntValue(&#34;Alice&#34;, &#34;age&#34;), 22);&#xA;Assertions.assertEquals(reader.getStringValue(&#34;Alice&#34;, &#34;city&#34;), &#34;San Francisco&#34;);&#xA;&#xA;Assertions.assertEquals(reader.getStringValue(&#34;Bob&#34;, &#34;firstname&#34;), &#34;Bob&#34;);&#xA;Assertions.assertEquals(reader.getIntValue(&#34;Bob&#34;, &#34;age&#34;), 25);&#xA;Assertions.assertNull(reader.getStringValue(&#34;Bob&#34;, &#34;city&#34;));&#xA;&#xA;writer.shutdownWriter();&#xA;reader.shutdownReader();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;APIs&lt;/h2&gt; &#xA;&lt;p&gt;In this section we go over some important interfaces and abstractions that IKV provides as a key-value database.&lt;/p&gt; &#xA;&lt;p&gt;These concepts are language independent. IKV stores documents (the &#34;value&#34;) associated with primary-keys (the &#34;key&#34;), in an &lt;a href=&#34;https://en.wikipedia.org/wiki/Eventual_consistency&#34;&gt;eventually consistent&lt;/a&gt; (read-after-write) manner. Given a primary-key, a user can do CRUD operations i.e. create/read/update/delete for a single document (batch operations are also supported).&lt;/p&gt; &#xA;&lt;h5&gt;Document&lt;/h5&gt; &#xA;&lt;p&gt;A document is a collection of fields/attributes. Each inner field/attribute contained within a document is optional (i.e. it&#39;s value can be missing), and can be used to store a particular property of the document. This is analogous to a &#34;single row&#34; of data in many SQL databases or something like DynamoDB, with each &#34;column&#34; being an inner field/attribute.&lt;/p&gt; &#xA;&lt;p&gt;A field can be uniquely identified by a &lt;strong&gt;name&lt;/strong&gt; and a &lt;strong&gt;type&lt;/strong&gt; - which is the same across all documents stored in a particular IKV store. Fields (except primary and partitioning keys) are not required to be declared while provisioning or in a &#34;schema/configuration&#34; file, instead IKV updates field information dynamically as and when they are encountered at runtime.&lt;/p&gt; &#xA;&lt;h5&gt;Field Types&lt;/h5&gt; &#xA;&lt;p&gt;Supported types include -&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Numeric&lt;/strong&gt;: int32, int64, float32, float64 - Can be used to store signed integer and floating point numbers of size 4 and 8 bytes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;String&lt;/strong&gt;: A sequence of UTF8 characters. Language specific IKV clients generate functions/methods that use language specific types to represent strings (ex. &lt;code&gt;java.lang.String&lt;/code&gt; in Java).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Bytes&lt;/strong&gt;: A sequence of 8-bit values or raw bytes. This type is quite useful to model complex types. ex. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Storing a list of float64: which can be done by creating a custom encode/decoder which stores the number of float64&#39;s in the list followed by the actual floats as a fixed-width 8 byte entity.&lt;/li&gt; &#xA;   &lt;li&gt;Storing complex/nested data: which can be done by leveraging serialization frameworks like Protobuf, Json, etc. - creating application specific objects and then converting them into raw bytes.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h5&gt;Primary Key&lt;/h5&gt; &#xA;&lt;p&gt;Primary Key is a unique identifier for a document and is itself a required field/attribute of the document. It can be of type string or bytes, and should be used for all CRUD operations on documents.&lt;/p&gt; &#xA;&lt;h5&gt;Partitioning Key&lt;/h5&gt; &#xA;&lt;p&gt;Since IKV is an embedded database, after a certain size all documents cannot fit in a single machine/host - hence partitioning keys are used to distribute documents across multiple hosts (i.e. partitions/shards). A user can declare an optional partitioning key (defaults to the primary key if missing), which itself is a required field/attribute of the document. It can be of type string or bytes. It is only relevant for write (create/update/delete) operations.&lt;/p&gt; &#xA;&lt;h5&gt;Operations&lt;/h5&gt; &#xA;&lt;p&gt;IKV supports the following operations on documents (for single/batch of documents) -&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Upsert&lt;/strong&gt;: Insert or Update-if-exists a document, given the document&#39;s fields (primary, partitioning keys and other fields). Upserts need not contain all field values as part of the same operation - fields get unionized to the same document, as and when they are published.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Delete&lt;/strong&gt;: Delete a document or specific fields from a document, given the document&#39;s primary and partitioning (if applicable) key.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Read&lt;/strong&gt;: Read a particular field(s) for a document, given its primary key. NOTE - Read operations are &lt;a href=&#34;https://en.wikipedia.org/wiki/Eventual_consistency&#34;&gt;eventually-consistent&lt;/a&gt; w.r.t upsert and delete operations, i.e. there will be small delay (usually in order of milliseconds) before changes to a document&#39;s fields are reflected in read operations.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h5&gt;Illustration&lt;/h5&gt; &#xA;&lt;p&gt;Let&#39;s consider an example where we want to store user profile&#39;s in an IKV store called - &lt;em&gt;users&lt;/em&gt;. A user profile contains their (1) first-name (2) age (3) city.&lt;/p&gt; &#xA;&lt;p&gt;To represent this data-model, we first think of how our IKV document would look like. Each document can represent a particular profile, which is uniquely identified by their &lt;em&gt;firstname&lt;/em&gt;. We will need the following types -&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Field-Name: firstname, Field-Type: String&lt;/li&gt; &#xA; &lt;li&gt;Field-Name: age, Field-Type: int32&lt;/li&gt; &#xA; &lt;li&gt;Field-Name: city, Field-Type: String&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Document Construction:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Upsert#Alice&#xA;{&#xA;  &#34;firstname&#34;: &#34;Alice&#34;,&#xA;  &#34;age&#34;: 22&#xA;}&#xA;&#xA;Upsert#Alice&#xA;{&#xA;  &#34;firstname&#34;: &#34;Alice&#34;,&#xA;  &#34;city&#34;: &#34;San Francisco&#34;&#xA;}&#xA;&#xA;Upsert#Bob&#xA;{&#xA;  &#34;firstname&#34;: &#34;Bob&#34;,&#xA;  &#34;age&#34;: 25&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Reads:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&#34;Alice#firstname&#34; -&amp;gt; &#34;Alice&#34;&#xA;&#34;Alice#age&#34; -&amp;gt; 22&#xA;&#34;Alice#city&#34; -&amp;gt; &#34;San Francisco&#34;&#xA;&#xA;&#34;Bob#firstname&#34; -&amp;gt; &#34;Bob&#34;&#xA;&#34;Bob#age&#34; -&amp;gt; 25&#xA;&#34;Bob#city&#34; -&amp;gt; // empty&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Architecture&lt;/h2&gt; &#xA;&lt;p&gt;This section has a bird&#39;s eye view of IKV&#39;s architecture.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/inlinedio/ikv-store/master/readme-img/architecture.png&#34; alt=&#34;IKV Architecture Schematic&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;IKV has a hybrid architecture wherein, the database reads are served from an embedded database but writes are persisted and propagated using a standalone service (i.e. IKV Cloud).&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Reader/Writer Clients&lt;/strong&gt;: Distributed as language specific libraries, this is how users perform all CRUD operations. The writer client publishes the events to IKV Cloud, while the reader client queries the embedded database which is up-to-date with latest data (in near real-time).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;IKV Cloud&lt;/strong&gt;: Gateway for write operations. It distributes incoming writes to readers using Kafka streams. It also serves other essential tasks like building index images periodically (for bootstrapping new readers), serving configuration, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Embedded database&lt;/strong&gt;: Written in Rust, this component is the core database engine used by readers. Clients interface with this using foreign function interface (ex. JNI for Java). The key data structures include: (1) sharded memory-mapped files which store serialized field values (2) hash-table which indexes primary-keys versus &#34;offsets&#34; into the mmaps. This design enables highly concurrent key-value lookup. For most scenarios, all of the data will reside in RAM, providing high performance.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Technical Support&lt;/h2&gt; &#xA;&lt;p&gt;For provisioning, documentation or any technical support- onboarding[@]inlined.io&lt;/p&gt;</summary>
  </entry>
</feed>