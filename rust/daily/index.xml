<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-23T01:38:57Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>haileys/bark</title>
    <updated>2023-08-23T01:38:57Z</updated>
    <id>tag:github.com,2023-08-23:/haileys/bark</id>
    <link href="https://github.com/haileys/bark" rel="alternate"></link>
    <summary type="html">&lt;p&gt;live sync audio streaming for local networks&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/179065/260457176-b0975ce3-03a0-4df8-a979-a2ba84b3b039.png&#34; width=&#34;64&#34; height=&#34;51&#34;&gt; bark!&lt;/h1&gt; &#xA;&lt;p&gt;low latency multi-receiver synchronised audio streaming for local networks.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Transmits uncompressed 48khz stereo audio over UDP multicast&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Built-in time synchronisation and latency detection - no high precision NTP required!&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Adjusts audio playback rate with the Speex resampler to stay in sync&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running the server under Pipewire or Pulse&lt;/h3&gt; &#xA;&lt;p&gt;Note: if using Pipewire, you must have &lt;code&gt;pipewire-alsa&lt;/code&gt; installed for this to work.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;First create a virtual node for Bark to receive audio from. You will configure applications to send audio to this node.&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;$ pactl load-module module-null-sink media.class=Audio/Duplex sink_name=Bark audio.position=FL,FR&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can list all sources on your system with &lt;code&gt;pactl&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;$ pactl list sources short&#xA;145     Bark    PipeWire        float32le 2ch 48000Hz   SUSPENDED&#xA;3676    alsa_output.usb-Focusrite_Scarlett_Solo_USB-00.analog-stereo.monitor     PipeWire        s32le 2ch 44100Hz       IDLE&#xA;3677    alsa_input.usb-Focusrite_Scarlett_Solo_USB-00.analog-stereo      PipeWire        s32le 2ch 44100Hz       SUSPENDED&#xA;3678    alsa_input.usb-046d_Logitech_Webcam_C930e-02.analog-stereo     PipeWire        s16le 2ch 44100Hz       SUSPENDED&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the Bark server passing the name of the sink you created with the &lt;code&gt;--device&lt;/code&gt; option:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;$ bark stream --multicast 224.100.100.100:1530 --device Bark&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Running the receiver&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Find the sink you want the receiver to output to:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;$ pactl list sinks short&#xA;145     Bark    PipeWire        float32le 2ch 48000Hz   SUSPENDED&#xA;3676    alsa_output.usb-Focusrite_Scarlett_Solo_USB-00.analog-stereo     PipeWire        s32le 2ch 44100Hz       RUNNING&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run the Bark receiver:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-sh-session&#34;&gt;$ bark receive --multicast 224.100.100.100:1530 --device alsa_output.usb-Focusrite_Scarlett_Solo_USB-00.analog-stereo&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;As well as on the command line, Bark&#39;s options can be set by environment variable or configuration file. Command line options and their corresponding environment variables are shown in &lt;code&gt;bark --help&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Bark also searches the XDG config directories for a &lt;code&gt;bark.toml&lt;/code&gt; configuration file, respecting any custom directories set in &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;By default, Bark will look in &lt;code&gt;$HOME/.config/bark.toml&lt;/code&gt; first, and then &lt;code&gt;/etc/bark.toml&lt;/code&gt;. Options set in the configuration file take lowest precedence, are overriden by environment variables, and then finally command line options take highest precedence.&lt;/p&gt; &#xA;&lt;p&gt;The config file supports all command line options Bark supports. Here&#39;s an example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;multicast = &#34;224.100.100.100:1530&#34;&#xA;&#xA;[source]&#xA;device = &#34;Bark&#34;&#xA;delay_ms = 15&#xA;&#xA;[receive]&#xA;device = &#34;alsa_output.usb-Focusrite_Scarlett_Solo_USB-00.analog-stereo&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Monitoring the stream&lt;/h3&gt; &#xA;&lt;p&gt;Run &lt;code&gt;bark stats&lt;/code&gt; to see a live view of the state of all Bark receivers.&lt;/p&gt; &#xA;&lt;p&gt;Four timing fields are shown for each receiver:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Audio:&lt;/strong&gt; The time offset of the audio stream, from when it should be according to the stream presentation timestamp, to when the receiver is actually playing. A positive offset means the receiver is &lt;em&gt;ahead&lt;/em&gt; of the stream, a negative offset means the receiver is &lt;em&gt;behind&lt;/em&gt; the stream.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Buffer:&lt;/strong&gt; The length of the audio data in the receiver buffer.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Network:&lt;/strong&gt; The one-way packet delay between stream source and receiver. For best sync, this should be as stable as possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Predict:&lt;/strong&gt; The offset from the data timestamp in an audio packet (the stream source&#39;s time when the packet was sent), to what the receiver thinks the data timestamp should be according to measured clock difference and network latency.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Tuning&lt;/h3&gt; &#xA;&lt;p&gt;The stream source is responsible for setting the delay of the audio stream. The delay wants to be as low as possible without causing receivers to slew or underrun their buffers too much. Receivers will always experience &lt;em&gt;some&lt;/em&gt; slewing to keep in sync - the network is not perfectly reliable, and clocks always run at slightly different rates - but ideally slewing should be kept to a minimum to ensure best quality. Keep an eye on &lt;code&gt;bark stats&lt;/code&gt; while tuning this value.&lt;/p&gt; &#xA;&lt;p&gt;The optimal delay value depends on your network, particularly with respect to packet loss and latency stability (receivers connecting wirelessly will need more delay to remain stable than those hard-wired), as well as the latency introduced by sound cards. I&#39;ve observed that my desktop, which has a USB DAC, consistently tends to have less in its buffer than receivers with PCI DACs.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>dtolnay/watt</title>
    <updated>2023-08-23T01:38:57Z</updated>
    <id>tag:github.com,2023-08-23:/dtolnay/watt</id>
    <link href="https://github.com/dtolnay/watt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Runtime for executing procedural macros as WebAssembly&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Watt&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/dtolnay/watt&#34;&gt;&lt;img alt=&#34;github&#34; src=&#34;https://img.shields.io/badge/github-dtolnay/watt-8da0cb?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=github&#34; height=&#34;20&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/watt&#34;&gt;&lt;img alt=&#34;crates.io&#34; src=&#34;https://img.shields.io/crates/v/watt.svg?style=for-the-badge&amp;amp;color=fc8d62&amp;amp;logo=rust&#34; height=&#34;20&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/watt&#34;&gt;&lt;img alt=&#34;docs.rs&#34; src=&#34;https://img.shields.io/badge/docs.rs-watt-66c2a5?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=docs.rs&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Watt is a runtime for executing Rust procedural macros compiled as WebAssembly.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;watt = &#34;0.4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Compiler support: requires rustc 1.42+&lt;/em&gt;&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Rationale&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Faster compilation.&lt;/strong&gt; By compiling macros ahead-of-time to Wasm, we save all downstream users of the macro from having to compile the macro logic or its dependencies themselves.&lt;/p&gt; &lt;p&gt;Instead, what they compile is a small self-contained Wasm runtime (~3 seconds, shared by all macros) and a tiny proc macro shim for each macro crate to hand off Wasm bytecode into the Watt runtime (~0.3 seconds per proc-macro crate you depend on). This is much less than the 20+ seconds it can take to compile complex procedural macros and their dependencies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Isolation.&lt;/strong&gt; The Watt runtime is 100% safe code with zero dependencies. While running in this environment, a macro&#39;s &lt;em&gt;only possible interaction with the world&lt;/em&gt; is limited to consuming tokens and producing tokens. This is true regardless of how much unsafe code the macro itself might contain! Modulo bugs in the Rust compiler or standard library, it is impossible for a macro to do anything other than shuffle tokens around.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Determinism.&lt;/strong&gt; From a build system point of view, a macro backed by Wasm has the advantage that it can be treated as a purely deterministic function from input to output. There is no possibility of implicit dependencies, such as via the filesystem, which aren&#39;t visible to or taken into account by the build system.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Start by implementing and testing your proc macro as you normally would, using whatever dependencies you want (syn, quote, etc). You will end up with something that looks like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use proc_macro::TokenStream;&#xA;&#xA;#[proc_macro]&#xA;pub fn the_macro(input: TokenStream) -&amp;gt; TokenStream {&#xA;    /* ... */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;#[proc_macro_derive]&lt;/code&gt; and &lt;code&gt;#[proc_macro_attribute]&lt;/code&gt; are supported as well; everything is analogous to what will be shown here for &lt;code&gt;#[proc_macro]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When your macro is ready, there are just a few changes we need to make to the signature and the Cargo.toml. In your lib.rs, change each of your macro entry points to a no_mangle extern &#34;C&#34; function, and change the TokenStream in the signature from proc_macro to proc_macro2.&lt;/p&gt; &#xA;&lt;p&gt;It will look like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use proc_macro2::TokenStream;&#xA;&#xA;#[no_mangle]&#xA;pub extern &#34;C&#34; fn the_macro(input: TokenStream) -&amp;gt; TokenStream {&#xA;    /* same as before */&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now in your macro&#39;s Cargo.toml which used to contain this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# my_macros/Cargo.toml&#xA;&#xA;[lib]&#xA;proc-macro = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;change it instead to say:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]&#xA;crate-type = [&#34;cdylib&#34;]&#xA;&#xA;[patch.crates-io]&#xA;proc-macro2 = { git = &#34;https://github.com/dtolnay/watt&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This crate will be the binary that we compile to Wasm. Compile it by running:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo build --release --target wasm32-unknown-unknown&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next we need to make a small proc-macro shim crate to hand off the compiled Wasm bytes into the Watt runtime. It&#39;s fine to give this the same crate name as the previous crate, since the other one won&#39;t be getting published to crates.io. In a new Cargo.toml, put:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]&#xA;proc-macro = true&#xA;&#xA;[dependencies]&#xA;watt = &#34;0.4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And in its src/lib.rs, define real proc macros corresponding to each of the ones previously defined as no_mangle extern &#34;C&#34; functions in the other crate:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use proc_macro::TokenStream;&#xA;use watt::WasmMacro;&#xA;&#xA;static MACRO: WasmMacro = WasmMacro::new(WASM);&#xA;static WASM: &amp;amp;[u8] = include_bytes!(&#34;my_macros.wasm&#34;);&#xA;&#xA;#[proc_macro]&#xA;pub fn the_macro(input: TokenStream) -&amp;gt; TokenStream {&#xA;    MACRO.proc_macro(&#34;the_macro&#34;, input)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, copy the compiled Wasm binary from target/wasm32-unknown-unknown/release/my_macros.wasm under your implementation crate, to the src directory of your shim crate, and it&#39;s ready to publish!&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Remaining work&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Performance.&lt;/strong&gt; Watt compiles pretty fast, but so far I have not put any effort toward optimizing the runtime. That means macro expansion can potentially take longer than with a natively compiled proc macro.&lt;/p&gt; &lt;p&gt;Note that the performance overhead of the Wasm environment is partially offset by the fact that our proc macros are compiled to Wasm in release mode, so downstream &lt;code&gt;cargo build&lt;/code&gt; will be running a release-mode macro when it would have been running debug-mode for a traditional proc macro.&lt;/p&gt; &lt;p&gt;A neat approach would be to provide some kind of &lt;code&gt;cargo install watt-runtime&lt;/code&gt; which installs an optimized Wasm runtime locally, which the Watt crate can detect and hand off code to if available. That way we avoid running things in a debug-mode runtime altogether. The experimental beginnings of this can be found under the &lt;a href=&#34;https://raw.githubusercontent.com/dtolnay/watt/master/jit&#34;&gt;jit/&lt;/a&gt; directory.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tooling.&lt;/strong&gt; The getting started section shows there are a lot of steps to building a macro for Watt, and a pretty hacky patching in of proc-macro2. Ideally this would all be more straightforward, including easy tooling for doing reproducible builds of the Wasm artifact for confirming that it was indeed compiled from the publicly available sources.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;RFCs.&lt;/strong&gt; The advantages of fast compile time, isolation, and determinism may make it worthwhile to build first-class support for Wasm proc macros into rustc and Cargo. The toolchain could ship its own high performance Wasm runtime, which is an even better outcome than Watt because that runtime can be heavily optimized and consumers of macros don&#39;t need to compile it.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;This can&#39;t be real&lt;/h2&gt; &#xA;&lt;p&gt;To assist in convincing you that this is real, &lt;a href=&#34;https://crates.io/crates/wa-serde-derive&#34;&gt;here is serde_derive compiled to Wasm&lt;/a&gt;. It was compiled from the commit &lt;a href=&#34;https://github.com/serde-rs/serde/commit/1afae183b06ffe47d054c796e68630752414cf9e&#34;&gt;serde-rs/serde@1afae183&lt;/a&gt;. Feel free to try it out as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// [dependencies]&#xA;// serde = &#34;1.0&#34;&#xA;// serde_json = &#34;1.0&#34;&#xA;// wa-serde-derive = &#34;0.1&#34;&#xA;&#xA;use wa_serde_derive::Serialize;&#xA;&#xA;#[derive(Serialize)]&#xA;struct Watt {&#xA;    msg: &amp;amp;&#39;static str,&#xA;}&#xA;&#xA;fn main() {&#xA;    let w = Watt { msg: &#34;hello from wasm!&#34; };&#xA;    println!(&#34;{}&#34;, serde_json::to_string(&amp;amp;w).unwrap());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;br&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;The current underlying Wasm runtime is a fork of the &lt;a href=&#34;https://github.com/yblein/rust-wasm&#34;&gt;Rust-WASM&lt;/a&gt; project by Yoann Blein and Hugo Guiroux, a simple and spec-compliant WebAssembly interpreter.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;h4&gt;License&lt;/h4&gt; &#xA;&lt;sup&gt; Everything outside of the `runtime` directory is licensed under either of &lt;a href=&#34;https://raw.githubusercontent.com/dtolnay/watt/master/LICENSE-APACHE&#34;&gt;Apache License, Version 2.0&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/dtolnay/watt/master/LICENSE-MIT&#34;&gt;MIT license&lt;/a&gt; at your option. The `runtime` directory is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/dtolnay/watt/master/runtime/LICENSE_ISC&#34;&gt;ISC license&lt;/a&gt;. &lt;/sup&gt; &#xA;&lt;br&gt; &#xA;&lt;sub&gt; Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. &lt;/sub&gt;</summary>
  </entry>
</feed>