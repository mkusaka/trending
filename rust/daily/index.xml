<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-06T01:39:51Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mattwparas/steel</title>
    <updated>2023-12-06T01:39:51Z</updated>
    <id>tag:github.com,2023-12-06:/mattwparas/steel</id>
    <link href="https://github.com/mattwparas/steel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An embedded scheme interpreter in Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Steel&lt;/h1&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;img width=&#34;150px&#34; src=&#34;https://raw.githubusercontent.com/mattwparas/steel/master/images/styled.png&#34;&gt; &#xA;&lt;/div&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p&gt;An embeddable and extensible scheme dialect built in Rust.&lt;/p&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/mattwparas/steel/workflows/Build/badge.svg?sanitize=true&#34; alt=&#34;Actions Status&#34;&gt; &lt;a href=&#34;https://coveralls.io/github/mattwparas/steel?branch=master&#34;&gt;&lt;img src=&#34;https://coveralls.io/repos/github/mattwparas/steel/badge.svg?branch=master&#34; alt=&#34;Coverage Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/WwFRXdN6HU&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/1152443024715034675.svg?logo=discord&amp;amp;label=discord&#34; alt=&#34;Discord Chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA; &lt;a href=&#34;https://mattwparas.github.io/steel-playground/dev&#34;&gt; &lt;b&gt;Try it on the Playground&lt;/b&gt; &lt;/a&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;This github repository contains a cli interpreter. To try it out on the online playground, go to the &lt;a href=&#34;https://mattwparas.github.io/steel-playground/dev&#34;&gt;Steel playground&lt;/a&gt;. To get started using a repl with the crates, make sure you first have rust installed.&lt;/p&gt; &#xA;&lt;p&gt;Then, clone the repo and run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will launch a REPL instance that looks something like this:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/mattwparas/steel/master/images/repl.gif&#34; width=&#34;100%&#34;&gt; &lt;/p&gt; &#xA;&lt;h3&gt;Packages&lt;/h3&gt; &#xA;&lt;p&gt;If you would like to install and use packages, please set the &lt;code&gt;STEEL_HOME&lt;/code&gt; environment variable. This will be the location that packages get installed to. Steel currently does not assume any default.&lt;/p&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Steel&lt;/code&gt; is an embeddable scheme interpreter, with a standalone cli included as well. Inspired largely by Racket, the language seeks to be ergonomic scheme variant helpful for embedding in applications, or to be used on its own with high performance functions implemented in Rust. The language implementation itself contains a fairly powerful macro system based on the &lt;code&gt;syntax-rules&lt;/code&gt; style and a bytecode virtual machine. At the moment, it is not explicitly compliant with any individual scheme specification.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt; The API is unstable with no guarantees, and may change at any time while pre 1.0. There are undoubtedly bugs that exist, and any major bug reports will be addressed quickly. That being said, I do use it as a daily driver for many scripting tasks myself.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Limited &lt;code&gt;syntax-rules&lt;/code&gt; style macros are supported&lt;/li&gt; &#xA; &lt;li&gt;Easy integration with Rust functions and structs&lt;/li&gt; &#xA; &lt;li&gt;Easily call a script from rust or via a separate file&lt;/li&gt; &#xA; &lt;li&gt;Efficient - common functions and data structures are optimized for performance (&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, etc)&lt;/li&gt; &#xA; &lt;li&gt;Higher order Contracts&lt;/li&gt; &#xA; &lt;li&gt;Built in immutable data structures include: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;lists&lt;/li&gt; &#xA;   &lt;li&gt;vectors&lt;/li&gt; &#xA;   &lt;li&gt;hashmaps&lt;/li&gt; &#xA;   &lt;li&gt;hashsets&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contracts&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by Racket&#39;s higher order contracts, &lt;code&gt;Steel&lt;/code&gt; implements* higher order contracts to enable design by contract, made easy with a &lt;code&gt;define/contract&lt;/code&gt; macro for easier ergonomics. Racket makes use of a concept known as &lt;em&gt;blame&lt;/em&gt; which seeks to identify the violating party - &lt;code&gt;Steel&lt;/code&gt; does not quite have fully fleshed out blame but that is a work in progress. Here are some examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; Simple flat contracts&#xA;(define/contract (test x y)&#xA;    (-&amp;gt;/c even? even? odd?)&#xA;    (+ x y 1))&#xA;&#xA;(test 2 2) ;; =&amp;gt; 5&#xA;&#xA;(define/contract (test-violation x y)&#xA;    (-&amp;gt;/c even? even? odd?)&#xA;    (+ x y 1))&#xA;&#xA;(test-violation 1 2) ;; contract violation&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Contracts are implemented as &lt;em&gt;values&lt;/em&gt;, so they are bound to functions. This enables the use of contract checking on functions themselves since functions can be passed around:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; Higher order contracts, check on application&#xA;(define/contract (higher-order func y)&#xA;    (-&amp;gt;/c (-&amp;gt;/c even? odd?) even? even?)&#xA;    (+ 1 (func y)))&#xA;&#xA;(higher-order (lambda (x) (+ x 1)) 2) ;; =&amp;gt; 4&#xA;&#xA;(define/contract (higher-order-violation func y)&#xA;    (-&amp;gt;/c (-&amp;gt;/c even? odd?) even? even?)&#xA;    (+ 1 (func y)))&#xA;&#xA;(higher-order-violation (lambda (x) (+ x 2)) 2) ;; contract violation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Contracts on functions do not get checked until they are applied, so a function returning a &lt;em&gt;contracted&lt;/em&gt; function won&#39;t cause a violation until that function is actually used:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; More higher order contracts, get checked on application&#xA;(define/contract (output)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? int?))&#xA;    (lambda (x) 10))&#xA;&#xA;(define/contract (accept func)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? int?) string?)&#xA;    &#34;cool cool cool&#34;)&#xA;&#xA;(accept (output)) ;; =&amp;gt; &#34;cool cool cool&#34;&#xA;&#xA;;; different contracts on the argument&#xA;(define/contract (accept-violation func)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? string?) string?)&#xA;    (func &#34;applesauce&#34;)&#xA;    &#34;cool cool cool&#34;)&#xA;&#xA;(accept-violation (output)) ;; contract violation&#xA;&#xA;;; generates a function&#xA;(define/contract (generate-closure)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? int?))&#xA;    (lambda (x) 10))&#xA;&#xA;;; calls generate-closure which should result in a contract violation&#xA;(define/contract (accept-violation)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? string?))&#xA;    (generate-closure))&#xA;&#xA;((accept-violation) &#34;test&#34;) ;; contract violation&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Perhaps a more nuanced case:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define/contract (output)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? int?))&#xA;    (lambda (x) 10.2))&#xA;&#xA;(define/contract (accept)&#xA;    (-&amp;gt;/c (-&amp;gt;/c string? number?))&#xA;    (output))&#xA;&#xA;&#xA;((accept) &#34;test&#34;) ;; contract violation 10.2 satisfies number? but _not_ int?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;* Very much a work in progress&lt;/p&gt; &#xA;&lt;h2&gt;Transducers&lt;/h2&gt; &#xA;&lt;p&gt;Inspired by clojure&#39;s transducers, &lt;code&gt;Steel&lt;/code&gt; has a similar object that is somewhere half way in between transducers and iterators. Consider the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;&#xA;(mapping (lambda (x) (+ x 1))) ;; =&amp;gt; &amp;lt;#iterator&amp;gt;&#xA;(filtering even?) ;; =&amp;gt; &amp;lt;#iterator&amp;gt;&#xA;(taking 15) ;; =&amp;gt; &amp;lt;#iterator&amp;gt;&#xA;&#xA;(compose &#xA;    (mapping add1)&#xA;    (filtering odd?)&#xA;    (taking 15)) ;; =&amp;gt; &amp;lt;#iterator&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Each of these expressions emit an &lt;code&gt;&amp;lt;#iterator&amp;gt;&lt;/code&gt; object, which means they&#39;re compatible with &lt;code&gt;transduce&lt;/code&gt;. &lt;code&gt;transduce&lt;/code&gt; takes a transducer (i.e. &lt;code&gt;&amp;lt;#iterator&amp;gt;&lt;/code&gt;) and a collection that can be iterated (&lt;code&gt;list&lt;/code&gt;, &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt;, &lt;code&gt;hashset&lt;/code&gt;, &lt;code&gt;hashmap&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;) and applies the transducer.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; Accepts lists&#xA;(transduce (list 1 2 3 4 5) (mapping (lambda (x) (+ x 1))) (into-list)) ;; =&amp;gt; &#39;(2 3 4 5 6)&#xA;&#xA;;; Accepts vectors&#xA;(transduce (vector 1 2 3 4 5) (mapping (lambda (x) (+ x 1))) (into-vector)) ;; &#39;#(2 3 4 5 6)&#xA;&#xA;;; Even accepts streams!&#xA;(define (integers n)&#xA;    (stream-cons n (lambda () (integers (+ 1 n)))))&#xA;&#xA;(transduce (integers 0) (taking 5) (into-list)) ;; =&amp;gt; &#39;(0 1 2 3 4)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Transduce accepts a reducer function as well. Above we used &lt;code&gt;into-list&lt;/code&gt; and &lt;code&gt;into-vector&lt;/code&gt;, but below we can use any arbitrary reducer:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; (-&amp;gt; transducer reducing-function initial-value iterable)&#xA;(transduce (list 0 1 2 3) (mapping (lambda (x) (+ x 1))) (into-reducer + 0)) ;; =&amp;gt; 10&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Compose just combines the iterator functions and lets us avoid intermediate allocation. The composition works left to right - it chains each value through the functions and then accumulates into the output type. See the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;(define xf &#xA;    (compose &#xA;        (mapping add1)&#xA;        (filtering odd?)&#xA;        (taking 5)))&#xA;&#xA;(transduce (range 0 100) xf (into-list)) ;; =&amp;gt; &#39;(1 3 5 7 9)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Syntax Choices&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;Steel&lt;/code&gt; is mildly opinionated in that there a few ways to define variables and functions. These choices are fairly arbitrary except for the shorthand function syntax, which I borrowed from Racket. &lt;code&gt;defn&lt;/code&gt; and &lt;code&gt;fn&lt;/code&gt; were really encouraged by me wanting to type less characters.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;&#xA;;; All of the following are equivalent&#xA;(define (foo x) (+ x 1))&#xA;(define foo (lambda (x) (+ x 1)))&#xA;(defn (foo x) (+ x 1))&#xA;(defn foo (lambda (x) (+ x 1)))&#xA;&#xA;;; All of the following are equivalent&#xA;(lambda (x) (+ x 1))&#xA;(Î» (x) (+ x 1))&#xA;(fn (x) (+ x 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Modules&lt;/h2&gt; &#xA;&lt;p&gt;In order to support a growing codebase, Steel has module support for projects spanning multiple files. Steel files can &lt;code&gt;provide&lt;/code&gt; values (with contracts attached) and &lt;code&gt;require&lt;/code&gt; modules from other files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;;; main.scm&#xA;(require &#34;provide.scm&#34;)&#xA;&#xA;(even-&amp;gt;odd 10)&#xA;&#xA;&#xA;;; provide.scm&#xA;(provide &#xA;    (contract/out even-&amp;gt;odd (-&amp;gt;/c even? odd?))&#xA;    no-contract&#xA;    flat-value)&#xA;&#xA;(define (even-&amp;gt;odd x) &#xA;    (+ x 1))&#xA;&#xA;(define (accept-number x) (+ x 10))&#xA;&#xA;(define (no-contract) &#34;cool cool cool&#34;)&#xA;(define flat-value 15)&#xA;&#xA;(displayln &#34;Calling even-&amp;gt;odd with some bad inputs but its okay&#34;)&#xA;(displayln (even-&amp;gt;odd 1))&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here we can see if we were to run &lt;code&gt;main&lt;/code&gt; that it would include the contents of &lt;code&gt;provide&lt;/code&gt;, and only provided values would be accessible from &lt;code&gt;main&lt;/code&gt;. The contract is attached at the contract boundary, so inside the &lt;code&gt;provide&lt;/code&gt; module, you can violate the contract, but outside the module the contract will be applied.&lt;/p&gt; &#xA;&lt;p&gt;A few notes on modules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Cyclical dependencies are not allowed&lt;/li&gt; &#xA; &lt;li&gt;Modules will be only compiled once and used across multiple files. If &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; requires &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; will be compiled once and shared between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Modules will be recompiled when changed, and any dependent files will also be recompiled as necessary&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;Preliminary benchmarks show the following on my machine:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Benchmark&lt;/th&gt; &#xA;   &lt;th&gt;Steel&lt;/th&gt; &#xA;   &lt;th&gt;Python&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;(fib 28)&lt;/td&gt; &#xA;   &lt;td&gt;63.383ms&lt;/td&gt; &#xA;   &lt;td&gt;65.10 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;(ack 3 3)&lt;/td&gt; &#xA;   &lt;td&gt;0.303 ms&lt;/td&gt; &#xA;   &lt;td&gt;0.195 ms&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Examples of embedding Rust values in the virtual machine&lt;/h2&gt; &#xA;&lt;p&gt;Rust values, types, and functions are easily embedded into Steel. Using the &lt;code&gt;register_fn&lt;/code&gt; call, you can embed functions easily:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use steel_vm::engine::Engine;&#xA;use steel_vm::register_fn::RegisterFn;&#xA;&#xA;fn external_function(arg1: usize, arg2: usize) -&amp;gt; usize {&#xA;    arg1 + arg2&#xA;}&#xA;&#xA;fn option_function(arg1: Option&amp;lt;String&amp;gt;) -&amp;gt; Option&amp;lt;String&amp;gt; {&#xA;    arg1&#xA;}&#xA;&#xA;fn result_function(arg1: Option&amp;lt;String&amp;gt;) -&amp;gt; Result&amp;lt;String, String&amp;gt; {&#xA;    if let Some(inner) = arg1 {&#xA;        Ok(inner)&#xA;    } else {&#xA;        Err(&#34;Got a none&#34;.to_string())&#xA;    }&#xA;}&#xA;&#xA;pub fn main() {&#xA;    let mut vm = Engine::new();&#xA;&#xA;    // Here we can register functions&#xA;    // Any function can accept parameters that implement `FromSteelVal` and&#xA;    // return values that implement `IntoSteelVal`&#xA;    vm.register_fn(&#34;external-function&#34;, external_function);&#xA;&#xA;    // See the docs for more information about `FromSteelVal` and `IntoSteelVal`&#xA;    // but we can see even functions that accept/return Option&amp;lt;T&amp;gt; or Result&amp;lt;T,E&amp;gt;&#xA;    // can be registered&#xA;    vm.register_fn(&#34;option-function&#34;, option_function);&#xA;&#xA;    // Result values will map directly to errors in the VM and bubble back up&#xA;    vm.register_fn(&#34;result-function&#34;, result_function);&#xA;&#xA;    vm.run(&#xA;        r#&#34;&#xA;        (define foo (external-function 10 25))&#xA;        (define bar (option-function &#34;applesauce&#34;))&#xA;        (define baz (result-function &#34;bananas&#34;))&#xA;    &#34;#,&#xA;    )&#xA;    .unwrap();&#xA;&#xA;    let foo = vm.extract::&amp;lt;usize&amp;gt;(&#34;foo&#34;).unwrap();&#xA;    println!(&#34;foo: {}&#34;, foo);&#xA;    assert_eq!(35, foo);&#xA;&#xA;    // Can also extract a value by specifying the type on the variable&#xA;    let bar: String = vm.extract(&#34;bar&#34;).unwrap();&#xA;    println!(&#34;bar: {}&#34;, bar);&#xA;    assert_eq!(&#34;applesauce&#34;.to_string(), bar);&#xA;&#xA;    let baz: String = vm.extract(&#34;baz&#34;).unwrap();&#xA;    println!(&#34;baz: {}&#34;, baz);&#xA;    assert_eq!(&#34;bananas&#34;.to_string(), baz);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can also embed structs themselves:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use steel_vm::engine::Engine;&#xA;use steel_vm::register_fn::RegisterFn;&#xA;&#xA;use steel_derive::Steel;&#xA;&#xA;// In order to register a type with Steel,&#xA;// it must implement Clone, Debug, and Steel&#xA;#[derive(Clone, Debug, Steel, PartialEq)]&#xA;pub struct ExternalStruct {&#xA;    foo: usize,&#xA;    bar: String,&#xA;    baz: f64,&#xA;}&#xA;&#xA;impl ExternalStruct {&#xA;    pub fn new(foo: usize, bar: String, baz: f64) -&amp;gt; Self {&#xA;        ExternalStruct { foo, bar, baz }&#xA;    }&#xA;&#xA;    // Embedding functions that take self by value&#xA;    pub fn method_by_value(self) -&amp;gt; usize {&#xA;        self.foo&#xA;    }&#xA;&#xA;    pub fn method_by_reference(&amp;amp;self) -&amp;gt; usize {&#xA;        self.foo&#xA;    }&#xA;&#xA;    // Setters should update the value and return a new instance (functional set)&#xA;    pub fn set_foo(mut self, foo: usize) -&amp;gt; Self {&#xA;        self.foo = foo;&#xA;        self&#xA;    }&#xA;}&#xA;&#xA;pub fn main() {&#xA;    let mut vm = Engine::new();&#xA;&#xA;    // Registering a type gives access to a predicate for the type&#xA;    vm.register_type::&amp;lt;ExternalStruct&amp;gt;(&#34;ExternalStruct?&#34;);&#xA;&#xA;    // Structs in steel typically have a constructor that is the name of the struct&#xA;    vm.register_fn(&#34;ExternalStruct&#34;, ExternalStruct::new);&#xA;&#xA;    // register_fn can be chained&#xA;    vm.register_fn(&#34;method-by-value&#34;, ExternalStruct::method_by_value)&#xA;        .register_fn(&#34;method-by-reference&#34;, ExternalStruct::method_by_reference)&#xA;        .register_fn(&#34;set-foo&#34;, ExternalStruct::set_foo);&#xA;&#xA;    let external_struct = ExternalStruct::new(1, &#34;foo&#34;.to_string(), 12.4);&#xA;&#xA;    // Registering an external value is fallible if the conversion fails for some reason&#xA;    // For instance, registering an Err(T) is fallible. However, most implementation outside of manual&#xA;    // ones should not fail&#xA;    vm.register_external_value(&#34;external-struct&#34;, external_struct)&#xA;        .unwrap();&#xA;&#xA;    let output = vm&#xA;        .run(&#xA;            r#&#34;&#xA;            (define new-external-struct (set-foo external-struct 100))&#xA;            (define get-output (method-by-value external-struct))&#xA;            (define second-new-external-struct (ExternalStruct 50 &#34;bananas&#34; 72.6))&#xA;            &#34;last-result&#34;&#xA;        &#34;#,&#xA;        )&#xA;        .unwrap();&#xA;&#xA;    let new_external_struct = vm.extract::&amp;lt;ExternalStruct&amp;gt;(&#34;new-external-struct&#34;).unwrap();&#xA;    println!(&#34;new_external_struct: {:?}&#34;, new_external_struct);&#xA;    assert_eq!(&#xA;        ExternalStruct::new(100, &#34;foo&#34;.to_string(), 12.4),&#xA;        new_external_struct&#xA;    );&#xA;&#xA;    // Can also extract a value by specifying the type on the variable&#xA;    let get_output: usize = vm.extract(&#34;get-output&#34;).unwrap();&#xA;    println!(&#34;get_output: {}&#34;, get_output);&#xA;    assert_eq!(1, get_output);&#xA;&#xA;    let second_new_external_struct: ExternalStruct =&#xA;        vm.extract(&#34;second-new-external-struct&#34;).unwrap();&#xA;    println!(&#xA;        &#34;second_new_external_struct: {:?}&#34;,&#xA;        second_new_external_struct&#xA;    );&#xA;    assert_eq!(&#xA;        ExternalStruct::new(50, &#34;bananas&#34;.to_string(), 72.6),&#xA;        second_new_external_struct&#xA;    );&#xA;&#xA;    // We also get the output of the VM as the value of every expression run&#xA;    // we can inspect the results just by printing like so&#xA;    println!(&#34;{:?}&#34;, output);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the examples folder for more examples on embedding values and interacting with the outside world.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apache License, Version 2.0 (&lt;a href=&#34;https://raw.githubusercontent.com/mattwparas/steel/master/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; or &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;MIT license (&lt;a href=&#34;https://raw.githubusercontent.com/mattwparas/steel/master/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; or &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your option.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/mattwparas/steel/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>BlackSnufkin/GhostDriver</title>
    <updated>2023-12-06T01:39:51Z</updated>
    <id>tag:github.com,2023-12-06:/BlackSnufkin/GhostDriver</id>
    <link href="https://github.com/BlackSnufkin/GhostDriver" rel="alternate"></link>
    <summary type="html">&lt;p&gt;yet another AV killer tool using BYOVD&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;GhostDriver ðŸ‘»&lt;/h1&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;GhostDriver is a Rust-built AV killer tool using BYOVD.&lt;/p&gt; &#xA;&lt;h2&gt;Get Started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Install Rust from &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;rust-lang.org&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Clone: &lt;code&gt;git clone https://github.com/BlackSnufkin/GhostDriver.git&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Build: &lt;code&gt;cargo build --release --target=x86_64-pc-windows-msvc&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Run: Execute the GhostDriver binary&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;POC&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/BlackSnufkin/GhostDriver/assets/61916899/7db7ef4f-b508-431a-8dbc-91861a197599&#34; alt=&#34;poc&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Reference&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/keowu/BadRentdrv2&#34;&gt;https://github.com/keowu/BadRentdrv2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://unit42.paloaltonetworks.com/agonizing-serpens-targets-israeli-tech-higher-ed-sectors&#34;&gt;https://unit42.paloaltonetworks.com/agonizing-serpens-targets-israeli-tech-higher-ed-sectors&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>ikatson/rqbit</title>
    <updated>2023-12-06T01:39:51Z</updated>
    <id>tag:github.com,2023-12-06:/ikatson/rqbit</id>
    <link href="https://github.com/ikatson/rqbit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A bittorrent client in Rust&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/rqbit&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/rqbit.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/librqbit&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/librqbit.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/librqbit/latest/librqbit/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/librqbit.svg?sanitize=true&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;rqbit - bittorrent client in Rust&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;rqbit&lt;/strong&gt; is a bittorrent client written entirely in Rust. Has HTTP API and Web UI, and can be used as a library.&lt;/p&gt; &#xA;&lt;p&gt;Also has a desktop app built with &lt;a href=&#34;https://tauri.app/&#34;&gt;Tauri&lt;/a&gt; (on Windows and OSX).&lt;/p&gt; &#xA;&lt;h2&gt;Usage quick start&lt;/h2&gt; &#xA;&lt;h3&gt;Optional - start the server&lt;/h3&gt; &#xA;&lt;p&gt;Assuming you are downloading to ~/Downloads.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rqbit server start ~/Downloads&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Download torrents&lt;/h3&gt; &#xA;&lt;p&gt;Assuming you are downloading to ~/Downloads. If the server is already started, &lt;code&gt;-o ~/Downloads&lt;/code&gt; can be omitted.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rqbit download -o ~/Downloads &#39;magnet:?....&#39; [https?://url/to/.torrent] [/path/to/local/file.torrent]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Web UI&lt;/h2&gt; &#xA;&lt;p&gt;Access with &lt;a href=&#34;http://localhost:3030/web/&#34;&gt;http://localhost:3030/web/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img width=&#34;995&#34; alt=&#34;Screenshot 2023-11-27 at 09 30 10&#34; src=&#34;https://github.com/ikatson/rqbit/assets/221386/d9403763-d162-492b-a718-a857ef4dd1e6&#34;&gt; &#xA;&lt;h2&gt;Desktop app&lt;/h2&gt; &#xA;&lt;p&gt;The desktop app is a &lt;a href=&#34;https://github.com/ikatson/rqbit/raw/main/desktop/src-tauri/src/main.rs&#34;&gt;thin wrapper&lt;/a&gt; on top of the Web UI frontend.&lt;/p&gt; &#xA;&lt;p&gt;Download it in &lt;a href=&#34;https://github.com/ikatson/rqbit/releases&#34;&gt;Releases&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;There are pre-built binaries in &lt;a href=&#34;https://github.com/ikatson/rqbit/releases&#34;&gt;Releases&lt;/a&gt;. If someone wants to put rqbit into e.g. homebrew, PRs welcome :)&lt;/p&gt; &#xA;&lt;p&gt;If you have rust toolchain installed, this should work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo install rqbit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;Just a regular Rust binary build process.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Useful options&lt;/h2&gt; &#xA;&lt;h3&gt;-v &#xA; &lt;log-level&gt;&lt;/log-level&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Increase verbosity. Possible values: trace, debug, info, warn, error.&lt;/p&gt; &#xA;&lt;h3&gt;--list&lt;/h3&gt; &#xA;&lt;p&gt;Will print the contents of the torrent file or the magnet link.&lt;/p&gt; &#xA;&lt;h3&gt;--overwrite&lt;/h3&gt; &#xA;&lt;p&gt;If you want to resume downloading a file that already exists, you&#39;ll need to add this option.&lt;/p&gt; &#xA;&lt;h3&gt;--peer-connect-timeout=10s&lt;/h3&gt; &#xA;&lt;p&gt;This will increase the default peer connect timeout. The default one is 2 seconds, and it&#39;s sometimes not enough.&lt;/p&gt; &#xA;&lt;h3&gt;-r / --filename-re&lt;/h3&gt; &#xA;&lt;p&gt;Use a regex here to select files by their names.&lt;/p&gt; &#xA;&lt;h2&gt;Features and missing features&lt;/h2&gt; &#xA;&lt;h3&gt;Some supported features&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Sequential downloading (the default and only option)&lt;/li&gt; &#xA; &lt;li&gt;Resume downloading file(s) if they already exist on disk&lt;/li&gt; &#xA; &lt;li&gt;Selective downloading using a regular expression for filename&lt;/li&gt; &#xA; &lt;li&gt;DHT support. Allows magnet links to work, and makes more peers available.&lt;/li&gt; &#xA; &lt;li&gt;HTTP API&lt;/li&gt; &#xA; &lt;li&gt;Pausing / unpausing / deleting (with files or not) APIs&lt;/li&gt; &#xA; &lt;li&gt;Stateful server&lt;/li&gt; &#xA; &lt;li&gt;Web UI&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Bugs, missing features and other caveats&lt;/h3&gt; &#xA;&lt;p&gt;PRs are very welcome.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Only supports BitTorrent V1 over TCP&lt;/li&gt; &#xA; &lt;li&gt;As this was created for personal needs, and for educational purposes, documentation, commit message quality etc. leave a lot to be desired.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;HTTP API&lt;/h2&gt; &#xA;&lt;p&gt;By default it listens on &lt;a href=&#34;http://127.0.0.1:3030&#34;&gt;http://127.0.0.1:3030&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;curl -s &#39;http://127.0.0.1:3030/&#39;&#xA;&#xA;{&#xA;    &#34;apis&#34;: {&#xA;        &#34;GET /&#34;: &#34;list all available APIs&#34;,&#xA;        &#34;GET /dht/stats&#34;: &#34;DHT stats&#34;,&#xA;        &#34;GET /dht/table&#34;: &#34;DHT routing table&#34;,&#xA;        &#34;GET /torrents&#34;: &#34;List torrents (default torrent is 0)&#34;,&#xA;        &#34;GET /torrents/{index}&#34;: &#34;Torrent details&#34;,&#xA;        &#34;GET /torrents/{index}/haves&#34;: &#34;The bitfield of have pieces&#34;,&#xA;        &#34;GET /torrents/{index}/peer_stats&#34;: &#34;Per peer stats&#34;,&#xA;        &#34;GET /torrents/{index}/stats/v1&#34;: &#34;Torrent stats&#34;,&#xA;        &#34;GET /web/&#34;: &#34;Web UI&#34;,&#xA;        &#34;POST /rust_log&#34;: &#34;Set RUST_LOG to this post launch (for debugging)&#34;,&#xA;        &#34;POST /torrents&#34;: &#34;Add a torrent here. magnet: or http:// or a local file.&#34;,&#xA;        &#34;POST /torrents/{index}/delete&#34;: &#34;Forget about the torrent, remove the files&#34;,&#xA;        &#34;POST /torrents/{index}/forget&#34;: &#34;Forget about the torrent, keep the files&#34;,&#xA;        &#34;POST /torrents/{index}/pause&#34;: &#34;Pause torrent&#34;,&#xA;        &#34;POST /torrents/{index}/start&#34;: &#34;Resume torrent&#34;&#xA;    },&#xA;    &#34;server&#34;: &#34;rqbit&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Add torrent through HTTP API&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;curl -d &#39;magnet:?...&#39; http://127.0.0.1:3030/torrents&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;OR&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;curl -d &#39;http://.../file.torrent&#39; http://127.0.0.1:3030/torrents&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;OR&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;curl --data-binary @/tmp/xubuntu-23.04-minimal-amd64.iso.torrent http://127.0.0.1:3030/torrents&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Supported query parameters, all optional:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;overwrite=true|false&lt;/li&gt; &#xA; &lt;li&gt;only_files_regex - the regular expression string to match filenames&lt;/li&gt; &#xA; &lt;li&gt;output_folder - the folder to download to. If not specified, defaults to the one that rqbit server started with&lt;/li&gt; &#xA; &lt;li&gt;list_only=true|false - if you want to just list the files in the torrent instead of downloading&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Code organization&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;crates/rqbit - main binary&lt;/li&gt; &#xA; &lt;li&gt;crates/librqbit - main library&lt;/li&gt; &#xA; &lt;li&gt;crates/librqbit-core - torrent utils&lt;/li&gt; &#xA; &lt;li&gt;crates/bencode - bencode serializing/deserializing&lt;/li&gt; &#xA; &lt;li&gt;crates/buffers - wrappers around binary buffers&lt;/li&gt; &#xA; &lt;li&gt;crates/clone_to_owned - a trait to make something owned&lt;/li&gt; &#xA; &lt;li&gt;crates/sha1w - wrappers around sha1 libraries&lt;/li&gt; &#xA; &lt;li&gt;crates/peer_binary_protocol - the protocol to talk to peers&lt;/li&gt; &#xA; &lt;li&gt;crates/dht - Distributed Hash Table implementation&lt;/li&gt; &#xA; &lt;li&gt;desktop - desktop app built with &lt;a href=&#34;https://tauri.app/&#34;&gt;Tauri&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Motivation&lt;/h2&gt; &#xA;&lt;p&gt;First of all, I love Rust. The project was created purely for the fun of the process of writing code in Rust.&lt;/p&gt; &#xA;&lt;p&gt;I was not satisfied with my regular bittorrent client, and was wondering how much work would it be to create a new one from scratch, and it got where it is, starting from bencode protocol implemenation, then peer protocol, etc, etc.&lt;/p&gt;</summary>
  </entry>
</feed>