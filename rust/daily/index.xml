<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-27T01:43:59Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>econaxis/time2reach</title>
    <updated>2023-07-27T01:43:59Z</updated>
    <id>tag:github.com,2023-07-27:/econaxis/time2reach</id>
    <link href="https://github.com/econaxis/time2reach" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Public-transit travel time map&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/econaxis/time2reach/main/image.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Time To Reach - Transit Travel-time Map&lt;/h1&gt; &#xA;&lt;p&gt;It&#39;s a travel-time map for public transit that shows which areas of the city are most accessible by public transit.&lt;/p&gt; &#xA;&lt;p&gt;I built this while trying to look for housing in Toronto. I found myself going back and forth on Google Maps trying to compare which locations have a shorter commute via transit. I completed this project long after I found a place, but hopefully it helps someone else.&lt;/p&gt; &#xA;&lt;h1&gt;How it works&lt;/h1&gt; &#xA;&lt;p&gt;The app consists of a Rust backend which queries the transit schedule data (in GTFS format) and a React frontend which displays the map and colors each road segment according to how long it takes to reach that segment from the origin.&lt;/p&gt; &#xA;&lt;h2&gt;Generating times to reach for each road&lt;/h2&gt; &#xA;&lt;p&gt;The backend uses heuristics-based BFS search on each trip from the origin. At all stops along that trip (&lt;code&gt;time_to_reach.rs:all_stops_along_trip()&lt;/code&gt;), we &#34;disembark&#34; and see what other routes we can take from that stop (&lt;code&gt;time_to_reach.rs:explore_from_point()&lt;/code&gt;). For each possible new route, we do the same thing: get on and along all stops, see what other new connections can be made.&lt;/p&gt; &#xA;&lt;p&gt;There are some heuristics to make each query faster:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We only get off a stop if we haven&#39;t reached that stop before (or we have reached it before but at a &lt;em&gt;worse time&lt;/em&gt;).&lt;/li&gt; &#xA; &lt;li&gt;Rather than using a queue like in traditional BFS, we prioritize exploring train/subway routes first, as they are faster and result in less work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Rendering the tiles&lt;/h2&gt; &#xA;&lt;p&gt;I used an approach similar to how Google Maps displays traffic congestion (red, yellow, green). I used the Python library OSMnx (&lt;code&gt;download_gpkg.py:generate_geopackage_all_cities&lt;/code&gt;) to download road vectors from OpenStreetMaps and loaded them into a PostGIS database.&lt;/p&gt; &#xA;&lt;p&gt;Using Mapbox&#39;s vector tile sources and Expressions feature, I could color these road segments based on their ID:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;map.setPaintProperty(&#34;transit-layer&#34;, &#34;line-color&#34;,&#xA;    [&#34;get&#34;, [&#34;to-string&#34;, [&#34;id&#34;]], [&#34;literal&#34;, timeToReachData]],&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;timeToReachData&lt;/code&gt; converts road segment IDs to a color, based on how long it takes to reach that segment.&lt;/p&gt; &#xA;&lt;h2&gt;Drawing paths&lt;/h2&gt; &#xA;&lt;p&gt;When you hover over any particular point, the app draws the path from the origin. The path shows you which buses or trains to take. We cache the results of the BFS search as a tree of individual vehicle trips. For example, if all destinations require you to take the Line 1 Subway, we only store that trip once. If a trip is a transfer from a previous trip, we store the Id of the parent trip in &lt;code&gt;InProcessTrip.previous_transfer&lt;/code&gt; (&lt;code&gt;in_progress_trip.rs&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;When you hover over a point, we simply traverse the tree backwards via the &lt;code&gt;previous_transfer&lt;/code&gt; pointer until we reach the origin.&lt;/p&gt; &#xA;&lt;p&gt;This approach requires very little memory to store all the possible trips and their paths from the origin. Since these trips are immutable, we store them inside an &lt;code&gt;Arena&lt;/code&gt; to avoid lifetime problems. Since Arenas store trips contiguously, we also don&#39;t experience memory fragmentation problems that come with large trees. Freeing the memory of the tree is also incredibly performant, as we just clear the memory of the Arena.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>apache/iceberg-rust</title>
    <updated>2023-07-27T01:43:59Z</updated>
    <id>tag:github.com,2023-07-27:/apache/iceberg-rust</id>
    <link href="https://github.com/apache/iceberg-rust" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Apache Iceberg&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Apache Iceberg Rust&lt;/h1&gt; &#xA;&lt;p&gt;Native Rust implementation of &lt;a href=&#34;https://iceberg.apache.org/&#34;&gt;Apache Iceberg&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contribute&lt;/h2&gt; &#xA;&lt;p&gt;Iceberg is an active open-source project. We are always open to people who want to use it or contribute to it. Here are some ways to go.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Start with &lt;a href=&#34;https://raw.githubusercontent.com/apache/iceberg-rust/main/CONTRIBUTING.md&#34;&gt;Contributing Guide&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Submit &lt;a href=&#34;https://github.com/apache/iceberg-rust/issues/new&#34;&gt;Issues&lt;/a&gt; for bug report or feature requests.&lt;/li&gt; &#xA; &lt;li&gt;Discuss at &lt;a href=&#34;mailto:dev@iceberg.apache.org&#34;&gt;dev mailing list&lt;/a&gt; (&lt;a href=&#34;mailto:dev-subscribe@iceberg.apache.org?subject=(send%20this%20email%20to%20subscribe)&#34;&gt;subscribe&lt;/a&gt; / &lt;a href=&#34;mailto:dev-unsubscribe@iceberg.apache.org?subject=(send%20this%20email%20to%20unsubscribe)&#34;&gt;unsubscribe&lt;/a&gt; / &lt;a href=&#34;https://lists.apache.org/list.html?dev@iceberg.apache.org&#34;&gt;archives&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Talk to community directly at &lt;a href=&#34;https://join.slack.com/t/apache-iceberg/shared_invite/zt-1zbov3k6e-KtJfoaxp97YfX6dPz1Bk7A&#34;&gt;Slack #rust channel&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under the &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache License, Version 2.0&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>powdr-labs/powdr</title>
    <updated>2023-07-27T01:43:59Z</updated>
    <id>tag:github.com,2023-07-27:/powdr-labs/powdr</id>
    <link href="https://github.com/powdr-labs/powdr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A modular stack for zkVMs, with a focus on productivity, security and performance.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;powdr&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://matrix.to/#/#powdr:matrix.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Matrix%20-chat-brightgreen?style=plastic&amp;amp;logo=matrix&#34; alt=&#34;Matrix Chat&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://twitter.com/powdr_labs&#34;&gt;&lt;img src=&#34;https://img.shields.io/twitter/follow/powdr_labs?style=plastic&amp;amp;logo=twitter&#34; alt=&#34;Twitter Follow&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;powdr&lt;/em&gt; is an extended polynomial identity (PIL) and zk-focused assembly (zkASM) language written in Rust, focused on modularity and excellent developer experience.&lt;/p&gt; &#xA;&lt;p&gt;WARNING: This is a proof-of-concept implementation. It is missing many internal checks. DO NOT USE FOR PRODUCTION!&lt;/p&gt; &#xA;&lt;h2&gt;Basic Concept&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;powdr&lt;/em&gt; is a toolkit that helps build zkVMs and similar proof frameworks.&lt;/p&gt; &#xA;&lt;p&gt;It has two main components:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A polynomial identity language that allows you to define polynomial constraints, lookups, etc.&lt;/li&gt; &#xA; &lt;li&gt;An extensible assembly language to perform dynamic executions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both frontend and backend are highly flexible.&lt;/p&gt; &#xA;&lt;p&gt;As an example, &lt;em&gt;powdr&lt;/em&gt; contains a frontend that enables you to write code in (no-std) Rust, which is compiled to RISCV, then to powdr-asm and finally to PIL.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;powdr&lt;/em&gt;-PIL can be used to generate proofs using multiple backends, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Halo2&lt;/li&gt; &#xA; &lt;li&gt;eSTARKs: &lt;em&gt;powdr&lt;/em&gt;-PIL is fully compatible with the eSTARKS backend from Polygon Hermez, although not yet fully integrated in an automatic way.&lt;/li&gt; &#xA; &lt;li&gt;Nova: ongoing work, should be ready after soon.&lt;/li&gt; &#xA; &lt;li&gt;other STARKs: maybe?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All stages are fully automatic, which means you do not need to write any additional code for witness generation besides your Rust code. All witnesses are automatically inferred from the constraints. Since the witnesses are inferred, &lt;em&gt;powdr&lt;/em&gt; can ensure that the system is not underconstrained, i.e. there are no additional unwanted witnesses.&lt;/p&gt; &#xA;&lt;p&gt;All artifacts from the compilation pipeline are human-readable. This means you can inspect the RISCV assembly files, the powdr-asm, and the PIL file.&lt;/p&gt; &#xA;&lt;p&gt;The assembly language is designed to be extensible. This means that it does not have a single native instruction. Instead, all instructions are user-defined and because of that, it is easy to adapt &lt;em&gt;powdr&lt;/em&gt; assembly to any VM.&lt;/p&gt; &#xA;&lt;h2&gt;How to run the Rust-RISCV example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Install the riscv target for the rust compiler&#xA;rustup target add riscv32imc-unknown-none-elf&#xA;# Run the compiler. It will generate files in /tmp/.&#xA;# -i specifies the prover witness input (see below)&#xA;cargo run --release rust riscv/tests/riscv_data/sum.rs -o /tmp -f -i 10,2,4,6 &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The following example Rust file verifies that a supplied list of integers sums up to a specified value. Note that this is the full and only input file you need for the whole process!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#![no_std]&#xA;&#xA;extern crate alloc;&#xA;use alloc::vec::Vec;&#xA;&#xA;use runtime::get_prover_input;&#xA;&#xA;#[no_mangle]&#xA;pub fn main() {&#xA;    // This is the sum claimed by the prover.&#xA;    let proposed_sum = get_prover_input(0);&#xA;    // The number of integers we want to sum.&#xA;    let len = get_prover_input(1) as usize;&#xA;    // Read the numbers from the prover and store them&#xA;    // in a vector.&#xA;    let data: Vec&amp;lt;_&amp;gt; = (2..(len + 2))&#xA;        .map(|idx| get_prover_input(idx as u32))&#xA;        .collect();&#xA;    // Compute the sum.&#xA;    let sum: u32 = data.iter().sum();&#xA;    // Check that our sum matches the prover&#39;s.&#xA;    assert_eq!(sum, proposed_sum);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function &lt;code&gt;get_prover_input&lt;/code&gt; reads a number from the list supplied with &lt;code&gt;-i&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is just a first mechanism to provide access to the outside world. The plan is to be able to call arbitrary user-defined &lt;code&gt;ffi&lt;/code&gt; functions that will translate to prover queries, and can then ask for e.g. the value of a storage slot at a certain address or the root hash of a merkle tree.&lt;/p&gt; &#xA;&lt;h3&gt;Notes on Efficiency&lt;/h3&gt; &#xA;&lt;p&gt;Currently, the code is extremely wasteful. It generates many unnecessary columns. The idea is to first see if automatic witness generation is possible in general. If this is confirmed, various optimizer stages will be built to reduce the column (and row) count automatically.&lt;/p&gt; &#xA;&lt;h3&gt;Project structure&lt;/h3&gt; &#xA;&lt;p&gt;For an overview of the project structure, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo doc --workspace --no-deps --open&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>