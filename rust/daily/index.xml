<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-24T01:40:51Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hexagonal-sun/ampkt</title>
    <updated>2023-09-24T01:40:51Z</updated>
    <id>tag:github.com,2023-09-24:/hexagonal-sun/ampkt</id>
    <link href="https://github.com/hexagonal-sun/ampkt" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Amateur radio packet experimentation framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;AMPKT - Amateur radio packet explorer&lt;/h1&gt; &#xA;&lt;p&gt;This is a project to facilitate experimentation with connecting two Linux machine&#39;s network stacks via the amateur radio bands.&lt;/p&gt; &#xA;&lt;h2&gt;Required Hardware&lt;/h2&gt; &#xA;&lt;p&gt;You will need two full-duplex SDRs, one for each machine. They will also need to be compatible with SoapySDR.&lt;/p&gt; &#xA;&lt;p&gt;Hardware that is known to work:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;USRP N210&lt;/li&gt; &#xA; &lt;li&gt;BladeRF&lt;/li&gt; &#xA; &lt;li&gt;LimeSDR&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Build the project:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;Connect your SDR hardware and start the &lt;code&gt;ampkt&lt;/code&gt; binary (note that you will probably need to run with &lt;code&gt;sudo&lt;/code&gt; so that the &lt;code&gt;tap&lt;/code&gt; interface can be created):&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;sudo ./target/release/ampkt &#34;driver=bladerf&#34; 433000000 435000000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will start ampkt using bladerf hardware, Txing on 433MHz and Rxing on 435MHz.&lt;/p&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;On a second machine do the same, ensuring that you swap the frequencies.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;On both machines, bring up the tap interface and assign an IP address:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;sudo ifconfig tap0 up&#xA;sudo ip add 10.0.0.1/24 dev tap0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Making sure you use a different IP address on the other machine.&lt;/p&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;At this point you should have working comms. You can check running &lt;code&gt;ping&lt;/code&gt;and seeing whether you get a reply from the other machine&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;ping 10.0.0.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Technical Information&lt;/h2&gt; &#xA;&lt;p&gt;A Linux &lt;a href=&#34;https://www.kernel.org/doc/html/v5.8/networking/tuntap.html&#34;&gt;TAP&lt;/a&gt; interface is created. This interface is used as the sink for the RX path and the source for the TX path.&lt;/p&gt; &#xA;&lt;h3&gt;Tx Path&lt;/h3&gt; &#xA;&lt;p&gt;Each incoming packet that is read from the tap interface is converted into a frame. The frame consists of a sync header (repeated twice) a frame size (as u16) followed by the packet data. We then convert the frame to a stream of symbols. We use QPSK modulation which means we have two bits per symbol. Each 2-bit nibble is converted into a symbol using the following map:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;A =&amp;gt; 0b00&#xA;B =&amp;gt; 0b01&#xA;C =&amp;gt; 0b10&#xA;D =&amp;gt; 0b11&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We then module the symbol stream into QPSK with the following constellation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;       Im&#xA;       |&#xA;    B  |   A&#xA;       |&#xA;       |&#xA;-------------&amp;gt; re&#xA;       |&#xA;       |&#xA;    D  |   C&#xA;       |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output of the QPSK modulator is then sent to the SDR for Tx.&lt;/p&gt; &#xA;&lt;h3&gt;Rx Path&lt;/h3&gt; &#xA;&lt;p&gt;Samples from the SDR are first sent into the clock sync block. This block decimates the incoming stream by selection of particular samples from the input stream. The number of samples that are &#39;skipped&#39; during selection is shifted by an error function which attempts to pick the sample at the peak of a symbol.&lt;/p&gt; &#xA;&lt;p&gt;The decimated stream is then sent into the carrier sync block. This attempts to compensate for any difference in clocks between the SDRs by &#39;de-reotating&#39; the constellation. When this block has &#39;locked&#39; the output should be stable samples in each quadrent of the constellation plot.&lt;/p&gt; &#xA;&lt;p&gt;Next, the samples passed through the QPSK demodulator which converts the samples into a stream of symbols.&lt;/p&gt; &#xA;&lt;p&gt;The symbol stream is then passed through a frame decoder. This block attempts to create the original packet of data from a stream of symbols. We use a SYNC header of 16-bytes (repeated twice) to resolve the phase ambiguity. Then the computed difference in phase is applied to all incoming symbols to decode the frame.&lt;/p&gt; &#xA;&lt;p&gt;Finally the frames are written to the TAP interface for injection into the Linux kernel network stack.&lt;/p&gt;</summary>
  </entry>
</feed>