<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-16T01:44:10Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>cloudflare/workers-rs</title>
    <updated>2023-11-16T01:44:10Z</updated>
    <id>tag:github.com,2023-11-16:/cloudflare/workers-rs</id>
    <link href="https://github.com/cloudflare/workers-rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Write Cloudflare Workers in 100% Rust via WebAssembly&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/cloudflare/workers-rs/main/.github/logo.png&#34; alt=&#34;workers-rs&#34;&gt; &lt;a href=&#34;https://crates.io/crates/worker&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/worker&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/worker&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/worker&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Work-in-progress&lt;/strong&gt; ergonomic Rust bindings to Cloudflare Workers environment. Write your entire worker in Rust!&lt;/p&gt; &#xA;&lt;p&gt;Read the &lt;a href=&#34;https://raw.githubusercontent.com/cloudflare/workers-rs/main/#notes-and-faq&#34;&gt;Notes and FAQ&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Example Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use worker::*;&#xA;&#xA;#[event(fetch)]&#xA;pub async fn main(req: Request, env: Env, _ctx: worker::Context) -&amp;gt; Result&amp;lt;Response&amp;gt; {&#xA;    console_log!(&#xA;        &#34;{} {}, located at: {:?}, within: {}&#34;,&#xA;        req.method().to_string(),&#xA;        req.path(),&#xA;        req.cf().unwrap().coordinates().unwrap_or_default(),&#xA;        req.cf().unwrap().region().unwrap_or(&#34;unknown region&#34;.into())&#xA;    );&#xA;&#xA;    if !matches!(req.method(), Method::Post) {&#xA;        return Response::error(&#34;Method Not Allowed&#34;, 405);&#xA;    }&#xA;&#xA;    if let Some(file) = req.form_data().await?.get(&#34;file&#34;) {&#xA;        return match file {&#xA;            FormEntry::File(buf) =&amp;gt; {&#xA;                Response::ok(&amp;amp;format!(&#34;size = {}&#34;, buf.bytes().await?.len()))&#xA;            }&#xA;            _ =&amp;gt; Response::error(&#34;`file` part of POST form must be a file&#34;, 400),&#xA;        };&#xA;    }&#xA;&#xA;    Response::error(&#34;Bad Request&#34;, 400)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Or use the &lt;code&gt;Router&lt;/code&gt;:&lt;/h3&gt; &#xA;&lt;p&gt;Parameterize routes and access the parameter values from within a handler. Each handler function takes a &lt;code&gt;Request&lt;/code&gt;, and a &lt;code&gt;RouteContext&lt;/code&gt;. The &lt;code&gt;RouteContext&lt;/code&gt; has shared data, route params, &lt;code&gt;Env&lt;/code&gt; bindings, and more.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use worker::*;&#xA;&#xA;#[event(fetch)]&#xA;pub async fn main(req: Request, env: Env, _ctx: worker::Context) -&amp;gt; Result&amp;lt;Response&amp;gt; {&#xA;&#xA;    // Create an instance of the Router, which can use parameters (/user/:name) or wildcard values&#xA;    // (/file/*pathname). Alternatively, use `Router::with_data(D)` and pass in arbitrary data for&#xA;    // routes to access and share using the `ctx.data()` method.&#xA;    let router = Router::new();&#xA;&#xA;    // useful for JSON APIs&#xA;    #[derive(Deserialize, Serialize)]&#xA;    struct Account {&#xA;        id: u64,&#xA;        // ...&#xA;    }&#xA;    router&#xA;        .get_async(&#34;/account/:id&#34;, |_req, ctx| async move {&#xA;            if let Some(id) = ctx.param(&#34;id&#34;) {&#xA;                let accounts = ctx.kv(&#34;ACCOUNTS&#34;)?;&#xA;                return match accounts.get(id).json::&amp;lt;Account&amp;gt;().await? {&#xA;                    Some(account) =&amp;gt; Response::from_json(&amp;amp;account),&#xA;                    None =&amp;gt; Response::error(&#34;Not found&#34;, 404),&#xA;                };&#xA;            }&#xA;&#xA;            Response::error(&#34;Bad Request&#34;, 400)&#xA;        })&#xA;        // handle files and fields from multipart/form-data requests&#xA;        .post_async(&#34;/upload&#34;, |mut req, _ctx| async move {&#xA;            let form = req.form_data().await?;&#xA;            if let Some(entry) = form.get(&#34;file&#34;) {&#xA;                match entry {&#xA;                    FormEntry::File(file) =&amp;gt; {&#xA;                        let bytes = file.bytes().await?;&#xA;                    }&#xA;                    FormEntry::Field(_) =&amp;gt; return Response::error(&#34;Bad Request&#34;, 400),&#xA;                }&#xA;                // ...&#xA;&#xA;                if let Some(permissions) = form.get(&#34;permissions&#34;) {&#xA;                    // permissions == &#34;a,b,c,d&#34;&#xA;                }&#xA;                // or call `form.get_all(&#34;permissions&#34;)` if using multiple entries per field&#xA;            }&#xA;&#xA;            Response::error(&#34;Bad Request&#34;, 400)&#xA;        })&#xA;        // read/write binary data&#xA;        .post_async(&#34;/echo-bytes&#34;, |mut req, _ctx| async move {&#xA;            let data = req.bytes().await?;&#xA;            if data.len() &amp;lt; 1024 {&#xA;                return Response::error(&#34;Bad Request&#34;, 400);&#xA;            }&#xA;&#xA;            Response::from_bytes(data)&#xA;        })&#xA;        .run(req, env).await&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;The project uses &lt;a href=&#34;https://github.com/cloudflare/wrangler2&#34;&gt;wrangler&lt;/a&gt; version 2.x for running and publishing your Worker.&lt;/p&gt; &#xA;&lt;p&gt;Get the Rust worker project &lt;a href=&#34;https://github.com/cloudflare/workers-sdk/tree/main/templates/experimental/worker-rust&#34;&gt;template&lt;/a&gt; manually, or run the following command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm init cloudflare project_name worker-rust&#xA;cd project_name&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You should see a new project layout with a &lt;code&gt;src/lib.rs&lt;/code&gt;. Start there! Use any local or remote crates and modules (as long as they compile to the &lt;code&gt;wasm32-unknown-unknown&lt;/code&gt; target).&lt;/p&gt; &#xA;&lt;p&gt;Once you&#39;re ready to run your project:&lt;/p&gt; &#xA;&lt;p&gt;First check that the wrangler version is 2.x&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npx wrangler --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, run your worker&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npx wrangler dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Finally, go live:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# configure your routes, zones &amp;amp; more in your worker&#39;s `wrangler.toml` file&#xA;npx wrangler publish&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you would like to have &lt;code&gt;wrangler&lt;/code&gt; installed on your machine, see instructions in &lt;a href=&#34;https://github.com/cloudflare/wrangler2&#34;&gt;wrangler repository&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Durable Object, KV, Secret, &amp;amp; Variable Bindings&lt;/h2&gt; &#xA;&lt;p&gt;All &#34;bindings&#34; to your script (Durable Object &amp;amp; KV Namespaces, Secrets, and Variables) are accessible from the &lt;code&gt;env&lt;/code&gt; parameter provided to both the entrypoint (&lt;code&gt;main&lt;/code&gt; in this example), and to the route handler callback (in the &lt;code&gt;ctx&lt;/code&gt; argument), if you use the &lt;code&gt;Router&lt;/code&gt; from the &lt;code&gt;worker&lt;/code&gt; crate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use worker::*;&#xA;&#xA;#[event(fetch, respond_with_errors)]&#xA;pub async fn main(req: Request, env: Env, _ctx: worker::Context) -&amp;gt; Result&amp;lt;Response&amp;gt; {&#xA;    utils::set_panic_hook();&#xA;&#xA;    let router = Router::new();&#xA;&#xA;    router&#xA;        .on_async(&#34;/durable&#34;, |_req, ctx| async move {&#xA;            let namespace = ctx.durable_object(&#34;CHATROOM&#34;)?;&#xA;            let stub = namespace.id_from_name(&#34;A&#34;)?.get_stub()?;&#xA;            stub.fetch_with_str(&#34;/messages&#34;).await&#xA;        })&#xA;        .get(&#34;/secret&#34;, |_req, ctx| {&#xA;            Response::ok(ctx.secret(&#34;CF_API_TOKEN&#34;)?.to_string())&#xA;        })&#xA;        .get(&#34;/var&#34;, |_req, ctx| {&#xA;            Response::ok(ctx.var(&#34;BUILD_NUMBER&#34;)?.to_string())&#xA;        })&#xA;        .post_async(&#34;/kv&#34;, |_req, ctx| async move {&#xA;            let kv = ctx.kv(&#34;SOME_NAMESPACE&#34;)?;&#xA;&#xA;            kv.put(&#34;key&#34;, &#34;value&#34;)?.execute().await?;&#xA;&#xA;            Response::empty()&#xA;        })&#xA;        .run(req, env).await&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information about how to configure these bindings, see:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developers.cloudflare.com/workers/cli-wrangler/configuration#keys&#34;&gt;https://developers.cloudflare.com/workers/cli-wrangler/configuration#keys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://developers.cloudflare.com/workers/learning/using-durable-objects#configuring-durable-object-bindings&#34;&gt;https://developers.cloudflare.com/workers/learning/using-durable-objects#configuring-durable-object-bindings&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Durable Objects&lt;/h2&gt; &#xA;&lt;h3&gt;Define a Durable Object in Rust&lt;/h3&gt; &#xA;&lt;p&gt;To define a Durable Object using the &lt;code&gt;worker&lt;/code&gt; crate you need to implement the &lt;code&gt;DurableObject&lt;/code&gt; trait on your own struct. Additionally, the &lt;code&gt;#[durable_object]&lt;/code&gt; attribute macro must be applied to &lt;em&gt;both&lt;/em&gt; your struct definition and the trait &lt;code&gt;impl&lt;/code&gt; block for it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use worker::*;&#xA;&#xA;#[durable_object]&#xA;pub struct Chatroom {&#xA;    users: Vec&amp;lt;User&amp;gt;,&#xA;    messages: Vec&amp;lt;Message&amp;gt;,&#xA;    state: State,&#xA;    env: Env, // access `Env` across requests, use inside `fetch`&#xA;}&#xA;&#xA;#[durable_object]&#xA;impl DurableObject for Chatroom {&#xA;    fn new(state: State, env: Env) -&amp;gt; Self {&#xA;        Self {&#xA;            users: vec![],&#xA;            messages: vec![],&#xA;            state: state,&#xA;            env,&#xA;        }&#xA;    }&#xA;&#xA;    async fn fetch(&amp;amp;mut self, _req: Request) -&amp;gt; Result&amp;lt;Response&amp;gt; {&#xA;        // do some work when a worker makes a request to this DO&#xA;        Response::ok(&amp;amp;format!(&#34;{} active users.&#34;, self.users.len()))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You&#39;ll need to &#34;migrate&#34; your worker script when it&#39;s published so that it is aware of this new Durable Object, and include a binding in your &lt;code&gt;wrangler.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Include the Durable Object binding type in you &lt;code&gt;wrangler.toml&lt;/code&gt; file:&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ...&#xA;&#xA;[durable_objects]&#xA;bindings = [&#xA;  { name = &#34;CHATROOM&#34;, class_name = &#34;Chatroom&#34; } # the `class_name` uses the Rust struct identifier name&#xA;]&#xA;&#xA;[[migrations]]&#xA;tag = &#34;v1&#34; # Should be unique for each entry&#xA;new_classes = [&#34;Chatroom&#34;] # Array of new classes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For more information about migrating your Durable Object as it changes, see the docs here: &lt;a href=&#34;https://developers.cloudflare.com/workers/learning/using-durable-objects#durable-object-migrations-in-wranglertoml&#34;&gt;https://developers.cloudflare.com/workers/learning/using-durable-objects#durable-object-migrations-in-wranglertoml&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Queues&lt;/h2&gt; &#xA;&lt;h3&gt;Enabling queues&lt;/h3&gt; &#xA;&lt;p&gt;As queues are in beta you need to enable the &lt;code&gt;queue&lt;/code&gt; feature flag.&lt;/p&gt; &#xA;&lt;p&gt;Enable it by adding it to the worker dependency in your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;worker = {version = &#34;...&#34;, features = [&#34;queue&#34;]}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example worker consuming and producing messages:&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use worker::*;&#xA;use serde::{Deserialize, Serialize};&#xA;#[derive(Serialize, Debug, Clone, Deserialize)]&#xA;pub struct MyType {&#xA;    foo: String,&#xA;    bar: u32,&#xA;}&#xA;&#xA;// Consume messages from a queue&#xA;#[event(queue)]&#xA;pub async fn main(message_batch: MessageBatch&amp;lt;MyType&amp;gt;, env: Env, _ctx: Context) -&amp;gt; Result&amp;lt;()&amp;gt; {&#xA;    // Get a queue with the binding &#39;my_queue&#39;&#xA;    let my_queue = env.queue(&#34;my_queue&#34;)?;&#xA;&#xA;    // Deserialize the message batch&#xA;    let messages = message_batch.messages()?;&#xA;&#xA;    // Loop through the messages&#xA;    for message in messages {&#xA;        // Log the message and meta data&#xA;        console_log!(&#xA;            &#34;Got message {:?}, with id {} and timestamp: {}&#34;,&#xA;            message.body,&#xA;            message.id,&#xA;            message.timestamp.to_string()&#xA;        );&#xA;&#xA;        // Send the message body to the other queue&#xA;        my_queue.send(&amp;amp;message.body).await?;&#xA;    }&#xA;&#xA;    // Retry all messages&#xA;    message_batch.retry_all();&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Testing with Miniflare&lt;/h2&gt; &#xA;&lt;p&gt;In order to test your Rust worker locally, the best approach is to use &lt;a href=&#34;https://github.com/cloudflare/miniflare&#34;&gt;Miniflare&lt;/a&gt;. However, because Miniflare is a Node package, you will need to write your end-to-end tests in JavaScript or TypeScript in your project. The official documentation for writing tests using Miniflare is &lt;a href=&#34;https://miniflare.dev/testing&#34;&gt;available here&lt;/a&gt;. This documentation being focused on JavaScript / TypeScript codebase, you will need to configure as follows to make it work with your Rust-based, WASM-generated worker:&lt;/p&gt; &#xA;&lt;h3&gt;Step 1: Add Wrangler and Miniflare to your &lt;code&gt;devDependencies&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install --save-dev wrangler miniflare&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Step 2: Build your worker before running the tests&lt;/h3&gt; &#xA;&lt;p&gt;Make sure that your worker is built before running your tests by calling the following in your build chain:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wrangler deploy --dry-run&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;By default, this should build your worker under the &lt;code&gt;./build/&lt;/code&gt; directory at the root of your project.&lt;/p&gt; &#xA;&lt;h3&gt;Step 3: Configure your Miniflare instance in your JavaScript / TypeScript tests&lt;/h3&gt; &#xA;&lt;p&gt;To instantiate the &lt;code&gt;Miniflare&lt;/code&gt; testing instance in your tests, make sure to configure its &lt;code&gt;scriptPath&lt;/code&gt; option to the relative path of where your JavaScript worker entrypoint was generated, and its &lt;code&gt;moduleRules&lt;/code&gt; so that it is able to resolve the &lt;code&gt;*.wasm&lt;/code&gt; file imported from that JavaScript worker:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// test.mjs&#xA;import assert from &#34;node:assert&#34;;&#xA;import { Miniflare } from &#34;miniflare&#34;;&#xA;&#xA;const mf = new Miniflare({&#xA;  scriptPath: &#34;./build/worker/shim.mjs&#34;,&#xA;  modules: true,&#xA;  modulesRules: [&#xA;    { type: &#34;CompiledWasm&#34;, include: [&#34;**/*.wasm&#34;], fallthrough: true }&#xA;  ]&#xA;});&#xA;&#xA;const res = await mf.dispatchFetch(&#34;http://localhost&#34;);&#xA;assert(res.ok);&#xA;assert.strictEqual(await res.text(), &#34;Hello, World!&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;D1 Databases&lt;/h2&gt; &#xA;&lt;h3&gt;Enabling D1 databases&lt;/h3&gt; &#xA;&lt;p&gt;As D1 databases are in alpha, you&#39;ll need to enable the &lt;code&gt;d1&lt;/code&gt; feature on the &lt;code&gt;worker&lt;/code&gt; crate.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;worker = { version = &#34;x.y.z&#34;, features = [&#34;d1&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Example usage&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use worker::*;&#xA;&#xA;#[derive(Deserialize)]&#xA;struct Thing {&#xA;&#x9;thing_id: String,&#xA;&#x9;desc: String,&#xA;&#x9;num: u32,&#xA;}&#xA;&#xA;#[event(fetch, respond_with_errors)]&#xA;pub async fn main(request: Request, env: Env, _ctx: Context) -&amp;gt; Result&amp;lt;Response&amp;gt; {&#xA;&#x9;Router::new()&#xA;&#x9;&#x9;.get_async(&#34;/:id&#34;, |_, ctx| async move {&#xA;&#x9;&#x9;&#x9;let id = ctx.param(&#34;id&#34;).unwrap()?;&#xA;&#x9;&#x9;&#x9;let d1 = ctx.env.d1(&#34;things-db&#34;)?;&#xA;&#x9;&#x9;&#x9;let statement = d1.prepare(&#34;SELECT * FROM things WHERE thing_id = ?1&#34;);&#xA;&#x9;&#x9;&#x9;let query = statement.bind(&amp;amp;[id])?;&#xA;&#x9;&#x9;&#x9;let result = query.first::&amp;lt;Thing&amp;gt;(None).await?;&#xA;&#x9;&#x9;&#x9;match result {&#xA;&#x9;&#x9;&#x9;&#x9;Some(thing) =&amp;gt; Response::from_json(&amp;amp;thing),&#xA;&#x9;&#x9;&#x9;&#x9;None =&amp;gt; Response::error(&#34;Not found&#34;, 404),&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;})&#xA;&#x9;&#x9;.run(request, env)&#xA;&#x9;&#x9;.await&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Notes and FAQ&lt;/h1&gt; &#xA;&lt;p&gt;It is exciting to see how much is possible with a framework like this, by expanding the options developers have when building on top of the Workers platform. However, there is still much to be done. Expect a few rough edges, some unimplemented APIs, and maybe a bug or two here and there. It’s worth calling out here that some things that may have worked in your Rust code might not work here - it’s all WebAssembly at the end of the day, and if your code or third-party libraries don’t target &lt;code&gt;wasm32-unknown-unknown&lt;/code&gt;, they can’t be used on Workers. Additionally, you’ve got to leave your threaded async runtimes at home; meaning no Tokio or async_std support. However, async/await syntax is still available and supported out of the box when you use the &lt;code&gt;worker&lt;/code&gt; crate.&lt;/p&gt; &#xA;&lt;p&gt;We fully intend to support this crate and continue to build out its missing features, but your help and feedback is a must. We don’t like to build in a vacuum, and we’re in an incredibly fortunate position to have brilliant customers like you who can help steer us towards an even better product.&lt;/p&gt; &#xA;&lt;p&gt;So give it a try, leave some feedback, and star the repo to encourage us to dedicate more time and resources to this kind of project.&lt;/p&gt; &#xA;&lt;p&gt;If this is interesting to you and you want to help out, we’d be happy to get outside contributors started. We know there are improvements to be made such as compatibility with popular Rust HTTP ecosystem types (we have an example conversion for &lt;a href=&#34;https://github.com/cloudflare/workers-rs/raw/3d5876a1aca0a649209152d1ffd52dae7bccda87/libworker/src/headers.rs#L131-L167&#34;&gt;Headers&lt;/a&gt; if you want to make one), implementing additional Web APIs, utility crates, and more. In fact, we’re always on the lookout for great engineers, and hiring for many open roles - please &lt;a href=&#34;https://www.cloudflare.com/careers/&#34;&gt;take a look&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;FAQ&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Can I deploy a Worker that uses &lt;code&gt;tokio&lt;/code&gt; or &lt;code&gt;async_std&lt;/code&gt; runtimes?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Currently no. All crates in your Worker project must compile to &lt;code&gt;wasm32-unknown-unknown&lt;/code&gt; target, which is more limited in some ways than targets for x86 and ARM64.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;The &lt;code&gt;worker&lt;/code&gt; crate doesn&#39;t have &lt;em&gt;X&lt;/em&gt;! Why not?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Most likely, it should, we just haven&#39;t had the time to fully implement it or add a library to wrap the FFI. Please let us know you need a feature by &lt;a href=&#34;https://github.com/cloudflare/workers-rs/issues&#34;&gt;opening an issue&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;My bundle size exceeds &lt;a href=&#34;https://developers.cloudflare.com/workers/platform/limits/&#34;&gt;Workers size limits&lt;/a&gt;, what do I do?&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;We&#39;re working on solutions here, but in the meantime you&#39;ll need to minimize the number of crates your code depends on, or strip as much from the &lt;code&gt;.wasm&lt;/code&gt; binary as possible. Here are some extra steps you can try: &lt;a href=&#34;https://rustwasm.github.io/book/reference/code-size.html#optimizing-builds-for-code-size&#34;&gt;https://rustwasm.github.io/book/reference/code-size.html#optimizing-builds-for-code-size&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;⚠️ Caveats&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Upgrading worker package to version &lt;code&gt;0.0.18&lt;/code&gt; and higher&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;While upgrading your worker to version &lt;code&gt;0.0.18&lt;/code&gt; an error &lt;code&gt;error[E0432]: unresolved import &lt;/code&gt;crate::sys::IoSourceState&lt;code&gt;can appear. In this case, upgrade&lt;/code&gt;package.edition&lt;code&gt;to&lt;/code&gt;edition = &#34;2021&#34;&lt;code&gt;in&lt;/code&gt;wrangler.toml`&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[package]&#xA;edition = &#34;2021&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Your feedback is welcome and appreciated! Please use the issue tracker to talk about potential implementations or make feature requests. If you&#39;re interested in making a PR, we suggest opening up an issue to talk about the change you&#39;d like to make as early as possible.&lt;/p&gt; &#xA;&lt;h2&gt;Project Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;worker&lt;/strong&gt;: the user-facing crate, with Rust-familiar abstractions over the Rust&amp;lt;-&amp;gt;JS/WebAssembly interop via wrappers and convenience library over the FFI bindings.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;worker-sys&lt;/strong&gt;: Rust extern &#34;C&#34; definitions for FFI compatibility with the Workers JS Runtime.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;worker-macros&lt;/strong&gt;: exports &lt;code&gt;event&lt;/code&gt; and &lt;code&gt;durable_object&lt;/code&gt; macros for wrapping Rust entry point in a &lt;code&gt;fetch&lt;/code&gt; method of an ES Module, and code generation to create and interact with Durable Objects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;worker-sandbox&lt;/strong&gt;: a functioning Cloudflare Worker for testing features and ergonomics.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;worker-build&lt;/strong&gt;: a cross-platform build command for &lt;code&gt;workers-rs&lt;/code&gt;-based projects.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>loro-dev/loro</title>
    <updated>2023-11-16T01:44:10Z</updated>
    <id>tag:github.com,2023-11-16:/loro-dev/loro</id>
    <link href="https://github.com/loro-dev/loro" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Reimagine state management with CRDTs&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://loro.dev&#34;&gt; &#xA;  &lt;picture&gt; &#xA;   &lt;img src=&#34;https://raw.githubusercontent.com/loro-dev/loro/main/docs/Loro.svg?sanitize=true&#34; width=&#34;200&#34;&gt; &#xA;  &lt;/picture&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;h1 align=&#34;center&#34;&gt; &lt;a href=&#34;https://loro.dev&#34; alt=&#34;loro-site&#34;&gt;Loro&lt;/a&gt; &lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt;Reimagine state management with CRDTs 🦜&lt;/b&gt;&lt;br&gt; Make your app state synchronized and collaborative effortlessly. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a aria-label=&#34;X&#34; href=&#34;https://x.com/loro_dev&#34; target=&#34;_blank&#34;&gt; &lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/Twitter-black?style=for-the-badge&amp;amp;logo=Twitter&#34;&gt; &lt;/a&gt; &lt;a aria-label=&#34;Discord-Link&#34; href=&#34;https://discord.gg/tUsBSVfqzf&#34; target=&#34;_blank&#34;&gt; &lt;img alt=&#34;&#34; src=&#34;https://img.shields.io/badge/Discord-black?style=for-the-badge&amp;amp;logo=discord&#34;&gt; &lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.postimg.cc/nr2SLHQB/202311120101-2.gif&#34; alt=&#34;Rich text example&#34;&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Notice&lt;/strong&gt;: The current API and encoding schema of Loro are &lt;strong&gt;experimental&lt;/strong&gt; and &lt;strong&gt;subject to change&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Loro is a CRDTs(Conflict-free Replicated Data Types) library that makes building &lt;a href=&#34;https://www.inkandswitch.com/local-first/&#34;&gt;local-first apps&lt;/a&gt; easier.&lt;/p&gt; &#xA;&lt;p&gt;Explore our vision for the local-first development paradigm in our blog post: &lt;a href=&#34;https://loro.dev/blog/loro-now-open-source&#34;&gt;&lt;strong&gt;Reimagine State Management with CRDTs&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;h2&gt;Supported CRDT Algorithms&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Common Data Structures&lt;/strong&gt;: Support for &lt;code&gt;List&lt;/code&gt; for ordered collections, LWW(Last Write Win) &lt;code&gt;Map&lt;/code&gt; for key-value pairs, &lt;code&gt;Tree&lt;/code&gt; for hierarchical data, and &lt;code&gt;Text&lt;/code&gt; for rich text manipulation, enabling various applications.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Text Editing with Fugue&lt;/strong&gt;: Loro integrates &lt;a href=&#34;https://arxiv.org/abs/2305.00583&#34;&gt;Fugue&lt;/a&gt;, a CRDT algorithm designed to minimize interleaving anomalies in concurrent text editing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Peritext-like Rich Text CRDT&lt;/strong&gt;: Drawing inspiration from &lt;a href=&#34;https://www.inkandswitch.com/peritext/&#34;&gt;Peritext&lt;/a&gt;, Loro manages rich text CRDTs that excel at merging concurrent rich text style edits, maintaining the original intent of users input as much as possible. Details on this will be explored further in an upcoming blog post.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Moveable Tree&lt;/strong&gt;: For applications requiring directory-like data manipulation, Loro utilizes the algorithm from &lt;a href=&#34;https://ieeexplore.ieee.org/document/9563274&#34;&gt;&lt;em&gt;A Highly-Available Move Operation for Replicated Trees&lt;/em&gt;&lt;/a&gt;, which simplifies the process of moving hierarchical data structures.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Advanced Features in Loro&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Preserve Editing History&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;With Loro, you can track changes effortlessly as it records the editing history with low overhead.&lt;/li&gt; &#xA;   &lt;li&gt;This feature is essential for audit trails, undo/redo functionality, and understanding the evolution of your data over time.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Time Travel Through History&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It allows users to compare and merge manually when needed, although CRDTs typically resolve conflicts well.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;High Performance&lt;/strong&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://www.loro.dev/docs/performance&#34;&gt;See benchmarks&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Build time travel feature easily for large documents&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/loro-dev/loro/assets/18425020/ec2d20a3-3d8c-4483-a601-b200243c9792&#34;&gt;https://github.com/loro-dev/loro/assets/18425020/ec2d20a3-3d8c-4483-a601-b200243c9792&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features Provided by CRDTs&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Decentralized Synchronization&lt;/strong&gt;: Loro allows your app&#39;s state synced via p2p connections.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Automatic Merging&lt;/strong&gt;: CRDTs guarantee strong eventual consistency by automating the merging of concurrent changes.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Local Availability&lt;/strong&gt;: Data can be persisted on users&#39; devices, supporting offline functionality and real-time responsiveness.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Scalability&lt;/strong&gt;: Effortlessly scale your application horizontally thanks to the inherently distributed nature of CRDTs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Delta Updates&lt;/strong&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Development&lt;/h1&gt; &#xA;&lt;h3&gt;Development Environment Setup&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rust&lt;/strong&gt;: Install from the official Rust website.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Deno&lt;/strong&gt;: Download and install from Deno&#39;s website.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt;: Install from the Node.js website.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;pnpm&lt;/strong&gt;: Run &lt;code&gt;npm i -g pnpm&lt;/code&gt; for global installation.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rust Target&lt;/strong&gt;: Add with &lt;code&gt;rustup target add wasm32-unknown-unknown&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;wasm-bindgen-cli&lt;/strong&gt;: Install version 0.2.86 via &lt;code&gt;cargo install wasm-bindgen-cli --version 0.2.86&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cargo-nextest&lt;/strong&gt;: Install using &lt;code&gt;cargo install cargo-nextest --locked&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cargo-fuzz&lt;/strong&gt;: Run &lt;code&gt;cargo install cargo-fuzz&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;deno task test&#xA;&#xA;# Build and test WASM&#xA;deno task test-wasm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Credits&lt;/h1&gt; &#xA;&lt;p&gt;Loro draws inspiration from the innovative work of the following projects and individuals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://inkandswitch.com/&#34;&gt;Ink &amp;amp; Switch&lt;/a&gt;: The principles of Local-first Software have greatly influenced this project. The &lt;a href=&#34;https://www.inkandswitch.com/peritext/&#34;&gt;Peritext&lt;/a&gt; project has also shaped our approach to rich text CRDTs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/josephg/diamond-types&#34;&gt;Diamond-types&lt;/a&gt;: The ingenious OT-like merging algorithm from @josephg has been adapted to reduce the computation and space usage of CRDTs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/automerge/automerge&#34;&gt;Automerge&lt;/a&gt;: Their use of columnar encoding for CRDTs has informed our strategies for efficient data encoding.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yjs/yjs&#34;&gt;Yjs&lt;/a&gt;: We have incorporated a similar algorithm for effectively merging collaborative editing operations, thanks to their pioneering contributions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://mattweidner.com/&#34;&gt;Matthew Weidner&lt;/a&gt;: His work on the &lt;a href=&#34;https://arxiv.org/abs/2305.00583&#34;&gt;Fugue&lt;/a&gt; algorithm has been invaluable, enhancing our text editing capabilities.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>