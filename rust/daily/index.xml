<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-05T01:37:57Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>eliaperantoni/spaceman</title>
    <updated>2023-04-05T01:37:57Z</updated>
    <id>tag:github.com,2023-04-05:/eliaperantoni/spaceman</id>
    <link href="https://github.com/eliaperantoni/spaceman" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A gRPC client from another world&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eliaperantoni/spaceman/main/img/banner.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Spaceman is a cross-platform gRPC client designed to be pleasant to use and pretty to look at. It is available both as a desktop GUI and as a CLI. Its main use-case is manual testing and debugging of gRPC server: simply load a &lt;a href=&#34;https://protobuf.dev/programming-guides/proto3/&#34;&gt;Protobuf&lt;/a&gt; descriptor, choose your request, fill in the input message body and send away, to infinity and beyond!&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eliaperantoni/spaceman/main/img/screen.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Ok but what&#39;s gRPC&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://grpc.io/&#34;&gt;gRPC&lt;/a&gt; is a modern high-level communication protocol developed at Google. In my mind, gRPC falls more or less in the same basket as HTTP. Nowadays, the latter is not just limited to serving webpages and REST APIs anymore: many applications, that have nothing to do with the web, communicate using it. I like to think of gRPC as a better way to do that.&lt;/p&gt; &#xA;&lt;p&gt;Some of the advantages are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A dedicated, official, SDK is available for &lt;a href=&#34;https://grpc.io/docs/languages/&#34;&gt;many programming languages&lt;/a&gt;. The SDK includes code generation utilities that make serving a gRPC service, or consuming one, a breeze as all the encoding, decoding, and data validation is done for you. For instance, calling a procedure on a remote server is as easy as calling a generated function and building a server usually boils down to implementing a method for each available endpoint.&lt;/li&gt; &#xA; &lt;li&gt;Exchanged messages are strongly typed with the &lt;a href=&#34;https://protobuf.dev/programming-guides/proto3/&#34;&gt;Protobuf3&lt;/a&gt; schema language (some degree of free-typing is opt-in). This is great for avoiding the headaches of fields missing or having an unexpected type. In my experience, the schema file alone is already great documentation in and of itself when working in a small team. See &lt;a href=&#34;https://raw.githubusercontent.com/eliaperantoni/spaceman/main/playground/proto/playground.proto&#34;&gt;playground.proto&lt;/a&gt; for an example.&lt;/li&gt; &#xA; &lt;li&gt;When working with a compiled language, the code generated by the SDK provides useful static typing. If your application doesn&#39;t communicate correctly, it won&#39;t even compile.&lt;/li&gt; &#xA; &lt;li&gt;Messages are binary encoded and, because there is no need for them to be self-describing, they are &lt;a href=&#34;https://nilsmagnus.github.io/post/proto-json-sizes/&#34;&gt;usually smaller than their JSON-encoded counterpart&lt;/a&gt;. Encoding and decoding the messages is performant and often takes &lt;a href=&#34;https://auth0.com/blog/beating-json-performance-with-protobuf/&#34;&gt;less time than &lt;code&gt;JSON.parse&lt;/code&gt;-ing the same message in JavaScript&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Apart from the usual &#34;send a request, receive a response&#34;, gRPC also supports the client and/or the server asynchronously sending messages as long as they want to. When a procedure is &lt;em&gt;streaming&lt;/em&gt; from both sides, you effectively have full-duplex communication just like &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&#34;&gt;WebSockets&lt;/a&gt; or &lt;a href=&#34;https://socket.io/&#34;&gt;socket.io&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/grpc/grpc-web&#34;&gt;It is interoperable with HTTP if you need it&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;In Action&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/6002855/229349667-a199b57d-9ba3-4349-9bbc-7e46f38ef1a8.mp4&#34;&gt;https://user-images.githubusercontent.com/6002855/229349667-a199b57d-9ba3-4349-9bbc-7e46f38ef1a8.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/FW9EIDQtEjv2Oq66F3HxZjAQG&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/FW9EIDQtEjv2Oq66F3HxZjAQG.svg?sanitize=true&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Install dependencies: &lt;a href=&#34;https://crates.io/crates/tauri-cli&#34;&gt;tauri-cli&lt;/a&gt; (&lt;code&gt;cargo install tauri-cli&lt;/code&gt;) and &lt;a href=&#34;https://trunkrs.dev/#install&#34;&gt;trunk&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# To build the CLI&#xA;$ cargo build --release -p spaceman_cli&#xA;&#xA;# To build the GUI&#xA;$ pushd spaceman_gui_back&#xA;$ cargo tauri build&#xA;$ popd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Technology Stack&lt;/h2&gt; &#xA;&lt;p&gt;Spaceman is built in &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt; using &lt;a href=&#34;https://github.com/hyperium/tonic&#34;&gt;Tonic&lt;/a&gt; (part of the &lt;a href=&#34;https://tokio.rs/&#34;&gt;Tokio ecosystem&lt;/a&gt;) for making gRPC calls and heavily relies on &lt;a href=&#34;https://crates.io/crates/prost-reflect&#34;&gt;Prost-Reflect&lt;/a&gt; to interpret Protobuf messages not known at compile time. That&#39;s the core of it, the CLI is just a facade built with &lt;a href=&#34;https://github.com/clap-rs/clap&#34;&gt;Clap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The GUI uses &lt;a href=&#34;https://tauri.app/&#34;&gt;Tauri&lt;/a&gt; as a framework for making webview-based desktop apps and the actual frontend is made with &lt;a href=&#34;https://yew.rs/&#34;&gt;Yew&lt;/a&gt;: a Rust reactive framework that compiles down to &lt;a href=&#34;https://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;. The text editors are built with &lt;a href=&#34;https://microsoft.github.io/monaco-editor/&#34;&gt;Monaco&lt;/a&gt;, the same technology that powers Visual Studio Code.&lt;/p&gt; &#xA;&lt;h2&gt;Miscellaneous&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: Is the project actively maintained&lt;/strong&gt;&lt;br&gt; A: Not really, I built this for my own usage (if even that) just because I felt like building something cool with Rust and I thought it came out nice enough to give it a logo and a detailed README.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Q: I&#39;m on Linux and the app behaves weirdly at times&lt;/strong&gt;&lt;br&gt; A: This is something that I experienced myself but I really can&#39;t do much about it. Tauri uses WebKit2GTK for rendering the webview on Linux and unfortunately, it doesn&#39;t play too nicely with WebAssembly. From my (limited) research, the issues that arise more frequently were solved in WebKit a long time ago but the fixes haven&#39;t made it into WebKit2GTK yet.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>xfbs/imstr</title>
    <updated>2023-04-05T01:37:57Z</updated>
    <id>tag:github.com,2023-04-05:/xfbs/imstr</id>
    <link href="https://github.com/xfbs/imstr" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Immutable strings, in Rust.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Immutable Strings&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/imstr&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/imstr.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Inspired by the &lt;a href=&#34;https://docs.rs/bytes&#34;&gt;bytes&lt;/a&gt; crate, which offers zero-copy byte slices, this crate does the same but for strings. It is backed by standard library string that is stored by smart pointer, and every instance contains a range into that String. This allows for cheap zero-copy cloning and slicing of the string. This is especially useful for parsing operations, where a large string needs to be sliced into a lot of substrings.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;TL;DR: This crate offers an &lt;code&gt;ImString&lt;/code&gt; type that acts as a &lt;code&gt;String&lt;/code&gt; (in that it can be modified and used in the same way), an &lt;code&gt;Arc&amp;lt;String&amp;gt;&lt;/code&gt; (in that it is cheap to clone) and an &lt;code&gt;&amp;amp;str&lt;/code&gt; (in that it is cheap to slice) all in one, owned type.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/xfbs/imstr/master/diagram.png&#34; alt=&#34;Diagram of ImString Internals&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This crate offers a safe API that ensures that every string and every string slice is UTF-8 encoded. It does not allow slicing of strings within UTF-8 multibyte sequences. It offers &lt;code&gt;try_*&lt;/code&gt; functions for every operation that can fail to avoid panics. It also uses extensive unit testing with a full test coverage to ensure that there is no unsoundness.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Efficient Cloning&lt;/strong&gt;: The crate&#39;s architecture enables low-cost (zero-copy) clone and slice creation, making it ideal for parsing strings that are widely shared.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Efficient Slicing&lt;/strong&gt;: The crate&#39;s architecture enables low-cost (zero-copy) slice creation, making it ideal for parsing operations where one large input string is slices into many smaller strings.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Copy on Write&lt;/strong&gt;: Despite being cheap to clone and slice, it allows for mutation using copy-on-write. For strings that are not shared, it has an optimisation to be able to mutate it in-place safely to avoid unnecessary copying.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Compatibility&lt;/strong&gt;: The API is designed to closely resemble Rust&#39;s standard library &lt;a href=&#34;https://doc.rust-lang.org/std/string/struct.String.html&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, facilitating smooth integration and being almost a drop-in replacement.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Generic over Storage&lt;/strong&gt;: The crate is flexible in terms of how the data is stored. It allows for using &lt;code&gt;Arc&amp;lt;String&amp;gt;&lt;/code&gt; for multithreaded applications and &lt;code&gt;Rc&amp;lt;String&amp;gt;&lt;/code&gt; for single-threaded use, providing adaptability to different storage requirements and avoiding the need to pay for atomic operations when they are not needed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Safety&lt;/strong&gt;: The crate enforces that all strings and string slices are UTF-8 encoded. Any methods that might violate this are marked as unsafe. All methods that can fail have a &lt;code&gt;try_*&lt;/code&gt; variant that will not panic. Use of safe functions cannot result in unsound behaviour.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use imstr::ImString;&#xA;&#xA;// Create new ImString, allocates data.&#xA;let mut string = ImString::from(&#34;Hello, World&#34;);&#xA;&#xA;// Edit: happens in-place (because this is the only reference).&#xA;string.push_str(&#34;!&#34;);&#xA;&#xA;// Clone: this is zero-copy.&#xA;let clone = string.clone();&#xA;&#xA;// Slice: this is zero-copy.&#xA;let hello = string.slice(0..5);&#xA;assert_eq!(hello, &#34;Hello&#34;);&#xA;&#xA;// Slice: this is zero-copy.&#xA;let world = string.slice(7..12);&#xA;assert_eq!(world, &#34;World&#34;);&#xA;&#xA;// Here we have to copy only the part that the slice refers to so it can be modified.&#xA;let hello = hello + &#34;!&#34;;&#xA;assert_eq!(hello, &#34;Hello!&#34;);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Similar&lt;/h2&gt; &#xA;&lt;p&gt;This is a comparison of this crate to other, similar crates. The comparison is made on these features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cheap Clone&lt;/strong&gt;: is it a zero-copy operation to clone a string?&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Cheap Slice&lt;/strong&gt; 🍕: is it possibly to cheaply slice a string?&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mutable&lt;/strong&gt;: is it possible to modify strings?&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Generic Storage&lt;/strong&gt;: is it possible to swap out the storage mechanism?&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;String Compatible&lt;/strong&gt;: is it compatible with &lt;a href=&#34;https://doc.rust-lang.org/std/string/struct.String.html&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;?&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here is the data, with links to the crates for further examination:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Crate&lt;/th&gt; &#xA;   &lt;th&gt;Cheap Clone&lt;/th&gt; &#xA;   &lt;th&gt;Cheap Slice&lt;/th&gt; &#xA;   &lt;th&gt;Mutable&lt;/th&gt; &#xA;   &lt;th&gt;Generic Storage&lt;/th&gt; &#xA;   &lt;th&gt;String Compatible&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/imstr&#34;&gt;&lt;code&gt;imstr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;This crate.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/tendril&#34;&gt;&lt;code&gt;tendril&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Complex implementation. API not quite compatible with &lt;a href=&#34;https://doc.rust-lang.org/std/string/struct.String.html&#34;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, but otherwise closest to what this crate does.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/immut_string&#34;&gt;&lt;code&gt;immut_string&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;🟡 (no optimization)&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Simply a wrapper around &lt;code&gt;Arc&amp;lt;String&amp;gt;&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/immutable_string&#34;&gt;&lt;code&gt;immutable_string&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Wrapper around &lt;code&gt;Arc&amp;lt;str&amp;gt;&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/arccstr&#34;&gt;&lt;code&gt;arccstr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Not UTF-8 (Null-terminated C string). Hand-written &lt;code&gt;Arc&lt;/code&gt; implementation.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/implicit-clone&#34;&gt;&lt;code&gt;implicit-clone&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;🟡&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;Immutable string library. Has &lt;code&gt;sync&lt;/code&gt; and &lt;code&gt;unsync&lt;/code&gt; variants.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/semistr&#34;&gt;&lt;code&gt;semistr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Stores short strings inline.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/quetta&#34;&gt;&lt;code&gt;quetta&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Wrapper around &lt;code&gt;Arc&amp;lt;String&amp;gt;&lt;/code&gt; that can be sliced.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/bytesstr&#34;&gt;&lt;code&gt;bytesstr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;🟡&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Wrapper around &lt;code&gt;Bytes&lt;/code&gt;. Cannot be directly sliced.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/fast-str&#34;&gt;&lt;code&gt;fast-str&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Looks like there could be some unsafety.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/flexstr&#34;&gt;&lt;code&gt;flexstr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/bytestring&#34;&gt;&lt;code&gt;bytestring&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;🟡&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Wrapper around &lt;code&gt;Bytes&lt;/code&gt;. Used by &lt;code&gt;actix&lt;/code&gt;. Can be indirectly sliced using &lt;code&gt;slice_ref()&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/arcstr&#34;&gt;&lt;code&gt;arcstr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Can store string literal as &lt;code&gt;&amp;amp;&#39;static str&lt;/code&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/cowstr&#34;&gt;&lt;code&gt;cowstr&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Reimplements &lt;code&gt;Arc&lt;/code&gt;, custom allocation strategy.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://crates.io/crates/strck&#34;&gt;&lt;code&gt;strck&lt;/code&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;✅&lt;/td&gt; &#xA;   &lt;td&gt;❌&lt;/td&gt; &#xA;   &lt;td&gt;Typechecked string library.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;MIT, see &lt;a href=&#34;https://raw.githubusercontent.com/xfbs/imstr/master/LICENSE.md&#34;&gt;LICENSE.md&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>