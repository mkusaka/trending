<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-26T01:43:06Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>glotlabs/gdrive</title>
    <updated>2023-04-26T01:43:06Z</updated>
    <id>tag:github.com,2023-04-26:/glotlabs/gdrive</id>
    <link href="https://github.com/glotlabs/gdrive" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Google Drive CLI Client&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;gdrive&lt;/h1&gt; &#xA;&lt;img src=&#34;https://user-images.githubusercontent.com/720405/210108089-32b7a259-b384-49c3-a2d3-fe07a42791e2.png&#34; width=&#34;100&#34;&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;gdrive is a command line application for interacting with Google Drive. This is the successor of &lt;a href=&#34;https://github.com/prasmussen/gdrive&#34;&gt;gdrive2&lt;/a&gt;, though at the moment only the most basic functionality is implemented.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;Join our &lt;a href=&#34;https://discord.gg/zPcdFUqKeQ&#34;&gt;discord server&lt;/a&gt; to discuss everything gdrive.&lt;/p&gt; &#xA;&lt;h2&gt;Sponsor&lt;/h2&gt; &#xA;&lt;p&gt;Help keep this project alive. By sponsoring the &lt;a href=&#34;https://github.com/sponsors/prasmussen&#34;&gt;gdrive tier&lt;/a&gt; you will help support:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Keeping up with api changes&lt;/li&gt; &#xA; &lt;li&gt;Development of new features&lt;/li&gt; &#xA; &lt;li&gt;Fixing and answering of issues&lt;/li&gt; &#xA; &lt;li&gt;Writing of guides and docs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;h3&gt;Requirements&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Google OAuth Client credentials, see &lt;a href=&#34;https://raw.githubusercontent.com/glotlabs/gdrive/main/docs/create_google_api_credentials.md&#34;&gt;docs&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Install binary&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the latest binary from &lt;a href=&#34;https://github.com/glotlabs/gdrive/releases&#34;&gt;the release section&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Unpack and put the binary somewhere in your PATH (i.e. &lt;code&gt;/usr/local/bin&lt;/code&gt; on linux and macos)&lt;/li&gt; &#xA; &lt;li&gt;Note that the binary is not code signed and will cause a warning on windows and macos when running. This will be fixed later, but for now you can find a workaround via you favorite search engine.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Add google account to gdrive&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run &lt;code&gt;gdrive account add&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;This will prompt you for your google Client ID and Client Secret (see &lt;a href=&#34;https://raw.githubusercontent.com/glotlabs/gdrive/main/#requirements&#34;&gt;Requirements&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Next you will be presented with an url&lt;/li&gt; &#xA; &lt;li&gt;Follow the url and give approval for gdrive to access your Drive&lt;/li&gt; &#xA; &lt;li&gt;You will be redirected to &lt;code&gt;http://localhost:8085&lt;/code&gt; (gdrive starts a temporary web server) which completes the setup&lt;/li&gt; &#xA; &lt;li&gt;Gdrive is now ready to use!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Using gdrive on a remote server&lt;/h3&gt; &#xA;&lt;p&gt;Part of the flow for adding an account to gdrive requires your web browser to access &lt;code&gt;localhost:8085&lt;/code&gt; on the machine that runs gdrive. This makes it tricky to set up accounts on remote servers. The suggested workaround is to add the account on your local machine and import it on the remote server:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;[local] Run &lt;code&gt;gdrive account add&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;[local] Run &lt;code&gt;gdrive account export &amp;lt;ACCOUNT_NAME&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;[local] Copy the exported archive to the remote server&lt;/li&gt; &#xA; &lt;li&gt;[remote] Run &lt;code&gt;gdrive account import &amp;lt;ARCHIVE_PATH&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Credentials&lt;/h3&gt; &#xA;&lt;p&gt;Gdrive saves your account credentials and tokens under &lt;code&gt;$HOME/.config/gdrive3/&lt;/code&gt;. You don&#39;t usually need to use these files directly, but if someone gets access to them, they will also be able to access your Google Drive. Keep them safe.&lt;/p&gt; &#xA;&lt;h3&gt;Gdrive on virtual machines in the cloud&lt;/h3&gt; &#xA;&lt;p&gt;There are some issues communicating with the Drive API from certain cloud providers. For example on an AWS instance the api returns a lot of &lt;code&gt;429 Too Many Requests&lt;/code&gt; / &lt;code&gt;503 Service Unavailable&lt;/code&gt; / &lt;code&gt;502 Bad Gateway&lt;/code&gt; errors while uploading. While the same file uploads without any errors from a Linode instance. Gdrive has retry logic built in for these errors, but it can slow down the upload significantly. To check if you are affected by these errors you can run the &lt;code&gt;upload&lt;/code&gt; command with these flags: &lt;code&gt;--print-chunk-errors&lt;/code&gt; &lt;code&gt;--print-chunk-info&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>mitsuhiko/rye</title>
    <updated>2023-04-26T01:43:06Z</updated>
    <id>tag:github.com,2023-04-26:/mitsuhiko/rye</id>
    <link href="https://github.com/mitsuhiko/rye" rel="alternate"></link>
    <summary type="html">&lt;p&gt;an experimental alternative to poetry/pip/pipenv/pyenv/venv/virtualenv/pdm/hatch/â€¦&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rye&lt;/h1&gt; &#xA;&lt;p&gt;Rye is &lt;a href=&#34;https://github.com/mitsuhiko/&#34;&gt;Armin&#39;s&lt;/a&gt; personal one-stop-shop for all his Python needs. It installs and manages Python installations, manages &lt;code&gt;pyproject.toml&lt;/code&gt; files, installs and uninstalls dependencies, manages virtualenvs behind the scenes. It supports monorepos and global tool installations.&lt;/p&gt; &#xA;&lt;p&gt;It is a wish of what Python was, with no guarantee to work for anyone else. It&#39;s an exploration, and it&#39;s far from perfect. Thus also the question: &lt;strong&gt;&lt;a href=&#34;https://github.com/mitsuhiko/rye/discussions/6&#34;&gt;Should it exist?&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://youtu.be/CyI8TBuKPF0&#34;&gt; &lt;img src=&#34;https://img.youtube.com/vi/CyI8TBuKPF0/sddefault.jpg&#34; alt=&#34;Watch the instruction&#34; width=&#34;40%&#34;&gt; &lt;/a&gt; &#xA; &lt;p&gt;&lt;em&gt;Click on the thumbnail to watch a 9 minute introduction video&lt;/em&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Rye is built in Rust. There is no binary distribution yet, it only works on Linux and macOS as of today:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cargo install --git https://github.com/mitsuhiko/rye rye&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;After installing &lt;code&gt;rye&lt;/code&gt;, all you need to enjoy automatic management of everything is &lt;code&gt;rye sync&lt;/code&gt; (and optionally &lt;code&gt;rye pin&lt;/code&gt; to pick a specific Python version):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rye pin cpython@3.11&#xA;$ rye sync&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The virtualenv that &lt;code&gt;rye&lt;/code&gt; manages is placed in &lt;code&gt;.venv&lt;/code&gt; next to your &lt;code&gt;pyproject.toml&lt;/code&gt;. You can activate and work with it as normal with one notable exception: the Python installation in it does not contain &lt;code&gt;pip&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;python&lt;/code&gt; will by default just be your regular Python. To have it automatically pick up the right Python without manually activating the virtualenv, you can add &lt;code&gt;~/.rye/shims&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; at higher preference than normal. If you operate outside of a rye managed project, the regular Python is picked up automatically. For the global tool installation you need to add the shims to the path.&lt;/p&gt; &#xA;&lt;h2&gt;Some of the things it does&lt;/h2&gt; &#xA;&lt;p&gt;It automatically installs and manages Python:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rye pin 3.11&#xA;$ rye run python&#xA;Python 3.11.1 (main, Jan 16 2023, 16:02:03) [Clang 15.0.7 ] on darwin&#xA;Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.&#xA;&amp;gt;&amp;gt;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install tools in isolation globally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rye install maturin&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Manage dependencies of a local &lt;code&gt;pyproject.toml&lt;/code&gt; and update the virtualenv automatically:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rye add flask&#xA;$ rye sync&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Decisions Made&lt;/h2&gt; &#xA;&lt;p&gt;To understand why things are the way they are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Virtualenvs:&lt;/strong&gt; while I personally do not like virtualenvs that much, they are so widespread and have reasonable tooling support, so I chose this over &lt;code&gt;__pypackages__&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Default Dependencies:&lt;/strong&gt; the virtualenvs when they come up are completely void of dependencies. Not even &lt;code&gt;pip&lt;/code&gt; or &lt;code&gt;setuptools&lt;/code&gt; are installed into it. Rye manages the virtualenv from outside the virtualenv.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Core Non Standard Stuff:&lt;/strong&gt; Rye (with the exception of it&#39;s own &lt;code&gt;tool&lt;/code&gt; section in the &lt;code&gt;pyproject.toml&lt;/code&gt;) uses standardized keys. That means it uses regular requirements as you would expect. It also does not use a custom lock file format and uses &lt;a href=&#34;https://github.com/jazzband/pip-tools&#34;&gt;&lt;code&gt;pip-tools&lt;/code&gt;&lt;/a&gt; behind the scenes.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Pip:&lt;/strong&gt; Rye uses pip, but it does not expose it. It manage dependencies in &lt;code&gt;pyproject.toml&lt;/code&gt; only.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No System Python:&lt;/strong&gt; I can&#39;t deal with any more linux distribution weird Python installations or whatever mess there is on macOS. I used to build my own Pythons that are the same everywhere, now I use &lt;a href=&#34;https://github.com/indygreg/python-build-standalone&#34;&gt;indygreg&#39;s Python builds&lt;/a&gt;. Rye will automatically download and manage Python builds from there. No compiling, no divergence.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Project Local Shims:&lt;/strong&gt; Rye maintains a &lt;code&gt;python&lt;/code&gt; shim that auto discovers the current &lt;code&gt;pyproject.toml&lt;/code&gt; and automatically operates below it. Just add the shims to your shell and you can run &lt;code&gt;python&lt;/code&gt; and it will automatically always operate in the right project.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What Could Be?&lt;/h2&gt; &#xA;&lt;p&gt;There are a few shortcomings in the Python packaging world, largely as a result of lack of standardization. Here is what this project ran into over the years:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Python Binary Distributions:&lt;/strong&gt; CPython builds from python.org are completely inadequate. On some platforms you only get an .msi installer, on some you literally only get tarballs. The various Python distributions that became popular over the years are diverging greatly and cause all kinds of nonsense downstream. This is why this Project uses the indygreg standalone builds. I hope that with time someone will start distributing well maintained and reliable Python builds to replace the mess we are dealing with today.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Dev Dependencies:&lt;/strong&gt; Rye currently needs a custom section in the &lt;code&gt;pyproject.toml&lt;/code&gt; to represent dev dependencies. There is no standard in the ecosystem for this. It really should be added.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Local Dependency Overlays:&lt;/strong&gt; There is no standard for how to represent local dependencies. Rust for this purpose has something like &lt;code&gt;{ path = &#34;../foo&#34; }&lt;/code&gt; which allows both remote and local references to co-exist and it rewrites them on publish.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Exposed Pip:&lt;/strong&gt; pip is intentionally not exposed. If you were to install something into the virtualenv, it disappears next time you sync. If you symlink &lt;code&gt;rye&lt;/code&gt; to &lt;code&gt;~/.rye/shims/pip&lt;/code&gt; you can get access to pip without installating it into the virtualenv. There be dragons.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Workspace Spec:&lt;/strong&gt; for monorepos and things of that nature, the Python ecosystem would need a definition of workspaces. Today that does not exist which forces every tool to come up with it&#39;s own solutions to this problem.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;No Basic Script Section:&lt;/strong&gt; There should be a standard in &lt;code&gt;pyproject.toml&lt;/code&gt; to represent scripts like &lt;code&gt;rye&lt;/code&gt; does in &lt;code&gt;rye.tools.scripts&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Adding Dependencies&lt;/h2&gt; &#xA;&lt;p&gt;To add a new dependency run &lt;code&gt;rye add&lt;/code&gt; with the name of the package that you want to install. Additionally a proprietary extension to &lt;code&gt;pyproject.toml&lt;/code&gt; exists to add development only packages. For those add &lt;code&gt;--dev&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rye add &#34;flask&amp;gt;=2.0&#34;&#xA;$ rye add --dev black&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Adding dependencies will not directly install them. To install them run &lt;code&gt;rye sync&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;h2&gt;Workspaces&lt;/h2&gt; &#xA;&lt;p&gt;To have multiple projects share the same virtualenv, it&#39;s possible to declare workspaces in the &lt;code&gt;pyproject.toml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[tool.rye.workspace]&#xA;members = [&#34;foo-*&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When &lt;code&gt;rye sync&lt;/code&gt; is run in a workspace, then all packages are installed at all times. This also means that they can inter-depend as they will all be installed editable by default.&lt;/p&gt; &#xA;&lt;h2&gt;Lockfiles&lt;/h2&gt; &#xA;&lt;p&gt;Rye does not try to re-invent the world (yet!). This means it uses &lt;code&gt;pip-tools&lt;/code&gt; behind the scenes automatically. As neither &lt;code&gt;pip&lt;/code&gt; nor &lt;code&gt;pip-tools&lt;/code&gt; provide lockfiles today Rye uses generated &lt;code&gt;requirements.txt&lt;/code&gt; files as replacement. Whenever you run &lt;code&gt;rye sync&lt;/code&gt; it updates the &lt;code&gt;requirements.lock&lt;/code&gt; and &lt;code&gt;requirements-dev.lock&lt;/code&gt; files automatically.&lt;/p&gt; &#xA;&lt;h2&gt;Scripts&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;rye run&lt;/code&gt; can be used to invoke a binary from the virtualenv or a configured script. Rye allows you to define basic scripts in the &lt;code&gt;pyproject.toml&lt;/code&gt; in the &lt;code&gt;tool.rye.scripts&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[tool.rye.scripts]&#xA;serve = &#34;python -m http.server 8000&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;They are only available via &lt;code&gt;rye run &amp;lt;script_name&amp;gt;&lt;/code&gt;. Each script can either be a string or an array where each item is an argument to the script. The scripts will be run with the virtualenv activated.&lt;/p&gt; &#xA;&lt;p&gt;To see what&#39;s available, run &lt;code&gt;rye run&lt;/code&gt; without arguments and it will list all scripts.&lt;/p&gt; &#xA;&lt;h2&gt;Python Distributions&lt;/h2&gt; &#xA;&lt;p&gt;Rye does not use system python installations. Instead it uses Gregory Szorc&#39;s standalone Python builds: &lt;a href=&#34;https://github.com/indygreg/python-build-standalone&#34;&gt;python-build-standalone&lt;/a&gt;. This is done to create a unified experience of Python installations and to avoid incompatibilities created by different Python distributions. Most importantly this also means you never need to compile a Python any more, it just downloads prepared binaries.&lt;/p&gt; &#xA;&lt;h2&gt;Managing Python Toolchains&lt;/h2&gt; &#xA;&lt;p&gt;You can register custom Python toolchains with &lt;code&gt;rye toolchain register&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rye toolchain register ~/Downloads/pypy3.9-v7.3.11-macos_arm64/bin/python&#xA;Registered /Users/mitsuhiko/Downloads/pypy3.9-v7.3.11-macos_arm64/bin/python as pypy@3.9.16&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Afterwards you can pin it, in this case with &lt;code&gt;rye pin pypy@3.9.16&lt;/code&gt;. The auto detection of the name might not be great, in which case you can provide an explicit name with &lt;code&gt;--name&lt;/code&gt;. To remove downloaded or linked toolchains, you can use the &lt;code&gt;rye toolchain remove&lt;/code&gt; command. To list what&#39;s available, use &lt;code&gt;rye toolchain list&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Global Tools&lt;/h2&gt; &#xA;&lt;p&gt;If you want tools to be installed into isolated virtualenvs (like pipsi and pipx), you can use &lt;code&gt;rye&lt;/code&gt; too (requires &lt;code&gt;~/.rye/shims&lt;/code&gt; to be on the path):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ rye install pycowsay&#xA;$ pycowsay Wow&#xA;&#xA;  ---&#xA;&amp;lt; Wow &amp;gt;&#xA;  ---&#xA;   \   ^__^&#xA;    \  (oo)\_______&#xA;       (__)\       )\/\&#xA;           ||----w |&#xA;           ||     ||&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To uninstall run &lt;code&gt;rye uninstall pycowsay&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;h2&gt;Using The Virtualenv&lt;/h2&gt; &#xA;&lt;p&gt;There are two ways to use the virtual environment. One is to just activate it like you would do normally:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ . .venv/bin/activate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The other is to use &lt;code&gt;rye run &amp;lt;script&amp;gt;&lt;/code&gt; to run a script (installed into &lt;code&gt;.venv/bin&lt;/code&gt;) in the context of the virtual environment. This for instance can be used to run black:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rye add --dev black&#xA;$ rye sync&#xA;$ rye run black .&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;License: MIT&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kuasar-io/kuasar</title>
    <updated>2023-04-26T01:43:06Z</updated>
    <id>tag:github.com,2023-04-26:/kuasar-io/kuasar</id>
    <link href="https://github.com/kuasar-io/kuasar" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An efficient container runtime that provides cloud-native, all-scenario multiple sandbox container solutions.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/images/logo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Kuasar is an efficient container runtime that provides cloud-native, all-scenario container solutions by supporting multiple sandbox techniques. Written in Rust, it offers a standard sandbox abstraction based on the sandbox API. Additionally, Kuasar provides an optimized framework to accelerate container startup and reduce unnecessary overheads.&lt;/p&gt; &#xA;&lt;h1&gt;Why Kuasar?&lt;/h1&gt; &#xA;&lt;p&gt;In the container world, a sandbox is a technique used to separate container processes from each other, and from the operating system itself. After the introduction of the &lt;a href=&#34;https://github.com/containerd/containerd/issues/4131&#34;&gt;Sandbox API&lt;/a&gt;, sandbox has become the first-class citizen in containerd. With more and more sandbox techniques available in the container world, a management service called &#34;sandboxer&#34; is expected to be proposed.&lt;/p&gt; &#xA;&lt;p&gt;Kuasar supports various types of sandboxers, making it possible for users to select the most appropriate sandboxer for each application, according to application requirements.&lt;/p&gt; &#xA;&lt;p&gt;Compared with other container runtimes, Kuasar has the following advantages:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Unified Sandbox Abstraction&lt;/strong&gt;: The sandbox is a first-class citizen in Kuasar as the Kuasar is entirely built upon the Sandbox API, which was previewed by the containerd community in October 2022. Kuasar fully utilizes the advantages of the Sandbox API, providing a unified way for sandbox access and management, and improving sandbox O&amp;amp;M efficiency.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multi-Sandbox Colocation&lt;/strong&gt;: Kuasar has built-in support for mainstream sandboxes, allowing multiple types of sandboxes to run on a single node. Kuasar is able to balance user&#39;s demands for security isolation, fast startup, and standardization, and enables a serverless node resource pool to meet various cloud-native scenario requirements.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Optimized Framework&lt;/strong&gt;: Optimization has been done in Kuasar via removing all pause containers and replacing shim processes by a single resident sandboxer process, bringing about a 1:N process management model, which has a better performance than the current 1:1 shim v2 process model. The benchmark test results showed that Kuasar&#39;s sandbox startup speed 2x, while the resource overhead for management was reduced by 99%. More details please refer to &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/#Performance&#34;&gt;Performance&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Open and Neutral&lt;/strong&gt;: Kuasar is committed to building an open and compatible multi-sandbox technology ecosystem. Thanks to the Sandbox API, it is more convenient and time-saving to integrate sandbox technologies. Kuasar keeps an open and neutral attitude towards sandbox technologies, therefore all sandbox technologies are welcome. Currently, the Kuasar project is collaborating with open-source communities and projects such as WasmEdge, openEuler and QuarkContainers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Kuasar Architecture&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/images/arch.png&#34; alt=&#34;arch&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sandboxers in Kuasar use their own isolation techniques for the containers, and they are also external plugins of containerd built on the new sandbox plugin mechanism. A discussion about the sandboxer plugin has been raised in this &lt;a href=&#34;https://github.com/containerd/containerd/issues/7739&#34;&gt;Containerd issue&lt;/a&gt;, with a community meeting record and slides attached in this &lt;a href=&#34;https://github.com/containerd/containerd/issues/7739#issuecomment-1384797825&#34;&gt;comment&lt;/a&gt;. Now this feature has been put into 2.0 milestone.&lt;/p&gt; &#xA;&lt;p&gt;Currently, Kuasar provides three types of sandboxers - &lt;strong&gt;MicroVM Sandboxer&lt;/strong&gt;, &lt;strong&gt;App Kernel Sandboxer&lt;/strong&gt; and &lt;strong&gt;Wasm Sandboxer&lt;/strong&gt; - all of which have been proven to be secure isolation techniques in a multi-tenant environment. The general architecture of a sandboxer consists of two modules: one that implements the Sandbox API to manage the sandbox&#39;s lifecycle, and the other that implements the Task API to handle operations related to containers.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, Kuasar is also a platform under active development, and we welcome more sandboxers can be built on top of it, such as Runc sandboxer.&lt;/p&gt; &#xA;&lt;h2&gt;MicroVM Sandboxer&lt;/h2&gt; &#xA;&lt;p&gt;In the microVM sandbox scenario, the VM process provides complete virtual machines and Linux kernels based on open-source VMMs such as &lt;a href=&#34;https://www.cloudhypervisor.org/&#34;&gt;Cloud Hypervisor&lt;/a&gt;, &lt;a href=&#34;https://gitee.com/openeuler/stratovirt&#34;&gt;StratoVirt&lt;/a&gt;, &lt;a href=&#34;https://firecracker-microvm.github.io/&#34;&gt;Firecracker&lt;/a&gt; and &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt;. Hence, the &lt;code&gt;vmm-sandboxer&lt;/code&gt; of MicroVM sandboxer is responsible for launching VMs and calling APIs, and the &lt;code&gt;vmm-task&lt;/code&gt;, as the init process in VMs, plays the role of running container processes. The container IO can be exported via vsock or uds.&lt;/p&gt; &#xA;&lt;p&gt;The microVM sandboxer avoids the necessity of running shim process on the host, bringing about a cleaner and more manageable architecture with only one process per pod.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/images/vmm-arch.png&#34; alt=&#34;vmm&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Please note that only Cloud Hypervisor, StratoVirt and QEMU are supported currently.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;App Kernel Sandboxer&lt;/h2&gt; &#xA;&lt;p&gt;The app kernel sandbox launches a KVM virtual machine and a guest kernel, without any application-level hypervisor or Linux kernel. This allows for customized optimization to speed up startup procedure, reduce memory overheads, and improve IO and network performance. Examples of such app kernel sandboxes include &lt;a href=&#34;https://gvisor.dev/&#34;&gt;gVisor&lt;/a&gt; and &lt;a href=&#34;https://github.com/QuarkContainer/Quark&#34;&gt;Quark&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Quark is an application kernel sandbox that utilizes its own hypervisor named &lt;code&gt;QVisor&lt;/code&gt; and a customized kernel called &lt;code&gt;QKernel&lt;/code&gt;. With customized modifications to these components, Quark can achieve significant performance.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;quark-sandboxer&lt;/code&gt; of app kernel sandboxer starts &lt;code&gt;Qvisor&lt;/code&gt; and an app kernel named &lt;code&gt;Qkernel&lt;/code&gt;. Whenever containerd needs to start a container in the sandbox, the &lt;code&gt;quark-task&lt;/code&gt; in &lt;code&gt;QVisor&lt;/code&gt; will call &lt;code&gt;Qkernel&lt;/code&gt; to launch a new container. All containers within the same pod will be running within the same process.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/images/quark-arch.png&#34; alt=&#34;quark&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Please note that only Quark is currently supported.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Wasm Sandboxer&lt;/h2&gt; &#xA;&lt;p&gt;The wasm sandbox, such as &lt;a href=&#34;https://wasmedge.org/&#34;&gt;WasmEdge&lt;/a&gt; or &lt;a href=&#34;https://wasmtime.dev/&#34;&gt;Wasmtime&lt;/a&gt;, is incredibly lightweight, but it may have constraints for some applications at present. The &lt;code&gt;wasm-sandboxer&lt;/code&gt; and &lt;code&gt;wasm-task&lt;/code&gt; launch containers within a WebAssembly runtime. Whenever containerd needs to start a container in the sandbox, the &lt;code&gt;wasm-task&lt;/code&gt; will fork a new process, start a new WasmEdge runtime, and run the Wasm code inside it. All containers within the same pod will share the same Namespace/Cgroup resources with the &lt;code&gt;wasm-task&lt;/code&gt; process. &lt;img src=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/images/wasm-arch.png&#34; alt=&#34;wasm&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Please note that only WasmEdge is currently supported.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;The performance of Kuasar is measured by two metrics:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;End-to-End containers startup time.&lt;/li&gt; &#xA; &lt;li&gt;Process memory consumption to run containers.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We used the Cloud Hypervisor in the benchmark test and tested the startup time of 100 PODs under both serial and parallel scenario. The result demonstrates that Kuasar outperforms open-source &lt;a href=&#34;https://github.com/kata-containers/kata-containers&#34;&gt;Kata-containers&lt;/a&gt; in terms of both startup speed and memory consumption.&lt;/p&gt; &#xA;&lt;p&gt;For detailed test scripts, test data, and results, please refer to the &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/tests/benchmark/Benchmark.md&#34;&gt;benchmark test&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Quick Start&lt;/h1&gt; &#xA;&lt;h2&gt;Prerequisites&lt;/h2&gt; &#xA;&lt;h3&gt;1. OS&lt;/h3&gt; &#xA;&lt;p&gt;The minimum versions of Linux distributions supported by Kuasar are &lt;em&gt;Ubuntu 22.04&lt;/em&gt; or &lt;em&gt;CentOS 8&lt;/em&gt; or openEuler 23.03.&lt;/p&gt; &#xA;&lt;p&gt;Please also note that Quark requires a Linux kernel version &amp;gt;= 5.15.&lt;/p&gt; &#xA;&lt;h3&gt;2. Sandbox&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MicroVM: To launch a microVM-based sandbox, a hypervisor must be installed on the host. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;It is recommended to install Cloud Hypervisor by default. You can find Cloud Hypervisor installation instructions &lt;a href=&#34;https://github.com/cloud-hypervisor/cloud-hypervisor/raw/main/docs/building.md&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;If you want to run kuasar with iSulad container engine and StratoVirt hypervisor, you can refer to this guide &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/vmm/how-to-run-kuasar-with-isulad-and-stratovirt.md&#34;&gt;how-to-run-kuasar-with-isulad-and-stratovirt&lt;/a&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Quark: To use Quark, please refer to the installation instructions &lt;a href=&#34;https://chat.openai.com/chat/docs/quark/README.md&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;WasmEdge: To start WebAssembly sandboxes, you need to install WasmEdge. Instructions for installing WasmEdge can be found in &lt;a href=&#34;https://wasmedge.org/book/en/quick_start/install.html&#34;&gt;install.html&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;3. containerd&lt;/h3&gt; &#xA;&lt;p&gt;Kuasar sandboxers are external plugins of containerd, so both containerd and its CRI plugin are required in order to manage the sandboxes and containers.&lt;/p&gt; &#xA;&lt;p&gt;We offer two ways to interact Kuasar with containerd:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;EXPERIMENTAL in containerd 2.0 milestone&lt;/strong&gt;: If you desire the full experience of Kuasar, please install &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/containerd.md&#34;&gt;containerd under kuasar-io organization&lt;/a&gt;. Rest assured that our containerd is built based on the official v1.7.0, so there is no need to worry about missing any functionalities.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If the compatibility is a real concern, you need to install official containerd v1.7.0 with an extra &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/shim&#34;&gt;kuasar-shim&lt;/a&gt; for request forwarding, see &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/docs/shim/README.md&#34;&gt;here&lt;/a&gt;. However, it&#39;s possible that this way may be deprecated in the future as containerd 2.0 evolves.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;4. crictl&lt;/h3&gt; &#xA;&lt;p&gt;Since Kuasar is built on top of the Sandbox API, which has already been integrated into the CRI of containerd, it makes sense to experience Kuasar from the CRI level.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;crictl&lt;/code&gt; is a debug CLI for CRI. To install it, please see &lt;a href=&#34;https://github.com/kubernetes-sigs/cri-tools/raw/master/docs/crictl.md#install-crictl&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;5. virtiofsd&lt;/h3&gt; &#xA;&lt;p&gt;MicroVMs like Cloud Hypervisor needs a virtiofs daemon to share the directories on the host. Please refer to &lt;a href=&#34;https://gitlab.com/virtio-fs/virtiofsd&#34;&gt;virtiofsd guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Build from source&lt;/h2&gt; &#xA;&lt;p&gt;Rust 1.67 or higher version is required to compile Kuasar. Build it with root user:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/kuasar-io/kuasar.git&#xA;cd kuasar&#xA;make all&#xA;make install&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Start Kuasar&lt;/h2&gt; &#xA;&lt;p&gt;Launch the sandboxers by the following commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For vmm: &lt;code&gt;nohup vmm-sandboxer --listen /run/vmm-sandboxer.sock --dir /run/kuasar-vmm &amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For quark: &lt;code&gt;nohup quark-sandboxer --listen /run/quark-sandboxer.sock --dir /var/lib/kuasar-quark &amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;For wasm: &lt;code&gt;nohup wasm-sandboxer --listen /run/wasm-sandboxer.sock --dir /run/kuasar-wasm &amp;amp;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Start Container&lt;/h2&gt; &#xA;&lt;p&gt;Since Kuasar is a low-level container runtime, all interactions should be done via CRI in containerd, such as crictl or Kubernetes. We use crictl as examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;For vmm and quark, run the following scripts:&lt;/p&gt; &lt;p&gt;&lt;code&gt;examples/run_example_container.sh vmm&lt;/code&gt; or &lt;code&gt;examples/run_example_container.sh quark&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;For wasm: Wasm container needs its own container image so our script has to build and import the container image at first.&lt;/p&gt; &lt;p&gt;&lt;code&gt;examples/run_example_wasm_container.sh&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contact&lt;/h1&gt; &#xA;&lt;p&gt;If you have questions, feel free to reach out to us in the following ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!forum/kuasar&#34;&gt;mailing list&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://app.slack.com/client/T08PSQ7BQ/C052JRURD8V&#34;&gt;slack&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;If you&#39;re interested in being a contributor and want to get involved in developing the Kuasar code, please see &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING&lt;/a&gt; for details on submitting patches and the contribution workflow.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Kuasar is under the Apache 2.0 license. See the &lt;a href=&#34;https://raw.githubusercontent.com/kuasar-io/kuasar/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt; &#xA;&lt;p&gt;Kuasar documentation is under the &lt;a href=&#34;https://creativecommons.org/licenses/by/4.0/legalcode&#34;&gt;CC-BY-4.0 license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>