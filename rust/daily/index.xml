<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-11T01:44:10Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>tweag/nickel</title>
    <updated>2023-06-11T01:44:10Z</updated>
    <id>tag:github.com,2023-06-11:/tweag/nickel</id>
    <link href="https://github.com/tweag/nickel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Better configuration for less&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Nickel&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tweag/nickel/actions?query=branch%3Amaster&#34;&gt;&lt;img src=&#34;https://github.com/tweag/nickel/workflows/Continuous%20integration/badge.svg?sanitize=true&#34; alt=&#34;Continuous integration&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://nickel-lang.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/website-up-down-green-red/http/cv.lbesson.qc.to.svg?sanitize=true&#34; alt=&#34;Website&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Nickel is the cheap configuration language.&lt;/p&gt; &#xA;&lt;p&gt;Its purpose is to automate the generation of static configuration files - think JSON, YAML, XML, or your favorite data representation language - that are then fed to another system. It is designed to have a simple, well-understood core: it is in essence JSON with functions.&lt;/p&gt; &#xA;&lt;p&gt;Nickel&#39;s salient traits are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight&lt;/strong&gt;: Nickel is easy to embed. An interpreter should be simple to implement. The reference interpreter can be called from many programming languages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Composable code&lt;/strong&gt;: the basic building blocks for computing are functions. They are first-class citizens, which can be passed around, called and composed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Composable data&lt;/strong&gt;: the basic building blocks for data are records (called &lt;em&gt;objects&lt;/em&gt; in JSON). In Nickel, records can be merged at will, including associated metadata (documentation, default values, type contracts, etc).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Typed, but only when it helps&lt;/strong&gt;: static types improve code quality, serve as documentation and eliminate bugs early. But application-specific self-contained code will always evaluate to the same value, so type errors will show up at runtime anyway. Some JSON is hard to type. There, types are only a burden. Whereas reusable code - that is, &lt;em&gt;functions&lt;/em&gt; - is evaluated on potentially infinitely many different inputs, and is impossible to test exhaustively. There, types are precious. Nickel has types, but you get to choose when you want it or not, and it handles safely the interaction between the typed and the untyped world.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Design by contract&lt;/strong&gt;: complementary to the type system, contracts are a principled approach to checking assertions. The interpreter automatically inserts assertions at the boundary between typed and untyped code. Nickel lets users add arbitrary assertions of their own and easily understand why when assertions fail.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The motto guiding Nickel&#39;s design is:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Great defaults, design for extensibility&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;There should be a standard, clear path for common things. There should be no arbitrary restrictions that limit what you can do you the one day you need to go beyond.&lt;/p&gt; &#xA;&lt;h2&gt;Use cases&lt;/h2&gt; &#xA;&lt;p&gt;Nickel is a good fit in any situation where you need to generate a complex configuration, be it for a single app, a machine, whole infrastructure, or a build system.&lt;/p&gt; &#xA;&lt;p&gt;The motivating use cases are in particular:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The &lt;a href=&#34;https://nixos.org/&#34;&gt;Nix package manager&lt;/a&gt;: Nix is a declarative package manager using its own language for specifying packages. Nickel is an evolution of the Nix language, while trying to overcome some of its limitations.&lt;/li&gt; &#xA; &lt;li&gt;Infrastructure as code: infrastructure is becoming increasingly complex, requiring a rigorous approach to deployment, modification and configuration. This is where a declarative approach also shines, as adopted by &lt;a href=&#34;https://www.terraform.io/&#34;&gt;Terraform&lt;/a&gt;, &lt;a href=&#34;https://github.com/NixOS/nixops&#34;&gt;NixOps&lt;/a&gt; or &lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;, all requiring potentially complex generation of configuration.&lt;/li&gt; &#xA; &lt;li&gt;Build systems: build systems (like &lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;) need a specification of the dependency graph.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most aforementioned projects have their own bespoke configuration language. See &lt;a href=&#34;https://raw.githubusercontent.com/tweag/nickel/master/#comparison&#34;&gt;Comparison&lt;/a&gt;. In general, application-specific languages might suffer from feature creep, lack of abstractions or just feel ad hoc. Nickel buys you more for less.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;Please follow the getting started guide for Nickel users on the &lt;a href=&#34;https://nickel-lang.org/getting-started&#34;&gt;nickel-lang website&lt;/a&gt;. The instructions below are either reproduced for this document to be self-contained or because they are aimed toward hacking on the Nickel interpreter itself (e.g. building the &lt;code&gt;nickel-lang&lt;/code&gt; crate documentation).&lt;/p&gt; &#xA;&lt;h3&gt;Run&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Get a Nickel binary:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;With &lt;a href=&#34;https://nixos.wiki/wiki/Flakes&#34;&gt;flake-enabled&lt;/a&gt; Nix, run Nickel directly with &lt;code&gt;nix run github:tweag/nickel&lt;/code&gt;. You can use &lt;a href=&#34;https://tweag-nickel.cachix.org/&#34;&gt;our binary cache&lt;/a&gt; to prevent rebuilding a lot of packages. Pass arguments to Nickel with an extra &lt;code&gt;--&lt;/code&gt; as in &lt;code&gt;nix run github:tweag/nickel -- repl&lt;/code&gt;,&lt;/li&gt; &#xA;   &lt;li&gt;Again with flake-enabled Nix, you can install Nickel in your profile with &lt;code&gt;nix profile add github:tweag/nickel&lt;/code&gt;. The &lt;code&gt;nickel&lt;/code&gt; command is then in your &lt;code&gt;$PATH&lt;/code&gt; and is available anywhere.&lt;/li&gt; &#xA;   &lt;li&gt;Without Nix, you can use &lt;code&gt;cargo run&lt;/code&gt; after &lt;a href=&#34;https://raw.githubusercontent.com/tweag/nickel/master/#build&#34;&gt;building&lt;/a&gt;, passing arguments with an extra &lt;code&gt;--&lt;/code&gt; as in &lt;code&gt;cargo run -- -f program.ncl&lt;/code&gt;.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run your first program:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ nickel &amp;lt;&amp;lt;&amp;lt; &#39;let x = 2 in x + x&#39;&#xA;4&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Or load it from a file:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ echo &#39;let s = &#34;world&#34; in &#34;Hello, &#34; ++ s&#39; &amp;gt; program.ncl&#xA;$ nickel -f program.ncl&#xA;&#34;Hello, world&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Start a REPL:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ nickel repl&#xA;nickel&amp;gt; let x = 2 in x + x&#xA;4&#xA;&#xA;nickel&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Use &lt;code&gt;:help&lt;/code&gt; for a list of available commands.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Export your configuration to JSON, YAML or TOML:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ nickel export --format json &amp;lt;&amp;lt;&amp;lt; &#39;{foo = &#34;Hello, world!&#34;}&#39;&#xA;{&#xA;  &#34;foo&#34;: &#34;Hello, world!&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Use &lt;code&gt;nickel help&lt;/code&gt; for a list of subcommands, and &lt;code&gt;nickel help &amp;lt;subcommand&amp;gt;&lt;/code&gt; for help about a specific subcommand.&lt;/p&gt; &#xA;&lt;h4&gt;Editor Setup&lt;/h4&gt; &#xA;&lt;p&gt;Nickel has syntax highlighting plugins for Vim/Neovim, and VSCode. In-editor diagnostics, type hints, and auto-completion are provided by the Nickel Language Server. Please follow &lt;a href=&#34;https://github.com/tweag/nickel/tree/master/lsp&#34;&gt;the LSP guide&lt;/a&gt; to set up syntax highlighting and NLS.&lt;/p&gt; &#xA;&lt;h4&gt;Formatting&lt;/h4&gt; &#xA;&lt;p&gt;You can format Nickel source code using &lt;a href=&#34;https://github.com/tweag/topiary/&#34;&gt;Topiary&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;topiary -i -f my-config.ncl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Please follow the Formatting Capabilities section of the &lt;a href=&#34;https://github.com/tweag/nickel/tree/master/lsp&#34;&gt;LSP documentation&lt;/a&gt; to know how to hook up the Nickel LSP and topiary in order to enable formatting inside your code editor.&lt;/p&gt; &#xA;&lt;h3&gt;Build&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Download build dependencies:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;With Nix&lt;/strong&gt;: If you have &lt;a href=&#34;https://nixos.org/nix&#34;&gt;Nix&lt;/a&gt; installed:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;nix-shell&#xA;nix develop # if you use Nix Flakes&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You will be dropped in a shell, ready to build. You can use &lt;a href=&#34;https://tweag-nickel.cachix.org/&#34;&gt;our binary cache&lt;/a&gt; to prevent rebuilding a lot of packages.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;strong&gt;Without Nix&lt;/strong&gt;: otherwise, follow &lt;a href=&#34;https://doc.rust-lang.org/cargo/getting-started/installation.html&#34;&gt;this guide&lt;/a&gt; to install Rust and Cargo first.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Build Nickel:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And voilà! Generated files are placed in &lt;code&gt;target/release&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Test&lt;/h3&gt; &#xA;&lt;p&gt;Run tests with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;cargo test&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;p&gt;The user manual is available &lt;a href=&#34;https://nickel-lang.org/user-manual/introduction&#34;&gt;on the nickel-lang.org website&lt;/a&gt;, and in this repository as a collection of Markdown files in &lt;code&gt;doc/manual&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To get the documentation of the &lt;code&gt;nickel-lang&lt;/code&gt; codebase itself:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Build the doc:&lt;/p&gt; &lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;cargo doc --no-deps&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Open the file &lt;code&gt;target/doc/nickel/index.html&lt;/code&gt; in your browser.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;You can find examples in the &lt;a href=&#34;https://raw.githubusercontent.com/tweag/nickel/master/examples&#34;&gt;&lt;code&gt;./examples&lt;/code&gt;&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;h2&gt;Current state and roadmap&lt;/h2&gt; &#xA;&lt;p&gt;Nickel is currently released in version &lt;code&gt;1.0&lt;/code&gt;. We expect the core design of the language to be stable and the language to be useful for real-world applications. The next steps we plan to work on are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Nix integration: being able to seamlessly use Nickel to write packages and shells (&lt;a href=&#34;https://github.com/nickel-lang/nickel-nix&#34;&gt;nickel-nix&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Custom merge functions (second part of the &lt;a href=&#34;https://github.com/tweag/nickel/raw/9fd6e436c0db8f101d4eb26cf97c4993357a7c38/rfcs/001-overriding.md&#34;&gt;overriding proposal&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Incremental evaluation: design an incremental evaluation model and a caching mechanism in order to perform fast re-evaluation upon small changes to a configuration.&lt;/li&gt; &#xA; &lt;li&gt;Performance improvements&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Comparison&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://cuelang.org/&#34;&gt;CUE&lt;/a&gt; is a configuration language with a focus on data validation. It introduces a new constraint system backed by a solid theory which ensures strong guarantees about your code. It allows for very elegant schema specifications. In return, the cost to pay is to abandon functions and &lt;a href=&#34;https://en.wikipedia.org/wiki/Turing_completeness&#34;&gt;Turing-completeness&lt;/a&gt;. Nickel&#39;s merge system is inspired by the one of CUE, even if since Nickel does have general functions and is Turing-complete, they are necessarily different.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nixos.org/&#34;&gt;Nix&lt;/a&gt;: The Nix language, or &lt;em&gt;Nix expressions&lt;/em&gt;, is one of the main inspirations for Nickel. It is a very simple yet powerful lazy functional language. We strive to retain this simplicity, while adding typing capabilities, modularity, and detaching the language from the Nix package manager.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dhall-lang.org/&#34;&gt;Dhall&lt;/a&gt; is a statically typed configuration language. It is also inspired by Nix, to which it adds a powerful static type system. However, this forces the programmer to annotate all of their code with types.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://jsonnet.org/&#34;&gt;Jsonnet&lt;/a&gt; is another language which could be dubbed as &#34;JSON with functions&#34; (and others things as well). It is a lazy functional language with object-oriented features, among which inheritance is similar to Nickel&#39;s merge system. One big difference with Nickel is the absence of typing.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.pulumi.com/&#34;&gt;Pulumi&lt;/a&gt; is not a language in itself, but a cloud tool (like Terraform) where you can use your preferred language for describing your infrastructure. This is a different approach to the problem, with different trade-offs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.bazel.build/versions/master/skylark/language.html&#34;&gt;Starlark&lt;/a&gt; is the language of &lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;, which is a dialect of &lt;a href=&#34;https://www.python.org/&#34;&gt;Python&lt;/a&gt;. It does not have types and recursion is forbidden, making it not Turing-complete.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/tweag/nickel/master/RATIONALE.md&#34;&gt;RATIONALE.md&lt;/a&gt; for the design rationale and a more detailed comparison with these languages.&lt;/p&gt; &#xA;&lt;h3&gt;Comparison with other configuration languages&lt;/h3&gt; &#xA;&lt;!-- Intentionally duplicated in `RATIONALE.md`, please update the other one for&#xA;any change done here --&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Language&lt;/th&gt; &#xA;   &lt;th&gt;Typing&lt;/th&gt; &#xA;   &lt;th&gt;Recursion&lt;/th&gt; &#xA;   &lt;th&gt;Evaluation&lt;/th&gt; &#xA;   &lt;th&gt;Side-effects&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Nickel&lt;/td&gt; &#xA;   &lt;td&gt;Gradual (dynamic + static)&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Lazy&lt;/td&gt; &#xA;   &lt;td&gt;Yes (constrained, planned)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Starlark&lt;/td&gt; &#xA;   &lt;td&gt;Dynamic&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;Strict&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Nix&lt;/td&gt; &#xA;   &lt;td&gt;Dynamic&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Lazy&lt;/td&gt; &#xA;   &lt;td&gt;Predefined and specialized to package management&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Dhall&lt;/td&gt; &#xA;   &lt;td&gt;Static (requires annotations)&lt;/td&gt; &#xA;   &lt;td&gt;Restricted&lt;/td&gt; &#xA;   &lt;td&gt;Lazy&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;CUE&lt;/td&gt; &#xA;   &lt;td&gt;Static (everything is a type)&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;Lazy&lt;/td&gt; &#xA;   &lt;td&gt;No, but allowed in the separated scripting layer&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Jsonnet&lt;/td&gt; &#xA;   &lt;td&gt;Dynamic&lt;/td&gt; &#xA;   &lt;td&gt;Yes&lt;/td&gt; &#xA;   &lt;td&gt;Lazy&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;JSON&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;Strict&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;YAML&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;TOML&lt;/td&gt; &#xA;   &lt;td&gt;None&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;No&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
</feed>