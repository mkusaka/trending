<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-12-24T01:37:34Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>probe-rs/probe-rs</title>
    <updated>2024-12-24T01:37:34Z</updated>
    <id>tag:github.com,2024-12-24:/probe-rs/probe-rs</id>
    <link href="https://github.com/probe-rs/probe-rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A debugging toolset and library for debugging embedded ARM and RISC-V targets on a separate host&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;probe-rs&lt;/h1&gt; &#xA;&lt;p&gt;a modern, embedded debugging toolkit, written in Rust&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/probe-rs&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/probe-rs&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/probe-rs&#34;&gt;&lt;img src=&#34;https://docs.rs/probe-rs/badge.svg?sanitize=true&#34; alt=&#34;documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/probe-rs/probe-rs/actions&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/probe-rs/probe-rs/ci.yml?branch=master&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://matrix.to/#/%23probe-rs:matrix.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-probe--rs%3Amatrix.org-brightgreen&#34; alt=&#34;chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The goal of this library is to provide a toolset to interact with a variety of embedded MCUs and debug probes.&lt;/p&gt; &#xA;&lt;p&gt;Similar projects like OpenOCD, PyOCD, Segger Toolset, ST Tooling, etc. exist. They all implement the GDB protocol and their own protocol on top of it to enable GDB to communicate with the debug probe. Only Segger provides a closed source DLL which you can use for talking to the JLink.&lt;/p&gt; &#xA;&lt;p&gt;This project gets rid of the GDB layer and provides a direct interface to the debug probe, which then enables other software to use its debug functionality.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;The end goal of this project is to have a complete library toolset to enable other tools to communicate with embedded targets.&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Functionality&lt;/h2&gt; &#xA;&lt;p&gt;As of version 0.10.0 this library can&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;connect to a DAPLink, STLink or JLink&lt;/li&gt; &#xA; &lt;li&gt;talk to ARM and Risc-V cores via SWD or JTAG&lt;/li&gt; &#xA; &lt;li&gt;read and write arbitrary memory of the target&lt;/li&gt; &#xA; &lt;li&gt;halt, run, step, breakpoint and much more the core&lt;/li&gt; &#xA; &lt;li&gt;download ELF, BIN and IHEX binaries using standard CMSIS-Pack flash algorithms to ARM cores&lt;/li&gt; &#xA; &lt;li&gt;provide debug information about the target state (stacktrace, stackframe, etc.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To see what new functionality was added have a look at the &lt;a href=&#34;https://raw.githubusercontent.com/probe-rs/probe-rs/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Support&lt;/h2&gt; &#xA;&lt;p&gt;If you think probe-rs makes your embedded journey more enjoyable or even earns you money, please consider supporting the project on &lt;a href=&#34;https://github.com/sponsors/probe-rs/&#34;&gt;Github Sponsors&lt;/a&gt; for better support and more features.&lt;/p&gt; &#xA;&lt;h2&gt;Tools&lt;/h2&gt; &#xA;&lt;p&gt;In addition to being a library, probe-rs also includes a suite of tools which can be used for flashing and debugging.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;The recommended way to install the tools is to download a precompiled version, using one of the methods below. See &lt;a href=&#34;https://probe.rs/docs/getting-started/installation/&#34;&gt;https://probe.rs/docs/getting-started/installation/&lt;/a&gt; for a more detailed guide.&lt;/p&gt; &#xA;&lt;h3&gt;cargo-flash&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;cargo-flash&lt;/code&gt; utility can be used as a cargo subcommand to download a compiled Rust program onto a target device. It can also be used to download arbitrary ELF files that might come out of a C/C++ compiler. Have a look at &lt;a href=&#34;https://probe.rs/docs/tools/cargo-flash/&#34;&gt;cargo-flash&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h3&gt;cargo-embed&lt;/h3&gt; &#xA;&lt;p&gt;If you are looking for a more extended debugging experience, please have a look at &lt;a href=&#34;https://probe.rs/docs/tools/cargo-embed/&#34;&gt;cargo-embed&lt;/a&gt; which provides support for GDB, RTT, and config files.&lt;/p&gt; &#xA;&lt;h3&gt;Editors and IDEs&lt;/h3&gt; &#xA;&lt;p&gt;We have implemented the &lt;a href=&#34;https://microsoft.github.io/debug-adapter-protocol/&#34;&gt;Microsoft Debug Adapter Protocol (DAP)&lt;/a&gt;. This makes embedded debugging via probe-rs available in modern code editors implementing the standard, such as VSCode. The DAP website includes &lt;a href=&#34;https://microsoft.github.io/debug-adapter-protocol/implementors/tools/&#34;&gt;a list of editors and IDEs which support DAP&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;VSCode&lt;/h4&gt; &#xA;&lt;p&gt;The probe-rs website includes &lt;a href=&#34;https://probe.rs/docs/tools/debugger/&#34;&gt;VSCode configuration instructions&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Usage Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Halting the attached chip&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;use probe_rs::probe::{list::Lister, Probe};&#xA;use probe_rs::Permissions;&#xA;&#xA;fn main() -&amp;gt; Result&amp;lt;(), probe_rs::Error&amp;gt; {&#xA;    // Get a list of all available debug probes.&#xA;    let lister = Lister::new();&#xA;&#xA;    let probes = lister.list_all();&#xA;&#xA;    // Use the first probe found.&#xA;    let mut probe = probes[0].open()?;&#xA;&#xA;    // Attach to a chip.&#xA;    let mut session = probe.attach(&#34;nRF52840_xxAA&#34;, Permissions::default())?;&#xA;&#xA;    // Select a core.&#xA;    let mut core = session.core(0)?;&#xA;&#xA;    // Halt the attached core.&#xA;    core.halt(std::time::Duration::from_millis(10))?;&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Reading from RAM&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;use probe_rs::{MemoryInterface, Permissions, Session};&#xA;&#xA;fn main() -&amp;gt; Result&amp;lt;(), probe_rs::Error&amp;gt; {&#xA;    // Attach to a chip.&#xA;    let mut session = Session::auto_attach(&#34;nRF52840_xxAA&#34;, Permissions::default())?;&#xA;&#xA;    // Select a core.&#xA;    let mut core = session.core(0)?;&#xA;&#xA;    // Read a block of 50 32 bit words.&#xA;    let mut buff = [0u32; 50];&#xA;    core.read_32(0x2000_0000, &amp;amp;mut buff)?;&#xA;&#xA;    // Read a single 32 bit word.&#xA;    let word = core.read_word_32(0x2000_0000)?;&#xA;&#xA;    // Writing is just as simple.&#xA;    let buff = [0u32; 50];&#xA;    core.write_32(0x2000_0000, &amp;amp;buff)?;&#xA;&#xA;    // of course we can also write 8bit words.&#xA;    let buff = [0u8; 50];&#xA;    core.write_8(0x2000_0000, &amp;amp;buff)?;&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;I need help!&lt;/h3&gt; &#xA;&lt;p&gt;Don&#39;t hesitate to &lt;a href=&#34;https://github.com/probe-rs/probe-rs/issues/new&#34;&gt;file an issue&lt;/a&gt;, ask questions on &lt;a href=&#34;https://matrix.to/#/%23probe-rs:matrix.org&#34;&gt;Matrix&lt;/a&gt;, or contact &lt;a href=&#34;https://github.com/Yatekii&#34;&gt;@Yatekii&lt;/a&gt; via e-mail.&lt;/p&gt; &#xA;&lt;p&gt;There is also a &lt;a href=&#34;https://probe.rs/docs/knowledge-base/troubleshooting/&#34;&gt;troubleshooting section&lt;/a&gt; on the &lt;a href=&#34;https://probe.rs/&#34;&gt;project page&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;How can I help?&lt;/h3&gt; &#xA;&lt;p&gt;Please have a look at the issues or open one if you feel that something is needed.&lt;/p&gt; &#xA;&lt;p&gt;Any contributions are very welcome!&lt;/p&gt; &#xA;&lt;p&gt;Also have a look at &lt;a href=&#34;https://raw.githubusercontent.com/probe-rs/probe-rs/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Our company needs feature X and would pay for its development&lt;/h3&gt; &#xA;&lt;p&gt;Please reach out to &lt;a href=&#34;https://github.com/Yatekii&#34;&gt;@Yatekii&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Building&lt;/h3&gt; &#xA;&lt;p&gt;Building requires Rust and Cargo which can be installed &lt;a href=&#34;https://rustup.rs/&#34;&gt;using rustup&lt;/a&gt;. On Linux these can be installed with your package manager:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# Ubuntu&#xA;&amp;gt; sudo apt install -y libudev-dev&#xA;&#xA;# Fedora&#xA;&amp;gt; sudo dnf install -y libudev-devel&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Adding Targets&lt;/h3&gt; &#xA;&lt;p&gt;Target files are generated using &lt;a href=&#34;https://github.com/probe-rs/probe-rs/tree/master/target-gen&#34;&gt;target-gen&lt;/a&gt; from CMSIS packs provided &lt;a href=&#34;https://developer.arm.com/tools-and-software/embedded/cmsis/cmsis-search&#34;&gt;here&lt;/a&gt;. Generated files are then placed in &lt;code&gt;probe-rs/targets&lt;/code&gt; for inclusion in the probe-rs project.&lt;/p&gt; &#xA;&lt;h3&gt;Writing new flash algorithms&lt;/h3&gt; &#xA;&lt;p&gt;If there is no CMSIS-Pack with a flash algorithm available, it is necessary to write a target definition and a flash algorithm by oneself. You can use our &lt;a href=&#34;https://github.com/probe-rs/flash-algorithm-template&#34;&gt;template&lt;/a&gt; for writing an algorithm. Please follow the instructions in the &lt;code&gt;README.md&lt;/code&gt; in that repo.&lt;/p&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;In early stages of this library, we profited invaluably from the pyOCD code to understand how flashing works. Also it&#39;s always a good reference to cross check how ARM specific things work. So, a big thank you to the team behind pyOCD!&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apache License, Version 2.0 (&lt;a href=&#34;https://raw.githubusercontent.com/probe-rs/probe-rs/master/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; or &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;MIT license (&lt;a href=&#34;https://raw.githubusercontent.com/probe-rs/probe-rs/master/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; or &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;) at your option.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt;</summary>
  </entry>
</feed>