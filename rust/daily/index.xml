<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-29T01:41:52Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ColinFinck/ntfs</title>
    <updated>2023-10-29T01:41:52Z</updated>
    <id>tag:github.com,2023-10-29:/ColinFinck/ntfs</id>
    <link href="https://github.com/ColinFinck/ntfs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An implementation of the NTFS filesystem in a Rust crate, usable from firmware level up to user-mode.&lt;/p&gt;&lt;hr&gt;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/ColinFinck/ntfs/master/img/ntfs.svg?sanitize=true&#34;&gt; &#xA;&lt;h1&gt;ntfs Rust crate&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/ntfs&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/ntfs&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/ntfs&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/ntfs&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/crates/l/ntfs&#34; alt=&#34;license: MIT OR Apache-2.0&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;by Colin Finck &amp;lt;&lt;a href=&#34;mailto:colin@reactos.org&#34;&gt;colin@reactos.org&lt;/a&gt;&amp;gt;&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;A low-level NTFS filesystem library implemented in Rust.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/NTFS&#34;&gt;NTFS&lt;/a&gt; is the primary filesystem in all versions of Windows (since Windows NT 3.1 in 1993). This crate is geared towards the NTFS 3.x versions used in Windows 2000 up to the current Windows 11. However, the basics are expected to be compatible to even earlier versions.&lt;/p&gt; &#xA;&lt;p&gt;The crate is &lt;code&gt;no_std&lt;/code&gt;-compatible and therefore usable from firmware-level code up to user-mode applications.&lt;/p&gt; &#xA;&lt;h2&gt;ntfs-shell&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ColinFinck/ntfs/master/img/ntfs-shell.gif&#34; alt=&#34;ntfs-shell demo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;ntfs-shell&lt;/code&gt; example comes with this crate to demonstrate all library features. Use it to explore the internal structures of an NTFS filesystem at any detail level, even of your running Windows partition. No artificial security restrictions will block you from accessing files and folders, extracting their data or Alternate Data Streams. The filesystem is opened read-only, so you can safely browse even a mounted filesystem without worrying about data corruption. That is also helpful to get an idea of the Windows NTFS driver, e.g. to find out when its lazy writer actually updates the data on disk.&lt;/p&gt; &#xA;&lt;p&gt;I originally wrote &lt;code&gt;ntfs-shell&lt;/code&gt; for myself to comfortably develop the library in user-mode before running the code in production in kernel-mode.&lt;/p&gt; &#xA;&lt;p&gt;To build &lt;code&gt;ntfs-shell&lt;/code&gt;, just clone this repo and call&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo build --example ntfs-shell --all-features&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run it, pass the path to an NTFS image (on all operating systems) or to a partition (like &lt;code&gt;\\.\C:&lt;/code&gt;, on Windows only with administrative privileges) to the resulting &lt;code&gt;ntfs-shell&lt;/code&gt; binary.&lt;/p&gt; &#xA;&lt;p&gt;Calling &lt;code&gt;help&lt;/code&gt; gives you a list of all supported commands. &lt;code&gt;help COMMAND&lt;/code&gt; details the syntax of that command.&lt;/p&gt; &#xA;&lt;p&gt;Most commands that take a filename also take an NTFS File Record Number (if prepended by &lt;code&gt;/&lt;/code&gt;). This File Record Number may be decimal or hexadecimal (if prepended by &lt;code&gt;0x&lt;/code&gt;). Some examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;fileinfo Windows&#xA;fileinfo /146810&#xA;fileinfo /0x23d7a&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Library Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;For the impatient: Convenience functions to treat NTFS like any other filesystem and just read files and directories using &lt;code&gt;Read&lt;/code&gt;/&lt;code&gt;Seek&lt;/code&gt; traits. At your option, you may also explore the filesystem at any detail level.&lt;/li&gt; &#xA; &lt;li&gt;Reading arbitrary resident and non-resident attributes, attributes in Attribute Lists, and attributes connected over multiple Attribute List entries, including sparse attribute data. All of this together enables reading file data and Alternate Data Streams of any size and on-disk structure.&lt;/li&gt; &#xA; &lt;li&gt;Iterating over a flattened &#34;data-centric&#34; view of the NTFS Attributes, abstracting away any nested Attribute List.&lt;/li&gt; &#xA; &lt;li&gt;Efficiently finding files in a directory, adhering to the filesystem&#39;s $Upcase Table for case-insensitive search.&lt;/li&gt; &#xA; &lt;li&gt;In-order iteration of directory contents at O(1).&lt;/li&gt; &#xA; &lt;li&gt;Leveraging Rust&#39;s typesystem to handle the various types of NTFS indexes in a typesafe way.&lt;/li&gt; &#xA; &lt;li&gt;Error propagation through a custom &lt;code&gt;NtfsError&lt;/code&gt; type that implements &lt;code&gt;Display&lt;/code&gt;. Where it makes sense, variants have additional fields to pinpoint any error to a specific location.&lt;/li&gt; &#xA; &lt;li&gt;Full functionality even in a &lt;code&gt;no_std&lt;/code&gt; environment with &lt;code&gt;alloc&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;No usage of &lt;code&gt;unsafe&lt;/code&gt; anywhere. Checked arithmetic where needed.&lt;/li&gt; &#xA; &lt;li&gt;Platform and endian independence.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Not yet supported&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Any write support&lt;/li&gt; &#xA; &lt;li&gt;Caching for better performance&lt;/li&gt; &#xA; &lt;li&gt;Compression&lt;/li&gt; &#xA; &lt;li&gt;Encryption&lt;/li&gt; &#xA; &lt;li&gt;Journaling&lt;/li&gt; &#xA; &lt;li&gt;Quotas&lt;/li&gt; &#xA; &lt;li&gt;Reparse Points&lt;/li&gt; &#xA; &lt;li&gt;Security Descriptors&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;The following example dumps the names of all files and folders in the root directory of a given NTFS filesystem.&lt;br&gt; The list is directly taken from the NTFS index, hence it&#39;s sorted in ascending order with respect to NTFS&#39;s understanding of case-insensitive string comparison.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;let mut ntfs = Ntfs::new(&amp;amp;mut fs).unwrap();&#xA;let root_dir = ntfs.root_directory(&amp;amp;mut fs).unwrap();&#xA;let index = root_dir.directory_index(&amp;amp;mut fs).unwrap();&#xA;let mut iter = index.entries();&#xA;&#xA;while let Some(entry) = iter.next(&amp;amp;mut fs) {&#xA;    let entry = entry.unwrap();&#xA;    let file_name = entry.key().unwrap();&#xA;    println!(&#34;{}&#34;, file_name.name());&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check out the &lt;a href=&#34;https://docs.rs/ntfs&#34;&gt;docs&lt;/a&gt;, the tests, and the supplied &lt;code&gt;ntfs-shell&lt;/code&gt; application for more examples on how to use the &lt;code&gt;ntfs&lt;/code&gt; library.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This crate is licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache License, Version 2.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;MIT license&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your option.&lt;/p&gt; &#xA;&lt;p&gt;Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt; &#xA;&lt;h2&gt;Further Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://flatcap.github.io/linux-ntfs/ntfs/&#34;&gt;flatcap.github.io linux-ntfs documentation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tuxera/ntfs-3g&#34;&gt;ntfs-3g driver&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>oxidecomputer/hubris</title>
    <updated>2023-10-29T01:41:52Z</updated>
    <id>tag:github.com,2023-10-29:/oxidecomputer/hubris</id>
    <link href="https://github.com/oxidecomputer/hubris" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A lightweight, memory-protected, message-passing kernel for deeply embedded systems.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Hubris&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/oxidecomputer/hubris/actions?query=workflow%3Abuild&#34;&gt;&lt;img src=&#34;https://github.com/oxidecomputer/hubris/workflows/build/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Hubris is a microcontroller operating environment designed for deeply-embedded systems with reliability requirements. Its design was initially proposed in RFD41, but has evolved considerably since then.&lt;/p&gt; &#xA;&lt;h1&gt;Learning&lt;/h1&gt; &#xA;&lt;p&gt;Developer documentation is in Asciidoc in the &lt;code&gt;doc/&lt;/code&gt; directory. It gets rendered via GitHub pages, and is available at &lt;a href=&#34;https://oxidecomputer.github.io/hubris&#34;&gt;https://oxidecomputer.github.io/hubris&lt;/a&gt; .&lt;/p&gt; &#xA;&lt;h1&gt;Navigating&lt;/h1&gt; &#xA;&lt;p&gt;The repo is laid out as follows.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;app/&lt;/code&gt; is where the top-level binary crates for applications live, e.g. &lt;code&gt;app/gimlet&lt;/code&gt; contains the firmware crate for Gimlet. Generally speaking, if you want to build an image for something, look here.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;build/&lt;/code&gt; contains the build system and supporting crates.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;chip/&lt;/code&gt; contains peripheral definitions and debugging support files for individual microcontrollers.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;doc/&lt;/code&gt; contains developer documentation.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;drv/&lt;/code&gt; contains drivers, a mix of simple driver lib crates and fully-fledged server bin crates. Current convention is that &lt;code&gt;drv/SYSTEM-DEVICE&lt;/code&gt; is the driver for &lt;code&gt;DEVICE&lt;/code&gt; on &lt;code&gt;SYSTEM&lt;/code&gt; (where &lt;code&gt;SYSTEM&lt;/code&gt; is usually an SoC name), whereas &lt;code&gt;drv/SYSTEM-DEVICE-server&lt;/code&gt; is the server bin crate.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;idl/&lt;/code&gt; contains interface definitions written in &lt;a href=&#34;https://github.com/oxidecomputer/idolatry&#34;&gt;Idol&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;lib/&lt;/code&gt; contains assorted utility libraries we&#39;ve written. If you need to make a reusable crate that doesn&#39;t fit into one of the other directories, it probably belongs here.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;stage0/&lt;/code&gt; is the bootloader/hypovisor, primarily for LPC55.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;support/&lt;/code&gt; contains some interface and programming support files, like fake certificates and programmer firmware images.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;sys/&lt;/code&gt; contains the &#34;system&#34; bits of Hubris, namely the kernel (&lt;code&gt;sys/kern&lt;/code&gt;), the shared crate defining the ABI (&lt;code&gt;sys/abi&lt;/code&gt;), and the user library used by tasks (&lt;code&gt;sys/userlib&lt;/code&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;task/&lt;/code&gt; contains reusable tasks that aren&#39;t drivers. The distinction between things that live in &lt;code&gt;task&lt;/code&gt; vs in &lt;code&gt;drv/something-server&lt;/code&gt; is fuzzy. Use your judgement.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;test/&lt;/code&gt; contains the test framework and binary crates for building it for various boards.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;website/&lt;/code&gt; contains the source code for the &lt;a href=&#34;https://hubris.oxide.computer/&#34;&gt;hubris website&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Developing&lt;/h1&gt; &#xA;&lt;p&gt;We currently support Linux and Windows as first-tier platforms. macOS is also used on a daily basis by Oxide employees, but is not tested in CI. The build probably also works on Illumos; if anyone would like to step up to maintain support and a continuous build for Illumos or macOS, we&#39;d love the help.&lt;/p&gt; &#xA;&lt;p&gt;To submit changes for review, push them to a branch in a fork and submit a pull request to merge that branch into &lt;code&gt;master&lt;/code&gt;. For details, see &lt;a href=&#34;https://raw.githubusercontent.com/oxidecomputer/hubris/master/CONTRIBUTING.md&#34;&gt;&lt;code&gt;CONTRIBUING.md&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Prereqs&lt;/h2&gt; &#xA;&lt;p&gt;You will need:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;A &lt;code&gt;rustup&lt;/code&gt;-based toolchain install. &lt;code&gt;rustup&lt;/code&gt; will take care of automatically installing our pinned toolchain version, and the cross-compilation targets, when you first try to build.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;openocd&lt;/code&gt; (ideally 0.11) or (if using the LPC55) &lt;code&gt;pyocd&lt;/code&gt; (0.27 or later). Note that the 0.10 release of OpenOCD predates the STLink v3. People are using various post-0.10, pre-0.11 builds provided by system package managers, with some success, but if your system isn&#39;t packaging 0.11 yet, pester them. If you&#39;re going to use Homebrew on macOS to install OpenOCD, you need to use &lt;code&gt;brew install --head openocd&lt;/code&gt; to build the tip of the main branch rather than using the latest binary release. If you need to build from source, you can find &lt;a href=&#34;https://sourceforge.net/projects/openocd/files/openocd/0.11.0/&#34;&gt;OpenOCD v0.11.0 here&lt;/a&gt;. When running &lt;code&gt;./configure&lt;/code&gt;, make sure that you see that the &lt;code&gt;ST-Link Programmer&lt;/code&gt; is set enabled (which should be the default).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://libusb.info/&#34;&gt;libusb&lt;/a&gt;, typically found from your system&#39;s package manager as &lt;code&gt;libusb-1.0.0&lt;/code&gt; or similar.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://www.intra2net.com/en/developer/libftdi/&#34;&gt;libfdti1&lt;/a&gt;, found as &lt;code&gt;libftdi1-dev&lt;/code&gt; or similar.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you will be running GDB, you should install &lt;code&gt;arm-none-eabi-gdb&lt;/code&gt;. This is typically from your system&#39;s package manager with a package name like &lt;code&gt;arm-none-eabi-gdb&lt;/code&gt; or &lt;code&gt;gdb-multiarch&lt;/code&gt;. macOS users can run &lt;code&gt;brew install --cask gcc-arm-embedded&lt;/code&gt; to install the &lt;a href=&#34;https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm&#34;&gt;official ARM binaries&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The Hubris debugger, &lt;a href=&#34;https://github.com/oxidecomputer/humility&#34;&gt;Humility&lt;/a&gt;. Note that &lt;code&gt;cargo install&lt;/code&gt; interacts strangely with the &lt;code&gt;rust-toolchain.toml&lt;/code&gt; file present in the root of this repository; if you run the following command verbatim to install Humility, do so from a different directory:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;cargo install --git https://github.com/oxidecomputer/humility.git --locked humility&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Windows&lt;/h3&gt; &#xA;&lt;p&gt;There are three alternative ways to install OpenOCD:&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://openocd.org/pages/getting-openocd.html&#34;&gt;here&lt;/a&gt; for getting the source of &lt;code&gt;openocd&lt;/code&gt; or get unofficial binaries.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can install with &lt;a href=&#34;https://chocolatey.org/install&#34;&gt;chocolatey&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;&amp;gt; choco install openocd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lastly, you could install &lt;code&gt;openocd&lt;/code&gt; with &lt;a href=&#34;https://scoop.sh/&#34;&gt;scoop&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;&amp;gt; scoop bucket add extras&#xA;&amp;gt; scoop install openocd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;openocd&lt;/code&gt; installed via &lt;code&gt;scoop&lt;/code&gt; has proven problematic for some users. If you experience problems, try installing via &lt;code&gt;choco&lt;/code&gt; or from source (see above).&lt;/p&gt; &#xA;&lt;p&gt;To use the ST-Link programmer, you&#39;ll probably need to install &lt;a href=&#34;https://www.st.com/en/development-tools/stsw-link009.html&#34;&gt;this driver&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s not necessary to build and run Hubris, but if you want to communicate over a serial link (and that&#39;s not supported by your terminal), you&#39;ll want to use PuTTY; &lt;a href=&#34;https://pbxbook.com/voip/sputty.html&#34;&gt;this guide&lt;/a&gt; does a good job of explaining how.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;We do not use &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo run&lt;/code&gt; directly because they are too inflexible for our purposes.&lt;/strong&gt; We have a complex multi-architecture build, which is a bit beyond them.&lt;/p&gt; &#xA;&lt;p&gt;Instead, the repo includes a Cargo extension called &lt;code&gt;xtask&lt;/code&gt; that namespaces our custom build commands.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo xtask dist TOMLFILE&lt;/code&gt; builds a distribution image for the application described by the TOML file.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32f4-discovery/app.toml&lt;/code&gt; - stm32f4-discovery&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32f4-discovery/app-f3.toml&lt;/code&gt; - stm32f3-discovery&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/lpc55xpresso/app.toml&lt;/code&gt; - lpcxpresso55s69&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32g0-nucleo/app-g031.toml&lt;/code&gt; - stm32g031&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32g0-nucleo/app-g070.toml&lt;/code&gt; - stm32g070&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32g0-nucleo/app-g0b1.toml&lt;/code&gt; - stm32g0b1&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32h7-nucleo/app-h743.toml&lt;/code&gt; - nucleo-ih743zi2&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/demo-stm32h7-nucleo/app-h753.toml&lt;/code&gt; - nucleo-ih753zi&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cargo xtask dist app/gemini-bu/app.toml&lt;/code&gt; - Gemini bringup board&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Iterating&lt;/h2&gt; &#xA;&lt;p&gt;Because a full image build can take 10 seconds or more, depending on what you&#39;ve changed, when you&#39;re iterating on a task or kernel you&#39;ll probably want to build it separately. This is what &lt;code&gt;cargo xtask build&lt;/code&gt; is for.&lt;/p&gt; &#xA;&lt;p&gt;For instance, to build &lt;code&gt;task-ping&lt;/code&gt; as it would be built in one of the images, but without building the rest of the demo, run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo xtask build app/gimletlet/app.toml ping&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Running &lt;code&gt;clippy&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;cargo xtask clippy&lt;/code&gt; subcommand can be used to run &lt;code&gt;clippy&lt;/code&gt; against one or more tasks in the context of a particular image:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo xtask clippy app/gimletlet/app.toml ping pong&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Integrating with &lt;code&gt;rust-analyzer&lt;/code&gt;&lt;/h2&gt; &#xA;&lt;p&gt;The Hubris build system will not work with &lt;code&gt;rust-analyzer&lt;/code&gt; out of the box.&lt;/p&gt; &#xA;&lt;p&gt;However, &lt;code&gt;cargo xtask lsp&lt;/code&gt; is here to help: it takes as its argument a Rust file, and returns JSON-encoded configuration for how to set up &lt;code&gt;rust-analyzer&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To use this data, some editor configuration is required!&lt;/p&gt; &#xA;&lt;p&gt;(we haven&#39;t made plugins yet, but it would certainly be possible)&lt;/p&gt; &#xA;&lt;p&gt;Using Neovim and &lt;a href=&#34;https://github.com/simrat39/rust-tools.nvim&#34;&gt;&lt;code&gt;rust-tools&lt;/code&gt;&lt;/a&gt;, here&#39;s an example configuration:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- monkeypatch rust-tools to correctly detect our custom rust-analyzer&#xA;require&#39;rust-tools.utils.utils&#39;.is_ra_server = function (client)&#xA;  local name = client.name&#xA;  local target = &#34;rust_analyzer&#34;&#xA;  return string.sub(client.name, 1, string.len(target)) == target&#xA;    or client.name == &#34;rust_analyzer-standalone&#34;&#xA;end&#xA;&#xA;-- Configure LSP through rust-tools.nvim plugin, with lots of bonus&#xA;-- content for Hubris compatibility&#xA;local cache = {}&#xA;local clients = {}&#xA;require&#39;rust-tools&#39;.setup{&#xA;  tools = { -- rust-tools options&#xA;    autoSetHints = true,&#xA;    inlay_hints = {&#xA;      show_parameter_hints = false,&#xA;      parameter_hints_prefix = &#34;&#34;,&#xA;      other_hints_prefix = &#34;&#34;,&#xA;      -- do other configuration here as desired&#xA;    },&#xA;  },&#xA;&#xA;  server = {&#xA;    on_new_config = function(new_config, new_root_dir)&#xA;      local bufnr = vim.api.nvim_get_current_buf()&#xA;      local bufname = vim.api.nvim_buf_get_name(bufnr)&#xA;      local dir = new_config.root_dir()&#xA;      if string.find(dir, &#34;hubris&#34;) then&#xA;        -- Run `xtask lsp` for the target file, which gives us a JSON&#xA;        -- dictionary with bonus configuration.&#xA;        local prev_cwd = vim.fn.getcwd()&#xA;        vim.cmd(&#34;cd &#34; .. dir)&#xA;        local cmd = dir .. &#34;/target/debug/xtask lsp &#34;&#xA;        -- Notify `xtask lsp` of existing clients in the CLI invocation,&#xA;        -- so it can check against them first (which would mean a faster&#xA;        -- attach)&#xA;        for _,v in pairs(clients) do&#xA;          local c = vim.fn.escape(vim.json.encode(v), &#39;&#34;&#39;)&#xA;          cmd = cmd .. &#39;-c&#34;&#39; .. c .. &#39;&#34; &#39;&#xA;        end&#xA;        local handle = io.popen(cmd .. bufname)&#xA;        handle:flush()&#xA;        local result = handle:read(&#34;*a&#34;)&#xA;        handle:close()&#xA;        vim.cmd(&#34;cd &#34; .. prev_cwd)&#xA;&#xA;        -- If `xtask` doesn&#39;t know about `lsp`, then it will print an error to&#xA;        -- stderr and return nothing on stdout.&#xA;        if result == &#34;&#34; then&#xA;          vim.notify(&#34;recompile `xtask` for `lsp` support&#34;, vim.log.levels.WARN)&#xA;        end&#xA;&#xA;        -- If the given file should be handled with special care, then&#xA;        -- we give the rust-analyzer client a custom name (to prevent&#xA;        -- multiple buffers from attaching to it), then cache the JSON in&#xA;        -- a local variable for use in `on_attach`&#xA;        local json = vim.json.decode(result)&#xA;        if json[&#34;Ok&#34;] ~= nil then&#xA;          new_config.name = &#34;rust_analyzer_&#34; .. json.Ok.hash&#xA;          cache[bufnr] = json&#xA;          table.insert(clients, {toml = json.Ok.app, task = json.Ok.task})&#xA;        else&#xA;          -- TODO:&#xA;          -- vim.notify(vim.inspect(json.Err), vim.log.levels.ERROR)&#xA;        end&#xA;      end&#xA;    end,&#xA;&#xA;    on_attach = function(client, bufnr)&#xA;      local json = cache[bufnr]&#xA;      if json ~= nil then&#xA;        local config = vim.deepcopy(client.config)&#xA;        local ra = config.settings[&#34;rust-analyzer&#34;]&#xA;        -- Do rust-analyzer builds in a separate folder to avoid blocking&#xA;        -- the main build with a file lock.&#xA;        table.insert(json.Ok.buildOverrideCommand, &#34;--target-dir&#34;)&#xA;        table.insert(json.Ok.buildOverrideCommand, &#34;target/rust-analyzer&#34;)&#xA;        ra.cargo = {&#xA;          extraEnv = json.Ok.extraEnv,&#xA;          features = json.Ok.features,&#xA;          noDefaultFeatures = true,&#xA;          target = json.Ok.target,&#xA;          buildScripts = {&#xA;            overrideCommand = json.Ok.buildOverrideCommand,&#xA;          },&#xA;        }&#xA;        ra.check = {&#xA;          overrideCommand = json.Ok.buildOverrideCommand,&#xA;        }&#xA;        config.lspinfo = function()&#xA;          return { &#34;Hubris app:      &#34; .. json.Ok.app,&#xA;                   &#34;Hubris task:     &#34; .. json.Ok.task }&#xA;        end&#xA;        client.config = config&#xA;      end&#xA;    end,&#xA;&#xA;    settings = {&#xA;      [&#34;rust-analyzer&#34;] = {&#xA;        -- enable clippy on save&#xA;        checkOnSave = {&#xA;          command = &#34;clippy&#34;,&#xA;          extraArgs = { &#39;--target-dir&#39;, &#39;target/rust-analyzer&#39; },&#xA;        },&#xA;        diagnostics = {&#xA;          disabled = {&#34;inactive-code&#34;},&#xA;        },&#xA;      }&#xA;    }&#xA;  },&#xA;}&#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;What&#39;s going on here?&lt;/h3&gt; &#xA;&lt;p&gt;When a new LSP configuration is created (&lt;code&gt;on_new_config&lt;/code&gt;), we run &lt;code&gt;cargo xtask lsp&lt;/code&gt; on the target file. The JSON configuration includes a hash of the configuration; we use that hash to modify the name of the client from &lt;code&gt;rust_analyzer&lt;/code&gt; to &lt;code&gt;rust_analyzer_$HASH&lt;/code&gt;. This prevents Neovim from attempting to reuse an existing client, which are normally deduplicated by client name and workspace root directory; in Hubris, we want multiple clients coexisting with same workspace root, so they need different names. Then, we stash the rest of the configuration in a local variable (&lt;code&gt;cache&lt;/code&gt;), and record the existence of this client in &lt;code&gt;clients&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When attaching to the LSP, we try to pull the configuration out of &lt;code&gt;cache&lt;/code&gt;. If one exists, then we know we&#39;re dealing with a Hubris buffer; copy over relevant portions of the configuration.&lt;/p&gt; &#xA;&lt;p&gt;Note that this does not compile &lt;code&gt;xtask&lt;/code&gt; for you; it assumes it already exists in &lt;code&gt;target/debug/xtask&lt;/code&gt;. This should be true if you&#39;re using Hubris regularly, and saves significant amounts of time when opening a new file.&lt;/p&gt; &#xA;&lt;h2&gt;Adding a task&lt;/h2&gt; &#xA;&lt;p&gt;To create your own task, the easiest method is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;task/template&lt;/code&gt; to a new name.&lt;/li&gt; &#xA; &lt;li&gt;Edit its &lt;code&gt;Cargo.toml&lt;/code&gt; with your name and a new package name.&lt;/li&gt; &#xA; &lt;li&gt;Add it to the list of workspace members in the root &lt;code&gt;Cargo.toml&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Add it to a system image by editing an &lt;code&gt;app.toml&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;li&gt;Run &lt;code&gt;cargo xtask build&lt;/code&gt; to compile it.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A typical &lt;code&gt;app.toml&lt;/code&gt; entry for a small task that uses no memory-mapped peripherals would read&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[tasks.name_for_task_in_this_image]&#xA;name = &#34;my-task-target-name&#34;&#xA;priority = 1&#xA;requires = {flash = 1024, ram = 1024}&#xA;start = true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Graphing task relationships and priorities&lt;/h2&gt; &#xA;&lt;p&gt;A graph can be generated that show the relationships of the various tasks and their priorities. The resulting file is in &lt;a href=&#34;https://graphviz.org/&#34;&gt;Graphviz&lt;/a&gt;&#39;s &lt;code&gt;dot&lt;/code&gt; format. &lt;code&gt;Dot&lt;/code&gt; source &lt;a href=&#34;https://docs.asciidoctor.org/diagram-extension/latest/&#34;&gt;can be included&lt;/a&gt; in &lt;a href=&#34;https://asciidoctor.org&#34;&gt;Asciidoctor&lt;/a&gt; source or rendered to a variety of formats.&lt;/p&gt; &#xA;&lt;p&gt;To create and view an SVG graph for &lt;code&gt;gimletlet&lt;/code&gt; on Ubuntu, ensure that the &lt;code&gt;graphviz&lt;/code&gt; package is installed. Then generate the graph:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo xtask graph -o gimletlet.dot app/gimletlet/app.toml&#xA;$ dot -Tsvg gimletlet.dot &amp;gt; gimletlet.svg&#xA;$ xdg-open gimletlet.svg&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Generating all graphs under Linux&lt;/h3&gt; &#xA;&lt;p&gt;Bash commands to generate all graphs:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;  APPS=( $(find app -name &#39;*.toml&#39; ! -name Cargo.toml) )&#xA;  for app in &#34;${APPS[@]}&#34;&#xA;  do&#xA;    out=$(basename ${app//\//_} .toml).dot&#xA;    svg=$(basename $out .dot).svg&#xA;    cargo xtask graph -o $out $app&#xA;    dot -Tsvg $out &amp;gt; $svg&#xA;  done&#xA;  first=&#34;${APPS[0]}&#34;&#xA;  out=&#34;$(basename ${first//\//_} .toml).dot&#34;&#xA;  svg=&#34;$(basename $out .dot).svg&#34;&#xA;  xdg-open &#34;${svg}&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;eog&lt;/code&gt; is the default viewer, opening the first SVG in a directory will allow cycling through all of the available graphs using the same window.&lt;/p&gt; &#xA;&lt;h1&gt;Using Hubris&lt;/h1&gt; &#xA;&lt;p&gt;Hubris is tightly coupled to its debugger, &lt;a href=&#34;https://github.com/oxidecomputer/humility&#34;&gt;Humility&lt;/a&gt;, which is used for the commands below either implicitly (in &lt;code&gt;cargo xtask flash&lt;/code&gt;) or explicitly (in &lt;code&gt;cargo xtask humility&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;If the &lt;code&gt;humility&lt;/code&gt; binary is not available on your &lt;code&gt;$PATH&lt;/code&gt;, the &lt;code&gt;HUBRIS_HUMILITY_PATH&lt;/code&gt; environment variable may be used to provide the path to the binary.&lt;/p&gt; &#xA;&lt;h2&gt;Flash&lt;/h2&gt; &#xA;&lt;p&gt;An image within a Hubris archive can be flashed directly onto a target board by running &lt;code&gt;cargo xtask flash&lt;/code&gt; and specifying the appropriate TOML file. This will run &lt;code&gt;cargo xtask dist&lt;/code&gt; and then pass the resulting build archive to &lt;code&gt;humility flash&lt;/code&gt;. &lt;code&gt;humility&lt;/code&gt; will invoke either OpenOCD or pyOCD to flash the image; the exact invocation depends on the board and is encoded in the build archive.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LPCXpresso55S69: &lt;code&gt;cargo xtask flash app/lpc55xpresso/app.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;STM32F4 Discovery board: &lt;code&gt;cargo xtask flash app/demo-stm32f4-discovery/app.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;ST Nucleo-H743ZI2 board: &lt;code&gt;cargo xtask flash app/demo-stm32h7-nucleo/app-h743.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;ST Nucleo-H753ZI board: &lt;code&gt;cargo xtask flash app/demo-stm32h7-nucleo/app-h753.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Gemini bringup board: &lt;code&gt;cargo xtask flash app/gemini-bu/app.toml&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Running Humility&lt;/h2&gt; &#xA;&lt;p&gt;Humility is run &lt;em&gt;in situ&lt;/em&gt; by specifying an archive on a directly connected board, or postmortem by specifying a dump. As a convenience for development, Humility can also be run &lt;em&gt;in situ&lt;/em&gt; by specifying the appropriate TOML, e.g. on a machine with an STM32F4 Discovery board directly attached:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo xtask humility app/demo-stm32f4-discovery/app.toml -- tasks&#xA;    Finished dev [optimized + debuginfo] target(s) in 0.17s&#xA;     Running `target/debug/xtask humility demo/app.toml -- tasks`&#xA;humility: attached via ST-Link&#xA;ID ADDR     TASK               GEN STATE    &#xA; 0 20000108 jefe                 0 Healthy(InRecv(None))     &#xA; 1 20000178 rcc_driver           0 Healthy(InRecv(None))     &#xA; 2 200001e8 usart_driver         0 Healthy(InRecv(None))     &#xA; 3 20000258 user_leds            0 Healthy(Runnable)          &amp;lt;-&#xA; 4 200002c8 ping                48 Healthy(Runnable)         &#xA; 5 20000338 pong                 0 Healthy(InRecv(None))     &#xA; 6 200003a8 idle                 0 Healthy(Runnable)         &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Debugging with GDB&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;humility&lt;/code&gt; includes a &lt;code&gt;gdb&lt;/code&gt; subcommand which attaches to a running system using &lt;code&gt;arm-none-eabi-gdb&lt;/code&gt;, optionally running its own &lt;code&gt;openocd&lt;/code&gt; instance based on configuration data in the build archive.&lt;/p&gt; &#xA;&lt;p&gt;For convenience, there&#39;s also a &lt;code&gt;cargo xtask gdb&lt;/code&gt; fa√ßade which calls &lt;code&gt;humility&lt;/code&gt; with the appropriate build archive:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo xtask gdb app/demo-stm32f4-discovery/app.toml -- --run-openocd&#xA;# ... lots of output elided ...&#xA;task_idle::main () at task/idle/src/main.rs:14&#xA;14          loop {&#xA;Breakpoint 1 at 0x800434c: file /crates.io/cortex-m-rt-0.6.15/src/lib.rs, line 560.&#xA;Note: automatically using hardware breakpoints for read-only addresses.&#xA;semihosting is enabled&#xA;&#xA;semihosting is enabled&#xA;&#xA;(gdb)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;cargo xtask gdb&lt;/code&gt; will (by default) also run &lt;code&gt;dist&lt;/code&gt; and &lt;code&gt;flash&lt;/code&gt;, to ensure that the image on the chip is up to date. The &lt;code&gt;-n&lt;/code&gt;/&lt;code&gt;--noflash&lt;/code&gt; option skips these steps.&lt;/p&gt; &#xA;&lt;h1&gt;Testing Hubris&lt;/h1&gt; &#xA;&lt;p&gt;The Hubris kernel is tested with a dedicated &lt;em&gt;test image&lt;/em&gt; that includes a test runner, assistant and test suite. The test image emits its results via ITM. While these results can be interpreted manually, &lt;code&gt;humility test&lt;/code&gt; automates this. &lt;code&gt;humility test&lt;/code&gt; itself is most easily run via &lt;code&gt;cargo xtask test&lt;/code&gt;, which runs the equivalent of &lt;code&gt;cargo xtask dist&lt;/code&gt;, &lt;code&gt;cargo xtask flash&lt;/code&gt; and &lt;code&gt;cargo xtask humility test&lt;/code&gt;. The exact invocation depends on the board:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;LPCXpresso55S69: &lt;code&gt;cargo xtask test test/tests-lpc55xpresso/app.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;STM32F3 Discovery board: &lt;code&gt;cargo xtask test test/tests-stm32fx/app-f3.toml&lt;/code&gt;&lt;br&gt; &lt;strong&gt;Note: for this board, SB10 must be soldered closed for ITM to work&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;STM32F4 Discovery board: &lt;code&gt;cargo xtask test test/tests-stm32fx/app.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;ST Nucleo-H743ZI2 board: &lt;code&gt;cargo xtask test test/tests-stm32h7/app-h743.toml&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;ST Nucleo-H753ZI board: &lt;code&gt;cargo xtask test test/tests-stm32h7/app-h753.toml&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note: &lt;code&gt;cargo xtask humility test&lt;/code&gt; runs OpenOCD to connect to the device. You must exit any other instances of OpenOCD that you have connected to the device before running tests.&lt;/p&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/oxidecomputer/humility#humility-test&#34;&gt;documentation for &lt;code&gt;humility test&lt;/code&gt;&lt;/a&gt; for details on test results.&lt;/p&gt; &#xA;&lt;h2&gt;Debugging tests&lt;/h2&gt; &#xA;&lt;p&gt;Output from tests is captured by &lt;code&gt;humility test&lt;/code&gt;; &lt;code&gt;sys_log!()&lt;/code&gt; calls to tests can be added and then captured in a &lt;code&gt;humility test&lt;/code&gt; dump. To capture a dump from tests that are otherwise passing, use &lt;code&gt;cargo xtask humility&lt;/code&gt; directly and pass the &lt;code&gt;-d&lt;/code&gt; flag, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cargo xtask humility test/tests-stm32fx/app.toml -- test -d&#xA;...&#xA;humility: attached via ST-Link&#xA;humility: TPIU sync packet found at offset 1&#xA;humility: ITM synchronization packet found at offset 12&#xA;humility: expecting 22 cases&#xA;humility: running test_send ... ok&#xA;...&#xA;humility: running test_timer_notify ... ok&#xA;humility: running test_timer_notify_past ... ok&#xA;humility: tests completed: pass&#xA;humility: test output dumped to hubris.testout.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;if one needs to both run GDB and the test suite, use &lt;code&gt;cargo xtask gdb&lt;/code&gt; with the test image&#39;s TOML and the appropriate GDB file, and then place breakpoints at the test of interest.&lt;/p&gt; &#xA;&lt;h1&gt;Special cases&lt;/h1&gt; &#xA;&lt;h2&gt;Gemini bringup board&lt;/h2&gt; &#xA;&lt;p&gt;See the Gemini Bringup &lt;a href=&#34;https://github.com/oxidecomputer/gemini-bringup/tree/master/gemini-bringup&#34;&gt;Getting Started&lt;/a&gt; docs (internal Oxide repo)&lt;/p&gt; &#xA;&lt;h2&gt;STM32F3 Discovery boards&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;For the STM32F3 Discovery board, SB10 must be soldered closed for ITM to work!&lt;/strong&gt; This solder bridge defaults to being open, which leaves SWO disconnected. See the STM32F3 Discovery User Manual (UM1570) for schematic and details.&lt;/p&gt; &#xA;&lt;h2&gt;LPCXpresso55S69 board&lt;/h2&gt; &#xA;&lt;p&gt;To use the LPCXpresso55S69, you will need &lt;a href=&#34;https://github.com/mbedmicro/pyOCD&#34;&gt;pyOCD&lt;/a&gt;, version 0.27.0 or later.&lt;/p&gt; &#xA;&lt;p&gt;The LPCXpresso55S69 is somewhat of a mess because the built-on on-chip debugger, LPC-Link2, &lt;a href=&#34;https://community.nxp.com/t5/LPC-Microcontrollers/SWO-SWV-on-LPC-Link2-with-CMSIS-DAP/m-p/1079442&#34;&gt;does not correctly support SWO/SWV&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;If you have the stock LPC-Link2, it will report itself this way via &lt;code&gt;pyocd list&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ pyocd list&#xA;  #   Probe                                           Unique ID&#xA;-----------------------------------------------------------------&#xA;  0   NXP Semiconductors LPC-LINK2 CMSIS-DAP V5.361   JSAQCQIQ&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It&#39;s also possible that you have the Segger J-Link firmware -- firmware that will make its odious presence known by prompting for you to accept license terms whenever running &lt;code&gt;pyocd list&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ pyocd list&#xA;  #   Probe                                                       Unique ID&#xA;-----------------------------------------------------------------------------&#xA;  0   Segger J-Link LPCXpresso V2 compiled Apr  4 2019 16:54:03   726424936&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In either of these cases you must -- as a one-time step -- install new firmware on the LPC-Link2. The new firmware is a build of the (open source) &lt;a href=&#34;https://github.com/oxidecomputer/DAPLink&#34;&gt;DAPLink&lt;/a&gt;, which we affectionally call &lt;strong&gt;RickLink&lt;/strong&gt; after the engineer who managed to get it all built -- no small feat!&lt;/p&gt; &#xA;&lt;p&gt;There are two files that you will need, both contained in the Hubris repository:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/oxidecomputer/hubris/master/support/lpc4322_bl_crc.bin&#34;&gt;lpc4322_bl_crc.bin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/oxidecomputer/hubris/master/support/lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin&#34;&gt;lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You will additionally need the &lt;a href=&#34;https://www.nxp.com/design/microcontrollers-developer-resources/lpc-microcontroller-utilities/lpcscrypt-v2-1-1:LPCSCRYPT&#34;&gt;LPCScrypt program&lt;/a&gt; from NXP.&lt;/p&gt; &#xA;&lt;p&gt;Here are the steps to install RickLink:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Install the DFU jumper. This can be found next to the SWD header on the left side of the board; it is labelled &#34;DFU&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Run &lt;code&gt;scripts/boot_lpcscrypt&lt;/code&gt; from the installed LPCScrypt software:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ /usr/local/lpcscrypt/scripts/boot_lpcscrypt &#xA;Looking for DFU devices with VID 1fc9 PID 000c ...&#xA;dfu-util -d 1fc9:000c -c 1 -i 0 -t 2048 -R  -D /usr/local/lpcscrypt/scripts/../bin/LPCScrypt_228.bin.hdr&#xA;Booted LPCScrypt target (1fc9:000c) with /usr/local/lpcscrypt/scripts/../bin/LPCScrypt_228.bin.hdr&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Run &lt;code&gt;lpcscrypt clockslow&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ /usr/local/lpcscrypt/bin/lpcscrypt clockslow&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;Run &lt;code&gt;lpcscrypt program +w1 0x0 BankA&lt;/code&gt; to overwrite existing firmware&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ /usr/local/lpcscrypt/bin/lpcscrypt program +w1 0x0 BankA&#xA;................&#xA;Programmed 524288 bytes to 0x1a000000 in 2.610s (196.165KB/sec)&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;Run &lt;code&gt;lpcscrypt program +c &amp;lt;path-to-lpc4322_bl_crc.bin&amp;gt; BankA&lt;/code&gt;:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ /usr/local/lpcscrypt/bin/lpcscrypt program +c ~/hubris/support/lpc4322_bl_crc.bin BankA&#xA;..&#xA;Programmed 57344 bytes to 0x1a000000 in 0.827s (67.717KB/sec)&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt; &lt;p&gt;Assuming it is successful, remove the DFU jumper and disconnect/reconnect USB&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;There should now be a USB mass storage device named &lt;code&gt;MAINTENANCE&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# fdisk -l&#xA;Disk /dev/nvme0n1: 477 GiB, 512110190592 bytes, 1000215216 sectors&#xA;Disk model: Micron 2200S NVMe 512GB&#xA;Units: sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;Disklabel type: gpt&#xA;Disk identifier: A8653F99-39AB-4F67-A9C9-524A2864856E&#xA;&#xA;Device             Start        End   Sectors   Size Type&#xA;/dev/nvme0n1p1      2048    1050623   1048576   512M EFI System&#xA;/dev/nvme0n1p2   1050624  967393279 966342656 460.8G Linux filesystem&#xA;/dev/nvme0n1p3 967393280 1000214527  32821248  15.7G Linux swap&#xA;&#xA;&#xA;Disk /dev/sda: 64.1 MiB, 67174400 bytes, 131200 sectors&#xA;Disk model: VFS&#xA;Units: sectors of 1 * 512 = 512 bytes&#xA;Sector size (logical/physical): 512 bytes / 512 bytes&#xA;I/O size (minimum/optimal): 512 bytes / 512 bytes&#xA;Disklabel type: dos&#xA;Disk identifier: 0x00000000&#xA;# mount /dev/sda /mnt&#xA;# ls /mnt&#xA;DETAILS.TXT  PRODINFO.HTM&#xA;# cat /mnt/DETAILS.TXT&#xA;# DAPLink Firmware - see https://mbed.com/daplink&#xA;Unique ID: 02360b000d96e4fc00000000000000000000000097969905&#xA;HIC ID: 97969905&#xA;Auto Reset: 1&#xA;Automation allowed: 1&#xA;Overflow detection: 1&#xA;Daplink Mode: Interface&#xA;Interface Version: 0254&#xA;Bootloader Version: 0254&#xA;Git SHA: f499eb6ec4a847a2b78831fe1acc856fd8eb2f28&#xA;Local Mods: 1&#xA;USB Interfaces: MSD, CDC, HID, WebUSB&#xA;Bootloader CRC: 0x09974fb3&#xA;Interface CRC: 0x7174ab4c&#xA;Remount count: 0&#xA;URL: https://os.mbed.com/platforms/LPCXpresso55S69/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;8&#34;&gt; &#xA; &lt;li&gt;Copy &lt;code&gt;lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin&lt;/code&gt; to the USB drive&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo cp ~/hubris/support/lpc4322_lpc55s69xpresso_if_rla_swo_hacks.bin /mnt&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;9&#34;&gt; &#xA; &lt;li&gt;Unmount (or otherwise sync) the USB drive:&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# umount /mnt&#xA;#&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;10&#34;&gt; &#xA; &lt;li&gt;Unplug and replug the USB cable.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Verify that you are on the new firmware by running &lt;code&gt;pyocd list&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ pyocd list&#xA;  #   Probe                        Unique ID                                         &#xA;-------------------------------------------------------------------------------------&#xA;  0   LPCXpresso55S69 [lpc55s69]   02360b000d96e4fc00000000000000000000000097969905  &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;LPC55S28 on Gemini carrier board&lt;/h2&gt; &#xA;&lt;p&gt;Note that the RickLink running on the LPCXpresso55S69 can &lt;em&gt;also&lt;/em&gt; be used as the debugger for the LPC55S28 on the Gemini carrier board. To do this, first, follow all of the instructions above to get RickLink onto your LPCXpresso55S69. Then:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Using a soldering iron, solder a two-pin header on J5. J5 can be be found to the left of P1 and below the &#34;Debugger&#34; jumper (J3).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Put a jumper on the new header&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Move the &#34;Debugger&#34; jumper (J3) to &#34;Ext&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Use a SWD cable (10-pin 2x5 1.27mm pitch cable) to connect the SWD on the LPCXpresso55S69 to the SWD underneath the carrier board on Gemini (J202)&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;(To allow your RickLink to once again debug its local LPC55S69, remove the jumper on J5 and move J3 to &#34;Loc&#34;.)&lt;/p&gt; &#xA;&lt;h2&gt;Multiple boards simultaneously&lt;/h2&gt; &#xA;&lt;p&gt;If multiple probes are attached, tools may struggle to find the right one at the right time. In particular, OpenOCD will pick the first one that it finds; to force OpenOCD to pick a &lt;em&gt;particular&lt;/em&gt; probe, you can ascertain the serial number of the probe (e.g., from &lt;code&gt;humility probe&lt;/code&gt;) and then specify that serial number in the corresponding &lt;code&gt;openocd.cfg&lt;/code&gt; by adding, e.g.:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;interface hla&#xA;hla_serial 271828182845904523536028&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Where &lt;code&gt;271828182845904523536028&lt;/code&gt; is the serial number of the probe.)&lt;/p&gt; &#xA;&lt;h2&gt;Updating ST-Link Firmware if necessary&lt;/h2&gt; &#xA;&lt;p&gt;It is common that debugging dongles, and development boards with embedded debug hardware like the Nucleo series, are delivered with older firmware.&lt;/p&gt; &#xA;&lt;p&gt;You will not be able to use Humilty with outdated ST-Link firmware. Humility will tell you this is the case, for example when attempting to use &lt;code&gt;humility test&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;Warn : Adding extra erase range, 0x08020060 .. 0x0803ffff&#xA;** Programming Finished **&#xA;** Verify Started **&#xA;** Verified OK **&#xA;** Resetting Target **&#xA;humility: test failed: The firmware on the probe is outdated&#xA;Error: test failed&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Follow this &#34;&lt;a href=&#34;https://www.st.com/en/development-tools/stsw-link007.html&#34;&gt;ST-LINK firmware upgrade&lt;/a&gt;&#34; link to find software and instructions necessary to install current firmware.&lt;/p&gt;</summary>
  </entry>
</feed>