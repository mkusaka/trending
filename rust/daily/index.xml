<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-15T01:41:30Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>nishuzumi/pow-erc20</title>
    <updated>2023-12-15T01:41:30Z</updated>
    <id>tag:github.com,2023-12-15:/nishuzumi/pow-erc20</id>
    <link href="https://github.com/nishuzumi/pow-erc20" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A minter for PowerERC20 by rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;PoWERC20 Mining Tool üöÄ&lt;/h1&gt; &#xA;&lt;h2&gt;Overview üìñ&lt;/h2&gt; &#xA;&lt;p&gt;This Rust project is a fully-functional tool for participating in Ethereum&#39;s PoWERC20 mining process. It offers a Rust-based implementation for connecting to the Ethereum blockchain, generating nonces, and submitting transactions upon discovering a valid nonce. Ideal for those interested in Ethereum mining or exploring the mechanics of blockchain interactions in Rust.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/nishuzumi/pow-erc20/main/media/image.png&#34; alt=&#34;Flying&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features ‚ú®&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Mining Functionality&lt;/strong&gt;: Generates nonces and compares the resulting hash with a target, mirroring Ethereum&#39;s actual mining process.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Parallel Mining Workers&lt;/strong&gt;: Leverages Rust&#39;s concurrency model with async/await and thread pools for deploying multiple mining workers, boosting the probability of finding a valid nonce.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Smart Contract Interaction&lt;/strong&gt;: Interfaces with a specified Ethereum smart contract to retrieve the current mining challenge and difficulty.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Nonce Submission and Transaction Handling&lt;/strong&gt;: Submits the mining solution to the Ethereum network and manages the transaction process after identifying a valid nonce.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation and Setup üõ†Ô∏è&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;Install Rust&lt;/strong&gt;: Ensure you have Rust 1.73 or newer installed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Clone the Repository&lt;/strong&gt;: Download this repository to your machine.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Build the Project&lt;/strong&gt;: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Navigate to the project directory.&lt;/li&gt; &#xA;   &lt;li&gt;Run &lt;code&gt;cargo build --release&lt;/code&gt; to build the release version of the executable.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Usage üöÄ&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Configuration&lt;/strong&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Configure your Ethereum private key and contract address in a configuration file or environment variables.&lt;/li&gt; &#xA;   &lt;li&gt;Adjust the number of mining workers as desired.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Running the Tool&lt;/strong&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Start the tool by running &lt;code&gt;./target/release/pow-erc20&lt;/code&gt; in your terminal.&lt;/li&gt; &#xA;   &lt;li&gt;Optional flags or environment variables can be used for specific configurations.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Contributing ü§ù&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome. Please adhere to the project&#39;s coding standards and include tests for any new features or fixes.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>SeaQL/FireDBG.for.Rust</title>
    <updated>2023-12-15T01:41:30Z</updated>
    <id>tag:github.com,2023-12-15:/SeaQL/FireDBG.for.Rust</id>
    <link href="https://github.com/SeaQL/FireDBG.for.Rust" rel="alternate"></link>
    <summary type="html">&lt;p&gt;üî• Time Travel Visual Debugger for Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;FireDBG for Rust&lt;/h1&gt; &#xA;&lt;h2&gt;Sub-systems&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SeaQL/FireDBG.for.Rust/main/#gh-dark-mode-only&#34;&gt;&lt;img src=&#34;https://firedbg.sea-ql.org/img/components-dark.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/SeaQL/FireDBG.for.Rust/main/#gh-light-mode-only&#34;&gt;&lt;img src=&#34;https://firedbg.sea-ql.org/img/components-light.png&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;For more information on the architecture of FireDBG, please read &lt;a href=&#34;https://firedbg.sea-ql.org/blog/2023-12-11-architecture-of-firedbg&#34;&gt;Architecture of FireDBG&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;codelldb&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;lldb binding; forked from codelldb&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;command&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;FireDBG command line interface&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;debugger&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Debugging engine of FireDBG&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;indexer&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Transforms &lt;code&gt;.firedbg.ss&lt;/code&gt; into &lt;code&gt;.sqlite&lt;/code&gt; file&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;library&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;FireDBG Support Library&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Parses source files in workspace&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;protocol&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;Event stream protocol of &lt;code&gt;.firedbg.ss&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;FireDBG Command Line Interface&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;firedbg-cli&lt;/code&gt; is a CLI to invoke all FireDBG operations.&lt;/p&gt; &#xA;&lt;h3&gt;Cargo Workspace&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;firedbg&lt;/code&gt; command can only act on &lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/workspaces.html&#34;&gt;Cargo Workspace&lt;/a&gt;. If you have a simple dependency free rust file, you still need to put it under a cargo workspace for &lt;code&gt;firedbg&lt;/code&gt; to work properly.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways to tell &lt;code&gt;firedbg&lt;/code&gt; where is the root directory of a cargo workspace:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;By default, the current directory will be the root directory of a cargo workspace&lt;/li&gt; &#xA; &lt;li&gt;Or, overriding it with &lt;code&gt;--workspace-root&lt;/code&gt; option, i.e. &lt;code&gt;firedbg --workspace-root &amp;lt;WORKSPACE-ROOT&amp;gt;&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Common Subcommands&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cache&lt;/code&gt;: Parse all &lt;code&gt;.rs&lt;/code&gt; source files in the current workspace&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;clean&lt;/code&gt;: Cleanup the &lt;code&gt;firedbg/&lt;/code&gt; folder&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;list-target&lt;/code&gt;: List all runnable targets&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;run&lt;/code&gt;: Run a binary target with debugging enabled&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;example&lt;/code&gt;: Run an example with debugging enabled&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;test&lt;/code&gt;: Run an integrated test with debugging enabled&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;unit-test&lt;/code&gt;: Run a unit test with debugging enabled&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;index&lt;/code&gt;: Run indexer on the latest run and save it as a &lt;code&gt;.sqlite&lt;/code&gt; db file&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;list-run&lt;/code&gt;: List all &lt;code&gt;firedbg&lt;/code&gt; runs&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;open&lt;/code&gt;: Open debugger view in VS Code&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;help&lt;/code&gt;: Print help message or the help of the given subcommand(s)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can get the help messages by appending the &lt;code&gt;--help&lt;/code&gt; flag.&lt;/p&gt; &#xA;&lt;h3&gt;The &lt;code&gt;firedbg.toml&lt;/code&gt; Config File&lt;/h3&gt; &#xA;&lt;p&gt;By default FireDBG will only trace the function calls of the debugging package. If you want to trace other packages in your local workspace, you will need to create a &lt;code&gt;firedbg.toml&lt;/code&gt; config file on your workspace root.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[workspace.members]&#xA;quicksort = { trace = &#34;full&#34; }&#xA;# Syntax: &amp;lt;PACKAGE&amp;gt; = { trace = &#34;&amp;lt;full | none&amp;gt;&#34; }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;FireDBG Source Parser for Rust&lt;/h2&gt; &#xA;&lt;p&gt;Based on &lt;a href=&#34;https://github.com/dtolnay/syn&#34;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;firedbg-rust-parser&lt;/code&gt; is a Rust source code parser. It can parse a Rust source file, walk the abstract syntax tree of Rust, then produce a list of breakpoints for the debugger to pause the program at the beginning of every function call.&lt;/p&gt; &#xA;&lt;h3&gt;Walking the AST&lt;/h3&gt; &#xA;&lt;p&gt;We will walk the Rust AST, &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html&#34;&gt;&lt;code&gt;syn::Item&lt;/code&gt;&lt;/a&gt;, and collect all forms of function / method:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Free standalone function, &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html#variant.Fn&#34;&gt;&lt;code&gt;syn::Item::Fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Impl function, &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html#variant.Impl&#34;&gt;&lt;code&gt;syn::Item::Impl&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Trait default function, &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html#variant.Trait&#34;&gt;&lt;code&gt;syn::Item::Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Impl trait function, &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html#variant.Impl&#34;&gt;&lt;code&gt;syn::Item::Impl&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Nested function, walking the &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html&#34;&gt;&lt;code&gt;syn::Item&lt;/code&gt;&lt;/a&gt; recursively&lt;/li&gt; &#xA; &lt;li&gt;Function defined inside inline module, &lt;a href=&#34;https://docs.rs/syn/latest/syn/enum.Item.html#variant.Mod&#34;&gt;&lt;code&gt;syn::Item::Mod&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Breakable Span&lt;/h3&gt; &#xA;&lt;p&gt;A span is a region of source code, denoted by a ranged line and column number tuple, along with macro expansion information. It allows the debugger to set a breakpoint at the correct location. The debugger will set the breakpoint either at the start or the end of the breakable span.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn func() -&amp;gt; i32 {&#xA;/*                ^-- Start of Breakable Span: (Line 1, Column 19)  */&#xA;    let mut i = 0;&#xA;/*  ^-- End of Breakable Span: (Line 3, Column 5)  */&#xA;    for _ in (1..10) {&#xA;        i += 1;&#xA;    }&#xA;    i&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Ideas&lt;/h3&gt; &#xA;&lt;p&gt;The current implementation is rudimentary, but we get exactly what we need. We considered embedding Rust Analyzer, for a few advantages: 1) to get the fully-qualified type names 2) to traverse the static call graph. The problem is resource usage: we&#39;d end up running the compiler frontend thrice (by cargo, by language server, by firedbg).&lt;/p&gt; &#xA;&lt;h2&gt;FireDBG Event Stream Protocol&lt;/h2&gt; &#xA;&lt;p&gt;The FireDBG Event Stream is serialized according to the SeaStreamer File Format, which by convention has the &lt;code&gt;.ss&lt;/code&gt; extension. The Protocol defines the different streams and formats of the messages on top of the file format, and thus they have the &lt;code&gt;.firedbg.ss&lt;/code&gt; extension. The file format is not tightly-coupled with the stream protocol, as it is possible to stream to/from a different backend, e.g. Redis.&lt;/p&gt; &#xA;&lt;p&gt;There are currently 4 streams:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Stream Key&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Format&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Json&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;DebuggerInfo: debugger version, debug target, arguments and exit code, etc&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;file&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Json&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;SourceFile: relative path to the source file&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;breakpoint&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Json&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Breakpoint: breakpoints created and the source location&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;event&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Binary&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Event: function call, function return, etc&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;FireDBG Event Indexer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;firedbg-stream-indexer&lt;/code&gt; is a streaming indexer. It can stream events from &lt;code&gt;.firedbg.ss&lt;/code&gt; files, index them in real-time, and write updates to &lt;code&gt;.sqlite&lt;/code&gt; incrementally.&lt;/p&gt; &#xA;&lt;p&gt;There are 4 event types:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Event Code&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Event Type&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;B&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Breakpoint&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;e.g. a breakpoint hit by &lt;code&gt;fire::dbg!&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Panic&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Program panic&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;F&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Function Call&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;R&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Function Return&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;-&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The indexer reconstructs the call stack for each thread from the event stream, and write a &lt;code&gt;parent_frame_id&lt;/code&gt; for each &lt;code&gt;F&lt;/code&gt; event.&lt;/p&gt; &#xA;&lt;p&gt;The indexer also deserializes the value blobs and translates them into JSON. The JSON is then transformed into pretty-printed Rust-like value strings:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Value Blob -&amp;gt; RValue -&amp;gt; Lifted RValue -&amp;gt; Pretty Print&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The database schema can be found under &lt;a href=&#34;https://github.com/SeaQL/FireDBG.for.Rust/tree/main/indexer/src/entity/&#34;&gt;&lt;code&gt;indexer/src/entity/&lt;/code&gt;&lt;/a&gt;, which is defined by a set of SeaORM entities.&lt;/p&gt; &#xA;&lt;p&gt;Highly recommend you to install a SQLite extension for VS Code. You can find some sample indexes in the &lt;a href=&#34;https://github.com/SeaQL/FireDBG.Rust.Testbench&#34;&gt;Testbench&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;FireDBG Debugger Engine for Rust&lt;/h2&gt; &#xA;&lt;p&gt;Based on &lt;a href=&#34;https://lldb.llvm.org/&#34;&gt;lldb&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This library is semver exempt. The version number is intended to track rustc&#39;s version.&lt;/p&gt; &#xA;&lt;h3&gt;Debugger Config&lt;/h3&gt; &#xA;&lt;p&gt;Configuration can be set via the &lt;code&gt;FIREDBG_RUST_CONFIG&lt;/code&gt; environment variable. e.g. &lt;code&gt;FIREDBG_RUST_CONFIG=MAX_ARRAY_SIZE=100;DONT_TRACE_ALLOCATION&lt;/code&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Key&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Type&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;MAX_ARRAY_SIZE&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Maximum number of items in array, string and other containers&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;RECURSIVE_DEREF_LIMIT&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Recursive limit; i.e. this limits the depth of a binary tree&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;KEEP_HASH_ORDER&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;If set, don&#39;t sort hash maps by hash key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;DONT_TRACE_ALLOCATION&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;If set, don&#39;t trace heap allocations&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Instruction Set&lt;/h3&gt; &#xA;&lt;p&gt;Currently supports x64 (aka amd64) and arm64 (aka aarch64). There are quite some assembly parsing and register fiddling catered to each platform. There are some assumptions to pointers being 8 bytes in the codebase. It requires considerable effort to support a new architecture, but we are open to commercial collaboration.&lt;/p&gt; &#xA;&lt;h3&gt;Operating Systems&lt;/h3&gt; &#xA;&lt;p&gt;There is no OS specific code for now. lldb is used on both Linux and macOS. But on macOS we&#39;d connect to the host&#39;s &lt;code&gt;lldb-server&lt;/code&gt;. If we decided to support Windows natively, we&#39;d need to make a Windows backend.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;debugger&lt;/code&gt; binary must be compiled for the same platform as the target binary. In addition, we assume they both use the same &lt;code&gt;rustc&lt;/code&gt; (not necessarily exactly the same, but ABI compatible with each other).&lt;/p&gt; &#xA;&lt;h3&gt;Standard Library Types&lt;/h3&gt; &#xA;&lt;p&gt;We intend to build-in all handling of standard library types. For &lt;code&gt;HashMap&lt;/code&gt;, &lt;a href=&#34;https://github.com/tyt2y3/frozen-hashbrown&#34;&gt;frozen-hashbrown&lt;/a&gt; is used. In the future, we want to open scripting interface (maybe via &lt;a href=&#34;https://rhai.rs/&#34;&gt;rhai&lt;/a&gt;) to handle vendor library types (e.g. &lt;code&gt;DateTime&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;), in a similar sense to Natvis.&lt;/p&gt; &#xA;&lt;h3&gt;Binary Value Format&lt;/h3&gt; &#xA;&lt;p&gt;The format for serializing Rust values can be best understood by reading &lt;code&gt;SourceReader::read_values()&lt;/code&gt; in &lt;code&gt;reader.rs&lt;/code&gt;. It should be pretty straight-forward, the only tricky part is &lt;code&gt;ReaderContext&lt;/code&gt; which is for resolving memory references.&lt;/p&gt; &#xA;&lt;h3&gt;Return Value Capture&lt;/h3&gt; &#xA;&lt;p&gt;This is highly architecture specific. We try to capture the return value at the moment the function returns, i.e. at the &lt;code&gt;ret&lt;/code&gt; instruction. Not everything is on the stack, sometimes the return value will be passed through registers.&lt;/p&gt; &#xA;&lt;p&gt;According to Rust&#39;s ABI convention, it means if the return value is:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;One or two primitives, each no bigger than 64 bits. This includes &lt;code&gt;(i64, i64)&lt;/code&gt; and &lt;code&gt;struct { a: i64, b: i64 }&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;One &lt;code&gt;i128&lt;/code&gt; / &lt;code&gt;u128&lt;/code&gt;; will be split into &lt;code&gt;rax&lt;/code&gt; / &lt;code&gt;rdx&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;One or two &lt;code&gt;f32&lt;/code&gt; / &lt;code&gt;f64&lt;/code&gt;; will be put in &lt;code&gt;xmm0&lt;/code&gt; / &lt;code&gt;xmm1&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;; where &lt;code&gt;T&lt;/code&gt; &amp;amp; &lt;code&gt;E&lt;/code&gt; is no bigger than 64 bits&lt;/p&gt; &lt;p&gt;The enum discriminant is in &lt;code&gt;rax&lt;/code&gt;, where:&lt;/p&gt; &#xA;  &lt;table&gt; &#xA;   &lt;thead&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;th align=&#34;center&#34;&gt;Type&lt;/th&gt; &#xA;     &lt;th align=&#34;center&#34;&gt;T&lt;/th&gt; &#xA;     &lt;th align=&#34;center&#34;&gt;E&lt;/th&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/thead&gt; &#xA;   &lt;tbody&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Some = 1&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;&lt;code&gt;None = 0&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;    &lt;tr&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Ok = 0&lt;/code&gt;&lt;/td&gt; &#xA;     &lt;td align=&#34;center&#34;&gt;&lt;code&gt;Err = 1&lt;/code&gt;&lt;/td&gt; &#xA;    &lt;/tr&gt; &#xA;   &lt;/tbody&gt; &#xA;  &lt;/table&gt; &lt;p&gt;and the &lt;code&gt;T&lt;/code&gt; / &lt;code&gt;E&lt;/code&gt; will be in &lt;code&gt;rdx&lt;/code&gt;.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Unfortunately it is much more complicated than &lt;a href=&#34;https://darkcoding.net/software/rust-multiple-return-types/&#34;&gt;the above summary&lt;/a&gt;. Right now the implementation is all mess, and completely based on heuristics. If we got the chance to do this properly, may be we can generate rust code and inspect the assembly (systematically). Say our return type is &lt;code&gt;(T, F)&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn probe() -&amp;gt; (T, F) { todo!() }&#xA;fn extractor() {&#xA;    let res = probe();&#xA;    std::hint::black_box(&amp;amp;res);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we disassemble the binary, we should see:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extractor:&#xA;call probe&#xA;mov ..&#xA;call black_box&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So between &lt;code&gt;probe&lt;/code&gt; and &lt;code&gt;black_box&lt;/code&gt;, there would be some memory fiddling, which would end up writing the full struct onto the stack, where the address will then be stored in &lt;code&gt;rax&lt;/code&gt; / &lt;code&gt;x0&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;There should be better ways to do this, if you have an idea please open a discussion thread!&lt;/p&gt; &#xA;&lt;h3&gt;Heap allocation&lt;/h3&gt; &#xA;&lt;p&gt;Right now it is still a WIP. We can trace all &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt; allocations now, so that we are able to extract the content of &lt;code&gt;Box&amp;lt;dyn T&amp;gt;&lt;/code&gt;. The TODO is to trace deallocations and output the information to a dedicated event stream.&lt;/p&gt; &#xA;&lt;h2&gt;FireDBG Support Library&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;fire::dbg!&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This macro allows you to capture the value of a variable via runtime inspection in FireDBG.&lt;/p&gt; &#xA;&lt;p&gt;Usage example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use firedbg_lib::fire;&#xA;&#xA;fn some_fn(v: i32) -&amp;gt; i32 {&#xA;    fire::dbg!(v) + 1&#xA;}&#xA;&#xA;fn other_fn(v: i32) -&amp;gt; i32 {&#xA;    fire::dbg!(&#34;arg_v&#34;, v) + 1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Which &lt;code&gt;fire::dbg!(v)&lt;/code&gt; would expand to &lt;code&gt;__firedbg_trace__(&#34;v&#34;, v)&lt;/code&gt; when compiled under debug mode. The label could be customized, which &lt;code&gt;fire::dbg!(&#34;arg_v&#34;, v)&lt;/code&gt; would expand to &lt;code&gt;__firedbg_trace__(&#34;arg_v&#34;, v)&lt;/code&gt;. In release mode, it would expand to an expression passing through the value, i.e. &lt;code&gt;{ v }&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that the function passes through the ownership of the variable, just like the &lt;a href=&#34;https://doc.rust-lang.org/std/macro.dbg.html&#34;&gt;&lt;code&gt;std::dbg!&lt;/code&gt;&lt;/a&gt; macro.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn __firedbg_trace__&amp;lt;T&amp;gt;(name: &amp;amp;&#39;static str, v: T) -&amp;gt; T { v }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apache License, Version 2.0 (&lt;a href=&#34;https://raw.githubusercontent.com/SeaQL/FireDBG.for.Rust/main/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; or &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;MIT license (&lt;a href=&#34;https://raw.githubusercontent.com/SeaQL/FireDBG.for.Rust/main/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; or &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your option.&lt;/p&gt; &#xA;&lt;p&gt;Any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>occlum/occlum</title>
    <updated>2023-12-15T01:41:30Z</updated>
    <id>tag:github.com,2023-12-15:/occlum/occlum</id>
    <link href="https://github.com/occlum/occlum" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Occlum is a memory-safe, multi-process library OS for Intel SGX&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/occlum/occlum/master/docs/images/logo.png&#34; alt=&#34;Occlum logo&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;&#xA; &lt;!-- render a nicely looking grey line to separate the logo from the content  --&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/occlum/occlum/master/CONTRIBUTORS.md&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/all_contributors-7-orange.svg?style=flat-square&#34; alt=&#34;All Contributors&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/occlum/occlum/actions?query=workflow%3A%22Essential+Test%22&#34;&gt;&lt;img src=&#34;https://github.com/occlum/occlum/workflows/Essential%20Test/badge.svg?branch=master&#34; alt=&#34;Essential Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/occlum/occlum/actions?query=workflow%3A%22SGX+Hardware+Mode+Test%22&#34;&gt;&lt;img src=&#34;https://github.com/occlum/occlum/workflows/SGX%20Hardware%20Mode%20Test/badge.svg?branch=master&#34; alt=&#34;SGX Hardware Mode Test&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/occlum/occlum/actions?query=workflow%3A%22Demo+Test%22&#34;&gt;&lt;img src=&#34;https://github.com/occlum/occlum/workflows/Demo%20Test/badge.svg?branch=master&#34; alt=&#34;Demo Test&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NEWS:&lt;/strong&gt; Our paper &lt;em&gt;Occlum: Secure and Efficient Multitasking Inside a Single Enclave of Intel SGX&lt;/em&gt; has been accepted by &lt;a href=&#34;https://asplos-conference.org/programs/&#34;&gt;ASPLOS&#39;20&lt;/a&gt;. This research paper highlights the advantages of the single-address-space architecture adopted by Occlum and describes a novel in-enclave isolation mechanism that complements this approach. The paper can be found on &lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3373376.3378469&#34;&gt;ACM Digital Library&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/2001.07450&#34;&gt;Arxiv&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Occlum is a &lt;em&gt;memory-safe&lt;/em&gt;, &lt;em&gt;multi-process&lt;/em&gt; library OS (LibOS) for &lt;a href=&#34;https://software.intel.com/en-us/sgx&#34;&gt;Intel SGX&lt;/a&gt;. As a LibOS, it enables &lt;em&gt;legacy&lt;/em&gt; applications to run on SGX with &lt;em&gt;little or even no modifications&lt;/em&gt; of source code, thus protecting the confidentiality and integrity of user workloads transparently.&lt;/p&gt; &#xA;&lt;p&gt;Occlum has the following salient features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Efficient multitasking.&lt;/strong&gt; Occlum offers &lt;em&gt;light-weight&lt;/em&gt; LibOS processes: they are light-weight in the sense that all LibOS processes share the same SGX enclave. Compared to the heavy-weight, per-enclave LibOS processes, Occlum&#39;s light-weight LibOS processes is up to &lt;em&gt;1,000X faster&lt;/em&gt; on startup and &lt;em&gt;3X faster&lt;/em&gt; on IPC. In addition, Occlum offers an optional &lt;a href=&#34;https://raw.githubusercontent.com/occlum/occlum/master/docs/pku_manual.md&#34;&gt;&lt;strong&gt;PKU&lt;/strong&gt;&lt;/a&gt; (Protection Keys for Userspace) feature to enhance fault isolation between Occlum&#39;s LibOS and userspace processes if needed.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Multiple file system support.&lt;/strong&gt; Occlum supports various types of file systems, e.g., &lt;em&gt;read-only hashed FS&lt;/em&gt; (for integrity protection), &lt;em&gt;writable encrypted FS&lt;/em&gt; (for confidentiality protection), &lt;em&gt;untrusted host FS&lt;/em&gt; (for convenient data exchange between the LibOS and the host OS).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Memory safety.&lt;/strong&gt; Occlum is the &lt;em&gt;first&lt;/em&gt; SGX LibOS written in a memory-safe programming language (&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;). Thus, Occlum is much less likely to contain low-level, memory-safety bugs and is more trustworthy to host security-critical applications.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Ease-of-use.&lt;/strong&gt; Occlum provides user-friendly build and command-line tools. Running applications on Occlum inside SGX enclaves can be as simple as only typing several shell commands (see the next section).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Since version 0.30.0, Occlum has introduced EDMM as an optional feature. With EDMM, Occlum configurations become more flexible, and enclave loading time is significantly reduced. More details please refer to &lt;a href=&#34;https://raw.githubusercontent.com/occlum/occlum/master/docs/edmm/edmm_config_guide.md&#34;&gt;edmm_config_guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Occlum Documentation&lt;/h2&gt; &#xA;&lt;p&gt;The official Occlum documentation can be found at &lt;a href=&#34;https://occlum.readthedocs.io&#34;&gt;&lt;code&gt;https://occlum.readthedocs.io&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Some quick links are as below.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://occlum.readthedocs.io/en/latest/quickstart.html#&#34;&gt;&lt;code&gt;Quick Start&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://occlum.readthedocs.io/en/latest/build_and_install.html#&#34;&gt;&lt;code&gt;Build and Install&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://occlum.readthedocs.io/en/latest/occlum_configuration.html&#34;&gt;&lt;code&gt;Occlum Configuration&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://occlum.readthedocs.io/en/latest/binaries_compatibility.html&#34;&gt;&lt;code&gt;Occlum Compatible Executable Binaries&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://occlum.readthedocs.io/en/latest/Demos/demos.html&#34;&gt;&lt;code&gt;Demos&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://occlum.readthedocs.io/en/latest/qa.html&#34;&gt;&lt;code&gt;Q &amp;amp; A&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What is the Implementation Status?&lt;/h2&gt; &#xA;&lt;p&gt;Occlum is being actively developed. We now focus on implementing more system calls and additional features required in the production environment, including baremetal server and public cloud (Aliyun, Azure, ...) VM.&lt;/p&gt; &#xA;&lt;p&gt;Also, a dedicated branch &lt;strong&gt;1.0.0-preview&lt;/strong&gt; is used for next generation Occlum development.&lt;/p&gt; &#xA;&lt;h2&gt;How about the Internal Working?&lt;/h2&gt; &#xA;&lt;p&gt;The high-level architecture of Occlum is summarized in the figure below:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/occlum/occlum/master/docs/images/arch_overview.png&#34; alt=&#34;Arch Overview&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why the Name?&lt;/h2&gt; &#xA;&lt;p&gt;The project name Occlum stems from the word &lt;em&gt;Occlumency&lt;/em&gt; coined in Harry Potter series by J. K. Rowling. In &lt;em&gt;Harry Potter and the Order of Phoenix&lt;/em&gt;, Occlumency is described as:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The magical defence of the mind against external penetration. An obscure branch of magic, but a highly useful one... Used properly, the power of Occlumency will help shield you from access or influence.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;The same thing can be said for Occlum, not for the mind, but for the program:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;The magical defence of the program against external penetration. An obscure branch of technology, but a highly useful one... Used properly, the power of Occlum will help shield your program from access or influence.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Of course, Occlum must be run on Intel x86 CPUs with SGX support to do its magic.&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;Contributions of any kind are welcome! We will publish contributing guidelines and accept pull requests after the project gets more stable.&lt;/p&gt; &#xA;&lt;p&gt;Thanks go to &lt;a href=&#34;https://raw.githubusercontent.com/occlum/occlum/master/CONTRIBUTORS.md&#34;&gt;all these wonderful contributors to this project&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Occlum is released under BSD License. See the copyright information &lt;a href=&#34;https://raw.githubusercontent.com/occlum/occlum/master/LICENSE&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>