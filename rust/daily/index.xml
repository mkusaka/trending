<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-25T01:45:59Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>AmbientRun/Ambient</title>
    <updated>2023-02-25T01:45:59Z</updated>
    <id>tag:github.com,2023-02-25:/AmbientRun/Ambient</id>
    <link href="https://github.com/AmbientRun/Ambient" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The multiplayer game engine&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Ambient&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/ambient_api&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/ambient_api&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/ambient_api&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/ambient_api&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/AmbientRun/Ambient#license&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34; alt=&#34;MIT&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/PhmPn6m8Tw&#34;&gt;&lt;img src=&#34;https://img.shields.io/discord/894505972289134632&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ambient is a runtime for building high-performance multiplayer games and 3D applications, powered by WebAssembly, Rust and WebGPU.&lt;/p&gt; &#xA;&lt;p&gt;See our &lt;a href=&#34;https://www.ambient.run/post/introducing-ambient&#34;&gt;announcement blog post&lt;/a&gt; for more details.&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Seamless networking&lt;/strong&gt;: Ambient is both your server and client. All you need to do is to build your server and/or client-side logic: the runtime handles synchronization of data for you.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Isolation&lt;/strong&gt;: Projects you build for Ambient are executed in isolation through the power of &lt;a href=&#34;https://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt; - so that if something crashes, it wonâ€™t take down your entire program. It also means that you can run untrusted code safely.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Data-oriented design&lt;/strong&gt;: The core data model of Ambient is an &lt;a href=&#34;https://en.wikipedia.org/wiki/Entity_component_system&#34;&gt;entity component system&lt;/a&gt; which each WASM module can manipulate.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Language-agnostic&lt;/strong&gt;: You will be able to build Ambient modules in any language that can compile to WebAssembly. At present, Rust is the only supported language, but we are working on expanding to other languages.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Single executable&lt;/strong&gt;: Ambient is a single executable which can run on Windows, Mac and Linux. It can act as a server or as a client.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Interoperability&lt;/strong&gt;: Ambient allows you to define custom components and &#34;concepts&#34; (collections of components). As long as your Ambient projects use the same components and concepts, they will be able to share data and interoperate, even if they have no awareness of each other.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Asset pipeline and streaming&lt;/strong&gt;: Ambient has an &lt;a href=&#34;https://ambientrun.github.io/Ambient/reference/asset_pipeline.html&#34;&gt;asset pipeline&lt;/a&gt; that is capable of compiling multiple asset formats, including &lt;code&gt;.glb&lt;/code&gt; and &lt;code&gt;.fbx&lt;/code&gt;. The assets are always streamed over the network, so your clients will receive everything they need when they join.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful renderer&lt;/strong&gt;: The Ambient renderer is GPU-driven, with both culling and level-of-detail switching being handled entirely by the GPU. By default, it uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Physically_based_rendering&#34;&gt;PBR&lt;/a&gt;. It also supports cascading shadow maps and instances everything that can be instanced.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://ambientrun.github.io/Ambient/&#34;&gt;documentation&lt;/a&gt; for a guide on how to get started, or browse the &lt;a href=&#34;https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples&#34;&gt;examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;The easiest way to get Ambient is by downloading the latest release &lt;a href=&#34;https://github.com/AmbientRun/Ambient/releases&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For alternative installation options, go to the &lt;a href=&#34;https://ambientrun.github.io/Ambient/user/installing.html&#34;&gt;documentation on installing&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note: Ambient is in an alpha stage and the API will be iterated on heavily. We are working towards a stable release.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Status&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ECS&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;Single-threaded.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WASM API&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;Rust is the only supported guest language right now, and WASM can only be used on the server. We are working on clientside WASM; see &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/6&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Multiplayer/networking&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;Multiplayer is server-authoritative without any prediction or compensation. See &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/150&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPU-driven renderer&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;FBX &amp;amp; glTF loading&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Physics (through PhysX)&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;Using PhysX 4.1. PhysX 5 support is tracked in &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/155&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Animations&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Skinmeshing&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Shadow maps&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Decals&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GPU culling and LoD&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Multi-platform&lt;/td&gt; &#xA;   &lt;td&gt;âœ…&lt;/td&gt; &#xA;   &lt;td&gt;Windows, Mac, and Linux so far. x86-64 and ARM64 are actively supported; other platforms may also work, but require testing.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Run on Web&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;See &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/151&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Multithreading API&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;Multithreading is already used internally, but we want to expose multithreading functionality within the WASM API. This may be explicit (i.e. task- or thread-spawning) or implicit (WASM modules being scheduled across threads).&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;UI API&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;A React-like UI library already exists in the repo, and we&#39;re working on exposing it through the WASM API. See &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/40&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Custom shaders&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;Custom shaders are supported by the renderer, but are not yet exposed in the API. See &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/98&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Hot-reloading assets&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;See &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/12&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Audio&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;Audio is supported, but not currently exposed. See &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/76&#34;&gt;this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ECS save/load&lt;/td&gt; &#xA;   &lt;td&gt;ðŸš§&lt;/td&gt; &#xA;   &lt;td&gt;For loading, &lt;a href=&#34;https://github.com/AmbientRun/Ambient/issues/71&#34;&gt;see this issue&lt;/a&gt;.&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Each example in the &lt;a href=&#34;https://raw.githubusercontent.com/AmbientRun/Ambient/main/guest/rust/examples/&#34;&gt;examples&lt;/a&gt; directory can be run with Ambient as both client and server:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cd guest/rust/examples/tictactoe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ambient run&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Every example can also be run server-only. To do so:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;cd guest/rust/examples/tictactoe&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ambient serve&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This will start a server that other people, including yourself, can join (assuming that ports 8999 and 9000 are forwarded):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ambient join [IP_OF_SERVER]&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Note that content is always streamed, so the only thing the joining user requires is Ambient itself to join the session.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome community contributions to this project.&lt;/p&gt; &#xA;&lt;p&gt;Please talk with us on Discord beforehand if you&#39;d like to contribute a larger piece of work.&lt;/p&gt; &#xA;&lt;h2&gt;License (MIT)&lt;/h2&gt; &#xA;&lt;p&gt;Ambient is licensed under MIT. See the &lt;a href=&#34;https://raw.githubusercontent.com/AmbientRun/Ambient/main/LICENSE.md&#34;&gt;LICENSE&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>lencx/nofwl</title>
    <updated>2023-02-25T01:45:59Z</updated>
    <id>tag:github.com,2023-02-25:/lencx/nofwl</id>
    <link href="https://github.com/lencx/nofwl" rel="alternate"></link>
    <summary type="html">&lt;p&gt;NoFWL Desktop Application&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;nofwl&lt;/h1&gt; &#xA;&lt;p&gt;NoFWL Desktop Application&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>hydro-project/rust-sitter</title>
    <updated>2023-02-25T01:45:59Z</updated>
    <id>tag:github.com,2023-02-25:/hydro-project/rust-sitter</id>
    <link href="https://github.com/hydro-project/rust-sitter" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Use Tree Sitter to parse your own languages in Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rust Sitter&lt;/h1&gt; &#xA;&lt;p&gt;Rust Sitter makes it easy to create efficient parsers in Rust by leveraging the &lt;a href=&#34;https://tree-sitter.github.io/tree-sitter/&#34;&gt;Tree Sitter&lt;/a&gt; parser generator. With Rust Sitter, you can define your entire grammar with annotations on idiomatic Rust code, and let macros generate the parser and type-safe bindings for you!&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;First, add Rust/Tree Sitter to your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;rust-sitter = &#34;0.2.1&#34;&#xA;&#xA;[build-dependencies]&#xA;rust-sitter-tool = &#34;0.2.1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Note: By default, Rust Sitter uses a fork of Tree Sitter with a pure-Rust runtime to support &lt;code&gt;wasm32-unknown-unknown&lt;/code&gt;. To use the standard C runtime instead, disable default features and enable the &lt;code&gt;tree-sitter-standard&lt;/code&gt; feature&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;The first step is to configure your &lt;code&gt;build.rs&lt;/code&gt; to compile and link the generated Tree Sitter parser:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::path::PathBuf;&#xA;&#xA;fn main() {&#xA;    println!(&#34;cargo:rerun-if-changed=src&#34;);&#xA;    rust_sitter_tool::build_parsers(&amp;amp;PathBuf::from(&#34;src/main.rs&#34;));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Defining a Grammar&lt;/h2&gt; &#xA;&lt;p&gt;Now that we have Rust Sitter added to our project, we can define our grammar. Rust Sitter grammars are defined in annotated Rust modules. First, we define the module that will contain our grammar&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[rust_sitter::grammar(&#34;arithmetic&#34;)]&#xA;mod grammar {&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, inside the module, we can define individual AST nodes. For this simple example, we&#39;ll define an expression that can be used in a mathematical expression. Note that we annotate this type as &lt;code&gt;#[rust_sitter::language]&lt;/code&gt; to indicate that it is the root AST type.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[rust_sitter::language]&#xA;pub enum Expr {&#xA;    Number(u32),&#xA;    Add(Box&amp;lt;Expr&amp;gt;, Box&amp;lt;Expr&amp;gt;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now that we have the type defined, we must annotate the enum variants to describe how to identify them in the text being parsed. First, we can apply &lt;code&gt;rust_sitter::leaf&lt;/code&gt; to use a regular expression to match digits corresponding to a number, and define a transformation that parses the resulting string into a &lt;code&gt;u32&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Number(&#xA;    #[rust_sitter::leaf(pattern = r&#34;\d+&#34;, transform = |v| v.parse().unwrap())]&#xA;    u32,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For the &lt;code&gt;Add&lt;/code&gt; variant, things are a bit more complicated. First, we add an extra field corresponding to the &lt;code&gt;+&lt;/code&gt; that must sit between the two sub-expressions. This can be achieved with &lt;code&gt;text&lt;/code&gt; parameter of &lt;code&gt;rust_sitter::leaf&lt;/code&gt;, which instructs the parser to match a specific string. Because we are parsing to &lt;code&gt;()&lt;/code&gt;, we do not need to provide a transformation.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Add(&#xA;    Box&amp;lt;Expr&amp;gt;,&#xA;    #[rust_sitter::leaf(text = &#34;+&#34;)] (),&#xA;    Box&amp;lt;Expr&amp;gt;,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If we try to compile this grammar, however, we will see ane error due to conflicting parse trees for expressions like &lt;code&gt;1 + 2 + 3&lt;/code&gt;, which could be parsed as &lt;code&gt;(1 + 2) + 3&lt;/code&gt; or &lt;code&gt;1 + (2 + 3)&lt;/code&gt;. We want the former, so we can add a further annotation specifying that we want left-associativity for this rule.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[rust_sitter::prec_left(1)]&#xA;Add(&#xA;    Box&amp;lt;Expr&amp;gt;,&#xA;    #[rust_sitter::leaf(text = &#34;+&#34;)] (),&#xA;    Box&amp;lt;Expr&amp;gt;,&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All together, our grammar looks like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[rust_sitter::grammar(&#34;arithmetic&#34;)]&#xA;mod grammar {&#xA;    #[rust_sitter::language]&#xA;    pub enum Expr {&#xA;        Number(&#xA;            #[rust_sitter::leaf(pattern = r&#34;\d+&#34;, transform = |v| v.parse().unwrap())]&#xA;            u32,&#xA;        ),&#xA;        #[rust_sitter::prec_left(1)]&#xA;        Add(&#xA;            Box&amp;lt;Expr&amp;gt;,&#xA;            #[rust_sitter::leaf(text = &#34;+&#34;)] (),&#xA;            Box&amp;lt;Expr&amp;gt;,&#xA;        )&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can then parse text using this grammar:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;dbg!(grammar::parse(&#34;1+2+3&#34;));&#xA;/*&#xA;grammar::parse(&#34;1+2+3&#34;) = Ok(Add(&#xA;    Add(&#xA;        Number(&#xA;            1,&#xA;        ),&#xA;        (),&#xA;        Number(&#xA;            2,&#xA;        ),&#xA;    ),&#xA;    (),&#xA;    Number(&#xA;        3,&#xA;    ),&#xA;))&#xA;*/&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Type Annotations&lt;/h2&gt; &#xA;&lt;p&gt;Rust Sitter supports a number of annotations that can be applied to type and fields in your grammar. These annotations can be used to control how the parser behaves, and how the resulting AST is constructed.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;#[rust_sitter::language]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This annotation marks the entrypoint for parsing, and determines which AST type will be returned from parsing. Only one type in the grammar can be marked as the entrypoint.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[rust_sitter::language]&#xA;struct Code {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;#[rust_sitter::extra]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This annotation marks a node as extra and can safely be skipped while parsing. This is useful for handling whitespace/newlines/comments.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[rust_sitter::extra]&#xA;struct Whitespace {&#xA;    #[rust_sitter::leaf(pattern = r&#34;\s&#34;)]&#xA;    _whitespace: (),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Field Annotations&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;#[rust_sitter::leaf(...)]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;#[rust_sitter::leaf(...)]&lt;/code&gt; annotation can be used to define a leaf node in the AST. This annotation takes a number of parameters that control how the parser behaves:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the &lt;code&gt;pattern&lt;/code&gt; parameter takes a regular expression that is used to match the text of the leaf node. This parameter is required.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;text&lt;/code&gt; parameter takes a string that is used to match the text of the leaf node. This parameter is mutually exclusive with &lt;code&gt;pattern&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;the &lt;code&gt;transform&lt;/code&gt; parameter takes a function that is used to transform the matched text (an &lt;code&gt;&amp;amp;str&lt;/code&gt;) into the desired type. This parameter is optional if the target type is &lt;code&gt;()&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;&lt;code&gt;#[rust_sitter::prec(...)]&lt;/code&gt; / &lt;code&gt;#[rust_sitter::prec_left(...)]&lt;/code&gt; / &lt;code&gt;#[rust_sitter::prec_right(...)]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This annotation can be used to define a non/left/right-associative operator. This annotation takes a single parameter, which is the precedence level of the operator (higher binds more tightly).&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;#[rust_sitter::skip(...)]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This annotation can be used to define a field that does not correspond to anything in the input string, such as some metadata. This annotation takes a single parameter, which is the value that should be used to populate that field at runtime.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;#[rust_sitter::word]&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;This annotation marks the field as a Tree Sitter &lt;a href=&#34;https://tree-sitter.github.io/tree-sitter/creating-parsers#keywords&#34;&gt;word&lt;/a&gt;, which is useful when handling errors involving keywords. Only one field in the grammar can be marked as a word.&lt;/p&gt; &#xA;&lt;h2&gt;Special Types&lt;/h2&gt; &#xA;&lt;p&gt;Rust Sitter has a few special types that can be used to define more complex grammars.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To parse repeating structures, you can use a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; to parse a list of &lt;code&gt;T&lt;/code&gt;s. Note that the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type &lt;strong&gt;cannot&lt;/strong&gt; be wrapped in another &lt;code&gt;Vec&lt;/code&gt; (create additional structs if this is necessary). There are two special attributes that can be applied to a &lt;code&gt;Vec&lt;/code&gt; field to control the parsing behavior.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;#[rust_sitter::delimited(...)]&lt;/code&gt; attribute can be used to specify a separator between elements of the list, and takes a parameter of the same format as an unnamed field. For example, we can define a grammar that parses a comma-separated list of expressions:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct CommaSeparatedExprs {&#xA;    #[rust_sitter::delimited(&#xA;        #[rust_sitter::leaf(text = &#34;,&#34;)]&#xA;        ()&#xA;    )]&#xA;    numbers: Vec&amp;lt;Expr&amp;gt;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;#[rust_sitter::repeat(...)]&lt;/code&gt; attribute can be used to specify additional configuration for the parser. Currently, there is only one available parameter: &lt;code&gt;non_empty&lt;/code&gt;, which takes a boolean that specifies if the list must contain at least one element. For example, we can define a grammar that parses a non-empty comma-separated list of numbers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct CommaSeparatedExprs {&#xA;    #[rust_sitter::repeat(non_empty = true)]&#xA;    #[rust_sitter::delimited(&#xA;        #[rust_sitter::leaf(text = &#34;,&#34;)]&#xA;        ()&#xA;    )]&#xA;    numbers: Vec&amp;lt;Expr&amp;gt;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;To parse optional structures, you can use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to parse a single &lt;code&gt;T&lt;/code&gt; or nothing. Like &lt;code&gt;Vec&lt;/code&gt;, the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type &lt;strong&gt;cannot&lt;/strong&gt; be wrapped in another &lt;code&gt;Option&lt;/code&gt; (create additional structs if this is necessary). For example, we can make the list elements in the previous example optional so we can parse strings like &lt;code&gt;1,,2&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct CommaSeparatedExprs {&#xA;    #[rust_sitter::repeat(non_empty = true)]&#xA;    #[rust_sitter::delimited(&#xA;        #[rust_sitter::leaf(text = &#34;,&#34;)]&#xA;        ()&#xA;    )]&#xA;    numbers: Vec&amp;lt;Option&amp;lt;Expr&amp;gt;&amp;gt;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;rust_sitter::Spanned&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;When using Rust Sitter to power diagnostic tools, it can be helpful to access spans marking the sections of text corresponding to a parsed node. To do this, you can use the &lt;code&gt;Spanned&amp;lt;T&amp;gt;&lt;/code&gt; type, which captures the underlying parsed &lt;code&gt;T&lt;/code&gt; and a pair of indices for the start (inclusive) and end (exclusive) of the corresponding substring. &lt;code&gt;Spanned&lt;/code&gt; types can be used anywhere, and do not affect the parsing logic. For example, we could capture the spans of the expressions in our previous example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct CommaSeparatedExprs {&#xA;    #[rust_sitter::repeat(non_empty = true)]&#xA;    #[rust_sitter::delimited(&#xA;        #[rust_sitter::leaf(text = &#34;,&#34;)]&#xA;        ()&#xA;    )]&#xA;    numbers: Vec&amp;lt;Option&amp;lt;Spanned&amp;lt;Expr&amp;gt;&amp;gt;&amp;gt;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Boxes are automatically constructed around the inner type when parsing, but Rust Sitter doesn&#39;t do anything extra beyond that.&lt;/p&gt;</summary>
  </entry>
</feed>