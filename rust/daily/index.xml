<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-18T01:40:13Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Keats/tera</title>
    <updated>2023-12-18T01:40:13Z</updated>
    <id>tag:github.com,2023-12-18:/Keats/tera</id>
    <link href="https://github.com/Keats/tera" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A template engine for Rust based on Jinja2/Django&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Tera&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Keats/tera/actions&#34;&gt;&lt;img src=&#34;https://github.com/Keats/tera/workflows/ci/badge.svg?sanitize=true&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/tera&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/tera.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/crate/tera/&#34;&gt;&lt;img src=&#34;https://docs.rs/tera/badge.svg?sanitize=true&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/Tera-templates/community?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/Tera-templates/community.svg?sanitize=true&#34; alt=&#34;Gitter&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Tera is a template engine inspired by &lt;a href=&#34;http://jinja.pocoo.org/&#34;&gt;Jinja2&lt;/a&gt; and the &lt;a href=&#34;https://docs.djangoproject.com/en/3.1/topics/templates/&#34;&gt;Django template language&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja2&#34;&gt;&amp;lt;title&amp;gt;{% block title %}{% endblock title %}&amp;lt;/title&amp;gt;&#xA;&amp;lt;ul&amp;gt;&#xA;{% for user in users %}&#xA;  &amp;lt;li&amp;gt;&amp;lt;a href=&#34;{{ user.url }}&#34;&amp;gt;{{ user.username }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#xA;{% endfor %}&#xA;&amp;lt;/ul&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It does not aim to be 100% compatible with them but has many of the Jinja2/Django filters and testers.&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;API documentation is available on &lt;a href=&#34;https://docs.rs/crate/tera/&#34;&gt;docs.rs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Tera documentation is available on its &lt;a href=&#34;http://keats.github.io/tera/docs&#34;&gt;site&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;SemVer&lt;/h2&gt; &#xA;&lt;p&gt;This project follows SemVer only for the public API, public API here meaning functions appearing in the docs. Some features, like accessing the AST, are also available but breaking changes in them can happen in any versions.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>okeyzero/evm_Ink_Rs</title>
    <updated>2023-12-18T01:40:13Z</updated>
    <id>tag:github.com,2023-12-18:/okeyzero/evm_Ink_Rs</id>
    <link href="https://github.com/okeyzero/evm_Ink_Rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;evm 系列 以太坊 bsc matic avax okx 等 区块链 通用 快速 打铭文工具&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;evm_ink_rs :evm系列通用打铭文工具 &lt;img src=&#34;https://img.shields.io/twitter/follow/0xNaiXi?style=social&#34; alt=&#34;twitter&#34;&gt;&lt;/h1&gt; &#xA;&lt;h1&gt;展示&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/okeyzero/evm_Ink_Rs/master/img.png&#34; alt=&#34;img.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;测试地址 &lt;a href=&#34;https://goerli.etherscan.io/tx/0xa7d4962386b3813596fefb81e16fe8eaec21f1589ebd0b573bf6757b118cfdf5&#34;&gt;https://goerli.etherscan.io/tx/0xa7d4962386b3813596fefb81e16fe8eaec21f1589ebd0b573bf6757b118cfdf5&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;使用方法&lt;/h1&gt; &#xA;&lt;p&gt;1,下载本项目,自行编译或者运行别人编译好的版本&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# 如果安装过rust 可以输入命令(务必设置好.env文件内容)&#xA;cargo run --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;2,自行设置.env文件内容&lt;/p&gt; &#xA;&lt;p&gt;3,运行&lt;/p&gt; &#xA;&lt;h1&gt;使用详情说明&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;rpc设置 &lt;code&gt;必填&lt;/code&gt;:&lt;/strong&gt; rpc 需要支持 batchRequest 一般都会支持&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;主网: &lt;a href=&#34;https://rpc.ankr.com/eth&#34;&gt;https://rpc.ankr.com/eth&lt;/a&gt; holesky测试网: &lt;a href=&#34;https://ethereum-goerli.publicnode.com&#34;&gt;https://ethereum-goerli.publicnode.com&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rpc_url=https://ethereum-goerli.publicnode.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;你的私钥&lt;code&gt;必填&lt;/code&gt;:&lt;/strong&gt; 带不带0x前缀都可以&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;private_key=b959811d951cfa75a5af5560db81d4a651535206d86fda54df02a6eece90d2b0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;接收地址 &lt;code&gt;选填&lt;/code&gt;:&lt;/strong&gt; 带0x前缀,可不填 不填默认为私钥对应的钱包地址&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;#to_address=&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;4&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;最大 gas 费用 &lt;code&gt;必填&lt;/code&gt;:&lt;/strong&gt; 这个值一定要大于 gas 优先费用&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;max_fee_per_gas=130&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;5&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;gas 优先费用(小费) &lt;code&gt;选填&lt;/code&gt;:&lt;/strong&gt; 如果当前链 不支持小费模式(EIP1559 比如 bsc) 这个值可以不填&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;max_priority_fee_per_gas=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;6&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;mint 的数量 &lt;code&gt;必填&lt;/code&gt;:&lt;/strong&gt; 如果包含id 范围数据 会取 count 和 id 范围的最小值&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;count=1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;7&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;mint 的数据 &lt;code&gt;必填&lt;/code&gt;:&lt;/strong&gt; 直接复制铭文文本，或十六进制（必须0x开头）复杂数据看下方说明&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;6227&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;或&#xA;data=0x646174613a2c7b2270223a226572632d3230222c226f70223a226d696e74222c227469636b223a2265746873222c226964223a2236323237222c22616d74223a2231303030227d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;8&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;prefix &lt;code&gt;选填&lt;/code&gt;:&lt;/strong&gt; 正常不需要设置和修改 除非 是 新出的各种 铭文协议 常规铭文 不懂不要设置&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;#prefix=data:,&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;9&#34;&gt; &#xA; &lt;li&gt;&lt;strong&gt;gas_limit &lt;code&gt;选填&lt;/code&gt;:&lt;/strong&gt; 正常不需要设置和修改 默认为 50000 但是由于个别项目 或者 个别链 50000 可能不够用 可以设置&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;#gas_limit=260000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;mint 的数据详细说明&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;如果是 json 文本格式(如 {&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;pi&#34;,&#34;amt&#34;:&#34;1000&#34;}) 前后一定要加一个 单引号(&lt;code&gt;&#39;&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;注意 双引号(&lt;code&gt;&#34;&lt;/code&gt;) 具体包裹的数据 注意 数据究竟带不带双引号&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;下方都是正确的例子 和 解释&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;你要 mint 的 数据，十六进制格式(0x开头的数据) 和 文本格式(json 格式 前后需要加两个单引号) 都可以填&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;6227&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;如果 json 数据中 有 需要改成当前地址的地方 使用 [address] 代替(注意前后的单引号) 下方是正确例子&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;6227&#34;,&#34;to&#34;:&#34;[address]&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;如果 json 数据中 有 需要更改序号的地方 使用 [start-end] 代替(注意前后的单引号)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;下方是三种情况 下方是正确例子&lt;/p&gt; &#xA;&lt;p&gt;(1) 下方是 id 从 1000 到 2000 的情况 具体数值需要自己设置 可以范围大一点 mint 数量会取 范围 和 上方 count 的最小值&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;[1000-1100]&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;[1000-2000]&#34;,&#34;to&#34;:&#34;[address]&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;[1000-1001]&#34;,&#34;to&#34;:&#34;[address]&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(2) 下方是 id 到 2000 结尾 的情况 程序会自动 从 2000 递减, 直到发出 上方设置 count 数量的交易, 也就是说如果 count 设置为 3 那么会发出 2000, 1999, 1998 三笔交易 具体数值 自己设置&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;[-2000]&#34;,&#34;to&#34;:&#34;[address]&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(3) 下方是 id 从 1000 开始 的情况 程序会自动 从 1000 递增, 直到发出 上方设置 count 数量的交易, 也就是说如果 count 设置为 3 那么会发出 1000, 1001, 1002 三笔交易 具体数值 自己设置&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;data=&#39;{&#34;p&#34;:&#34;erc-20&#34;,&#34;op&#34;:&#34;mint&#34;,&#34;tick&#34;:&#34;eths&#34;,&#34;id&#34;:&#34;[1000-]&#34;,&#34;to&#34;:&#34;[address]&#34;,&#34;amt&#34;:&#34;1000&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;提示&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;先1张测试成功后再加数量, 或者使用其他gas低的链rpc先测试使用&lt;/li&gt; &#xA; &lt;li&gt;软件未经过大量测试, 请谨慎使用, 请自行测试&lt;/li&gt; &#xA; &lt;li&gt;不懂的看说明解释, 有问题可以留言&lt;/li&gt; &#xA; &lt;li&gt;全自动亏钱 关注 @0xNaiXi&lt;/li&gt; &#xA; &lt;li&gt;恭喜发财&lt;/li&gt; &#xA; &lt;li&gt;合作联系推特 @0xNaiXi&lt;/li&gt; &#xA; &lt;li&gt;有时候由于 卡链 发出去的交易 一直卡再 交易池 不会被执行 多跑几次就行了&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;说明&lt;/h1&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;只是学习rust的练手项目(代码搬运工)，代码比较烂，有更优者可以提pr 或 留言你的项目地址&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
  <entry>
    <title>tontinton/dbeel</title>
    <updated>2023-12-18T01:40:13Z</updated>
    <id>tag:github.com,2023-12-18:/tontinton/dbeel</id>
    <link href="https://github.com/tontinton/dbeel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A distributed thread-per-core document database&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/tontinton/dbeel/main/logo.svg?sanitize=true&#34;&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;dbeel&lt;/code&gt; is an attempt to learn modern database architecture.&lt;/p&gt; &#xA;&lt;p&gt;The best one-liner to describe the db is: &lt;em&gt;A distributed thread-per-core document database written in rust.&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;So basically it has a document API like in &lt;code&gt;MongoDB&lt;/code&gt; with leaderless replication like in &lt;code&gt;Cassandra&lt;/code&gt; and thread-per-core architecture like in &lt;code&gt;ScyllaDB&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s not production ready at all, but that doesn&#39;t mean there is no value in the project. If you ever wanted to read database code without getting overwhelmed by massive amounts of code, dbeel is for you.&lt;/p&gt; &#xA;&lt;p&gt;You can try it out by running &lt;code&gt;cargo install dbeel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;I&#39;ve also posted a &lt;a href=&#34;https://tontinton.com/posts/database-fundementals/&#34;&gt;blog post&lt;/a&gt; as a summary of what I&#39;ve learned working on this project.&lt;/p&gt; &#xA;&lt;h2&gt;Traits&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Documents + API in &lt;a href=&#34;https://msgpack.org&#34;&gt;msgpack&lt;/a&gt; format&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Log-structured_merge-tree&#34;&gt;LSM Tree&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Memtable is a red black tree&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://seastar.io/shared-nothing&#34;&gt;Thread per core&lt;/a&gt; (thanks &lt;code&gt;glommio&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://unixism.net/loti/what_is_io_uring.html&#34;&gt;io_uring&lt;/a&gt; (thanks again &lt;code&gt;glommio&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;Direct I/O &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Page cache implemented using &lt;a href=&#34;https://arxiv.org/pdf/1512.00727.pdf&#34;&gt;WTiny-LFU&lt;/a&gt; eviction algorithm&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Load balanced via &lt;a href=&#34;https://en.wikipedia.org/wiki/Consistent_hashing&#34;&gt;consistent hashing&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Each shard (core) is placed on the ring&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Metadata events sent using &lt;a href=&#34;https://en.wikipedia.org/wiki/Gossip_protocol&#34;&gt;gossip dissemination&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Leaderless replication with tunable consistency &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;replication_factor&lt;/code&gt; (parameter in &lt;code&gt;create_collection&lt;/code&gt; command) - Number of nodes that will store a copy of data&lt;/li&gt; &#xA;   &lt;li&gt;Write &lt;code&gt;consistency&lt;/code&gt; (parameter in &lt;code&gt;set&lt;/code&gt; command) - Number of nodes that will acknowledge a write for it to succeed&lt;/li&gt; &#xA;   &lt;li&gt;Read &lt;code&gt;consistency&lt;/code&gt; (parameter in &lt;code&gt;get&lt;/code&gt; command) - Number of nodes that have to respond to a read operation for it to succeed &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;Max timestamp conflict resolution&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;Running the benchmark on my machine (&lt;a href=&#34;https://tech-docs.system76.com/models/lemp11/README.html&#34;&gt;System76 lemp11&lt;/a&gt;) with no &lt;code&gt;fdatasync&lt;/code&gt; results in the following output:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Set:&#xA;total: 54.424290449s, min: 80.219µs, p50: 446.851µs, p90: 905.422µs, p99: 1.806261ms, p999: 7.463916ms, max: 35.385961ms&#xA;&#xA;Get:&#xA;total: 29.281556369s, min: 36.577µs, p50: 231.464µs, p90: 479.929µs, p99: 1.222589ms, p999: 3.269881ms, max: 6.242454ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Running with &lt;code&gt;--wal-sync&lt;/code&gt; (calls &lt;code&gt;fdatasync&lt;/code&gt; after each write to the WAL file) results in the following output for Set (note that &lt;code&gt;fdatasync&lt;/code&gt; on my machine takes 6-10ms):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Set:&#xA;total: 1253.611595658s, min: 6.625024ms, p50: 12.57609ms, p90: 12.858347ms, p99: 13.4931ms, p999: 19.062725ms, max: 31.880792ms&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can always configure &lt;code&gt;--wal-sync&lt;/code&gt; to achieve better throughput, with worse tail latencies, by setting &lt;code&gt;--wal-sync-delay&lt;/code&gt; (try setting half the time it takes to &lt;code&gt;fdatasync&lt;/code&gt; a file on average in your setup).&lt;/p&gt; &#xA;&lt;h2&gt;How to use&lt;/h2&gt; &#xA;&lt;p&gt;The only implemented client is in async rust, and can work on either &lt;code&gt;glommio&lt;/code&gt; or &lt;code&gt;tokio&lt;/code&gt; (select which using cargo features).&lt;/p&gt; &#xA;&lt;p&gt;Documents are formatted in &lt;code&gt;msgpack&lt;/code&gt; and the best crate I found for it is &lt;code&gt;rmpv&lt;/code&gt;, so the client makes heavy use of it.&lt;/p&gt; &#xA;&lt;p&gt;Example (mostly copied from &lt;code&gt;tokio_example/&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// When connecting to a cluster, you provide nodes to request cluster metadata from.&#xA;let seed_nodes = [(&#34;127.0.0.1&#34;, 10000)];&#xA;let client = DbeelClient::from_seed_nodes(&amp;amp;seed_nodes).await?;&#xA;&#xA;// Create a collection with replication of 3 (meaning 3 copies for each document).&#xA;let collection = client.create_collection_with_replication(COLLECTION_NAME, 3).await?;&#xA;&#xA;// Create key and document using rmpv.&#xA;let key = Value::String(&#34;key&#34;.into());&#xA;let document = Value::Map(vec![&#xA;    (Value::String(&#34;is_best_db&#34;.into()), Value::Boolean(true)),&#xA;    (Value::String(&#34;owner&#34;.into()), Value::String(&#34;tontinton&#34;.into())),&#xA;]);&#xA;&#xA;// Write document using quorum consistency.&#xA;collection.set_consistent(key.clone(), value.clone(), Consistency::Quorum).await?;&#xA;&#xA;// Read document using quorum consistency.&#xA;let response = collection.get_consistent(key, Consistency::Quorum).await?;&#xA;assert_eq!(response, value);&#xA;&#xA;// Drop collection.&#xA;collection.drop().await?;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Try out the benchmarks yourself&lt;/h2&gt; &#xA;&lt;p&gt;To compile the DB (you can skip building the db by running &lt;code&gt;cargo install dbeel&lt;/code&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo build --release&#xA;./target/release/dbeel --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To compile the blackbox benchmarks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd blackbox_bench&#xA;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To run the benchmarks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# If you installed using cargo instead of building, dbeel should be in your PATH.&#xA;./target/release/dbeel               # On first terminal&#xA;./target/release/blackbox-bench      # On second terminal&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>