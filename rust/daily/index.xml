<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-01T01:45:46Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bytecodealliance/javy</title>
    <updated>2023-06-01T01:45:46Z</updated>
    <id>tag:github.com,2023-06-01:/bytecodealliance/javy</id>
    <link href="https://github.com/bytecodealliance/javy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;JS to WebAssembly toolchain&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;&lt;code&gt;Javy&lt;/code&gt;&lt;/h1&gt; &#xA; &lt;p&gt; &lt;strong&gt;A &lt;i&gt;Jav&lt;/i&gt;aScript to Webassembl&lt;i&gt;y&lt;/i&gt; toolchain&lt;/strong&gt; &lt;/p&gt; &#xA; &lt;p&gt;&lt;strong&gt;A &lt;a href=&#34;https://bytecodealliance.org/&#34;&gt;Bytecode Alliance&lt;/a&gt; project&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt; &lt;a href=&#34;https://github.com/bytecodealliance/javy/actions/workflows/ci.yml&#34;&gt;&lt;img alt=&#34;Build status&#34; src=&#34;https://github.com/bytecodealliance/javy/actions/workflows/ci.yml/badge.svg?branch=main&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bytecodealliance.zulipchat.com/#narrow/stream/370816-javy&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/zulip-join_chat-brightgreen.svg?sanitize=true&#34; alt=&#34;zulip chat&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;About this repo&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;: Run your JavaScript on WebAssembly. Javy takes your JavaScript code, and executes it in a WebAssembly embedded JavaScript runtime. Javy can create &lt;em&gt;very&lt;/em&gt; small Wasm modules in the 1 to 16 KB range with use of dynamic linking. The default static linking produces modules that are at least 869 KB in size.&lt;/p&gt; &#xA;&lt;h2&gt;Runtime requirements&lt;/h2&gt; &#xA;&lt;p&gt;When running the official Javy binary on Linux, &lt;code&gt;glibc&lt;/code&gt; 2.31 or greater must be available. You may need to update the version of your operating system if you are using an older version of &lt;code&gt;glibc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;We welcome feedback, bug reports and bug fixes. We&#39;re also happy to discuss feature development but please discuss the features in an issue before contributing.&lt;/p&gt; &#xA;&lt;p&gt;Read our &lt;a href=&#34;https://raw.githubusercontent.com/bytecodealliance/javy/main/docs/contributing.md&#34;&gt;contribution documentation&lt;/a&gt; for additional information on contributing to Javy.&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://rustup.rs/&#34;&gt;rustup&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Stable Rust (&lt;code&gt;rustup install stable &amp;amp;&amp;amp; rustup default stable&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;wasm32-wasi, can be installed via &lt;code&gt;rustup target add wasm32-wasi&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;cmake, depending on your operating system and architecture, it might not be installed by default. On Mac it can be installed with &lt;code&gt;homebrew&lt;/code&gt; via &lt;code&gt;brew install cmake&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Rosetta 2 if running MacOS on Apple Silicon, can be installed via &lt;code&gt;softwareupdate --install-rosetta&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install the &lt;code&gt;wasi-sdk&lt;/code&gt; by running &lt;code&gt;make download-wasi-sdk&lt;/code&gt; in the top-level directory in this repository&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;wasmtime-cli, can be installed via &lt;code&gt;cargo install wasmtime-cli&lt;/code&gt; (required for &lt;code&gt;cargo-wasi&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;cargo-wasi, can be installed via &lt;code&gt;cargo install cargo-wasi&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;wizer, can be installed via &lt;code&gt;cargo install wizer --all-features&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;cargo-hack, can be installed via &lt;code&gt;cargo +stable install cargo-hack --locked&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;After all the dependencies are installed, run &lt;code&gt;make&lt;/code&gt; in the top-level directory of this repository. You should now have access to the executable in &lt;code&gt;target/release/javy&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Alternatively you can run &lt;code&gt;make &amp;amp;&amp;amp; cargo install --path crates/cli&lt;/code&gt;. After running the previous command you&#39;ll have a global installation of the executable.&lt;/p&gt; &#xA;&lt;h2&gt;Compiling to WebAssembly&lt;/h2&gt; &#xA;&lt;p&gt;Define your JavaScript like:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Read input from stdin&#xA;const input = readInput();&#xA;// Call the function with the input&#xA;const result = foo(input);&#xA;// Write the result to stdout&#xA;writeOutput(result);&#xA;&#xA;// The main function.&#xA;function foo(input) {&#xA;    return { foo: input.n + 1, newBar: input.bar + &#34;!&#34; };&#xA;}&#xA;&#xA;// Read input from stdin&#xA;function readInput() {&#xA;    const chunkSize = 1024;&#xA;    const inputChunks = [];&#xA;    let totalBytes = 0;&#xA;&#xA;    // Read all the available bytes&#xA;    while (1) {&#xA;        const buffer = new Uint8Array(chunkSize);&#xA;        // Stdin file descriptor&#xA;        const fd = 0;&#xA;        const bytesRead = Javy.IO.readSync(fd, buffer);&#xA;&#xA;        totalBytes += bytesRead;&#xA;        if (bytesRead === 0) {&#xA;            break;&#xA;        }&#xA;        inputChunks.push(buffer.subarray(0, bytesRead));&#xA;    }&#xA;&#xA;    // Assemble input into a single Uint8Array&#xA;    const { finalBuffer } = inputChunks.reduce((context, chunk) =&amp;gt; {&#xA;        context.finalBuffer.set(chunk, context.bufferOffset);&#xA;        context.bufferOffset += chunk.length;&#xA;        return context;&#xA;    }, { bufferOffset: 0, finalBuffer: new Uint8Array(totalBytes) });&#xA;&#xA;    return JSON.parse(new TextDecoder().decode(finalBuffer));&#xA;}&#xA;&#xA;// Write output to stdout&#xA;function writeOutput(output) {&#xA;    const encodedOutput = new TextEncoder().encode(JSON.stringify(output));&#xA;    const buffer = new Uint8Array(encodedOutput);&#xA;    // Stdout file descriptor&#xA;    const fd = 1;&#xA;    Javy.IO.writeSync(fd, buffer);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create a WebAssembly binary from your JavaScript by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;javy compile index.js -o destination/index.wasm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information on the commands you can run &lt;code&gt;javy --help&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can then execute your WebAssembly binary using a WebAssembly engine:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo &#39;{ &#34;n&#34;: 2, &#34;bar&#34;: &#34;baz&#34; }&#39; | wasmtime index.wasm&#xA;{&#34;foo&#34;:3,&#34;newBar&#34;:&#34;baz!&#34;}%   &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Invoking Javy-generated modules programatically&lt;/h3&gt; &#xA;&lt;p&gt;Javy-generated modules are by design WASI only and follow the &lt;a href=&#34;https://github.com/WebAssembly/WASI/raw/snapshot-01/design/application-abi.md#current-unstable-abi&#34;&gt;command pattern&lt;/a&gt;. Any input must be passed via &lt;code&gt;stdin&lt;/code&gt; and any output will be placed in &lt;code&gt;stdout&lt;/code&gt;. This is especially important when invoking Javy modules from a custom embedding.&lt;/p&gt; &#xA;&lt;p&gt;In a runtime like Wasmtime, &lt;a href=&#34;https://docs.rs/wasmtime-wasi/latest/wasmtime_wasi/struct.WasiCtx.html#method.set_stdin&#34;&gt;wasmtime-wasi&lt;/a&gt; can be used to set the input and retrieve the output.&lt;/p&gt; &#xA;&lt;h2&gt;Creating and using dynamically linked modules&lt;/h2&gt; &#xA;&lt;p&gt;An important use for Javy is for when you may want or need to generate much smaller Wasm modules. Using the &lt;code&gt;-d&lt;/code&gt; flag when invoking Javy will create a dynamically linked module which will have a much smaller file size than a statically linked module. Statically linked modules embed the JS engine inside the module while dynamically linked modules rely on Wasm imports to provide the JS engine. Dynamically linked modules have special requirements that statically linked modules do not and will not execute in WebAssembly runtimes that do not meet these requirements.&lt;/p&gt; &#xA;&lt;p&gt;To successfully instantiate and run a dynamically linked Javy module, the execution environment must provide a &lt;code&gt;javy_quickjs_provider_v1&lt;/code&gt; namespace for importing that links to the exports provided by the &lt;code&gt;javy_quickjs_provider.wasm&lt;/code&gt; module. Dynamically linked modules &lt;strong&gt;cannot&lt;/strong&gt; be instantiated in environments that do not provide this import.&lt;/p&gt; &#xA;&lt;p&gt;Dynamically linked Javy modules are tied to QuickJS since they use QuickJS&#39;s bytecode representation.&lt;/p&gt; &#xA;&lt;h3&gt;Obtaining the QuickJS provider module&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;javy_quickjs_provider.wasm&lt;/code&gt; module is available as an asset on the Javy release you are using. It can also be obtained by running &lt;code&gt;javy emit-provider -o &amp;lt;path&amp;gt;&lt;/code&gt; to write the module into &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Creating and running a dynamically linked module on the CLI&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;console.log(&#34;hello world!&#34;);&#39; &amp;gt; my_code.js&#xA;$ javy compile -d -o my_code.wasm my_code.js&#xA;$ javy emit-provider -o provider.wasm&#xA;$ wasmtime run --preload javy_quickjs_provider_v1=provider.wasm my_code.wasm&#xA;hello world!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Using quickjs-wasm-rs to build your own toolchain&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;code&gt;quickjs-wasm-rs&lt;/code&gt; crate that is part of this project can be used as part of a Rust crate targeting Wasm to customize how that Rust crate interacts with QuickJS. This may be useful when trying to use JavaScript inside a Wasm module and Javy does not fit your needs as &lt;code&gt;quickjs-wasm-rs&lt;/code&gt; contains serializers that make it easier to send structured data (for example, strings or objects) between host code and Wasm code.&lt;/p&gt; &#xA;&lt;h2&gt;Releasing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Update the root &lt;code&gt;Cargo.toml&lt;/code&gt; with the new version&lt;/li&gt; &#xA; &lt;li&gt;Create a tag for the new version like &lt;code&gt;v0.2.0&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code&gt;git tag v0.2.0&#xA;git push origin --tags&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Create a new release from the new tag in github &lt;a href=&#34;https://github.com/bytecodealliance/javy/releases/new&#34;&gt;here&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A GitHub Action will trigger for &lt;code&gt;publish.yml&lt;/code&gt; when a release is published (&lt;a href=&#34;https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#:~:text=created%2C%20edited%2C%20or%20deleted%20activity%20types%20for%20draft%20releases&#34;&gt;i.e. it doesn&#39;t run on drafts&lt;/a&gt;), creating the artifacts for downloading.&lt;/li&gt; &#xA;&lt;/ol&gt;</summary>
  </entry>
</feed>