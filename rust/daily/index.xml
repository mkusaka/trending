<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-25T01:33:37Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kylebarron/parquet-wasm</title>
    <updated>2024-04-25T01:33:37Z</updated>
    <id>tag:github.com,2024-04-25:/kylebarron/parquet-wasm</id>
    <link href="https://github.com/kylebarron/parquet-wasm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust-based WebAssembly bindings to read and write Apache Parquet data&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;WASM Parquet &lt;a href=&#34;https://www.npmjs.com/package/parquet-wasm&#34;&gt;&lt;img src=&#34;https://img.shields.io/npm/v/parquet-wasm.svg?sanitize=true&#34; alt=&#34;npm version&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;WebAssembly bindings to read and write the &lt;a href=&#34;https://parquet.apache.org/&#34;&gt;Apache Parquet&lt;/a&gt; format to and from &lt;a href=&#34;https://arrow.apache.org/&#34;&gt;Apache Arrow&lt;/a&gt; using the Rust &lt;a href=&#34;https://crates.io/crates/parquet&#34;&gt;&lt;code&gt;parquet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://crates.io/crates/arrow&#34;&gt;&lt;code&gt;arrow&lt;/code&gt;&lt;/a&gt; crates.&lt;/p&gt; &#xA;&lt;p&gt;This is designed to be used alongside a JavaScript Arrow implementation, such as the canonical &lt;a href=&#34;https://arrow.apache.org/docs/js/&#34;&gt;JS Arrow library&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Including read and write support and all compression codecs, the brotli-compressed WASM bundle is 1.2 MB. Refer to &lt;a href=&#34;https://raw.githubusercontent.com/kylebarron/parquet-wasm/main/#custom-builds&#34;&gt;custom builds&lt;/a&gt; for how to build a smaller bundle. A minimal read-only bundle without compression support can be as small as 456 KB brotli-compressed.&lt;/p&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;parquet-wasm&lt;/code&gt; is published to NPM. Install with&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;yarn add parquet-wasm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;npm install parquet-wasm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;Parquet-wasm has both a synchronous and asynchronous API. The sync API is simpler but requires fetching the entire Parquet buffer in advance, which is often prohibitive.&lt;/p&gt; &#xA;&lt;h3&gt;Sync API&lt;/h3&gt; &#xA;&lt;p&gt;Refer to these functions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.readParquet.html&#34;&gt;&lt;code&gt;readParquet&lt;/code&gt;&lt;/a&gt;: Read a Parquet file synchronously.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.readSchema.html&#34;&gt;&lt;code&gt;readSchema&lt;/code&gt;&lt;/a&gt;: Read an Arrow schema from a Parquet file synchronously.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.writeParquet.html&#34;&gt;&lt;code&gt;writeParquet&lt;/code&gt;&lt;/a&gt;: Write a Parquet file synchronously.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Async API&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/functions/esm_parquet_wasm.readParquetStream.html&#34;&gt;&lt;code&gt;readParquetStream&lt;/code&gt;&lt;/a&gt;: Create a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream&#34;&gt;ReadableStream&lt;/a&gt; that emits Arrow RecordBatches from a Parquet file.&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html&#34;&gt;&lt;code&gt;ParquetFile&lt;/code&gt;&lt;/a&gt;: A class for reading portions of a remote Parquet file. Use &lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#fromUrl&#34;&gt;&lt;code&gt;fromUrl&lt;/code&gt;&lt;/a&gt; to construct from a remote URL or &lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#fromFile&#34;&gt;&lt;code&gt;fromFile&lt;/code&gt;&lt;/a&gt; to construct from a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/File&#34;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; handle. Note that when you&#39;re done using this class, you&#39;ll need to call &lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.ParquetFile.html#free&#34;&gt;&lt;code&gt;free&lt;/code&gt;&lt;/a&gt; to release any memory held by the ParquetFile instance itself.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both sync and async functions return or accept a &lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/bundler_parquet_wasm.Table.html&#34;&gt;&lt;code&gt;Table&lt;/code&gt;&lt;/a&gt; class, an Arrow table in WebAssembly memory. Refer to its documentation for moving data into/out of WebAssembly.&lt;/p&gt; &#xA;&lt;h2&gt;Entry Points&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Entry point&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Documentation&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;parquet-wasm&lt;/code&gt;, &lt;code&gt;parquet-wasm/esm&lt;/code&gt;, or &lt;code&gt;parquet-wasm/esm/parquet_wasm.js&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;ESM, to be used directly from the Web as an ES Module&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/modules/esm_parquet_wasm.html&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;parquet-wasm/bundler&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&#34;Bundler&#34; build, to be used in bundlers such as Webpack&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/modules/bundler_parquet_wasm.html&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;parquet-wasm/node&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Node build, to be used with synchronous &lt;code&gt;require&lt;/code&gt; in NodeJS&lt;/td&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://kylebarron.dev/parquet-wasm/modules/node_parquet_wasm.html&#34;&gt;Link&lt;/a&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h3&gt;ESM&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;esm&lt;/code&gt; entry point is the primary entry point. It is the default export from &lt;code&gt;parquet-wasm&lt;/code&gt;, and is also accessible at &lt;code&gt;parquet-wasm/esm&lt;/code&gt; and &lt;code&gt;parquet-wasm/esm/parquet_wasm.js&lt;/code&gt; (for symmetric imports &lt;a href=&#34;https://raw.githubusercontent.com/kylebarron/parquet-wasm/main/#using-directly-from-a-browser&#34;&gt;directly from a browser&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note that when using the &lt;code&gt;esm&lt;/code&gt; bundles, you must manually initialize the WebAssembly module before using any APIs&lt;/strong&gt;. Otherwise, you&#39;ll get an error &lt;code&gt;TypeError: Cannot read properties of undefined&lt;/code&gt;. There are multiple ways to initialize the WebAssembly code:&lt;/p&gt; &#xA;&lt;h4&gt;Asynchronous initialization&lt;/h4&gt; &#xA;&lt;p&gt;The primary way to initialize is by awaiting the default export.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import wasmInit, {readParquet} from &#34;parquet-wasm&#34;;&#xA;&#xA;await wasmInit();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Without any parameter, this will try to fetch a file named &lt;code&gt;&#39;parquet_wasm_bg.wasm&#39;&lt;/code&gt; at the same location as &lt;code&gt;parquet-wasm&lt;/code&gt;. (E.g. this snippet &lt;code&gt;input = new URL(&#39;parquet_wasm_bg.wasm&#39;, import.meta.url);&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Note that you can also pass in a custom URL if you want to host the &lt;code&gt;.wasm&lt;/code&gt; file on your own servers.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import wasmInit, {readParquet} from &#34;parquet-wasm&#34;;&#xA;&#xA;// Update this version to match the version you&#39;re using.&#xA;const wasmUrl = &#34;https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/parquet_wasm_bg.wasm&#34;;&#xA;await wasmInit(wasmUrl);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Synchronous initialization&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;initSync&lt;/code&gt; named export allows for&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import {initSync, readParquet} from &#34;parquet-wasm&#34;;&#xA;&#xA;// The contents of esm/parquet_wasm_bg.wasm in an ArrayBuffer&#xA;const wasmBuffer = new ArrayBuffer(...);&#xA;&#xA;// Initialize the Wasm synchronously&#xA;initSync(wasmBuffer)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Async initialization should be preferred over downloading the Wasm buffer and then initializing it synchronously, as &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming_static&#34;&gt;&lt;code&gt;WebAssembly.instantiateStreaming&lt;/code&gt;&lt;/a&gt; is the most efficient way to both download and initialize Wasm code.&lt;/p&gt; &#xA;&lt;h3&gt;Bundler&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;bundler&lt;/code&gt; entry point doesn&#39;t require manual initialization of the WebAssembly blob, but needs setup with whatever bundler you&#39;re using. &lt;a href=&#34;https://rustwasm.github.io/docs/wasm-bindgen/reference/deployment.html#bundlers&#34;&gt;Refer to the Rust Wasm documentation for more info&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Node&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;node&lt;/code&gt; entry point can be loaded synchronously from Node.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const {readParquet} = require(&#34;parquet-wasm&#34;);&#xA;&#xA;const wasmTable = readParquet(...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Using directly from a browser&lt;/h3&gt; &#xA;&lt;p&gt;You can load the &lt;code&gt;esm/parquet_wasm.js&lt;/code&gt; file directly from a CDN&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const parquet = await import(&#xA;  &#34;https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.0/esm/+esm&#34;&#xA;)&#xA;await parquet.default();&#xA;&#xA;const wasmTable = parquet.readParquet(...);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This specific endpoint will minify the ESM before you receive it.&lt;/p&gt; &#xA;&lt;h3&gt;Debug functions&lt;/h3&gt; &#xA;&lt;p&gt;These functions are not present in normal builds to cut down on bundle size. To create a custom build, see &lt;a href=&#34;https://raw.githubusercontent.com/kylebarron/parquet-wasm/main/#custom-builds&#34;&gt;Custom Builds&lt;/a&gt; below.&lt;/p&gt; &#xA;&lt;h4&gt;&lt;code&gt;setPanicHook&lt;/code&gt;&lt;/h4&gt; &#xA;&lt;p&gt;&lt;code&gt;setPanicHook(): void&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sets &lt;a href=&#34;https://github.com/rustwasm/console_error_panic_hook&#34;&gt;&lt;code&gt;console_error_panic_hook&lt;/code&gt;&lt;/a&gt; in Rust, which provides better debugging of panics by having more informative &lt;code&gt;console.error&lt;/code&gt; messages. Initialize this first if you&#39;re getting errors such as &lt;code&gt;RuntimeError: Unreachable executed&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The WASM bundle must be compiled with the &lt;code&gt;console_error_panic_hook&lt;/code&gt; feature for this function to exist.&lt;/p&gt; &#xA;&lt;h2&gt;Example&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import * as arrow from &#34;apache-arrow&#34;;&#xA;import initWasm, {&#xA;  Compression,&#xA;  readParquet,&#xA;  Table,&#xA;  writeParquet,&#xA;  WriterPropertiesBuilder,&#xA;} from &#34;parquet-wasm&#34;;&#xA;&#xA;// Instantiate the WebAssembly context&#xA;await initWasm();&#xA;&#xA;// Create Arrow Table in JS&#xA;const LENGTH = 2000;&#xA;const rainAmounts = Float32Array.from({ length: LENGTH }, () =&amp;gt;&#xA;  Number((Math.random() * 20).toFixed(1))&#xA;);&#xA;&#xA;const rainDates = Array.from(&#xA;  { length: LENGTH },&#xA;  (_, i) =&amp;gt; new Date(Date.now() - 1000 * 60 * 60 * 24 * i)&#xA;);&#xA;&#xA;const rainfall = arrow.tableFromArrays({&#xA;  precipitation: rainAmounts,&#xA;  date: rainDates,&#xA;});&#xA;&#xA;// Write Arrow Table to Parquet&#xA;&#xA;// wasmTable is an Arrow table in WebAssembly memory&#xA;const wasmTable = Table.fromIPCStream(arrow.tableToIPC(rainfall, &#34;stream&#34;));&#xA;const writerProperties = new WriterPropertiesBuilder()&#xA;  .setCompression(Compression.ZSTD)&#xA;  .build();&#xA;const parquetUint8Array = writeParquet(wasmTable, writerProperties);&#xA;&#xA;// Read Parquet buffer back to Arrow Table&#xA;// arrowWasmTable is an Arrow table in WebAssembly memory&#xA;const arrowWasmTable = readParquet(parquetUint8Array);&#xA;&#xA;// table is now an Arrow table in JS memory&#xA;const table = arrow.tableFromIPC(arrowWasmTable.intoIPCStream());&#xA;console.log(table.schema.toString());&#xA;// Schema&amp;lt;{ 0: precipitation: Float32, 1: date: Date64&amp;lt;MILLISECOND&amp;gt; }&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Published examples&lt;/h3&gt; &#xA;&lt;p&gt;(These may use older versions of the library with a different API).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://observablehq.com/@kylebarron/geoparquet-on-the-web&#34;&gt;GeoParquet on the Web (Observable)&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://observablehq.com/@bmschmidt/hello-parquet-wasm&#34;&gt;Hello, Parquet-WASM (Observable)&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Performance considerations&lt;/h2&gt; &#xA;&lt;p&gt;Tl;dr: When you have a &lt;code&gt;Table&lt;/code&gt; object (resulting from &lt;code&gt;readParquet&lt;/code&gt;), try the new &lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.Table.html#intoFFI&#34;&gt;&lt;code&gt;Table.intoFFI&lt;/code&gt;&lt;/a&gt; API to move it to JavaScript memory. This API is less well tested than the &lt;a href=&#34;https://kylebarron.dev/parquet-wasm/classes/esm_parquet_wasm.Table.html#intoIPCStream&#34;&gt;&lt;code&gt;Table.intoIPCStream&lt;/code&gt;&lt;/a&gt; API, but should be faster and have &lt;strong&gt;much&lt;/strong&gt; less memory overhead (by a factor of 2). If you hit any bugs, please &lt;a href=&#34;https://github.com/kylebarron/parquet-wasm/issues/new&#34;&gt;create a reproducible issue&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Under the hood, &lt;code&gt;parquet-wasm&lt;/code&gt; first decodes a Parquet file into Arrow &lt;em&gt;in WebAssembly memory&lt;/em&gt;. But then that WebAssembly memory needs to be copied into JavaScript for use by Arrow JS. The &#34;normal&#34; conversion APIs (e.g. &lt;code&gt;Table.intoIPCStream&lt;/code&gt;) use the &lt;a href=&#34;https://arrow.apache.org/docs/python/ipc.html&#34;&gt;Arrow IPC format&lt;/a&gt; to get the data back to JavaScript. But this requires another memory copy &lt;em&gt;inside WebAssembly&lt;/em&gt; to assemble the various arrays into a single buffer to be copied back to JS.&lt;/p&gt; &#xA;&lt;p&gt;Instead, the new &lt;code&gt;Table.intoFFI&lt;/code&gt; API uses Arrow&#39;s &lt;a href=&#34;https://arrow.apache.org/docs/format/CDataInterface.html&#34;&gt;C Data Interface&lt;/a&gt; to be able to copy or view Arrow arrays from within WebAssembly memory without any serialization.&lt;/p&gt; &#xA;&lt;p&gt;Note that this approach uses the &lt;a href=&#34;https://github.com/kylebarron/arrow-js-ffi&#34;&gt;&lt;code&gt;arrow-js-ffi&lt;/code&gt;&lt;/a&gt; library to parse the Arrow C Data Interface definitions. This library has not yet been tested in production, so it may have bugs!&lt;/p&gt; &#xA;&lt;p&gt;I wrote an &lt;a href=&#34;https://observablehq.com/@kylebarron/zero-copy-apache-arrow-with-webassembly&#34;&gt;interactive blog post&lt;/a&gt; on this approach and the Arrow C Data Interface if you want to read more!&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import * as arrow from &#34;apache-arrow&#34;;&#xA;import { parseTable } from &#34;arrow-js-ffi&#34;;&#xA;import initWasm, { wasmMemory, readParquet } from &#34;parquet-wasm&#34;;&#xA;&#xA;// Instantiate the WebAssembly context&#xA;await initWasm();&#xA;&#xA;// A reference to the WebAssembly memory object.&#xA;const WASM_MEMORY = wasmMemory();&#xA;&#xA;const resp = await fetch(&#34;https://example.com/file.parquet&#34;);&#xA;const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());&#xA;const wasmArrowTable = readParquet(parquetUint8Array).intoFFI();&#xA;&#xA;// Arrow JS table that was directly copied from Wasm memory&#xA;const table: arrow.Table = parseTable(&#xA;  WASM_MEMORY.buffer,&#xA;  wasmArrowTable.arrayAddrs(),&#xA;  wasmArrowTable.schemaAddr()&#xA;);&#xA;&#xA;// VERY IMPORTANT! You must call `drop` on the Wasm table object when you&#39;re done using it&#xA;// to release the Wasm memory.&#xA;// Note that any access to the pointers in this table is undefined behavior after this call.&#xA;// Calling any `wasmArrowTable` method will error.&#xA;wasmArrowTable.drop();&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compression support&lt;/h2&gt; &#xA;&lt;p&gt;The Parquet specification permits several compression codecs. This library currently supports:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Uncompressed&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Snappy&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Gzip&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Brotli&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; ZSTD&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; LZ4_RAW&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; LZ4 (deprecated)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;LZ4 support in Parquet is a bit messy. As described &lt;a href=&#34;https://github.com/apache/parquet-format/raw/54e53e5d7794d383529dd30746378f19a12afd58/Compression.md&#34;&gt;here&lt;/a&gt;, there are &lt;em&gt;two&lt;/em&gt; LZ4 compression options in Parquet (as of version 2.9.0). The original version &lt;code&gt;LZ4&lt;/code&gt; is now deprecated; it used an undocumented framing scheme which made interoperability difficult. The specification now reads:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;It is strongly suggested that implementors of Parquet writers deprecate this compression codec in their user-facing APIs, and advise users to switch to the newer, interoperable &lt;code&gt;LZ4_RAW&lt;/code&gt; codec.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;It&#39;s currently unknown how widespread the ecosystem support is for &lt;code&gt;LZ4_RAW&lt;/code&gt;. As of &lt;code&gt;pyarrow&lt;/code&gt; v7, it now writes &lt;code&gt;LZ4_RAW&lt;/code&gt; by default and presumably has read support for it as well.&lt;/p&gt; &#xA;&lt;h2&gt;Custom builds&lt;/h2&gt; &#xA;&lt;p&gt;In some cases, you may know ahead of time that your Parquet files will only include a single compression codec, say Snappy, or even no compression at all. In these cases, you may want to create a custom build of &lt;code&gt;parquet-wasm&lt;/code&gt; to keep bundle size at a minimum. If you install the Rust toolchain and &lt;code&gt;wasm-pack&lt;/code&gt; (see &lt;a href=&#34;https://raw.githubusercontent.com/kylebarron/parquet-wasm/main/DEVELOP.md&#34;&gt;Development&lt;/a&gt;), you can create a custom build with only the compression codecs you require.&lt;/p&gt; &#xA;&lt;p&gt;The minimum supported Rust version in this project is 1.60. To upgrade your toolchain, use &lt;code&gt;rustup update stable&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Example custom builds&lt;/h3&gt; &#xA;&lt;p&gt;Reader-only bundle with Snappy compression:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wasm-pack build --no-default-features --features snappy --features reader&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Writer-only bundle with no compression support, targeting Node:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;wasm-pack build --target nodejs --no-default-features --features writer&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bundle with reader and writer support, targeting Node, using &lt;code&gt;arrow&lt;/code&gt; and &lt;code&gt;parquet&lt;/code&gt; crates with all their supported compressions, with &lt;code&gt;console_error_panic_hook&lt;/code&gt; enabled:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wasm-pack build \&#xA;  --target nodejs \&#xA;  --no-default-features \&#xA;  --features reader \&#xA;  --features writer \&#xA;  --features all_compressions \&#xA;  --features debug&#xA;# Or, given the fact that the default feature includes several of these features, a shorter version:&#xA;wasm-pack build --target nodejs --features debug&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Refer to the &lt;a href=&#34;https://rustwasm.github.io/docs/wasm-pack/commands/build.html&#34;&gt;&lt;code&gt;wasm-pack&lt;/code&gt; documentation&lt;/a&gt; for more info on flags such as &lt;code&gt;--release&lt;/code&gt;, &lt;code&gt;--dev&lt;/code&gt;, &lt;code&gt;target&lt;/code&gt;, and to the &lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/features.html&#34;&gt;Cargo documentation&lt;/a&gt; for more info on how to use features.&lt;/p&gt; &#xA;&lt;h3&gt;Available features&lt;/h3&gt; &#xA;&lt;p&gt;By default, &lt;code&gt;all_compressions&lt;/code&gt;, &lt;code&gt;reader&lt;/code&gt;, &lt;code&gt;writer&lt;/code&gt;, and &lt;code&gt;async&lt;/code&gt; features are enabled. Use &lt;code&gt;--no-default-features&lt;/code&gt; to remove these defaults.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;reader&lt;/code&gt;: Activate read support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;writer&lt;/code&gt;: Activate write support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;async&lt;/code&gt;: Activate asynchronous read support.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;all_compressions&lt;/code&gt;: Activate all supported compressions.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;brotli&lt;/code&gt;: Activate Brotli compression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gzip&lt;/code&gt;: Activate Gzip compression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;snappy&lt;/code&gt;: Activate Snappy compression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;zstd&lt;/code&gt;: Activate ZSTD compression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;lz4&lt;/code&gt;: Activate LZ4_RAW compression.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;debug&lt;/code&gt;: Expose the &lt;code&gt;setPanicHook&lt;/code&gt; function for better error messages for Rust panics.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Node &amp;lt;20&lt;/h2&gt; &#xA;&lt;p&gt;On Node versions before 20, you&#39;ll have to &lt;a href=&#34;https://docs.rs/getrandom/latest/getrandom/#nodejs-es-module-support&#34;&gt;polyfill the Web Cryptography API&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Future work&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Example of pushdown predicate filtering, to download only chunks that match a specific condition&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Column filtering, to download only certain columns&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; More tests&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgements&lt;/h2&gt; &#xA;&lt;p&gt;A starting point of my work came from @my-liminal-space&#39;s &lt;a href=&#34;https://github.com/my-liminal-space/read-parquet-browser&#34;&gt;&lt;code&gt;read-parquet-browser&lt;/code&gt;&lt;/a&gt; (which is also dual licensed MIT and Apache 2).&lt;/p&gt; &#xA;&lt;p&gt;@domoritz&#39;s &lt;a href=&#34;https://github.com/domoritz/arrow-wasm&#34;&gt;&lt;code&gt;arrow-wasm&lt;/code&gt;&lt;/a&gt; was a very helpful reference for bootstrapping Rust-WASM bindings.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>xelis-project/xelis-blockchain</title>
    <updated>2024-04-25T01:33:37Z</updated>
    <id>tag:github.com,2024-04-25:/xelis-project/xelis-blockchain</id>
    <link href="https://github.com/xelis-project/xelis-blockchain" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A private blockDAG using Homomorphic Encryption with Smart Contract support&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;XELIS&lt;/h1&gt; &#xA;&lt;p&gt;All rights reserved.&lt;/p&gt; &#xA;&lt;p&gt;A from scratch blockchain made in Rust and powered by Tokio, using account model. XELIS is based on an event-driven system combined with the native async/await and works with a unique and from scratch p2p system. This allow to be notified on any events happening on the network and to be able to react to them instead of checking periodically for updates.&lt;/p&gt; &#xA;&lt;p&gt;BlockDAG is enabled to improve the scalability and the security of the network. Homomorphic Encryption using ElGamal is used to provide privacy on transactions (transfered amounts) and balances.&lt;/p&gt; &#xA;&lt;p&gt;ElGamal cryptosystem was choosen because it&#39;s a well known and studied encryption algorithm which has homomorphism features. ElGamal is fast and is used in combination with Ristretto255 curve to provide a good level of security (~128 bits of security). Homomorphic operations available using ElGamal are addition/subtraction between ciphertexts and/or plaintext and multiplication against plaintext value.&lt;/p&gt; &#xA;&lt;p&gt;Account Model allows to have a more flexible system than UTXO model and to have a better privacy because there is no need to link inputs and outputs, which provide real fungibility. It allows also the fast-sync feature to only download the last state of the blockchain instead of downloading all the history.&lt;/p&gt; &#xA;&lt;p&gt;Pruning system is also available to reduce the size of the blockchain by removing old blocks and transactions.&lt;/p&gt; &#xA;&lt;p&gt;We also aims to enabled Smart Contracts support in the future.&lt;/p&gt; &#xA;&lt;p&gt;We provide differents built-in network:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Mainnet: Not released yet&lt;/li&gt; &#xA; &lt;li&gt;Testnet: Running&lt;/li&gt; &#xA; &lt;li&gt;Devnet: this network is used for local development purpose where you want to create your own local chain. It has no peers&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Acknowledgments&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/cchudant&#34;&gt;@cchudant&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Optimized decoding RistrettoPoint implementation (ECDLP).&lt;/li&gt; &#xA; &lt;li&gt;Twisted ElGamal implementation along ZK-Proofs integration for Confidential Transactions.&lt;/li&gt; &#xA; &lt;li&gt;To read more, please see &lt;a href=&#34;https://github.com/xelis-project/xelis-he&#34;&gt;XELIS-HE&lt;/a&gt; framework created by him.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/deroholic&#34;&gt;@deroholic&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Difficulty adjustment algorithm using Kalman-Filter.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Thank you to every people testing actively the code base, honest miners and every future contributors!&lt;/p&gt; &#xA;&lt;h2&gt;Main features&lt;/h2&gt; &#xA;&lt;p&gt;The main features of XELIS are the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;BlockDAG&lt;/strong&gt;: reduce orphaned blocks rate.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Egalitarian Mining&lt;/strong&gt;: any CPU or GPU can mine XELIS easily.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Privacy&lt;/strong&gt;: Homomorphic Encryption allows to have encrypted balances and encrypted transfered amounts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Confidential Asset&lt;/strong&gt;: Any asset deployed on XELIS network will have the same privacy and functionality like XELIS. Not just a number in a Smart Contract.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Event system&lt;/strong&gt;: every event happening on the network (daemon or wallet) can be detected and notified easily.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Instant Sync&lt;/strong&gt;: Your wallet balances and history is synced in few seconds.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Smart Contracts&lt;/strong&gt;: Create and deploy unstoppable decentralized applications.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Integrated addresses&lt;/strong&gt;: introduce any data in your wallet address to share informations in a transaction.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Easy to use&lt;/strong&gt;: We aims to provide the most easiest platform to build and use daily.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Objectives&lt;/h2&gt; &#xA;&lt;p&gt;The main objectives of XELIS are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provide privacy on transactions / balances.&lt;/li&gt; &#xA; &lt;li&gt;Provide Smart Contracts support.&lt;/li&gt; &#xA; &lt;li&gt;Secure and fast.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Others objectives in mind are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Provide real custom assets working as the native coin.&lt;/li&gt; &#xA; &lt;li&gt;Designed as CPU/GPU mining friendly to improve decentralization as possible.&lt;/li&gt; &#xA; &lt;li&gt;Simple to use.&lt;/li&gt; &#xA; &lt;li&gt;Community driven decisions.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Config&lt;/h2&gt; &#xA;&lt;h3&gt;Network&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Expected Block Time is &lt;code&gt;15&lt;/code&gt; seconds&lt;/li&gt; &#xA; &lt;li&gt;Address prefix is &lt;code&gt;xel&lt;/code&gt; on mainnet and &lt;code&gt;xet&lt;/code&gt; for testnet/devnet&lt;/li&gt; &#xA; &lt;li&gt;Transaction fee is &lt;code&gt;0.01000&lt;/code&gt; XEL per KB&lt;/li&gt; &#xA; &lt;li&gt;Up to &lt;code&gt;8&lt;/code&gt; decimals&lt;/li&gt; &#xA; &lt;li&gt;Maximum supply: &lt;code&gt;18.4&lt;/code&gt; millions&lt;/li&gt; &#xA; &lt;li&gt;Maximum block size: &lt;code&gt;1.25&lt;/code&gt;&amp;nbsp;MB&lt;/li&gt; &#xA; &lt;li&gt;Difficulty adjustment algorithm: retarget at every block&lt;/li&gt; &#xA; &lt;li&gt;Block reward emission: retarget at every block (Smooth decrease)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Daemon&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Default P2P port is &lt;code&gt;2125&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Defaut RPC Server port is &lt;code&gt;8080&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Wallet&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Default RPC Server port is &lt;code&gt;8081&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Include extra fees when sending coins to a not-yet registered address&lt;/li&gt; &#xA; &lt;li&gt;Support of Smart Contracts (xelis-vm)&lt;/li&gt; &#xA; &lt;li&gt;Privacy (through Homomorphic Encryption)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;BlockDAG&lt;/h2&gt; &#xA;&lt;p&gt;XELIS use a blockDAG with following rules:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A block is considered &lt;code&gt;Sync Block&lt;/code&gt; when the block height is less than &lt;code&gt;TOP_HEIGHT - STABLE_LIMIT&lt;/code&gt; and it&#39;s the unique block at a specific height (or only ordered block at its height and don&#39;t have lower cumulative difficulty than previous blocks).&lt;/li&gt; &#xA; &lt;li&gt;A block is considered &lt;code&gt;Side Block&lt;/code&gt; when block height is less than or equal to height of past 8 topological blocks.&lt;/li&gt; &#xA; &lt;li&gt;A block is considered &lt;code&gt;Orphaned&lt;/code&gt; when the block is not ordered in DAG (no topological height for it).&lt;/li&gt; &#xA; &lt;li&gt;A height is not unique anymore.&lt;/li&gt; &#xA; &lt;li&gt;Topo height is unique for each block, but can change when the DAG is re-ordered up to &lt;code&gt;TOP_HEIGHT - STABLE_LIMIT&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;You can have up to 3 previous blocks in a block.&lt;/li&gt; &#xA; &lt;li&gt;For mining, you have to mine on one of 3 of the most heavier tips.&lt;/li&gt; &#xA; &lt;li&gt;Block should not have deviated too much from main chain / heavier tips.&lt;/li&gt; &#xA; &lt;li&gt;Maximum 9% of difficulty difference between Tips selected in the same block.&lt;/li&gt; &#xA; &lt;li&gt;Side Blocks receive only 30% of block reward.&lt;/li&gt; &#xA; &lt;li&gt;Supply is re-calculated each time the block is re-ordered because its based on topo order.&lt;/li&gt; &#xA; &lt;li&gt;Transactions and miner rewards are re-computed when a new block is added and the block there linked to is not yet in stable topo height.&lt;/li&gt; &#xA; &lt;li&gt;A same transaction can be added in more than a block if they are not in the same tip branch. Client protocol will execute it only one time.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Topoheight represents how many unique blocks there is in the blockchain ordered by DAG.&lt;/p&gt; &#xA;&lt;p&gt;A block ordered is a valid and executed one.&lt;/p&gt; &#xA;&lt;p&gt;Topoheight order is unstable and may change until the blocks are in the stable height.&lt;/p&gt; &#xA;&lt;p&gt;Longest chain is the one selected by nodes. But for tips branches conflicts, cumulative difficulty is used to select the main chain.&lt;/p&gt; &#xA;&lt;h2&gt;Homomorphic Encryption&lt;/h2&gt; &#xA;&lt;p&gt;Homomorphic Encryption (HE) will allow to add privacy on transactions and accounts by doing computation while staying in encrypted form. Each balances, transaction assets values are in encrypted form and nobody can determine the real value of it except involved parties.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: This part is not yet deployed and is under heavy work.&lt;/p&gt; &#xA;&lt;h2&gt;Mining&lt;/h2&gt; &#xA;&lt;p&gt;Mining capabilities of XELIS are a bit differents from others chains because of standards being not implemented. Each job send to a miner is a &lt;code&gt;BlockMiner&lt;/code&gt; instance in hex format.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;BlockMiner&lt;/code&gt; is in following format:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;header work hash: 32 bytes&lt;/li&gt; &#xA; &lt;li&gt;timestamp (u64 for milliseconds): 8 bytes (BigEndian)&lt;/li&gt; &#xA; &lt;li&gt;nonce (u64): 8 bytes (BigEndian)&lt;/li&gt; &#xA; &lt;li&gt;extra nonce: 32 bytes&lt;/li&gt; &#xA; &lt;li&gt;miner public key: 32 bytes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The total block work size should be equal to 120 bytes. Header work hash is the immutable part of a block work, its a hash calculated using &lt;code&gt;Blake3&lt;/code&gt; hashing algorithm with the following format as input:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;block version: 1 byte&lt;/li&gt; &#xA; &lt;li&gt;block height (u64): 8 bytes (BigEndian)&lt;/li&gt; &#xA; &lt;li&gt;Hash of the tips: 32 bytes&lt;/li&gt; &#xA; &lt;li&gt;Hash of the transactions hashes: 32 bytes&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The header work has to be equal to 73 bytes exactly and its hash to 32 bytes.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Miner key is not included in the immutable of the block work to be have generic block template that can be compatible with any miner.&lt;/p&gt; &#xA;&lt;p&gt;All hashes are calculated using the &lt;code&gt;Blake3&lt;/code&gt; hashing algorithm except the Proof-Of-Work hash.&lt;/p&gt; &#xA;&lt;p&gt;POW Hash should be calculated from the &lt;code&gt;BlockMiner&lt;/code&gt; format and compared against the target difficulty.&lt;/p&gt; &#xA;&lt;p&gt;NOTE: It is recommended to use the GetWork WebSocket server to be notified of new block work and submit correct work.&lt;/p&gt; &#xA;&lt;p&gt;Mining jobs are send only when a new block is found or when a new TX is added in mempool. Miners software are recommended to update themselves the block timestamp (or at least every 500ms) for best network difficulty calculation.&lt;/p&gt; &#xA;&lt;p&gt;The POW Hashing algorithm is &lt;a href=&#34;https://github.com/xelis-project/xelis-hash&#34;&gt;xelis-hash&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Client Protocol&lt;/h2&gt; &#xA;&lt;p&gt;XELIS integrate along with BlockDAG a way to accept multiple times the same TX and only execute it one time. Instead of excluding the whole block because we have a collision with another blockDAG branch for a TX, we just don&#39;t execute the TX and keep its hash.&lt;/p&gt; &#xA;&lt;p&gt;The same TX can be contained in multiple blocks only if:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;TX is not executed in stable height&lt;/li&gt; &#xA; &lt;li&gt;TX is not included in block Tips (previous blocks)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Also, for more security, user account should only do TXs on the same chain/tip to prevent any orphaned TX. An orphaned TX can happens when two differents TXs (but same owner) with the same nonce are sent in two differents branchs.&lt;/p&gt; &#xA;&lt;p&gt;During the generation of the DAG order (linking unique topoheight to a block hash), the first block being ordered will execute the TX first.&lt;/p&gt; &#xA;&lt;p&gt;This feature allows to accept others branch tips even if transactions are the same and prevent more orphans blocks when branches are merged.&lt;/p&gt; &#xA;&lt;h2&gt;Transaction&lt;/h2&gt; &#xA;&lt;p&gt;Transaction types supported:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Transfer: possibility to send many assets to many addresses in the same TX (up to 255 outputs inside)&lt;/li&gt; &#xA; &lt;li&gt;Burn: publicly burn amount of a specific asset and use this TX as proof of burn (coins are completely deleted from circulation)&lt;/li&gt; &#xA; &lt;li&gt;Call Contract: call a Smart Contract with specific parameters and list of assets to deposit (WIP) (NOTE: Multi Call Contract in the same TX ?)&lt;/li&gt; &#xA; &lt;li&gt;Deploy Contract: deploy a new (valid) Smart Contract on chain (WIP)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At this moment, transactions are public and have the following data.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Type&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Comment&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;owner&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;PublicKey&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Signer of this transaction&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;data&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;TransactionType&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Type with data included of this transaction&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;fee&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Fees to be paid by the owner for including this TX&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;nonce&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Matching nonce of balance to be validated and prevent any replay TX attack&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;signature&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Signature&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Valid signature to prove that the owner validated this TX&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;Transactions support any registered asset natively.&lt;/p&gt; &#xA;&lt;p&gt;To prevent any replay attack or double spending, each TX should include a nonce that match the account balance. After each TX, the nonce is incremented by 1.&lt;/p&gt; &#xA;&lt;h2&gt;Integrated Address&lt;/h2&gt; &#xA;&lt;p&gt;Integrated address are base address with custom data integrated. For example, you can integrate in it a unique identifier that will be integrated in the future transaction done using it. Its helpful to determine easily which account to link a transaction with an account/order on service side.&lt;/p&gt; &#xA;&lt;p&gt;Maximum data allowed is 1KB (same as transaction payload).&lt;/p&gt; &#xA;&lt;p&gt;Every data is integrated in the transaction payload when using an integrated address.&lt;/p&gt; &#xA;&lt;h2&gt;P2p (Encrypted Network)&lt;/h2&gt; &#xA;&lt;p&gt;All transfered data are using a custom Serializer/Deserializer made by hand to transform a struct representation in raw bytes directly. This serialization is done using the fixed position of each fields and their corresponding bits size.&lt;/p&gt; &#xA;&lt;p&gt;Before sending a packet, we&#39;re encrypting it using ChaCha20-Poly1305 algorithm to prevent network traffic analysis and authenticate each transfered data.&lt;/p&gt; &#xA;&lt;p&gt;Every data transfered is done through the Packet system which allow easily to read &amp;amp; transfer data and doing the whole serialization itself.&lt;/p&gt; &#xA;&lt;p&gt;The connection for a new peer (took from the queue or a new incoming connections) is executed through a unique tokio task with the same allocated buffer for handshake. This prevents any DoS attack on creating multiple task and verifying connection.&lt;/p&gt; &#xA;&lt;p&gt;When the peer is verified and valid, we create him his own tasks. One for reading incoming packets and one for writing packets to him. By separating both directions in two differents task it prevents blocking the communication of opposed side.&lt;/p&gt; &#xA;&lt;p&gt;For transactions propagation, we keep in cache last N transactions sent or received from a peer to not send the same data twice during propagation.&lt;/p&gt; &#xA;&lt;p&gt;The daemon also have 3 tokio tasks running:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Maintains connections with seed nodes&lt;/li&gt; &#xA; &lt;li&gt;Chain sync (which select a random peer for syncing its chain)&lt;/li&gt; &#xA; &lt;li&gt;Ping task which build a generic ping packet which is send to every peers connected (or build a specific one for each when its necessary)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Pruning Mode&lt;/h3&gt; &#xA;&lt;p&gt;This allows anyone who want to run a light node to reduce the blockchain size by deleting blocks, transactions and versioned balances. The pruned topoheight can only be at a &lt;code&gt;Sync Block&lt;/code&gt; and behind at least &lt;code&gt;PRUNE_SAFETY_LIMIT&lt;/code&gt; blocks of the top topoheight.&lt;/p&gt; &#xA;&lt;p&gt;For wallets connected to a pruned node, you can&#39;t retrieve transactions history and miner rewards which happened before the pruned topoheight. But your balances are still up-to-date with the chain and if your wallets already synced them, they stay in your wallet database.&lt;/p&gt; &#xA;&lt;p&gt;The security of the chain is not reduced as all your blocks were already verified by your own node locally.&lt;/p&gt; &#xA;&lt;h3&gt;Fast Sync&lt;/h3&gt; &#xA;&lt;p&gt;Fast sync mode allow you to sync really fast the necessary data only to run a correct and valid version of the chain. For this we request a peer to send us its chain state at a stable point, which include all accounts nonces, assets, balances, top blocks. So in future, when the chain will be really heavy, anyone can still join it by using fast sync system, which is compatible with the pruning mode.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: You should use fast sync mode only with a trusted peer, because they can send you a potential fake chain.&lt;/p&gt; &#xA;&lt;h3&gt;Boost Sync&lt;/h3&gt; &#xA;&lt;p&gt;This is requesting the full chain to others nodes, but faster. Boost sync mode can be enabled using &lt;code&gt;--allow-boost-sync-mode&lt;/code&gt;. This mode use more resources but sync much faster. It is faster because it&#39;s requesting blocks to sync in parallel, instead of traditional synchronization that would just request one block, verify it, execute it, repeat. It&#39;s not enabled by default to prevent too much load on nodes.&lt;/p&gt; &#xA;&lt;p&gt;This is the perfect mix between Fast sync and traditional chain sync, to have the full ledger while being faster.&lt;/p&gt; &#xA;&lt;h3&gt;Packets&lt;/h3&gt; &#xA;&lt;p&gt;This parts explains the most importants packets used in XELIS network to communicate over the P2p network.&lt;/p&gt; &#xA;&lt;h4&gt;Key Exchange&lt;/h4&gt; &#xA;&lt;p&gt;Key Exchange is the real first packet to be sent when creating a new connection. This allow to exchange symetric encryption keys between peer to establish an encrypted communication channel over TCP.&lt;/p&gt; &#xA;&lt;p&gt;Currently, we are using ChaCha20-Poly1305 algorithm to encrypt / decrypt every packets.&lt;/p&gt; &#xA;&lt;p&gt;This packet can be sent later to rotate the key of a peer. This is currently done every 1 GB of data sent.&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re using two different symetric keys for encryption per Peer. One key is from us, to encrypt our packet, and the other key is to decrypt peer&#39;s packets.&lt;/p&gt; &#xA;&lt;h4&gt;Handshake&lt;/h4&gt; &#xA;&lt;p&gt;Handshake packet must be the first packet sent with the blockchain state inside to upgrade a connection to a peer. If valid, the peer will send the same packet with is own blockchain state.&lt;/p&gt; &#xA;&lt;p&gt;Except at beginning, this packet should never be sent again.&lt;/p&gt; &#xA;&lt;h4&gt;Ping&lt;/h4&gt; &#xA;&lt;p&gt;Ping packet is sent at an regular interval and inform peers of the our blockchain state. Every 15 minutes, the packet can contains up to &lt;code&gt;MAX_LEN&lt;/code&gt; sockets addresses (IPv4 or IPv6) to help others nodes to extends theirs peers list.&lt;/p&gt; &#xA;&lt;h4&gt;Chain Sync&lt;/h4&gt; &#xA;&lt;p&gt;We select randomly a peer which is higher in height from the peers list than us and send him a chain request.&lt;/p&gt; &#xA;&lt;p&gt;The chain request includes last &lt;code&gt;CHAIN_SYNC_REQUEST_MAX_BLOCKS&lt;/code&gt; blocks hashes of our chain with theirs topoheight espaced exponentially. This data is used by the select peer to try to find a common point with our chain and his own (block hash must be at same topoheight as other peer). If selected peer found a common point, he add up to &lt;code&gt;CHAIN_SYNC_RESPONSE_MAX_BLOCKS&lt;/code&gt; blocks hashes ordered by block height.&lt;/p&gt; &#xA;&lt;p&gt;Through the &#34;ask and await&#34; request object system, we ask the complete block (block header with transactions included) and add it to chain directly.&lt;/p&gt; &#xA;&lt;p&gt;Chain sync is requested with a minimum interval of &lt;code&gt;CHAIN_SYNC_DELAY&lt;/code&gt; seconds.&lt;/p&gt; &#xA;&lt;h4&gt;Block Propagation&lt;/h4&gt; &#xA;&lt;p&gt;Block propagation packet contains the block header only. Its sent to all peers who have theirs height minus our height less than &lt;code&gt;STABLE_LIMIT&lt;/code&gt;. To build the block, we retrieve transactions from mempool. If a transaction is not found in the mempool, we request it from the same peer in order to build it.&lt;/p&gt; &#xA;&lt;h4&gt;Transaction Propagation&lt;/h4&gt; &#xA;&lt;p&gt;Transaction propagation packet contains the hash only to prevent sending the TX. Its also backed by a cache per peer to knows if the transaction was already received from him / send to him.&lt;/p&gt; &#xA;&lt;h2&gt;Storage&lt;/h2&gt; &#xA;&lt;p&gt;All theses data are saved in plaintext.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Tree&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Key Type&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Value Type&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;Comment&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;transactions&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Transaction&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save the whole transaction based on its hash&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;blocks&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Block Header&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save the block header only based on its hash&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;blocks_at_height&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Array of Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save all blocks hash at a specific height&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;extra&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Bytes&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;No specific type&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save the highest topo height, pruned topoheight and TIPS&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;topo_by_hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save a block hash at a specific topo height&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;hash_by_topo&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save a topo height for a specific block hash&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;cumulative_difficulty&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save the cumulative difficulty for each block hash&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;assets&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Verify if an assets exist and its registration height&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;rewards&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Save the block reward&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;supply&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Calculated supply (past + block reward) at each block&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;difficulty&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Difficulty for each block&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;tx_blocks&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Array of Hash&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;All blocks in which this TX hash is included&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;balances&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Custom&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Last topoheight of versioned balance&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;nonces&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Public Key&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Integer&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Store the highest topoheight of versioned nonce&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;versioned_balances&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Custom&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Versioned Balance&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Key is composed of topoheight + asset + public key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;versioned_nonces&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Custom&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Versioned Nonce&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Key is composed of topoheight + public key&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;balances&lt;/code&gt; has a custom key which is composed of 32 bytes of Public Key and 32 bytes of Asset.&lt;/li&gt; &#xA; &lt;li&gt;Balances and nonces are versioned, which means they are stored each time a change happened in chain.&lt;/li&gt; &#xA; &lt;li&gt;Using a Tree per version is too heavy because of overhead per trees, solution is to hash a generated key based on properties.&lt;/li&gt; &#xA; &lt;li&gt;Assets registered have in value their topoheight at which it was registered.&lt;/li&gt; &#xA; &lt;li&gt;Supply and block rewards are only stored when the block is topologically ordered&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The database engine used is sled. It may changes in future.&lt;/p&gt; &#xA;&lt;p&gt;Current overhead per block:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;blocks&lt;/code&gt; saving Block header (132 bytes with no TXs) value using Hash (32 bytes) key.&lt;/li&gt; &#xA; &lt;li&gt;Trees &lt;code&gt;topo_by_hash&lt;/code&gt; and &lt;code&gt;hash_by_topo&lt;/code&gt; saving both Hash (32 bytes) &amp;lt;=&amp;gt; topoheight (8 bytes) pointers. (x2)&lt;/li&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;difficulty&lt;/code&gt; saving Difficulty value of a block (up to 33 bytes) using Hash (32 bytes) key.&lt;/li&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;cumulative_difficulty&lt;/code&gt; saving the cumulative difficulty value (up to 33 bytes) of a topoheight (8 bytes).&lt;/li&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;rewards&lt;/code&gt; saving block reward value (8 bytes) using topoheight (8 bytes) key.&lt;/li&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;supply&lt;/code&gt; saving current circulating supply value (8 bytes) using topoheight (8 bytes) key.&lt;/li&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;versioned_balances&lt;/code&gt; is updated at each block (for miner rewards), and also for each account that had interactions (transactions): 72 bytes for key and 16 bytes for value.&lt;/li&gt; &#xA; &lt;li&gt;Tree &lt;code&gt;versioned_nonces&lt;/code&gt; is updated for each account that send at least one TX per topoheight: 40 bytes for key and 16 bytes for value&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At this moment with current implementation, minimal overhead per new account is 208 bytes for keys and 56 bytes for values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;balances&lt;/code&gt; Public Key + Asset (64 bytes) =&amp;gt; topoheight of last versioned balance (8 bytes)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;nonces&lt;/code&gt; Public Key (32 bytes) =&amp;gt; topoheight of last versioned nonce (8 bytes)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;versioned_balances&lt;/code&gt; Public Topoheight + Key + Asset (72 bytes) =&amp;gt; Versioned Balance (16 bytes)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;versioned_nonces&lt;/code&gt; Topoheight + Public Key (40 bytes) =&amp;gt; Versioned Nonce (16 bytes)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;An optimized version could be done to reduce further the disk usage by creating pointers. Instead of saving multiple times the whole Public Key (32 bytes), we create a pointer table to which a u64 value is assigned. And we store this u64 id instead of the whole Public Key, asset..&lt;/p&gt; &#xA;&lt;h2&gt;Wallet&lt;/h2&gt; &#xA;&lt;p&gt;Wallet keep tracks of all your transactions on chain, all your assets you own.&lt;/p&gt; &#xA;&lt;p&gt;When creating a new wallet, it generate a new random secure &#34;master key&#34; which will be encrypted by a password hashed. This master key allows to change easily the password of your wallet because you only have to save new encrypted version of it.&lt;/p&gt; &#xA;&lt;p&gt;The master key is also the one which will be able to decrypt/encrypt all your wallet storage.&lt;/p&gt; &#xA;&lt;p&gt;This way allow to save securely and easily data on any device.&lt;/p&gt; &#xA;&lt;p&gt;Password hashing algorithm used is Argon2id with a configuration of 15 MB and 16 iterations.&lt;/p&gt; &#xA;&lt;h3&gt;Storage&lt;/h3&gt; &#xA;&lt;p&gt;Wallet implement a fully-encrypted storage system with following features:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tree names are hashed with generated salt&lt;/li&gt; &#xA; &lt;li&gt;Keys data are hashed with generated salt&lt;/li&gt; &#xA; &lt;li&gt;Values are encrypted using XChaCha20Poly1305 and a random newly generated nonce each time its saved.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Exception for assets list which has its key encrypted to be able to retrieve them later.&lt;/p&gt; &#xA;&lt;p&gt;Hash algorithm used is Blake3 for keys / tree names. The random salt generated is a 64 bytes length. This simple system prevent someone to read / use the data without the necessary secret key.&lt;/p&gt; &#xA;&lt;h3&gt;Data Type and Value&lt;/h3&gt; &#xA;&lt;p&gt;This protocol allows to transfer data through a custom wallet address called &lt;code&gt;integrated address&lt;/code&gt;. It will simply integrate encoded data in the wallet address which can be used to send specific data to the wallet when creating a transaction. Each transaction can reserve up to 1 KB of space (for encrypted data transfering for example).&lt;/p&gt; &#xA;&lt;p&gt;You can create simple service / communication on chain through wallets while staying anonymous and in encrypted form.&lt;/p&gt; &#xA;&lt;p&gt;Actually, you can have following values through API:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Null value representation&lt;/li&gt; &#xA; &lt;li&gt;Boolean&lt;/li&gt; &#xA; &lt;li&gt;String&lt;/li&gt; &#xA; &lt;li&gt;Unsigned numbers (&lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And these types:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Value (which is only one value, can be used for PaymentID representation)&lt;/li&gt; &#xA; &lt;li&gt;Array (of any different values types)&lt;/li&gt; &#xA; &lt;li&gt;Fields (which can be used to represent custom &lt;code&gt;struct&lt;/code&gt; for example)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;API&lt;/h2&gt; &#xA;&lt;p&gt;Http Server run using Actix Framework and serve the JSON-RPC API and WebSocket.&lt;/p&gt; &#xA;&lt;h3&gt;JSON-RPC&lt;/h3&gt; &#xA;&lt;p&gt;JSON-RPC is available on &lt;code&gt;/json_rpc&lt;/code&gt; route on RPC server address that you set (or default one). For a much more detailed API, see the API documentation &lt;a href=&#34;https://raw.githubusercontent.com/xelis-project/xelis-blockchain/master/API.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;WebSocket&lt;/h3&gt; &#xA;&lt;p&gt;WebSocket allow JSON-RPC call and any app to be notified when a specific event happens on the daemon. It is running on &lt;code&gt;/ws&lt;/code&gt; route on same RPC server address.&lt;/p&gt; &#xA;&lt;p&gt;Example to subscribe to a registered event in the WebSocket connection:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;jsonrpc&#34;: &#34;2.0&#34;,&#xA;    &#34;id&#34;: 1,&#xA;    &#34;method&#34;: &#34;subscribe&#34;,&#xA;    &#34;params&#34;: {&#xA;        &#34;notify&#34;: &#34;new_block&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can notify to several events, just do a request for each event you want. The daemon will send you every events happening as long as you don&#39;t unsubscribe or close the WebSocket.&lt;/p&gt; &#xA;&lt;p&gt;Example to unsubscribe to a specific event:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;jsonrpc&#34;: &#34;2.0&#34;,&#xA;    &#34;id&#34;: 1,&#xA;    &#34;method&#34;: &#34;unsubscribe&#34;,&#xA;    &#34;params&#34;: {&#xA;        &#34;notify&#34;: &#34;new_block&#34;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Daemon&lt;/h4&gt; &#xA;&lt;p&gt;Events availables to subscribe on the daemon API are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;block_ordered&lt;/code&gt;: when a block is ordered by DAG&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;stable_height_changed&lt;/code&gt;: when the stable height has been updated&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;peer_connected&lt;/code&gt;: when a new peer has connected to the node&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;peer_disconnected&lt;/code&gt;: when a peer disconnected from us&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;peer_peer_list_updated&lt;/code&gt;: when the peerlist of a peer has been updated&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;peer_state_updated&lt;/code&gt;: when the peer state has been updated&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;peer_peer_disconnected&lt;/code&gt;: when a common peer disconnect from one of our peer&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;new_block&lt;/code&gt;: when a new block is accepted by chain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;transaction_added_in_mempool&lt;/code&gt;: when a new valid transaction is added in mempool&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;transaction_executed&lt;/code&gt;: when a transaction has been included in a valid block &amp;amp; executed on chain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;transaction_sc_result&lt;/code&gt;: when a valid TX SC Call hash has been executed by chain&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;new_asset&lt;/code&gt;: when a new asset has been registered&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;block_ordered&lt;/code&gt; when a block is ordered for the first time or reordered to a new topoheight&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;block_orphaned&lt;/code&gt; when a block that was previously ordered became orphaned because it was not selected in DAG reorg.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Wallet&lt;/h4&gt; &#xA;&lt;p&gt;Events availables to subscribe on the wallet API are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;new_topoheight&lt;/code&gt;: when a new topoheight is sent by the daemon&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;new_asset&lt;/code&gt;: when a new asset has been added to the wallet.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;new_transaction&lt;/code&gt;: when a new transaction (coinbase, outgoing, incoming) has been added to wallet history.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;balance_changed&lt;/code&gt;: when a balance changes has been detected.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;rescan&lt;/code&gt;: when a rescan happened on the wallet.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;online&lt;/code&gt;: when the wallet network state is now online.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;offline&lt;/code&gt;: whenthe wallet network state is now offline.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;XSWD&lt;/h3&gt; &#xA;&lt;p&gt;XSWD (XELIS Secure WebSocket DApp) Protocol is a WebSocket started on unique port &lt;code&gt;44325&lt;/code&gt; and path &lt;code&gt;/xswd&lt;/code&gt; for easy findings from dApps. Its job is to provide an easy to access and secure way to communicate from a desktop/CLI wallet to any dApp (software or in-browser/websites directly).&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s based on the JSON-RPC API and have exact same methods for easy compabitility, the only exception is how verification is done. On a traditional RPC-Server, if authentication is enabled, you must provide a username/password.&lt;/p&gt; &#xA;&lt;p&gt;XSWD stay open but request a manual action from user to accept the connection of the dApp on the XSWD Server. When accepted, the dApp can requests JSON-RPC methods easily and the user can set/configure a permission for each method. If no permission is found for a request method, it will be prompted/asked to the user for manual verification.&lt;/p&gt; &#xA;&lt;p&gt;XSWD also have the ability to sends JSON-RPC requests to the daemon directly. For this, set the prefix &lt;code&gt;node.&lt;/code&gt; in front of daemon requests, it will not be requested to the user as it&#39;s public on-chain data. For wallets RPC methods, set the prefix &lt;code&gt;wallet.&lt;/code&gt; which will requests/use the permission set by the user.&lt;/p&gt; &#xA;&lt;p&gt;DApp can also request to sign the &lt;code&gt;ApplicationData&lt;/code&gt; to persist the configured permissions on its side and then provide it when user would reconnect later.&lt;/p&gt; &#xA;&lt;p&gt;First JSON message from the dApp must be in following format to identify the application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;id&#34;: &#34;0000006b2aec4651b82111816ed599d1b72176c425128c66b2ab945552437dc9&#34;,&#xA;    &#34;name&#34;: &#34;XELIS Example&#34;,&#xA;    &#34;description&#34;: &#34;Description example of up to 255 characters&#34;,&#xA;    &#34;url&#34;: &#34;https://xelis.io&#34;,&#xA;    &#34;permissions&#34;: {}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also add &lt;code&gt;signature&lt;/code&gt; field and provide signed permissions if your dApp requested a signature from wallet in previous connection.&lt;/p&gt; &#xA;&lt;p&gt;If dApp is accepted by user through XSWD, you will receive the following response:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;id&#34;: null,&#xA;    &#34;jsonrpc&#34;: &#34;2.0&#34;,&#xA;    &#34;result&#34;: true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Otherwise, an error like this will be sent and the connection will be closed by the server:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;    &#34;error&#34;: {&#xA;        &#34;code&#34;: -32603,&#xA;        &#34;message&#34;: &#34;Invalid JSON format for application data&#34;&#xA;    },&#xA;    &#34;id&#34;: null,&#xA;    &#34;jsonrpc&#34;: &#34;2.0&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;How to build&lt;/h2&gt; &#xA;&lt;p&gt;Building this project requires a working &lt;a href=&#34;https://rustup.rs&#34;&gt;Rust&lt;/a&gt; (stable) toolchain.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s expected to be cross-platform and guaranteed to work on Linux, Windows, MacOS platforms.&lt;/p&gt; &#xA;&lt;h3&gt;Build from sub project&lt;/h3&gt; &#xA;&lt;p&gt;Go to one of following folder you want to build from source: &lt;code&gt;xelis_daemon&lt;/code&gt;, &lt;code&gt;xelis_miner&lt;/code&gt; or &lt;code&gt;xelis_wallet&lt;/code&gt;. To build a release (optimized) version: &lt;code&gt;cargo build --release&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Build from workspace&lt;/h3&gt; &#xA;&lt;p&gt;To build a version from workspace (parent folder) directly, use the option &lt;code&gt;--bin&lt;/code&gt; with &lt;code&gt;xelis_daemon&lt;/code&gt;, &lt;code&gt;xelis_miner&lt;/code&gt; or &lt;code&gt;xelis_wallet&lt;/code&gt; as value. Example: &lt;code&gt;cargo build --release --bin xelis_miner&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can also build a debug version (just remove &lt;code&gt;--release&lt;/code&gt; option) or run it directly from cargo: &lt;code&gt;cargo run&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Build from Docker&lt;/h3&gt; &#xA;&lt;p&gt;To build using Docker, use the following command, using the &lt;code&gt;app&lt;/code&gt; build argument to chose which project to build: &lt;code&gt;docker build -t xelis-daemon:master --build-arg app=xelis_daemon .&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Funding&lt;/h2&gt; &#xA;&lt;p&gt;XELIS is a community driven project and is not funded by any company or organization. To helps the development, the success and provide a better support of XELIS, we set a dev fee percentage starting at 15% on block reward.&lt;/p&gt; &#xA;&lt;p&gt;Current dev fee curve is as following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;15% from block 0 to 1 250 000 (expected time is ~6 months with side blocks from blockDAG)&lt;/li&gt; &#xA; &lt;li&gt;10% from block 1 250 001 to 3 000 000 (expected time is another ~6 months with side blocks from blockDAG and network growing)&lt;/li&gt; &#xA; &lt;li&gt;5% from 3 000 001 until the project being developed and stable enough to reduce it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>