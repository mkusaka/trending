<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-12T01:45:24Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>queer/boxxy</title>
    <updated>2023-02-12T01:45:24Z</updated>
    <id>tag:github.com,2023-02-12:/queer/boxxy</id>
    <link href="https://github.com/queer/boxxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;boxxy puts bad Linux applications in a box with only their files.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;boxxy&lt;/h1&gt; &#xA;&lt;p&gt;boxxy is a tool for boxing up misbehaving Linux applications and forcing them to put their files and directories in the right place, &lt;strong&gt;without symlinks!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Linux-only! boxxy uses Linux namespaces for its functionality.&lt;/p&gt; &#xA;&lt;p&gt;For example, consider tmux. It wants to put its config in &lt;code&gt;~/.tmux.conf&lt;/code&gt;. With boxxy, you can put its config in &lt;code&gt;~/.config/tmux/tmux.conf&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# ~/.config/boxxy/boxxy.yaml&#xA;rules:&#xA;- name: &#34;redirect tmux config from ~/.tmux.conf to ~/.config/tmux/tmux.conf&#34;&#xA;  target: &#34;~/.tmux.conf&#34;&#xA;  rewrite: &#34;~/.config/tmux/tmux.conf&#34;&#xA;  mode: &#34;file&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/558679&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/558679.svg?sanitize=true&#34; alt=&#34;asciicast&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;motivation&lt;/h2&gt; &#xA;&lt;p&gt;I recently had to use the AWS CLI. It wants to save data in &lt;code&gt;~/.aws&lt;/code&gt;, but I don&#39;t want it to just clutter up my &lt;code&gt;$HOME&lt;/code&gt; however it wants. boxxy lets me force it to puts its data somewhere nice and proper.&lt;/p&gt; &#xA;&lt;h2&gt;features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;box any program and force it to put its files/directories where you want it to&lt;/li&gt; &#xA; &lt;li&gt;context-dependent boxing, ie different rules apply in different directories depending on your configuration&lt;/li&gt; &#xA; &lt;li&gt;minimal overhead&lt;/li&gt; &#xA; &lt;li&gt;opt-in immutable fs outside of rule rewrites, ie only the files/directories you specify in rules are writable&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;potential drawbacks&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;new project, 0.x.y, comes with all those warnings&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;cannot&lt;/strong&gt; use sudo inside the container (see &lt;a href=&#34;https://github.com/queer/boxxy/issues/6&#34;&gt;#6&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;primarily tested for my use-cases&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;example usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git:(mistress) | ▶  cat ~/.config/boxxy/boxxy.yaml&#xA;rules:&#xA;- name: &#34;Store AWS CLI config in ~/.config/aws&#34;&#xA;  target: &#34;~/.aws&#34;&#xA;  rewrite: &#34;~/.config/aws&#34;&#xA;&#xA;git:(mistress) | ▶  boxxy aws configure&#xA; INFO  boxxy &amp;gt; loaded 1 rules&#xA; INFO  boxxy::enclosure &amp;gt; applying rule &#39;Store AWS CLI config in ~/.config/aws&#39;&#xA; INFO  boxxy::enclosure &amp;gt; redirect: ~/.aws -&amp;gt; ~/.config/aws&#xA; INFO  boxxy::enclosure &amp;gt; boxed &#34;aws&#34; ♥&#xA;AWS Access Key ID [****************d]: a&#xA;AWS Secret Access Key [****************c]: b&#xA;Default region name [b]: c&#xA;Default output format [a]: d&#xA;git:(mistress) | ▶  ls ~/.aws&#xA;git:(mistress) | ▶  ls ~/.config/aws&#xA;config  credentials&#xA;git:(mistress) | ▶  cat ~/.config/aws/config&#xA;[default]&#xA;region = c&#xA;output = d&#xA;git:(mistress) | ▶&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;suggested usage&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;alias aws=&#34;boxxy aws&#34;&lt;/code&gt; (repeat for other tools)&lt;/li&gt; &#xA; &lt;li&gt;use contexts to keep project configs separate on disk&lt;/li&gt; &#xA; &lt;li&gt;dotfiles!&lt;/li&gt; &#xA; &lt;li&gt;stop using symlinks!!!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;configuration&lt;/h2&gt; &#xA;&lt;p&gt;The boxxy configuration file lives in &lt;code&gt;~/.config/boxxy/boxxy.yaml&lt;/code&gt;. If none exists, an empty one will be created for you.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;rules:&#xA;# The name of the rule. User-friendly name for your reference&#xA;- name: &#34;redirect aws-cli from ~/.aws to ~/.config/aws&#34;&#xA;  # The target of the rule, ie the file/directory that will be shadowed by the&#xA;  # rewrite.&#xA;  target: &#34;~/.aws&#34;&#xA;  # The rewrite of the rule, ie the file/directory that will be used instead of&#xA;  # the target.&#xA;  rewrite: &#34;~/.config/aws&#34;&#xA;- name: &#34;use different k8s configs when in ~/Projects/my-cool-startup&#34;&#xA;  target: &#34;~/.kube/config&#34;&#xA;  rewrite: &#34;~/Projects/my-cool-startup/.kube/config&#34;&#xA;  # The context for the rule. Any paths listed in the context are paths where&#xA;  # this rule will apply. If no context is specified, the rule applies&#xA;  # globally.&#xA;  context:&#xA;  - &#34;~/Projects/my-cool-startup&#34;&#xA;  # The mode of this rule, either `directory` or `file`. `directory` is the&#xA;  # default. Must be specified for the correct behaviour when the target is a&#xA;  # file. Required because the target file/directory may not exist yet.&#xA;  mode: &#34;file&#34;&#xA;  # The list of commands that this rule applies to. If no commands are&#xA;  # specified, the rule applies to all programs run with boxxy.&#xA;  only:&#xA;  - &#34;kubectl&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;syntax&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;rules:&#xA;- name: &#34;any valid string&#34; # required&#xA;  target: &#34;path&#34; # required&#xA;  rewrite: &#34;path&#34; # required&#xA;  context: # optional&#xA;  - &#34;path&#34;&#xA;  - &#34;path&#34;&#xA;  mode: &#34;directory | file&#34; # optional&#xA;  only: # optional&#xA;  - &#34;binary name&#34;&#xA;  - &#34;binary name&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;developing&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;set up pre-commit: &lt;code&gt;pre-commit install&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;make sure it builds: &lt;code&gt;cargo build&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;do the thing!&lt;/li&gt; &#xA; &lt;li&gt;test with the command of your choice, ex. &lt;code&gt;cargo run -- ls -lah ~/.config&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;how does it work?&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;create temporary directory in /tmp&lt;/li&gt; &#xA; &lt;li&gt;set up new user/mount namespace&lt;/li&gt; &#xA; &lt;li&gt;bind-mount &lt;code&gt;/&lt;/code&gt; to tmp directory&lt;/li&gt; &#xA; &lt;li&gt;bind-mount rule mounts rw so that target programs can use them&lt;/li&gt; &#xA; &lt;li&gt;remount &lt;code&gt;/&lt;/code&gt; ro&lt;/li&gt; &#xA; &lt;li&gt;run!&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>eto-ai/lance</title>
    <updated>2023-02-12T01:45:24Z</updated>
    <id>tag:github.com,2023-02-12:/eto-ai/lance</id>
    <link href="https://github.com/eto-ai/lance" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Alternative to Parquet. 100x faster for random access, includes a vector index and automatic versioning. Apache Arrow and DuckDB compatible.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;p align=&#34;center&#34;&gt; &lt;img width=&#34;257&#34; alt=&#34;Lance Logo&#34; src=&#34;https://user-images.githubusercontent.com/917119/199353423-d3e202f7-0269-411d-8ff2-e747e419e492.png&#34;&gt; &lt;/p&gt;&#xA; &lt;p&gt;&lt;strong&gt;Alternative to Parquet. 100x faster for random access, includes a vector index and automatic versioning. Apache Arrow and DuckDB compatible.&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;a href=&#34;https://eto-ai.github.io/lance/&#34;&gt;Documentation&lt;/a&gt; • &lt;a href=&#34;https://blog.eto.ai/&#34;&gt;Blog&lt;/a&gt; • &lt;a href=&#34;https://discord.gg/zMM32dvNtd&#34;&gt;Discord&lt;/a&gt; • &lt;a href=&#34;https://twitter.com/etodotai&#34;&gt;Twitter&lt;/a&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://github.com/eto-ai/lance/actions/workflows/rust.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://eto-ai.github.io/lance/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docs-passing-brightgreen&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/pypi/pyversions/pylance&#34; alt=&#34;Python versions&#34;&gt;&lt;/p&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;Lance is a columnar data format that is easy and fast to version, query and train on. It’s designed to be used with images, videos, 3D point clouds, audio and of course tabular data. The key features of Lance include:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;High-performance random access:&lt;/strong&gt; 100x faster than Parquet.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Vector search:&lt;/strong&gt; find nearest neighbors in under 1 millisecond and combine OLAP-queries with vector search.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Zero-copy, automatic versioning:&lt;/strong&gt; manage versions of your data automatically, and reduce redundancy with zero-copy logic built-in.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Ecosystem integrations:&lt;/strong&gt; Apache-Arrow, DuckDB and more on the way.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Installation&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install pylance&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Converting to Lance&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import lance&#xA;&#xA;import pandas as pd&#xA;import pyarrow as pa&#xA;import pyarrow.dataset&#xA;&#xA;df = pd.DataFrame({&#34;a&#34;: [5], &#34;b&#34;: [10]})&#xA;uri = &#34;/tmp/test.parquet&#34;&#xA;tbl = pa.Table.from_pandas(df)&#xA;pa.dataset.write_dataset(tbl, uri, format=&#39;parquet&#39;)&#xA;&#xA;parquet = pa.dataset.dataset(uri, format=&#39;parquet&#39;)&#xA;lance.write_dataset(parquet, &#34;/tmp/test.lance&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Reading Lance data&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset = lance.dataset(&#34;/tmp/test.lance&#34;)&#xA;assert isinstance(dataset, pa.dataset.Dataset)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Pandas&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = dataset.to_table().to_pandas()&#xA;df&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;DuckDB&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import duckdb&#xA;&#xA;tbl = dataset.to_table()  # next release of duckdb will have pushdowns enabled&#xA;duckdb.query(&#34;SELECT * FROM tbl LIMIT 10&#34;).to_df()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vector search&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Download an indexed &lt;a href=&#34;https://eto-public.s3.us-west-2.amazonaws.com/datasets/sift/sift_ivf256_pq16.tar.gz&#34;&gt;sift dataset&lt;/a&gt;, and unzip it into &lt;code&gt;vec_data.lance&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://eto-public.s3.us-west-2.amazonaws.com/datasets/sift/sift_ivf256_pq16.tar.gz&#xA;tar -xzf sift_ivf256_pq16.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Get top 10 similar vectors&#xA;import lance&#xA;import duckdb&#xA;import numpy as np&#xA;&#xA;uri = &#34;vec_data.lance&#34;&#xA;dataset = lance.dataset(uri)&#xA;&#xA;# Sample 100 query vectors&#xA;tbl = dataset.to_table()&#xA;sample = duckdb.query(&#34;SELECT vector FROM tbl USING SAMPLE 100&#34;).to_df()&#xA;query_vectors = np.array([np.array(x) for x in sample.vector])&#xA;&#xA;# Get nearest neighbors for all of them&#xA;rs = [dataset.to_table(nearest={&#34;column&#34;: &#34;vector&#34;, &#xA;                                &#34;k&#34;: 10, &#xA;                                &#34;q&#34;: query_vectors[i, :]}) &#xA;      for i in range(query_vectors.shape[0])]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Directory structure&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Directory&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eto-ai/lance/main/rust&#34;&gt;rust&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Core Rust implementation&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eto-ai/lance/main/python&#34;&gt;python&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Python bindings (pyo3)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://raw.githubusercontent.com/eto-ai/lance/main/docs&#34;&gt;docs&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Documentation source&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;What makes Lance different&lt;/h2&gt; &#xA;&lt;p&gt;Here we will highlight a few aspects of Lance’s design. For more details, see the full &lt;a href=&#34;https://eto-ai.github.io/lance/format.html&#34;&gt;Lance design document&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Vector index&lt;/strong&gt;: Vector index for similarity search over embedding space&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Encodings&lt;/strong&gt;: to achieve both fast columnar scan and sub-linear point queries, Lance uses custom encodings and layouts.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Nested fields&lt;/strong&gt;: Lance stores each subfield as a separate column to support efficient filters like “find images where detected objects include cats”.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Versioning&lt;/strong&gt;: a Manifest can be used to record snapshots. Currently we support creating new versions automatically via appends, overwrites, and index creation&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fast updates&lt;/strong&gt; (ROADMAP): Updates will be supported via write-ahead logs.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Rich secondary indices&lt;/strong&gt; (ROADMAP):&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Inverted index for fuzzy search over many label / annotation fields&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;h3&gt;Vector search&lt;/h3&gt; &#xA;&lt;p&gt;We used the sift dataset to benchmark our results with 1M vectors of 128D&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;For 100 randomly sampled query vectors, we get &amp;lt;1ms average response time (on a 2023 m2 macbook air)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eto-ai/lance/main/docs/avg_latency.png&#34; alt=&#34;avg_latency.png&#34;&gt;&lt;/p&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;ANN is always a trade-off between recall and performance&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eto-ai/lance/main/docs/recall_vs_latency.png&#34; alt=&#34;avg_latency.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Vs parquet&lt;/h3&gt; &#xA;&lt;p&gt;We create a Lance dataset using the Oxford Pet dataset to do some preliminary performance testing of Lance as compared to Parquet and raw image/xmls. For analytics queries, Lance is 50-100x better than reading the raw metadata. For batched random access, Lance is 100x better than both parquet and raw files.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/eto-ai/lance/main/docs/lance_perf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why are you building yet another data format?!&lt;/h2&gt; &#xA;&lt;p&gt;Machine Learning development cycle involves the steps:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR&#xA;    A[Collection] --&amp;gt; B[Exploration];&#xA;    B --&amp;gt; C[Analytics];&#xA;    C --&amp;gt; D[Feature Engineer];&#xA;    D --&amp;gt; E[Training];&#xA;    E --&amp;gt; F[Evaluation];&#xA;    F --&amp;gt; C;&#xA;    E --&amp;gt; G[Deployment];&#xA;    G --&amp;gt; H[Monitoring];&#xA;    H --&amp;gt; A;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;People use different data representations to varying stages for the performance or limited by the tooling available. The academia mainly uses XML / JSON for annotations and zipped images/sensors data for deep learning, which is difficult to integrated into data infrastructure and slow to train over cloud storage. While the industry uses data lake (Parquet-based techniques, i.e., Delta Lake, Iceberg) or data warehouse (AWS Redshift or Google BigQuery) to collect and analyze data, they have to convert the data into training-friendly formats, such as &lt;a href=&#34;https://github.com/eto-ai/rikai&#34;&gt;Rikai&lt;/a&gt;/&lt;a href=&#34;https://github.com/uber/petastorm&#34;&gt;Petastorm&lt;/a&gt; or &lt;a href=&#34;https://www.tensorflow.org/tutorials/load_data/tfrecord&#34;&gt;Tfrecord&lt;/a&gt;. Multiple single-purpose data transforms, as well as syncing copies between cloud storage to local training instances have become a common practice among ML practices.&lt;/p&gt; &#xA;&lt;p&gt;While each of the existing data formats excel at its original designed workload, we need a new data format to tailored for multistage ML development cycle to reduce the fraction in tools and data silos.&lt;/p&gt; &#xA;&lt;p&gt;A comparison of different data formats in each stage of ML development cycle.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;&lt;/th&gt; &#xA;   &lt;th&gt;Lance&lt;/th&gt; &#xA;   &lt;th&gt;Parquet &amp;amp; ORC&lt;/th&gt; &#xA;   &lt;th&gt;JSON &amp;amp; XML&lt;/th&gt; &#xA;   &lt;th&gt;Tfrecord&lt;/th&gt; &#xA;   &lt;th&gt;Database&lt;/th&gt; &#xA;   &lt;th&gt;Warehouse&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Analytics&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;   &lt;td&gt;Decent&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Feature Engineering&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Decent&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;   &lt;td&gt;Decent&lt;/td&gt; &#xA;   &lt;td&gt;Good&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Training&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Decent&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Exploration&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Slow&lt;/td&gt; &#xA;   &lt;td&gt;Fast&lt;/td&gt; &#xA;   &lt;td&gt;Decent&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Infra Support&lt;/td&gt; &#xA;   &lt;td&gt;Rich&lt;/td&gt; &#xA;   &lt;td&gt;Rich&lt;/td&gt; &#xA;   &lt;td&gt;Decent&lt;/td&gt; &#xA;   &lt;td&gt;Limited&lt;/td&gt; &#xA;   &lt;td&gt;Rich&lt;/td&gt; &#xA;   &lt;td&gt;Rich&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Presentations and Talks&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.google.com/presentation/d/1a4nAiQAkPDBtOfXFpPg7lbeDAxcNDVKgoUkw3cUs2rE/edit#slide=id.p&#34;&gt;Lance: A New Columnar Data Format&lt;/a&gt;, &lt;a href=&#34;https://www.scipy2022.scipy.org/posters&#34;&gt;Scipy 2022, Austin, TX&lt;/a&gt;. July, 2022.&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>