<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-26T01:33:55Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>beac0n/ruroco</title>
    <updated>2024-08-26T01:33:55Z</updated>
    <id>tag:github.com,2024-08-26:/beac0n/ruroco</id>
    <link href="https://github.com/beac0n/ruroco" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruroco is a tool that lets you execute commands on a server by sending UDP packets. The commands are configured on the server side, so the client does not define what is going to be executed, it only picks from existing commands.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/beac0n/ruroco/actions&#34;&gt;&lt;img src=&#34;https://github.com/beac0n/ruroco/actions/workflows/rust.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/beac0n/ruroco/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/beac0n/ruroco?style=flat&amp;amp;labelColor=1C2C2E&amp;amp;color=C96329&amp;amp;logo=GitHub&amp;amp;logoColor=white&#34; alt=&#34;release&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/beac0n/ruroco&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/beac0n/ruroco/graph/badge.svg?token=H7ABBHYYWT&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;ruroco - RUn RemOte COmmand&lt;/h1&gt; &#xA;&lt;p&gt;ruroco is a tool that lets you execute commands on a server by sending UDP packets.&lt;/p&gt; &#xA;&lt;p&gt;the tool consist of 3 binaries:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;client&lt;/code&gt;: runs on your notebook/computer and sends the UDP packets&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server&lt;/code&gt;: receives the UDP packets and makes sure that they are valid&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;commander&lt;/code&gt;: runs the command encoded by the data of the UDP packet if it&#39;s valid&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The commands are configured on the server side, so the client does not define what is going to be executed, it only picks from existing commands.&lt;/p&gt; &#xA;&lt;h2&gt;security&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;client sends UDP packet to server, server never responds to it -&amp;gt; &lt;strong&gt;port-scanning&lt;/strong&gt; does not help an adversary&lt;/li&gt; &#xA; &lt;li&gt;data sent from client to server is &lt;strong&gt;encrypted&lt;/strong&gt; using &lt;strong&gt;RSA&lt;/strong&gt;&lt;/li&gt; &#xA; &lt;li&gt;client only defines command to execute, &lt;strong&gt;commands are saved on server&lt;/strong&gt; -&amp;gt; client can pick command but not define it&lt;/li&gt; &#xA; &lt;li&gt;run server software in such a way so that it uses &lt;strong&gt;as little operating system rights&lt;/strong&gt; as possible&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;replay protection&lt;/strong&gt; by adding every packet that the server received to a blocklist&lt;/li&gt; &#xA; &lt;li&gt;(WIP) DoS protection&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;use cases&lt;/h1&gt; &#xA;&lt;h2&gt;single packet authorization (SPA)&lt;/h2&gt; &#xA;&lt;p&gt;If you host a server on the web, you know that you&#39;ll get lots of brute-force attacks on (at least) the SSH port of your server. While using good practices in securing your server will keep you safe from such attacks, these attacks are quite annoying (filling up logs) and even if you secured your server correctly, you will still not be 100% safe, see &lt;a href=&#34;https://www.schneier.com/blog/archives/2024/04/xz-utils-backdoor.html&#34;&gt;https://www.schneier.com/blog/archives/2024/04/xz-utils-backdoor.html&lt;/a&gt; or &lt;a href=&#34;https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt&#34;&gt;https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Completely blocking all traffic to all ports that do not have to be open at all times can reduce the attack surface. But blocking the SSH port completely will make SSH unusable for that server.&lt;/p&gt; &#xA;&lt;p&gt;This is where ruroco comes in. Ruroco can execute a command that opens up the SSH port for just a short amount of time, so that you can ssh into your server. Afterward ruruco closes the SSH port again. To implement this use case with ruroco, you have to use a configuration similar to the one shown below:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;address = &#34;0.0.0.0:8080&#34;  # address the ruroco serer listens on, if systemd/ruroco.socket is not used&#xA;config_dir = &#34;/etc/ruroco/&#34;  # path where the configuration files are saved&#xA;&#xA;[commands]&#xA;# open ssh, but only for the IP address where the request came from&#xA;open_ssh = &#34;ufw allow from $RUROCO_IP proto tcp to any port 22&#34;&#xA;# close ssh, but only for the IP address where the request came from&#xA;close_ssh = &#34;ufw delete allow from $RUROCO_IP proto tcp to any port 22&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have configured ruroco on server like that and execute the following client side command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruroco-client send --address host.domain:8080 --private-pem-path /path/to/ruroco_private.pem --command open_ssh --deadline 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the server will validate that the client is authorized to execute that command by using public-key cryptography (RSA) and will then execute the command defined in the config above under &#34;open_ssh&#34;. The &lt;code&gt;--deadline&lt;/code&gt; argument means that the command has to be started on the server within 5 seconds after executing the command.&lt;/p&gt; &#xA;&lt;p&gt;This gives you the ability to effectively only allow access to the SSH port, for only the IP that the UDP packet was sent from, if you want to connect to your server. Of course, you should also do all the other security hardening tasks you would do if the SSH port would be exposed to the internet.&lt;/p&gt; &#xA;&lt;p&gt;You can define any number of commands you wish, by adding more commands to configuration file.&lt;/p&gt; &#xA;&lt;h2&gt;Enabling webservice&lt;/h2&gt; &#xA;&lt;p&gt;You may run a webservice like &lt;a href=&#34;https://github.com/filebrowser/filebrowser&#34;&gt;https://github.com/filebrowser/filebrowser&lt;/a&gt; on your server, which you do not want to publicly expose. If you use nginx as a reverse proxy, you can use ruroco to enable or disable services:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;address = &#34;0.0.0.0:8080&#34;  # address the ruroco serer listens on, if systemd/ruroco.socket is not used&#xA;config_dir = &#34;/etc/ruroco/&#34;  # path where the configuration files are saved&#xA;&#xA;[commands]&#xA;# disable file browser nginx config file and reload nginx&#xA;disable_file_browser = &#34;mv /etc/nginx/conf.d/https_file_browser.conf /etc/nginx/conf.d/https_file_browser.conf_disabled &amp;amp;&amp;amp; nginx -s reload&#34;&#xA;# enable file browser nginx config file and reload nginx&#xA;enable_file_browser = &#34;mv /etc/nginx/conf.d/https_file_browser.conf_disabled /etc/nginx/conf.d/https_file_browser.conf &amp;amp;&amp;amp; nginx -s reload&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you have configured ruroco on server like that and execute the following client side command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ruroco-client send --address host.domain:8080 --private-pem-path /path/to/ruroco_private.pem --command enable_file_browser --deadline 5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;the file browser nginx config will be enabled and nginx reloaded, effectively making the file browser accessible.&lt;/p&gt; &#xA;&lt;h1&gt;setup&lt;/h1&gt; &#xA;&lt;p&gt;download binaries from the &lt;a href=&#34;https://github.com/beac0n/ruroco/releases&#34;&gt;releases page&lt;/a&gt; or build them yourself by running&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;make release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;you can find the binaries in &lt;code&gt;target/release/client&lt;/code&gt;, &lt;code&gt;target/release/server&lt;/code&gt; and &lt;code&gt;target/release/commander&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;client&lt;/h2&gt; &#xA;&lt;h3&gt;self-build&lt;/h3&gt; &#xA;&lt;p&gt;See make goal &lt;code&gt;install_client&lt;/code&gt;. This builds the project and copies the client binary to &lt;code&gt;/usr/local/bin/ruroco-client&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;pre-build&lt;/h3&gt; &#xA;&lt;p&gt;Download the &lt;code&gt;client-v&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;.&amp;lt;patch&amp;gt;-x86_64-linux&lt;/code&gt; binary from &lt;a href=&#34;https://github.com/beac0n/ruroco/releases/latest&#34;&gt;https://github.com/beac0n/ruroco/releases/latest&lt;/a&gt; and move it to &lt;code&gt;/usr/local/bin/ruroco-client&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;server&lt;/h2&gt; &#xA;&lt;h3&gt;self-build&lt;/h3&gt; &#xA;&lt;p&gt;See make goal &lt;code&gt;install_server&lt;/code&gt;, which&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Builds the project&lt;/li&gt; &#xA; &lt;li&gt;Copies the binaries to &lt;code&gt;/usr/local/bin/&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Adds a &lt;code&gt;ruroco&lt;/code&gt; user if it does not exist yet&lt;/li&gt; &#xA; &lt;li&gt;Copies the systemd service files and config files to the right places&lt;/li&gt; &#xA; &lt;li&gt;Assigns correct file permissions to the systemd and config files&lt;/li&gt; &#xA; &lt;li&gt;Enables and starts the systemd services&lt;/li&gt; &#xA; &lt;li&gt;After running the make goal, you have to &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;generate a RSA key and copy it to the right place&lt;/li&gt; &#xA;   &lt;li&gt;setup the &lt;code&gt;config.toml&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;pre-build&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Download the &lt;code&gt;server-v&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;.&amp;lt;patch&amp;gt;-x86_64-linux&lt;/code&gt; and &lt;code&gt;commander-v&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;.&amp;lt;patch&amp;gt;-x86_64-linux&lt;/code&gt; binaries from &lt;a href=&#34;https://github.com/beac0n/ruroco/releases/latest&#34;&gt;https://github.com/beac0n/ruroco/releases/latest&lt;/a&gt; and move them to &lt;code&gt;/usr/local/bin/ruroco-server&lt;/code&gt; and &lt;code&gt;/usr/local/bin/ruroco-commander&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Make sure that the binaries have the minimal permission sets needed: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo chmod 500 /usr/local/bin/ruroco-server&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo chmod 100 /usr/local/bin/ruroco-commander&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo chown ruroco:ruroco /usr/local/bin/ruroco-server&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Create the &lt;code&gt;ruroco&lt;/code&gt; user: &lt;code&gt;sudo useradd --system ruroco --shell /bin/false&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Install the systemd service files from the &lt;code&gt;systemd&lt;/code&gt; folder: &lt;code&gt;sudo cp ./systemd/* /etc/systemd/system&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Create &lt;code&gt;/etc/ruroco/config.toml&lt;/code&gt; and define your config and commands, e.g.: &lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;address = &#34;127.0.0.1:8080&#34;  # address the ruroco serer listens on, if systemd/ruroco.socket is not used&#xA;config_dir = &#34;/etc/ruroco/&#34;  # path where the configuration files are saved&#xA;&#xA;[commands]&#xA;# commands will be added here - see configuration chapter&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Make sure that the configuration file has the minimal permission set needed: &lt;code&gt;sudo chmod 400 /etc/ruroco/config.toml&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;N.B. If you edit the [commands] in &lt;code&gt;/etc/ruroco/config.toml&lt;/code&gt; then restart ruroco-commander&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Since new systemd files have been added, reload the daemon: &lt;code&gt;sudo systemctl daemon-reload&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Enable the systemd services: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo systemctl enable ruroco.service&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo systemctl enable ruroco-commander.service&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo systemctl enable ruroco.socket&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;Start the systemd services &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo systemctl start ruroco-commander.service&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo systemctl start ruroco.socket&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;sudo systemctl start ruroco.service&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;configuration&lt;/h1&gt; &#xA;&lt;h2&gt;generate and deploy rsa key&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;run &lt;code&gt;ruroco-client gen&lt;/code&gt; to generate two files: &lt;code&gt;ruroco_private.pem&lt;/code&gt; and &lt;code&gt;ruroco_public.pem&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;move &lt;code&gt;ruroco_public.pem&lt;/code&gt; to &lt;code&gt;/etc/ruroco/ruroco_public.pem&lt;/code&gt; on server&lt;/li&gt; &#xA; &lt;li&gt;save &lt;code&gt;ruroco_private.pem&lt;/code&gt; to &lt;code&gt;~/.config/ruroco/ruroco_private.pem&lt;/code&gt; on client&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;update config&lt;/h2&gt; &#xA;&lt;p&gt;Add commands to config &lt;code&gt;/etc/ruroco/config.toml&lt;/code&gt; on server. The new config file &lt;strong&gt;could&lt;/strong&gt; look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;address = &#34;127.0.0.1:8080&#34;  # address the ruroco serer listens on, if systemd/ruroco.socket is not used&#xA;config_dir = &#34;/etc/ruroco/&#34;  # path where the configuration files are saved&#xA;&#xA;[commands]&#xA;# open ssh, but only for the IP address where the request came from&#xA;open_ssh = &#34;ufw allow from $RUROCO_IP proto tcp to any port 22&#34;&#xA;# close ssh, but only for the IP address where the request came from&#xA;close_ssh = &#34;ufw delete allow from $RUROCO_IP proto tcp to any port 22&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;architecture&lt;/h1&gt; &#xA;&lt;h2&gt;overview&lt;/h2&gt; &#xA;&lt;p&gt;The service consists of three parts:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;client&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;binary that is executed on your local host&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;server&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;service that runs on a remote host where you wish to execute the commands on&lt;/li&gt; &#xA;   &lt;li&gt;exposed to the internet&lt;/li&gt; &#xA;   &lt;li&gt;has minimal rights to receive and decrypt data and to communicate with the commander&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;commander&lt;/code&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;daemon service that runs on the same host as the server&lt;/li&gt; &#xA;   &lt;li&gt;not exposed to the internet&lt;/li&gt; &#xA;   &lt;li&gt;has all the rights it needs to run the commands that are passed to it&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- created with https://asciiflow.com/#/ --&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;┌────────────────┐ ┌────────────────┐&#xA;│                │ │                │&#xA;│   ┌────────┐   │ │ ┌────────────┐ │&#xA;│   │ Client ├───┼─┤►│   Server   │ │&#xA;│   └────────┘   │ │ └─────┬──────┘ │&#xA;│                │ │       │        │&#xA;│                │ │ ┌─────▼──────┐ │&#xA;│                │ │ │  Commander │ │&#xA;│                │ │ └────────────┘ │&#xA;│   Local Host   │ │   Remote Host  │&#xA;└────────────────┘ └────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;execution&lt;/h2&gt; &#xA;&lt;p&gt;Whenever a user sends a command via the client, the following steps are executed&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;client concatenates the current timestamp (in nanoseconds) with the command name (e.g. &#34;default&#34;), encrypts data with the private key and sends the encrypted data via UDP to the server&lt;/li&gt; &#xA; &lt;li&gt;server receives the UDP package (does &lt;strong&gt;not&lt;/strong&gt; answer), decrypts it with the public key and validates its content&lt;/li&gt; &#xA; &lt;li&gt;if the content is valid, the server sends the command name to the commander. If the content is invalid an error message is logged&lt;/li&gt; &#xA; &lt;li&gt;commander receives the command name and executes the command if the command is defined in the configuration&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;     ┌─────────┐            ┌─────────┐              ┌───────────┐              &#xA;     │ Client  │            │ Server  │              │ Commander │              &#xA;     └────┬────┘            └────┬────┘              └─────┬─────┘              &#xA;          │                      │                         │                    &#xA;          │ Encrypt and send     │                         │                    &#xA;          ├─────────────────────►│                         │                    &#xA;          │ data via UDP         │                         │                    &#xA;          │                      │ Decrypt and validate    │                    &#xA;          │                      ├─────────────┐ data      │                    &#xA;          │                      │             │           │                    &#xA;          │                      │◄────────────┘           │                    &#xA;          │                      │                         │                    &#xA;          │                      │                         │                    &#xA;          │                      │                         │                    &#xA;┌────┬────┼──────────────────────┼─────────────────────────┼───────────────────┐&#xA;│alt │    │                      │                         │                   │&#xA;├────┘    │                      │ Log error               │                   │&#xA;│if is    │                      ├─────────────┐           │                   │&#xA;│invalid  │                      │             │           │                   │&#xA;│         │                      │◄────────────┘           │                   │&#xA;│         │                      │                         │                   │&#xA;├─  ──  ──┤ ──  ──  ──  ──  ──  ─┤  ──  ──  ──  ──  ──  ── ├──  ──  ──  ──  ── │&#xA;│else     │                      │                         │                   │&#xA;│         │                      │ Send command name       │                   │&#xA;│         │                      ├────────────────────────►│                   │&#xA;│         │                      │                         │                   │&#xA;│         │                      │                         │ Check if command  │&#xA;│         │                      │                         │ is valid          │&#xA;│         │                      │                         ├───────────────┐   │&#xA;│         │                      │                         │               │   │&#xA;│         │                      │                         │◄──────────────┘   │&#xA;│         │                      │                         │                   │&#xA;│         │            ┌────┬────┼─────────────────────────┼───────────────────┤&#xA;│         │            │alt │    │                         │ Execute command   │&#xA;│         │            ├────┘    │                         ├───────────────┐   │&#xA;│         │            │if is    │                         │               │   │&#xA;│         │            │valid    │                         │◄──────────────┘   │&#xA;│         │            │         │                         │                   │&#xA;│         │            ├─  ──  ──┤ ──  ──  ──  ──  ──  ──  ├─  ──  ──  ──  ──  │&#xA;│         │            │else     │                         │Log Error          │&#xA;│         │            │         │                         ├───────────────┐   │&#xA;│         │            │         │                         │               │   │&#xA;│         │            │         │                         │◄──────────────┘   │&#xA;│         │            │         │                         │                   │&#xA;└─────────┴────────────┴─────────┴─────────────────────────┴───────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>