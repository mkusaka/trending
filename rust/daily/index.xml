<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-02T01:39:43Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>01mf02/jaq</title>
    <updated>2023-12-02T01:39:43Z</updated>
    <id>tag:github.com,2023-12-02:/01mf02/jaq</id>
    <link href="https://github.com/01mf02/jaq" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A jq clone focussed on correctness, speed, and simplicity&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;jaq&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/01mf02/jaq/workflows/Rust/badge.svg?sanitize=true&#34; alt=&#34;Build status&#34;&gt; &lt;a href=&#34;https://crates.io/crates/jaq-interpret&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/jaq-interpret.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/jaq-interpret&#34;&gt;&lt;img src=&#34;https://docs.rs/jaq-interpret/badge.svg?sanitize=true&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.rust-lang.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/rust-1.64+-orange.svg?sanitize=true&#34; alt=&#34;Rust 1.64+&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;jaq (pronounced like &lt;em&gt;Jacques&lt;/em&gt;[^jacques]) is a clone of the JSON data processing tool &lt;a href=&#34;https://jqlang.github.io/jq/&#34;&gt;jq&lt;/a&gt;. jaq aims to support a large subset of jq&#39;s syntax and operations.&lt;/p&gt; &#xA;&lt;p&gt;jaq focuses on three goals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Correctness&lt;/strong&gt;: jaq aims to provide a more correct and predictable implementation of jq, while preserving compatibility with jq in most cases.&lt;/p&gt; &#xA;  &lt;details&gt;&#xA;   &lt;summary&gt;Examples of surprising jq behaviour&lt;/summary&gt; &#xA;   &lt;ul&gt; &#xA;    &lt;li&gt;&lt;code&gt;nan &amp;gt; nan&lt;/code&gt; is false, while &lt;code&gt;nan &amp;lt; nan&lt;/code&gt; is true.&lt;/li&gt; &#xA;    &lt;li&gt;&lt;code&gt;[[]] | implode&lt;/code&gt; crashes jq, and this was not fixed at the time of writing despite &lt;a href=&#34;https://github.com/jqlang/jq/issues/1160&#34;&gt;being known since five years&lt;/a&gt;.&lt;/li&gt; &#xA;    &lt;li&gt;The &lt;a href=&#34;https://jqlang.github.io/jq/manual/v1.6/&#34;&gt;jq manual&lt;/a&gt; claims that &lt;code&gt;limit(n; exp)&lt;/code&gt; &#34;extracts up to &lt;code&gt;n&lt;/code&gt; outputs from &lt;code&gt;exp&lt;/code&gt;&#34;. This holds for values of &lt;code&gt;n &amp;gt; 1&lt;/code&gt;, e.g. &lt;code&gt;jq -n &#39;[limit(2; 1, 2, 3)]&#39;&lt;/code&gt; yields &lt;code&gt;[1, 2]&lt;/code&gt;, but when &lt;code&gt;n == 0&lt;/code&gt;, &lt;code&gt;jq -n &#39;[limit(0; 1, 2, 3)]&#39;&lt;/code&gt; yields &lt;code&gt;[1]&lt;/code&gt; instead of &lt;code&gt;[]&lt;/code&gt;. And perhaps even worse, when &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, then &lt;code&gt;limit&lt;/code&gt; yields &lt;em&gt;all&lt;/em&gt; outputs from &lt;code&gt;exp&lt;/code&gt;, which is not documented.&lt;/li&gt; &#xA;   &lt;/ul&gt; &#xA;  &lt;/details&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Performance&lt;/strong&gt;: I created jaq originally because I was bothered by &lt;a href=&#34;https://github.com/jqlang/jq/issues/1411&#34;&gt;jq&#39;s long start-up time&lt;/a&gt;, which amounts to about 50ms on my machine. This can particularly show when processing a large number of small files. jaq starts up about 30 times faster than jq 1.6 and &lt;a href=&#34;https://raw.githubusercontent.com/01mf02/jaq/main/#performance&#34;&gt;outperforms jq also on many other benchmarks&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Simplicity&lt;/strong&gt;: jaq aims to have a simple and small implementation, in order to reduce the potential for bugs and to facilitate contributions.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I drew inspiration from another Rust program, namely &lt;a href=&#34;https://github.com/yamafaktory/jql&#34;&gt;jql&lt;/a&gt;. However, unlike jql, jaq aims to closely imitate jq&#39;s syntax and semantics. This should allow users proficient in jq to easily use jaq.&lt;/p&gt; &#xA;&lt;p&gt;[^jacques]: I wanted to create a tool that should be discreet and obliging, like a good waiter. And when I think of a typical name for a (French) waiter, to my mind comes &#34;Jacques&#34;. Later, I found out about the old French word &lt;em&gt;jacquet&lt;/em&gt;, meaning &#34;squirrel&#34;, which makes for a nice &lt;em&gt;ex post&lt;/em&gt; inspiration for the name.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;h2&gt;From Source&lt;/h2&gt; &#xA;&lt;p&gt;To compile jaq, you need a Rust toolchain. See &lt;a href=&#34;https://rustup.rs/&#34;&gt;https://rustup.rs/&lt;/a&gt; for instructions. (Note that Rust compilers shipped with Linux distributions may be too outdated to compile jaq.)&lt;/p&gt; &#xA;&lt;p&gt;Any of the following commands install jaq:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cargo install --locked jaq&#xA;$ cargo install --locked --git https://github.com/01mf02/jaq # latest development version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;On my system, both commands place the executable at &lt;code&gt;~/.cargo/bin/jaq&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have cloned this repository, you can also build jaq by executing one of the commands in the cloned repository:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ cargo build --release # places binary into target/release/jaq&#xA;$ cargo install --locked --path jaq # installs binary&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;jaq should work on any system supported by Rust. If it does not, please file an issue.&lt;/p&gt; &#xA;&lt;h2&gt;Binaries&lt;/h2&gt; &#xA;&lt;p&gt;You may also install jaq using &lt;a href=&#34;https://formulae.brew.sh/formula/jaq&#34;&gt;homebrew&lt;/a&gt; on macOS or Linux:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ brew install jaq&#xA;$ brew install --HEAD jaq # latest development version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Examples&lt;/h1&gt; &#xA;&lt;p&gt;The following examples should give an impression of what jaq can currently do. You should obtain the same outputs by replacing jaq with jq. If not, your filing an issue would be appreciated. :) The syntax is documented in the &lt;a href=&#34;https://jqlang.github.io/jq/manual/v1.6/&#34;&gt;jq manual&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Access a field:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;.a&#39;&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Add values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;add&#39;&#xA;3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Construct an array from an object in two ways and show that they are equal:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;{&#34;a&#34;: 1, &#34;b&#34;: 2}&#39; | jaq &#39;[.a, .b] == [.[]]&#39;&#xA;true&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Apply a filter to all elements of an array and filter the results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;[0, 1, 2, 3]&#39; | jaq &#39;map(.*2) | [.[] | select(. &amp;lt; 5)]&#39;&#xA;[0, 2, 4]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Read (slurp) input values into an array and get the average of its elements:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;1 2 3 4&#39; | jaq -s &#39;add / length&#39;&#xA;2.5&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Repeatedly apply a filter to itself and output the intermediate results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;0&#39; | jaq &#39;[recurse(.+1; . &amp;lt; 3)]&#39;&#xA;[0, 1, 2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Lazily fold over inputs and output intermediate results:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ seq 1000 | jaq -n &#39;foreach inputs as $x (0; . + $x)&#39;&#xA;1 3 6 10 15 [...]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;The following evaluation consists of several benchmarks that allow comparing the performance of jaq, jq, and &lt;a href=&#34;https://github.com/itchyny/gojq&#34;&gt;gojq&lt;/a&gt;. The &lt;code&gt;empty&lt;/code&gt; benchmark runs &lt;code&gt;n&lt;/code&gt; times the filter &lt;code&gt;empty&lt;/code&gt; with null input, serving to measure the startup time. The &lt;code&gt;bf-fib&lt;/code&gt; benchmark runs a Brainfuck interpreter written in jq, interpreting a Brainfuck script that produces &lt;code&gt;n&lt;/code&gt; Fibonacci numbers. The other benchmarks evaluate various filters with &lt;code&gt;n&lt;/code&gt; as input; see &lt;a href=&#34;https://raw.githubusercontent.com/01mf02/jaq/main/bench.sh&#34;&gt;&lt;code&gt;bench.sh&lt;/code&gt;&lt;/a&gt; for details.&lt;/p&gt; &#xA;&lt;p&gt;I generated the benchmark data with &lt;code&gt;bench.sh target/release/jaq jq-1.7 gojq-0.12.13 jq-1.6 | tee bench.json&lt;/code&gt; on a Linux system with an AMD Ryzen 5 5500U.[^binaries] I then processed the results with a &#34;one-liner&#34; (stretching the term and the line a bit):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;jq -rs &#39;.[] | &#34;|`\(.name)`|\(.n)|&#34; + ([.time[] | min | (.*1000|round)? // &#34;N/A&#34;] | min as $total_min | map(if . == $total_min then &#34;**\(.)**&#34; else &#34;\(.)&#34; end) | join(&#34;|&#34;))&#39; bench.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;(Of course, you can also use jaq here instead of jq.) Finally, I concatenated the table header with the output and piped it through &lt;code&gt;pandoc -t gfm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;[^binaries]: The binaries for jq-1.7 and gojq-0.12.13 were retrieved from their GitHub release pages, the binary for jq-1.6 was installed from the standard Ubuntu repository.&lt;/p&gt; &#xA;&lt;p&gt;Table: Evaluation results in milliseconds (&#34;N/A&#34; if more than 10 seconds).&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Benchmark&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;n&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;jaq-1.2&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;jq-1.7&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;gojq-0.12.13&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;jq-1.6&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;512&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;650&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;790&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;740&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;8340&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bf-fib&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;13&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;410&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1280&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;820&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1420&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;60&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;680&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;310&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;630&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;140&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;530&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;600&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;670&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;group-by&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;420&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1850&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1680&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2830&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;min-max&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;220&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;320&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;290&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;310&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;add&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;480&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;650&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1540&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;750&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;kv&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;131072&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;160&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;150&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;250&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;200&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;kv-update&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;131072&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;190&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;530&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;570&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;kv-entries&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;131072&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;580&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1170&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;820&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1110&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ex-implode&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;460&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1110&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;740&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1080&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;740&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;880&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;N/A&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;850&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;try-catch&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1048576&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;180&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;330&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;480&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;650&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tree-flatten&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;17&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;650&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;360&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;480&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tree-update&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;17&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;450&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;980&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1850&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1180&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;tree-paths&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;17&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;450&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;380&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;920&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;470&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;to-fromjson&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;65536&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;40&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;370&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;100&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;380&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;ack&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;7&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;570&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;680&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1090&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;610&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;range-prop&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;128&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;&lt;strong&gt;260&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;310&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;320&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;580&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;The results show that jaq-1.2 is fastest on 16 benchmarks, whereas jq-1.7 is fastest on 2 benchmarks and gojq-0.12.13 is fastest on 1 benchmark. gojq is much faster on &lt;code&gt;tree-flatten&lt;/code&gt; because it implements the filter &lt;code&gt;flatten&lt;/code&gt; natively instead of by definition.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;p&gt;Here is an overview that summarises:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; features already implemented, and&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; features not yet implemented.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/01mf02/jaq/main/#contributing&#34;&gt;Contributions to extend jaq are highly welcome.&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Basics&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Identity (&lt;code&gt;.&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Recursion (&lt;code&gt;..&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Basic data types (null, boolean, number, string, array, object)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; if-then-else (&lt;code&gt;if .a &amp;lt; .b then .a else .b end&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Folding (&lt;code&gt;reduce .[] as $x (0; . + $x)&lt;/code&gt;, &lt;code&gt;foreach .[] as $x (0; . + $x; . + .)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Error handling (&lt;code&gt;try ... catch ...&lt;/code&gt;) (see the &lt;a href=&#34;https://raw.githubusercontent.com/01mf02/jaq/main/#error-handling&#34;&gt;differences from jq&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String interpolation (&lt;code&gt;&#34;The successor of \(.) is \(.+1).&#34;&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Format strings (&lt;code&gt;@json&lt;/code&gt;, &lt;code&gt;@text&lt;/code&gt;, &lt;code&gt;@csv&lt;/code&gt;, &lt;code&gt;@tsv&lt;/code&gt;, &lt;code&gt;@html&lt;/code&gt;, &lt;code&gt;@sh&lt;/code&gt;, &lt;code&gt;@base64&lt;/code&gt;, &lt;code&gt;@base64d&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Paths&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Indexing of arrays/objects (&lt;code&gt;.[0]&lt;/code&gt;, &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.[&#34;a&#34;]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Iterating over arrays/objects (&lt;code&gt;.[]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Optional indexing/iteration (&lt;code&gt;.a?&lt;/code&gt;, &lt;code&gt;.[]?&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Array slices (&lt;code&gt;.[3:7]&lt;/code&gt;, &lt;code&gt;.[0:-1]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String slices&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Operators&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Composition (&lt;code&gt;|&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Binding (&lt;code&gt;. as $x | $x&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Concatenation (&lt;code&gt;,&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Plain assignment (&lt;code&gt;=&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Update assignment (&lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Alternation (&lt;code&gt;//&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Logic (&lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Equality and comparison (&lt;code&gt;.a == .b&lt;/code&gt;, &lt;code&gt;.a &amp;lt; .b&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Negation (&lt;code&gt;-&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Error suppression (&lt;code&gt;?&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Definitions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Basic definitions (&lt;code&gt;def map(f): [.[] | f];&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Recursive definitions (&lt;code&gt;def r: r; r&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Core filters&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Empty (&lt;code&gt;empty&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Errors (&lt;code&gt;error&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Input (&lt;code&gt;inputs&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Length (&lt;code&gt;length&lt;/code&gt;, &lt;code&gt;utf8bytelength&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Rounding (&lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String &amp;lt;-&amp;gt; JSON (&lt;code&gt;fromjson&lt;/code&gt;, &lt;code&gt;tojson&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String &amp;lt;-&amp;gt; integers (&lt;code&gt;explode&lt;/code&gt;, &lt;code&gt;implode&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String normalisation (&lt;code&gt;ascii_downcase&lt;/code&gt;, &lt;code&gt;ascii_upcase&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String prefix/postfix (&lt;code&gt;startswith&lt;/code&gt;, &lt;code&gt;endswith&lt;/code&gt;, &lt;code&gt;ltrimstr&lt;/code&gt;, &lt;code&gt;rtrimstr&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; String splitting (&lt;code&gt;split(&#34;foo&#34;)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Array filters (&lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;sort_by(-.)&lt;/code&gt;, &lt;code&gt;group_by&lt;/code&gt;, &lt;code&gt;min_by&lt;/code&gt;, &lt;code&gt;max_by&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Stream consumers (&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Stream generators (&lt;code&gt;range&lt;/code&gt;, &lt;code&gt;recurse&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Time (&lt;code&gt;now&lt;/code&gt;, &lt;code&gt;fromdateiso8601&lt;/code&gt;, &lt;code&gt;todateiso8601&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; More numeric filters (&lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, ...) (&lt;a href=&#34;https://raw.githubusercontent.com/01mf02/jaq/main/#numeric-filters&#34;&gt;list of numeric filters&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; More time filters (&lt;code&gt;strptime&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;strflocaltime&lt;/code&gt;, &lt;code&gt;mktime&lt;/code&gt;, &lt;code&gt;gmtime&lt;/code&gt;, and &lt;code&gt;localtime&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Standard filters&lt;/h2&gt; &#xA;&lt;p&gt;These filters are defined via more basic filters. Their definitions are at &lt;a href=&#34;https://raw.githubusercontent.com/01mf02/jaq/main/jaq-std/src/std.jq&#34;&gt;&lt;code&gt;std.jq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Undefined (&lt;code&gt;null&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Booleans (&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Special numbers (&lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;infinite&lt;/code&gt;, &lt;code&gt;isnan&lt;/code&gt;, &lt;code&gt;isinfinite&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Type (&lt;code&gt;type&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Filtering (&lt;code&gt;select(. &amp;gt;= 0)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Selection (&lt;code&gt;values&lt;/code&gt;, &lt;code&gt;nulls&lt;/code&gt;, &lt;code&gt;booleans&lt;/code&gt;, &lt;code&gt;numbers&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, &lt;code&gt;arrays&lt;/code&gt;, &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;iterables&lt;/code&gt;, &lt;code&gt;scalars&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Conversion (&lt;code&gt;tostring&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Iterable filters (&lt;code&gt;map(.+1)&lt;/code&gt;, &lt;code&gt;map_values(.+1)&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;join(&#34;a&#34;)&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Array filters (&lt;code&gt;transpose&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;nth(10)&lt;/code&gt;, &lt;code&gt;flatten&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Object-array conversion (&lt;code&gt;to_entries&lt;/code&gt;, &lt;code&gt;from_entries&lt;/code&gt;, &lt;code&gt;with_entries&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Universal/existential (&lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Recursion (&lt;code&gt;walk&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; I/O (&lt;code&gt;input&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Regular expressions (&lt;code&gt;test&lt;/code&gt;, &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;capture&lt;/code&gt;, &lt;code&gt;splits&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;, &lt;code&gt;gsub&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Time (&lt;code&gt;fromdate&lt;/code&gt;, &lt;code&gt;todate&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Numeric filters&lt;/h2&gt; &#xA;&lt;p&gt;jaq imports many filters from &lt;a href=&#34;https://crates.io/crates/libm&#34;&gt;libm&lt;/a&gt; and follows their type signature.&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;Full list of numeric filters defined in jaq&lt;/summary&gt; &#xA; &lt;p&gt;Zero-argument filters:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;acos&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;acosh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;asin&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;asinh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;atan&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;atanh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;cbrt&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;cos&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;cosh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;erf&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;erfc&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;exp&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;exp10&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;exp2&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;expm1&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;fabs&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;frexp&lt;/code&gt;, which returns pairs of (float, integer).&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;ilogb&lt;/code&gt;, which returns integers.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;j0&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;j1&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;lgamma&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;log&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;log10&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;log1p&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;log2&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;logb&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;modf&lt;/code&gt;, which returns pairs of (float, float).&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;nearbyint&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;pow10&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;rint&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;significand&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;sin&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;sinh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;sqrt&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;tan&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;tanh&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;tgamma&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;trunc&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;y0&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;y1&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Two-argument filters that ignore &lt;code&gt;.&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;atan2&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;copysign&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;drem&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;fdim&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;fmax&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;fmin&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;fmod&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;hypot&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;jn&lt;/code&gt;, which takes an integer as first argument.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;ldexp&lt;/code&gt;, which takes an integer as second argument.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;nextafter&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;nexttoward&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;pow&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;remainder&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;scalb&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;scalbln&lt;/code&gt;, which takes as integer as second argument.&lt;/li&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;yn&lt;/code&gt;, which takes an integer as first argument.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Three-argument filters that ignore &lt;code&gt;.&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; &lt;code&gt;fma&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;Advanced features&lt;/h2&gt; &#xA;&lt;p&gt;jaq currently does &lt;em&gt;not&lt;/em&gt; aim to support several features of jq, such as:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Modules&lt;/li&gt; &#xA; &lt;li&gt;SQL-style operators&lt;/li&gt; &#xA; &lt;li&gt;Streaming&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Differences between jq and jaq&lt;/h1&gt; &#xA;&lt;h2&gt;Numbers&lt;/h2&gt; &#xA;&lt;p&gt;jq uses 64-bit floating-point numbers (floats) for any number. By contrast, jaq interprets numbers such as 0 or -42 as machine-sized integers and numbers such as 0.0 or 3e8 as 64-bit floats. Many operations in jaq, such as array indexing, check whether the passed numbers are indeed integer. The motivation behind this is to avoid rounding errors that may silently lead to wrong results. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ jq  -n &#39;[0, 1, 2] | .[1.0000000000000001]&#39;&#xA;1&#xA;$ jaq -n &#39;[0, 1, 2] | .[1.0000000000000001]&#39;&#xA;Error: cannot use 1.0 as integer&#xA;$ jaq -n &#39;[0, 1, 2] | .[1]&#39;&#xA;1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The rules of jaq are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The sum, difference, product, and remainder of two integers is integer.&lt;/li&gt; &#xA; &lt;li&gt;Any other operation between two numbers yields a float.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ jaq -n &#39;1 + 2&#39;&#xA;3&#xA;$ jaq -n &#39;10 / 2&#39;&#xA;5.0&#xA;$ jaq -n &#39;1.0 + 2&#39;&#xA;3.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can convert an integer to a floating-point number e.g. by adding 0.0, by multiplying with 1.0, or by dividing with 1. You can convert a floating-point number to an integer by &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, or &lt;code&gt;ceil&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ jaq -n &#39;1.2 | [floor, round, ceil]&#39;&#xA;[1, 1, 2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;NaN and infinity&lt;/h3&gt; &#xA;&lt;p&gt;In jq, division by 0 has some surprising properties; for example, &lt;code&gt;0 / 0&lt;/code&gt; yields &lt;code&gt;nan&lt;/code&gt;, whereas &lt;code&gt;0 as $n | $n / 0&lt;/code&gt; yields an error. In jaq, &lt;code&gt;n / 0&lt;/code&gt; yields &lt;code&gt;nan&lt;/code&gt; if &lt;code&gt;n == 0&lt;/code&gt;, &lt;code&gt;infinite&lt;/code&gt; if &lt;code&gt;n &amp;gt; 0&lt;/code&gt;, and &lt;code&gt;-infinite&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;. jaq&#39;s behaviour is closer to the IEEE standard for floating-point arithmetic (IEEE 754).&lt;/p&gt; &#xA;&lt;p&gt;jaq implements a total ordering on floating-point numbers to allow sorting values. Therefore, it unfortunately has to enforce that &lt;code&gt;nan == nan&lt;/code&gt;. (jq gets around this by enforcing &lt;code&gt;nan &amp;lt; nan&lt;/code&gt;, which breaks basic laws about total orders.)&lt;/p&gt; &#xA;&lt;p&gt;Like jq, jaq prints &lt;code&gt;nan&lt;/code&gt; and &lt;code&gt;infinite&lt;/code&gt; as &lt;code&gt;null&lt;/code&gt; in JSON, because JSON does not support encoding these values as numbers.&lt;/p&gt; &#xA;&lt;h3&gt;Preservation of fractional numbers&lt;/h3&gt; &#xA;&lt;p&gt;jaq preserves fractional numbers coming from JSON data perfectly (as long as they are not used in some arithmetic operation), whereas jq 1.6 may silently convert to 64-bit floating-point numbers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ echo &#39;1e500&#39; | jq &#39;.&#39;&#xA;1.7976931348623157e+308&#xA;$ echo &#39;1e500&#39; | jaq &#39;.&#39;&#xA;1e500&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Therefore, unlike jq 1.6, jaq satisfies the following paragraph in the &lt;a href=&#34;https://jqlang.github.io/jq/manual/v1.6/&#34;&gt;jq manual&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;An important point about the identity filter is that it guarantees to preserve the literal decimal representation of values. This is particularly important when dealing with numbers which can&#39;t be losslessly converted to an IEEE754 double precision representation.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Please note that newer versions of jq, e.g. 1.7, seem to preserve the literal decimal representation as well.&lt;/p&gt; &#xA;&lt;h2&gt;Assignments&lt;/h2&gt; &#xA;&lt;p&gt;Like jq, jaq allows for assignments of the form &lt;code&gt;p |= f&lt;/code&gt;. However, jaq interprets these assignments differently. Fortunately, in most cases, the result is the same.&lt;/p&gt; &#xA;&lt;p&gt;In jq, an assignment &lt;code&gt;p |= f&lt;/code&gt; first constructs paths to all values that match &lt;code&gt;p&lt;/code&gt;. &lt;em&gt;Only then&lt;/em&gt;, it applies the filter &lt;code&gt;f&lt;/code&gt; to these values.&lt;/p&gt; &#xA;&lt;p&gt;In jaq, an assignment &lt;code&gt;p |= f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; &lt;em&gt;immediately&lt;/em&gt; to any value matching &lt;code&gt;p&lt;/code&gt;. Unlike in jq, assignment does not explicitly construct paths.&lt;/p&gt; &#xA;&lt;p&gt;jaq&#39;s implementation of assignment likely yields higher performance, because it does not construct paths. Furthermore, this also prevents several bugs in jq &#34;by design&#34;. For example, given the filter &lt;code&gt;[0, 1, 2, 3] | .[] |= empty&lt;/code&gt;, jq yields &lt;code&gt;[1, 3]&lt;/code&gt;, whereas jaq yields &lt;code&gt;[]&lt;/code&gt;. What happens here?&lt;/p&gt; &#xA;&lt;p&gt;jq first constructs the paths corresponding to &lt;code&gt;.[]&lt;/code&gt;, which are &lt;code&gt;.0, .1, .2, .3&lt;/code&gt;. Then, it removes the element at each of these paths. However, each of these removals &lt;em&gt;changes&lt;/em&gt; the value that the remaining paths refer to. That is, after removing &lt;code&gt;.0&lt;/code&gt; (value 0), &lt;code&gt;.1&lt;/code&gt; does not refer to value 1, but value 2! That is also why value 1 (and in consequence also value 3) is not removed.&lt;/p&gt; &#xA;&lt;p&gt;There is more weirdness ahead in jq; for example, &lt;code&gt;0 | 0 |= .+1&lt;/code&gt; yields &lt;code&gt;1&lt;/code&gt; in jq, although &lt;code&gt;0&lt;/code&gt; is not a valid path expression. However, &lt;code&gt;1 | 0 |= .+1&lt;/code&gt; yields an error. In jaq, any such assignment yields an error.&lt;/p&gt; &#xA;&lt;p&gt;jaq attempts to use multiple outputs of the right-hand side, whereas jq uses only the first. For example, &lt;code&gt;0 | (., .) |= (., .+1)&lt;/code&gt; yields &lt;code&gt;0 1 1 2&lt;/code&gt; in jaq, whereas it yields only &lt;code&gt;0&lt;/code&gt; in jq. However, &lt;code&gt;{a: 1} | .a |= (2, 3)&lt;/code&gt; yields &lt;code&gt;{&#34;a&#34;: 2}&lt;/code&gt; in both jaq and jq, because an object can only associate a single value with any given key, so we cannot use multiple outputs in a meaningful way here.&lt;/p&gt; &#xA;&lt;p&gt;Because jaq does not construct paths, it does not allow some filters on the left-hand side of assignments, for example &lt;code&gt;first&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt;: For example, &lt;code&gt;[1, 2, 3] | first(.[]) |= .-1&lt;/code&gt; yields &lt;code&gt;[0, 2, 3]&lt;/code&gt; in jq, but is invalid in jaq. Similarly, &lt;code&gt;[1, 2, 3] | limit(2; .[]) |= .-1&lt;/code&gt; yields &lt;code&gt;[0, 1, 3]&lt;/code&gt; in jq, but is invalid in jaq. (Inconsequentially, jq also does not allow for &lt;code&gt;last&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;h2&gt;Definitions&lt;/h2&gt; &#xA;&lt;p&gt;Like jq, jaq allows for the definition of filters, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def map(f): [.[] | f];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Arguments can also be passed &lt;em&gt;by value&lt;/em&gt;, such as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def cartesian($f; $g): [$f, $g];&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Filter definitions can be nested and recursive, i.e. refer to themselves. That is, a filter such as &lt;code&gt;recurse&lt;/code&gt; can be defined in jaq:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def recurse(f): def r: ., (f | r); r;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since jaq 1.2, jaq optimises tail calls, like jq. Since jaq 1.1, recursive filters can also have non-variable arguments, like in jq. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;def f(a): a, f(1+a);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Recursive filters with non-variable arguments can yield surprising effects; for example, a call &lt;code&gt;f(0)&lt;/code&gt; builds up calls of the shape &lt;code&gt;f(1+(..(1+0)...))&lt;/code&gt;, which leads to exponential execution times.&lt;/p&gt; &#xA;&lt;p&gt;Recursive filters with non-variable arguments can very frequently be alternatively implemented by either:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A nested filter: for example, instead of &lt;code&gt;def walk(f): (.[]? |= walk(f)) | f;&lt;/code&gt;, you can use &lt;code&gt;def walk(f): def rec: (.[]? |= rec) | f; rec;&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A filter with variable arguments: for example, instead of &lt;code&gt;def f(a): a, f(1+a);&lt;/code&gt;, you can equally well write &lt;code&gt;def f($a): $a, f(1+$a);&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;A filter with &lt;code&gt;recurse&lt;/code&gt;: for example, you may write &lt;code&gt;def f(a): a | recurse(1+.);&lt;/code&gt;. If you expect your filter to recurse deeply, it is advised to implement it using &lt;code&gt;recurse&lt;/code&gt;, because jaq has an optimised implementation of &lt;code&gt;recurse&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;All of these options are supported by jaq.&lt;/p&gt; &#xA;&lt;h2&gt;Arguments&lt;/h2&gt; &#xA;&lt;p&gt;Like jq, jaq allows to define arguments via the command line, in particular by the options &lt;code&gt;--arg&lt;/code&gt;, &lt;code&gt;--rawfile&lt;/code&gt;, &lt;code&gt;--slurpfile&lt;/code&gt;. This binds variables to values, and for every variable &lt;code&gt;$x&lt;/code&gt; bound to &lt;code&gt;v&lt;/code&gt; this way, &lt;code&gt;$ARGS.named&lt;/code&gt; contains an entry with key &lt;code&gt;x&lt;/code&gt; and value &lt;code&gt;v&lt;/code&gt;. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ jaq -n --arg x 1 --arg y 2 &#39;$x, $y, $ARGS.named&#39;&#xA;&#34;1&#34;&#xA;&#34;2&#34;&#xA;{&#xA;  &#34;x&#34;: &#34;1&#34;,&#xA;  &#34;y&#34;: &#34;2&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Folding&lt;/h2&gt; &#xA;&lt;p&gt;jq and jaq provide filters &lt;code&gt;reduce xs as $x (init; f)&lt;/code&gt; and &lt;code&gt;foreach xs as $x (init; f)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;In jaq, the output of these filters is defined very simply: Assuming that &lt;code&gt;xs&lt;/code&gt; evaluates to &lt;code&gt;x0&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;, ..., &lt;code&gt;xn&lt;/code&gt;, &lt;code&gt;reduce xs as $x (init; f)&lt;/code&gt; evaluates to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;init&#xA;| x0 as $x | f&#xA;| ...&#xA;| xn as $x | f&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and &lt;code&gt;foreach xs as $x (init; f)&lt;/code&gt; evaluates to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;init&#xA;| x0 as $x | f | (.,&#xA;| ...&#xA;| xn as $x | f | (.,&#xA;empty)...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Additionally, jaq provides the filter &lt;code&gt;for xs as $x (init; f)&lt;/code&gt; that evaluates to&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;init&#xA;| ., (x0 as $x | f&#xA;| ...&#xA;| ., (xn as $x | f&#xA;)...)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The difference between &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; is that &lt;code&gt;for&lt;/code&gt; yields the output of &lt;code&gt;init&lt;/code&gt;, whereas &lt;code&gt;foreach&lt;/code&gt; omits it. For example, &lt;code&gt;foreach (1, 2, 3) as $x (0; .+$x)&lt;/code&gt; yields &lt;code&gt;1, 3, 6&lt;/code&gt;, whereas &lt;code&gt;for (1, 2, 3) as $x (0; .+$x)&lt;/code&gt; yields &lt;code&gt;0, 1, 3, 6&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The interpretation of &lt;code&gt;reduce&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt; in jaq has the following advantages over jq:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;It deals very naturally with filters that yield multiple outputs. In contrast, jq discriminates outputs of &lt;code&gt;f&lt;/code&gt;, because it recurses only on the last of them, although it outputs all of them. &#xA;  &lt;details&gt;&#xA;   &lt;summary&gt;Example&lt;/summary&gt; `foreach (5, 10) as $x (1; .+$x, -.)` yields `6, -1, 9, 1` in jq, whereas it yields `6, 16, -6, -1, 9, 1` in jaq. We can see that both jq and jaq yield the values `6` and `-1` resulting from the first iteration (where `$x` is 5), namely `1 | 5 as $x | (.+$x, -.)`. However, jq performs the second iteration (where `$x` is 10) *only on the last value* returned from the first iteration, namely `-1`, yielding the values `9` and `1` resulting from `-1 | 10 as $x | (.+$x, -.)`. jaq yields these values too, but it also performs the second iteration on all other values returned from the first iteration, namely `6`, yielding the values `16` and `-6` that result from ` 6 | 10 as $x | (.+$x, -.)`. &#xA;  &lt;/details&gt; &lt;/li&gt; &#xA; &lt;li&gt;It makes the implementation of &lt;code&gt;reduce&lt;/code&gt; and &lt;code&gt;foreach&lt;/code&gt; special cases of the same code, reducing the potential for bugs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Compared to &lt;code&gt;foreach ...&lt;/code&gt;, the filter &lt;code&gt;for ...&lt;/code&gt; (where &lt;code&gt;...&lt;/code&gt; refers to &lt;code&gt;xs as $x (init; f)&lt;/code&gt;) has a stronger relationship with &lt;code&gt;reduce&lt;/code&gt;. In particular, the values yielded by &lt;code&gt;reduce ...&lt;/code&gt; are a subset of the values yielded by &lt;code&gt;for ...&lt;/code&gt;. This does not hold if you replace &lt;code&gt;for&lt;/code&gt; by &lt;code&gt;foreach&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;details&gt;&#xA;  As an example, if we set `...` to `empty as $x (0; .+$x)`, then `foreach ...` yields no value, whereas `for ...` and `reduce ...` yield `0`. &#xA;&lt;/details&gt; &#xA;&lt;p&gt;Furthermore, jq provides the filter &lt;code&gt;foreach xs as $x (init; f; proj)&lt;/code&gt; (&lt;code&gt;foreach/3&lt;/code&gt;) and interprets &lt;code&gt;foreach xs as $x (init; f)&lt;/code&gt; (&lt;code&gt;foreach/2&lt;/code&gt;) as &lt;code&gt;foreach xs as $x (init; f; .)&lt;/code&gt;, whereas jaq does &lt;em&gt;not&lt;/em&gt; provide &lt;code&gt;foreach/3&lt;/code&gt; because it requires completely separate logic from &lt;code&gt;foreach/2&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; in both the parser and the interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;Error handling&lt;/h2&gt; &#xA;&lt;p&gt;In jq, the &lt;code&gt;try f catch g&lt;/code&gt; expression breaks out of the &lt;code&gt;f&lt;/code&gt; stream as soon as an error occurs, ceding control to &lt;code&gt;g&lt;/code&gt; after that. This is mentioned in its manual as a possible mechanism for breaking out of loops (&lt;a href=&#34;https://jqlang.github.io/jq/manual/#breaking-out-of-control-structures&#34;&gt;here&lt;/a&gt;). jaq however doesn&#39;t interrupt the &lt;code&gt;f&lt;/code&gt; stream, but instead sends &lt;em&gt;each&lt;/em&gt; error value emitted to the &lt;code&gt;g&lt;/code&gt; filter; the result is a stream of values emitted from &lt;code&gt;f&lt;/code&gt; with values emitted from &lt;code&gt;g&lt;/code&gt; interspersed where errors occurred.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following example: this expression is &lt;code&gt;true&lt;/code&gt; in jq, because the first &lt;code&gt;error(2)&lt;/code&gt; interrupts the stream:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jq&#34;&gt;[try (1, error(2), 3, error(4)) catch .] == [1, 2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In jaq however, this holds:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jq&#34;&gt;[try (1, error(2), 3, error(4)) catch .] == [1, 2, 3, 4]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Miscellaneous&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Slurping: When files are slurped in (via the &lt;code&gt;-s&lt;/code&gt; / &lt;code&gt;--slurp&lt;/code&gt; option), jq combines the inputs of all files into one single array, whereas jaq yields an array for every file. The behaviour of jq can be approximated in jaq; for example, to achieve the output of &lt;code&gt;jq -s . a b&lt;/code&gt;, you may use &lt;code&gt;jaq -s . &amp;lt;(cat a b)&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Cartesian products: In jq, &lt;code&gt;[(1,2) * (3,4)]&lt;/code&gt; yields &lt;code&gt;[3, 6, 4, 8]&lt;/code&gt;, whereas &lt;code&gt;[{a: (1,2), b: (3,4)} | .a * .b]&lt;/code&gt; yields &lt;code&gt;[3, 4, 6, 8]&lt;/code&gt;. jaq yields &lt;code&gt;[3, 4, 6, 8]&lt;/code&gt; in both cases.&lt;/li&gt; &#xA; &lt;li&gt;List updating: In jq, &lt;code&gt;[0, 1] | .[3] = 3&lt;/code&gt; yields &lt;code&gt;[0, 1, null, 3]&lt;/code&gt;; that is, jq fills up the list with &lt;code&gt;null&lt;/code&gt;s if we update beyond its size. In contrast, jaq fails with an out-of-bounds error in such a case.&lt;/li&gt; &#xA; &lt;li&gt;Input reading: When there is no more input value left, in jq, &lt;code&gt;input&lt;/code&gt; yields an error, whereas in jaq, it yields no output value.&lt;/li&gt; &#xA; &lt;li&gt;Joining: When given an array &lt;code&gt;[x0, x1, ..., xn]&lt;/code&gt;, in jq, &lt;code&gt;join(x)&lt;/code&gt; converts all elements of the input array to strings and intersperses them with &lt;code&gt;x&lt;/code&gt;, whereas in jaq, &lt;code&gt;join(x)&lt;/code&gt; simply calculates &lt;code&gt;x0 + x + x1 + x + ... + xn&lt;/code&gt;. When all elements of the input array and &lt;code&gt;x&lt;/code&gt; are strings, jq and jaq yield the same output.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Contributing&lt;/h1&gt; &#xA;&lt;p&gt;Contributions to jaq are welcome. Please make sure that after your change, &lt;code&gt;cargo test&lt;/code&gt; runs successfully.&lt;/p&gt; &#xA;&lt;h1&gt;Acknowledgements&lt;/h1&gt; &#xA;&lt;p&gt;jaq has profited tremendously from:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/serde_json/&#34;&gt;serde_json&lt;/a&gt; to read and &lt;a href=&#34;https://docs.rs/colored_json/&#34;&gt;colored_json&lt;/a&gt; to output JSON,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/chumsky/&#34;&gt;chumsky&lt;/a&gt; to parse and &lt;a href=&#34;https://docs.rs/ariadne/&#34;&gt;ariadne&lt;/a&gt; to pretty-print parse errors,&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/mimalloc/&#34;&gt;mimalloc&lt;/a&gt; to boost the performance of memory allocation, and&lt;/li&gt; &#xA; &lt;li&gt;the Rust standard library, in particular its awesome &lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;Iterator&lt;/a&gt;, which builds the rock-solid base of jaq&#39;s filter execution&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>google-research/deduplicate-text-datasets</title>
    <updated>2023-12-02T01:39:43Z</updated>
    <id>tag:github.com,2023-12-02:/google-research/deduplicate-text-datasets</id>
    <link href="https://github.com/google-research/deduplicate-text-datasets" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Deduplicating Training Data Makes Language Models Better&lt;/h1&gt; &#xA;&lt;p&gt;This repository contains code to deduplicate language model datasets as descrbed in the paper &lt;a href=&#34;https://arxiv.org/abs/2107.06499&#34;&gt;&#34;Deduplicating Training Data Makes Language Models Better&#34;&lt;/a&gt; by Katherine Lee, Daphne Ippolito, Andrew Nystrom, Chiyuan Zhang, Douglas Eck, Chris Callison-Burch and Nicholas Carlini. We release the ExactSubstr deduplication implementation (written in Rust) along with the scripts we used in the paper to perform ExactSubstr deduplication and inspect the results (written in Python). We also release the document clusters resulting from running NearDup deduplication on C4, RealNews, LM1B, and Wiki-4B-en.&lt;/p&gt; &#xA;&lt;p&gt;This is not an officially supported Google product.&lt;/p&gt; &#xA;&lt;h2&gt;Why deduplicate?&lt;/h2&gt; &#xA;&lt;p&gt;When datasets are created by scraping raw text from the Internet, this will often result in the same sequences being repeated multiple times (e.g., we find a single 50 word sequence that is repeated in the C4 dataset 60,000 times). Training models on deduplicated datasets is faster (because they see fewer total examples) and experimentally results in models with similar or better perplexity to models trained on data that hasn&#39;t been deduplicated. Moreover, language models are less likely to exhibit memorization when their training data has been well-deduplicated.&lt;/p&gt; &#xA;&lt;h2&gt;Citing this work&lt;/h2&gt; &#xA;&lt;p&gt;If you use this repository or our deduplicated datasets you can cite&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;@inproceedings{lee2021deduplicating,&#xA;      title={Deduplicating Training Data Makes Language Models Better}, &#xA;      author={Katherine Lee and Daphne Ippolito and Andrew Nystrom and Chiyuan Zhang and Douglas Eck and Chris Callison-Burch and Nicholas Carlini},&#xA;    booktitle = &#34;Proceedings of the 60th Annual Meeting of the Association for Computational Linguistics&#34;,&#xA;    year = &#34;2022&#34;,&#xA;    publisher = &#34;Association for Computational Linguistics&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Exact Deduplication Code&lt;/h1&gt; &#xA;&lt;p&gt;We provide an implementation of the exact deduplication technique used in the paper. This is very much research code: it works well for what we designed it to do, and deduplicate text datasets, but it might not directly do what you want it to do. We did clean it up fairly significantly for a Version 1.0.0 release (see below for release history). If you want to deduplicate small (&amp;lt;10GB) datasets, it should work on any modern machine with ~16GB of RAM and a few CPU cores. As always, bigger machines are better. If you want to deduplicate something the size of C4 (~300GB) you will want a machine with as many cores as you can get (we used 96 cores) and &amp;gt;600GB of RAM. You will also need &amp;gt;1TB hard drive space. If your machine is big enough, there should be no upper bound on the size of the dataset it can handle (well, 2^64-1 bytes is the limit, but I think we can all agree that&#39;s essentially unlimited).&lt;/p&gt; &#xA;&lt;p&gt;We build a suffix array (based on &lt;a href=&#34;https://github.com/BurntSushi/suffix/&#34;&gt;Andrew Gallant&#39;s suffix array implementation&lt;/a&gt;) in &lt;a href=&#34;https://raw.githubusercontent.com/google-research/deduplicate-text-datasets/master/src/table.rs&#34;&gt;src/table.rs&lt;/a&gt;. It has some minor changes from the original version that make it so we can&#39;t just import this library as a crate. First, we need 64-bit integers. The original implementation says that u32 works for &#34;reasonably sized documents (~4GB)&#34; but we&#39;re working with unreasonably sized documents. So we need u64. Second, we don&#39;t want UTF8 strings. Everything is a [u8] byte array, because we might be working over token sequences which aren&#39;t valid UTF8. The main complication in the rest of &lt;a href=&#34;https://raw.githubusercontent.com/google-research/deduplicate-text-datasets/master/src/main.rs&#34;&gt;src/main.rs&lt;/a&gt; is the fact that we want things to run in parallel, and we probably can&#39;t fit the entire suffix array into memory. And so all of our algorithms are designed around these constraints.&lt;/p&gt; &#xA;&lt;h2&gt;Installing&lt;/h2&gt; &#xA;&lt;p&gt;To run the rust deduplicator you will need to install Rust:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;You&#39;ll also need a C compiler, &lt;code&gt;sudo apt-get install gcc&lt;/code&gt; will do that if you don&#39;t already.&lt;/p&gt; &#xA;&lt;p&gt;If you additionally want to generate datasets to run the rust script on (and you probably do, at least to follow this demo) then you will need python dependencies:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;pip3 install numpy scipy tensorflow tensorflow_datasets transformers sentencepiece&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Basic Usage&lt;/h2&gt; &#xA;&lt;p&gt;This section walks through the code for getting started using it. Later we&#39;ll cover how to actually deduplicate a dataset, for now we&#39;ll just walk through the basics for how it works.&lt;/p&gt; &#xA;&lt;p&gt;Start by running&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo build&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;to compile the rust code, and then run&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;python3 scripts/load_dataset.py --data_dir $LOAD_DIR --save_dir $SAVE_DIR --name $DATASET --split $SPLIT [--tokenize]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example, to get the Wik40B test set (you should do this, to walk through the demo) run&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;python3 scripts/load_dataset.py --data_dir ~/tensorflow_datasets --save_dir data --name wiki40b --split test&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This should will take just a minute or so to run on the test set.&lt;/p&gt; &#xA;&lt;p&gt;If the dataset is really big, you might want to add the &lt;code&gt;--tokenize&lt;/code&gt; flag. This will shrink the dataset by roughly a factor of two by tokenizing it with the GPT-2 tokenizer.&lt;/p&gt; &#xA;&lt;p&gt;This will create a file that&#39;s called &lt;code&gt;data/wiki40b.test&lt;/code&gt; and &lt;code&gt;data/wiki40b.test.size&lt;/code&gt;. The first file contains the entire Wiki40B test set smashed together, and the second file has the byte offset of where each individual training example begins, in sorted order.&lt;/p&gt; &#xA;&lt;p&gt;From here we can now build a suffix array of this entire dataset that&#39;s now in a single file.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;python3 scripts/make_suffix_array.py [path/to/dataset]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;For example, if you run (you should do this to follow along!) &lt;code&gt;python3 scripts/make_suffix_array.py data/wiki40b.test&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will create a file &lt;code&gt;data/wiki40b.test.table.bin&lt;/code&gt; containing the suffix array. Again, this should be fast. The test set should process in about a minute.&lt;/p&gt; &#xA;&lt;p&gt;(When running on larger files, if you get an error that you have too many open files, that&#39;s because this script opens lots of files. You should run &lt;code&gt;ulimit -Sn 1000000&lt;/code&gt; to &#34;fix&#34; the error. You might want to do this preemptively before hitting this crash after hour ten of the job.)&lt;/p&gt; &#xA;&lt;h3&gt;Querying a suffix array to find duplicated examples&lt;/h3&gt; &#xA;&lt;p&gt;We&#39;re not yet going to deduplicate a dataset. To start, let&#39;s just see how to count how often a particular example has been repeated. To do this, run&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;python3 scripts/count_occurrences.py --suffix [path/to/dataset] [--query query_string] [--query_file /path/to/query]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This should be very fast. Even when you run on a dataset that&#39;s 100s of gigabytes, it should take a few seconds, most of which is dominated by Python starting up. The actual core lookup just requires O(log(dataset_size)) time, which often is on the order of ~miliseconds.&lt;/p&gt; &#xA;&lt;p&gt;On the LM1B test set, running &lt;code&gt;python3 scripts/count_occurrences.py --suffix data/wiki40b.test --query &#34; on Tuesday&#34;&lt;/code&gt; should return 289. If you tokenized the dataset, then you should pass &lt;code&gt;--tokenize&lt;/code&gt; to &lt;code&gt;count_occurrences.py&lt;/code&gt; as well, to get the same result (plus or minus tokenization differences).&lt;/p&gt; &#xA;&lt;p&gt;If you want to confirm this the outputted number is correct (assuming you haven&#39;t tokenized), you can run &lt;code&gt;cat data/wiki40b.test | grep -ao &#34; on Tuesday&#34; | wc -l&lt;/code&gt; and get the same result (slower).&lt;/p&gt; &#xA;&lt;h2&gt;Deduplicating a Dataset&lt;/h2&gt; &#xA;&lt;p&gt;Now let&#39;s explain how to deduplicate a dataset as we do in the paper. As a running example we&#39;ll continue with the LM1b test set.&lt;/p&gt; &#xA;&lt;h3&gt;Finding all repeated substrings within a document&lt;/h3&gt; &#xA;&lt;p&gt;The first step in deduplicating a dataset is identifying all substrings of a given length that are repeated more than some threshold number of times. To do this we run the &lt;code&gt;self-similar&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo run self-similar --data-file data/wiki40b.test --length-threshold 100 --cache-dir /tmp/cache --num-threads 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For larger datasets, you may want to replace num-threads with as many cores as you have on your machine. It parallelizes perfectly, so there&#39;s no reason not to. For now though, keep it at 8 just for the sake of keeping things on track with this guide.&lt;/p&gt; &#xA;&lt;p&gt;The output of this should be the string&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Duplicates found: 3374227&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This means that the deduplicator found 3,374,227 sequences of length 100 that existed somewhere else in the dataset. The length threshold here is entirely dataset-dependent. In our paper, we used 50 tokens (which is 100 bytes---so remember that if you pass --tokenize you&#39;ll need to double the number of bytes for the length threshold).&lt;/p&gt; &#xA;&lt;p&gt;At this point the deduplicator will have dumped a bunch of files to a cache directory. There are two kinds of files here&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;/cache/dups_$DATASET_A-B&lt;/li&gt; &#xA; &lt;li&gt;/cache/sizes_$DATASET_A-B&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Each &lt;code&gt;dups&lt;/code&gt; file is a list of pointers into the dataset that corresponds to sequences repeated multiple times. Each file has the duplicates that correspond to items A through B in the suffix array. There should be 28,464 total entries when added up across all of these files. The duplicates are all clustered together, so all duplicates of the same string should appear sequentially.&lt;/p&gt; &#xA;&lt;p&gt;Each &lt;code&gt;sizes&lt;/code&gt; file says how large the cluster sizes are. This is typically a small number.&lt;/p&gt; &#xA;&lt;p&gt;All pointers are the same size, but the size of the pointers depends on the size of the dataset. We use the smallest pointer size that could address the entire dataset. For the LM1B test set, this is a 32-bit pointer. For the training set it would be a 40-bit pointer. For larger documents it might be 48 bits. This helps save memory on disk.&lt;/p&gt; &#xA;&lt;p&gt;The above explanation might be confusing. Let&#39;s see an example. Let&#39;s fine the first duplicate in the dataset:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ xxd /tmp/cache/sizes_wiki40b.test_0-64596445 | head -n 1 &#xA;00000000: 0200 0000 0200 0000 0200 0000 0200 0000  ................&#xA;$ xxd /tmp/cache/dups_wiki40b.test_0-64596445 | head -n 1 &#xA;00000000: daa4 ae05 8c7a 8505 c7a4 ae05 797a 8505  .....z......yz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Recall these pointers are 32-bit pointers. You can determine this by checking the ratio in size between /tmp/data/lm1b.test and /tmp/data/lm1b.test.table.bin. So this says that the first cluster of duplicates is of size 2, and starts at location 0x05aea4da in the data file, with the second occurrence at location 0x05857a8c. To confirm this, you can run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ python3&#xA;&amp;gt;&amp;gt;&amp;gt; open(&#34;data/wiki40b.test&#34;,&#34;rb&#34;).read()[0x05aea4da:0x05aea4da+100]&#xA;b&#39;\n        \n          t\n          \n            0\n          \n        \n        ,\n        \n          t\n  &#39;&#xA;&amp;gt;&amp;gt;&amp;gt; open(&#34;data/wiki40b.test&#34;,&#34;rb&#34;).read()[0x05857a8c:0x05857a8c+100]&#xA;b&#39;\n        \n          t\n          \n            0\n          \n        \n        ,\n        \n          t\n  &#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And we&#39;ve confirmed that this example is correctly identified twice in the dataset. This is a fairly boring and benign duplicate, but it&#39;s definitely correct. (Exercise for the reader: how would you count how many times this string is repeated in the dataset? It should be twice. Can you check that?)&lt;/p&gt; &#xA;&lt;h3&gt;Collecting the duplicates together&lt;/h3&gt; &#xA;&lt;p&gt;The next step is to take all of the length-100 sequences we&#39;ve found and collect them together to figure out what we should be removing from our dataset. To see why this is necessary, imagine that we have a length-200 sequence that&#39;s repeated more than once. The current data we have would tag this sequence as being a duplicate 99 times---once for each initial byte where a match occurs.&lt;/p&gt; &#xA;&lt;p&gt;This step reduces that down to just find ranges of bytes [a,b) which are duplicated more than once. To do this, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo run collect --data-file data/wiki40b.test --cache-dir /tmp/cache --length-threshold 100 &amp;gt; /tmp/wiki40b.test.remove.byterange&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The output here will be a long list of byte pair ranges&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;out&#xA;41887 41999&#xA;42347 42479&#xA;42507 42715&#xA;42741 42931&#xA;43101 43315&#xA;43891 43993&#xA;44021 44220&#xA;44366 44604&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What this means is that the substring in the dataset from byte 41887 to byte 41999 is repeated more than once and should be removed, as should the data from bytes 42347 to 42479 and so on. Let&#39;s check this.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ python3&#xA;&amp;gt;&amp;gt;&amp;gt; data=open(&#34;data/wiki40b.test&#34;,&#34;rb&#34;).read()&#xA;&amp;gt;&amp;gt;&amp;gt; data[41887:41999]&#xA;b&#39;8\xc2\xa0km\xc2\xb2), all of it land.\n_START_SECTION_\n2010 census\n_START_PARAGRAPH_\nAs of the census of 2010, there were 2,5&#39;&#xA;&amp;gt;&amp;gt;&amp;gt; data.count(data[41887:41999])&#xA;1 ## WHAT??? See below&#xA;&amp;gt;&amp;gt;&amp;gt; data[42347:42479]&#xA;b&#39;% from other races, and 0.9% from two or more races. Hispanic or Latino of any race were 2.5% of the population._NEWLINE_There were &#39;&#xA;&amp;gt;&amp;gt;&amp;gt; data.count(data[42347:42479])&#xA;2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Okay so what&#39;s going on here? The first of these look like it&#39;s repeated just once (but the second looks correct). Well if you actually check what we&#39;re saying here is the following: every byte contained in the range 41887 to 41999 is a member of at least one length-100 duplicate match. So while the whole sequence isn&#39;t repeated, the sub-sequences are. So for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; data.count(data[41887:41887+100])&#xA;9&#xA;&amp;gt;&amp;gt;&amp;gt; data.count(data[41999-100:41999])&#xA;2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In our paper we suggest just taking all of these duplicate sequences that have been identified and completely striking them from the dataset. This somewhat breaks the flow of text, for example if previously had an example &#34;Alice wanted to go to the store&#34; and we deduplicated at the level of 10 characters, we might completely strike &#34; to go to the &#34; and be left with &#34;Alice wantedstore&#34;. In practice we have found this doesn&#39;t break the language model because we remove relatively little text, and so these breaks don&#39;t cause harm.&lt;/p&gt; &#xA;&lt;p&gt;How exactly how you write out a dataset that&#39;s been deduplicated depends on the format the dataset started as. If you&#39;re just running this on wiki40b, we&#39;ve provided a script to do this conversion for you which will output another valid TensorFlow Dataset directory. But if you&#39;re using some other dataset, this is the part you&#39;ll have to take over and write the rest.&lt;/p&gt; &#xA;&lt;p&gt;To run the wiki40b script, you can just run this command&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 scripts/finish_dedup_wiki40b.py --data_dir ~/tensorflow_datasets/ --save_dir /tmp/tfds_wiki40b --name wiki40b --split test --suffixarray_dir data --remove /tmp/wiki40b.test.remove.byterange&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will create a new directory called &lt;code&gt;/tmp/tfds_wiki40b_dedup&lt;/code&gt;, and will take a few minutes to process completely.&lt;/p&gt; &#xA;&lt;p&gt;You can verify the deduplication has succeeded by then re-running the pipeline using the resulting output. Instead of finding 3,374,227 duplicate sequences during the deduplication phase, it should instead find 374. Importantly, you can check that these 374 duplicates are not errors of the pipeline: they are new sequences that are now duplicated when previously they were not. You can check this by running &lt;code&gt;count-occurrences&lt;/code&gt; in the original dataset for the sequences that (now) have two occurrences.&lt;/p&gt; &#xA;&lt;p&gt;To do this, just re-run everything top-down:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;python3 scripts/load_dataset.py --data_dir /tmp/tfds_wiki40b_dedup --save_dir data_dedup --name wiki40b --split test&#xA;python3 scripts/make_suffix_array.py data_dedup/wiki40b.test&#xA;cargo run self-similar --data-file data/wiki40b.test --length-threshold 100 --cache-dir /tmp/cache --num-threads 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and observe the output&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Duplicates found: 374&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Why do we get new duplicates? Consider the following example where we&#39;re going to remove all sequences of 4 characters that repeat twice: &lt;code&gt;e a b c d f g h . e f a b c d g h&lt;/code&gt;. Initially the sequence &lt;code&gt;a b c d&lt;/code&gt; is repeated twice. So we remove them both, and are now left with the file &lt;code&gt;e f g h . e f g h&lt;/code&gt;. This file still has duplicates! It&#39;s not that the first run failed, it&#39;s that in doing the first deduplication, we ended up with more (new) duplicates.&lt;/p&gt; &#xA;&lt;p&gt;To generate the result of our paper, we ran the deduplicator twice. This often cuts the number of duplicates down by over 100,000x, which in practice means to ~zero for normal datasets or ~a few hundred for massive 100GB+ datasets.&lt;/p&gt; &#xA;&lt;h2&gt;A full end-to-end dataset deduplication example&lt;/h2&gt; &#xA;&lt;p&gt;Okay so maybe you don&#39;t like reading. You skipped the entire section above. (Honestly I don&#39;t blame you.) You just want it to run. Then just do this&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bash scripts/run_pipeline.sh&#xA;python3 scripts/finish_dedup_wiki40b.py --data_dir ~/tensorflow_datasets/ --save_dir /tmp/dedup --name wiki40b --split test --suffixarray_dir data --remove /tmp/wiki40b.test.remove.byterange&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will run the entire deduplication pipeline top-to-bottom, starting with loading the wiki40b test set, then creating a suffix array, finding all repeated sequences, merging them together to sequence ranges, and finally spitting out a deduplicated TF Dataset that you can use exactly as normal.&lt;/p&gt; &#xA;&lt;p&gt;Note that this finish script is often the slowest part of the pipeline, depsite doing the least work. I&#39;m sure this is something that could be parallelized or made faster, but it&#39;s not an algorithms problem, it&#39;s an engineering problem. And that&#39;s not particularly fun. If you want to do this and submit a PR we&#39;d gladly take it.&lt;/p&gt; &#xA;&lt;h2&gt;A full end-to-end single file deduplication example&lt;/h2&gt; &#xA;&lt;p&gt;If you have a large single file and want to remove all length-N duplicates from within that file, we also provide the helper script here&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bash scripts/deduplicate_single_file.sh [path/to/source] [path/to/destination] [dup_length_threshold] [num_cores]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Advanced Usage&lt;/h2&gt; &#xA;&lt;p&gt;The above scripts work by calling into the core Rust suffix array deduplicator. If you want to do each step yourself, the following options are available:&lt;/p&gt; &#xA;&lt;h3&gt;Single threaded suffix array construction&lt;/h3&gt; &#xA;&lt;p&gt;To build a suffix array for any particular file, you can run&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run make --data-file [file_path]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will create a file called &lt;code&gt;[file_path].table.bin&lt;/code&gt; which contains the suffix array for the file provided. This algorithm is linear time, but (a) only runs on a single core, and (b) has memory requirement &lt;code&gt;O(big * len(file))&lt;/code&gt; which is prohibitive for large files.&lt;/p&gt; &#xA;&lt;h3&gt;Parallel suffix array construction&lt;/h3&gt; &#xA;&lt;p&gt;To build a suffix array for an extremely large file (e.g., ~about as much RAM as available) it is better to run the script&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;python scripts/make_suffix_array.py [file_path]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This script will build the suffix array in parallel by splitting the single file into chunks, generating suffix arrays for each chunk, and then merging the suffix arrays together to form the full suffix array. Note that in general this algorithm is quadratic, but when the maximum substring length is short relative to the total file length (as it is, when generating suffix arrays for N independent training examples) it will never reach this worst case behavior.&lt;/p&gt; &#xA;&lt;p&gt;The two steps are described below.&lt;/p&gt; &#xA;&lt;h4&gt;Building a piece of a suffix array from a piece of a file&lt;/h4&gt; &#xA;&lt;p&gt;The first generates a suffix array from a piece of a file. This is implemented by running&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run make_part --data-file [file_path] --start_byte [byte_offset] --end_byte [byte_offset]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;And builds a suffix array for the byte sequence between [byte_start] and [byte_end] for the given file. Multiple of these can be run in parallel to build a suffix array for a file quickly.&lt;/p&gt; &#xA;&lt;h4&gt;Merging suffix array pieces to create a single suffix array&lt;/h4&gt; &#xA;&lt;p&gt;Given the several independent suffix arrays, merging them is now just a matter of calling&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run merge --suffix-path [path_to_partial_suffix_tree] [--suffix-path [another_path_to_partial] ...] -- output-file [tmp_output_directory] --num-threads [number-of-machine-cores]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;to generate a collection of ordered suffix arrays pieces in the output directory. The final step just requires merging these together&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cat [tmp_output_directory]/* &amp;gt; [file_path].table.bin&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Finding Duplicates&lt;/h3&gt; &#xA;&lt;p&gt;Given a suffix array file, as generated in the previous section, it can now be queried for interesting statistics. The simplest operation, counting occurrences of particular substrings, takes O(log(N)) time and O(query_length) memory requirements, (as shown above with &lt;code&gt;scripts/count_occurrences.py&lt;/code&gt;). To do this you can run:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run count-occurrences --data-file /path/to/dataset --query-file /path/to/query_file&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;(Indeed, the python script is just a wrapper that makes calling this nicer, with the option for tokenization.) This is useful mainly as a commandline interface to interact with the dataset to find interesting properties. To run more sophisticated analysis, use the tools described below:&lt;/p&gt; &#xA;&lt;h4&gt;Finding duplicates between two different documents&lt;/h4&gt; &#xA;&lt;p&gt;Given a document A and another document B, we can find all duplicates between the two by (1) constructing suffix arrays for both, and then (2) linearly walking the suffix arrays in order to find all duplicates of a given length.&lt;/p&gt; &#xA;&lt;p&gt;Once the suffix array for the dataset has been constructed, this algorithm therefore requires time O(len(dataset) + len(query)) and space O(len(dataset)). It is better to run this algorithm when the number of queries into the dataset is greater than O(len(dataset)/log(len(query))). However note that the prior code requires &lt;em&gt;disk seeks&lt;/em&gt; and and this implementation is a linear scan through the suffix array table, so in practice there is at least a factor-of-10 speedup here. As a rough order of magnitude, for a dataset with ~100GB, it is faster to run &lt;code&gt;across-similar&lt;/code&gt; (described below) when querying with more than a few megabytes of text. Otherwise it is probably faster to run &lt;code&gt;count_occurances&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Notice that this command also requires that the entire dataset fits in memory. For many datasets this is not a problem, but the C4 dataset is 350 GB and the Pile dataset is 750 GB (both even after tokenization). The machine must therefore have a lot of RAM for this to work.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run across-similar --data-file-1 [dataset1] --data-file-2 [dataset2] --length-threshold [num_bytes] --cache-dir [where/to/save] --num-threads [N]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This creates files (similar to the self-similar command containing the position of all examples in dataset2 that are also in dataset1, and also at the same time the position of all examples in dataset1 that are also in dataset2. As before, the output is both &lt;code&gt;dups&lt;/code&gt; files that have the byte offset of where the &lt;code&gt;length-threshold&lt;/code&gt; duplicates occur, and also &lt;code&gt;sizes&lt;/code&gt; files that give the sizes of each cluster.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s again possible to run&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run collect --data-name [dataset1 or dataset2]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will write to stdout the byte ranges [a,b) where all tokens in this range are part of an overlap contained in the other document.&lt;/p&gt; &#xA;&lt;h4&gt;Finding duplicates within one document&lt;/h4&gt; &#xA;&lt;p&gt;To find duplicates that are contained within one document (for example, to actually deduplicate a dataset as we do in the paper) run the command&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cargo run self-similar --data-file [path] --length-threshold [bytes] --cache-dir [where/to/save] --num-threads [cpu cores]&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will find all repeated substrings contained in the dataset above a given length threshold. To see how it is used look above where it&#39;s called as part of the dataset deduplication process. Again run collect_similar to find the indexs of repeated examples.&lt;/p&gt; &#xA;&lt;h2&gt;Rust Deduplicator Version History&lt;/h2&gt; &#xA;&lt;p&gt;Version 0.1.0 was an initial code release that reproduces the paper.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The code worked, but was rather terrible.&lt;/li&gt; &#xA; &lt;li&gt;I am sorry if you had to look at it.&lt;/li&gt; &#xA; &lt;li&gt;You don&#39;t want to look at this code unless you&#39;re explicitly trying to reproduce our paper.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Version 1.0.0 is complete restructuring of the code. IT IS NOT BACKWARDS COMPATIBLE.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The suffix array data structure is basically the only thing that remains unchanged (thanks to Andrew Gallant who actually understood how to write code). You won&#39;t need to re-generate the suffix array tables if you upgrade from 0.1 to 1.0.&lt;/li&gt; &#xA; &lt;li&gt;The rust code now uses argument parsing, instead of relying on the order arguments are passed. So the CLI interface has changed.&lt;/li&gt; &#xA; &lt;li&gt;Added one-line scripts to deduplicate a single file, or a TFDS dataset.&lt;/li&gt; &#xA; &lt;li&gt;The intermediate data files have changed. This shouldn&#39;t matter unless you were looking at the internals of the code. If you were, then you &lt;em&gt;will&lt;/em&gt; need to re-generate intermediate data files&lt;/li&gt; &#xA; &lt;li&gt;The code is not entirely terrible to read, and has comments.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Approx Deduplication Results&lt;/h1&gt; &#xA;&lt;p&gt;The following CSVs contain three columns: the document ID, a boolean indicating whether or not this document was deleted during deduplication, and a cluster ID. Documents with the same cluster ID were identified as near-duplicates. For C4 and RealNews, the document ID is the url associated with the document. For Wiki-40B, it is the &lt;code&gt;wikidata_id&lt;/code&gt;. LM1B coming soon.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;Link&lt;/strong&gt;&lt;/th&gt; &#xA;   &lt;th align=&#34;center&#34;&gt;&lt;strong&gt;Size&lt;/strong&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;C4&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://storage.googleapis.com/gresearch/data_deduplication/c4.tar.gz&#34;&gt;link&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;13GB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;RealNews&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://storage.googleapis.com/gresearch/data_deduplication/realnews.tar.gz&#34;&gt;link&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;1.4GB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;Wiki-40B&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;&lt;a href=&#34;https://storage.googleapis.com/gresearch/data_deduplication/wiki40b.tar.gz&#34;&gt;link&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td align=&#34;center&#34;&gt;26MB&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>yamafaktory/jql</title>
    <updated>2023-12-02T01:39:43Z</updated>
    <id>tag:github.com,2023-12-02:/yamafaktory/jql</id>
    <link href="https://github.com/yamafaktory/jql" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A JSON Query Language CLI tool&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yamafaktory/jql/main/jql.svg?sanitize=true&#34; alt=&#34;jql&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/yamafaktory/jql/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/yamafaktory/jql/ci.yml?branch=main&amp;amp;logo=github&amp;amp;style=flat-square&#34; alt=&#34;GitHub Workflow Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/jql&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/jql?style=flat-square&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/jql-parser/latest/jql_parser/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/jql-parser?label=jql-parser%20docs&amp;amp;style=flat-square&#34; alt=&#34;Docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/jql-runner/latest/jql_runner/&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/jql-runner?label=jql-runner%20docs&amp;amp;style=flat-square&#34; alt=&#34;Docs.rs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;jql&lt;/code&gt; is a JSON Query Language tool built with Rust .&lt;/p&gt; &#xA;&lt;p&gt;Pronounce it as &lt;strong&gt;jackal&lt;/strong&gt; .&lt;/p&gt; &#xA;&lt;h2&gt; Philosophy&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Be fast&lt;/li&gt; &#xA; &lt;li&gt; Stay lightweight&lt;/li&gt; &#xA; &lt;li&gt; Keep its features as simple as possible&lt;/li&gt; &#xA; &lt;li&gt; Avoid redundancy&lt;/li&gt; &#xA; &lt;li&gt; Provide meaningful error messages&lt;/li&gt; &#xA; &lt;li&gt; Eat JSON as input, process, output JSON back&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt; Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Alpine Linux&lt;/h3&gt; &#xA;&lt;p&gt;The package is maintained by @jirutka.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;apk add jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Archlinux&lt;/h3&gt; &#xA;&lt;p&gt;The AUR package is maintained by @barklan.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yay -S jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Cargo&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo install jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Fedora&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;dnf install jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;FreeBSD&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pkg install jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Homebrew&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Nix&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nix-env -i jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;openSUSE&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;zypper install jql&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Manual installation from GitHub&lt;/h3&gt; &#xA;&lt;p&gt;Compiled binary versions are automatically uploaded to GitHub when a new release is made. You can install &lt;code&gt;jql&lt;/code&gt; manually by &lt;a href=&#34;https://github.com/yamafaktory/jql/releases&#34;&gt;downloading a release&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt; Usage&lt;/h2&gt; &#xA;&lt;p&gt;To make a selection from a JSON input, &lt;code&gt;jql&lt;/code&gt; expects a &lt;strong&gt;query&lt;/strong&gt; as a sequence of &lt;strong&gt;tokens&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To be fully compliant with the JSON format, &lt;code&gt;jql&lt;/code&gt; always expect key selectors to be &lt;strong&gt;double-quoted&lt;/strong&gt;, see &lt;a href=&#34;https://tools.ietf.org/html/rfc8259#section-13&#34;&gt;The JavaScript Object Notation (JSON) Data Interchange Format&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;.valid&#34;: 1337,&#xA;  &#34;&#34;: &#34;yeah!&#34;,&#xA;  &#34;\&#34;&#34;: &#34;yup, valid too!&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Consequently, to be shell compliant, a query must be either enclosed by single quotation marks or every inner double quotation mark must be escaped.&lt;/p&gt; &#xA;&lt;h3&gt;Separators&lt;/h3&gt; &#xA;&lt;h4&gt;Group separator&lt;/h4&gt; &#xA;&lt;p&gt;Group separators build up an array from sub-queries.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 3 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;&#34;a&#34;,&#34;b&#34;,&#34;c&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Selectors&lt;/h3&gt; &#xA;&lt;h4&gt;Arrays&lt;/h4&gt; &#xA;&lt;h5&gt;Array index selector&lt;/h5&gt; &#xA;&lt;p&gt;Indexes can be used in arbitrary order.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;[2,1]&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[3, 2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Array range selector&lt;/h5&gt; &#xA;&lt;p&gt;Range can be in natural order &lt;code&gt;[0:2]&lt;/code&gt;, reversed &lt;code&gt;[2:0]&lt;/code&gt;, without lower &lt;code&gt;[:2]&lt;/code&gt; or upper bound &lt;code&gt;[0:]&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[1, 2, 3]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;[2:1]&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[3, 2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Lens selector&lt;/h5&gt; &#xA;&lt;p&gt;Lens can be a combination of one or more selectors with or an optional value, a value being any of &lt;strong&gt;boolean&lt;/strong&gt; | &lt;strong&gt;null&lt;/strong&gt; | &lt;strong&gt;number&lt;/strong&gt; | &lt;strong&gt;string&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  { &#34;a&#34;: 1, &#34;b&#34;: { &#34;d&#34;: 2 } },&#xA;  { &#34;a&#34;: 2, &#34;b&#34;: &#34;some&#34; },&#xA;  { &#34;a&#34;: 2, &#34;b&#34;: { &#34;d&#34;: null } },&#xA;  { &#34;a&#34;: 2, &#34;b&#34;: true },&#xA;  { &#34;c&#34;: 3, &#34;b&#34;: 4 }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;|={&#34;b&#34;&#34;d&#34;=2, &#34;c&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[&#xA;  { &#34;a&#34;: 1, &#34;b&#34;: { &#34;d&#34;: 2 } },&#xA;  { &#34;c&#34;: 3, &#34;b&#34;: 4 }&#xA;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Objects&lt;/h4&gt; &#xA;&lt;h5&gt;Key selector&lt;/h5&gt; &#xA;&lt;p&gt;Any valid JSON key can be used.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 3 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;&#34;c&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;3&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Multi key selector&lt;/h5&gt; &#xA;&lt;p&gt;Keys can be used in arbitrary order.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 3 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;{&#34;c&#34;,&#34;a&#34;}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;c&#34;: 3, &#34;a&#34;: 1 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Object index selector&lt;/h5&gt; &#xA;&lt;p&gt;Indexes can be used in arbitrary order.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 3 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;{2,0}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;c&#34;: 3, &#34;a&#34;: 1 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Object range selector&lt;/h5&gt; &#xA;&lt;p&gt;Range can be in natural order &lt;code&gt;{0:2}&lt;/code&gt;, reversed &lt;code&gt;{2:0}&lt;/code&gt;, without lower &lt;code&gt;{:2}&lt;/code&gt; or upper bound &lt;code&gt;{0:}&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: 1, &#34;b&#34;: 2, &#34;c&#34;: 3 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;{2:1}&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;c&#34;: 3, &#34;b&#34;: 2 }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Operators&lt;/h4&gt; &#xA;&lt;h5&gt;Flatten operator&lt;/h5&gt; &#xA;&lt;p&gt;Flattens arrays and objects.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[[[[[[[[[[[[[[{ &#34;a&#34;: 1 }]]]]]]]]]]]]], [[[[[{ &#34;b&#34;: 2 }]]]], { &#34;c&#34;: 3 }], null]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;..&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[{ &#34;a&#34;: 1 }, { &#34;b&#34;: 2 }, { &#34;c&#34;: 3 }, null]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: { &#34;c&#34;: false }, &#34;b&#34;: { &#34;d&#34;: { &#34;e&#34;: { &#34;f&#34;: 1, &#34;g&#34;: { &#34;h&#34;: 2 } } } } }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;..&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;a.c&#34;: false,&#xA;  &#34;b.d.e.f&#34;: 1,&#xA;  &#34;b.d.e.g.h&#34;: 2&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Pipe in operator&lt;/h5&gt; &#xA;&lt;p&gt;Applies the next tokens in parallel on each element of an array.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: [{ &#34;b&#34;: { &#34;c&#34;: 1 } }, { &#34;b&#34;: { &#34;c&#34;: 2 } }] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;&#34;a&#34;|&amp;gt;&#34;b&#34;&#34;c&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[1, 2]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Pipe out operator&lt;/h5&gt; &#xA;&lt;p&gt;Stops the parallelization initiated by the pipe in operator.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: [{ &#34;b&#34;: { &#34;c&#34;: 1 } }, { &#34;b&#34;: { &#34;c&#34;: 2 } }] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;&#34;a&#34;|&amp;gt;&#34;b&#34;&#34;c&#34;&amp;lt;|[1]&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h5&gt;Truncate operator&lt;/h5&gt; &#xA;&lt;p&gt;Maps the output into simple JSON primitives &lt;strong&gt;boolean&lt;/strong&gt; | &lt;strong&gt;null&lt;/strong&gt; | &lt;strong&gt;number&lt;/strong&gt; | &lt;strong&gt;string&lt;/strong&gt; | &lt;strong&gt;[]&lt;/strong&gt; | &lt;strong&gt;{}&lt;/strong&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON input&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &#34;a&#34;: [1, 2, 3] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&#39;&#34;a&#34;!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;strong&gt;JSON output&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt; Shell integration&lt;/h2&gt; &#xA;&lt;h3&gt;How to save the output&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;jql &#39;&#34;a&#34;&#39; input.json &amp;gt; output.json&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;How to read from stdin&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat test.json | jql &#39;&#34;a&#34;&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Available flags&lt;/h3&gt; &#xA;&lt;h4&gt;Inline the JSON output&lt;/h4&gt; &#xA;&lt;p&gt;By default, the output is pretty printed in a more human-readable way, this can be disabled.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-i, --inline&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Read the query from file&lt;/h4&gt; &#xA;&lt;p&gt;The command will read the provided query from a file instead of the stdin.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-q, --query &amp;lt;FILE&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Write to stdout without JSON double-quotes&lt;/h4&gt; &#xA;&lt;p&gt;This can be useful to drop the double-quotes surrounding a string primitive.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-r, --raw-string&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Read a stream of JSON data line by line&lt;/h4&gt; &#xA;&lt;p&gt;This flag is only about reading processing any JSON output streamed line by line (e.g. Docker logs with the &lt;code&gt;--follow&lt;/code&gt; flag). This is not an option to read an incomplete streamed content (e.g. a very large input).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-s, --stream&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Validate the JSON data&lt;/h4&gt; &#xA;&lt;p&gt;The command will return a matching exit code based on the validity of the JSON content or file provided.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-v, --validate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Print help&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-h, --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Print version&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;-V, --version&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Help&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;jql -h&#xA;jql --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt; Workspace&lt;/h2&gt; &#xA;&lt;p&gt;This project is composed of following crates:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;jql (&lt;em&gt;binary&lt;/em&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/jql-parser/latest/jql_parser/&#34;&gt;jql-parser&lt;/a&gt; (&lt;em&gt;library&lt;/em&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/jql-runner/latest/jql_runner/&#34;&gt;jql-runner&lt;/a&gt; (&lt;em&gt;library&lt;/em&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Some commands are available as a &lt;code&gt;justfile&lt;/code&gt; at the root of the workspace (testing / fuzzing).&lt;/p&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://nexte.st/&#34;&gt;cargo-nextest&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://just.systems/man/en/&#34;&gt;just&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Commands&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;just --list&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt; Non-goal&lt;/h2&gt; &#xA;&lt;p&gt;There&#39;s no plan to align &lt;code&gt;jql&lt;/code&gt; with &lt;code&gt;jq&lt;/code&gt; or any other similar tool.&lt;/p&gt; &#xA;&lt;h2&gt; Performance&lt;/h2&gt; &#xA;&lt;p&gt;Some benchmarks comparing a set of similar functionalities provided by this tool and &lt;a href=&#34;https://stedolan.github.io/jq/&#34;&gt;jq&lt;/a&gt; are available &lt;a href=&#34;https://raw.githubusercontent.com/yamafaktory/jql/main/PERFORMANCE.md&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt; Licenses&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yamafaktory/jql/raw/main/LICENSE-APACHE&#34;&gt;Apache License, Version 2.0&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/yamafaktory/jql/raw/main/LICENSE-MIT&#34;&gt;MIT license&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>