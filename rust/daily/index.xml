<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-09-20T01:40:03Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Ruddle/Fomos</title>
    <updated>2023-09-20T01:40:03Z</updated>
    <id>tag:github.com,2023-09-20:/Ruddle/Fomos</id>
    <link href="https://github.com/Ruddle/Fomos" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Experimental OS, built with rust&lt;/p&gt;&lt;hr&gt;&lt;blockquote&gt; &#xA; &lt;p&gt;You can support this night time project by hiring me for a day time job !&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h1&gt;Fomos&lt;/h1&gt; &#xA;&lt;p&gt;Experimental OS, built with Rust&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/Ruddle/Fomos/assets/14235713/3ee75d5e-5ebe-4cc1-b267-8b73337ee157&#34;&gt;https://github.com/Ruddle/Fomos/assets/14235713/3ee75d5e-5ebe-4cc1-b267-8b73337ee157&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Fun fact&lt;/strong&gt;: there are 3 apps running in the video. A background app, a cursor app, and a console app.&lt;/p&gt; &#xA;&lt;h1&gt;Why&lt;/h1&gt; &#xA;&lt;p&gt;I wanted to experiment with Non-Unix OS ideas.&lt;/p&gt; &#xA;&lt;p&gt;Exo-kernels are interesting, but it is mostly a theory. This project helps me understand the challenges involved in that pattern.&lt;/p&gt; &#xA;&lt;p&gt;OS development is extremely hard, Rust makes it more bearable.&lt;/p&gt; &#xA;&lt;h1&gt;Features&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Has a graphical output&lt;/li&gt; &#xA; &lt;li&gt;Dynamic allocation&lt;/li&gt; &#xA; &lt;li&gt;Load and run concurrent apps&lt;/li&gt; &#xA; &lt;li&gt;All apps run in an async loop&lt;/li&gt; &#xA; &lt;li&gt;Support Virtio mouse and keyboard (drivers are async tasks)&lt;/li&gt; &#xA; &lt;li&gt;Cooperative scheduling (apps yield control as much as possible)&lt;/li&gt; &#xA; &lt;li&gt;No context switches once booted&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;Nearly support Virgl&lt;/em&gt; â„¢&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;There is 5 examples of apps in this repo named &lt;code&gt;app_*&lt;/code&gt;, some in Rust, one in C. The kernel is in &lt;code&gt;bootloader&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;What is unique&lt;/h1&gt; &#xA;&lt;p&gt;The signature of an app in Fomos:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub extern &#34;C&#34; fn _start(ctx: &amp;amp;mut Context) -&amp;gt; i32&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Apps do not need a standard library, any OS functionality is given to the app through the &lt;em&gt;Context&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;the &lt;em&gt;Context&lt;/em&gt; is mostly a pointer to a bag of kernel functionnalities&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub extern &#34;C&#34; fn&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In Fomos, an app is really just a &lt;strong&gt;function&lt;/strong&gt;. There is nothing else ! This is a &lt;strong&gt;huge&lt;/strong&gt; claim. An executable for a Unix or Windows OS is extremely complex compared to a freestanding function.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;&amp;lt;rant&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;It is out a frustration for all my Glibc problems during day job dev on linux that I chose to try this approach.&lt;/p&gt; &#xA;&lt;p&gt;I want a flat contract between an app and the OS. So what if an app was a function ? The contract is then &lt;strong&gt;only&lt;/strong&gt; the explicit argument type.&lt;/p&gt; &#xA;&lt;p&gt;In Unix, an app has to know the target OS, but also what standard library it uses, that is 2 levels of indirections. Sometimes the os level has a conflict, sometimes the standard library level has a conflict, and sometimes I just don&#39;t have the level to understand why something doesn&#39;t work. I merely know it is related.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;&amp;lt;/rant&amp;gt;&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;I am trying to know if it is possible to have an OS-App ecosystem that does not suppose &lt;strong&gt;ANY&lt;/strong&gt; &lt;strong&gt;implicit&lt;/strong&gt; configuration. An app would &lt;strong&gt;JUST&lt;/strong&gt; have to handle its explicit &lt;code&gt;start&lt;/code&gt; &lt;em&gt;context&lt;/em&gt; argument.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Context&lt;/em&gt; gives any OS function necessary, think alloc, free, access to a framebuffer, or any hardware, any system calls etc.&lt;/p&gt; &#xA;&lt;p&gt;That way, apps could be freestanding, and compatible on multiple OS.&lt;/p&gt; &#xA;&lt;h3&gt;More about Context&lt;/h3&gt; &#xA;&lt;p&gt;Here is the &lt;em&gt;Context&lt;/em&gt; for the last version of this OS&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[repr(C)]&#xA;pub struct Context&amp;lt;&#39;a, T&amp;gt; {&#xA;    pub version: u8,&#xA;    pub start_time: u64,&#xA;    pub log: extern &#34;C&#34; fn(s: *const u8, l: u32),&#xA;    pub pid: u64,&#xA;    pub fb: FB&amp;lt;&#39;a&amp;gt;,&#xA;    pub calloc: extern &#34;C&#34; fn(usize, usize) -&amp;gt; *mut u8,&#xA;    pub cdalloc: extern &#34;C&#34; fn(*mut u8, usize, usize),&#xA;    pub store: &amp;amp;&#39;a mut Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;,&#xA;    pub input: &amp;amp;&#39;a Input,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that &lt;code&gt;app_test&lt;/code&gt; for instance, uses an old version of the &lt;em&gt;Context&lt;/em&gt;, and still works on the newer version of the OS&lt;/p&gt; &#xA;&lt;p&gt;Old Context used by &lt;code&gt;app_test&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;#[repr(C)]&#xA;pub struct Context&amp;lt;&#39;a&amp;gt; {&#xA;    pub version: u8,&#xA;    start_time: u64,&#xA;    log: extern &#34;C&#34; fn(s: *const u8, l: u32),&#xA;    pid: u64,&#xA;    fb: FB&amp;lt;&#39;a&amp;gt;,&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Meaning Fomos already handles gracefully Apps designed for a much older version of itself. As long as the OS stays compatible with the old stuff in the context, it can add new functionalities for other App by just appending to the context the new functions (here calloc, cdalloc, store, and input).&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;app_test&lt;/code&gt; precedes the dynamic allocation age !&lt;/p&gt; &#xA;&lt;p&gt;Could that pattern work in the long term ?&lt;/p&gt; &#xA;&lt;h3&gt;How about system calls&lt;/h3&gt; &#xA;&lt;p&gt;None. Lets try to put everything into &lt;em&gt;Context&lt;/em&gt; functions. No voodoo cpu instruction magic.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;But how do you give back control to the OS ?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Just&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;return;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;How do you sleep, or wait asynchronously ?&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Just&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;return;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Apps are &lt;strong&gt;cooperative&lt;/strong&gt; in Fomos, They can just return (which would exit permanently an app on a classic OS), and assume that they are gonna be called through their only function &lt;code&gt;start&lt;/code&gt; again soon, maybe even instantly if the &#34;system call&#34; works that way.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;But an app loses all RAM data everytime it yields that way !&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;No, an app can store anything it wants in Context.store during its execution, and get it back every &lt;code&gt;start&lt;/code&gt; call. The OS keeps everything in RAM (on the heap). The stack itself is &#34;reset&#34;. But it is not more &#34;reset&#34; than it is after any function execution in a normal program. You don&#39;t lose anything. In Fomos, apps are merely a single function called multiple times!&lt;/p&gt; &#xA;&lt;p&gt;Over simplification of the kernel loop:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;loop {&#xA;    for app in apps.iter_mut() {&#xA;        app._start(Context::new(...));&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;There are a lot of questions without answer yet, but by now you might be curious, what if all the question had an answer in the pattern ? It looks like it could actually work (with a lot of work).&lt;/p&gt; &#xA;&lt;h1&gt;Advantages&lt;/h1&gt; &#xA;&lt;p&gt;A lot of stuff comes free once you accept the premises.&lt;/p&gt; &#xA;&lt;h4&gt;Sandboxing, instrumentation, debugging&lt;/h4&gt; &#xA;&lt;p&gt;Every functionnality and side effect given to an app goes explicitely through the &lt;em&gt;Context&lt;/em&gt;. The &lt;em&gt;Context&lt;/em&gt; is just a struct, we can wrap or replace anything in it. Lets instrument an app we&#39;ll call &lt;code&gt;special_app&lt;/code&gt;. Over simplification :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;loop {&#xA;    for normal_app in normal_apps.iter_mut() {&#xA;        app._start(Context::new(alloc,..));&#xA;    }&#xA;    // special_app alloc instrumentation&#xA;    fn alloc_log(..){log(&#34;allocation detected!&#34;); return alloc(..);}&#xA;    special_app._start(Context::new(alloc_log,..));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Restart, sleep, change of hardware&lt;/h4&gt; &#xA;&lt;p&gt;An app memory lives in its context. The stack is fleeting. It is reset after each yield and doesn&#39;t mean much in Fomos. Since the &lt;em&gt;Context&lt;/em&gt; is explicit, it can be stored. A restart &lt;em&gt;can&lt;/em&gt; be made completely transparent to an app.&lt;/p&gt; &#xA;&lt;p&gt;Pseudo code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;//kernel just started&#xA;...&#xA;let app = App::new(..);&#xA;let ctx = disk.load(app.id).unwrap_or(Context::new(..));&#xA;loop{&#xA;    app._start(ctx);&#xA;    if restart_request{&#xA;        disk.save(app.id, ctx)&#xA;        break;&#xA;    }&#xA;}&#xA;//handle restart&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Quickload and quicksave of an app complete state is trivial. Note that some change of hardware could make an app bug. It would be a problem if it was transparent. However, it could be made opaque and obvious, in an opt-in manner, again through the &lt;em&gt;Context&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Disadvantages&lt;/h1&gt; &#xA;&lt;h3&gt;Security&lt;/h3&gt; &#xA;&lt;p&gt;Right now it is not implemented, any app can casually check the ram of another app ^^. This is going to be a hard problem to solve. I have plans to have data security without context switch, and without giving every damn app its own virtual memory stack.&lt;/p&gt; &#xA;&lt;h3&gt;Cooperative vs preemptive scheduling&lt;/h3&gt; &#xA;&lt;p&gt;The argument that a cooperative scheduling is doomed to fail is overblown. Apps are already very much cooperative. For proof, run a version of that on your nice preemptive system :&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;while(true){&#xA;  new Thread( () =&amp;gt; {&#xA;    fs.writeFile(&#34;/home/&#34;+randomString(),randomString())&#xA;    malloc(randomInt())&#xA;    curl(&#34;http://&#34;+randomString()+&#34;.com&#34;)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Blender does a compelling impression of that when you increase the level of details one too many times. Might fill your swap and crash unsaved work on other apps.&lt;/li&gt; &#xA; &lt;li&gt;Badly written Webgl websites crash my gpu driver.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not only is preemptive scheduling not enough, IMO it is not necessary. Also it is a spectrum. A system can be optimistically cooperative, and turn preemptive pessimistically.&lt;/p&gt; &#xA;&lt;p&gt;However the ecosystem is made for preemptive OS. There is friction in doing things differently.&lt;/p&gt; &#xA;&lt;h1&gt;Missing&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Permanent storage (should be easy since virtio is already implemented)&lt;/li&gt; &#xA; &lt;li&gt;Gpu support (virgl wip)&lt;/li&gt; &#xA; &lt;li&gt;Networking&lt;/li&gt; &#xA; &lt;li&gt;A nice abstraction for apps to share data and functionnalities between themselves&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The rest should live in userland.&lt;/p&gt; &#xA;&lt;h1&gt;Building&lt;/h1&gt; &#xA;&lt;p&gt;run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;You might need rust nightly, gcc, qemu with virgl &amp;amp; sdl flag&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/Ruddle/Fomos/main/docs/BUILD.md&#34;&gt;More info here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Credit&lt;/h1&gt; &#xA;&lt;p&gt;Heavily inspired by &lt;a href=&#34;https://os.phil-opp.com/&#34;&gt;Philipp Oppermann&#39;s blog&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/darbysauter/myOS&#34;&gt;darbysauter&lt;/a&gt; for the advice given.&lt;/p&gt;</summary>
  </entry>
</feed>