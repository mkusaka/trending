<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-08T01:40:24Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>ekzhang/sshx</title>
    <updated>2023-11-08T01:40:24Z</updated>
    <id>tag:github.com,2023-11-08:/ekzhang/sshx</id>
    <link href="https://github.com/ekzhang/sshx" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fast, collaborative live terminal sharing over the web&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sshx&lt;/h1&gt; &#xA;&lt;p&gt;A secure web-based, collaborative terminal.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Q3qKAHW.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Features:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run a single command to share your terminal with anyone.&lt;/li&gt; &#xA; &lt;li&gt;Resize, move windows, and freely zoom and pan on an infinite canvas.&lt;/li&gt; &#xA; &lt;li&gt;See other people&#39;s cursors moving in real time.&lt;/li&gt; &#xA; &lt;li&gt;Connect to the nearest server in a globally distributed mesh.&lt;/li&gt; &#xA; &lt;li&gt;End-to-end encryption with Argon2 and AES.&lt;/li&gt; &#xA; &lt;li&gt;Automatic reconnection and real-time latency estimates.&lt;/li&gt; &#xA; &lt;li&gt;Predictive echo for faster local editing (à la Mosh).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Visit &lt;a href=&#34;https://sshx.io&#34;&gt;sshx.io&lt;/a&gt; to learn more.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Just run this command to get the &lt;code&gt;sshx&lt;/code&gt; binary for your platform.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -sSf https://sshx.io/get | sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Supports Linux and MacOS, on both x86_64 and arm64 architectures. The precompiled Linux binaries are statically linked.&lt;/p&gt; &#xA;&lt;h3&gt;CI/CD&lt;/h3&gt; &#xA;&lt;p&gt;You can also use sshx in continuous integration workflows to help debug tricky issues, like in GitHub Actions.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: CI&#xA;on: push&#xA;&#xA;jobs:&#xA;  build:&#xA;    runs-on: ubuntu-latest&#xA;    steps:&#xA;      - uses: actions/checkout@v3&#xA;&#xA;      # ... other steps ...&#xA;&#xA;      - run: curl -sSf https://sshx.io/get | sh &amp;amp;&amp;amp; sshx&#xA;      #      ^&#xA;      #      └ This will open a remote terminal session and print the URL. It&#xA;      #        should take under a second.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We don&#39;t have a prepackaged action because it&#39;s just a single command. It works anywhere: GitLab CI, CircleCI, CI on your Raspberry Pi, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Development&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s how to work on the project, if you want to contribute.&lt;/p&gt; &#xA;&lt;h3&gt;Building from source&lt;/h3&gt; &#xA;&lt;p&gt;To build the latest version of the client from source, clone this repository and run, with &lt;a href=&#34;https://rust-lang.com/&#34;&gt;Rust&lt;/a&gt; installed:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo install --path crates/sshx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will compile the &lt;code&gt;sshx&lt;/code&gt; binary and place it in your &lt;code&gt;~/.cargo/bin&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;h3&gt;Workflow&lt;/h3&gt; &#xA;&lt;p&gt;First, start service containers for development.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust 1.70+&lt;/a&gt;, &lt;a href=&#34;https://nodejs.org/&#34;&gt;Node v18&lt;/a&gt;, &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;NPM v9&lt;/a&gt;, and &lt;a href=&#34;https://github.com/pvolok/mprocs&#34;&gt;mprocs&lt;/a&gt;. Then, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install&#xA;mprocs&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will compile and start the server, an instance of the client, and the web frontend in parallel on your machine.&lt;/p&gt; &#xA;&lt;h2&gt;Deployment&lt;/h2&gt; &#xA;&lt;p&gt;The application servers are deployed on &lt;a href=&#34;https://fly.io/&#34;&gt;Fly.io&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fly deploy&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>KnorrFG/dotree</title>
    <updated>2023-11-08T01:40:24Z</updated>
    <id>tag:github.com,2023-11-08:/KnorrFG/dotree</id>
    <link href="https://github.com/KnorrFG/dotree" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A small, interactive command runner&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Dotree is a small interactive command runner. It wants to be a better home for your aliases and bash functions, especially those that you don&#39;t use that often, and an alternative to &lt;a href=&#34;https://github.com/casey/just&#34;&gt;just&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KnorrFG/dotree/main/demo.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Given a config file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;menu root {&#xA;&#x9;g: git&#xA;&#x9;m: misc&#xA;}&#xA;&#xA;menu git {&#xA;&#x9;am: &#34;amend&#34; - &#34;git commit --amend --no-edit&#34;&#xA;&#x9;aam: &#34;all amend&#34; - &#34;git commit -a --amend --no-edit&#34;&#xA;&#x9;ca: &#34;git commit -a&#34;&#xA;&#x9;b: &#34;git switch $(git branch | fzf)&#34;&#xA;&#x9;w: cmd {&#xA;&#x9;&#x9;vars output_dir, branch&#xA;&#x9;&#x9;&#34;add worktree&#34; - &#34;git worktree add -b $branch $output_dir&#34;&#xA;&#x9;}&#xA;}&#xA;&#xA;menu misc {&#xA;&#x9;mn: &#34;mount-netdrives&#34;&#xA;&#x9;un: &#34;unmount-netdrives&#34;&#xA;&#x9;cv: &#34;connect-vpn&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;it presents you with the options to execute the commands configured in the file by typing the configured key. For Example: with the given config file above, I could start dotree by typing &lt;code&gt;dt&lt;/code&gt; (after it was installed), and then type &lt;code&gt;gb&lt;/code&gt; while dotree is running to execute &lt;code&gt;git switch $(git branch | fzf)&lt;/code&gt; in bash.&lt;/p&gt; &#xA;&lt;p&gt;Alternativly you can also do that by entering &lt;code&gt;dt gb&lt;/code&gt;. If you provide an argument, its characters will be processed as if you typed them when the program is running.&lt;/p&gt; &#xA;&lt;p&gt;A command can either be declared as quick command, i.e. a string that contains bash code, optionally with another string and a &lt;code&gt;-&lt;/code&gt; in front of it, to have a name displayed in place of the bash code, or as command via the &lt;code&gt;cmd&lt;/code&gt; keyword, which allows for the additional definition of variables that will be queried and then passed as env vars to the bash invocation. To query the input, &lt;a href=&#34;https://github.com/kkawakam/rustyline&#34;&gt;rustyline&lt;/a&gt; is used, and you have path completion and a history.&lt;/p&gt; &#xA;&lt;p&gt;An alternate form of strings are protected strings: &lt;code&gt;!&#34;&amp;lt;content&amp;gt;&#34;!&lt;/code&gt;, in which case you can use &lt;code&gt;&#34;&lt;/code&gt; freely within the string. and in case you even need &lt;code&gt;!&#34;&lt;/code&gt; in a string, you can add any characters between the &lt;code&gt;!&lt;/code&gt; and the &lt;code&gt;&#34;&lt;/code&gt;. The characters are not mirrored on the closing delimiter. So &lt;code&gt;!ab&#34;&amp;lt;content&amp;gt;&#34;ab!&lt;/code&gt; is valid, but &lt;del&gt;&lt;code&gt;!ab&#34;&amp;lt;content&amp;gt;&#34;ba!&lt;/code&gt;&lt;/del&gt; is not.&lt;/p&gt; &#xA;&lt;p&gt;For an example of a real world config, &lt;a href=&#34;https://raw.githubusercontent.com/KnorrFG/dotree/main/example.dt&#34;&gt;click here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Command Arguments&lt;/h3&gt; &#xA;&lt;p&gt;Commands can have arguments, which will be queried interactively, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;...&#xA;menu git {&#xA;&#x9;...&#xA;&#x9;w: cmd {&#xA;&#x9;&#x9;vars output_dir, branch&#xA;&#x9;&#x9;&#34;add worktree&#34; - &#34;git worktree add -b $branch $output_dir&#34;&#xA;&#x9;}&#xA;}&#xA;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The values are exposed via environment variables to the callee. If you invoke dt with additional arguments, the additional arguments will be used as values for the vars. For example: &lt;code&gt;dt gw fknorr/some-feature /tmp/worktree_dir&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Repeating Commands&lt;/h3&gt; &#xA;&lt;p&gt;You can configure dotree to continue after a command was executed, so that you can trigger the command again with a single keypress. This is usefull for example, if you want to change screen brightness when you don&#39;t have a keyboard with appropriate keys:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;menu root {&#xA;&#x9;m: brightnessctl&#xA;}&#xA;&#xA;menu brightnessctl {&#xA;&#x9;+: cmd {&#xA;&#x9;&#x9;set repeat&#xA;&#x9;&#x9;&#34;brightnessctl set +10%&#34;&#xA;&#x9;}&#xA;&#x9;-: cmd {&#xA;&#x9;&#x9;set repeat&#xA;&#x9;&#x9; &#34;brightnessctl set -10%&#34;&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also add &lt;code&gt;ignore_result&lt;/code&gt; as a config option, in which case dotree won&#39;t escape when the command has a non-zero exit code, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;menu brightnessctl {&#xA;...&#xA;&#x9;+: cmd {&#xA;&#x9;&#x9;set repeat, ignore_result&#xA;&#x9;&#x9;&#34;brightnessctl set +10%&#34;&#xA;&#x9;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Naming Menus&lt;/h3&gt; &#xA;&lt;p&gt;You can also assign a different display name to a menu, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;menu &#34;Worktree&#34; git_worktree {&#xA;&#x9;...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Local mode&lt;/h3&gt; &#xA;&lt;p&gt;If you start dotree with -l, it will search for a dotree.dt file between the cwd and the file system root. If it finds one, it uses it instead of the normal config file, and changes the working directory before executing commands, to the containing directory. This way, you can use dotree as a more interactive version of &lt;a href=&#34;https://github.com/casey/just&#34;&gt;just&lt;/a&gt;. I aliased &lt;code&gt;dt -l&lt;/code&gt; to &lt;code&gt;dtl&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Default Shell&lt;/h3&gt; &#xA;&lt;p&gt;By default, dotree uses &#34;bash -euo pipefail -c&#34; as shell invocation on linux, or &#34;cmd /c&#34; on windows. The shell string is always appended as last argument. You can change the default shell by setting the environment variable &lt;code&gt;DT_DEFAULT_SHELL&lt;/code&gt; or on a per file basis, by placing a shell directive as first element in the config file like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;shell sh -c&#xA;&#xA;menu root {&#xA;&#x9;g: git&#xA;&#x9;m: misc&#xA;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It is also possible to change the shell for a command, by putting a shell directive into a command like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;menu root {&#xA;&#x9;p: cmd {&#xA;&#x9;&#x9;shell python -c&#xA;&#x9;&#x9;&#34;python hi&#34; - !&#34;print(&#34;hello from python&#34;)&#34;!&#xA;&#x9;}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Alternative Config Path&lt;/h3&gt; &#xA;&lt;p&gt;By default, dotree looks at a file named &lt;code&gt;dotree.dt&lt;/code&gt; in the XDG config dir, you can make it look somewhere else with the &lt;code&gt;-c&lt;/code&gt; command line argument&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Download the appropriate binary for your platform (windows is untested) from the release page, or install via cargo: &lt;code&gt;cargo install --git https://github.com/knorrfg/dotree&lt;/code&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>