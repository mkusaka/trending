<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-19T01:43:15Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>matsadler/magnus</title>
    <updated>2023-02-19T01:43:15Z</updated>
    <id>tag:github.com,2023-02-19:/matsadler/magnus</id>
    <link href="https://github.com/matsadler/magnus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ruby bindings for Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Magnus&lt;/h1&gt; &#xA;&lt;p&gt;Ruby bindings for Rust. Write Ruby extension gems in Rust, or call Ruby code from a Rust binary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.rs/magnus/latest/magnus/&#34;&gt;API Docs&lt;/a&gt; | &lt;a href=&#34;https://github.com/matsadler/magnus&#34;&gt;GitHub&lt;/a&gt; | &lt;a href=&#34;https://crates.io/crates/magnus&#34;&gt;crates.io&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/matsadler/magnus/main/#getting-started&#34;&gt;Getting Started&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/matsadler/magnus/main/#type-conversions&#34;&gt;Type Conversions&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/matsadler/magnus/main/#safety&#34;&gt;Safety&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/matsadler/magnus/main/#compatibility&#34;&gt;Compatibility&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Defining Methods&lt;/h3&gt; &#xA;&lt;p&gt;Using Magnus, regular Rust functions can be bound to Ruby as methods with automatic type conversion. Callers passing the wrong arguments or incompatible types will get the same kind of &lt;code&gt;ArgumentError&lt;/code&gt; or &lt;code&gt;TypeError&lt;/code&gt; they are used to seeing from Ruby&#39;s built in methods.&lt;/p&gt; &#xA;&lt;p&gt;Defining a function (with no Ruby &lt;code&gt;self&lt;/code&gt; argument):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn fib(n: usize) -&amp;gt; usize {&#xA;    match n {&#xA;        0 =&amp;gt; 0,&#xA;        1 | 2 =&amp;gt; 1,&#xA;        _ =&amp;gt; fib(n - 1) + fib(n - 2),&#xA;    }&#xA;}&#xA;&#xA;magnus::define_global_function(&#34;fib&#34;, magnus::function!(fib, 1));&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Defining a method (with a Ruby &lt;code&gt;self&lt;/code&gt; argument):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn is_blank(rb_self: String) -&amp;gt; bool {&#xA;    !rb_self.contains(|c: char| !c.is_whitespace())&#xA;}&#xA;&#xA;let class = magnus::define_class(&#34;String&#34;, magnus::class::object())?;&#xA;// 0 as self doesn&#39;t count against the number of arguments&#xA;class.define_method(&#34;blank?&#34;, magnus::method!(is_blank, 0))?;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Calling Ruby Methods&lt;/h3&gt; &#xA;&lt;p&gt;Some Ruby methods have direct counterparts in Ruby&#39;s C API and therefore in Magnus. Ruby&#39;s &lt;code&gt;Object#frozen?&lt;/code&gt; method is available as &lt;code&gt;magnus::ReprValue::check_frozen&lt;/code&gt;, or &lt;code&gt;Array#[]&lt;/code&gt; becomes &lt;code&gt;magnus::RArray::aref&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Other Ruby methods that are defined only in Ruby must be called with &lt;code&gt;magnus::ReprValue::funcall&lt;/code&gt;. All of Magnus&#39; Ruby wrapper types implement the &lt;code&gt;ReprValue&lt;/code&gt; trait, so &lt;code&gt;funcall&lt;/code&gt; can be used on all of them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let s: String = value.funcall(&#34;test&#34;, ())?; // 0 arguments&#xA;let x: bool = value.funcall(&#34;example&#34;, (&#34;foo&#34;,))?; // 1 argument&#xA;let i: i64 = value.funcall(&#34;other&#34;, (42, false))?; // 2 arguments, etc&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;funcall&lt;/code&gt; will convert return types, returning &lt;code&gt;Err(magnus::Error)&lt;/code&gt; if the type conversion fails or the method call raised an error. To skip type conversion make sure the return type is &lt;code&gt;magnus::Value&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Wrapping Rust Types in Ruby Objects&lt;/h3&gt; &#xA;&lt;p&gt;Rust structs and enums can be wrapped in Ruby objects so they can be returned to Ruby.&lt;/p&gt; &#xA;&lt;p&gt;Types can opt-in to this with the &lt;code&gt;magnus::wrap&lt;/code&gt; macro (or by implementing &lt;code&gt;magnus::TypedData&lt;/code&gt;). Whenever a compatible type is returned to Ruby it will be wrapped in the specified class, and whenever it is passed back to Rust it will be unwrapped to a reference.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use magnus::{class, define_class, function, method, prelude::*, Error};&#xA;&#xA;#[magnus::wrap(class = &#34;Point&#34;)]&#xA;struct Point {&#xA;    x: isize,&#xA;    y: isize,&#xA;}&#xA;&#xA;impl Point {&#xA;    fn new(x: isize, y: isize) -&amp;gt; Self {&#xA;        Self { x, y }&#xA;    }&#xA;&#xA;    fn x(&amp;amp;self) -&amp;gt; isize {&#xA;        self.x&#xA;    }&#xA;&#xA;    fn y(&amp;amp;self) -&amp;gt; isize {&#xA;        self.y&#xA;    }&#xA;&#xA;    fn distance(&amp;amp;self, other: &amp;amp;Point) -&amp;gt; f64 {&#xA;        (((other.x - self.x).pow(2) + (other.y - self.y).pow(2)) as f64).sqrt()&#xA;    }&#xA;}&#xA;&#xA;#[magnus::init]&#xA;fn init() -&amp;gt; Result&amp;lt;(), Error&amp;gt; {&#xA;    let class = define_class(&#34;Point&#34;, class::object())?;&#xA;    class.define_singleton_method(&#34;new&#34;, function!(Point::new, 2))?;&#xA;    class.define_method(&#34;x&#34;, method!(Point::x, 0))?;&#xA;    class.define_method(&#34;y&#34;, method!(Point::y, 0))?;&#xA;    class.define_method(&#34;distance&#34;, method!(Point::distance, 1))?;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The newtype pattern and &lt;code&gt;RefCell&lt;/code&gt; can be used if mutability is required:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;struct Point {&#xA;    x: isize,&#xA;    y: isize,&#xA;}&#xA;&#xA;#[magnus::wrap(class = &#34;Point&#34;)]&#xA;struct MutPoint(std::cell::RefCell&amp;lt;Point&amp;gt;);&#xA;&#xA;impl MutPoint {&#xA;    fn set_x(&amp;amp;self, i: isize) {&#xA;        self.0.borrow_mut().x = i;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Writing an extension gem (calling Rust from Ruby)&lt;/h3&gt; &#xA;&lt;p&gt;Ruby extensions must be built as dynamic system libraries, this can be done by setting the &lt;code&gt;crate-type&lt;/code&gt; attribute in your &lt;code&gt;Cargo.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Cargo.toml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[lib]&#xA;crate-type = [&#34;cdylib&#34;]&#xA;&#xA;[dependencies]&#xA;magnus = &#34;0.4&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When Ruby loads your extension it calls an &#39;init&#39; function defined in your extension. In this function you will need to define your Ruby classes and bind Rust functions to Ruby methods. Use the &lt;code&gt;#[magnus::init]&lt;/code&gt; attribute to mark your init function so it can be correctly exposed to Ruby.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;src/lib.rs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use magnus::{define_global_function, function};&#xA;&#xA;fn distance(a: (f64, f64), b: (f64, f64)) -&amp;gt; f64 {&#xA;    ((b.0 - a.0).powi(2) + (b.1 - a.1).powi(2)).sqrt()&#xA;}&#xA;&#xA;#[magnus::init]&#xA;fn init() {&#xA;    define_global_function(&#34;distance&#34;, function!(distance, 2));&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you wish to package your extension as a Gem, we recommend using the &lt;a href=&#34;https://github.com/oxidize-rb/rb-sys/tree/main/gem&#34;&gt;&lt;code&gt;rb_sys&lt;/code&gt; gem&lt;/a&gt; to build along with &lt;code&gt;rake-compiler&lt;/code&gt;. These tools will automatically build your Rust extension as a dynamic library, and then package it as a gem.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: The newest version of rubygems does have beta support for compiling Rust, so in the future the &lt;code&gt;rb_sys&lt;/code&gt; gem won&#39;t be necessary.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;my_example_gem.gemspec&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;spec.extensions = [&#34;ext/my_example_gem/extconf.rb&#34;]&#xA;&#xA;# needed until rubygems supports Rust support is out of beta&#xA;spec.add_dependency &#34;rb_sys&#34;, &#34;~&amp;gt; 0.9.39&#34;&#xA;&#xA;# only needed when developing or packaging your gem&#xA;spec.add_development_dependency &#34;rake-compiler&#34;, &#34;~&amp;gt; 1.2.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, we add an &lt;code&gt;extconf.rb&lt;/code&gt; file to the &lt;code&gt;ext&lt;/code&gt; directory. Ruby will execute this file during the compilation process, and it will generate a &lt;code&gt;Makefile&lt;/code&gt; in the &lt;code&gt;ext&lt;/code&gt; directory. See the &lt;a href=&#34;https://github.com/oxidize-rb/rb-sys/tree/main/gem&#34;&gt;&lt;code&gt;rb_sys&lt;/code&gt; gem&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;ext/my_example_gem/extconf.rb&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#34;mkmf&#34;&#xA;require &#34;rb_sys/mkmf&#34;&#xA;&#xA;create_rust_makefile(&#34;my_example_gem/my_example_gem&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/matsadler/magnus/tree/main/examples/rust_blank/ext/rust_blank&#34;&gt;&lt;code&gt;rust_blank&lt;/code&gt;&lt;/a&gt; example for examples if &lt;code&gt;extconf.rb&lt;/code&gt; and &lt;code&gt;Rakefile&lt;/code&gt;. Running &lt;code&gt;rake compile&lt;/code&gt; will place the extension at &lt;code&gt;lib/my_example_gem/my_example_gem.so&lt;/code&gt; (or &lt;code&gt;.bundle&lt;/code&gt; on macOS), which you&#39;d load from Ruby like so:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;lib/my_example_gem.rb&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require_relative &#34;my_example_gem/my_example_gem&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a more detailed example (including cross-compilation and more), see the &lt;a href=&#34;https://github.com/oxidize-rb/rb-sys/tree/main/examples/rust_reverse&#34;&gt;&lt;code&gt;rb-sys&lt;/code&gt; example project&lt;/a&gt;. Although the code in &lt;code&gt;lib.rs&lt;/code&gt; does not feature magnus, but it will compile and run properly.&lt;/p&gt; &#xA;&lt;h3&gt;Embedding Ruby in Rust&lt;/h3&gt; &#xA;&lt;p&gt;To call Ruby from a Rust program, enable the &lt;code&gt;embed&lt;/code&gt; feature:&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Cargo.toml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;magnus = { version = &#34;0.4&#34;, features = [&#34;embed&#34;] }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This enables linking to Ruby and gives access to the &lt;code&gt;embed&lt;/code&gt; module. &lt;code&gt;magnus::embed::init&lt;/code&gt; must be called before calling Ruby and the value it returns must not be dropped until you are done with Ruby. &lt;code&gt;init&lt;/code&gt; can not be called more than once.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;src/main.rs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use magnus::{embed, eval};&#xA;&#xA;fn main() {&#xA;    let _cleanup = unsafe { embed::init() };&#xA;&#xA;    let val: f64 = eval!(&#34;a + rand&#34;, a = 1).unwrap();&#xA;&#xA;    println!(&#34;{}&#34;, val);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Type Conversions&lt;/h2&gt; &#xA;&lt;p&gt;Magnus will automatically convert between Rust and Ruby types, including converting Ruby exceptions to Rust &lt;code&gt;Result&lt;/code&gt;s and vice versa.&lt;/p&gt; &#xA;&lt;p&gt;These conversions follow the pattern set by Ruby&#39;s core and standard libraries, where many conversions will delegate to a &lt;code&gt;#to_&amp;lt;type&amp;gt;&lt;/code&gt; method if the object is not of the requested type, but does implement the &lt;code&gt;#to_&amp;lt;type&amp;gt;&lt;/code&gt; method.&lt;/p&gt; &#xA;&lt;p&gt;Below are tables outlining many common conversions. See the Magnus api documentation for the full list of types.&lt;/p&gt; &#xA;&lt;h3&gt;Rust functions accepting values from Ruby&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;code&gt;magnus::TryConvert&lt;/code&gt; for more details.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Rust function argument&lt;/th&gt; &#xA;   &lt;th&gt;accepted from Ruby&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;i8&lt;/code&gt;,&lt;code&gt;i16&lt;/code&gt;,&lt;code&gt;i32&lt;/code&gt;,&lt;code&gt;i64&lt;/code&gt;,&lt;code&gt;isize&lt;/code&gt;, &lt;code&gt;magnus::Integer&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;#to_int&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;u8&lt;/code&gt;,&lt;code&gt;u16&lt;/code&gt;,&lt;code&gt;u32&lt;/code&gt;,&lt;code&gt;u64&lt;/code&gt;,&lt;code&gt;usize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Integer&lt;/code&gt;, &lt;code&gt;#to_int&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;f32&lt;/code&gt;,&lt;code&gt;f64&lt;/code&gt;, &lt;code&gt;magnus::Float&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Numeric&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;PathBuf&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;magnus::RString&lt;/code&gt;, &lt;code&gt;bytes::Bytes&lt;/code&gt;***&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;#to_str&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;magnus::Symbol&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Symbol&lt;/code&gt;, &lt;code&gt;#to_sym&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;any object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;magnus::Range&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;magnus::Encoding&lt;/code&gt;, &lt;code&gt;magnus::RbEncoding&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Encoding&lt;/code&gt;, encoding name as a string&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;T&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;(T, U)&lt;/code&gt;, &lt;code&gt;(T, U, V)&lt;/code&gt;, etc&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;[T, U]&lt;/code&gt;, &lt;code&gt;[T, U, V]&lt;/code&gt;, etc, &lt;code&gt;#to_ary&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;[T; N]&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;[T]&lt;/code&gt;, &lt;code&gt;#to_ary&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;magnus::RArray&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;#to_ary&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;magnus::RHash&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;#to_hash&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;magnus::Value&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;any object&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;*&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;[T]&lt;/code&gt;, &lt;code&gt;#to_ary&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;*&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;{K =&amp;gt; V}&lt;/code&gt;, &lt;code&gt;#to_hash&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;typed_data::Obj&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T: TypedData&lt;/code&gt;**&lt;/td&gt; &#xA;   &lt;td&gt;instance of &lt;code&gt;&amp;lt;T as TypedData&amp;gt;::class()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;* when converting to &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; the types of &lt;code&gt;T&lt;/code&gt;/&lt;code&gt;K&lt;/code&gt;,&lt;code&gt;V&lt;/code&gt; must be native Rust types.&lt;/p&gt; &#xA;&lt;p&gt;** see the &lt;code&gt;wrap&lt;/code&gt; macro.&lt;/p&gt; &#xA;&lt;p&gt;*** when the bytes-crate feature is enabled&lt;/p&gt; &#xA;&lt;h3&gt;Rust returning / passing values to Ruby&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;code&gt;magnus::IntoValue&lt;/code&gt; for more details, plus &lt;code&gt;magnus::method::ReturnValue&lt;/code&gt; and &lt;code&gt;magnus::ArgList&lt;/code&gt; for some additional details.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;returned from Rust / calling Ruby from Rust&lt;/th&gt; &#xA;   &lt;th&gt;received in Ruby&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;i8&lt;/code&gt;,&lt;code&gt;i16&lt;/code&gt;,&lt;code&gt;i32&lt;/code&gt;,&lt;code&gt;i64&lt;/code&gt;,&lt;code&gt;isize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;u8&lt;/code&gt;,&lt;code&gt;u16&lt;/code&gt;,&lt;code&gt;u32&lt;/code&gt;,&lt;code&gt;u64&lt;/code&gt;,&lt;code&gt;usize&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;f32&lt;/code&gt;, &lt;code&gt;f64&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;&amp;amp;Path&lt;/code&gt;, &lt;code&gt;PathBuf&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;String&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Range&lt;/code&gt;, &lt;code&gt;RangeFrom&lt;/code&gt;, &lt;code&gt;RangeTo&lt;/code&gt;, &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;T&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;Result&amp;lt;T, magnus::Error&amp;gt;&lt;/code&gt; (return only)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;T&lt;/code&gt; or raises error&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;(T, U)&lt;/code&gt;, &lt;code&gt;(T, U, V)&lt;/code&gt;, etc, &lt;code&gt;[T; N]&lt;/code&gt;, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;code&gt;T&lt;/code&gt;, &lt;code&gt;typed_data::Obj&amp;lt;T&amp;gt;&lt;/code&gt; where &lt;code&gt;T: TypedData&lt;/code&gt;**&lt;/td&gt; &#xA;   &lt;td&gt;instance of &lt;code&gt;&amp;lt;T as TypedData&amp;gt;::class()&lt;/code&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;** see the &lt;code&gt;wrap&lt;/code&gt; macro.&lt;/p&gt; &#xA;&lt;h3&gt;Conversions via Serde&lt;/h3&gt; &#xA;&lt;p&gt;Rust types can also be converted to Ruby, and vice versa, using &lt;a href=&#34;https://github.com/serde-rs/serde&#34;&gt;Serde&lt;/a&gt; with the &lt;a href=&#34;https://github.com/georgeclaghorn/serde-magnus&#34;&gt;&lt;code&gt;serde_magnus&lt;/code&gt;&lt;/a&gt; crate.&lt;/p&gt; &#xA;&lt;h3&gt;Manual Conversions&lt;/h3&gt; &#xA;&lt;p&gt;There may be cases where you want to bypass the automatic type conversions, to do this use the type &lt;code&gt;magnus::Value&lt;/code&gt; and then manually convert or type check from there.&lt;/p&gt; &#xA;&lt;p&gt;For example, if you wanted to ensure your function is always passed a UTF-8 encoded String so you can take a reference without allocating you could do the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn example(val: magnus::Value) -&amp;gt; Result&amp;lt;(), magnus::Error&amp;gt; {&#xA;    // checks value is a String, does not call #to_str&#xA;    let r_string = RString::from_value(val)&#xA;        .ok_or_else(|| magnus::Error::new(magnus::exception::type_error(), &#34;expected string&#34;))?;&#xA;    // error on encodings that would otherwise need converting to utf-8&#xA;    if !r_string.is_utf8_compatible_encoding() {&#xA;        return Err(magnus::Error::new(&#xA;            magnus::exception::encoding_error(),&#xA;            &#34;string must be utf-8&#34;,&#xA;        ));&#xA;    }&#xA;    // RString::as_str is unsafe as it&#39;s possible for Ruby to invalidate the&#xA;    // str as we hold a reference to it. The easiest way to ensure the &amp;amp;str&#xA;    // stays valid is to avoid any other calls to Ruby for the life of the&#xA;    // reference (the rest of the unsafe block).&#xA;    unsafe {&#xA;        let s = r_string.as_str()?;&#xA;        // ...&#xA;    }&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Safety&lt;/h2&gt; &#xA;&lt;p&gt;When using Magnus, in Rust code, Ruby objects must be kept on the stack. If objects are moved to the heap the Ruby GC can not reach them, and they may be garbage collected. This could lead to memory safety issues.&lt;/p&gt; &#xA;&lt;p&gt;It is not possible to enforce this rule in Rust&#39;s type system or via the borrow checker, users of Magnus must maintain this rule manually.&lt;/p&gt; &#xA;&lt;p&gt;An example of something that breaks this rule would be storing a Ruby object in a Rust heap allocated data structure, such as &lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, or &lt;code&gt;Box&lt;/code&gt;. This must be avoided at all costs.&lt;/p&gt; &#xA;&lt;p&gt;While it would be possible to mark any functions that could expose this unsafty as &lt;code&gt;unsafe&lt;/code&gt;, that would mean that almost every interaction with Ruby would be &lt;code&gt;unsafe&lt;/code&gt;. This would leave no way to differentiate the &lt;em&gt;really&lt;/em&gt; unsafe functions that need much more care to use.&lt;/p&gt; &#xA;&lt;p&gt;Other than this, Magnus strives to match Rust&#39;s usual safety guaranties for users of the library. Magnus itself contains a large amount of code marked with the &lt;code&gt;unsafe&lt;/code&gt; keyword, it is impossible to interact with Ruby&#39;s C-api without this, but users of Magnus should be able to do most things without needing to use &lt;code&gt;unsafe&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Compatibility&lt;/h2&gt; &#xA;&lt;p&gt;Ruby versions 2.7, 3.0, 3.1, and 3.2 are fully supported.&lt;/p&gt; &#xA;&lt;p&gt;Magnus currently works with Ruby 2.6, but as this version of the language is no longer supported by the Ruby developers it is not recommended and future support in Magnus is not guaranteed.&lt;/p&gt; &#xA;&lt;p&gt;Ruby bindings will be generated at compile time, this may require libclang to be installed.&lt;/p&gt; &#xA;&lt;p&gt;The Minimum supported Rust version is currently Rust 1.51 (Rust 1.54 on macOS with Xcode 14).&lt;/p&gt; &#xA;&lt;p&gt;Support for statically linking Ruby is provided.&lt;/p&gt; &#xA;&lt;p&gt;Cross-compilation is supported by rb-sys &lt;a href=&#34;https://github.com/oxidize-rb/rb-sys#supported-platforms&#34;&gt;for the platforms listed here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Support for 32 bit systems is almost certainly broken, patches are welcome.&lt;/p&gt; &#xA;&lt;h2&gt;Crates that work with Magnus&lt;/h2&gt; &#xA;&lt;h3&gt;rb-sys&lt;/h3&gt; &#xA;&lt;p&gt;Magnus uses &lt;a href=&#34;https://github.com/oxidize-rb/rb-sys/tree/main/crates/rb-sys&#34;&gt;rb-sys&lt;/a&gt; to provide the low-level bindings to Ruby. The &lt;code&gt;rb-sys-interop&lt;/code&gt; feature enables the &lt;a href=&#34;https://docs.rs/magnus/latest/magnus/rb_sys/index.html&#34;&gt;&lt;code&gt;rb_sys&lt;/code&gt;&lt;/a&gt; module for advanced interoperability with rb-sys, allows you to access low-level Ruby APIs which Magnus does not expose.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;code&gt;serde_magnus&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;serde_magnus&lt;/code&gt; integrates &lt;a href=&#34;https://github.com/serde-rs/serde&#34;&gt;Serde&lt;/a&gt; and Magnus for seamless serialisation and deserialisation of Rust to Ruby data structures and vice versa.&lt;/p&gt; &#xA;&lt;h2&gt;Users&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/matsadler/halton-rb&#34;&gt;&lt;code&gt;halton&lt;/code&gt;&lt;/a&gt; a Ruby gem providing a highly optimised method for generating Halton sequences.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Please open a &lt;a href=&#34;https://github.com/matsadler/magnus/pulls&#34;&gt;pull request&lt;/a&gt; if you&#39;d like your project listed here.&lt;/p&gt; &#xA;&lt;h2&gt;Troubleshooting&lt;/h2&gt; &#xA;&lt;h3&gt;Issues with static linking&lt;/h3&gt; &#xA;&lt;p&gt;If you encounter an error such as &lt;code&gt;symbol not found in flat namespace &#39;_rb_ext_ractor_safe&#39;&lt;/code&gt; when embedding static Ruby, you will need to instruct Cargo not to strip code that it thinks is dead.&lt;/p&gt; &#xA;&lt;p&gt;In you the same directory as your &lt;code&gt;Cargo.toml&lt;/code&gt; file, create a &lt;code&gt;.cargo/config.toml&lt;/code&gt; file with the following contents:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[build]&#xA;# Without this flag, when linking static libruby, the linker removes symbols&#xA;# (such as `_rb_ext_ractor_safe`) which it thinks are dead code... but they are&#xA;# not, and they need to be included for the `embed` feature to work with static&#xA;# Ruby.&#xA;rustflags = [&#34;-C&#34;, &#34;link-dead-code=on&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Alternatives&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/danielpclark/rutie&#34;&gt;rutie&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/nvzqz/rosy&#34;&gt;rosy&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/steveklabnik/ruby-sys&#34;&gt;ruby-sys&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/d-unseductable/ruru&#34;&gt;ruru&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dylanmckay/plugger&#34;&gt;plugger&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/tildeio/helix&#34;&gt;helix&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Naming&lt;/h2&gt; &#xA;&lt;p&gt;Magnus is named after &lt;em&gt;Magnus the Red&lt;/em&gt; a character from the Warhammer 40,000 universe. A sorcerer who believed he could tame the psychic energy of the Warp. Ultimately, his hubris lead to his fall to Chaos, but lets hope using this library turns out better for you.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the MIT license, see LICENSE.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>slawlor/ractor</title>
    <updated>2023-02-19T01:43:15Z</updated>
    <id>tag:github.com,2023-02-19:/slawlor/ractor</id>
    <link href="https://github.com/slawlor/ractor" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust actor framework&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ractor&lt;/h1&gt; &#xA;&lt;p&gt;&lt;em&gt;Pronounced &lt;strong&gt;R&lt;/strong&gt;-aktor&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;A pure-Rust actor framework. Inspired from &lt;a href=&#34;https://www.erlang.org/doc/man/gen_server.html&#34;&gt;Erlang&#39;s &lt;code&gt;gen_server&lt;/code&gt;&lt;/a&gt;, with the speed + performance of Rust!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/slawlor/ractor&#34;&gt;&lt;img alt=&#34;github&#34; src=&#34;https://img.shields.io/badge/github-slawlor/ractor-8da0cb?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=github&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://crates.io/crates/ractor&#34;&gt;&lt;img alt=&#34;crates.io&#34; src=&#34;https://img.shields.io/crates/v/ractor.svg?style=for-the-badge&amp;amp;color=fc8d62&amp;amp;logo=rust&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/ractor&#34;&gt;&lt;img alt=&#34;docs.rs&#34; src=&#34;https://img.shields.io/badge/docs.rs-ractor-66c2a5?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=docs.rs&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://docs.rs/ractor_cluster&#34;&gt;&lt;img alt=&#34;docs.rs&#34; src=&#34;https://img.shields.io/badge/docs.rs-ractor_cluster-66c2a5?style=for-the-badge&amp;amp;labelColor=555555&amp;amp;logo=docs.rs&#34; height=&#34;20&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/slawlor/ractor/actions/workflows/ci.yaml&#34;&gt;&lt;img src=&#34;https://github.com/slawlor/ractor/actions/workflows/ci.yaml/badge.svg?branch=main&#34; alt=&#34;CI/main&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://codecov.io/gh/slawlor/ractor&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/slawlor/ractor/branch/main/graph/badge.svg?token=61AGYYPWBA&#34; alt=&#34;codecov&#34;&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ractor&lt;/code&gt;: &lt;img src=&#34;https://img.shields.io/crates/d/ractor.svg?sanitize=true&#34; alt=&#34;ractor Downloads&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ractor_cluster&lt;/code&gt;: &lt;img src=&#34;https://img.shields.io/crates/d/ractor_cluster.svg?sanitize=true&#34; alt=&#34;ractor_cluster Downloads&#34;&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ractor&lt;/code&gt; tries to solve the problem of building and maintaining an Erlang-like actor framework in Rust. It gives a set of generic primitives and helps automate the supervision tree and management of our actors along with the traditional actor message processing logic. It&#39;s built &lt;em&gt;heavily&lt;/em&gt; on &lt;code&gt;tokio&lt;/code&gt; which is a hard requirement for &lt;code&gt;ractor&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ractor&lt;/code&gt; is a modern actor framework written in 100% rust with NO &lt;code&gt;unsafe&lt;/code&gt; code.&lt;/p&gt; &#xA;&lt;p&gt;Additionally &lt;code&gt;ractor&lt;/code&gt; has a companion library, &lt;code&gt;ractor_cluster&lt;/code&gt; which is needed for &lt;code&gt;ractor&lt;/code&gt; to be deployed in a distributed (cluster-like) scenario. &lt;code&gt;ractor_cluster&lt;/code&gt; is not yet ready for public release, but is work-in-progress and coming shortly!&lt;/p&gt; &#xA;&lt;h3&gt;Why ractor?&lt;/h3&gt; &#xA;&lt;p&gt;There are other actor frameworks written in Rust (&lt;a href=&#34;https://github.com/actix/actix&#34;&gt;Actix&lt;/a&gt;, &lt;a href=&#34;https://github.com/riker-rs/riker&#34;&gt;riker&lt;/a&gt;, or &lt;a href=&#34;https://ryhl.io/blog/actors-with-tokio/&#34;&gt;just actors in Tokio&lt;/a&gt;) plus a whole list compiled on &lt;a href=&#34;https://www.reddit.com/r/rust/comments/n2cmvd/there_are_a_lot_of_actor_framework_projects_on/&#34;&gt;this Reddit post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Ractor tries to be different by modelling more on a pure Erlang &lt;code&gt;gen_server&lt;/code&gt;. This means that each actor can also simply be a supervisor to other actors with no additional cost (simply link them together!). Additionally we&#39;re aiming to maintain close logic with Erlang&#39;s patterns, as they work quite well and are well utilized in the industry.&lt;/p&gt; &#xA;&lt;p&gt;Additionally we wrote &lt;code&gt;ractor&lt;/code&gt; without building on some kind of &#34;Runtime&#34; or &#34;System&#34; which needs to be spawned. Actors can be run independently, in conjunction with other basic &lt;code&gt;tokio&lt;/code&gt; runtimes with little additional overhead.&lt;/p&gt; &#xA;&lt;p&gt;We currently have full support for:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Single-threaded message processing&lt;/li&gt; &#xA; &lt;li&gt;Actor supervision tree&lt;/li&gt; &#xA; &lt;li&gt;Remote procedure calls to actors&lt;/li&gt; &#xA; &lt;li&gt;Timers&lt;/li&gt; &#xA; &lt;li&gt;Named actor registry (&lt;code&gt;ractor::registry&lt;/code&gt;) from &lt;a href=&#34;https://www.erlang.org/doc/reference_manual/processes.html&#34;&gt;Erlang&#39;s &lt;code&gt;Registered processes&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Process groups (&lt;code&gt;ractor::pg&lt;/code&gt;) from &lt;a href=&#34;https://www.erlang.org/doc/man/pg.html&#34;&gt;Erlang&#39;s &lt;code&gt;pg&lt;/code&gt; module&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;On our roadmap is to add more of the Erlang functionality including potentially a distributed actor cluster.&lt;/p&gt; &#xA;&lt;h3&gt;Performance&lt;/h3&gt; &#xA;&lt;p&gt;Actors in &lt;code&gt;ractor&lt;/code&gt; are generally quite lightweight and there are benchmarks which you are welcome to run on your own host system with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo bench -p ractor&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Install &lt;code&gt;ractor&lt;/code&gt; by adding the following to your Cargo.toml dependencies.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;ractor = &#34;0.7&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;ractor&lt;/code&gt; exposes a single feature currently, namely:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;cluster&lt;/code&gt;, which exposes various functionality required for &lt;code&gt;ractor_cluster&lt;/code&gt; to set up and manage a cluster of actors over a network link. This is work-in-progress and is being tracked in &lt;a href=&#34;https://github.com/slawlor/ractor/issues/16&#34;&gt;#16&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Working with Actors&lt;/h2&gt; &#xA;&lt;p&gt;Actors in &lt;code&gt;ractor&lt;/code&gt; are very lightweight and can be treated as thread-safe. Each actor will only call one of its handler functions at a time, and they will never be executed in parallel. Following the actor model leads to microservices with well-defined state and processing logic.&lt;/p&gt; &#xA;&lt;p&gt;An example &lt;code&gt;ping-pong&lt;/code&gt; actor might be the following&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ractor::{cast, Actor, ActorProcessingErr, ActorRef};&#xA;&#xA;/// [PingPong] is a basic actor that will print&#xA;/// ping..pong.. repeatedly until some exit&#xA;/// condition is met (a counter hits 10). Then&#xA;/// it will exit&#xA;pub struct PingPong;&#xA;&#xA;/// This is the types of message [PingPong] supports&#xA;#[derive(Debug, Clone)]&#xA;pub enum Message {&#xA;    Ping,&#xA;    Pong,&#xA;}&#xA;&#xA;impl Message {&#xA;    // retrieve the next message in the sequence&#xA;    fn next(&amp;amp;self) -&amp;gt; Self {&#xA;        match self {&#xA;            Self::Ping =&amp;gt; Self::Pong,&#xA;            Self::Pong =&amp;gt; Self::Ping,&#xA;        }&#xA;    }&#xA;    // print out this message&#xA;    fn print(&amp;amp;self) {&#xA;        match self {&#xA;            Self::Ping =&amp;gt; print!(&#34;ping..&#34;),&#xA;            Self::Pong =&amp;gt; print!(&#34;pong..&#34;),&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;// the implementation of our actor&#39;s &#34;logic&#34;&#xA;#[async_trait::async_trait]&#xA;impl Actor for PingPong {&#xA;    // An actor has a message type&#xA;    type Msg = Message;&#xA;    // and (optionally) internal state&#xA;    type State = u8;&#xA;    // Startup initialization args&#xA;    type Arguments = ();&#xA;&#xA;    // Initially we need to create our state, and potentially&#xA;    // start some internal processing (by posting a message for&#xA;    // example)&#xA;    async fn pre_start(&#xA;        &amp;amp;self,&#xA;        myself: ActorRef&amp;lt;Self&amp;gt;,&#xA;        _: (),&#xA;    ) -&amp;gt; Result&amp;lt;Self::State, ActorProcessingErr&amp;gt; {&#xA;        // startup the event processing&#xA;        cast!(myself, Message::Ping)?;&#xA;        // create the initial state&#xA;        Ok(0u8)&#xA;    }&#xA;&#xA;    // This is our main message handler&#xA;    async fn handle(&#xA;        &amp;amp;self,&#xA;        myself: ActorRef&amp;lt;Self&amp;gt;,&#xA;        message: Self::Msg,&#xA;        state: &amp;amp;mut Self::State,&#xA;    ) -&amp;gt; Result&amp;lt;(), ActorProcessingErr&amp;gt; {&#xA;        if *state &amp;lt; 10u8 {&#xA;            message.print();&#xA;            cast!(myself, message.next())?;&#xA;            *state += 1;&#xA;        } else {&#xA;            println!();&#xA;            myself.stop(None);&#xA;            // don&#39;t send another message, rather stop the agent after 10 iterations&#xA;        }&#xA;        Ok(())&#xA;    }&#xA;}&#xA;&#xA;#[tokio::main]&#xA;async fn main() {&#xA;    let (_actor, handle) = Actor::spawn(None, PingPong, ())&#xA;        .await&#xA;        .expect(&#34;Failed to start ping-pong actor&#34;);&#xA;    handle&#xA;        .await&#xA;        .expect(&#34;Ping-pong actor failed to exit properly&#34;);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which will output&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cargo run&#xA;ping..pong..ping..pong..ping..pong..ping..pong..ping..pong..&#xA;$ &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Messaging actors&lt;/h2&gt; &#xA;&lt;p&gt;The means of communication between actors is that they pass messages to each other. A developer can define any message type which is &lt;code&gt;Send + &#39;static&lt;/code&gt; and it will be supported by &lt;code&gt;ractor&lt;/code&gt;. There are 4 concurrent message types, which are listened to in priority. They are&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Signals: Signals are the highest-priority of all and will interrupt the actor wherever processing currently is (this includes terminating async work). There is only 1 signal today, which is &lt;code&gt;Signal::Kill&lt;/code&gt;, and it immediately terminates all work. This includes message processing or supervision event processing.&lt;/li&gt; &#xA; &lt;li&gt;Stop: There is also a pre-defined stop signal. You can give a &#34;stop reason&#34; if you want, but it&#39;s optional. Stop is a graceful exit, meaning currently executing async work will complete, and on the next message processing iteration Stop will take priority over future supervision events or regular messages. It will &lt;strong&gt;not&lt;/strong&gt; terminate currently executing work, regardless of the provided reason.&lt;/li&gt; &#xA; &lt;li&gt;SupervisionEvent: Supervision events are messages from child actors to their supervisors in the event of their startup, death, and/or unhandled panic. Supervision events are how an actor&#39;s supervisor(s) are notified of events of their children and can handle lifetime events for them.&lt;/li&gt; &#xA; &lt;li&gt;Messages: Regular, user-defined, messages are the last channel of communication to actors. They are the lowest priority of the 4 message types and denote general actor work. The first 3 messages types (signals, stop, supervision) are generally quiet unless it&#39;s a lifecycle event for the actor, but this channel is the &#34;work&#34; channel doing what your actor wants to do!&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Ractor in distributed clusters&lt;/h2&gt; &#xA;&lt;p&gt;Ractor actors can also be used to build a distributed pool of actors, similar to &lt;a href=&#34;https://www.erlang.org/doc/man/epmd.html&#34;&gt;Erlang&#39;s EPMD&lt;/a&gt; which manages inter-node connections + node naming. In our implementation, we have &lt;a href=&#34;https://crates.io/crates/ractor_cluster&#34;&gt;&lt;code&gt;ractor_cluster&lt;/code&gt;&lt;/a&gt; in order to facilitate distributed &lt;code&gt;ractor&lt;/code&gt; actors.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;ractor_cluster&lt;/code&gt; has a single main type in it, namely the &lt;code&gt;NodeServer&lt;/code&gt; which represents a host of a &lt;code&gt;node()&lt;/code&gt; process. It additionally has some macros and a procedural macros to facilitate developer efficiency when building distributed actors. The &lt;code&gt;NodeServer&lt;/code&gt; is responsible for&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Managing all incoming and outgoing &lt;code&gt;NodeSession&lt;/code&gt; actors which represent a remote node connected to this host.&lt;/li&gt; &#xA; &lt;li&gt;Managing the &lt;code&gt;TcpListener&lt;/code&gt; which hosts the server socket to accept incoming session requests.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;The bulk of the logic for node interconnections however is held in the &lt;code&gt;NodeSession&lt;/code&gt; which manages&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;The underlying TCP connection managing reading and writing to the stream.&lt;/li&gt; &#xA; &lt;li&gt;The authentication between this node and the connection to the peer&lt;/li&gt; &#xA; &lt;li&gt;Managing actor lifecycle for actors spawned on the remote system.&lt;/li&gt; &#xA; &lt;li&gt;Transmitting all inter-actor messages between nodes.&lt;/li&gt; &#xA; &lt;li&gt;Managing PG group synchronization&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;etc..&lt;/p&gt; &#xA;&lt;p&gt;The &lt;code&gt;NodeSession&lt;/code&gt; makes local actors available on a remote system by spawning &lt;code&gt;RemoteActor&lt;/code&gt;s which are essentially untyped actors that only handle serialized messages, leaving message deserialization up to the originating system. It also keeps track of pending RPC requests, to match request to response upon reply. There are special extension points in &lt;code&gt;ractor&lt;/code&gt; which are added to specifically support &lt;code&gt;RemoteActor&lt;/code&gt;s that aren&#39;t generally meant to be used outside of the standard&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;Actor::spawn(Some(&#34;name&#34;.to_string()), MyActor).await&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;pattern.&lt;/p&gt; &#xA;&lt;h3&gt;Designing remote-supported actors&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; not all actors are created equal. Actors need to support having their message types sent over the network link. This is done by overriding specific methods of the &lt;code&gt;ractor::Message&lt;/code&gt; trait all messages need to support. Due to the lack of specialization support in Rust, if you choose to use &lt;code&gt;ractor_cluster&lt;/code&gt; you&#39;ll need to derive the &lt;code&gt;ractor::Message&lt;/code&gt; trait for &lt;strong&gt;all&lt;/strong&gt; message types in your crate. However to support this, we have a few procedural macros to make this a more painless process&lt;/p&gt; &#xA;&lt;h4&gt;Deriving the basic Message trait for in-process only actors&lt;/h4&gt; &#xA;&lt;p&gt;Many actors are going to be local-only and have no need sending messages over the network link. This is the most basic scenario and in this case the default &lt;code&gt;ractor::Message&lt;/code&gt; trait implementation is fine. You can derive it quickly with:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ractor_cluster::RactorMessage;&#xA;use ractor::RpcReplyPort;&#xA;&#xA;#[derive(RactorMessage)]&#xA;enum MyBasicMessageType {&#xA;    Cast1(String, u64),&#xA;    Call1(u8, i64, RpcReplyPort&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This will implement the default &lt;code&gt;ractor::Message&lt;/code&gt; trait for you without you having to write it out by hand.&lt;/p&gt; &#xA;&lt;h4&gt;Deriving the network serializable message trait for remote actors&lt;/h4&gt; &#xA;&lt;p&gt;If you want your actor to &lt;em&gt;support&lt;/em&gt; remoting, then you should use a different derive statement, namely:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use ractor_cluster::RactorClusterMessage;&#xA;use ractor::RpcReplyPort;&#xA;&#xA;#[derive(RactorClusterMessage)]&#xA;enum MyBasicMessageType {&#xA;    Cast1(String, u64),&#xA;    #[rpc]&#xA;    Call1(u8, i64, RpcReplyPort&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;),&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which adds a significant amount of underlying boilerplate (take a look yourself with &lt;code&gt;cargo expand&lt;/code&gt;!) for the implementation. But the short answer is, each enum variant needs to serialize to a byte array of arguments, a variant name, and if it&#39;s an RPC give a port that receives a byte array and de-serialize the reply back. Each of the types inside of either the arguments or reply type need to implement the &lt;code&gt;ractor_cluster::BytesConvertable&lt;/code&gt; trait which just says this value can be written to a byte array and decoded from a byte array. If you&#39;re using &lt;code&gt;prost&lt;/code&gt; for your message type definitions (protobuf), we have a macro to auto-implement this for your types.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;ractor_cluster::derive_serialization_for_prost_type! {MyProtobufType}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Besides that, just write your actor as you would. The actor itself will live where you define it and will be capable of receiving messages sent over the network link from other clusters!&lt;/p&gt; &#xA;&lt;h2&gt;Contributors&lt;/h2&gt; &#xA;&lt;p&gt;The original authors of &lt;code&gt;ractor&lt;/code&gt; are Sean Lawlor (@slawlor), Dillon George (@dillonrg), and Evan Au (@afterdusk). To learn more about contributing to &lt;code&gt;ractor&lt;/code&gt; please see &lt;a href=&#34;https://github.com/slawlor/ractor/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under &lt;a href=&#34;https://github.com/slawlor/ractor/raw/main/LICENSE&#34;&gt;MIT&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>