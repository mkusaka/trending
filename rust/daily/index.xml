<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-07T01:46:02Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>orlp/glidesort</title>
    <updated>2023-02-07T01:46:02Z</updated>
    <id>tag:github.com,2023-02-07:/orlp/glidesort</id>
    <link href="https://github.com/orlp/glidesort" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Rust implementation of Glidesort, my stable adaptive quicksort/mergesort hybrid sorting algorithm.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Glidesort&lt;/h1&gt; &#xA;&lt;p&gt;Glidesort is a novel stable sorting algorithm that combines the best-case behavior of Timsort-style merge sorts for pre-sorted data with the best-case behavior of &lt;a href=&#34;https://github.com/orlp/pdqsort&#34;&gt;pattern-defeating quicksort&lt;/a&gt; for data with many duplicates. It is a comparison-based sort supporting arbitrary comparison operators, and while exceptional on data with patterns it is also very fast for random data.&lt;/p&gt; &#xA;&lt;p&gt;For sorting &lt;code&gt;n&lt;/code&gt; elements with &lt;code&gt;k&lt;/code&gt; distinct values glidesort has the following characteristics by default:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Best    Average     Worst       Memory      Stable      Deterministic&#xA;n       n log k     n log n     n / 8       Yes         Yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Glidesort can use as much (up to &lt;code&gt;n&lt;/code&gt;) or as little extra memory as you want. If given only &lt;code&gt;O(1)&lt;/code&gt; memory the average and worst case become &lt;code&gt;O(n (log n)^2)&lt;/code&gt;, however in practice its performance is great for all but the most skewed data size / auxiliary space ratios. The default is to allocate up to &lt;code&gt;n&lt;/code&gt; elements worth of data, unless this exceeds 1 MiB, in which case we scale this down to &lt;code&gt;n / 2&lt;/code&gt; elements worth of data up until 1 GiB after which glidesort uses &lt;code&gt;n / 8&lt;/code&gt; memory.&lt;/p&gt; &#xA;&lt;h1&gt;Benchmark&lt;/h1&gt; &#xA;&lt;p&gt;Performance varies a lot from machine to machine and dataset to dataset, so your mileage will vary. Nevertheless, an example benchmark from a 2021 Apple M1 machine comparing against &lt;code&gt;[T]::sort&lt;/code&gt; and &lt;code&gt;[T]::sort_unstable&lt;/code&gt; for various input distributions of &lt;code&gt;u64&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8fIACqY.png&#34; alt=&#34;Performance graph&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Compiled with &lt;code&gt;rustc 1.69.0-nightly (11d96b593)&lt;/code&gt; using &lt;code&gt;--release --features unstable&lt;/code&gt; and &lt;code&gt;lto = &#34;thin&#34;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Usage&lt;/h1&gt; &#xA;&lt;p&gt;Use &lt;code&gt;cargo add glidesort&lt;/code&gt; and replace &lt;code&gt;a.sort()&lt;/code&gt; with &lt;code&gt;glidesort::sort(&amp;amp;mut a)&lt;/code&gt;. A similar process works for &lt;code&gt;sort_by&lt;/code&gt; and &lt;code&gt;sort_by_key&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Glidesort exposes two more families of sorting functions. &lt;code&gt;glidesort::sort_with_buffer(&amp;amp;mut a, buf)&lt;/code&gt; asks you to pass a &lt;code&gt;&amp;amp;mut [MaybeUninit&amp;lt;T&amp;gt;]&lt;/code&gt; buffer which it will then (exclusively) use as auxiliary space to sort the elements. &lt;code&gt;glidesort::sort_in_vec(&amp;amp;mut v)&lt;/code&gt; behaves like normal glidesort but will allocate its auxiliary space at the end of the passed &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This allows future sorting calls to re-use the same space and reduce allocations. Both these families also support the &lt;code&gt;_by&lt;/code&gt; and &lt;code&gt;_by_key&lt;/code&gt; interface.&lt;/p&gt; &#xA;&lt;h1&gt;Visualization&lt;/h1&gt; &#xA;&lt;p&gt;This visualization focuses on demonstrating the advanced merging techniques in glidesort:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/202547/216675278-e4c8f15c-e42d-4224-b8c7-fdc67fdc2bde.mp4&#34;&gt;https://user-images.githubusercontent.com/202547/216675278-e4c8f15c-e42d-4224-b8c7-fdc67fdc2bde.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;This visualization shows how glidesort is adaptive to both pre-existing runs as well as many duplicates together:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://user-images.githubusercontent.com/202547/216675274-6e61689f-a120-4b7c-b1a7-9b5aa5fd013e.mp4&#34;&gt;https://user-images.githubusercontent.com/202547/216675274-6e61689f-a120-4b7c-b1a7-9b5aa5fd013e.mp4&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Note that both visualizations have different small sorting thresholds and auxiliary memory parameters to show the techniques in action on a smaller scale.&lt;/p&gt; &#xA;&lt;h1&gt;Technique overview&lt;/h1&gt; &#xA;&lt;p&gt;If you prefer I also have a recorded talk I gave at FOSDEM 2023 that gives a high level overview of glidesort:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://fosdem.org/2023/schedule/event/rust_glidesort/&#34;&gt;&lt;img src=&#34;https://i.imgur.com/Lcl0KbI.png&#34; alt=&#34;Talk recording preview&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Glidesort uses a novel main loop based on powersort. Powersort is similar to Timsort, using heuristics to find a good order of stably merging sorted runs. Like powersort it does a linear scan over the input, recognizing any ascending or strictly descending sequences. However, unlike powersort it does not eagerly sort sequences that are considered unordered into small sorted blocks. Instead it processes them as-is, unsorted. This process produces &lt;em&gt;logical runs&lt;/em&gt;, which may be sorted or unsorted.&lt;/p&gt; &#xA;&lt;p&gt;Glidesort repeatedly uses a &lt;em&gt;logical&lt;/em&gt; merge operation on these logical runs, as powersort would. In a logical merge unsorted runs are simply concatenated into larger unsorted runs. Sorted runs are also concatenated into &lt;em&gt;double sorted&lt;/em&gt; runs. Only when merging a sorted and unsorted run finally the unsorted run is sorted using stable quicksort, and when merging double sorted runs glidesort uses interleaved ping-pong merges.&lt;/p&gt; &#xA;&lt;p&gt;Using this novel hybrid approach glidesort can take advantage of arbitrary sorted runs in the data as well as process data with many duplicate items faster similar to pattern-defeating quicksort.&lt;/p&gt; &#xA;&lt;h1&gt;Stable merging&lt;/h1&gt; &#xA;&lt;p&gt;Glidesort merges multiple sorted runs at the same time, and interleaves their merging loops for better memory-level and instruction-level parallelism as well as hiding data dependencies. For similar reasons it also interleaves independent left-to-right and right-to-left merging loops as bidirectional merges, which are a generalization of &lt;a href=&#34;https://github.com/scandum/quadsort&#34;&gt;quadsort&lt;/a&gt;s parity merges. Merging multiple runs at the same time also lets glidesort use ping-pong merging, avoiding unnecessary &lt;code&gt;memcpy&lt;/code&gt; calls by using the implicit copy you get from an out-of-place merge. All merging loops are completely branchless, making it fast for random data as well.&lt;/p&gt; &#xA;&lt;p&gt;Glidesort further uses binary searches to split up large merge operations into smaller merge operations that it then performs at the same time using instruction-level parallelism. This splitting procedure also allows glidesort to use arbitrarily small amounts of memory, as it can choose to split a merge repeatedly until it fits in our scratch space to process.&lt;/p&gt; &#xA;&lt;h1&gt;Stable quicksort&lt;/h1&gt; &#xA;&lt;p&gt;Yes, stable quicksort. Wikipedia will outright tell you that quicksort is unstable, or at least all efficient implementations are. That simply isn&#39;t true, all it needs is auxiliary memory. Credit to Igor van den Hoven&#39;s &lt;a href=&#34;https://github.com/scandum/fluxsort&#34;&gt;fluxsort&lt;/a&gt; for demonstrating that stable quicksort can be efficient in practice.&lt;/p&gt; &#xA;&lt;p&gt;Glidesort uses a novel bidirectional stable partitioning method that interleaves a left-to-right partition scan with a right-to-left partition scan for greater memory-level parallelism and hiding data dependencies. Partitioning is done entirely branchlessly (if the comparison operator is), giving consistent performance on all data.&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;Glidesort is dual-licensed under the Apache License, Version 2.0 and the MIT license.&lt;/p&gt;</summary>
  </entry>
</feed>