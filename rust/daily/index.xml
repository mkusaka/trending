<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-03T01:35:10Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>yujqiao/rathole</title>
    <updated>2025-06-03T01:35:10Z</updated>
    <id>tag:github.com,2025-06-03:/yujqiao/rathole</id>
    <link href="https://github.com/yujqiao/rathole" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A lightweight and high-performance reverse proxy for NAT traversal, written in Rust. An alternative to frp and ngrok.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rathole&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/img/rathole-logo.png&#34; alt=&#34;rathole-logo&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/rapiz1/rathole/stargazers&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/rapiz1/rathole&#34; alt=&#34;GitHub stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/rapiz1/rathole/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/v/release/rapiz1/rathole&#34; alt=&#34;GitHub release (latest SemVer)&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/github/actions/workflow/status/rapiz1/rathole/rust.yml?branch=main&#34; alt=&#34;GitHub Workflow Status (branch)&#34;&gt; &lt;a href=&#34;https://github.com/rapiz1/rathole/releases&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/downloads/rapiz1/rathole/total&#34; alt=&#34;GitHub all releases&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://hub.docker.com/r/rapiz1/rathole&#34;&gt;&lt;img src=&#34;https://img.shields.io/docker/pulls/rapiz1/rathole&#34; alt=&#34;Docker Pulls&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://gitter.im/rapiz1/rathole?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge&#34;&gt;&lt;img src=&#34;https://badges.gitter.im/rapiz1/rathole.svg?sanitize=true&#34; alt=&#34;Join the chat at https://gitter.im/rapiz1/rathole&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/README-zh.md&#34;&gt;简体中文&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A secure, stable and high-performance reverse proxy for NAT traversal, written in Rust&lt;/p&gt; &#xA;&lt;p&gt;rathole, like &lt;a href=&#34;https://github.com/fatedier/frp&#34;&gt;frp&lt;/a&gt; and &lt;a href=&#34;https://github.com/inconshreveable/ngrok&#34;&gt;ngrok&lt;/a&gt;, can help to expose the service on the device behind the NAT to the Internet, via a server with a public IP.&lt;/p&gt; &#xA;&lt;!-- TOC --&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#rathole&#34;&gt;rathole&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#configuration&#34;&gt;Configuration&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#logging&#34;&gt;Logging&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#tuning&#34;&gt;Tuning&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#benchmark&#34;&gt;Benchmark&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#planning&#34;&gt;Planning&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- /TOC --&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;High Performance&lt;/strong&gt; Much higher throughput can be achieved than frp, and more stable when handling a large volume of connections. See &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#benchmark&#34;&gt;Benchmark&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Low Resource Consumption&lt;/strong&gt; Consumes much fewer memory than similar tools. See &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#benchmark&#34;&gt;Benchmark&lt;/a&gt;. &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/build-guide.md&#34;&gt;The binary can be&lt;/a&gt; &lt;strong&gt;as small as ~500KiB&lt;/strong&gt; to fit the constraints of devices, like embedded devices as routers.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt; Tokens of services are mandatory and service-wise. The server and clients are responsible for their own configs. With the optional Noise Protocol, encryption can be configured at ease. No need to create a self-signed certificate! TLS is also supported.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Hot Reload&lt;/strong&gt; Services can be added or removed dynamically by hot-reloading the configuration file. HTTP API is WIP.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;A full-powered &lt;code&gt;rathole&lt;/code&gt; can be obtained from the &lt;a href=&#34;https://github.com/rapiz1/rathole/releases&#34;&gt;release&lt;/a&gt; page. Or &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/build-guide.md&#34;&gt;build from source&lt;/a&gt; &lt;strong&gt;for other platforms and minimizing the binary&lt;/strong&gt;. A &lt;a href=&#34;https://hub.docker.com/r/rapiz1/rathole&#34;&gt;Docker image&lt;/a&gt; is also available.&lt;/p&gt; &#xA;&lt;p&gt;The usage of &lt;code&gt;rathole&lt;/code&gt; is very similar to frp. If you have experience with the latter, then the configuration is very easy for you. The only difference is that configuration of a service is split into the client side and the server side, and a token is mandatory.&lt;/p&gt; &#xA;&lt;p&gt;To use &lt;code&gt;rathole&lt;/code&gt;, you need a server with a public IP, and a device behind the NAT, where some services that need to be exposed to the Internet.&lt;/p&gt; &#xA;&lt;p&gt;Assuming you have a NAS at home behind the NAT, and want to expose its ssh service to the Internet:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;On the server which has a public IP&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Create &lt;code&gt;server.toml&lt;/code&gt; with the following content and accommodate it to your needs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# server.toml&#xA;[server]&#xA;bind_addr = &#34;0.0.0.0:2333&#34; # `2333` specifies the port that rathole listens for clients&#xA;&#xA;[server.services.my_nas_ssh]&#xA;token = &#34;use_a_secret_that_only_you_know&#34; # Token that is used to authenticate the client for the service. Change to an arbitrary value.&#xA;bind_addr = &#34;0.0.0.0:5202&#34; # `5202` specifies the port that exposes `my_nas_ssh` to the Internet&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./rathole server.toml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;2&#34;&gt; &#xA; &lt;li&gt;On the host which is behind the NAT (your NAS)&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Create &lt;code&gt;client.toml&lt;/code&gt; with the following content and accommodate it to your needs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# client.toml&#xA;[client]&#xA;remote_addr = &#34;myserver.com:2333&#34; # The address of the server. The port must be the same with the port in `server.bind_addr`&#xA;&#xA;[client.services.my_nas_ssh]&#xA;token = &#34;use_a_secret_that_only_you_know&#34; # Must be the same with the server to pass the validation&#xA;local_addr = &#34;127.0.0.1:22&#34; # The address of the service that needs to be forwarded&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./rathole client.toml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ol start=&#34;3&#34;&gt; &#xA; &lt;li&gt;Now the client will try to connect to the server &lt;code&gt;myserver.com&lt;/code&gt; on port &lt;code&gt;2333&lt;/code&gt;, and any traffic to &lt;code&gt;myserver.com:5202&lt;/code&gt; will be forwarded to the client&#39;s port &lt;code&gt;22&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;So you can &lt;code&gt;ssh myserver.com:5202&lt;/code&gt; to ssh to your NAS.&lt;/p&gt; &#xA;&lt;p&gt;To run &lt;code&gt;rathole&lt;/code&gt; run as a background service on Linux, checkout the &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/examples/systemd&#34;&gt;systemd examples&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;rathole&lt;/code&gt; can automatically determine to run in the server mode or the client mode, according to the content of the configuration file, if only one of &lt;code&gt;[server]&lt;/code&gt; and &lt;code&gt;[client]&lt;/code&gt; block is present, like the example in &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/#quickstart&#34;&gt;Quickstart&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;But the &lt;code&gt;[client]&lt;/code&gt; and &lt;code&gt;[server]&lt;/code&gt; block can also be put in one file. Then on the server side, run &lt;code&gt;rathole --server config.toml&lt;/code&gt; and on the client side, run &lt;code&gt;rathole --client config.toml&lt;/code&gt; to explicitly tell &lt;code&gt;rathole&lt;/code&gt; the running mode.&lt;/p&gt; &#xA;&lt;p&gt;Before heading to the full configuration specification, it&#39;s recommend to skim &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/examples&#34;&gt;the configuration examples&lt;/a&gt; to get a feeling of the configuration format.&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/transport.md&#34;&gt;Transport&lt;/a&gt; for more details about encryption and the &lt;code&gt;transport&lt;/code&gt; block.&lt;/p&gt; &#xA;&lt;p&gt;Here is the full configuration specification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[client]&#xA;remote_addr = &#34;example.com:2333&#34; # Necessary. The address of the server&#xA;default_token = &#34;default_token_if_not_specify&#34; # Optional. The default token of services, if they don&#39;t define their own ones&#xA;heartbeat_timeout = 40 # Optional. Set to 0 to disable the application-layer heartbeat test. The value must be greater than `server.heartbeat_interval`. Default: 40 seconds&#xA;retry_interval = 1 # Optional. The interval between retry to connect to the server. Default: 1 second&#xA;&#xA;[client.transport] # The whole block is optional. Specify which transport to use&#xA;type = &#34;tcp&#34; # Optional. Possible values: [&#34;tcp&#34;, &#34;tls&#34;, &#34;noise&#34;]. Default: &#34;tcp&#34;&#xA;&#xA;[client.transport.tcp] # Optional. Also affects `noise` and `tls`&#xA;proxy = &#34;socks5://user:passwd@127.0.0.1:1080&#34; # Optional. The proxy used to connect to the server. `http` and `socks5` is supported.&#xA;nodelay = true # Optional. Determine whether to enable TCP_NODELAY, if applicable, to improve the latency but decrease the bandwidth. Default: true&#xA;keepalive_secs = 20 # Optional. Specify `tcp_keepalive_time` in `tcp(7)`, if applicable. Default: 20 seconds&#xA;keepalive_interval = 8 # Optional. Specify `tcp_keepalive_intvl` in `tcp(7)`, if applicable. Default: 8 seconds&#xA;&#xA;[client.transport.tls] # Necessary if `type` is &#34;tls&#34;&#xA;trusted_root = &#34;ca.pem&#34; # Necessary. The certificate of CA that signed the server&#39;s certificate&#xA;hostname = &#34;example.com&#34; # Optional. The hostname that the client uses to validate the certificate. If not set, fallback to `client.remote_addr`&#xA;&#xA;[client.transport.noise] # Noise protocol. See `docs/transport.md` for further explanation&#xA;pattern = &#34;Noise_NK_25519_ChaChaPoly_BLAKE2s&#34; # Optional. Default value as shown&#xA;local_private_key = &#34;key_encoded_in_base64&#34; # Optional&#xA;remote_public_key = &#34;key_encoded_in_base64&#34; # Optional&#xA;&#xA;[client.transport.websocket] # Necessary if `type` is &#34;websocket&#34;&#xA;tls = true # If `true` then it will use settings in `client.transport.tls`&#xA;&#xA;[client.services.service1] # A service that needs forwarding. The name `service1` can change arbitrarily, as long as identical to the name in the server&#39;s configuration&#xA;type = &#34;tcp&#34; # Optional. The protocol that needs forwarding. Possible values: [&#34;tcp&#34;, &#34;udp&#34;]. Default: &#34;tcp&#34;&#xA;token = &#34;whatever&#34; # Necessary if `client.default_token` not set&#xA;local_addr = &#34;127.0.0.1:1081&#34; # Necessary. The address of the service that needs to be forwarded&#xA;nodelay = true # Optional. Override the `client.transport.nodelay` per service&#xA;retry_interval = 1 # Optional. The interval between retry to connect to the server. Default: inherits the global config&#xA;&#xA;[client.services.service2] # Multiple services can be defined&#xA;local_addr = &#34;127.0.0.1:1082&#34;&#xA;&#xA;[server]&#xA;bind_addr = &#34;0.0.0.0:2333&#34; # Necessary. The address that the server listens for clients. Generally only the port needs to be change.&#xA;default_token = &#34;default_token_if_not_specify&#34; # Optional&#xA;heartbeat_interval = 30 # Optional. The interval between two application-layer heartbeat. Set to 0 to disable sending heartbeat. Default: 30 seconds&#xA;&#xA;[server.transport] # Same as `[client.transport]`&#xA;type = &#34;tcp&#34;&#xA;&#xA;[server.transport.tcp] # Same as the client&#xA;nodelay = true&#xA;keepalive_secs = 20&#xA;keepalive_interval = 8&#xA;&#xA;[server.transport.tls] # Necessary if `type` is &#34;tls&#34;&#xA;pkcs12 = &#34;identify.pfx&#34; # Necessary. pkcs12 file of server&#39;s certificate and private key&#xA;pkcs12_password = &#34;password&#34; # Necessary. Password of the pkcs12 file&#xA;&#xA;[server.transport.noise] # Same as `[client.transport.noise]`&#xA;pattern = &#34;Noise_NK_25519_ChaChaPoly_BLAKE2s&#34;&#xA;local_private_key = &#34;key_encoded_in_base64&#34;&#xA;remote_public_key = &#34;key_encoded_in_base64&#34;&#xA;&#xA;[server.transport.websocket] # Necessary if `type` is &#34;websocket&#34;&#xA;tls = true # If `true` then it will use settings in `server.transport.tls`&#xA;&#xA;[server.services.service1] # The service name must be identical to the client side&#xA;type = &#34;tcp&#34; # Optional. Same as the client `[client.services.X.type]&#xA;token = &#34;whatever&#34; # Necessary if `server.default_token` not set&#xA;bind_addr = &#34;0.0.0.0:8081&#34; # Necessary. The address of the service is exposed at. Generally only the port needs to be change.&#xA;nodelay = true # Optional. Same as the client&#xA;&#xA;[server.services.service2]&#xA;bind_addr = &#34;0.0.0.1:8082&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Logging&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;rathole&lt;/code&gt;, like many other Rust programs, use environment variables to control the logging level. &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt;, &lt;code&gt;trace&lt;/code&gt; are available.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;RUST_LOG=error ./rathole config.toml&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;will run &lt;code&gt;rathole&lt;/code&gt; with only error level logging.&lt;/p&gt; &#xA;&lt;p&gt;If &lt;code&gt;RUST_LOG&lt;/code&gt; is not present, the default logging level is &lt;code&gt;info&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Tuning&lt;/h3&gt; &#xA;&lt;p&gt;From v0.4.7, rathole enables TCP_NODELAY by default, which should benefit the latency and interactive applications like rdp, Minecraft servers. However, it slightly decreases the bandwidth.&lt;/p&gt; &#xA;&lt;p&gt;If the bandwidth is more important, TCP_NODELAY can be opted out with &lt;code&gt;nodelay = false&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmark&lt;/h2&gt; &#xA;&lt;p&gt;rathole has similar latency to &lt;a href=&#34;https://github.com/fatedier/frp&#34;&gt;frp&lt;/a&gt;, but can handle a more connections, provide larger bandwidth, with less memory usage.&lt;/p&gt; &#xA;&lt;p&gt;For more details, see the separate page &lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/benchmark.md&#34;&gt;Benchmark&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;However, don&#39;t take it from here that &lt;code&gt;rathole&lt;/code&gt; can magically make your forwarded service faster several times than before.&lt;/strong&gt; The benchmark is done on local loopback, indicating the performance when the task is cpu-bounded. One can gain quite a improvement if the network is not the bottleneck. Unfortunately, that&#39;s not true for many users. In that case, the main benefit is lower resource consumption, while the bandwidth and the latency may not improved significantly.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/img/http_throughput.svg?sanitize=true&#34; alt=&#34;http_throughput&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/img/tcp_bitrate.svg?sanitize=true&#34; alt=&#34;tcp_bitrate&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/img/udp_bitrate.svg?sanitize=true&#34; alt=&#34;udp_bitrate&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/img/mem-graph.png&#34; alt=&#34;mem&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Planning&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; HTTP APIs for configuration&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/yujqiao/rathole/main/docs/out-of-scope.md&#34;&gt;Out of Scope&lt;/a&gt; lists features that are not planned to be implemented and why.&lt;/p&gt;</summary>
  </entry>
</feed>