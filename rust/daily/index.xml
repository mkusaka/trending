<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-09T01:36:16Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>fasterthanlime/rc-zip</title>
    <updated>2024-02-09T01:36:16Z</updated>
    <id>tag:github.com,2024-02-09:/fasterthanlime/rc-zip</id>
    <link href="https://github.com/fasterthanlime/rc-zip" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Pure rust zip &amp; zip64 reading&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;rc-zip&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/fasterthanlime/rc-zip/actions/workflows/test.yml?query=branch%3Amain&#34;&gt;&lt;img src=&#34;https://github.com/fasterthanlime/rc-zip/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;test pipeline&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://codecov.io/gh/fasterthanlime/rc-zip/&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/fasterthanlime/rc-zip/branch/main/graph/badge.svg?sanitize=true&#34; alt=&#34;Coverage Status (codecov.io)&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Motivation&lt;/h3&gt; &#xA;&lt;p&gt;Have a pure rust, highly compatible, I/O-model-independent, zip reading and writing library.&lt;/p&gt; &#xA;&lt;p&gt;(Note: as of now, rc-zip does reading only)&lt;/p&gt; &#xA;&lt;h3&gt;Funding&lt;/h3&gt; &#xA;&lt;p&gt;Thanks to these companies for contracting work on rc-zip:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://rowzero.io&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/fasterthanlime/rc-zip/main/static/row-zero.svg?sanitize=true&#34; alt=&#34;Row Zero&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;And thanks to all my &lt;a href=&#34;https://fasterthanli.me/donate&#34;&gt;individual sponsors&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Design decisions&lt;/h3&gt; &#xA;&lt;p&gt;The core of this crate does not perform I/O directly. Instead, it uses a state machine, and asks for reads at specific offsets. This allows it to work under different I/O models: blocking, non-blocking, and async. It has no expectations of the zip archive being present on disk (ie. it doesn&#39;t assume &lt;code&gt;std::fs&lt;/code&gt;), just that random access is possible.&lt;/p&gt; &#xA;&lt;p&gt;The recommended interface relies on the central directory rather than local headers:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[local file header 1] // &amp;lt;---------------- ignored&#xA;[file data 1]&#xA;[local file header 2]&#xA;[file data 2]&#xA;[central directory header 1] // &amp;lt;--------- used&#xA;[central directory header 2]&#xA;[end of central directory record]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The reason for that is that the central directory is the canonical list of entries in a zip. Archives that have been repacked may contain duplicate local file headers (and data), along with headers for entries that have been removed. Only the central directory is authoritative when it comes to the contents of a zip archive.&lt;/p&gt; &#xA;&lt;p&gt;However, as of v4.0.0, a streaming decompression interface was added to both &lt;code&gt;rc-zip-sync&lt;/code&gt; and &lt;code&gt;rc-zip-tokio&lt;/code&gt;, in the form of the &lt;code&gt;ReadZipStreaming&lt;/code&gt; traits.&lt;/p&gt; &#xA;&lt;p&gt;This crate accepts what is known as &#34;trailing zips&#34; - for example, files that are valid ELF or PE executables, and merely have a valid zip archive appended. This covers some forms of self-extracting archives and installers.&lt;/p&gt; &#xA;&lt;p&gt;This crate recognizes and uses zip64 metadata. This allows for a large number of entries (above 65536) and large entries (above 4GiB). This crate attempts to forgives some non-standard behavior from common tools. Such behavior has been observed in the wild and is, whenever possible, tested.&lt;/p&gt; &#xA;&lt;p&gt;This crate attempts to recognize as much metadata as possible, and normalize it. For example, MSDOS timestamps, NTFS timestamps, Extended timestamps and Unix timestamps are supported, and they&#39;re all converted to a &lt;a href=&#34;https://crates.io/crates/chrono&#34;&gt;chrono DateTime&#xA;  &lt;utc&gt;&lt;/utc&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Although the normalized version of metadata (names, timestamps, UID, GID, etc.) is put front and center, this crate attempts to expose a &#34;raw&#34; version of that same metadata whenever the authors felt it was necessary.&lt;/p&gt; &#xA;&lt;p&gt;Whenever the zip archive doesn&#39;t explicitly specify UTF-8 encoding, this crate relies on encoding detection to decide between CP-437 and Shift-JIS. It uses &lt;a href=&#34;https://crates.io/crates/encoding_rs&#34;&gt;encoding_rs&lt;/a&gt; to deal with Shift-JIS.&lt;/p&gt; &#xA;&lt;p&gt;Due to the history of the zip format, some compatibility issues are to be expected: for example, for archives with only MSDOS timestamps, the results might be in the wrong timezone. For archive with very few files and non-UTF8 names, the encoding might not be detected properly, and thus decoding may fail.&lt;/p&gt; &#xA;&lt;p&gt;As much as possible, &lt;a href=&#34;https://crates.io/crates/winnow&#34;&gt;winnow&lt;/a&gt; is used to parse the various data structures used in the zip archive format. This allows a semi-declarative style that is easier to write, read, and amend if needed. Some (hygienic) macros are used to avoid repetition.&lt;/p&gt; &#xA;&lt;h3&gt;API design&lt;/h3&gt; &#xA;&lt;p&gt;The design of the API is constrained by several parameters:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A compliant zip reader &lt;em&gt;must&lt;/em&gt; first read the central directory, located near the end of the zip archive. This means simply taking an &lt;code&gt;Read&lt;/code&gt; won&#39;t do.&lt;/li&gt; &#xA; &lt;li&gt;Multiple I/O models must be supported. Whereas other crates focus on taking a &lt;code&gt;Read&lt;/code&gt;, a &lt;code&gt;Read + Seek&lt;/code&gt;, or simply a byte slice, this crate aims to support synchronous &lt;em&gt;and&lt;/em&gt; asynchronous I/O.&lt;/li&gt; &#xA; &lt;li&gt;Not everyone wants a compliant zip reader. Some may want to rely on local headers instead, completely ignoring the central directory, thus throwing caution to the wind.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As a result, the structs in this crate are state machines, that advertise their need to read (and from where), to process data, or to write. I/O errors are cleanly separated from the rest, and calls to this crate never block.&lt;/p&gt; &#xA;&lt;p&gt;Separate crates add specific I/O models on top of rc-zip, see the &lt;a href=&#34;https://crates.io/crates/rc-zip-sync&#34;&gt;rc-zip-sync&lt;/a&gt; and &lt;a href=&#34;https://crates.io/crates/rc-zip-tokio&#34;&gt;rc-zip-tokio&lt;/a&gt; crates.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;This project is primarily distributed under the terms of both the MIT license and the Apache License (Version 2.0).&lt;/p&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/fasterthanlime/rc-zip/main/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/fasterthanlime/rc-zip/main/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; for details.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>facebook/dotslash</title>
    <updated>2024-02-09T01:36:16Z</updated>
    <id>tag:github.com,2024-02-09:/facebook/dotslash</id>
    <link href="https://github.com/facebook/dotslash" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Simplified executable deployment&lt;/p&gt;&lt;hr&gt;&lt;div class=&#34;title-block&#34; style=&#34;text-align: center;&#34; align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;DotSlash: simplified executable deployment&lt;/h1&gt; &#xA; &lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-blueviolet.svg?sanitize=true&#34; alt=&#34;License&#34;&gt; &lt;a href=&#34;https://github.com/facebook/dotslash/actions/workflows/build.yml&#34;&gt;&lt;img src=&#34;https://github.com/facebook/dotslash/actions/workflows/build.yml/badge.svg?branch=main&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;DotSlash (&lt;code&gt;dotslash&lt;/code&gt;) is a command-line tool that lets you represent a set of platform-specific, heavyweight executables with an equivalent small, easy-to-read text file. In turn, this makes it efficient to store executables in source control without hurting repository size. This paves the way for checking build toolchains and other tools directly into the repo, reducing dependencies on the host environment and thereby facilitating reproducible builds.&lt;/p&gt; &#xA;&lt;p&gt;We will illustrate this with &lt;a href=&#34;https://dotslash-cli.com/docs/&#34;&gt;an example taken from the DotSlash website&lt;/a&gt;. Traditionally, if you want to vendor a specific version of Node.js into your project and you want to support both macOS and Linux, you likely need at least two binaries (one for macOS and one for Linux) as well as a shell script like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash&#xA;&#xA;# Copied from https://stackoverflow.com/a/246128.&#xA;DIR=&#34;$( cd -- &#34;$( dirname -- &#34;${BASH_SOURCE[0]}&#34; )&#34; &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; pwd )&#34;&#xA;&#xA;if [ &#34;$(uname)&#34; == &#34;Darwin&#34; ]; then&#xA;  # In this example, assume node-mac-v18.16.0 is a universal macOS binary.&#xA;  &#34;$DIR/node-mac-v18.16.0&#34; &#34;$@&#34;&#xA;else&#xA;  &#34;$DIR/node-linux-v18.16.0&#34; &#34;$@&#34;&#xA;fi&#xA;&#xA;exit $?&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With DotSlash, the shell script and the binaries can be replaced with a single file named &lt;code&gt;node&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jsonc&#34;&gt;#!/usr/bin/env dotslash&#xA;&#xA;// The URLs in this file were taken from https://nodejs.org/dist/v18.19.0/&#xA;&#xA;{&#xA;  &#34;name&#34;: &#34;node-v18.19.0&#34;,&#xA;  &#34;platforms&#34;: {&#xA;    &#34;macos-aarch64&#34;: {&#xA;      &#34;size&#34;: 40660307,&#xA;      &#34;hash&#34;: &#34;blake3&#34;,&#xA;      &#34;digest&#34;: &#34;6e2ca33951e586e7670016dd9e503d028454bf9249d5ff556347c3d98c347c34&#34;,&#xA;      &#34;format&#34;: &#34;tar.gz&#34;,&#xA;      &#34;path&#34;: &#34;node-v18.19.0-darwin-arm64/bin/node&#34;,&#xA;      &#34;providers&#34;: [&#xA;        {&#xA;          &#34;url&#34;: &#34;https://nodejs.org/dist/v18.19.0/node-v18.19.0-darwin-arm64.tar.gz&#34;&#xA;        }&#xA;      ]&#xA;    },&#xA;    // Note that with DotSlash, it is straightforward to specify separate&#xA;    // binaries for different platforms, such as x86 vs. arm64 on macOS.&#xA;    &#34;macos-x86_64&#34;: {&#xA;      &#34;size&#34;: 42202872,&#xA;      &#34;hash&#34;: &#34;blake3&#34;,&#xA;      &#34;digest&#34;: &#34;37521058114e7f71e0de3fe8042c8fa7908305e9115488c6c29b514f9cd2a24c&#34;,&#xA;      &#34;format&#34;: &#34;tar.gz&#34;,&#xA;      &#34;path&#34;: &#34;node-v18.19.0-darwin-x64/bin/node&#34;,&#xA;      &#34;providers&#34;: [&#xA;        {&#xA;          &#34;url&#34;: &#34;https://nodejs.org/dist/v18.19.0/node-v18.19.0-darwin-x64.tar.gz&#34;&#xA;        }&#xA;      ]&#xA;    },&#xA;    &#34;linux-x86_64&#34;: {&#xA;      &#34;size&#34;: 44694523,&#xA;      &#34;hash&#34;: &#34;blake3&#34;,&#xA;      &#34;digest&#34;: &#34;72b81fc3a30b7bedc1a09a3fafc4478a1b02e5ebf0ad04ea15d23b3e9dc89212&#34;,&#xA;      &#34;format&#34;: &#34;tar.gz&#34;,&#xA;      &#34;path&#34;: &#34;node-v18.19.0-linux-x64/bin/node&#34;,&#xA;      &#34;providers&#34;: [&#xA;        {&#xA;          &#34;url&#34;: &#34;https://nodejs.org/dist/v18.19.0/node-v18.19.0-linux-x64.tar.gz&#34;&#xA;        }&#xA;      ]&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Assuming &lt;code&gt;dotslash&lt;/code&gt; is on your &lt;code&gt;$PATH&lt;/code&gt; and you remembered to &lt;code&gt;chmod +x node&lt;/code&gt; to mark it as executable, you can now run your Node.js wrapper exactly as you did before:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./node --version&#xA;v18.16.0&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first time you run &lt;code&gt;./node --version&lt;/code&gt;, you will likely experience a small delay while DotSlash fetches, decompresses, and verifies the appropriate &lt;code&gt;.tar.gz&lt;/code&gt;, but subsequent invocations should be instantaneous.&lt;/p&gt; &#xA;&lt;p&gt;To understand what is happening under the hood, read the article on &lt;a href=&#34;https://dotslash-cli.com/docs/execution/&#34;&gt;how DotSlash works&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installing DotSlash&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://dotslash-cli.com/docs/installation/&#34;&gt;installation instructions&lt;/a&gt; on the DotSlash website.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;DotSlash is licensed under both the MIT license and Apache-2.0 license; the exact terms can be found in the &lt;a href=&#34;https://raw.githubusercontent.com/facebook/dotslash/main/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/facebook/dotslash/main/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; files, respectively.&lt;/p&gt;</summary>
  </entry>
</feed>