<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-12-29T01:32:59Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>GregoryConrad/rearch-rs</title>
    <updated>2023-12-29T01:32:59Z</updated>
    <id>tag:github.com,2023-12-29:/GregoryConrad/rearch-rs</id>
    <link href="https://github.com/GregoryConrad/rearch-rs" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Re-imagined approach to application design and architecture&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://github.com/GregoryConrad/rearch-rs/actions&#34;&gt;&lt;img src=&#34;https://github.com/GregoryConrad/rearch-rs/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;CI Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/GregoryConrad/rearch-rs&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/GregoryConrad/rearch-rs.svg?style=flat&amp;amp;logo=github&amp;amp;colorB=deeppink&amp;amp;label=stars&#34; alt=&#34;Github Stars&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-purple.svg?sanitize=true&#34; alt=&#34;MIT License&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/GregoryConrad/rearch-docs/raw/main/assets/banner.jpg?raw=true&#34; width=&#34;75%&#34; alt=&#34;Banner&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; ReArch = re-imagined approach to application design and architecture &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;p&gt;Specifically, ReArch is a novel solution to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;‚ö°Ô∏è State Management&lt;/li&gt; &#xA; &lt;li&gt;üßÆ Incremental Computation&lt;/li&gt; &#xA; &lt;li&gt;üß± Component-Based Software Engineering&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;And with those, come:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Reactivity through declarative code&lt;/li&gt; &#xA; &lt;li&gt;Loose coupling and high testability&lt;/li&gt; &#xA; &lt;li&gt;App-level composability via a functional approach to dependency inversion&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://blog.gsconrad.com/2023/12/22/the-problem-with-state-management.html&#34;&gt;Feature composition through &lt;em&gt;side effects&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;In a Nutshell&lt;/h2&gt; &#xA;&lt;p&gt;Define your &#34;capsules&#34; (en-&lt;em&gt;capsulated&lt;/em&gt; pieces of state) at the top level:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;// Capsules are simply functions that consume a CapsuleHandle.&#xA;// The CapsuleHandle lets you get the state of other capsules,&#xA;// in addition to using a large variety of side effects.&#xA;&#xA;// This capsule provides the count and a way to increment that count.&#xA;fn count_manager(CapsuleHandle { register, .. }: CapsuleHandle) -&amp;gt; (u8, impl CData + Fn()) {&#xA;    let (count, set_count) = register(effects::state(0));&#xA;    let count = *count; // the state side effect returns a &amp;amp;mut T&#xA;    let increment_count = move || set_count(count + 1);&#xA;    (count, increment_count)&#xA;}&#xA;&#xA;// This capsule provides the count, plus one.&#xA;fn count_plus_one_capsule(CapsuleHandle { mut get, .. }: CapsuleHandle) -&amp;gt; u8 {&#xA;    let (count, _increment_count) = get(count_manager);&#xA;    count + 1&#xA;}&#xA;&#xA;let container = Container::new();&#xA;&#xA;let ((count, increment_count), count_plus_one) =&#xA;    container.read((count_manager, count_plus_one_capsule));&#xA;assert_eq!(count, 0);&#xA;assert_eq!(count_plus_one, 1);&#xA;&#xA;increment_count();&#xA;&#xA;let ((count, _), count_plus_one) = container.read((count_manager, count_plus_one_capsule));&#xA;assert_eq!(count, 1);&#xA;assert_eq!(count_plus_one, 2);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;Simply run: &lt;code&gt;cargo add rearch rearch-effects&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then, create one container for your application:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use rearch::*;&#xA;use rearch_effects as effects;&#xA;&#xA;fn main() {&#xA;  let container = Container::new();&#xA;  // Use the container.&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And take a look at the &lt;a href=&#34;https://github.com/GregoryConrad/rearch-rs/tree/main/examples&#34;&gt;examples&lt;/a&gt; to get an idea on how to make some of your own capsules!&lt;/p&gt; &#xA;&lt;h3&gt;Documentation&lt;/h3&gt; &#xA;&lt;p&gt;Also, there is some WIP &lt;a href=&#34;https://rearch.gsconrad.com&#34;&gt;documentation&lt;/a&gt; that will help you learn the core concepts behind ReArch!&lt;/p&gt; &#xA;&lt;h2&gt;Minimum Supported Rust Version (MSRV)&lt;/h2&gt; &#xA;&lt;p&gt;The MSRV is currently 1.74.0 and may change in any new ReArch version/release.&lt;/p&gt; &#xA;&lt;p&gt;It is also worth mentioning that the example shown in &#34;In a Nutshell&#34; above requires nightly for &lt;code&gt;unboxed_closures&lt;/code&gt; and &lt;code&gt;fn_traits&lt;/code&gt;, which is feature-gated under the &lt;code&gt;better-api&lt;/code&gt; feature. Once &lt;code&gt;unboxed_closures&lt;/code&gt; and &lt;code&gt;fn_traits&lt;/code&gt; stabilize, this nightly syntax will be the preferred syntax, and this will no longer be feature-gated. (Without nightly, you must instead call the slightly more verbose &lt;code&gt;get.get(some_capsule)&lt;/code&gt; and &lt;code&gt;register.register(effect())&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;h2&gt;Help Wanted!&lt;/h2&gt; &#xA;&lt;p&gt;As much as I have done with ReArch, it always seems like there is more to do. One person can only do so much!&lt;/p&gt; &#xA;&lt;p&gt;If you would like to contribute, here are some areas where I would really appreciate help!&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Documentation (especially inline!) &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;If you could add code samples/improve clarity, that would be greatly appreciated.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;New side effects! &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;I&#39;ve made many as I&#39;ve needed them, but it&#39;d be great to have more.&lt;/li&gt; &#xA;   &lt;li&gt;If you find yourself using a custom side effect over and over, consider making a PR! Chances are other developers can use it too.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Sponsors&lt;/h2&gt; &#xA;&lt;p&gt;You can become a sponsor of my work &lt;a href=&#34;https://github.com/sponsors/GregoryConrad&#34;&gt;here!&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/GregoryConrad/GregoryConrad/main/sponsorkit/sponsors.svg?sanitize=true&#34;&gt; &lt;/p&gt;</summary>
  </entry>
</feed>