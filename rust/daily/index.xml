<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-08T01:45:08Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>m1guelpf/tinyvector</title>
    <updated>2023-07-08T01:45:08Z</updated>
    <id>tag:github.com,2023-07-08:/m1guelpf/tinyvector</id>
    <link href="https://github.com/m1guelpf/tinyvector" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tiny embedding database in pure Rust.&lt;/p&gt;&lt;hr&gt;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/m1guelpf/tinyvector/assets/23558090/512ff4ad-49fd-43ec-b3bd-57365b920078&#34; alt=&#34;tinyvector logo&#34;&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;b&gt;tinyvector - a tiny embedding database in pure Rust&lt;/b&gt; &lt;br&gt;&lt;br&gt; &lt;a href=&#34;https://crates.io/crates/tinyvector&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/tinyvector&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/m1guelpf/tinyvector/actions/workflows/build&#34;&gt;&lt;img src=&#34;https://github.com/m1guelpf/tinyvector/actions/workflows/build.yaml/badge.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/m1guelpf/tinyvector/main/LICENSE&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT-blue.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;‚ú® Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tiny&lt;/strong&gt;: It&#39;s in the name. It&#39;s literally just an axum server. Extremely easy to customize, around 600 lines of code.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fast&lt;/strong&gt;: Tinyvector &lt;em&gt;should&lt;/em&gt; have comparable speed to advanced vector databases when it comes on small to medium datasets, and slightly better accuracy.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Vertically Scales&lt;/strong&gt;: Tinyvector stores all indexes in memory for fast querying. Very easy to scale up to 100 million+ vector dimensions without issue.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Open Source&lt;/strong&gt;: MIT Licensed, free forever.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Soon&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Powerful Queries&lt;/strong&gt;: Allow filtering by the provided vector metadata without slowing the search down.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Integrated Models&lt;/strong&gt;: Soon you won&#39;t have to bring your own vectors, just generate them on the server automaticaly. Aiming to support support SBert, Hugging Face models, OpenAI, Cohere, etc.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Typescript/Python Libraries&lt;/strong&gt;: Should be able to auto-generate pretty good clients using the included OpenAPI schema.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üöÄ Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;üê≥ Docker&lt;/h3&gt; &#xA;&lt;p&gt;We provide a lightweight Docker container that you can run anywhere. It only takes one command to get up and running with the latest changes:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run \&#xA;  -p 8000:8000 \&#xA;  ghcr.io/m1guelpf/tinyvector:edge&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; When running via Docker Compose or Kubernetes, make sure to bind a volume to &lt;code&gt;/tinyvector/storage&lt;/code&gt; for persistence. This is handled automatically in the command above.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;üõ†Ô∏è Building from scratch&lt;/h3&gt; &#xA;&lt;p&gt;You can build tinyvector from the latest tagged release by running &lt;code&gt;cargo install tinyvector&lt;/code&gt; (you might need to &lt;a href=&#34;https://rustup.rs/&#34;&gt;install Rust&lt;/a&gt; first). Then, run &lt;code&gt;tinyvector&lt;/code&gt; to start up the server.&lt;/p&gt; &#xA;&lt;p&gt;You can also build it from the latest commit by cloning the repo and running &lt;code&gt;cargo build --release&lt;/code&gt;, and run it with &lt;code&gt;./target/release/tinyvector&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;üí° Why use tinyvector?&lt;/h2&gt; &#xA;&lt;p&gt;Most vector databases are overkill for simple setups. For example:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Using embeddings to chat with your documents. Most document search is nowhere close to what you&#39;d need to justify accelerating search speed with &lt;a href=&#34;https://github.com/nmslib/hnswlib&#34;&gt;HNSW&lt;/a&gt; or &lt;a href=&#34;https://github.com/facebookresearch/faiss&#34;&gt;FAISS&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Doing search for your website or store. Unless you&#39;re selling 1,000,000 items, you don&#39;t need Pinecone.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üß© Embeddings?&lt;/h2&gt; &#xA;&lt;p&gt;Embeddings are a way to compare similar things, in the same way humans compare similar things, by converting text into a small list of numbers. Similar pieces of text will have similar numbers, different ones have very different numbers.&lt;/p&gt; &#xA;&lt;p&gt;Read OpenAI&#39;s &lt;a href=&#34;https://platform.openai.com/docs/guides/embeddings/what-are-embeddings&#34;&gt;explanation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;üôè Acknowledgements&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Will Depue&#39;s &lt;a href=&#34;https://twitter.com/willdepue/status/1675796236304252928&#34;&gt;tinyvector&lt;/a&gt; (python+sqlite+numpy) inspired me to build a vector database from scratch (and borrow the name). Will also contributed plenty of ideas to optimize performance.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìÑ License&lt;/h2&gt; &#xA;&lt;p&gt;This project is open-sourced under the MIT license. See &lt;a href=&#34;https://raw.githubusercontent.com/m1guelpf/tinyvector/main/LICENSE&#34;&gt;the License file&lt;/a&gt; for more information.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>bytewax/bytewax</title>
    <updated>2023-07-08T01:45:08Z</updated>
    <id>tag:github.com,2023-07-08:/bytewax/bytewax</id>
    <link href="https://github.com/bytewax/bytewax" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Python Stream Processing&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/bytewax/bytewax/actions&#34;&gt;&lt;img src=&#34;https://github.com/bytewax/bytewax/workflows/CI/badge.svg?sanitize=true&#34; alt=&#34;Actions Status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pypi.org/project/bytewax/&#34;&gt;&lt;img src=&#34;https://img.shields.io/pypi/v/bytewax.svg?style=flat-square&#34; alt=&#34;PyPI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://bytewax.io/docs&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/user-guide-brightgreen?style=flat-square&#34; alt=&#34;Bytewax User Guide&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;picture&gt; &#xA; &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://user-images.githubusercontent.com/6073079/195393689-7334098b-a8cd-4aaa-8791-e4556c25713e.png&#34; width=&#34;350&#34;&gt; &#xA; &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://user-images.githubusercontent.com/6073079/194626697-425ade3d-3d72-4b4c-928e-47bad174a376.png&#34; width=&#34;350&#34;&gt; &#xA; &lt;img alt=&#34;Bytewax&#34;&gt; &#xA;&lt;/picture&gt; &#xA;&lt;h2&gt;Python Stateful Stream Processing Framework&lt;/h2&gt; &#xA;&lt;p&gt;Bytewax is a Python framework that simplifies event and stream processing. Because Bytewax couples the stream and event processing capabilities of Flink, Spark, and Kafka Streams with the friendly and familiar interface of Python, you can re-use the Python libraries you already know and love. Connect data sources, run stateful transformations and write to various different downstream systems with built-in connectors or existing Python libraries.&lt;/p&gt; &#xA;&lt;img width=&#34;1303&#34; alt=&#34;Screen Shot 2022-10-07 at 2 22 49 PM&#34; src=&#34;https://user-images.githubusercontent.com/6073079/194624582-c16df8d6-d501-46b2-bdbc-78dbed67902e.png&#34;&gt; &#xA;&lt;h3&gt;How it all works&lt;/h3&gt; &#xA;&lt;p&gt;Bytewax is a Python framework and Rust distributed processing engine that uses a dataflow computational model to provide parallelizable stream processing and event processing capabilities similar to Flink, Spark, and Kafka Streams. You can use Bytewax for a variety of workloads from moving data √† la Kafka Connect style all the way to advanced online machine learning workloads. Bytewax is not limited to streaming applications but excels anywhere that data can be distributed at the input and output.&lt;/p&gt; &#xA;&lt;p&gt;Bytewax has an accompanying command line interface, &lt;a href=&#34;https://bytewax.io/docs/deployment/waxctl/&#34;&gt;waxctl&lt;/a&gt;, which supports the deployment of dataflows on cloud vms or kuberentes. You can download it &lt;a href=&#34;https://bytewax.io/downloads/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h3&gt;Getting Started with Bytewax&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip install bytewax&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://bytewax.io/downloads/&#34;&gt;&lt;em&gt;Install waxctl&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A Bytewax dataflow is Python code that will represent an input, a series of processing steps, and an output. The inputs could range from a Kafka stream to a WebSocket and the outputs could vary from a data lake to a key-value store.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bytewax.dataflow import Dataflow&#xA;from bytewax.connectors.kafka import KafkaInput&#xA;&#xA;# Bytewax has input and output helpers for common input and output data sources&#xA;# but you can also create your own with the ManualOutputConfig.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;At a high-level, the dataflow compute model is one in which a program execution is conceptualized as data flowing through a series of operator-based steps. Operators like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; are the processing primitives of Bytewax. Each of them gives you a ‚Äúshape‚Äù of data transformation, and you give them regular Python functions to customize them to a specific task you need. See the documentation for a list of the &lt;a href=&#34;https://bytewax.io/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow&#34;&gt;available operators&lt;/a&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import json&#xA;&#xA;def deserialize(key_bytes__payload_bytes):&#xA;    _, payload_bytes = key_bytes__payload_bytes&#xA;    event_data = json.loads(payload_bytes) if payload_bytes else None&#xA;    return event_data[&#34;user_id&#34;], event_data&#xA;&#xA;&#xA;def anonymize_email(user_id__event_data):&#xA;    user_id, event_data = user_id__event_data&#xA;    event_data[&#34;email&#34;] = &#34;@&#34;.join([&#34;******&#34;, event_data[&#34;email&#34;].split(&#34;@&#34;)[-1]])&#xA;    return user_id, event_data&#xA;&#xA;&#xA;def remove_bytewax(user_id__event_data):&#xA;    user_id, event_data = user_id__event_data&#xA;    return &#34;bytewax&#34; not in event_data[&#34;email&#34;]&#xA;&#xA;flow = Dataflow()&#xA;flow.input(&#34;inp&#34;, KafkaInput(brokers=[&#34;localhost:9092&#34;], topic=&#34;web_events&#34;))&#xA;flow.map(deserialize)&#xA;flow.map(anonymize_email)&#xA;flow.filter(remove_bytewax)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bytewax is a stateful stream processing framework, which means that some operations remember information across multiple events. Windows and aggregations are also stateful, and can be reconstructed in the event of failure. Bytewax can be configured with different &lt;a href=&#34;https://bytewax.io/apidocs/bytewax.recovery&#34;&gt;state recovery mechanisms&lt;/a&gt; to durably persist state in order to recover from failure.&lt;/p&gt; &#xA;&lt;p&gt;There are multiple stateful operators available like &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;stateful_map&lt;/code&gt; and &lt;code&gt;fold_window&lt;/code&gt;. The complete list can be found in the &lt;a href=&#34;https://bytewax.io/apidocs/bytewax.dataflow&#34;&gt;API documentation for all operators&lt;/a&gt;. Below we use the &lt;code&gt;fold_window&lt;/code&gt; operator with a tumbling window based on system time to gather events and calculate the number of times events have occurred on a per-user basis.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime, timedelta, timezone&#xA;from collections import defaultdict&#xA;&#xA;from bytewax.window import TumblingWindow, SystemClockConfig&#xA;&#xA;def build():&#xA;    return defaultdict(lambda: 0)&#xA;&#xA;&#xA;def count_events(results, event):&#xA;    results[event[&#34;type&#34;]] += 1&#xA;    return results&#xA;&#xA;&#xA;cc = SystemClockConfig()&#xA;align_to = datetime(2023, 1, 1, tzinfo=timezone.utc)&#xA;wc = TumblingWindow(length=timedelta(seconds=5), align_to=align_to)&#xA;&#xA;flow.fold_window(&#34;session_state_recovery&#34;, cc, wc, build, count_events)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Output mechanisms in Bytewax are managed in the &lt;a href=&#34;https://bytewax.io/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow.output&#34;&gt;output operator&lt;/a&gt;. There are a number of helpers that allow you to easily connect and write to other systems (&lt;a href=&#34;https://docs.bytewax.io/apidocs/bytewax.outputs&#34;&gt;output docs&lt;/a&gt;). If there isn‚Äôt a helper built, it is easy to build a custom version, which we will do below. Similar the input, Bytewax output can be parallelized and the client connection will occur on the worker.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import json&#xA;&#xA;import psycopg2&#xA;&#xA;from bytewax.outputs import PartitionedOutput, StatefulSink&#xA;&#xA;&#xA;class PsqlSink(StatefulSink):&#xA;    def __init__(self):&#xA;        self.conn = psycopg2.connect(&#34;dbname=website user=bytewax&#34;)&#xA;        self.conn.set_session(autocommit=True)&#xA;        self.cur = self.conn.cursor()&#xA;&#xA;    def write(self, user_id__user_data):&#xA;        user_id, user_data = user_id__user_data&#xA;        query_string = &#34;&#34;&#34;&#xA;            INSERT INTO events (user_id, data)&#xA;            VALUES (%s, %s)&#xA;            ON CONFLICT (user_id)&#xA;            DO UPDATE SET data = %s;&#xA;        &#34;&#34;&#34;&#xA;        self.cur.execute(&#xA;            query_string, (user_id, json.dumps(user_data), json.dumps(user_data))&#xA;        )&#xA;&#xA;    def snapshot(self):&#xA;        pass&#xA;&#xA;    def close(self):&#xA;        self.conn.close()&#xA;&#xA;&#xA;class PsqlOutput(PartitionedOutput):&#xA;    def list_parts(self):&#xA;        return {&#34;single&#34;}&#xA;&#xA;    def assign_part(self, item_key):&#xA;        return &#34;single&#34;&#xA;&#xA;    def build_part(for_part, resume_state):&#xA;        return PsqlSink()&#xA;&#xA;&#xA;flow.output(&#34;out&#34;, PsqlOutput())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Bytewax dataflows can be executed on a single host with multiple Python processes, or on multiple hosts. When processing data in a distributed fashion, Bytewax will ensure that all items with the same key are routed to the same host.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;python -m bytewax.run my_dataflow:flow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It can also be run in a Docker container as described further in the &lt;a href=&#34;https://bytewax.io/docs/deployment/container&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Kubernetes&lt;/h4&gt; &#xA;&lt;p&gt;The recommended way to run dataflows at scale is to leverage the &lt;a href=&#34;https://bytewax.io/docs/deployment/k8s-ecosystem&#34;&gt;kubernetes ecosystem&lt;/a&gt;. To help manage deployment, we built &lt;a href=&#34;https://bytewax.io/docs/deployment/waxctl&#34;&gt;waxctl&lt;/a&gt;, which allows you to easily deploy dataflows that will run at huge scale across multiple compute nodes.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;waxctl df deploy my_dataflow.py --name my-dataflow&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Why Bytewax?&lt;/h2&gt; &#xA;&lt;p&gt;At a high level, Bytewax provides a few major benefits:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The operators in Bytewax are largely ‚Äúdata-parallel‚Äù, meaning they can operate on independent parts of the data concurrently.&lt;/li&gt; &#xA; &lt;li&gt;Bytewax offers the ability to express higher-level control constructs, like iteration.&lt;/li&gt; &#xA; &lt;li&gt;Bytewax allows you to develop and run your code locally, and then easily scale that code to multiple workers or processes without changes.&lt;/li&gt; &#xA; &lt;li&gt;Bytewax can be used in both a streaming and batch context&lt;/li&gt; &#xA; &lt;li&gt;Ability to leverage the Python ecosystem directly&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://join.slack.com/t/bytewaxcommunity/shared_invite/zt-vkos2f6r-_SeT9pF2~n9ArOaeI3ND2w&#34;&gt;Slack&lt;/a&gt; Is the main forum for communication and discussion.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bytewax/bytewax/issues&#34;&gt;GitHub Issues&lt;/a&gt; is reserved only for actual issues. Please use the slack community for discussions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/bytewax/bytewax/raw/main/CODE_OF_CONDUCT.md&#34;&gt;Code of Conduct&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Install the &lt;a href=&#34;https://github.com/bytewax/bytewax/releases/latest&#34;&gt;latest release&lt;/a&gt; with pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install bytewax&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Building From Source&lt;/h3&gt; &#xA;&lt;p&gt;To build a specific branch, you will need to use Maturin and have Rust installed on your machine. Once those have been installed run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;maturin develop -E dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;em&gt;Important&lt;/em&gt;: If you are testing with a maturin built version from source, you should use &lt;code&gt;maturin build --release&lt;/code&gt; since &lt;code&gt;maturin develop&lt;/code&gt; will be slower.&lt;/p&gt; &#xA;&lt;h2&gt;More Examples&lt;/h2&gt; &#xA;&lt;p&gt;For a more complete example, and documentation on the available operators, check out the &lt;a href=&#34;https://bytewax.io/docs&#34;&gt;User Guide&lt;/a&gt; and the &lt;a href=&#34;https://raw.githubusercontent.com/bytewax/bytewax/main/examples&#34;&gt;/examples&lt;/a&gt; folder.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Bytewax is licensed under the &lt;a href=&#34;https://opensource.org/licenses/APACHE-2.0&#34;&gt;Apache-2.0&lt;/a&gt; license.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Contributions are welcome! This community and project would not be what it is without the &lt;a href=&#34;https://github.com/bytewax/bytewax/graphs/contributors&#34;&gt;contributors&lt;/a&gt;. All contributions, from bug reports to new features, are welcome and encouraged. Please view the &lt;a href=&#34;https://raw.githubusercontent.com/bytewax/bytewax/main/CONTRIBUTING.md&#34;&gt;contribution guidelines&lt;/a&gt; before getting started.&lt;/p&gt; &#xA;&lt;br&gt; &#xA;&lt;br&gt; &#xA;&lt;p align=&#34;center&#34;&gt; With ‚ù§Ô∏è Bytewax&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/6073079/157482621-331ad886-df3c-4c92-8948-9e50accd38c9.png&#34;&gt; &lt;/p&gt; &#xA;&lt;img referrerpolicy=&#34;no-referrer-when-downgrade&#34; src=&#34;https://static.scarf.sh/a.png?x-pxid=07749572-3e76-4ac0-952b-d5dcf3bff737&#34;&gt;</summary>
  </entry>
</feed>