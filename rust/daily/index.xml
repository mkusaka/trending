<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-07-28T01:44:23Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>o8vm/octox</title>
    <updated>2023-07-28T01:44:23Z</updated>
    <id>tag:github.com,2023-07-28:/o8vm/octox</id>
    <link href="https://github.com/o8vm/octox" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Unix-like OS in Rust inspired by xv6-riscv&lt;/p&gt;&lt;hr&gt;&lt;p&gt;#+title: octox #+author: Hayato Ohhashi #+email: &lt;a href=&#34;mailto:o8@vmm.dev&#34;&gt;o8@vmm.dev&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;octox is a Unix-like operating system inspired by xv6-riscv. octox loosely follows the structure and style of xv6, but is implemented in pure Rust.&lt;/p&gt; &#xA;&lt;p&gt;[[https://vhs.charm.sh/vhs-6MQBIyAo3DpBrARBxHxL35.gif]]&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Everything from kernel, userland, mkfs, to build system is written in safe Rust as much as possible.&lt;/li&gt; &#xA; &lt;li&gt;There are no dependencies on external crates.&lt;/li&gt; &#xA; &lt;li&gt;The userland has a library similar to Rust‚Äôs std with K&amp;amp;R malloc.&lt;/li&gt; &#xA; &lt;li&gt;Multi-core support, buddy allocator as kernel-side memory allocator, file system with logging support, etc.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Getting Started&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Requirements&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Install the rust toolchain to have cargo installed by following [[https://www.rust-lang.org/tools/install][this]] guide.&lt;/li&gt; &#xA; &lt;li&gt;Install &lt;del&gt;qemu-system-riscv&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;(option) Install &lt;del&gt;gdb-multiarch&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Build and Run&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Clone this project &amp;amp; enter: &lt;del&gt;git clone ... &amp;amp;&amp;amp; cd octox&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;Build: &lt;del&gt;cargo build --target riscv64gc-unknown-none-elf&lt;/del&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Run: &lt;del&gt;cargo run --target riscv64gc-unknown-none-elf&lt;/del&gt;, then qemu will boot octox. To exit, press &lt;del&gt;Ctrl+a&lt;/del&gt; and &lt;del&gt;x&lt;/del&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Play with the Shell&lt;/p&gt; &#xA;&lt;p&gt;A very simple shell is implemented. In addition to executing commands, you can only do the following things.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Pipe: &lt;del&gt;cat file | head | grep test&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;Dump processes: &lt;del&gt;Ctrl + P&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;End of line: &lt;del&gt;Ctrl + D&lt;/del&gt;&lt;/li&gt; &#xA; &lt;li&gt;Redirect output: &lt;del&gt;&amp;gt;&lt;/del&gt;, &lt;del&gt;&amp;gt;&amp;gt;&lt;/del&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Development&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Userland Application&lt;/p&gt; &#xA;&lt;p&gt;The userland comes with a user library called ulib that is similar to Rust‚Äôs std, so you can use it to develop your favorite commands. If you create a bin crate named &lt;del&gt;_command&lt;/del&gt; in src/user, the build.rs and mkfs.rs will place a file named &lt;del&gt;command&lt;/del&gt; in the file system and make it available for use.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;In src/user/Cargo.toml, define a bin crate with the name of the command you want to create with a &lt;del&gt;_&lt;/del&gt; prefix #+begin_src toml [[bin]] name = &#34;_rm&#34; path = &#34;rm.rs&#34; #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;userland is also no_std, so don‚Äôt forget to add &lt;del&gt;#[no_std]&lt;/del&gt;. Use ulib to develop any command you like. Here is an example of the rm command. #+begin_src rust #![no_std] use ulib::{env, fs};&lt;/p&gt; &lt;p&gt;fn main() { let mut args = env::args().skip(1).peekable();&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  if args.peek().is_none() {&#xA;      panic!(&#34;Usage: rm files...&#34;)&#xA;  }&#xA;  for arg in args {&#xA;      fs::remove_file(arg).unwrap()&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;} #+end_src&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Then, &lt;del&gt;cargo run --target riscv64gc-unknown-none-elf&lt;/del&gt; in the root of octox.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;To use &lt;del&gt;Vec&lt;/del&gt; and &lt;del&gt;String&lt;/del&gt;, etc, do the following: #+begin_src rust extern crate alloc; use alloc::{string::String, vec::Vec}; #+end_src&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;** Kernel&lt;/p&gt; &#xA;&lt;p&gt;Developing in src/kernel. Here is an example of adding a system call. If you want to add a new system call, you only need to add a definition to the system call table in libkernel, and the userland library will be automatically generated by build.rs.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Add a variant and Syscall Number to &lt;del&gt;enum SysCalls&lt;/del&gt; in src/kernel/syscall.rs. Here is &lt;del&gt;Dup2&lt;/del&gt; as an example: #+begin_src rust pub enum SysCalls { Fork = 1, ..., Dup2 = 23, Invalid = 0, } #+end_src&lt;/li&gt; &#xA; &lt;li&gt;Define the function signature of the system call in the &lt;del&gt;TABLE&lt;/del&gt; of &lt;del&gt;SysCalls&lt;/del&gt;. Use the enum type &lt;del&gt;Fn&lt;/del&gt; to describe the return type(&lt;del&gt;U&lt;/del&gt; (Unit), &lt;del&gt;I&lt;/del&gt; (Integer), &lt;del&gt;N&lt;/del&gt; (never)) and use &lt;del&gt;&amp;amp;str&lt;/del&gt; to represent arguments. then, define kernel-side implementation as a method on &lt;del&gt;SysCalls&lt;/del&gt;. &lt;del&gt;cfg&lt;/del&gt; flag is used to control the compilation target for kernel and the rest. Here is an example of &lt;del&gt;dup2&lt;/del&gt;: #+begin_src rust impl SysCalls { pub const TABLE: [(fn, &amp;amp;&#39;static str); variant_count::&#xA;  &lt;self&gt;&#xA;   ()] = [ (Fn::N(Self::Invalid), &#34;&#34;), (Fn::I(Self::fork), &#34;()&#34;), (Fn::N(Self::exit), &#34;(xstatus: i32)&#34;), ..., (Fn::I(Self::dup2), &#34;(src: usize, dst: usize)&#34;), ]; pub fn dup2() -&amp;gt; Result&#xA;   &lt;usize&gt;&#xA;     { #[cfg(not(all(target_os = &#34;none&#34;, feature = &#34;kernel&#34;)))] return Ok(0); #[cfg(all(target_os = &#34;none&#34;, feature = &#34;kernel&#34;))] { let p = Cpus::myproc().unwrap().data_mut(); let src_fd = argraw(0); let dst_fd = argraw(1); if src_fd != dst_fd { let mut src = p.ofile.get_mut(src_fd).unwrap() .take().unwrap(); src.clear_cloexec(); p.ofile.get_mut(dst_fd) .ok_or(FileDescriptorTooLarge)?.replace(src); } Ok(dst_fd) } } #+end_src&#xA;   &lt;/usize&gt;&#xA;  &lt;/self&gt;&lt;/li&gt; &#xA; &lt;li&gt;With just these steps, the dup2 system call is implemented in both kernel and userland.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;License&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;[[http://www.apache.org/licenses/LICENSE-2.0][Apache License, Version 2.0]]&lt;/li&gt; &#xA; &lt;li&gt;[[http://opensource.org/licenses/MIT][MIT license]]&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your option.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Acknowledgments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;octox is inspired by [[https://github.com/mit-pdos/xv6-riscv][xv6-riscv]].&lt;/p&gt; &#xA;&lt;p&gt;I&#39;m also grateful for the bug reports and discussion about the implementation contributed by Takahiro Itazuri and Kuniyuki Iwashima.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Contribution&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a learning project for me, and I will not be accepting pull requests until I consider the implementation complete. However, discussions and advice are welcome.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>ThousandBirdsInc/chidori</title>
    <updated>2023-07-28T01:44:23Z</updated>
    <id>tag:github.com,2023-07-28:/ThousandBirdsInc/chidori</id>
    <link href="https://github.com/ThousandBirdsInc/chidori" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A reactive runtime for building durable AI agents&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/assets/515757/6b088f7d-d8f7-4c7e-9006-4360ae40d1de&#34;&gt;https://github.com/ThousandBirdsInc/chidori/assets/515757/6b088f7d-d8f7-4c7e-9006-4360ae40d1de&lt;/a&gt;&lt;/p&gt; &#xA;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;&amp;nbsp; Chidori &amp;nbsp;&lt;/h1&gt; &#xA; &lt;p&gt;&lt;strong&gt;A reactive runtime for building durable AI agents&lt;/strong&gt;&lt;/p&gt; &#xA; &lt;p&gt; &lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/commits&#34;&gt;&lt;img alt=&#34;Current Build Status&#34; src=&#34;https://img.shields.io/github/actions/workflow/status/ThousandBirdsInc/chidori/push.yml&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/commits&#34;&gt;&lt;img alt=&#34;GitHub Last Commit&#34; src=&#34;https://img.shields.io/github/last-commit/ThousandBirdsInc/chidori&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/commits&#34;&gt;&lt;img alt=&#34;Cargo.io download&#34; src=&#34;https://img.shields.io/crates/dv/chidori/0.1.1&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/commits&#34;&gt;&lt;img alt=&#34;Cargo.io download&#34; src=&#34;https://img.shields.io/pypi/v/chidori&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/commits&#34;&gt;&lt;img alt=&#34;Cargo.io download&#34; src=&#34;https://img.shields.io/npm/v/@1kbirds/chidori&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/ThousandBirdsInc/chidori/raw/main/LICENSE&#34;&gt;&lt;img alt=&#34;Github License&#34; src=&#34;https://img.shields.io/badge/License-MIT-green.svg?sanitize=true&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA; &lt;br&gt; &#xA;&lt;/div&gt; &#xA;&lt;p&gt;Star us on Github! Join us on &lt;a href=&#34;https://discord.gg/CJwKsPSgew&#34;&gt;Discord&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://docs.thousandbirds.ai/3fe20a82965148c7a0b480f7daf0aff6&#34;&gt;high level docs &lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#-chidori-&#34;&gt;&amp;nbsp; Chidori &amp;nbsp;&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#contents&#34;&gt;Contents&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#-chidori&#34;&gt;üìñ Chidori&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#%EF%B8%8F-getting-started&#34;&gt;‚ö°Ô∏è Getting Started&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#environment-variables&#34;&gt;Environment Variables&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#-about&#34;&gt;ü§î About&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#reactive-runtime&#34;&gt;Reactive Runtime&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#monitoring-and-observability&#34;&gt;Monitoring and Observability&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#branching-and-time-travel&#34;&gt;Branching and Time-Travel&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#code-interpreter-environments&#34;&gt;Code Interpreter Environments&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#%EF%B8%8F-roadmap&#34;&gt;üõ£Ô∏è Roadmap&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#short-term&#34;&gt;Short term&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#med-term&#34;&gt;Med term&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#faq&#34;&gt;FAQ&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#why-another-ai-framework&#34;&gt;Why Another AI Framework?&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#why-chidori&#34;&gt;Why Chidori?&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#well-then-why-thousand-birds&#34;&gt;Well then why Thousand Birds?&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#why-rust&#34;&gt;Why Rust?&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#inspiration&#34;&gt;Inspiration&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/#help-us-out&#34;&gt;Help us out!&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;üìñ Chidori&lt;/h2&gt; &#xA;&lt;p&gt;Chidori is a reactive runtime for building AI agents. It provides a framework for building AI agents that are reactive, observable, and robust. It supports building agents with Node.js, Python, and Rust.&lt;/p&gt; &#xA;&lt;p&gt;It is currently in alpha, and is not yet ready for production use. We are continuing to make significant changes in response to feedback.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Built from the ground up for constructing agents&lt;/li&gt; &#xA; &lt;li&gt;Runtime written in Rust supporting Python and Node.js out of the box&lt;/li&gt; &#xA; &lt;li&gt;Build agents that actually work :emoji:&lt;/li&gt; &#xA; &lt;li&gt;LLM caching to minimize cost during development&lt;/li&gt; &#xA; &lt;li&gt;Optimized for long-running AI workflows&lt;/li&gt; &#xA; &lt;li&gt;Embedded code interpreter&lt;/li&gt; &#xA; &lt;li&gt;Time travel debugging&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;‚ö°Ô∏è Getting Started&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;You can use Chidori from Node.js, Python or Rust.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th width=&#34;450px&#34;&gt;&lt;b&gt;Node.js&lt;/b&gt;&lt;/th&gt; &#xA;   &lt;th width=&#34;450px&#34;&gt;&lt;b&gt;Python&lt;/b&gt;&lt;/th&gt; &#xA;   &lt;th width=&#34;450px&#34;&gt;&lt;b&gt;Rust&lt;/b&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm i @1kbirds/chidori&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install chidori&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo install chidori&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h3&gt;Environment Variables&lt;/h3&gt; &#xA;&lt;p&gt;You will need to set the following environment variables if you depend on nodes that require them.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;OPENAI_API_KEY=...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Examples&lt;/h3&gt; &#xA;&lt;p&gt;In the table below are examples for Node.js, Python and Rust. You&#39;ll need to scroll horizontally to view each.&lt;/p&gt; &#xA;&lt;p&gt;The following examples show how to build a simple agent that fetches the top stories from Hacker News and call the OpenAI API to filter to AI related launches and then format that data into markdown. Results from the example are pushed into the Chidori database and can be visualized using the prompt-graph-ui project. We&#39;ll update this example with a pattern that makes those results more accessible soon.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;tbody&gt;&#xA;  &lt;tr&gt; &#xA;   &lt;th width=&#34;450px&#34;&gt;&lt;b&gt;Node.js&lt;/b&gt;&lt;/th&gt; &#xA;   &lt;th width=&#34;450px&#34;&gt;&lt;b&gt;Python&lt;/b&gt;&lt;/th&gt; &#xA;   &lt;th width=&#34;450px&#34;&gt;&lt;b&gt;Rust&lt;/b&gt;&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const axios = require(&#39;axios&#39;);&#xA;const {Chidori, GraphBuilder} = require(&#34;@1kbirds/chidori&#34;);&#xA;&#xA;class Story {&#xA;    constructor(title, url, score) {&#xA;        this.title = title;&#xA;        this.url = url;&#xA;        this.score = score;&#xA;    }&#xA;}&#xA;&#xA;const HN_URL_TOP_STORIES = &#34;https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty&#34;;&#xA;&#xA;function fetchStory(id) {&#xA;    return axios.get(`https://hacker-news.firebaseio.com/v0/item/${id}.json?print=pretty`)&#xA;        .then(response =&amp;gt; response.data);&#xA;}&#xA;&#xA;function fetchHN() {&#xA;    return axios.get(HN_URL_TOP_STORIES)&#xA;        .then(response =&amp;gt; {&#xA;            const storyIds = response.data;&#xA;            const tasks = storyIds.slice(0, 30).map(id =&amp;gt; fetchStory(id));  // Limit to 30 stories&#xA;            return Promise.all(tasks)&#xA;                .then(stories =&amp;gt; {&#xA;                    return stories.map(story =&amp;gt; {&#xA;                        const { title, url, score } = story;&#xA;                        return new Story(title, url, score);&#xA;                    });&#xA;                });&#xA;        });&#xA;}&#xA;&#xA;class ChidoriWorker {&#xA;    constructor() {&#xA;        this.c = new Chidori(&#34;0&#34;, &#34;http://localhost:9800&#34;);  // Assuming this is a connection object, replaced with an empty object for now&#xA;    }&#xA;&#xA;    async buildGraph() {&#xA;        const g = new GraphBuilder();&#xA;&#xA;        const h = g.customNode({&#xA;            name: &#34;FetchTopHN&#34;,&#xA;            nodeTypeName: &#34;FetchTopHN&#34;,&#xA;            output: &#34;type FetchTopHN { output: String }&#34;&#xA;        });&#xA;&#xA;        const hInterpret = g.promptNode({&#xA;            name: &#34;InterpretTheGroup&#34;,&#xA;            template: `&#xA;                Based on the following list of HackerNews threads,&#xA;                filter this list to only launches of new AI projects: {{FetchTopHN.output}}&#xA;            `&#xA;        });&#xA;        hInterpret.runWhen(g, h);&#xA;&#xA;        const hFormatAndRank = g.promptNode({&#xA;            name: &#34;FormatAndRank&#34;,&#xA;            template: `&#xA;                Format this list of new AI projects in markdown, ranking the most &#xA;                interesting projects from most interesting to least. &#xA;                &#xA;                {{InterpretTheGroup.promptResult}}&#xA;            `&#xA;        });&#xA;        hFormatAndRank.runWhen(g, hInterpret);&#xA;&#xA;        await g.commit(this.c, 0)&#xA;    }&#xA;&#xA;    async run() {&#xA;        // Construct the agent graph&#xA;        await this.buildGraph();&#xA;&#xA;        // Start graph execution from the root&#xA;        // Implement the functionality of the play function&#xA;        await this.c.play(0, 0);&#xA;&#xA;        // Run the node execution loop&#xA;        // Implement the functionality of the run_custom_node_loop function&#xA;        await this.c.runCustomNodeLoop()&#xA;    }&#xA;}&#xA;&#xA;&#xA;async function handleFetchHN(nodeWillExec, cb) {&#xA;    const stories = await fetchHN();&#xA;    // return JSON.stringify(stories);&#xA;    return cb({ &#34;output&#34;: JSON.stringify(stories) });&#xA;    // return ;&#xA;}&#xA;&#xA;async function main() {&#xA;    let w = new ChidoriWorker();&#xA;    await w.c.startServer(&#34;:memory:&#34;)&#xA;    await w.c.registerCustomNodeHandle(&#34;FetchTopHN&#34;, handleFetchHN);&#xA;    await w.run()&#xA;}&#xA;&#xA;&#xA;main();&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import aiohttp&#xA;import asyncio&#xA;from typing import List, Optional&#xA;import json&#xA;from chidori import Chidori, GraphBuilder&#xA;&#xA;&#xA;class Story:&#xA;    def __init__(self, title: str, url: Optional[str], score: Optional[float]):&#xA;        self.title = title&#xA;        self.url = url&#xA;        self.score = score&#xA;&#xA;&#xA;HN_URL_TOP_STORIES = &#34;https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty&#34;&#xA;&#xA;&#xA;async def fetch_story(session, id):&#xA;    async with session.get(f&#34;https://hacker-news.firebaseio.com/v0/item/{id}.json?print=pretty&#34;) as response:&#xA;        return await response.json()&#xA;&#xA;&#xA;async def fetch_hn() -&amp;gt; List[Story]:&#xA;    async with aiohttp.ClientSession() as session:&#xA;        async with session.get(HN_URL_TOP_STORIES) as response:&#xA;            story_ids = await response.json()&#xA;&#xA;        tasks = []&#xA;        for id in story_ids[:30]:  # Limit to 30 stories&#xA;            tasks.append(fetch_story(session, id))&#xA;&#xA;        stories = await asyncio.gather(*tasks)&#xA;&#xA;        stories_out = []&#xA;        for story in stories:&#xA;            for k in (&#39;title&#39;, &#39;url&#39;, &#39;score&#39;):&#xA;                stories_out.append(Story(**dict((k, story.get(k, None)))))&#xA;&#xA;        return stories_out&#xA;&#xA;&#xA;# ^^^^^^^^^^^^^^^^^^^^^^^^^^^&#xA;# Methods for fetching hacker news posts via api&#xA;&#xA;class ChidoriWorker:&#xA;    def __init__(self):&#xA;        self.c = Chidori(&#34;0&#34;, &#34;http://localhost:9800&#34;)&#xA;        self.staged_custom_nodes = []&#xA;&#xA;    async def build_graph(self):&#xA;        g = GraphBuilder()&#xA;&#xA;        # Create a custom node, we will implement our&#xA;        # own handler for this node type&#xA;        h = await g.custom_node(&#xA;            name=&#34;FetchTopHN&#34;,&#xA;            node_type_name=&#34;FetchTopHN&#34;,&#xA;            output=&#34;type O { output: String }&#34;&#xA;        )&#xA;&#xA;        # A prompt node, pulling in the value of the output from FetchTopHN&#xA;        # and templating that into the prompt for GPT3.5&#xA;        h_interpret = await g.prompt_node(&#xA;            name=&#34;InterpretTheGroup&#34;,&#xA;            template=&#34;&#34;&#34;&#xA;                Based on the following list of HackerNews threads, &#xA;                filter this list to only launches of new AI projects: {{FetchTopHN.output}}&#xA;            &#34;&#34;&#34;&#xA;        )&#xA;        await h_interpret.run_when(g, h)&#xA;&#xA;        h_format_and_rank = await g.prompt_node(&#xA;            name=&#34;FormatAndRank&#34;,&#xA;            template=&#34;&#34;&#34;&#xA;                Format this list of new AI projects in markdown, ranking the most &#xA;                interesting projects from most interesting to least. &#xA;                &#xA;                {{InterpretTheGroup.promptResult}}&#xA;            &#34;&#34;&#34;&#xA;        )&#xA;        await h_format_and_rank.run_when(g, h_interpret)&#xA;&#xA;        # Commit the graph, this pushes the configured graph&#xA;        # to our durable execution runtime.&#xA;        await g.commit(self.c, 0)&#xA;&#xA;    async def run(self):&#xA;        # Construct the agent graph&#xA;        await self.build_graph()&#xA;&#xA;        # Start graph execution from the root&#xA;        await self.c.play(0, 0)&#xA;&#xA;        # Run the node execution loop&#xA;        await self.c.run_custom_node_loop()&#xA;&#xA;&#xA;async def handle_fetch_hn(node_will_exec):&#xA;    stories = await fetch_hn()&#xA;    result = {&#34;output&#34;: json.dumps([story.__dict__ for story in stories])}&#xA;    return result&#xA;&#xA;&#xA;async def main():&#xA;    w = ChidoriWorker()&#xA;    await w.c.start_server(&#34;:memory:&#34;)&#xA;    await w.c.register_custom_node_handle(&#34;FetchTopHN&#34;, handle_fetch_hn)&#xA;    await w.run()&#xA;&#xA;&#xA;if __name__ == &#34;__main__&#34;:&#xA;    asyncio.run(main())&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;   &lt;td&gt; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate chidori;&#xA;use std::collections::HashMap;&#xA;use std::env;&#xA;use std::net::ToSocketAddrs;&#xA;use anyhow;&#xA;use futures::stream::{self, StreamExt, TryStreamExt};&#xA;use reqwest;&#xA;use serde::{Deserialize, Serialize};&#xA;use serde_json::json;&#xA;use chidori::{create_change_value, NodeWillExecuteOnBranch};&#xA;use chidori::register_node_handle;&#xA;use chidori::translations::rust::{Chidori, CustomNodeCreateOpts, DenoCodeNodeCreateOpts, GraphBuilder, Handler, PromptNodeCreateOpts, serialized_value_to_string};&#xA;&#xA;#[derive(Debug, Deserialize, Serialize)]&#xA;struct Story {&#xA;    title: String,&#xA;    url: Option&amp;lt;String&amp;gt;,&#xA;    score: Option&amp;lt;f32&amp;gt;,&#xA;}&#xA;&#xA;const HN_URL_TOP_STORIES: &amp;amp;&#39;static str = &#34;https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty&#34;;&#xA;&#xA;async fn fetch_hn() -&amp;gt; anyhow::Result&amp;lt;Vec&amp;lt;Story&amp;gt;&amp;gt; {&#xA;    let client = reqwest::Client::new();&#xA;    // Fetch the top 60 story ids&#xA;    let story_ids: Vec&amp;lt;u32&amp;gt; = client.get(HN_URL_TOP_STORIES).send().await?.json().await?;&#xA;&#xA;    // Fetch details for each story&#xA;    let stories: anyhow::Result&amp;lt;Vec&amp;lt;Story&amp;gt;&amp;gt; = stream::iter(story_ids.into_iter().take(30))&#xA;        .map(|id| {&#xA;            let client = &amp;amp;client;&#xA;            async move {&#xA;                let resource = format!(&#34;https://hacker-news.firebaseio.com/v0/item/{}.json?print=pretty&#34;, id);&#xA;                let mut story: Story = client.get(&amp;amp;resource).send().await?.json().await?;&#xA;                Ok(story)&#xA;            }&#xA;        })&#xA;        .buffer_unordered(10)  // Fetch up to 10 stories concurrently&#xA;        .try_collect()&#xA;        .await;&#xA;    stories&#xA;}&#xA;&#xA;async fn handle_fetch_hn(_node_will_exec: NodeWillExecuteOnBranch) -&amp;gt; anyhow::Result&amp;lt;serde_json::Value&amp;gt; {&#xA;    let stories = fetch_hn().await.unwrap();&#xA;    let mut result = HashMap::new();&#xA;    result.insert(&#34;output&#34;, format!(&#34;{:?}&#34;, stories));&#xA;    Ok(serde_json::to_value(result).unwrap())&#xA;}&#xA;&#xA;/// Maintain a list summarizing recent AI launches across the week&#xA;#[tokio::main]&#xA;async fn main() -&amp;gt; anyhow::Result&amp;lt;()&amp;gt; {&#xA;    let mut c = Chidori::new(String::from(&#34;0&#34;), String::from(&#34;http://localhost:9800&#34;));&#xA;    c.start_server(Some(&#34;:memory:&#34;.to_string())).await?;&#xA;&#xA;    let mut g = GraphBuilder::new();&#xA;&#xA;    let h = g.custom_node(CustomNodeCreateOpts {&#xA;        name: &#34;FetchTopHN&#34;.to_string(),&#xA;        node_type_name: &#34;FetchTopHN&#34;.to_string(),&#xA;        output: Some(&#34;type O { output: String }&#34;.to_string()),&#xA;        ..CustomNodeCreateOpts::default()&#xA;    })?;&#xA;&#xA;    let mut h_interpret = g.prompt_node(PromptNodeCreateOpts {&#xA;        name: &#34;InterpretTheGroup&#34;.to_string(),&#xA;        template: &#34;Based on the following list of HackerNews threads, filter this list to only launches of new AI projects: {{FetchTopHN.output}}&#34;.to_string(),&#xA;        ..PromptNodeCreateOpts::default()&#xA;    })?;&#xA;    h_interpret.run_when(&amp;amp;mut g, &amp;amp;h)?;&#xA;&#xA;    let mut h_format_and_rank = g.prompt_node(PromptNodeCreateOpts {&#xA;        name: &#34;FormatAndRank&#34;.to_string(),&#xA;        template: &#34;Format this list of new AI projects in markdown, ranking the most interesting projects from most interesting to least. {{InterpretTheGroup.promptResult}}&#34;.to_string(),&#xA;        ..PromptNodeCreateOpts::default()&#xA;    })?;&#xA;    h_format_and_rank.run_when(&amp;amp;mut g, &amp;amp;h_interpret)?;&#xA;&#xA;    // Commit the graph&#xA;    g.commit(&amp;amp;c, 0).await?;&#xA;&#xA;    // Start graph execution from the root&#xA;    c.play(0, 0).await?;&#xA;&#xA;    // Register the handler for our custom node&#xA;    register_node_handle!(c, &#34;FetchTopHN&#34;, handle_fetch_hn);&#xA;&#xA;    // Run the node execution loop&#xA;    if let Err(x) = c.run_custom_node_loop().await {&#xA;        eprintln!(&#34;Custom Node Loop Failed On - {:?}&#34;, x);&#xA;    };&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt;&#xA;&lt;/table&gt; &#xA;&lt;h2&gt;ü§î About&lt;/h2&gt; &#xA;&lt;h3&gt;Reactive Runtime&lt;/h3&gt; &#xA;&lt;p&gt;At its core, Chidori brings a reactive runtime that orchestrates interactions between different agents and their components. The runtime is comprised of &#34;nodes&#34;, which react to system changes they subscribe to, providing dynamic and responsive behavior in your AI systems. Nodes can encompass code, prompts, vector databases, custom code, services, or even complete systems.&lt;/p&gt; &#xA;&lt;h3&gt;Monitoring and Observability&lt;/h3&gt; &#xA;&lt;p&gt;Chidori ensures comprehensive monitoring and observability of your agents. We record all the inputs and outputs emitted by nodes, enabling us to explain precisely what led to what, enhancing your debugging experience and understanding of the system‚Äôs production behavior.&lt;/p&gt; &#xA;&lt;h3&gt;Branching and Time-Travel&lt;/h3&gt; &#xA;&lt;p&gt;With Chidori, you can take snapshots of your system and explore different possible outcomes from that point (branching), or rewind the system to a previous state (time-travel). This functionality improves error handling, debugging, and system robustness by offering alternative pathways and do-overs.&lt;/p&gt; &#xA;&lt;h3&gt;Code Interpreter Environments&lt;/h3&gt; &#xA;&lt;p&gt;Chidori comes with first-class support for code interpreter environments like &lt;a href=&#34;https://deno.land/&#34;&gt;Deno&lt;/a&gt; or &lt;a href=&#34;https://github.com/bazelbuild/starlark/raw/master/spec.md&#34;&gt;Starlark&lt;/a&gt;. You can execute code directly within your system, providing quick startup, ease of use, and secure execution. We&#39;re continually working on additional safeguards against running untrusted code, with containerized nodes support coming soon.&lt;/p&gt; &#xA;&lt;h2&gt;üõ£Ô∏è Roadmap&lt;/h2&gt; &#xA;&lt;h3&gt;Short term&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Reactive subscriptions between nodes&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Branching and time travel debugging, reverting execution of a graph&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Node.js, Python, and Rust support for building and executing graphs&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Simple local vector db for development&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Adding support for containerized nodes&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Allowing filtering in node queries&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Medium term&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Analysis tools for comparing executions&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Agent re-evaluation with feedback&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Definitive patterns for human in the loop agents&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Adding support for more vector databases&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Adding support for other LLM sources&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; Adding support for more code interpreter environments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;This is an early open source release and we&#39;re looking for collaborators from the community. A good place to start would be to join our &lt;a href=&#34;https://discord.gg/CJwKsPSgew&#34;&gt;discord&lt;/a&gt;!&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;Why Another AI Framework?&lt;/h3&gt; &#xA;&lt;p&gt;Chidori focuses on the specifics of how LLM+code execution operates rather than providing specific compositions of prompts. Other frameworks haven‚Äôt focused on this space, and it&#39;s an important one. We reduce accidental complexity in building systems for long-running agents; this helps developers build successful systems.&lt;/p&gt; &#xA;&lt;h3&gt;Why Chidori?&lt;/h3&gt; &#xA;&lt;p&gt;Chidori is the name of the lightning blade technique used by Kakashi in the Naruto anime series. It also happens to &lt;a href=&#34;https://en.wikipedia.org/wiki/Chidori&#34;&gt;mean Thousand Birds in Japanese&lt;/a&gt;, which is a nice coincidence.&lt;/p&gt; &#xA;&lt;h3&gt;Well then why Thousand Birds?&lt;/h3&gt; &#xA;&lt;p&gt;Thousand Birds is a reference to flocks of birds (or a murmuration) and the emergent behavior that arises from their interactions. We think this is a good metaphor for the behavior of long running agents, the internal units of LLM execution within them, and the emergent behavior that arises from their interactions.&lt;/p&gt; &#xA;&lt;h3&gt;Why Rust?&lt;/h3&gt; &#xA;&lt;p&gt;Rust is a great language for building systems, we like the type system and the guarantees provided by it. We also like the performance characteristics of Rust, and the ability to build a single binary that can be deployed anywhere. The Rust ecosystem makes it fairly easy to provide bindings to other languages, which is important for us to provide a good developer experience.&lt;/p&gt; &#xA;&lt;h2&gt;Inspiration&lt;/h2&gt; &#xA;&lt;p&gt;Our framework is inspired by the work of many others, including:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://temporal.io&#34;&gt;Temporal.io&lt;/a&gt; - providing reliability and durability to workflows&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;http://witheve.com&#34;&gt;Eve&lt;/a&gt; - developing patterns for building reactive systems and reducing accidental complexity&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://timelydataflow.github.io/timely-dataflow&#34;&gt;Timely Dataflow&lt;/a&gt; - efficiently streaming changes&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.langchain.com&#34;&gt;Langchain&lt;/a&gt; - developing tools and patterns for building with LLMs&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Thousand Birds is under the MIT license. See the &lt;a href=&#34;https://raw.githubusercontent.com/ThousandBirdsInc/chidori/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; for more information.&lt;/p&gt; &#xA;&lt;h2&gt;Help us out!&lt;/h2&gt; &#xA;&lt;p&gt;Please star the github repo and give us feedback in &lt;a href=&#34;https://discord.gg/CJwKsPSgew&#34;&gt;discord&lt;/a&gt;!&lt;/p&gt;</summary>
  </entry>
</feed>