<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-04-07T01:43:21Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>godzie44/BugStalker</title>
    <updated>2024-04-07T01:43:21Z</updated>
    <id>tag:github.com,2024-04-07:/godzie44/BugStalker</id>
    <link href="https://github.com/godzie44/BugStalker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust debugger for Linux x86-64&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BugStalker&lt;/h1&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Modern debugger for Linux x86-64. Written in Rust for Rust programs.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/doc/demo.gif&#34; alt=&#34;debugger-demo&#34;&gt;&lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h1&gt;Table of Contents&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#bugstalker&#34;&gt;BugStalker&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#supported-rustc-versions&#34;&gt;Supported rustc versions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#start-debugger-session&#34;&gt;Start debugger session&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#help&#34;&gt;Help&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#start-and-restart&#34;&gt;Start and restart&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#stopping-and-continuing&#34;&gt;Stopping and continuing&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#examining-the-stack&#34;&gt;Examining the stack&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#examining-source-files&#34;&gt;Examining source files&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#examining-data&#34;&gt;Examining data&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#other-commands&#34;&gt;Other commands&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#tui-interface&#34;&gt;Tui interface&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#oracles&#34;&gt;Oracles&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Supported rustc versions&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;1.75&lt;/li&gt; &#xA; &lt;li&gt;1.76&lt;/li&gt; &#xA; &lt;li&gt;1.77&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;written in rust for rust language with simplicity as a priority goal&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#stopping-and-continuing&#34;&gt;breakpoints, steps, signals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;multithreaded application support&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#examining-data&#34;&gt;data query expressions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;support for a rust type system (collections, smart pointers, thread locals and many others), not only for printing but also for interaction&lt;/li&gt; &#xA; &lt;li&gt;two ui types: console and &lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#tui-interface&#34;&gt;tui&lt;/a&gt;, switch available at any moment&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#oracles&#34;&gt;oracle&lt;/a&gt; as an extension mechanism&lt;/li&gt; &#xA; &lt;li&gt;builtin &lt;a href=&#34;https://raw.githubusercontent.com/godzie44/BugStalker/master/#oracles&#34;&gt;tokio oracle&lt;/a&gt; - like &lt;a href=&#34;https://github.com/tokio-rs/console&#34;&gt;tokio_console&lt;/a&gt; but there is no need to make changes to the source codes&lt;/li&gt; &#xA; &lt;li&gt;and much more!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;First check if the necessary dependencies (&lt;code&gt;pkg-config&lt;/code&gt; and &lt;code&gt;libunwind-dev&lt;/code&gt;) are installed:&lt;/p&gt; &#xA;&lt;p&gt;For example, ubuntu/debian:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt install pkg-config libunwind-dev&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now install debugger:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo install bugstalker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That&#39;s all, &lt;code&gt;bs&lt;/code&gt; command is available now!&lt;/p&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;Problem with libunwind?&lt;/summary&gt; If you have any issues with `libunwind`, you can try to install `bs` with native unwinder (currently, I don&#39;t recommend this method because libunwind is better :)) &#xA; &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo install bugstalker --no-default-features&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Start debugger session&lt;/h2&gt; &#xA;&lt;p&gt;To start with program from binary file use:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bs my_cool_program&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or with arguments:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bs my_cool_program -- --arg1 val1 --arg2 val2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or attach to program by its pid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bs -p 123&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Help&lt;/h2&gt; &#xA;&lt;p&gt;Print &lt;code&gt;help&lt;/code&gt; for view all available commands.&lt;/p&gt; &#xA;&lt;h2&gt;Start and restart&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.terminalizer.com/view/2914f76f5890&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;run&lt;/code&gt; - start or restart a program (alias: &lt;code&gt;r&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Stopping and continuing&lt;/h2&gt; &#xA;&lt;p&gt;The Debugger stops your program when breakpoints are hit, or after steps commands, or when the OS signal is coming. BugStalker always stops the whole program, meaning that all threads are stopped. Thread witch initiated a stop become a current selected thread.&lt;/p&gt; &#xA;&lt;h3&gt;Continue execution&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/6d5048415891&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;continue&lt;/code&gt; - resume a stopped program&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Breakpoints&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/0a5ee2a05889&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;break {file}:{line}&lt;/code&gt; - set breakpoint at line (alias: &lt;code&gt;b {file}:{line}&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;break {function name}&lt;/code&gt; - set breakpoint at start of the function (alias: &lt;code&gt;b {function_name}&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;break {instruction address}&lt;/code&gt; - set breakpoint at instruction (alias: &lt;code&gt;b {instruction address}&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;break remove {number}&lt;/code&gt; - remove breakpoint by its number (alias: &lt;code&gt;b r {number}&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;break remove {file}:{line}&lt;/code&gt; - remove breakpoint at line (alias: &lt;code&gt;b r {file}:{line}&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;break remove {function name}&lt;/code&gt; - remove breakpoint at start of the function (alias: &lt;code&gt;b r {function name}&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;break info&lt;/code&gt; - print all breakpoints&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Steps&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/cb4e35a55888&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;stepi&lt;/code&gt; - step a single instruction&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;step&lt;/code&gt; - step a program until it reaches a different source line (alias: &lt;code&gt;stepinto&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;next&lt;/code&gt; - step a program, stepping over subroutine (function) calls (alias: &lt;code&gt;stepover&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;finish&lt;/code&gt; - execute a program until selected stack frame returns (alias: &lt;code&gt;stepout&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Signals&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/4ed500545892&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;You can send OS signal to debugee program, for example, send SIGINT (ctrl+c) to the debugee program to stop it.&lt;/p&gt; &#xA;&lt;h3&gt;Change current selected thread&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/ad448b5c5893&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;thread info&lt;/code&gt; - print list of information about threads&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;thread current&lt;/code&gt; - prints current selected thread&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;thread switch {number}&lt;/code&gt; - switch selected thread&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examining the stack&lt;/h2&gt; &#xA;&lt;p&gt;When your program has stopped, the first thing you need to know is where it stopped and how it got there.&lt;/p&gt; &#xA;&lt;p&gt;Each time your program performs a function call, the information about where in your program the call was made from is saved in a block of data called a stack frame. The frame also contains the arguments of the call and the local variables of the function that was called. All the stack frames are allocated in a region of memory called the call stack.&lt;/p&gt; &#xA;&lt;h3&gt;Stack frames&lt;/h3&gt; &#xA;&lt;p&gt;The call stack is divided up into contiguous pieces called stack frames. Each frame is the data associated with one call to one function. The frame contains the arguments given to the function, the function&#39;s local variables, and the address at which the function is executed.&lt;/p&gt; &#xA;&lt;h3&gt;Backtrace&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/64f028235898&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;backtrace&lt;/code&gt; - print backtrace of current stopped thread (alias: &lt;code&gt;bt&lt;/code&gt;). Backtrace contains information about thread (number, pid, address of instruction where thread stopped) and all frames starting with the currently executing frame (frame zero), followed by its caller (frame one), and on up the stack.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;backtrace all&lt;/code&gt; - print backtraces of all active threads (alias: &lt;code&gt;bt all&lt;/code&gt;).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Select a frame&lt;/h3&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/8ac0ed475896&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Most commands for examining the stack and other data in your program works on whichever stack frame is selected at the moment.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;frame info&lt;/code&gt; - print information about current selected frame.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;frame switch {num}&lt;/code&gt; - change current selected frame.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examining source files&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/be63c4b85899&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;BugStalker can print parts of your program&#39;s source code. When your program stops, the debugger spontaneously prints the line where it stopped. There is &lt;code&gt;source&lt;/code&gt; commands for print more.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;source fn&lt;/code&gt; - print current selected function&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;source {num}&lt;/code&gt; - print lines range [current_line-num; current_line+num]&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;source asm&lt;/code&gt; - print assembly representation of current selected function&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Examining data&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/418b5da85903&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Of course, you need a way to examine data of your program.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;var {expression}|locals&lt;/code&gt; command for print local and global variables&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;arg {expression}|all&lt;/code&gt; command for print a function arguments&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These commands accept expressions as input or have a special mode (&lt;code&gt;var locals&lt;/code&gt; print all local variables, &lt;code&gt;args all&lt;/code&gt; print all arguments).&lt;/p&gt; &#xA;&lt;h3&gt;Expression&lt;/h3&gt; &#xA;&lt;p&gt;BugStalker has a special syntax for explore program data. You can dereference references, get structure fields, slice arrays or get elements from vectors by its index (and much more!).&lt;/p&gt; &#xA;&lt;p&gt;Operator available in expressions:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;select variable by its name (ex. &lt;code&gt;var a&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;dereference pointers/references/smart pointers (ex. &lt;code&gt;var *ref_to_a&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;take a structure field (ex. &lt;code&gt;var some_struct.some_field&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;take an element by index from arrays, slices, vectors, hashmaps (ex. &lt;code&gt;var arr[1]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;slice arrays, vectors, slices (ex. &lt;code&gt;var some_vector[1..3]&lt;/code&gt; or &lt;code&gt;var some_vector[1..]&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;cast constant address to a pointer of a concrete type (ex. &lt;code&gt;(*mut SomeType)0x123AABCD&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;parentheses for control an operator execution ordering&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Write expressions is simple, and you can do it right now! Some examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;var *some_variable&lt;/code&gt; - dereference and print value of &lt;code&gt;some_variable&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;var some_array[0][2..5]&lt;/code&gt; - print 3 elements, starts from index 2 from zero element of &lt;code&gt;some_array&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;var *some_array[0]&lt;/code&gt; - print dereferenced value of &lt;code&gt;some_array[0]&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;var (*some_array)[0]&lt;/code&gt; - print a zero element of &lt;code&gt;*some_array&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;var *(*(var1.field1)).field2[1][2]&lt;/code&gt; - print dereferenced value of element at index 2 in element at index 1 at field &lt;code&gt;field2&lt;/code&gt; in dereferenced value of field &lt;code&gt;field1&lt;/code&gt; at variable var1 🤡&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Other commands&lt;/h2&gt; &#xA;&lt;p&gt;Of course, the debugger provides many more commands:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;symbol {name or regex}&lt;/code&gt; - print symbol kind and address&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;memory read {addr}&lt;/code&gt; - read debugged program memory (alias: &lt;code&gt;mem read&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;memory write {addr} {value}&lt;/code&gt; - write into debugged program memory (alias: &lt;code&gt;mem write&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;register read {reg_name}&lt;/code&gt; - print value of register by name (x86_64 register name in lowercase) (alias: &lt;code&gt;reg read&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;register write {reg_name} {value}&lt;/code&gt; - set new value to register by name (alias: &lt;code&gt;reg write&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;register info&lt;/code&gt; - print list of registers with it values (alias: &lt;code&gt;reg info&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sharedlib info&lt;/code&gt; - show list of shared libraries&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;quit&lt;/code&gt; - exit the BugStalker (alias: &lt;code&gt;q&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Tui interface&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/c8de6a1e5901&#34;&gt;demo&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;One of the most funny BugStalker features is switching between old school terminal interface and pretty tui at any moment.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;tui&lt;/code&gt; - switch too terminal ui (in tui use &lt;code&gt;Esc&lt;/code&gt; for switch back)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Oracles&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/0ea924865908&#34;&gt;demo console&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://terminalizer.com/view/971412185907&#34;&gt;demo tui&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Oracle is a module that expands the capabilities of the debugger. Oracles can monitor the internal state of a program to display interesting information. For example, tokio oracle is able to provide information about tokio runtime during program debugging without the need to change the source code. You must run the debugger with enabled oracle, for example, for tokio oracle:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bs --oracle tokio ...&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then use &lt;code&gt;oracle&lt;/code&gt; command for view oracle information:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;oracle {oracle name} {subcommands}&lt;/code&gt; - run oracle (ex. &lt;code&gt;oracle tokio&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Oracles also available in tui. Currently, there is only one builtin oracle - tokio oracle.&lt;/p&gt;</summary>
  </entry>
</feed>