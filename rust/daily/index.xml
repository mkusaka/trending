<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-08-30T01:34:26Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>a-b-street/abstreet</title>
    <updated>2024-08-30T01:34:26Z</updated>
    <id>tag:github.com,2024-08-30:/a-b-street/abstreet</id>
    <link href="https://github.com/a-b-street/abstreet" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Transportation planning and traffic simulation software for creating cities friendlier to walking, biking, and public transit&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;A/B Street&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://zenodo.org/badge/latestdoi/135952436&#34;&gt;&lt;img src=&#34;https://zenodo.org/badge/135952436.svg?sanitize=true&#34; alt=&#34;DOI&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://discord.gg/nCvMD4xj4K&#34;&gt;&lt;img src=&#34;https://dcbadge.vercel.app/api/server/nCvMD4xj4K?style=flat&#34; alt=&#34;&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ever been stuck in traffic on a bus, wondering why is there legal street parking instead of a dedicated bus lane? A/B Street is a project to plan, simulate, and communicate visions for making cities friendlier to people walking, biking, and taking public transit. We create software to &lt;a href=&#34;https://a-b-street.github.io/docs/software/abstreet.html&#34;&gt;simulate traffic, edit streets and intersections&lt;/a&gt;, &lt;a href=&#34;https://a-b-street.github.io/docs/software/ungap_the_map/index.html&#34;&gt;plan bike networks&lt;/a&gt;, create &lt;a href=&#34;https://a-b-street.github.io/docs/software/ltn/index.html&#34;&gt;low-traffic neighborhoods&lt;/a&gt;, and educate the public about &lt;a href=&#34;https://a-b-street.github.io/docs/software/santa.html&#34;&gt;15-minute neighborhoods through games&lt;/a&gt;. The project works anywhere in the world, thanks to &lt;a href=&#34;https://www.openstreetmap.org/about&#34;&gt;OpenStreetMap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Run it on &lt;a href=&#34;https://play.abstreet.org/0.3.49/abstreet.html&#34;&gt;your web browser&lt;/a&gt;, &lt;a href=&#34;https://github.com/a-b-street/abstreet/releases/download/v0.3.49/abstreet_windows_v0_3_49.zip&#34;&gt;Windows&lt;/a&gt;, &lt;a href=&#34;https://github.com/a-b-street/abstreet/releases/download/v0.3.49/abstreet_mac_v0_3_49.zip&#34;&gt;Mac&lt;/a&gt;, &lt;a href=&#34;https://github.com/a-b-street/abstreet/releases/download/v0.3.49/abstreet_linux_v0_3_49.zip&#34;&gt;Linux&lt;/a&gt;, &lt;a href=&#34;https://www.freshports.org/games/abstreet/&#34;&gt;FreeBSD&lt;/a&gt;, or &lt;a href=&#34;https://a-b-street.github.io/docs/user/index.html&#34;&gt;read all instructions&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/tech/dev/index.html&#34;&gt;build from source&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As of January 2024, development of the tools above has slowed down, because newer tools are being developed in other repositories. Please also check out:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://dabreegster.github.io/severance_snape&#34;&gt;Severance Snape&lt;/a&gt; to explore how far walking routes detour to cross big roads&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Urban-Analytics-Technology-Platform/od2net&#34;&gt;od2net&lt;/a&gt; to calculate the most important roads to prioritize for cycling&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Videos&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=LxPD4n_1-LU&#34;&gt;Alpha release trailer&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/project/presentations.html&#34;&gt;Presentations&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://a-b-street.github.io/docs/project/history/retrospective/traffic_sim.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/user/index.html&#34;&gt;User guide&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Technical &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/tech/dev/index.html&#34;&gt;Developer guide&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/tech/trafficsim/discrete_event/index.html&#34;&gt;How the traffic simulation works&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/tech/map/geometry/index.html&#34;&gt;Intersection geometry&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Project &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/software/ungap_the_map/plan.html#future-directions&#34;&gt;Roadmap&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/project/contributing.html&#34;&gt;Getting involved&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/project/history/retrospective/index.html&#34;&gt;Accomplishments &amp;amp; challenges&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Project mission&lt;/h2&gt; &#xA;&lt;p&gt;We amplify the efforts of individuals and advocacy groups who campaign to transition cities away from private motor vehicles. We believe in transparent and reproducible analysis, so all of our work is open source and based on public data. We believe everybody should have a voice in shaping their city, so our software aims to be easy to use.&lt;/p&gt; &#xA;&lt;p&gt;Why not leave city planning to professionals? People are local experts on the small slice of the city they interact with daily -- the one left turn lane that always backs up or a certain set of poorly timed walk signals. &lt;a href=&#34;http://www.govtech.com/data/SimCities-Can-City-Planning-Mistakes-Be-Avoided-Through-Data-Driven-Simulations.html&#34;&gt;Laura Adler&lt;/a&gt; writes:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&#34;Only with simple, accessible simulation programs can citizens become active generators of their own urban visions, not just passive recipients of options laid out by government officials.&#34;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Existing urban planning software is either proprietary or hard to use. A/B Street strives to be highly accessible, by being a fun, engaging game. See &lt;a href=&#34;https://a-b-street.github.io/docs/project/motivations.html&#34;&gt;here&lt;/a&gt; for more guiding principles.&lt;/p&gt; &#xA;&lt;h2&gt;Credits&lt;/h2&gt; &#xA;&lt;p&gt;Core team:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Dustin Carlino (&lt;a href=&#34;mailto:dabreegster@gmail.com&#34;&gt;dabreegster@gmail.com&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.yuwen-li.com/&#34;&gt;Yuwen Li&lt;/a&gt; (UX)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/michaelkirk&#34;&gt;Michael Kirk&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://a-b-street.github.io/docs/project/team.html&#34;&gt;See full credits&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Contact &lt;a href=&#34;mailto:dabreegster@gmail.com&#34;&gt;dabreegster@gmail.com&lt;/a&gt; or follow &lt;a href=&#34;https://twitter.com/CarlinoDustin&#34;&gt;@CarlinoDustin&lt;/a&gt; for updates.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>spaceandtimelabs/sxt-proof-of-sql</title>
    <updated>2024-08-30T01:34:26Z</updated>
    <id>tag:github.com,2024-08-30:/spaceandtimelabs/sxt-proof-of-sql</id>
    <link href="https://github.com/spaceandtimelabs/sxt-proof-of-sql" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Space and Time | Proof of SQL&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Proof of SQL&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/ProofOfSQLBanner.png&#34; alt=&#34;Proof of SQL&#34; width=&#34;100%&#34;&gt; &lt;a href=&#34;https://twitter.com/intent/follow?screen_name=spaceandtimedb&#34;&gt;&lt;img alt=&#34;Twitter&#34; src=&#34;https://img.shields.io/twitter/follow/spaceandtimedb.svg?style=social&amp;amp;label=Follow&#34;&gt;&lt;/a&gt;&lt;a href=&#34;http://discord.gg/SpaceandTimeDB&#34;&gt;&lt;img alt=&#34;Discord Server&#34; src=&#34;https://img.shields.io/discord/953025874154893342?logo=discord&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p&gt;Proof of SQL is a high performance zero knowledge (ZK) prover developed by the &lt;a href=&#34;https://www.spaceandtime.io/&#34;&gt;Space and Time&lt;/a&gt; team, which cryptographically guarantees SQL queries were computed accurately against untampered data. It targets online latencies while proving computations over entire chain histories, an order of magnitude faster than state-of-the art zkVMs and coprocessors.&lt;/p&gt; &#xA;&lt;p&gt;As the first sub-second ZK prover, the protocol can execute analytic queries over 100k-row tables in less than a second on a single GPU (see benchmarks below). It can aggregate over millions of rows of indexed data within Ethereum block time on a single NVIDIA T4. The protocol is designed to support both onchain and offchain verification, leveraging a novel commitment scheme which significantly lowers gas fees with onchain verification.&lt;/p&gt; &#xA;&lt;p&gt;Using Proof of SQL, developers can compute over both onchain and offchain datasets in a trustless manner, proving the result back to their smart contract (or offchain verifier) just-in-time during a transaction to power more sophisticated DeFi protocols with data-driven contracts. Proof of SQL can be integrated into any SQL database (such as &lt;a href=&#34;https://cloud.google.com/blog/topics/partners/how-space-and-times-proof-of-sql-integrates-with-bigquery&#34;&gt;Google BigQuery&lt;/a&gt;), centralized or decentralized, and is already securing some of the most prominent Web3 apps, financial institutions, and enterprises.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Proof of SQL is in active development, and not all SQL functions are supported yet. Proof of SQL is most powerful as a community-driven project. We hope to foster a large group of contributers that can help maintain, improve, and use this project to create a trustless and data-driven future. Please create an Issue, file a PR, or reach out via Discord if you want to add a SQL feature, integrate into another ZK solution, use this in your project, or anything else! Check out our guidelines: &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;For Developers&lt;/h2&gt; &#xA;&lt;p&gt;Get started with Proof of SQL by using the published crate on &lt;a href=&#34;https://crates.io/&#34;&gt;crates.io&lt;/a&gt; or clone the repo and check out the examples. Check out the following sections of the README:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/#examples&#34;&gt;Examples&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/#benchmarks&#34;&gt;Benchmarks&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/#supported-sql-syntax&#34;&gt;Supported SQL Syntax&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/#roadmap&#34;&gt;Roadmap&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/#protocol-overview&#34;&gt;Protocol Overview&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Setup&lt;/h2&gt; &#xA;&lt;h3&gt;Prerequisites&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Linux x86_64 (NOTE: Most of the codebase &lt;em&gt;should&lt;/em&gt; work for most rust targets. However, proofs are accelerated using NVIDIA GPUs, so other targets would run very slowly and may require modification.)&lt;/li&gt; &#xA; &lt;li&gt;NVIDIA GPU &amp;amp; Drivers (Strongly Recommended)&lt;/li&gt; &#xA; &lt;li&gt;lld (&lt;code&gt;sudo apt install lld&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;clang (&lt;code&gt;sudo apt install clang&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.rust-lang.org/tools/install&#34;&gt;Rust 1.78.0&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;!-- TDDO: add this in when we put it on crates.io&#xA;&#xA;### Setup&#xA;&#xA;To use Proof of SQL, add it as a dependency in your `Cargo.toml` file:&#xA;&#xA;```toml&#xA;[dependencies]&#xA;proof-of-sql = &#34;x.x.x&#34;&#xA;```&#xA;&#xA;Replace `x.x.x` with the version number you want to use. You can now use Proof of SQL in your Rust project. Import the necessary modules using `proof-of-sql::prelude::*` and start using the library&#39;s features in your code:&#xA;&#xA;```rust&#xA;use proof-of-sql::prelude::*;&#xA;&#xA;fn main() {&#xA;    // Your code here&#xA;}&#xA;```&#xA;--&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;Proof of SQL comes with example code demonstrating its usage. You can find the examples in the &lt;code&gt;crates/proof-of-sql/examples&lt;/code&gt; folder. Below are explainations of how to run some of these examples:&lt;/p&gt; &#xA;&lt;h3&gt;&#34;Hello World&#34; Example&lt;/h3&gt; &#xA;&lt;p&gt;The &#34;Hello World&#34; example demonstrates generating and verifying a proof of the query &lt;code&gt;SELECT b FROM table WHERE a = 2&lt;/code&gt; for the table:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;a&lt;/th&gt; &#xA;   &lt;th&gt;b&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;hi&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;hello&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;there&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;world&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h4&gt;Run&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo run --example hello_world&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Output&lt;/h4&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Warming up GPU... 520.959485ms&#xA;Loading data... 3.229767ms&#xA;Parsing Query... 1.870256ms&#xA;Generating Proof... 467.45371ms&#xA;Verifying Proof... 7.106864ms&#xA;Valid proof!&#xA;Query result: OwnedTable { table: {Identifier { name: &#34;b&#34; }: VarChar([&#34;hello&#34;, &#34;world&#34;])} }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For a detailed explanation of the example and its implementation, refer to the &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/crates/proof-of-sql/examples/hello_world/README.md&#34;&gt;README&lt;/a&gt; and source code in &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/crates/proof-of-sql/examples/hello_world/main.rs&#34;&gt;hello_world/main.rs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;CSV Database Example&lt;/h3&gt; &#xA;&lt;p&gt;The CSV Database example demonstrates an implementation of a simple CSV-backed database with Proof of SQL capabilities.&lt;/p&gt; &#xA;&lt;p&gt;To install the example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo install --example posql_db --path crates/proof-of-sql #TODO: update once this is published to crates.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For detailed usage instructions and examples of how to create, append to, prove, and verify queries in the CSV-backed database, refer to the &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/crates/proof-of-sql/examples/posql_db/README.md&#34;&gt;README&lt;/a&gt; and source code in &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/crates/proof-of-sql/examples/posql_db/main.rs&#34;&gt;posql_db/main.rs&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Benchmarks&lt;/h2&gt; &#xA;&lt;p&gt;Proof of SQL is optimized for speed and efficiency. Here&#39;s how it&#39;s so fast:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;We use &lt;strong&gt;native, precomputed commitments&lt;/strong&gt; to the data. In other words, when adding data to the database, we compute a &#34;digest&#34; of the data, which effectively &#34;locks in&#34; the data. Instead of using a merkle tree based commitment, like those use in most blockchains, we use the commitment scheme that is inherent to Proof of SQL itself.&lt;/li&gt; &#xA; &lt;li&gt;SQL is conducive to a &lt;strong&gt;natural arithmatization&lt;/strong&gt;, meaning that there is very little overhead compared with other proof systems that are designed around instructions/sequential compute. Instead, Proof of SQL is designed from the ground up with data processing and parallelism in mind.&lt;/li&gt; &#xA; &lt;li&gt;We use &lt;strong&gt;GPU acceleration&lt;/strong&gt; on the most expensive cryptography in the prover. We use &lt;a href=&#34;https://github.com/spaceandtimelabs/blitzar&#34;&gt;Blitzar&lt;/a&gt; as our acceleration framework.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h3&gt;Setup&lt;/h3&gt; &#xA;&lt;p&gt;We run benchmarks using both a machine with multiple NVIDIA A100 GPUs (NC A100 v4-series Azure VM) and a machine with a single NVIDIA T4 GPU (NCasT4_v3-series Azure VM).&lt;/p&gt; &#xA;&lt;p&gt;To run these benchmarks we first generate a large, randomly-filled table of data such as the following:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;/p&gt;&#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;a (BIGINT)&lt;/th&gt; &#xA;   &lt;th&gt;b (BIGINT)&lt;/th&gt; &#xA;   &lt;th&gt;c (VARCHAR)&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;17717&lt;/td&gt; &#xA;   &lt;td&gt;-1&lt;/td&gt; &#xA;   &lt;td&gt;Z&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;11651&lt;/td&gt; &#xA;   &lt;td&gt;-3&lt;/td&gt; &#xA;   &lt;td&gt;W&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-9563&lt;/td&gt; &#xA;   &lt;td&gt;-2&lt;/td&gt; &#xA;   &lt;td&gt;dS&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-6435&lt;/td&gt; &#xA;   &lt;td&gt;-2&lt;/td&gt; &#xA;   &lt;td&gt;x&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;-8338&lt;/td&gt; &#xA;   &lt;td&gt;-1&lt;/td&gt; &#xA;   &lt;td&gt;jI&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;12420&lt;/td&gt; &#xA;   &lt;td&gt;-2&lt;/td&gt; &#xA;   &lt;td&gt;DX&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;11546&lt;/td&gt; &#xA;   &lt;td&gt;-3&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;18292&lt;/td&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;6500&lt;/td&gt; &#xA;   &lt;td&gt;-1&lt;/td&gt; &#xA;   &lt;td&gt;C&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;16219&lt;/td&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;D5&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;p&gt;Then, we run the following 3 queries against these data, prove, and verify the results:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Query #1 - &lt;code&gt;SELECT b FROM table WHERE a = 0&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Query #2 - &lt;code&gt;SELECT * FROM table WHERE ((a = 0) or (b = 1)) and (not (c = &#39;a&#39;))&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Query #3 - &lt;code&gt;SELECT b, SUM(a) as sum_a, COUNT(*) as c FROM table WHERE (c = &#39;a&#39; OR c = &#39;b&#39;) AND b &amp;gt; 0 GROUP BY b&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;An example result for the 3rd query looks like this:&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;/p&gt;&#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;b&lt;/th&gt; &#xA;   &lt;th&gt;sum_a&lt;/th&gt; &#xA;   &lt;th&gt;c&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;1&lt;/td&gt; &#xA;   &lt;td&gt;-45585&lt;/td&gt; &#xA;   &lt;td&gt;301&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;2&lt;/td&gt; &#xA;   &lt;td&gt;-137574,&lt;/td&gt; &#xA;   &lt;td&gt;300&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;3&lt;/td&gt; &#xA;   &lt;td&gt;-107073&lt;/td&gt; &#xA;   &lt;td&gt;282&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Results&lt;/h3&gt; &#xA;&lt;p&gt;The results are shown in the graphs below for the T4 machine and the A100 machine on all three of the queries listed above. Broadly the results are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A query against 100k rows of data can be proven in sub-second time.&lt;/li&gt; &#xA; &lt;li&gt;A query against 100 million rows of data can be proven in roughly a minute.&lt;/li&gt; &#xA; &lt;li&gt;Verification time is roughly 20ms across the board.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/ProofOfSQLBenchmarks200kT4.svg?sanitize=true&#34; alt=&#34;Proof Of SQL Benchmarks (200k - T4)&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/ProofOfSQLBenchmarks200kA100.svg?sanitize=true&#34; alt=&#34;Proof Of SQL Benchmarks (200k - A100)&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/ProofOfSQLBenchmarks10mT4.svg?sanitize=true&#34; alt=&#34;Proof Of SQL Benchmarks (10m - T4)&#34; width=&#34;50%&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/ProofOfSQLBenchmarks100mA100.svg?sanitize=true&#34; alt=&#34;Proof Of SQL Benchmarks (100m - A100)&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Supported SQL Syntax&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/docs/SQLSyntaxSpecification.md&#34;&gt;SQL specification&lt;/a&gt; for more details. Broadly, we support the following with more SQL features being added quickly:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SELECT ... WHERE&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;GROUP BY&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Comparison operations: &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc.&lt;/li&gt; &#xA; &lt;li&gt;Logical operations: &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;NOT&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Numerical operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Aggregations: &lt;code&gt;SUM&lt;/code&gt;, &lt;code&gt;COUNT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;Data Types: &lt;code&gt;BOOLEAN&lt;/code&gt;, Integer types, &lt;code&gt;VARCHAR&lt;/code&gt;, &lt;code&gt;DECIMAL75&lt;/code&gt;, &lt;code&gt;TIMESTAMP&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;Proof of SQL is in active development. Here are some items that we are currently working on. We are happy to recieve feedback on additional features that the community requests.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Expanded SQL support - in particular, multi-table queries (like JOIN) and subqueries&lt;/li&gt; &#xA; &lt;li&gt;Cluster scale proofs - this means faster proofs over larger tables!&lt;/li&gt; &#xA; &lt;li&gt;Solidity (EVM) verifier - for more efficient onchain verification.&lt;/li&gt; &#xA; &lt;li&gt;A novel commitment scheme - while we support a variety of commitment schemes, we are developing a commitment scheme specifically for database operations, ensuring lower-gas onchain verification.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We are also currently undergoing robust security audits. Keep this in mind as you use this code.&lt;/p&gt; &#xA;&lt;h2&gt;Protocol Overview&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://assets-global.website-files.com/642d91209f1e772d3740afa0/658edf3cf26933c4878ec965_whitepaper.pdf&#34;&gt;Space and Time Whitepaper&lt;/a&gt; for a more in depth explanation. We will also be adding more technical documentation to this repo soon.&lt;/p&gt; &#xA;&lt;p&gt;We created this protocol with a few key goals. First, it needs to be super fast for data processing, both for verification and round-trip execution. This requires a design that is built from the ground up, as opposed to using arbitrary zkVMs. Second, we made it very developer-friendly. Using SQL, the most popular data query language, ensures a familiar experience for anyone building data-focused applications, or sophisticated data-driven contracts. Finally, our protocol is designed to handle complex data processing, not just simple serial compute or data retrieval.&lt;/p&gt; &#xA;&lt;p&gt;In this protocol, there are two main roles: the client sending the query (Verifier) and the database service returning the result (Prover). Of course, the Verifier doesn&#39;t always have to send the query; it can be any client, such as a smart contract, a dapp frontend, or a laptop . This setup is crucial for applications with limited compute or storage but still requires a security guarantee that data analytics are correctly executed and the data remains unaltered. The Prover handles heavy computations, while the Verifier is lightweight, suitable for client devices or smart contracts with limited resources.&lt;/p&gt; &#xA;&lt;p&gt;A key architectural feature is the concept of a commitment, or digest. To ensure data integrity, the Verifier maintains this commitment to detect any tampering. Think of it as a digital fingerprint—a lightweight digest representing the data in the table.&lt;/p&gt; &#xA;&lt;h3&gt;Data Ingestion&lt;/h3&gt; &#xA;&lt;p&gt;The initial interaction between the Verifier and the Prover involves data ingestion. In this process, when a service or client submits data for database inclusion, it first passes through the Verifier. Here, the Verifier generates (or updates) a commitment containing sufficient information to safeguard against tampering throughout the protocol. Once this commitment is established, the Verifier forwards the data to the database for storage, while retaining the commitment for future reference.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/DataIngestionDiagram.png&#34; alt=&#34;Data Ingestion Diagram&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Query Request&lt;/h3&gt; &#xA;&lt;p&gt;The second interaction involves query requests, where the Verifier seeks data analytics on Prover-held data. When a service, client, or Verifier initiates a query request, it sends the request to the Prover. Here, the Prover parses the query, computes the result, and generates a proof, sent alongside the result to the Verifier, which is maintaining the commitment. The Verifier, armed with the proof and commitment, can verify the Prover&#39;s result against the query request.&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/spaceandtimelabs/sxt-proof-of-sql/main/docs/QueryRequestDiagram.png&#34; alt=&#34;Query Request Diagram&#34; width=&#34;50%&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Proof of SQL is licensed under the Decentralized Open Software License 1.0. Please see the &lt;a href=&#34;https://github.com/spaceandtimelabs/sxt-proof-of-sql/raw/main/LICENSE&#34;&gt;LICENSE&lt;/a&gt; file for details.&lt;/p&gt;</summary>
  </entry>
</feed>