<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-15T01:37:13Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>wojciech-graj/oriel</title>
    <updated>2023-08-15T01:37:13Z</updated>
    <id>tag:github.com,2023-08-15:/wojciech-graj/oriel</id>
    <link href="https://github.com/wojciech-graj/oriel" rel="alternate"></link>
    <summary type="html">&lt;p&gt;An interpreter for the 1991 Oriel scripting language&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Oriel&lt;/h1&gt; &#xA;&lt;p&gt;Oriel is a &lt;em&gt;&#34;graphics-based batch language&#34;&lt;/em&gt; from the &lt;em&gt;Power Tools&lt;/em&gt; series of books. This interpreter aims to accurately recreate the 1991 implementation of the language for Windows 3 on modern hardware using Rust and Gtk+3.&lt;/p&gt; &#xA;&lt;p&gt;To read about Oriel, see the book&#39;s chapter in &lt;code&gt;book.pdf&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;Support for the 1994 Windows NT version of Oriel may be added in the future, but &#34;Windows NT Power Tools&#34; is extremely elusive.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wojciech-graj/oriel/master/screenshot/set.png&#34; alt=&#34;set&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/wojciech-graj/oriel/master/screenshot/setkeyboard.png&#34; alt=&#34;setkeyboard&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Build&lt;/h2&gt; &#xA;&lt;p&gt;To compile the program, run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, either run the program using cargo&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo run --release source.orl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or use the binary found at &lt;code&gt;target/release/oriel&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;All of the 55 example programs from the book can be found in the &lt;code&gt;examples&lt;/code&gt; directory. See &lt;a href=&#34;https://raw.githubusercontent.com/wojciech-graj/oriel/master/examples/EXAMPLES.md&#34;&gt;EXAMPLES.md&lt;/a&gt; for an index.&lt;/p&gt; &#xA;&lt;p&gt;A hello world program looks as follows:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;DrawText(10,10,&#34;Hello world!&#34;)&#xA;WaitInput()&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;Copyright (C) 2023  Wojciech Graj&#xA;&#xA;This program is free software: you can redistribute it and/or modify&#xA;it under the terms of the GNU General Public License as published by&#xA;the Free Software Foundation, either version 3 of the License, or&#xA;(at your option) any later version.&#xA;&#xA;This program is distributed in the hope that it will be useful,&#xA;but WITHOUT ANY WARRANTY; without even the implied warranty of&#xA;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#xA;GNU General Public License for more details.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Portions of this software are copyright of their respective authors:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/pest-parser/pest&#34;&gt;pest&lt;/a&gt;, Licensed under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/dtolnay/thiserror&#34;&gt;thiserror&lt;/a&gt;, Licensed under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/gtk-rs/gtk3-rs&#34;&gt;gtk3-rs&lt;/a&gt;, Licensed under the &lt;a href=&#34;https://opensource.org/licenses/MIT&#34;&gt;MIT License&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://gtk.org/&#34;&gt;Gtk+3&lt;/a&gt;, Licensed under the &lt;a href=&#34;https://opensource.org/licenses/LGPL-2.1&#34;&gt;LGPL-2.1+ License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A big thank you goes out to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Geoffrey T. LeBlond, William B. LeBlond, and Jennifer L. Palonus for creating the Oriel language and writing WINDOWS 3 POWER TOOLS&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>denoland/rusty_v8</title>
    <updated>2023-08-15T01:37:13Z</updated>
    <id>tag:github.com,2023-08-15:/denoland/rusty_v8</id>
    <link href="https://github.com/denoland/rusty_v8" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rust bindings for the V8 JavaScript engine&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rusty V8 Binding&lt;/h1&gt; &#xA;&lt;p&gt;V8 Version: 11.7.439.1&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/denoland/rusty_v8/actions&#34;&gt;&lt;img src=&#34;https://github.com/denoland/rusty_v8/workflows/ci/badge.svg?branch=main&#34; alt=&#34;ci&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/v8&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/v8.svg?sanitize=true&#34; alt=&#34;crates&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/v8&#34;&gt;&lt;img src=&#34;https://docs.rs/v8/badge.svg?sanitize=true&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt; &lt;p&gt;Provide high quality Rust bindings to &lt;a href=&#34;https://cs.chromium.org/chromium/src/v8/include/v8.h&#34;&gt;V8&#39;s C++ API&lt;/a&gt;. The API should match the original API as closely as possible.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Do not introduce additional call overhead. (For example, previous attempts at Rust V8 bindings forced the use of Persistent handles.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Do not rely on a binary &lt;code&gt;libv8.a&lt;/code&gt; built outside of cargo. V8 is a very large project (over 600,000 lines of C++) which often takes 30 minutes to compile. Furthermore, V8 relies on Chromium&#39;s bespoke build system (gn + ninja) which is not easy to use outside of Chromium. For this reason many attempts to bind to V8 rely on pre-built binaries that are built separately from the binding itself. While this is simple, it makes upgrading V8 difficult, it makes CI difficult, it makes producing builds with different configurations difficult, and it is a security concern since binary blobs can hide malicious code. For this reason we believe it is imperative to build V8 from source code during &#34;cargo build&#34;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Publish the crate on crates.io and allow docs.rs to generate documentation. Due to the complexity and size of V8&#39;s build, this is nontrivial. For example the crate size must be kept under 10 MiB in order to publish.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Binary Build&lt;/h2&gt; &#xA;&lt;p&gt;V8 is very large and takes a long time to compile. Many users will prefer to use a prebuilt version of V8. We publish static libs for every version of rusty v8 on &lt;a href=&#34;https://github.com/denoland/rusty_v8/releases&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Binaries builds are turned on by default: &lt;code&gt;cargo build&lt;/code&gt; will initiate a download from github to get the static lib. To disable this build using the &lt;code&gt;V8_FROM_SOURCE&lt;/code&gt; environmental variable.&lt;/p&gt; &#xA;&lt;p&gt;When making changes to rusty_v8 itself, it should be tested by build from source. The CI always builds from source.&lt;/p&gt; &#xA;&lt;h2&gt;The &lt;code&gt;V8_FORCE_DEBUG&lt;/code&gt; environment variable&lt;/h2&gt; &#xA;&lt;p&gt;By default &lt;code&gt;rusty_v8&lt;/code&gt; will link against release builds of &lt;code&gt;v8&lt;/code&gt;, if you want to use a debug build of &lt;code&gt;v8&lt;/code&gt; set &lt;code&gt;V8_FORCE_DEBUG=true&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We default to release builds of &lt;code&gt;v8&lt;/code&gt; due to performance &amp;amp; CI reasons in &lt;code&gt;deno&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;The &lt;code&gt;RUSTY_V8_MIRROR&lt;/code&gt; environment variable&lt;/h2&gt; &#xA;&lt;p&gt;Tells the build script where to get binary builds from. Understands &lt;code&gt;http://&lt;/code&gt; and &lt;code&gt;https://&lt;/code&gt; URLs, and file paths. The default is &lt;a href=&#34;https://github.com/denoland/rusty_v8/releases/download&#34;&gt;https://github.com/denoland/rusty_v8/releases/download&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;File-based mirrors are good for using cached downloads. First, point the environment variable to a suitable location:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# you might want to add this to your .bashrc&#xA;$ export RUSTY_V8_MIRROR=$HOME/.cache/rusty_v8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then populate the cache:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash&#xA;&#xA;# see https://github.com/denoland/rusty_v8/releases&#xA;&#xA;for REL in v0.13.0 v0.12.0; do&#xA;  mkdir -p $RUSTY_V8_MIRROR/$REL&#xA;  for FILE in \&#xA;    librusty_v8_debug_x86_64-unknown-linux-gnu.a \&#xA;    librusty_v8_release_x86_64-unknown-linux-gnu.a \&#xA;  ; do&#xA;    if [ ! -f $RUSTY_V8_MIRROR/$REL/$FILE ]; then&#xA;      wget -O $RUSTY_V8_MIRROR/$REL/$FILE \&#xA;        https://github.com/denoland/rusty_v8/releases/download/$REL/$FILE&#xA;    fi&#xA;  done&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;The &lt;code&gt;RUSTY_V8_ARCHIVE&lt;/code&gt; environment variable&lt;/h2&gt; &#xA;&lt;p&gt;Tell the build script to use a specific v8 library. This can be an URL or a path. This is useful when you have a prebuilt archive somewhere:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export RUSTY_V8_ARCHIVE=/path/to/custom_archive.a&#xA;cargo build&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Build V8 from Source&lt;/h2&gt; &#xA;&lt;p&gt;Use &lt;code&gt;V8_FROM_SOURCE=1 cargo build -vv&lt;/code&gt; to build the crate completely from source.&lt;/p&gt; &#xA;&lt;p&gt;The build scripts require Python 3 to be available as &lt;code&gt;python3&lt;/code&gt; in your &lt;code&gt;PATH&lt;/code&gt;. If you want to specify the exact binary of Python to use, you should use the &lt;code&gt;PYTHON&lt;/code&gt; environment variable.&lt;/p&gt; &#xA;&lt;p&gt;The build also requires &lt;code&gt;curl&lt;/code&gt; to be installed on your system.&lt;/p&gt; &#xA;&lt;p&gt;For linux builds: glib-2.0 development files need to be installed such that pkg-config can find them. On Ubuntu, run &lt;code&gt;sudo apt install libglib2.0-dev&lt;/code&gt; to install them.&lt;/p&gt; &#xA;&lt;p&gt;For Windows builds: the 64-bit toolchain needs to be used. 32-bit targets are not supported.&lt;/p&gt; &#xA;&lt;p&gt;For Mac builds: You&#39;ll need Xcode and Xcode CLT installed. Recent macOS versions will also require you to pass PYTHON=python3 because macOS no longer ships with &lt;code&gt;python&lt;/code&gt; simlinked to Python 3.&lt;/p&gt; &#xA;&lt;p&gt;The build depends on several binary tools: &lt;code&gt;gn&lt;/code&gt;, &lt;code&gt;ninja&lt;/code&gt; and &lt;code&gt;clang&lt;/code&gt;. The tools will automatically be downloaded, if they are not detected in the environment.&lt;/p&gt; &#xA;&lt;p&gt;Specifying the &lt;code&gt;$GN&lt;/code&gt; and &lt;code&gt;$NINJA&lt;/code&gt; environmental variables can be used to skip the download of gn and ninja. The clang download can be skipped by setting &lt;code&gt;$CLANG_BASE_PATH&lt;/code&gt; to the directory containing a &lt;code&gt;llvm&lt;/code&gt;/&lt;code&gt;clang&lt;/code&gt; installation. V8 is known to rely on bleeding edge features, so LLVM v8.0+ or Apple clang 11.0+ is recommended.&lt;/p&gt; &#xA;&lt;p&gt;Arguments can be passed to &lt;code&gt;gn&lt;/code&gt; by setting the &lt;code&gt;$GN_ARGS&lt;/code&gt; environmental variable.&lt;/p&gt; &#xA;&lt;p&gt;Env vars used in when building from source: &lt;code&gt;SCCACHE&lt;/code&gt;, &lt;code&gt;CCACHE&lt;/code&gt;, &lt;code&gt;GN&lt;/code&gt;, &lt;code&gt;NINJA&lt;/code&gt;, &lt;code&gt;CLANG_BASE_PATH&lt;/code&gt;, &lt;code&gt;GN_ARGS&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Building V8 takes over 30 minutes, this is too slow for me to use this crate. What should I do?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://github.com/mozilla/sccache&#34;&gt;sccache&lt;/a&gt; or &lt;a href=&#34;https://ccache.dev/&#34;&gt;ccache&lt;/a&gt;. Our build scripts will detect and use them. Set the &lt;code&gt;$SCCACHE&lt;/code&gt; or &lt;code&gt;$CCACHE&lt;/code&gt; environmental variable if it&#39;s not in your path.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;What are all these random directories for like &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;buildtools&lt;/code&gt; are these really necessary?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;In order to build V8 from source code, we must provide a certain directory structure with some git submodules from Chromium. We welcome any simplifications to the code base, but this is a structure we have found after many failed attempts that carefully balances the requirements of cargo crates and GN/Ninja.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;V8 has a very large API with hundreds of methods. Why don&#39;t you automate the generation of this binding code?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;In the limit we would like to auto-generate bindings. We have actually started down this route several times, however due to many eccentric features of the V8 API, this has not proven successful. Therefore we are proceeding in a brute-force fashion for now, focusing on solving our stated goals first. We hope to auto-generate bindings in the future.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Why are you building this?&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;This is to support &lt;a href=&#34;https://deno.land/&#34;&gt;the Deno project&lt;/a&gt;. We previously have gotten away with a simpler high-level Rust binding to V8 called &lt;a href=&#34;https://github.com/denoland/deno/tree/32937251315493ef2c3b42dd29340e8a34501aa4/core/libdeno&#34;&gt;libdeno&lt;/a&gt;. But as Deno has matured we&#39;ve found ourselves continually needing access to an increasing amount of V8&#39;s API in Rust.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;When building I get unknown argument: &#39;-gno-inline-line-tables&#39;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Use &lt;code&gt;export GN_ARGS=&#34;no_inline_line_tables=false&#34;&lt;/code&gt; during build.&lt;/p&gt; &#xA;&lt;h2&gt;For maintainers&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Cut a release&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Go to &lt;a href=&#34;https://github.com/denoland/rusty_v8/actions/workflows/release.yml&#34;&gt;https://github.com/denoland/rusty_v8/actions/workflows/release.yml&lt;/a&gt;, select proper release kind and wait for the workflow to complete. It will bump the version and create a tag. You will need to manually upload binary archives for M1 build.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ V8_FROM_SOURCE=1 cargo build&#xA;$ V8_FROM_SOURCE=1 cargo build --release&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>