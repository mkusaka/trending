<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-07-04T01:35:43Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>mmastrac/stylus</title>
    <updated>2025-07-04T01:35:43Z</updated>
    <id>tag:github.com,2025-07-04:/mmastrac/stylus</id>
    <link href="https://github.com/mmastrac/stylus" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Lightweight status page for home infrastructure&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;stylus &lt;img src=&#34;https://github.com/mmastrac/stylus/workflows/CI/badge.svg?branch=master&#34; alt=&#34;CI&#34;&gt; &lt;a href=&#34;https://crates.io/crates/stylus&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/stylus.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;strong&gt;Stylus&lt;/strong&gt; (&lt;em&gt;style + status&lt;/em&gt;) is a lightweight status page for home infrastructure. Configure a set of bash scripts that test the various parts of your infrastructure, set up HTML/SVG with a diagram of your network, and stylus will generate you a dynamic stylesheet to give you a visual overview of the current state.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mmastrac/stylus/master/docs/screenshot-2.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mmastrac/stylus/wiki/Running-Stylus&#34;&gt;See the wiki page on running Stylus here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Theory of operation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Stylus&lt;/strong&gt; acts as a webserver with special endpoints and a status monitoring tool.&lt;/p&gt; &#xA;&lt;p&gt;The status monitoring portion is based around scripts, written in any shell scripting language you like. Each script is run on an interval, and if the script returns &lt;code&gt;0&lt;/code&gt; that is considered &#34;up&#34; for a given service. If the service times out, or returns a non-zero error this is considered a soft (&#34;yellow&#34;) or hard (&#34;red&#34;) failure.&lt;/p&gt; &#xA;&lt;p&gt;The special endpoints available on the webserver are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;/style.css&lt;/code&gt;: A dynamically generated CSS file based on the current&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/status.json&lt;/code&gt;: A JSON representation of the current state&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The &lt;code&gt;style.css&lt;/code&gt; endpoint may be linked by a HTML or SVG file served from the &lt;code&gt;static&lt;/code&gt; directory that is configured. If desired, the HTML page can dynamically refresh the CSS periodically using Javascript. See the included example for a sample of how this might work.&lt;/p&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;The first step to get started is copying the example to a location you&#39;d like to use to run your status monitoring scripts. For each of the servers you&#39;d like to monitor, create a new subdirectory under &lt;code&gt;monitor.d&lt;/code&gt; with the name of that server.&lt;/p&gt; &#xA;&lt;p&gt;Using a tool like &lt;a href=&#34;https://app.diagrams.net/?splash=0&amp;amp;p=svgdata&#34;&gt;diagrams.net&lt;/a&gt;, create an SVG diagram of your network. Attach an SVG DOM attribute to the elements you&#39;d like to style with status changes. If you&#39;re using &lt;a href=&#34;https://app.diagrams.net/?splash=0&amp;amp;p=svgdata&#34;&gt;diagrams.net&lt;/a&gt;, this can be done using the &lt;code&gt;svgdata&lt;/code&gt; plugin. Alternatively, you can use the automatic identifiers generated by your SVG editor as your monitoring identifiers.&lt;/p&gt; &#xA;&lt;p&gt;From the SVG you&#39;ve generated, create CSS selectors and rules that will apply styles to the appropriate elements as statuses change. The SVG &lt;code&gt;fill&lt;/code&gt; attribute is a good candidate to change, but ensure that you&#39;re using &lt;code&gt;!important&lt;/code&gt; on all your rules to override the fill colors created by your SVG editor.&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Example &lt;code&gt;config.yaml&lt;/code&gt; for a &lt;strong&gt;Stylus&lt;/strong&gt; install. This configuration attaches metadata to the various states and has selectors that apply to both and HTML (for a status table) and CSS (for a status SVG image).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: 1&#xA;server:&#xA;  port: 8000&#xA;  static: static/&#xA;&#xA;monitor:&#xA;  dir: monitor.d/&#xA;&#xA;css:&#xA;  # Arbitrary metadata can be associated with the four states&#xA;  metadata:&#xA;    blank:&#xA;      color: &#34;white&#34;&#xA;    red:&#xA;      color: &#34;#fa897b&#34;&#xA;    yellow:&#xA;      color: &#34;#ffdd94&#34;&#xA;    green:&#xA;      color: &#34;#d0e6a5&#34;&#xA;  rules:&#xA;    # Multiple CSS rules with handlebars replacements are supported&#xA;    - selectors: &#34;#{{monitor.id}}&#34;&#xA;      declarations: &#34;&#xA;        background-color: {{monitor.status.css.metadata.color}} !important;&#xA;      &#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The monitors are configured by creating a subdirectory in the monitor directory (default &lt;code&gt;monitor.d/&lt;/code&gt;) and placing a &lt;code&gt;config.yaml&lt;/code&gt; in that monitor subdirectory.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# ID is optional and will be inferred from the directory&#xA;id: router-1&#xA;test:&#xA;  interval: 60s&#xA;  timeout: 30s&#xA;  command: test.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Test scripts&lt;/h2&gt; &#xA;&lt;p&gt;The test scripts are usually pretty simple. Note that the docker container ships with a number of useful utilities, but you can consider manually installing additional packages (either creating an additional docker container or manually running alpine&#39;s &lt;code&gt;apk&lt;/code&gt; tool inside the container) to handle your specific cases.&lt;/p&gt; &#xA;&lt;h3&gt;Ping&lt;/h3&gt; &#xA;&lt;p&gt;Unless you have a particularly lossy connection, a single ping should be enough to test whether a host is up:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash&#xA;set -xeuf -o pipefail&#xA;ping -c 1 8.8.8.8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;cURL&lt;/h3&gt; &#xA;&lt;p&gt;For hosts with services that may be up or down, you may want to use cURL to test whether the service itself is reachable.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash&#xA;set -xeuf -o pipefail&#xA;curl --retry 2 --max-time 5 --connect-timeout 5 http://192.168.1.1:9000&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Advanced techniques&lt;/h3&gt; &#xA;&lt;p&gt;Tools such as &lt;code&gt;jq&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt;, or &lt;code&gt;awk&lt;/code&gt; can be used for more advanced tests (ie: APIs). If needed, ssh can be used to connect to hosts and remote tests can be executed. &lt;code&gt;snmpwalk&lt;/code&gt; and &lt;code&gt;snmpget&lt;/code&gt; can also be used to construct tests for devices that speak SNMP.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;Stylus&lt;/strong&gt; is very lightweight, both from a processing and memory perspective.&lt;/p&gt; &#xA;&lt;p&gt;On a Raspberry Pi 1B, &lt;strong&gt;Stylus&lt;/strong&gt; uses less than 1% of CPU while refreshing CSS at a rate of 1/s. On a 2015 MacBook Pro, Stylus uses approximately 0.1% of a single core while actively refreshing.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Stylus&lt;/strong&gt; uses approxmately 2MB to monitor 15 services on a Raspberry Pi (according to &lt;a href=&#34;https://raw.githubusercontent.com/pixelb/ps_mem/master/ps_mem.py&#34;&gt;ps_mem&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;When not actively monitored, &lt;strong&gt;Stylus&lt;/strong&gt; uses a nearly unmeasurable amount of CPU and is pretty much limited by how heavyweight your test scripts are.&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots&lt;/h2&gt; &#xA;&lt;h3&gt;Included example&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mmastrac/stylus/master/docs/screenshot-1.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;My personal network&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mmastrac/stylus/master/docs/screenshot-2.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Historical Note&lt;/h2&gt; &#xA;&lt;p&gt;Note that this project was originally written using deno, but was rewritten in Rust to support Raspberry Pis. The original deno source is available in the &lt;code&gt;deno&lt;/code&gt; branch.&lt;/p&gt;</summary>
  </entry>
</feed>