<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-05T08:28:51Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Skepfyr/little-loadshedder</title>
    <updated>2023-02-05T08:28:51Z</updated>
    <id>tag:github.com,2023-02-05:/Skepfyr/little-loadshedder</id>
    <link href="https://github.com/Skepfyr/little-loadshedder" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Rust hyper/tower service that implements load shedding with queuing &amp; concurrency limiting based on latency.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Little Loadshedder&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/little-loadshedder&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/little-loadshedder.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/little-loadshedder/&#34;&gt;&lt;img src=&#34;https://docs.rs/little-loadshedder/badge.svg?sanitize=true&#34; alt=&#34;API reference&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Skepfyr/little-loadshedder#license&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/license-MIT_OR_Apache--2.0-blue.svg?sanitize=true&#34; alt=&#34;License&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;A Rust hyper/tower service that implements load shedding with queuing &amp;amp; concurrency limiting based on latency.&lt;/p&gt; &#xA;&lt;p&gt;It uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Little%27s_law&#34;&gt;Little&#39;s Law&lt;/a&gt; to intelligently shed load in order to maintain a target average latency. It achieves this by placing a queue in front of the service it wraps, the size of which is determined by measuring the average latency of calls to the inner service. Additionally, it controls the number of concurrent requests to the inner service, in order to achieve the maximum possible throughput.&lt;/p&gt; &#xA;&lt;p&gt;The following images show metrics from the example server under load generated by the example client.&lt;/p&gt; &#xA;&lt;p&gt;First, when load is turned on, some requests are rejected while the middleware works out the queue size, and increases the concurrency. &lt;img src=&#34;https://user-images.githubusercontent.com/3080863/215579375-39abe718-2820-4fb4-ac52-3a5ca705085d.png&#34; alt=&#34;startup&#34;&gt; This quickly resolves to a steady state where the service can easily handle the load on it, and so the queue size is large.&lt;/p&gt; &#xA;&lt;p&gt;Next, we send a large burst of traffic, note that none of it is dropped as it is all absorbed by the queue. &lt;img src=&#34;https://user-images.githubusercontent.com/3080863/215579359-075c94fe-245b-47fb-899e-d273b954bb1e.png&#34; alt=&#34;burst&#34;&gt; Once the burst stops, the service slowly clears it&#39;s backlog of requests and returns to the steady state.&lt;/p&gt; &#xA;&lt;p&gt;Now we simulate a service degradation, all requests are taking twice as long to process. The queue shrinks to about half its original size in order to hit the target average latency, however the service cannot acheive this throughput any longer so the queue fills and requests are rejected. &lt;img src=&#34;https://user-images.githubusercontent.com/3080863/215579365-7af527c9-745f-4ab4-b87f-813a09664018.png&#34; alt=&#34;degradation&#34;&gt; Note that from the client&#39;s point of view requests are either immediately rejected or complete at roughly the target latency.&lt;/p&gt; &#xA;&lt;p&gt;Now the service degrades substantially. The queue shrinks to almost nothing and the concurrency is slowly reduced until the latency matches the goal. &lt;img src=&#34;https://user-images.githubusercontent.com/3080863/215579369-1f1261ec-8029-49e1-817a-a77f47e2f747.png&#34; alt=&#34;slow&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Finally, the service recovers, the middleware rapidly notices and returns to it&#39;s inital steady state. &lt;img src=&#34;https://user-images.githubusercontent.com/3080863/215579367-17a94de3-674c-4e3b-84a3-185daf087956.png&#34; alt=&#34;recovery&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apache License, Version 2.0 (&lt;a href=&#34;https://raw.githubusercontent.com/Skepfyr/little-loadshedder/main/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; or &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;MIT license (&lt;a href=&#34;https://raw.githubusercontent.com/Skepfyr/little-loadshedder/main/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; or &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your option.&lt;/p&gt; &#xA;&lt;h2&gt;Contribution&lt;/h2&gt; &#xA;&lt;p&gt;This project welcomes contributions and suggestions, just open an issue or pull request!&lt;/p&gt; &#xA;&lt;p&gt;Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>pop-os/cosmic-comp</title>
    <updated>2023-02-05T08:28:51Z</updated>
    <id>tag:github.com,2023-02-05:/pop-os/cosmic-comp</id>
    <link href="https://github.com/pop-os/cosmic-comp" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Compositor for the COSMIC desktop environment&lt;/p&gt;&lt;hr&gt;</summary>
  </entry>
  <entry>
    <title>gfx-rs/naga</title>
    <updated>2023-02-05T08:28:51Z</updated>
    <id>tag:github.com,2023-02-05:/gfx-rs/naga</id>
    <link href="https://github.com/gfx-rs/naga" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Universal shader translation in Rust&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Naga&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://matrix.to/#/#naga:matrix.org&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Matrix-%23naga%3Amatrix.org-blueviolet.svg?sanitize=true&#34; alt=&#34;Matrix&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/naga&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/naga.svg?label=naga&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/naga&#34;&gt;&lt;img src=&#34;https://docs.rs/naga/badge.svg?sanitize=true&#34; alt=&#34;Docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/gfx-rs/naga/actions&#34;&gt;&lt;img src=&#34;https://github.com/gfx-rs/naga/workflows/pipeline/badge.svg?sanitize=true&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt; &lt;img src=&#34;https://img.shields.io/badge/rustc-1.63+-blue.svg?sanitize=true&#34; alt=&#34;MSRV&#34;&gt; &lt;a href=&#34;https://codecov.io/gh/gfx-rs/naga&#34;&gt;&lt;img src=&#34;https://codecov.io/gh/gfx-rs/naga/branch/master/graph/badge.svg?token=9VOKYO8BM2&#34; alt=&#34;codecov.io&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The shader translation library for the needs of &lt;a href=&#34;https://github.com/gfx-rs/wgpu&#34;&gt;wgpu&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Supported end-points&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Front-end&lt;/th&gt; &#xA;   &lt;th&gt;Status&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPIR-V (binary)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;âœ…&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;spv-in&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WGSL&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;âœ…&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;wgsl-in&lt;/td&gt; &#xA;   &lt;td&gt;Fully validated&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GLSL&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;ðŸ†—&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;glsl-in&lt;/td&gt; &#xA;   &lt;td&gt;GLSL 440+ and Vulkan semantics only&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Back-end&lt;/th&gt; &#xA;   &lt;th&gt;Status&lt;/th&gt; &#xA;   &lt;th&gt;Feature&lt;/th&gt; &#xA;   &lt;th&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;SPIR-V&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;âœ…&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;spv-out&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;WGSL&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;ðŸ†—&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;wgsl-out&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Metal&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;âœ…&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;msl-out&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;HLSL&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;âœ…&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;hlsl-out&lt;/td&gt; &#xA;   &lt;td&gt;Shader Model 5.0+ (DirectX 11+)&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;GLSL&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;ðŸ†—&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;glsl-out&lt;/td&gt; &#xA;   &lt;td&gt;GLSL 330+ and GLSL ES 300+&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;AIR&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DXIL/DXIR&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DXBC&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;DOT (GraphViz)&lt;/td&gt; &#xA;   &lt;td&gt;&lt;span&gt;ðŸ†—&lt;/span&gt;&lt;/td&gt; &#xA;   &lt;td&gt;dot-out&lt;/td&gt; &#xA;   &lt;td&gt;Not a shading language&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;&lt;span&gt;âœ…&lt;/span&gt; = Primary support â€” &lt;span&gt;ðŸ†—&lt;/span&gt; = Secondary support â€” &lt;span&gt;ðŸš§&lt;/span&gt; = Unsupported, but support in progress&lt;/p&gt; &#xA;&lt;h2&gt;Conversion tool&lt;/h2&gt; &#xA;&lt;p&gt;Naga can be used as a CLI, which allows to test the conversion of different code paths.&lt;/p&gt; &#xA;&lt;p&gt;First, install &lt;code&gt;naga-cli&lt;/code&gt; from crates.io or directly from GitHub.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# release version&#xA;cargo install naga-cli&#xA;&#xA;# development version&#xA;cargo install naga-cli --git https://github.com/gfx-rs/naga.git&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then, you can run &lt;code&gt;naga&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;naga my_shader.wgsl # validate only&#xA;naga my_shader.spv my_shader.txt # dump the IR module into a file&#xA;naga my_shader.spv my_shader.metal --flow-dir flow-dir # convert the SPV to Metal, also dump the SPIR-V flow graph to `flow-dir`&#xA;naga my_shader.wgsl my_shader.vert --profile es310 # convert the WGSL to GLSL vertex stage under ES 3.20 profile&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As naga includes a default binary target, you can also use &lt;code&gt;cargo run&lt;/code&gt; without installation. This is useful when you develop naga itself, or investigate the behavior of naga at a specific commit (e.g. &lt;a href=&#34;https://github.com/gfx-rs/wgpu&#34;&gt;wgpu&lt;/a&gt; might pin a different version of naga than the &lt;code&gt;HEAD&lt;/code&gt; of this repository).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cargo run my_shader.wgsl&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Development workflow&lt;/h2&gt; &#xA;&lt;p&gt;The main instrument aiding the development is the good old &lt;code&gt;cargo test --all-features --workspace&lt;/code&gt;, which will run the unit tests, and also update all the snapshots. You&#39;ll see these changes in git before committing the code.&lt;/p&gt; &#xA;&lt;p&gt;If working on a particular front-end or back-end, it may be convenient to enable the relevant features in &lt;code&gt;Cargo.toml&lt;/code&gt;, e.g.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;default = [&#34;spv-out&#34;] #TEMP!&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This allows IDE basic checks to report errors there, unless your IDE is sufficiently configurable already.&lt;/p&gt; &#xA;&lt;p&gt;Finally, when changes to the snapshots are made, we should verify that the produced shaders are indeed valid for the target platforms they are compiled for. We automate this with &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make validate-spv # for Vulkan shaders, requires SPIRV-Tools installed&#xA;make validate-msl # for Metal shaders, requires XCode command-line tools installed&#xA;make validate-glsl # for OpenGL shaders, requires GLSLang installed&#xA;make validate-dot # for dot files, requires GraphViz installed&#xA;make validate-wgsl # for WGSL shaders&#xA;make validate-hlsl-dxc # for HLSL shaders via DXC&#xA;make validate-hlsl-fxc # for HLSL shaders via FXC&#xA;# Note: HLSL Make targets make use of the &#34;sh&#34; shell. This is not the default shell in Windows.&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
</feed>