<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-02-07T01:38:34Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>emmett-framework/granian</title>
    <updated>2024-02-07T01:38:34Z</updated>
    <id>tag:github.com,2024-02-07:/emmett-framework/granian</id>
    <link href="https://github.com/emmett-framework/granian" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A Rust HTTP server for Python applications&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Granian&lt;/h1&gt; &#xA;&lt;p&gt;A Rust HTTP server for Python applications.&lt;/p&gt; &#xA;&lt;h2&gt;Rationale&lt;/h2&gt; &#xA;&lt;p&gt;The main reasons behind Granian design are:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Have a single, correct HTTP implementation, supporting versions 1, 2 (and eventually 3)&lt;/li&gt; &#xA; &lt;li&gt;Provide a single package for several platforms&lt;/li&gt; &#xA; &lt;li&gt;Avoid the usual Gunicorn + uvicorn + http-tools dependency composition on unix systems&lt;/li&gt; &#xA; &lt;li&gt;Provide stable &lt;a href=&#34;https://github.com/emmett-framework/granian/raw/master/benchmarks/README.md&#34;&gt;performance&lt;/a&gt; when compared to existing alternatives&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Supports ASGI/3, &lt;a href=&#34;https://github.com/emmett-framework/granian/raw/master/docs/spec/RSGI.md&#34;&gt;RSGI&lt;/a&gt; and WSGI interface applications&lt;/li&gt; &#xA; &lt;li&gt;Implements HTTP/1 and HTTP/2 protocols&lt;/li&gt; &#xA; &lt;li&gt;Supports HTTPS&lt;/li&gt; &#xA; &lt;li&gt;Supports Websockets&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;You can install Granian using pip:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ pip install granian&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Create an ASGI application in your &lt;code&gt;main.py&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;async def app(scope, receive, send):&#xA;    assert scope[&#39;type&#39;] == &#39;http&#39;&#xA;&#xA;    await send({&#xA;        &#39;type&#39;: &#39;http.response.start&#39;,&#xA;        &#39;status&#39;: 200,&#xA;        &#39;headers&#39;: [&#xA;            [b&#39;content-type&#39;, b&#39;text/plain&#39;],&#xA;        ],&#xA;    })&#xA;    await send({&#xA;        &#39;type&#39;: &#39;http.response.body&#39;,&#xA;        &#39;body&#39;: b&#39;Hello, world!&#39;,&#xA;    })&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and serve it:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ granian --interface asgi main:app&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can also create an app using the &lt;a href=&#34;https://github.com/emmett-framework/granian/raw/master/docs/spec/RSGI.md&#34;&gt;RSGI&lt;/a&gt; specification:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;async def app(scope, proto):&#xA;    assert scope.proto == &#39;http&#39;&#xA;&#xA;    proto.response_str(&#xA;        status=200,&#xA;        headers=[&#xA;            (&#39;content-type&#39;, &#39;text/plain&#39;)&#xA;        ],&#xA;        body=&#34;Hello, world!&#34;&#xA;    )&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and serve it using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;$ granian --interface rsgi main:app&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Options&lt;/h2&gt; &#xA;&lt;p&gt;You can check all the options provided by Granian with the &lt;code&gt;--help&lt;/code&gt; command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ granian --help&#xA;Usage: granian [OPTIONS] APP&#xA;&#xA;Arguments:&#xA;  APP  Application target to serve.  [required]&#xA;&#xA;Options:&#xA;  --host TEXT                     Host address to bind to  [env var:&#xA;                                  GRANIAN_HOST; default: 127.0.0.1]&#xA;  --port INTEGER                  Port to bind to.  [env var: GRANIAN_PORT;&#xA;                                  default: 8000]&#xA;  --interface [asgi|rsgi|wsgi]    Application interface type  [env var:&#xA;                                  GRANIAN_INTERFACE; default: rsgi]&#xA;  --http [auto|1|2]               HTTP version  [env var: GRANIAN_HTTP;&#xA;                                  default: auto]&#xA;  --ws / --no-ws                  Enable websockets handling  [env var:&#xA;                                  GRANIAN_WEBSOCKETS; default: (enabled)]&#xA;  --workers INTEGER RANGE         Number of worker processes  [env var:&#xA;                                  GRANIAN_WORKERS; default: 1; x&amp;gt;=1]&#xA;  --threads INTEGER RANGE         Number of threads  [env var:&#xA;                                  GRANIAN_THREADS; default: 1; x&amp;gt;=1]&#xA;  --blocking-threads INTEGER RANGE&#xA;                                  Number of blocking threads  [env var:&#xA;                                  GRANIAN_BLOCKING_THREADS; default: 1; x&amp;gt;=1]&#xA;  --threading-mode [runtime|workers]&#xA;                                  Threading mode to use  [env var:&#xA;                                  GRANIAN_THREADING_MODE; default: workers]&#xA;  --loop [auto|asyncio|uvloop]    Event loop implementation  [env var:&#xA;                                  GRANIAN_LOOP; default: auto]&#xA;  --opt / --no-opt                Enable loop optimizations  [env var:&#xA;                                  GRANIAN_LOOP_OPT; default: (disabled)]&#xA;  --backlog INTEGER RANGE         Maximum number of connections to hold in&#xA;                                  backlog  [env var: GRANIAN_BACKLOG; default:&#xA;                                  1024; x&amp;gt;=128]&#xA;  --http1-buffer-size INTEGER RANGE&#xA;                                  Set the maximum buffer size for HTTP/1&#xA;                                  connections  [env var:&#xA;                                  GRANIAN_HTTP1_BUFFER_SIZE; default: 417792;&#xA;                                  x&amp;gt;=8192]&#xA;  --http1-keep-alive / --no-http1-keep-alive&#xA;                                  Enables or disables HTTP/1 keep-alive  [env&#xA;                                  var: GRANIAN_HTTP1_KEEP_ALIVE; default:&#xA;                                  (enabled)]&#xA;  --http1-pipeline-flush / --no-http1-pipeline-flush&#xA;                                  Aggregates HTTP/1 flushes to better support&#xA;                                  pipelined responses (experimental)  [env&#xA;                                  var: GRANIAN_HTTP1_PIPELINE_FLUSH; default:&#xA;                                  (disabled)]&#xA;  --http2-adaptive-window / --no-http2-adaptive-window&#xA;                                  Sets whether to use an adaptive flow control&#xA;                                  for HTTP2  [env var:&#xA;                                  GRANIAN_HTTP2_ADAPTIVE_WINDOW; default:&#xA;                                  (disabled)]&#xA;  --http2-initial-connection-window-size INTEGER&#xA;                                  Sets the max connection-level flow control&#xA;                                  for HTTP2  [env var: GRANIAN_HTTP2_INITIAL_C&#xA;                                  ONNECTION_WINDOW_SIZE; default: 1048576]&#xA;  --http2-initial-stream-window-size INTEGER&#xA;                                  Sets the `SETTINGS_INITIAL_WINDOW_SIZE`&#xA;                                  option for HTTP2 stream-level flow control&#xA;                                  [env var:&#xA;                                  GRANIAN_HTTP2_INITIAL_STREAM_WINDOW_SIZE;&#xA;                                  default: 1048576]&#xA;  --http2-keep-alive-interval INTEGER&#xA;                                  Sets an interval for HTTP2 Ping frames&#xA;                                  should be sent to keep a connection alive&#xA;                                  [env var: GRANIAN_HTTP2_KEEP_ALIVE_INTERVAL;&#xA;                                  default: (disabled)]&#xA;  --http2-keep-alive-timeout INTEGER&#xA;                                  Sets a timeout for receiving an&#xA;                                  acknowledgement of the HTTP2 keep-alive ping&#xA;                                  [env var: GRANIAN_HTTP2_KEEP_ALIVE_TIMEOUT;&#xA;                                  default: 20]&#xA;  --http2-max-concurrent-streams INTEGER&#xA;                                  Sets the SETTINGS_MAX_CONCURRENT_STREAMS&#xA;                                  option for HTTP2 connections  [env var:&#xA;                                  GRANIAN_HTTP2_MAX_CONCURRENT_STREAMS;&#xA;                                  default: 200]&#xA;  --http2-max-frame-size INTEGER  Sets the maximum frame size to use for HTTP2&#xA;                                  [env var: GRANIAN_HTTP2_MAX_FRAME_SIZE;&#xA;                                  default: 16384]&#xA;  --http2-max-headers-size INTEGER&#xA;                                  Sets the max size of received header frames&#xA;                                  [env var: GRANIAN_HTTP2_MAX_HEADERS_SIZE;&#xA;                                  default: 16777216]&#xA;  --http2-max-send-buffer-size INTEGER&#xA;                                  Set the maximum write buffer size for each&#xA;                                  HTTP/2 stream  [env var:&#xA;                                  GRANIAN_HTTP2_MAX_SEND_BUFFER_SIZE; default:&#xA;                                  409600]&#xA;  --log / --no-log                Enable logging  [env var:&#xA;                                  GRANIAN_LOG_ENABLED; default: (enabled)]&#xA;  --log-level [critical|error|warning|warn|info|debug]&#xA;                                  Log level  [env var: GRANIAN_LOG_LEVEL;&#xA;                                  default: info]&#xA;  --log-config FILE               Logging configuration file (json)  [env var:&#xA;                                  GRANIAN_LOG_CONFIG]&#xA;  --ssl-keyfile FILE              SSL key file  [env var: GRANIAN_SSL_KEYFILE]&#xA;  --ssl-certificate FILE          SSL certificate file  [env var:&#xA;                                  GRANIAN_SSL_CERTIFICATE]&#xA;  --url-path-prefix TEXT          URL path prefix the app is mounted on  [env&#xA;                                  var: GRANIAN_URL_PATH_PREFIX]&#xA;  --respawn-failed-workers / --no-respawn-failed-workers&#xA;                                  Enable workers respawn on unexpected exit&#xA;                                  [env var: GRANIAN_RESPAWN_FAILED_WORKERS;&#xA;                                  default: (disabled)]&#xA;  --reload / --no-reload          Enable auto reload on application&#39;s files&#xA;                                  changes  [env var: GRANIAN_RELOAD; default:&#xA;                                  (disabled)]&#xA;  --version                       Shows the version and exit&#xA;  --install-completion [bash|zsh|fish|powershell|pwsh]&#xA;                                  Install completion for the specified shell.&#xA;                                  [env var: GRANIAN_INSTALL_COMPLETION]&#xA;  --show-completion [bash|zsh|fish|powershell|pwsh]&#xA;                                  Show completion for the specified shell, to&#xA;                                  copy it or customize the installation.  [env&#xA;                                  var: GRANIAN_SHOW_COMPLETION]&#xA;  --help                          Show this message and exit.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Threading mode&lt;/h3&gt; &#xA;&lt;p&gt;Granian offers two different threading paradigms, due to the fact the inner Rust runtime can be multi-threaded â€“ in opposition to what happens in Python event-loop which can only run as a single thread.&lt;/p&gt; &#xA;&lt;p&gt;Given you specify N threads with the relevant option, in &lt;strong&gt;workers&lt;/strong&gt; threading mode Granian will spawn N single-threaded Rust runtimes, while in &lt;strong&gt;runtime&lt;/strong&gt; threading mode Granian will spawn a single multi-threaded runtime with N threads.&lt;/p&gt; &#xA;&lt;p&gt;Benchmarks suggests &lt;strong&gt;workers&lt;/strong&gt; mode to be more efficient with a small amount of processes, while &lt;strong&gt;runtime&lt;/strong&gt; mode seems to scale more efficiently where you have a large number of CPUs. Real performance will though depend on specific application code, and thus &lt;em&gt;your mileage might vary&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Event loop optimizations&lt;/h3&gt; &#xA;&lt;p&gt;With the &lt;code&gt;--opt&lt;/code&gt; option Granian will use custom task handlers for Python coroutines and awaitables to improve Python code execution. Due to the nature of such handlers some libraries and specific application code relying on &lt;code&gt;asyncio&lt;/code&gt; internals might not work.&lt;/p&gt; &#xA;&lt;p&gt;You might test the effect such optimizations cause over your application and decide wether to enable &#39;em or leave &#39;em disabled (as per default).&lt;/p&gt; &#xA;&lt;h2&gt;Project status&lt;/h2&gt; &#xA;&lt;p&gt;Granian is currently under active development.&lt;/p&gt; &#xA;&lt;p&gt;Granian is compatible with Python 3.8 and above versions.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Granian is released under the BSD License.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>kneasle/sapling</title>
    <updated>2024-02-07T01:38:34Z</updated>
    <id>tag:github.com,2024-02-07:/kneasle/sapling</id>
    <link href="https://github.com/kneasle/sapling" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A highly experimental vi-inspired editor where you edit code, not text.&lt;/p&gt;&lt;hr&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/resources/sapling.gif&#34; alt=&#34;Sapling Logo&#34; align=&#34;right&#34;&gt; &#xA;&lt;h1&gt;Sapling&lt;/h1&gt; &#xA;&lt;p&gt;A highly experimental code editor where you edit code, not text.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;I (@kneasle) don&#39;t currently have time to work on Sapling (I have exams coming up and other projects are requiring my time). This doesn&#39;t mean the project is dead or that I&#39;ve forgotten about it - I still think it&#39;s cool and the community support has been crazy. I&#39;m also not currently streaming development, but all vods are still on &lt;a href=&#34;https://www.youtube.com/channel/UCKl0T4IDZC3vUz152hDAzGw&#34;&gt;my YouTube channel&lt;/a&gt; for anyone interested. There&#39;s also a discord server for discussions about Sapling and structured editing in general (&lt;a href=&#34;https://discord.gg/Amv3Tsb4fV&#34;&gt;invite link&lt;/a&gt;). OK enough from me, onto the real README!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;Most of the ideas for this project come from my friend Shtanton&#39;s &lt;a href=&#34;http://shtanton.com/posts/ex.html&#34;&gt;blog post&lt;/a&gt;. The concept of directly editing syntax trees is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Structure_editor&#34;&gt;&#39;structured editing&#39;&lt;/a&gt; and is not new; the purpose of Sapling is to use ideas from structured editing to &lt;strong&gt;speed up&lt;/strong&gt; moment-to-moment code editing, much how editors like Vim and Emacs speed up editing. Sapling&#39;s editing model will be largely inspired by &lt;a href=&#34;https://github.com/vim/vim&#34;&gt;Vim&lt;/a&gt;/&lt;a href=&#34;https://github.com/neovim/neovim&#34;&gt;NeoVim&lt;/a&gt; and &lt;a href=&#34;https://github.com/mawww/kakoune&#34;&gt;kakoune&lt;/a&gt;. Sapling also aims to be &lt;strong&gt;general purpose&lt;/strong&gt; - Sapling should be able to edit any language, given that a suitable grammar is provided.&lt;/p&gt; &#xA;&lt;p&gt;&lt;em&gt;Contributions of all kinds are very welcome!&lt;/em&gt;&lt;/p&gt; &#xA;&lt;p&gt;It is worth noting that Sapling is primarily &lt;strong&gt;an experiment&lt;/strong&gt; to determine whether or not such an editor could work. Therefore, for the time being, Sapling can be expected to change at any time. Hopefully the design of Sapling will converge over time - its current state is similar to how pre-1.0 Rust was continually evolving and making potentially-breaking changes so that post-1.0 Rust could be as useful as possible.&lt;/p&gt; &#xA;&lt;h2&gt;Contents&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#but-why&#34;&gt;&lt;strong&gt;But Why?&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#goals-of-sapling&#34;&gt;&lt;strong&gt;Goals of Sapling&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#inspirations&#34;&gt;&lt;strong&gt;Inspirations&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#quick-startplay-with-sapling&#34;&gt;&lt;strong&gt;Quick Start&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#pros-of-ast-based-editing&#34;&gt;&lt;strong&gt;Pros of AST-based Editing&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#cons-of-ast-based-editing-otherwise-known-as-extra-fun-challenges&#34;&gt;&lt;strong&gt;&#39;Extra Fun Challenges&#39;&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/#whats-an-ast&#34;&gt;&lt;strong&gt;What&#39;s an AST?&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;But why?&lt;/h2&gt; &#xA;&lt;p&gt;When writing code with any text editor, you are usually only interested in a tiny subset of all the possible strings of text - those that correspond to valid programs in whatever language you&#39;re writing. In a &lt;strong&gt;text&lt;/strong&gt; editor, you will spend the overwhelming majority of your time with the text in your editor being invalid as you make edits to move between valid programs. This is inefficient for the programmer, and causes lots of issues for software like Language Servers which have to cope as best they can with these invalid states.&lt;/p&gt; &#xA;&lt;p&gt;To be fair, editors like Vim, Emacs and Kakoune do better than most by providing shortcuts to do common text manipulations, which is a step in the right direction. Interestingly, though, the most useful of these shortcuts are those correspond to modifications of the syntax tree (e.g. &lt;code&gt;ci)&lt;/code&gt; to remove the replace the contents of &lt;code&gt;()&lt;/code&gt; in Vim), and so it seems logical to apply modal editing to directly modifying the syntax trees of programs.&lt;/p&gt; &#xA;&lt;p&gt;Sapling takes the idea of keystrokes primarily modifying text, but instead applies those keystrokes as actions to the syntax tree of your program. I have no idea if this will be useful, but it seems worth a try.&lt;/p&gt; &#xA;&lt;h2&gt;Goals of Sapling&lt;/h2&gt; &#xA;&lt;p&gt;These goals are roughly in order of importance, with the most important first:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Editing Speed&lt;/strong&gt;: Sapling should be an editor that allows power users to edit code as close to their thinking speed as possible. Flattening the learning curve is also important, but Sapling is not trying to be an editor for every single developer and is designed primarily with power users in mind.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Stability&lt;/strong&gt;: Sapling should not, under any circumstances, corrupt the user&#39;s data or crash. Either of these are considered critical bugs and should be reported.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Generality&lt;/strong&gt;: Sapling should, in theory, be able to edit any language. This will likely be done with making the language plug-in-able and probably specified by some kind of grammar.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Familiarity&lt;/strong&gt;: Sapling should feel familiar to people who are used to modal editors such as Vim and Kakoune. However, some alterations are required for Sapling to edit ASTs and not just text.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Interactivity&lt;/strong&gt;: Sapling should always give the user immediate feedback about their actions. Kakoune is a model example of this, and Vim/NeoVim does pretty well too.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt;: The user should not have to wait for Sapling to do anything. Sapling should also have a small resource footprint - an editor should not have to use several hundred megabytes of RAM when idling.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Inspirations:&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/vim/vim&#34;&gt;Vim&lt;/a&gt;, &lt;a href=&#34;https://github.com/neovim/neovim&#34;&gt;NeoVim&lt;/a&gt; and &lt;a href=&#34;https://github.com/mawww/kakoune&#34;&gt;Kakoune&lt;/a&gt;&lt;/em&gt;: &#39;Modal&#39; editors where keystrokes can correspond to &lt;em&gt;actions&lt;/em&gt; on the text rather than always inserting directly to the text buffer. Shoutout in particular to Kakoune for its beautiful multi-selection based editing model.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://github.com/tree-sitter/tree-sitter&#34;&gt;Tree Sitter&lt;/a&gt;&lt;/em&gt;: A generic, flexible, error-handling parser that is not language specific. Designed primarily to provide better syntax highlighting for &lt;a href=&#34;https://github.com/atom/atom&#34;&gt;the Atom text editor&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;a href=&#34;http://www.graspjs.com/&#34;&gt;grasp&lt;/a&gt;&lt;/em&gt;: A regex-like language for searching JavaScript ASTs.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://reddit.com/r/nosyntax&#34;&gt;r/nosyntax&lt;/a&gt;&lt;/em&gt;: A subreddit for strutured and projectional editors. They also have &lt;a href=&#34;https://www.reddit.com/r/nosyntax/comments/6xv61b/list_of_projects/&#34;&gt;a list&lt;/a&gt; of such projects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;em&gt;&lt;a href=&#34;https://www.researchgate.net/publication/221518157_Barista_An_implementation_framework_for_enabling_new_tools_interaction_techniques_and_views_in_code_editors&#34;&gt;Barista&lt;/a&gt;&lt;/em&gt;: A structured editor that allows the user to fall back on text editing if required, which is something I&#39;d like to explore for Sapling. The source code is &lt;a href=&#34;https://github.com/amyjko/citrus-barista&#34;&gt;here&lt;/a&gt;, but since this was a research project it seems to be unmaintained.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Quick Start/Play with Sapling&lt;/h2&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;Sapling is not yet on &lt;a href=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/crates.io&#34;&gt;crates.io&lt;/a&gt; and is very much still in early development, but if you want to play around with Sapling as it currently stands, the best way is to clone the repository and build from source (you&#39;ll need &lt;a href=&#34;https://www.rust-lang.org/learn/get-started&#34;&gt;Rust&lt;/a&gt; installed in order to do this):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/kneasle/sapling.git&#xA;cargo run 2&amp;gt; log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Demo&lt;/h3&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/60934058/112751246-d8e23f00-8fc4-11eb-9a15-8a3ef32d54a4.gif&#34; alt=&#34;Demo GIF&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Current Keybindings&lt;/h3&gt; &#xA;&lt;h4&gt;Misc&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;q&lt;/code&gt;: Quit Sapling&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;u&lt;/code&gt;: Undo a change&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;R&lt;/code&gt;: Redo a change&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Cursor Movement&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;h&lt;/code&gt;/&lt;code&gt;k&lt;/code&gt;: Move the cursor to the previous sibling of the current node&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;j&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt;: Move the cursor to the next sibling of the current node&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;c&lt;/code&gt;: Move the cursor to the first child of the current node (if it exists)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;p&lt;/code&gt;: Move the cursor to the parent of the node it&#39;s currently at&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Modify the tree&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;r*&lt;/code&gt;: Replace the node under the cursor with the node represented by the key &lt;code&gt;*&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;x&lt;/code&gt;: Delete the node under the cursor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;o*&lt;/code&gt;: Insert a new node represented by &lt;code&gt;*&lt;/code&gt; as a &lt;strong&gt;child&lt;/strong&gt; of the cursor&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;a*&lt;/code&gt;/&lt;code&gt;i*&lt;/code&gt;: Insert a new node represented by &lt;code&gt;*&lt;/code&gt; before or after the cursor respectively&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;As with Vim, all commands can be repeated by inserting a count before them. For example, &lt;code&gt;3u&lt;/code&gt; will undo 3 steps in one go.&lt;/p&gt; &#xA;&lt;p&gt;Sapling can currently only edit JSON with the following keys: &lt;code&gt;[a]rray&lt;/code&gt;, &lt;code&gt;[o]bject&lt;/code&gt;, &lt;code&gt;[t]rue&lt;/code&gt;, &lt;code&gt;[f]alse&lt;/code&gt;, &lt;code&gt;[n]ull&lt;/code&gt;, &lt;code&gt;[s]tring&lt;/code&gt;. There is currently no way to insert text into a string or to open and close files (yet!).&lt;/p&gt; &#xA;&lt;p&gt;Sapling handle multiple nodes in one go by adding a count before the node name, for example &lt;code&gt;i3t&lt;/code&gt; will insert 3 &lt;code&gt;true&lt;/code&gt;s before the cursor.&lt;/p&gt; &#xA;&lt;h2&gt;Pros of AST-based editing&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Because the editor already knows the syntactic structure of your program, the following are &lt;strong&gt;much&lt;/strong&gt; easier to implement for every language supported by Sapling: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Syntax highlighting&lt;/li&gt; &#xA;   &lt;li&gt;Code folding&lt;/li&gt; &#xA;   &lt;li&gt;Auto-formatting of code (in fact, this is nearly automatic and elegantly preserving code formatting is hard)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;It will hopefully be &lt;strong&gt;FAST&lt;/strong&gt; to edit code&lt;/li&gt; &#xA; &lt;li&gt;It might actually be more intuitive than text-based editing&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Cons of AST-based editing (otherwise known as &#39;Extra Fun Challenges&#39;)&lt;/h2&gt; &#xA;&lt;p&gt;Because the editor &lt;em&gt;has&lt;/em&gt; to hold a valid program, the following things that other editors take for granted are hard to implement:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Searching a file - because only syntax tree nodes can be selected, we need a way to concisely search for nodes in a tree. &lt;a href=&#34;http://www.graspjs.com/&#34;&gt;grasp&lt;/a&gt; seems like it&#39;d be good inspiration for this.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Just opening a file - opening a syntactically correct file is essentially the same as writing a compiler-esque parser for every language you want to load (not an easy task but there&#39;s plenty of literature/libraries already existing for this). The real issue is that Sapling has to at least attempt to open any file, regardless of syntactic correctness, and this essentially boils down to building an error-correcting parser that&#39;s generic enough to parse any language.&lt;/p&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/tree-sitter/tree-sitter&#34;&gt;Tree Sitter&lt;/a&gt; has already had a good crack at this problem, but Tree Sitter is geared towards providing accurate syntax highlighting and has a few missing features that Sapling needs:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Sapling needs comments to be preserved when parsing (but whitespace is perhaps not so essential)&lt;/li&gt; &#xA;   &lt;li&gt;Sapling needs to be able to render ASTs back to text, which I don&#39;t think Tree Sitter&#39;s grammars can handle&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;p&gt;For the sake of pragmatism, I think we should initially write a wrapper around tree-sitter for parsing/reading files so that Sapling at least works whilst we decide if a custom grammar is required (and if it is, how it should work).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;What&#39;s an AST?&lt;/h2&gt; &#xA;&lt;p&gt;AST stands for &lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;&#39;Abstract Syntax Tree&#39;&lt;/a&gt;, and in essence it is a tree-like representation of only the structure of a program, without any details about formatting.&lt;/p&gt; &#xA;&lt;p&gt;For example, the following Rust code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;fn foo(y: u64, z: u32) {&#xA;    let x = y * 3 + z as u64;&#xA;    combine(x, y);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;would correspond to a syntax tree something like the following (simplified for demonstration purposes). Notice how each &#39;element&#39; of the code corresponds to one &#39;node&#39; in the syntax tree:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kneasle/sapling/master/resources/example_tree.png&#34; alt=&#34;Example tree&#34;&gt;&lt;/p&gt;</summary>
  </entry>
</feed>