<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-16T01:36:52Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>shell-pool/shpool</title>
    <updated>2024-06-16T01:36:52Z</updated>
    <id>tag:github.com,2024-06-16:/shell-pool/shpool</id>
    <link href="https://github.com/shell-pool/shpool" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Think tmux, then aim... lower&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;shpool&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;shpool&lt;/code&gt; is a service that enables session persistence by allowing the creation of named shell sessions owned by &lt;code&gt;shpool&lt;/code&gt; so that the session is not lost if the connection drops. &lt;code&gt;shpool&lt;/code&gt; can be thought of as a lighter weight alternative to &lt;code&gt;tmux&lt;/code&gt; or GNU &lt;code&gt;screen&lt;/code&gt;. While &lt;code&gt;tmux&lt;/code&gt; and &lt;code&gt;screen&lt;/code&gt; take over the whole terminal and provide window splitting and tiling features, &lt;code&gt;shpool&lt;/code&gt; only provides persistent sessions. The biggest advantage of this approach is that &lt;code&gt;shpool&lt;/code&gt; does not break native scrollback or copy-paste.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Installing from crates.io&lt;/h3&gt; &#xA;&lt;p&gt;Run&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo install shpool&#xA;curl -fLo &#34;${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user/shpool.service&#34; --create-dirs https://raw.githubusercontent.com/shell-pool/shpool/master/systemd/shpool.service&#xA;sed -i &#34;s|/usr|$HOME/.cargo|&#34; &#34;${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user/shpool.service&#34;&#xA;curl -fLo &#34;${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user/shpool.socket&#34; --create-dirs https://raw.githubusercontent.com/shell-pool/shpool/master/systemd/shpool.socket&#xA;systemctl --user enable shpool&#xA;systemctl --user start shpool&#xA;loginctl enable-linger&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Generally &lt;code&gt;shpool&lt;/code&gt; is used to provide persistent sessions when sshing in to a remote host. To do so, &lt;code&gt;shpool&lt;/code&gt; must be installed on the remote host. No extra software is required on the client. After installing and setting up, the typical usage pattern is to ssh into the host you have installed shpool on, then create a new named session by running &lt;code&gt;shpool attach main&lt;/code&gt;. Here &lt;code&gt;main&lt;/code&gt; is the name of the session. You&#39;ll want a separate named session for each terminal you use to connect to your remote host. If your connection drops or becomes stuck, you can ssh back into the remote host and re-attach to the same named session by running &lt;code&gt;shpool attach main&lt;/code&gt; again.&lt;/p&gt; &#xA;&lt;p&gt;If your terminal gets stuck and you forcibly close the window, you might find that &lt;code&gt;shpool&lt;/code&gt; still think a terminal is connected to your session when you attempt to reattach. This is likely because an ssh proxy is holding the connection open in the vain hope that it will get some traffic again. You can just run &lt;code&gt;shpool detach main&lt;/code&gt; to force the session to detach and allow you to attach.&lt;/p&gt; &#xA;&lt;h3&gt;Configuration&lt;/h3&gt; &#xA;&lt;p&gt;You can specify some additional configuration options to the daemon by passing a &lt;code&gt;-c /path/to/config.toml&lt;/code&gt; flag, or by creating and editing &lt;code&gt;~/.config/shpool/config.toml&lt;/code&gt;. The options available are documented in detail in &lt;code&gt;libshpool/src/config.rs&lt;/code&gt;, but there are a few common things you may wish to tweak.&lt;/p&gt; &#xA;&lt;h4&gt;Detach Keybinding&lt;/h4&gt; &#xA;&lt;p&gt;You may wish to configure your detach keybinding. By default, &lt;code&gt;shpool&lt;/code&gt; will detach from the current user session when you press the sequence &lt;code&gt;Ctrl-Space Ctrl-q&lt;/code&gt; (press &lt;code&gt;Ctrl-Space&lt;/code&gt; then release it and press &lt;code&gt;Ctrl-q&lt;/code&gt;, don&#39;t try to hold down all three keys at once), but you can configure a different binding by adding an entry like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[[keybinding]]&#xA;binding = &#34;Ctrl-a d&#34;&#xA;action = &#34;Detach&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your &lt;code&gt;~/.config/shpool/config.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For the moment, control is the only modifier key supported, but the keybinding engine is designed to be able to handle more, so if you want a different one, you can file a bug with your feature request.&lt;/p&gt; &#xA;&lt;h4&gt;Session Restore Mode&lt;/h4&gt; &#xA;&lt;p&gt;Shpool can do a few different things when you re-attach to an existing session. You can choose what you want it to do with the &lt;code&gt;session_restore_mode&lt;/code&gt; configuration option.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;&#34;screen&#34;&lt;/code&gt; (default) - restore a screenful of history&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;&#34;screen&#34;&lt;/code&gt; option causes &lt;code&gt;shpool&lt;/code&gt; to re-draw sufficient output to fill the entire screen of the client terminal as well as using the SIGWINCH trick described in the &lt;code&gt;&#34;simple&#34;&lt;/code&gt; section below. This will help restore context for interactive terminal sessions that are not full blown ncurses apps. &lt;code&gt;&#34;screen&#34;&lt;/code&gt; is the default reattach behavior for &lt;code&gt;shpool&lt;/code&gt;. You can choose this option explicitly by adding&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;session_restore_mode = &#34;screen&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your &lt;code&gt;~/.config/shpool/config.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;&#34;simple&#34;&lt;/code&gt; - only ask child processes to redraw&lt;/h5&gt; &#xA;&lt;p&gt;The &lt;code&gt;&#34;simple&#34;&lt;/code&gt; option avoids restoring any output. In this reconnect mode, &lt;code&gt;shpool&lt;/code&gt; will issue some SIGWINCH signals to try to convince full screen ncurses apps such as vim or emacs to re-draw the screen, but will otherwise do nothing. Any shell output produced when there was no client connected to the session will be lost. You can choose this connection mode by adding&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;session_restore_mode = &#34;simple&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your &lt;code&gt;~/.config/shpool/config.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;&lt;code&gt;{ lines = n }&lt;/code&gt; - restore the last n lines of history&lt;/h5&gt; &#xA;&lt;p&gt;The lines option is much like the &lt;code&gt;&#34;screen&#34;&lt;/code&gt; option, except that rather than just a screenful of text, it restores the last n lines of text from the terminal being re-attached to. This could be useful if you wish to have more context than a single screenful of text. Note that n cannot exceed the value of the &lt;code&gt;output_spool_lines&lt;/code&gt; configuration option, but it defaults to the value of the lines option, so you likely won&#39;t need to change it.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;session_restore_mode = { lines = n }&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;where n is a number to your &lt;code&gt;~/.config/shpool/config.toml&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Shell Config&lt;/h4&gt; &#xA;&lt;h5&gt;bash&lt;/h5&gt; &#xA;&lt;p&gt;If you use bash, you may want to ensure that the &lt;code&gt;huponexit&lt;/code&gt; option is set to make sure that child processes exit when you leave a shell. Without this setting, background processes you have spawned over the course of your shell session will stick around in the &lt;code&gt;shpool&lt;/code&gt; daemon&#39;s process tree and eat up memory. To set this option add&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;shopt -s huponexit&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your &lt;code&gt;~/.bashrc&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Subcommands&lt;/h3&gt; &#xA;&lt;h4&gt;shpool daemon&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;daemon&lt;/code&gt; subcommand causes &lt;code&gt;shpool&lt;/code&gt; to run in daemon mode. When running in this mode, &lt;code&gt;shpool&lt;/code&gt; listens for incoming connections and opens up subshells, retaining ownership of them in a table. In general, this subcommand will not be invoked directly by users, but will instead be called from a systemd unit file.&lt;/p&gt; &#xA;&lt;h4&gt;shpool attach&lt;/h4&gt; &#xA;&lt;p&gt;The &lt;code&gt;attach&lt;/code&gt; subcommand connects to the &lt;code&gt;shpool daemon&lt;/code&gt; instance, passing in a name. If the name is new, a new shell is created, and if it already exists it just attaches to the existing session so long as no other terminal is currently connected to that session. The &lt;code&gt;--ttl&lt;/code&gt; flag can be used to limit how long the session will last.&lt;/p&gt; &#xA;&lt;h4&gt;shpool list&lt;/h4&gt; &#xA;&lt;p&gt;Lists all the current shell sessions.&lt;/p&gt; &#xA;&lt;h4&gt;shpool detach&lt;/h4&gt; &#xA;&lt;p&gt;Detach from a one or more sessions without stopping them. Will detach the current session if run from inside a &lt;code&gt;shpool&lt;/code&gt; session with no session name arguments.&lt;/p&gt; &#xA;&lt;h4&gt;shpool kill&lt;/h4&gt; &#xA;&lt;p&gt;Kills a named shell session.&lt;/p&gt; &#xA;&lt;h3&gt;(Optional) Automatically Connect to shpool&lt;/h3&gt; &#xA;&lt;h4&gt;Explicitly named sessions&lt;/h4&gt; &#xA;&lt;p&gt;Specifying session names yourself lets you assign logical roles such as text editing to each session.&lt;/p&gt; &#xA;&lt;h5&gt;ssh config&lt;/h5&gt; &#xA;&lt;p&gt;If you typically connect to a small number of sessions with the same jobs on a particular machine, custom ssh config blocks on your client machine are probably the best fit.&lt;/p&gt; &#xA;&lt;p&gt;To do this, you can add a config block named &lt;code&gt;edit&lt;/code&gt; like so&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Host = edit&#xA;    Hostname remote.host.example.com&#xA;&#xA;    RemoteCommand shpool attach -f edit&#xA;    RequestTTY yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to &lt;code&gt;~/.ssh/config&lt;/code&gt; on your client machine. You will need one such block per session name. You can then invoke this with &lt;code&gt;ssh edit&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h5&gt;shell function&lt;/h5&gt; &#xA;&lt;p&gt;If you would rather have a little more flexibility in specifying the session name and machine you are targeting, you can make a custom shell function to let you specify both at invocation time. Add&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;function shpool-ssh () {&#xA;    if [ $# -ne 2 ] ; then&#xA;        echo &#34;usage: shpool-ssh &amp;lt;remote-machine&amp;gt; &amp;lt;session-name&amp;gt;&#34; &amp;gt;&amp;amp;2&#xA;        return 1&#xA;    fi&#xA;    ssh -t &#34;-oRemoteCommand=shpool attach -f $2&#34; &#34;$1&#34;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to your &lt;code&gt;.bashrc&lt;/code&gt; then invoke it like &lt;code&gt;shpool-ssh remote.host.example.com main&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Local tty based&lt;/h4&gt; &#xA;&lt;p&gt;Rather than specify an explicit name when you connect, you can set up your system to automatically generate a &lt;code&gt;shpool&lt;/code&gt; session name based on your local terminal emulator&#39;s tty number. To do so, you can add a block of custom ssh config in the &lt;code&gt;~/.ssh/config&lt;/code&gt; of your local machine like&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;Host = by-tty&#xA;    User remoteuser&#xA;    Hostname remote.host.example.com&#xA;&#xA;    RemoteCommand shpool attach -f &#34;ssh-$(basename $(tty))&#34;&#xA;    RequestTTY yes&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which you then invoke with &lt;code&gt;ssh by-tty&lt;/code&gt;. You can apply the same principle of using &lt;code&gt;$(basename $(tty))&lt;/code&gt; to get a unique id for your local terminal to the custom shell function approach as well.&lt;/p&gt; &#xA;&lt;p&gt;The local-tty based approach has the advantage that you don&#39;t need to specify a session name, but it can run into problems if you have to close the local window and open a new terminal, which can come up if your connection freezes rather than drops.&lt;/p&gt; &#xA;&lt;h2&gt;Comparison with other tools&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;tmux&lt;/code&gt; and GNU &lt;code&gt;screen&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;tmux&lt;/code&gt; is probably the best known session persistence tool, and GNU &lt;code&gt;screen&lt;/code&gt; has a similar feature set, so in comparison to &lt;code&gt;shpool&lt;/code&gt; it can be thought of as belonging to the same category.&lt;/p&gt; &#xA;&lt;p&gt;The main way that &lt;code&gt;shpool&lt;/code&gt; differs from &lt;code&gt;tmux&lt;/code&gt; is that &lt;code&gt;tmux&lt;/code&gt; is a terminal multiplexer which necessarily means that it offers session persistence features, while &lt;code&gt;shpool&lt;/code&gt; only aims to be a session persistence tool. In contrast to &lt;code&gt;tmux&lt;/code&gt; the philosophy of &lt;code&gt;shpool&lt;/code&gt; is that managing different terminals is the job of your display or window manager, not your session persistence tool. Every operating system has its own idioms for switching between applications, and there is no reason to switch to different idioms when switching between terminals. Especially for users of tiling window managers such as &lt;code&gt;i3&lt;/code&gt;, &lt;code&gt;sway&lt;/code&gt; or &lt;code&gt;xmonad&lt;/code&gt;, tmux&#39;s multiplexing features are redundant.&lt;/p&gt; &#xA;&lt;p&gt;While &lt;code&gt;tmux&lt;/code&gt; renders terminal contents remotely and only paints the current view to the screen, &lt;code&gt;shpool&lt;/code&gt; just directly sends all shell output back to the user&#39;s local terminal. This means that all rendering is handled by a single terminal state machine rather than going through &lt;code&gt;tmux&lt;/code&gt;s internal in-memory terminal before getting formatted and re-rendered by the local terminal. This has performance implications, and probably most importantly means that a terminal using &lt;code&gt;shpool&lt;/code&gt; will feel completely native. Scrollback and copy-paste will work exactly as they do in your native terminal, while they can behave differently when using &lt;code&gt;tmux&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/mobile-shell/mosh&#34;&gt;&lt;code&gt;mosh&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;&lt;code&gt;mosh&lt;/code&gt; is another tool focused on providing persistent remote shell sessions. It differs from the other tools discussed here in that it has its own network protocol, which it bootstraps off of regular ssh. Like &lt;code&gt;tmux&lt;/code&gt;, it renders the screen contents remotely and sends just the current view back. It is somewhat unique in trying to predicatively guess the right output to display to the user if there is a network lag.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;shpool&lt;/code&gt; differs from &lt;code&gt;mosh&lt;/code&gt; in that it has nothing to do with the network, remaining confined to a single machine like most of these other tools. Just like in the case of &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;mosh&lt;/code&gt; will impact the way scrollback and copy-paste work, while &lt;code&gt;shpool&lt;/code&gt; keeps them feeling entirely native.&lt;/p&gt; &#xA;&lt;h3&gt;&lt;a href=&#34;https://github.com/crigler/dtach&#34;&gt;&lt;code&gt;dtach&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://github.com/martanne/abduco&#34;&gt;&lt;code&gt;abduco&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://github.com/yazgoo/diss&#34;&gt;&lt;code&gt;diss&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt; &#xA;&lt;p&gt;These tools have the most in common with &lt;code&gt;shpool&lt;/code&gt;. Just like &lt;code&gt;shpool&lt;/code&gt;, they eschew multiplexing and just send the raw bytes back to you for your local terminal to render. While you could say that &lt;code&gt;shpool&lt;/code&gt; aims to be a simpler version of &lt;code&gt;tmux&lt;/code&gt;, these tools follow the same philosophy with an even greater laser focus on simplicity and doing one thing well.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;shpool&lt;/code&gt; aims to be an easy and pleasant experience for people who just want session persistence without having to care about it too much, so it has a few more &#34;cushy&#34; features that would not be as good a fit for the focus on simplicity of these tools.&lt;/p&gt; &#xA;&lt;p&gt;The most obvious of these features is the difference between how &lt;code&gt;shpool&lt;/code&gt; and these programs handle re-attaches. Though under normal operation, &lt;code&gt;shpool&lt;/code&gt; does not do any rendering and subsetting of the shell output, it continually maintains an in-memory render of the terminal state via the &lt;a href=&#34;https://crates.io/crates/shpool_vt100&#34;&gt;&lt;code&gt;shpool_vt100&lt;/code&gt;&lt;/a&gt; crate. On reattach, &lt;code&gt;shpool&lt;/code&gt; will use this in-memory render to re-draw the screen, so you can easily see where you were when your connection dropped. This even allows you to see output generated after your connection dropped.&lt;/p&gt; &#xA;&lt;p&gt;Another such feature is the automatic prompt prefix. &lt;code&gt;shpool&lt;/code&gt; will detect when you are using a known shell (currently &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;zsh&lt;/code&gt;, or &lt;code&gt;fish&lt;/code&gt;) and automatically inject a prefix into your prompt to let you know the name of the &lt;code&gt;shpool&lt;/code&gt; session you are in. This adds some nice context so you don&#39;t lose track of your terminals and have some hint about the current terminal state.&lt;/p&gt; &#xA;&lt;p&gt;There are also some features &lt;code&gt;shpool&lt;/code&gt; is missing which these programs have. In particular, it seems that &lt;code&gt;dtach&lt;/code&gt; and &lt;code&gt;abduco&lt;/code&gt; support shared sessions, while &lt;code&gt;shpool&lt;/code&gt; only allows a single client to be connected to a particular session at a time. There may be more since I don&#39;t know these tools as well as &lt;code&gt;shpool&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Hacking&lt;/h2&gt; &#xA;&lt;p&gt;For information on how to develop shpool, see &lt;a href=&#34;https://raw.githubusercontent.com/shell-pool/shpool/master/HACKING.md&#34;&gt;HACKING.md&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>