<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-03-10T01:40:32Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>bkettle/message-book</title>
    <updated>2024-03-10T01:40:32Z</updated>
    <id>tag:github.com,2024-03-10:/bkettle/message-book</id>
    <link href="https://github.com/bkettle/message-book" rel="alternate"></link>
    <summary type="html">&lt;p&gt;make a book from imessages&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;message-book&lt;/h1&gt; &#xA;&lt;p&gt;This is a tool to make a book out of a given iMessage conversation. To use it, you need either an iPhone backup or a Mac that holds all the messages you want included. To use the tool, clone the repo and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cargo run -- --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The code is in pretty rough shape, but it should do the job. Let me know if you run into any issues.&lt;/p&gt; &#xA;&lt;p&gt;An example of the output can be seen in the &lt;a href=&#34;https://raw.githubusercontent.com/bkettle/message-book/main/example-output&#34;&gt;example-output&lt;/a&gt; directory.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bkettle/message-book/main/example-output/reservation-page.png&#34; alt=&#34;an example page, showing an automated reservation confirmation message on a blank page&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/bkettle/message-book/main/example-output/long-toc.png&#34; alt=&#34;an example table of contents for a book containing a whole year of text messages. Each month is listed with its page.&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>Rust-GPU/Rust-CUDA</title>
    <updated>2024-03-10T01:40:32Z</updated>
    <id>tag:github.com,2024-03-10:/Rust-GPU/Rust-CUDA</id>
    <link href="https://github.com/Rust-GPU/Rust-CUDA" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Ecosystem of libraries and tools for writing and executing fast GPU code fully in Rust.&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;h1&gt;The Rust CUDA Project&lt;/h1&gt; &#xA; &lt;p&gt; &lt;strong&gt;An ecosystem of libraries and tools for writing and executing extremely fast GPU code fully in &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust&lt;/a&gt;&lt;/strong&gt; &lt;/p&gt; &#xA; &lt;h3&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Rust-GPU/Rust-CUDA/master/guide&#34;&gt;Guide&lt;/a&gt; &lt;span&gt; | &lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Rust-GPU/Rust-CUDA/master/guide/src/guide/getting_started.md&#34;&gt;Getting Started&lt;/a&gt; &lt;span&gt; | &lt;/span&gt; &lt;a href=&#34;https://raw.githubusercontent.com/Rust-GPU/Rust-CUDA/master/guide/src/features.md&#34;&gt;Features&lt;/a&gt; &lt;/h3&gt; &#xA; &lt;strong&gt;⚠️ The project is still in early development, expect bugs, safety issues, and things that don&#39;t work ⚠️&lt;/strong&gt; &#xA;&lt;/div&gt; &#xA;&lt;h2&gt;Goal&lt;/h2&gt; &#xA;&lt;p&gt;The Rust CUDA Project is a project aimed at making Rust a tier-1 language for extremely fast GPU computing using the CUDA Toolkit. It provides tools for compiling Rust to extremely fast PTX code as well as libraries for using existing CUDA libraries with it.&lt;/p&gt; &#xA;&lt;h2&gt;Background&lt;/h2&gt; &#xA;&lt;p&gt;Historically, general purpose high performance GPU computing has been done using the CUDA toolkit. The CUDA toolkit primarily provides a way to use Fortran/C/C++ code for GPU computing in tandem with CPU code with a single source. It also provides many libraries, tools, forums, and documentation to supplement the single-source CPU/GPU code.&lt;/p&gt; &#xA;&lt;p&gt;CUDA is exclusively an NVIDIA-only toolkit. Many tools have been proposed for cross-platform GPU computing such as OpenCL, Vulkan Computing, and HIP. However, CUDA remains the most used toolkit for such tasks by far. This is why it is imperative to make Rust a viable option for use with the CUDA toolkit.&lt;/p&gt; &#xA;&lt;p&gt;However, CUDA with Rust has been a historically very rocky road. The only viable option until now has been to use the LLVM PTX backend, however, the LLVM PTX backend does not always work and would generate invalid PTX for many common Rust operations, and in recent years it has been shown time and time again that a specialized solution is needed for Rust on the GPU with the advent of projects such as rust-gpu (for Rust -&amp;gt; SPIR-V).&lt;/p&gt; &#xA;&lt;p&gt;Our hope is that with this project we can push the Rust GPU computing industry forward and make Rust an excellent language for such tasks. Rust offers plenty of benefits such as &lt;code&gt;__restrict__&lt;/code&gt; performance benefits for every kernel, An excellent module/crate system, delimiting of unsafe areas of CPU/GPU code with &lt;code&gt;unsafe&lt;/code&gt;, high level wrappers to low level CUDA libraries, etc.&lt;/p&gt; &#xA;&lt;h2&gt;Structure&lt;/h2&gt; &#xA;&lt;p&gt;The scope of the Rust CUDA Project is quite broad, it spans the entirety of the CUDA ecosystem, with libraries and tools to make it usable using Rust. Therefore, the project contains many crates for all corners of the CUDA ecosystem.&lt;/p&gt; &#xA;&lt;p&gt;The current line-up of libraries is the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;rustc_codegen_nvvm&lt;/code&gt; Which is a rustc backend that targets NVVM IR (a subset of LLVM IR) for the &lt;a href=&#34;https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html&#34;&gt;libnvvm&lt;/a&gt; library. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;Generates highly optimized PTX code which can be loaded by the CUDA Driver API to execute on the GPU.&lt;/li&gt; &#xA;   &lt;li&gt;For the near future it will be CUDA-only, but it may be used to target amdgpu in the future.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cuda_std&lt;/code&gt; for GPU-side functions and utilities, such as thread index queries, memory allocation, warp intrinsics, etc. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;em&gt;Not&lt;/em&gt; a low level library, provides many utility functions to make it easier to write cleaner and more reliable GPU kernels.&lt;/li&gt; &#xA;   &lt;li&gt;Closely tied to &lt;code&gt;rustc_codegen_nvvm&lt;/code&gt; which exposes GPU features through it internally.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Rust-GPU/Rust-CUDA/tree/master/crates/cudnn&#34;&gt;&lt;code&gt;cudnn&lt;/code&gt;&lt;/a&gt; for a collection of GPU-accelerated primitives for deep neural networks.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;cust&lt;/code&gt; for CPU-side CUDA features such as launching GPU kernels, GPU memory allocation, device queries, etc. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;High level with features such as RAII and Rust Results that make it easier and cleaner to manage the interface to the GPU.&lt;/li&gt; &#xA;   &lt;li&gt;A high level wrapper for the CUDA Driver API, the lower level version of the more common CUDA Runtime API used from C++.&lt;/li&gt; &#xA;   &lt;li&gt;Provides much more fine grained control over things like kernel concurrency and module loading than the C++ Runtime API.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gpu_rand&lt;/code&gt; for GPU-friendly random number generation, currently only implements xoroshiro RNGs from &lt;code&gt;rand_xoshiro&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;optix&lt;/code&gt; for CPU-side hardware raytracing and denoising using the CUDA OptiX library.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In addition to many &#34;glue&#34; crates for things such as high level wrappers for certain smaller CUDA libraries.&lt;/p&gt; &#xA;&lt;h2&gt;Related Projects&lt;/h2&gt; &#xA;&lt;p&gt;Other projects related to using Rust on the GPU:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;2016: &lt;a href=&#34;https://github.com/kmcallister/glassful&#34;&gt;glassful&lt;/a&gt; Subset of Rust that compiles to GLSL.&lt;/li&gt; &#xA; &lt;li&gt;2017: &lt;a href=&#34;https://github.com/msiglreith/inspirv-rust&#34;&gt;inspirv-rust&lt;/a&gt; Experimental Rust MIR -&amp;gt; SPIR-V Compiler.&lt;/li&gt; &#xA; &lt;li&gt;2018: &lt;a href=&#34;https://github.com/japaric-archived/nvptx&#34;&gt;nvptx&lt;/a&gt; Rust to PTX compiler using the &lt;code&gt;nvptx&lt;/code&gt; target for rustc (using the LLVM PTX backend).&lt;/li&gt; &#xA; &lt;li&gt;2020: &lt;a href=&#34;https://github.com/termoshtt/accel&#34;&gt;accel&lt;/a&gt; Higher level library that relied on the same mechanism that &lt;code&gt;nvptx&lt;/code&gt; does.&lt;/li&gt; &#xA; &lt;li&gt;2020: &lt;a href=&#34;https://github.com/MaikKlein/rlsl&#34;&gt;rlsl&lt;/a&gt; Experimental Rust -&amp;gt; SPIR-V compiler (predecessor to rust-gpu)&lt;/li&gt; &#xA; &lt;li&gt;2020: &lt;a href=&#34;https://github.com/EmbarkStudios/rust-gpu&#34;&gt;rust-gpu&lt;/a&gt; Rustc codegen backend to compile Rust to SPIR-V for use in shaders, similar mechanism as our project.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under either of&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Apache License, Version 2.0, (&lt;a href=&#34;https://raw.githubusercontent.com/Rust-GPU/Rust-CUDA/master/LICENSE-APACHE&#34;&gt;LICENSE-APACHE&lt;/a&gt; or &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;)&lt;/li&gt; &#xA; &lt;li&gt;MIT license (&lt;a href=&#34;https://raw.githubusercontent.com/Rust-GPU/Rust-CUDA/master/LICENSE-MIT&#34;&gt;LICENSE-MIT&lt;/a&gt; or &lt;a href=&#34;http://opensource.org/licenses/MIT&#34;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;at your discretion.&lt;/p&gt; &#xA;&lt;h3&gt;Contribution&lt;/h3&gt; &#xA;&lt;p&gt;Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>explodingcamera/tinywasm</title>
    <updated>2024-03-10T01:40:32Z</updated>
    <id>tag:github.com,2024-03-10:/explodingcamera/tinywasm</id>
    <link href="https://github.com/explodingcamera/tinywasm" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A tiny, interpreted WebAssembly Runtime written in Rust&lt;/p&gt;&lt;hr&gt;&lt;div&gt; &#xA; &lt;div&gt; &#xA;  &lt;a href=&#34;&#34;&gt;&lt;img align=&#34;left&#34; src=&#34;https://raw.githubusercontent.com/explodingcamera/tinywasm/main/tinywasm.png&#34; width=&#34;100px&#34;&gt;&lt;/a&gt; &#xA; &lt;/div&gt; &#xA; &lt;h1&gt;TinyWasm&lt;/h1&gt; A tiny WebAssembly Runtime written in Rust &#xA;&lt;/div&gt; &#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.rs/tinywasm&#34;&gt;&lt;img src=&#34;https://img.shields.io/docsrs/tinywasm?logo=rust&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/tinywasm&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/tinywasm.svg?logo=rust&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://raw.githubusercontent.com/explodingcamera/tinywasm/main/LICENSE-APACHE&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/l/tinywasm.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Why TinyWasm?&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Tiny&lt;/strong&gt;: TinyWasm is designed to be as small as possible without significantly compromising performance or functionality (&amp;lt; 6000 lines of code).&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Portable&lt;/strong&gt;: TinyWasm runs on any platform that Rust can target, including other WebAssembly Runtimes, with minimal external dependencies.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Lightweight&lt;/strong&gt;: TinyWasm is easy to integrate and has a low call overhead, making it suitable for scripting and embedding.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;As of version &lt;code&gt;0.3.0&lt;/code&gt;, TinyWasm successfully passes all the WebAssembly 1.0 tests in the &lt;a href=&#34;https://github.com/WebAssembly/testsuite&#34;&gt;WebAssembly Test Suite&lt;/a&gt;. Work on the 2.0 tests is ongoing. This enables TinyWasm to run most WebAssembly programs, including executing TinyWasm itself compiled to WebAssembly (see &lt;a href=&#34;https://raw.githubusercontent.com/explodingcamera/tinywasm/main/examples/wasm-rust.rs&#34;&gt;examples/wasm-rust.rs&lt;/a&gt;). The results of the testsuites are available &lt;a href=&#34;https://github.com/explodingcamera/tinywasm/tree/main/crates/tinywasm/tests/generated&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The API is still unstable and may change at any time, so you probably don&#39;t want to use it in production &lt;em&gt;yet&lt;/em&gt;. TinyWasm isn&#39;t primarily designed for high performance; it focuses more on simplicity, size, and portability. More details on its performance can be found in &lt;a href=&#34;https://raw.githubusercontent.com/explodingcamera/tinywasm/main/BENCHMARKS.md&#34;&gt;BENCHMARKS.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Future Development&lt;/strong&gt;: The first major version will focus on improving the API and adding support for &lt;a href=&#34;https://wasi.dev/&#34;&gt;WASI&lt;/a&gt;. While doing so, I also want to further simplify and reduce the codebase&#39;s size and improve the parser&#39;s performance.&lt;/p&gt; &#xA;&lt;h2&gt;Supported Proposals&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Proposal&lt;/th&gt; &#xA;   &lt;th&gt;Implementation Status&lt;/th&gt; &#xA;   &lt;th&gt;Version&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/mutable-global/raw/master/proposals/mutable-global/Overview.md&#34;&gt;&lt;strong&gt;Mutable Globals&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fully implemented&lt;/td&gt; &#xA;   &lt;td&gt;0.2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/spec/raw/master/proposals/multi-value/Overview.md&#34;&gt;&lt;strong&gt;Multi-value&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fully implemented&lt;/td&gt; &#xA;   &lt;td&gt;0.2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/spec/raw/master/proposals/sign-extension-ops/Overview.md&#34;&gt;&lt;strong&gt;Sign-extension operators&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fully implemented&lt;/td&gt; &#xA;   &lt;td&gt;0.2.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/spec/raw/master/proposals/bulk-memory-operations/Overview.md&#34;&gt;&lt;strong&gt;Bulk Memory Operations&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Fully implemented&lt;/td&gt; &#xA;   &lt;td&gt;0.4.0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/reference-types/raw/master/proposals/reference-types/Overview.md&#34;&gt;&lt;strong&gt;Reference Types&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Partially implemented&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/multi-memory/raw/master/proposals/multi-memory/Overview.md&#34;&gt;&lt;strong&gt;Multiple Memories&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Partially implemented&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://github.com/WebAssembly/memory64/raw/master/proposals/memory64/Overview.md&#34;&gt;&lt;strong&gt;Memory64&lt;/strong&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Partially implemented&lt;/td&gt; &#xA;   &lt;td&gt;N/A&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;TinyWasm can be used through the &lt;code&gt;tinywasm-cli&lt;/code&gt; CLI tool or as a library in your Rust project. Documentation can be found &lt;a href=&#34;https://docs.rs/tinywasm&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Library&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cargo add tinywasm&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;CLI&lt;/h3&gt; &#xA;&lt;p&gt;The CLI is mainly available for testing purposes, but can also be used to run WebAssembly programs.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cargo install tinywasm-cli&#xA;$ tinywasm-cli --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Feature Flags&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;std&lt;/code&gt;&lt;/strong&gt;&lt;br&gt; Enables the use of &lt;code&gt;std&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt; for parsing from files and streams. This is enabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/strong&gt;&lt;br&gt; Enables logging using the &lt;code&gt;log&lt;/code&gt; crate. This is enabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/strong&gt;&lt;br&gt; Enables the &lt;code&gt;tinywasm-parser&lt;/code&gt; crate. This is enabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;archive&lt;/code&gt;&lt;/strong&gt;&lt;br&gt; Enables pre-parsing of archives. This is enabled by default.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/strong&gt;&lt;br&gt; Uses &lt;code&gt;unsafe&lt;/code&gt; code to improve performance, particularly in Memory access.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;With all these features disabled, TinyWasm only depends on &lt;code&gt;core&lt;/code&gt;, &lt;code&gt;alloc&lt;/code&gt; ,and &lt;code&gt;libm&lt;/code&gt; and can be used in &lt;code&gt;no_std&lt;/code&gt; environments. Since &lt;code&gt;libm&lt;/code&gt; is not as performant as the compiler&#39;s math intrinsics, it is recommended to use the &lt;code&gt;std&lt;/code&gt; feature if possible (at least &lt;a href=&#34;https://github.com/rust-lang/rfcs/issues/2505&#34;&gt;for now&lt;/a&gt;), especially on wasm32 targets.&lt;/p&gt; &#xA;&lt;h2&gt;Inspiration&lt;/h2&gt; &#xA;&lt;p&gt;Big thanks to the authors of the following projects, which have inspired and influenced TinyWasm:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wasmi-labs/wasmi&#34;&gt;wasmi&lt;/a&gt; - an efficient and lightweight WebAssembly interpreter that also runs on &lt;code&gt;no_std&lt;/code&gt; environments&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wasm3/wasm3&#34;&gt;wasm3&lt;/a&gt; - a high performance WebAssembly interpreter written in C&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://wazero.io/&#34;&gt;wazero&lt;/a&gt; - a zero-dependency WebAssembly interpreter written in go&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/rhysd/wain&#34;&gt;wain&lt;/a&gt; - a zero-dependency WebAssembly interpreter written in Rust&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;I encourage you to check these projects out if you&#39;re looking for a more mature and feature-complete WebAssembly interpreter.&lt;/p&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Licensed under either of &lt;a href=&#34;https://raw.githubusercontent.com/explodingcamera/tinywasm/main/LICENSE-APACHE&#34;&gt;Apache License, Version 2.0&lt;/a&gt; or &lt;a href=&#34;https://raw.githubusercontent.com/explodingcamera/tinywasm/main/LICENSE-MIT&#34;&gt;MIT license&lt;/a&gt; at your option.&lt;/p&gt; &#xA;&lt;p&gt;Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in TinyWasm by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The GitHub repository contains a Submodule (&lt;code&gt;crates/tinywasm-parser/data&lt;/code&gt;) which is licensed only under the &lt;a href=&#34;https://github.com/WebAssembly/spec/raw/main/test/LICENSE&#34;&gt;Apache License, Version 2.0&lt;/a&gt;. This data is generated from the &lt;a href=&#34;https://github.com/WebAssembly/spec/tree/main/test&#34;&gt;WebAssembly Specification&lt;/a&gt; and is only used for testing purposes and not included in the final binary.&lt;/p&gt;</summary>
  </entry>
</feed>