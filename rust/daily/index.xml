<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-03T02:30:34Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>sfu-db/connector-x</title>
    <updated>2023-03-03T02:30:34Z</updated>
    <id>tag:github.com,2023-03-03:/sfu-db/connector-x</id>
    <link href="https://github.com/sfu-db/connector-x" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Fastest library to load data from DB to DataFrames in Rust and Python&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;ConnectorX &lt;a href=&#34;https://github.com/sfu-db/connector-x/actions&#34;&gt;&lt;img src=&#34;https://github.com/sfu-db/connector-x/workflows/ci/badge.svg?sanitize=true&#34; alt=&#34;status&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/sfu-db/connector-x/discussions&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Forum-Github%20Discussions-blue&#34; alt=&#34;discussions&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://pepy.tech/project/connectorx&#34;&gt;&lt;img src=&#34;https://pepy.tech/badge/connectorx&#34; alt=&#34;Downloads&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;Load data from &lt;img src=&#34;https://raw.githubusercontent.com/sfu-db/connector-x/main/assets/sources.gif&#34; width=&#34;6.5%&#34; style=&#34;margin-bottom: -2px&#34;&gt; to &lt;img src=&#34;https://raw.githubusercontent.com/sfu-db/connector-x/main/assets/destinations.gif&#34; width=&#34;7%&#34; style=&#34;margin-bottom: -2px&#34;&gt;, the fastest way.&lt;/p&gt; &#xA;&lt;p&gt;ConnectorX enables you to load data from databases into Python in the fastest and most memory efficient way.&lt;/p&gt; &#xA;&lt;p&gt;What you need is one line of code:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import connectorx as cx&#xA;&#xA;cx.read_sql(&#34;postgresql://username:password@server:port/database&#34;, &#34;SELECT * FROM lineitem&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Optionally, you can accelerate the data loading using parallelism by specifying a partition column.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import connectorx as cx&#xA;&#xA;cx.read_sql(&#34;postgresql://username:password@server:port/database&#34;, &#34;SELECT * FROM lineitem&#34;, partition_on=&#34;l_orderkey&#34;, partition_num=10)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The function will partition the query by &lt;strong&gt;evenly&lt;/strong&gt; splitting the specified column to the amount of partitions. ConnectorX will assign one thread for each partition to load and write data in parallel. Currently, we support partitioning on &lt;strong&gt;numerical&lt;/strong&gt; columns (&lt;strong&gt;cannot contain NULL&lt;/strong&gt;) for &lt;strong&gt;SPJA&lt;/strong&gt; queries.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Experimental: We are now providing federated query support (PostgreSQL only and do not support partition for now), you can write a single query to join tables from two or more databases! (JRE &amp;gt;= 1.8 is required)&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import connectorx as cx&#xA;&#xA;db1 = &#34;postgresql://username1:password1@server1:port1/database1&#34;&#xA;db2 = &#34;postgresql://username2:password2@server2:port2/database2&#34;&#xA;&#xA;cx.read_sql({&#34;db1&#34;: db1, &#34;db2&#34;: db2}, &#34;SELECT * FROM db1.nation n, db2.region r where n.n_regionkey = r.r_regionkey&#34;)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check out more detailed usage and examples &lt;a href=&#34;https://sfu-db.github.io/connector-x/api.html&#34;&gt;here&lt;/a&gt;. A general introduction of the project can be found in this &lt;a href=&#34;https://towardsdatascience.com/connectorx-the-fastest-way-to-load-data-from-databases-a65d4d4062d5&#34;&gt;blog post&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install connectorx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Check out &lt;a href=&#34;https://sfu-db.github.io/connector-x/install.html#build-from-source-code&#34;&gt;here&lt;/a&gt; to see how to build python wheel from source.&lt;/p&gt; &#xA;&lt;h1&gt;Performance&lt;/h1&gt; &#xA;&lt;p&gt;We compared different solutions in Python that provides the &lt;code&gt;read_sql&lt;/code&gt; function, by loading a 10x TPC-H lineitem table (8.6GB) from Postgres into a DataFrame, with 4 cores parallelism.&lt;/p&gt; &#xA;&lt;h2&gt;Time chart, lower is better.&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img alt=&#34;time chart&#34; src=&#34;https://raw.githubusercontent.com/sfu-db/connector-x/main/assets/pg-time.png&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Memory consumption chart, lower is better.&lt;/h2&gt; &#xA;&lt;p align=&#34;center&#34;&gt;&lt;img alt=&#34;memory chart&#34; src=&#34;https://raw.githubusercontent.com/sfu-db/connector-x/main/assets/pg-mem.png&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;In conclusion, ConnectorX uses up to &lt;strong&gt;3x&lt;/strong&gt; less memory and &lt;strong&gt;21x&lt;/strong&gt; less time (&lt;strong&gt;3x&lt;/strong&gt; less memory and &lt;strong&gt;13x&lt;/strong&gt; less time compared with Pandas.). More on &lt;a href=&#34;https://github.com/sfu-db/connector-x/raw/main/Benchmark.md#benchmark-result-on-aws-r54xlarge&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;How does ConnectorX achieve a lightning speed while keeping the memory footprint low?&lt;/h2&gt; &#xA;&lt;p&gt;We observe that existing solutions more or less do data copy multiple times when downloading the data. Additionally, implementing a data intensive application in Python brings additional cost.&lt;/p&gt; &#xA;&lt;p&gt;ConnectorX is written in Rust and follows &#34;zero-copy&#34; principle. This allows it to make full use of the CPU by becoming cache and branch predictor friendly. Moreover, the architecture of ConnectorX ensures the data will be copied exactly once, directly from the source to the destination.&lt;/p&gt; &#xA;&lt;h2&gt;How does ConnectorX download the data?&lt;/h2&gt; &#xA;&lt;p&gt;Upon receiving the query, e.g. &lt;code&gt;SELECT * FROM lineitem&lt;/code&gt;, ConnectorX will first issue a &lt;code&gt;LIMIT 1&lt;/code&gt; query &lt;code&gt;SELECT * FROM lineitem LIMIT 1&lt;/code&gt; to get the schema of the result set.&lt;/p&gt; &#xA;&lt;p&gt;Then, if &lt;code&gt;partition_on&lt;/code&gt; is specified, ConnectorX will issue &lt;code&gt;SELECT MIN($partition_on), MAX($partition_on) FROM (SELECT * FROM lineitem)&lt;/code&gt; to know the range of the partition column. After that, the original query is split into partitions based on the min/max information, e.g. &lt;code&gt;SELECT * FROM (SELECT * FROM lineitem) WHERE $partition_on &amp;gt; 0 AND $partition_on &amp;lt; 10000&lt;/code&gt;. ConnectorX will then run a count query to get the partition size (e.g. &lt;code&gt;SELECT COUNT(*) FROM (SELECT * FROM lineitem) WHERE $partition_on &amp;gt; 0 AND $partition_on &amp;lt; 10000&lt;/code&gt;). If the partition is not specified, the count query will be &lt;code&gt;SELECT COUNT(*) FROM (SELECT * FROM lineitem)&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Finally, ConnectorX will use the schema info as well as the count info to allocate memory and download data by executing the queries normally.&lt;/p&gt; &#xA;&lt;p&gt;Once the downloading begins, there will be one thread for each partition so that the data are downloaded in parallel at the partition level. The thread will issue the query of the corresponding partition to the database and then write the returned data to the destination row-wise or column-wise (depends on the database) in a streaming fashion.&lt;/p&gt; &#xA;&lt;h1&gt;Supported Sources &amp;amp; Destinations&lt;/h1&gt; &#xA;&lt;p&gt;Example connection string, supported protocols and data types for each data source can be found &lt;a href=&#34;https://sfu-db.github.io/connector-x/databases.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;For more planned data sources, please check out our &lt;a href=&#34;https://github.com/sfu-db/connector-x/discussions/61&#34;&gt;discussion&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Sources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Postgres&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Mysql&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Mariadb (through mysql protocol)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Sqlite&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Redshift (through postgres protocol)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Clickhouse (through mysql protocol)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; SQL Server&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Azure SQL Database (through mssql protocol)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Oracle&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Big Query&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; ODBC (WIP)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled&gt; ...&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Destinations&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Pandas&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; PyArrow&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Modin (through Pandas)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Dask (through Pandas)&lt;/li&gt; &#xA; &lt;li&gt;&lt;input type=&#34;checkbox&#34; checked disabled&gt; Polars (through PyArrow)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;p&gt;Doc: &lt;a href=&#34;https://sfu-db.github.io/connector-x/intro.html&#34;&gt;https://sfu-db.github.io/connector-x/intro.html&lt;/a&gt; Rust docs: &lt;a href=&#34;https://docs.rs/connectorx&#34;&gt;stable&lt;/a&gt; &lt;a href=&#34;https://sfu-db.github.io/connector-x/connectorx/&#34;&gt;nightly&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Next Plan&lt;/h1&gt; &#xA;&lt;p&gt;Checkout our &lt;a href=&#34;https://github.com/sfu-db/connector-x/discussions&#34;&gt;discussion&lt;/a&gt; to participate in deciding our next plan!&lt;/p&gt; &#xA;&lt;h1&gt;Historical Benchmark Results&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://sfu-db.github.io/connector-x/dev/bench/&#34;&gt;https://sfu-db.github.io/connector-x/dev/bench/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Developer&#39;s Guide&lt;/h1&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://github.com/sfu-db/connector-x/raw/main/CONTRIBUTING.md&#34;&gt;Developer&#39;s Guide&lt;/a&gt; for information about developing ConnectorX.&lt;/p&gt; &#xA;&lt;h1&gt;Supports&lt;/h1&gt; &#xA;&lt;p&gt;You are always welcomed to:&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;Ask questions &amp;amp; propose new ideas in our github &lt;a href=&#34;https://github.com/sfu-db/connector-x/discussions&#34;&gt;discussion&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Ask questions in stackoverflow. Make sure to have #connectorx attached.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h1&gt;Organizations and Projects using ConnectorX&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/pola-rs/polars&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pola-rs/polars-static/master/logos/polars-logo-dark.svg?sanitize=true&#34; height=&#34;60&#34; style=&#34;margin-bottom: -2px&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://dataprep.ai/&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/sfu-db/dataprep/develop/assets/logo.png&#34; height=&#34;60&#34; style=&#34;margin-bottom: -2px&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://modin.readthedocs.io&#34;&gt;&lt;img src=&#34;https://github.com/modin-project/modin/raw/3d6368edf311995ad231ec5342a51cd9e4e3dc20/docs/img/MODIN_ver2_hrz.png?raw=true&#34; height=&#34;60&#34; style=&#34;margin-bottom: -2px&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;To add your project/organization here, reply our post &lt;a href=&#34;https://github.com/sfu-db/connector-x/discussions/146&#34;&gt;here&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Citing ConnectorX&lt;/h1&gt; &#xA;&lt;p&gt;If you use ConnectorX, please consider citing the following paper:&lt;/p&gt; &#xA;&lt;p&gt;Xiaoying Wang, Weiyuan Wu, Jinze Wu, Yizhou Chen, Nick Zrymiak, Changbo Qu, Lampros Flokas, George Chow, Jiannan Wang, Tianzheng Wang, Eugene Wu, Qingqing Zhou. &lt;a href=&#34;https://www.vldb.org/pvldb/vol15/p2994-wang.pdf&#34;&gt;ConnectorX: Accelerating Data Loading From Databases to Dataframes.&lt;/a&gt; &lt;em&gt;VLDB 2022&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;BibTeX entry:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bibtex&#34;&gt;@article{connectorx2022,&#xA;  author    = {Xiaoying Wang and Weiyuan Wu and Jinze Wu and Yizhou Chen and Nick Zrymiak and Changbo Qu and Lampros Flokas and George Chow and Jiannan Wang and Tianzheng Wang and Eugene Wu and Qingqing Zhou},&#xA;  title     = {ConnectorX: Accelerating Data Loading From Databases to Dataframes},&#xA;  journal   = {Proc. {VLDB} Endow.},&#xA;  volume    = {15},&#xA;  number    = {11},&#xA;  pages     = {2994--3003},&#xA;  year      = {2022},&#xA;  url       = {https://www.vldb.org/pvldb/vol15/p2994-wang.pdf},&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>rosenpass/rosenpass</title>
    <updated>2023-03-03T02:30:34Z</updated>
    <id>tag:github.com,2023-03-03:/rosenpass/rosenpass</id>
    <link href="https://github.com/rosenpass/rosenpass" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Rosenpass is a formally verified, post-quantum secure VPN that uses WireGuard to transport the actual data.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Rosenpass README&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/rosenpass/rosenpass/actions/workflows/nix.yaml/badge.svg?sanitize=true&#34; alt=&#34;Nix&#34;&gt; &lt;img src=&#34;https://github.com/rosenpass/rosenpass/actions/workflows/qc.yaml/badge.svg?sanitize=true&#34; alt=&#34;QC&#34;&gt; &lt;img src=&#34;https://img.shields.io/crates/v/rosenpass.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt; &lt;img src=&#34;https://img.shields.io/librariesio/release/cargo/rosenpass&#34; alt=&#34;Libraries.io dependency status for latest release&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;This repository contains&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;A description of the &lt;a href=&#34;https://github.com/rosenpass/rosenpass/raw/papers-pdf/whitepaper.pdf&#34;&gt;Rosenpass protocol&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;The reference implementation of the protocol – the &lt;a href=&#34;https://raw.githubusercontent.com/rosenpass/rosenpass/main/src&#34;&gt;rosenpass tool&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;A frontend integrating Rosenpass and WireGuard to create a vpn – the &lt;a href=&#34;https://raw.githubusercontent.com/rosenpass/rosenpass/main/rp&#34;&gt;rp frontend&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/rosenpass/rosenpass/main/analysis&#34;&gt;Security analysis&lt;/a&gt; of the protocol using proverif&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Getting started&lt;/h2&gt; &#xA;&lt;p&gt;First, &lt;a href=&#34;https://raw.githubusercontent.com/rosenpass/rosenpass/main/#Getting-Rosenpass&#34;&gt;install rosenpass&lt;/a&gt;. Then, check out the help funtions of &lt;code&gt;rp&lt;/code&gt; &amp;amp; &lt;code&gt;rosenpass&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rp help&#xA;rosenpass help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Follow &lt;a href=&#34;https://rosenpass.eu/#start&#34;&gt;quickstart instructions&lt;/a&gt; to get a VPN up and running.&lt;/p&gt; &#xA;&lt;h2&gt;Software architecture&lt;/h2&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/rosenpass/rosenpass/main/src/&#34;&gt;rosenpass tool&lt;/a&gt; is written in Rust and uses liboqs&lt;a href=&#34;https://openquantumsafe.org/liboqs/&#34;&gt;^liboqs&lt;/a&gt; and libsodium&lt;a href=&#34;https://doc.libsodium.org/&#34;&gt;^libsodium&lt;/a&gt;. The tool establishes a symmetric key and provides it to WireGuard. Since it supplies WireGuard with key through the PSK feature using Rosenpass+WireGuard is cryptographically no less secure than using WireGuard on its own (&#34;hybrid security&#34;). Rosenpass refreshes the symmetric key every two minutes.&lt;/p&gt; &#xA;&lt;p&gt;As with any application a small risk of critical security issues (such as buffer overflows, remote code execution) exists; the Rosenpass application is written in the Rust programming language which is much less prone to such issues. Rosenpass can also write keys to files instead of supplying them to WireGuard With a bit of scripting the stand alone mode of the implementation can be used to run the application in a Container, VM or on another host. This mode can also be used to integrate tools other than WireGuard with Rosenpass.&lt;/p&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/rosenpass/rosenpass/main/rp&#34;&gt;&lt;code&gt;rp&lt;/code&gt;&lt;/a&gt; tool written in bash makes it easy to create a VPN using WireGuard and Rosenpass.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;rp&lt;/code&gt; is easy to get started with but has a few drawbacks; it runs as root, demanding access to both WireGuard and Rosenpass private keys, takes control of the interface and works with exactly one interface. If you do not feel confident about running Rosenpass as root, you should use the stand-alone mode to create a more secure setup using containers, jails, or virtual machines.&lt;/p&gt; &#xA;&lt;h3&gt;Networking &amp;amp; ports&lt;/h3&gt; &#xA;&lt;p&gt;rp allocates two UDP ports; if port N is specified for rosenpass, it will allocate port N+1 for WireGuard.&lt;/p&gt; &#xA;&lt;p&gt;Like WireGuard, Rosenpass does not enforce any separation between clients and servers. If you do not specify the &lt;code&gt;listen&lt;/code&gt; option, Rosenpass and WireGuard will choose random ports; this is &lt;em&gt;client mode&lt;/em&gt;. If you do not specify &lt;code&gt;endpoint&lt;/code&gt;, Rosenpass will not try to connect to the peer and instead wait for connections from peers. This is &lt;em&gt;server mode&lt;/em&gt;. You may specify both. Leaving out both is not forbidden but also not very useful.&lt;/p&gt; &#xA;&lt;h2&gt;Security analysis&lt;/h2&gt; &#xA;&lt;!-- Currently, a symbolic analysis in proverif asserts various properties for the Rosenpass protocol. Further on, a proof of the cryptographic promises based on cryptoverif is in the process of being made. --&gt; &#xA;&lt;p&gt;We are working on a cryptographic proof of security, but we already provide a symbolic analysis using proverif as part of the software package. You can run the security analysis using the nix package manager which handles installing the dependencies or you can call the &lt;a href=&#34;https://github.com/rosenpass/rosenpass/raw/main/analyze.sh&#34;&gt;&lt;code&gt;./analyze.sh&lt;/code&gt;&lt;/a&gt; script directly. In this case, you need to ensure that &lt;code&gt;proverif&lt;/code&gt;, &lt;code&gt;graphviz&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, and &lt;code&gt;cpp&lt;/code&gt; are installed on your system.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;   (nix) $ nix build .#proof-proverif --print-build-logs&#xA;(manual) $ ./analyze.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The analysis is implemented according to modern software engineering principles: Using the C preprocessor, we where able to split the analysis into multiple files and uses some metaprogramming to avoid repetition. The code uses a variety of optimizations to speed up analysis such as using secret functions to model trusted/malicious setup. We split the model into two separate entry points which can be analyzed in parallel. Each is much faster than both models combined. A wrapper script provides instant feedback about which queries execute as expected in color: A red cross if a query fails and a green check if it succeeds.&lt;/p&gt; &#xA;&lt;p&gt;[^pqwg-statedis]: Unless supplied with a pre-shared-key, but this defeates the purpose of a key exchange protocol [^wg-statedis]: &lt;a href=&#34;https://lists.zx2c4.com/pipermail/wireguard/2021-August/006916.htmlA&#34;&gt;https://lists.zx2c4.com/pipermail/wireguard/2021-August/006916.htmlA&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Getting Rosenpass&lt;/h1&gt; &#xA;&lt;p&gt;Rosenpass is packaged for more and more distros, maybe also for the distro of your choice?&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://repology.org/project/rosenpass/versions&#34;&gt;&lt;img src=&#34;https://repology.org/badge/vertical-allrepos/rosenpass.svg?sanitize=true&#34; alt=&#34;Packaging status&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Supported by&lt;/h1&gt; &#xA;&lt;p&gt;Funded through &lt;a href=&#34;https://nlnet.nl/&#34;&gt;NLNet&lt;/a&gt; with financial support for the European Commission&#39;s &lt;a href=&#34;https://nlnet.nl/assure&#34;&gt;NGI Assure&lt;/a&gt; program.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>KusionStack/KCLVM</title>
    <updated>2023-03-03T02:30:34Z</updated>
    <id>tag:github.com,2023-03-03:/KusionStack/KCLVM</id>
    <link href="https://github.com/KusionStack/KCLVM" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A constraint-based record &amp; functional language mainly used in configuration and policy scenarios.&lt;/p&gt;&lt;hr&gt;&lt;h1 align=&#34;center&#34;&gt;KCL: Constraint-based Record &amp;amp; Functional Language&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/README.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/README-zh.md&#34;&gt;简体中文&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#introduction&#34;&gt;Introduction&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#features&#34;&gt;Features&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#what-is-it-for&#34;&gt;What is it for&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#installation&#34;&gt;Installation&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#showcase&#34;&gt;Showcase&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#documentation&#34;&gt;Documentation&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#contributing&#34;&gt;Contributing&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/#roadmap&#34;&gt;Roadmap&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/KusionStack/KCLVM/workflows/release/badge.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square&#34;&gt; &lt;img src=&#34;https://coveralls.io/repos/github/KusionStack/KCLVM/badge.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/release/KusionStack/KCLVM.svg?sanitize=true&#34;&gt; &lt;img src=&#34;https://img.shields.io/github/license/KusionStack/KCLVM.svg?sanitize=true&#34;&gt; &lt;/p&gt; &#xA;&lt;h2&gt;Introduction&lt;/h2&gt; &#xA;&lt;p&gt;Kusion Configuration Language (KCL) is an open-source, constraint-based record and functional language. KCL improves the complexity of writing numerous complex configurations, such as cloud native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great ecological extensibility.&lt;/p&gt; &#xA;&lt;h2&gt;What is it for?&lt;/h2&gt; &#xA;&lt;p&gt;You can use KCL to&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://kcl-lang.io/docs/user_docs/guides/configuration&#34;&gt;Generate low-level static configuration data&lt;/a&gt; such as JSON, YAML, etc., or &lt;a href=&#34;https://kcl-lang.io/docs/user_docs/guides/data-integration&#34;&gt;integrate with existing data&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Reduce boilerplate in configuration data with the &lt;a href=&#34;https://kcl-lang.io/docs/user_docs/guides/schema-definition&#34;&gt;schema modeling&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Define schemas with &lt;a href=&#34;https://kcl-lang.io/docs/user_docs/guides/validation&#34;&gt;rule constraints for configuration data and validate&lt;/a&gt; them automatically.&lt;/li&gt; &#xA; &lt;li&gt;Organize, simplify, unify and manage large configurations without side effects through &lt;a href=&#34;https://kcl-lang.io/docs/user_docs/guides/automation&#34;&gt;gradient automation schemes&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Manage large configurations in a scalable way with &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#config-operations&#34;&gt;isolated configuration blocks&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Used as a platform engineering programming language to deliver modern applications with &lt;a href=&#34;https://kusionstack.io&#34;&gt;Kusion Stack&lt;/a&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Easy-to-use&lt;/strong&gt;: Originated from high-level languages ​​such as Python and Golang, incorporating functional language features with low side-effects.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Well-designed&lt;/strong&gt;: Independent spec-driven syntax, semantics, runtime and system modules design.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Quick modeling&lt;/strong&gt;: &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#schema&#34;&gt;Schema&lt;/a&gt;-centric configuration types and modular abstraction.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Rich capabilities&lt;/strong&gt;: Configuration with type, logic and policy based on &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#config-operations&#34;&gt;Config&lt;/a&gt;, &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#schema&#34;&gt;Schema&lt;/a&gt;, &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#function&#34;&gt;Lambda&lt;/a&gt;, &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#rule&#34;&gt;Rule&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Stability&lt;/strong&gt;: Configuration stability is achieved through a &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour/#type-system&#34;&gt;static type system&lt;/a&gt;, &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour/#validation&#34;&gt;constraints&lt;/a&gt;, and &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour#rule&#34;&gt;rules&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Scalability&lt;/strong&gt;: High scalability is assured with an &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour/#-operators-1&#34;&gt;automatic merge mechanism&lt;/a&gt; of isolated config blocks.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Fast automation&lt;/strong&gt;: Gradient automation scheme of &lt;a href=&#34;https://kcl-lang.io/docs/reference/lang/tour/#kcl-cli-variable-override&#34;&gt;CRUD APIs&lt;/a&gt;, &lt;a href=&#34;https://kcl-lang.io/docs/reference/xlang-api/overview&#34;&gt;multilingual SDKs&lt;/a&gt;, and &lt;a href=&#34;https://github.com/KusionStack/kcl-plugin&#34;&gt;language plugin&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;High performance&lt;/strong&gt;: High compile-time and runtime performance using Rust &amp;amp; C and &lt;a href=&#34;https://llvm.org/&#34;&gt;LLVM&lt;/a&gt;, and support compilation to native code and &lt;a href=&#34;https://webassembly.org/&#34;&gt;WASM&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;API affinity&lt;/strong&gt;: Native support for ecological API specifications such as &lt;a href=&#34;https://github.com/KusionStack/kcl-openapi&#34;&gt;OpenAPI&lt;/a&gt;, Kubernetes CRD, Kubernetes YAML spec.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Developer-friendly&lt;/strong&gt;: Friendly development experiences with rich &lt;a href=&#34;https://kcl-lang.io/docs/tools/cli/kcl/&#34;&gt;language tools&lt;/a&gt; (Format, Lint, Test, Vet, Doc, etc.) and &lt;a href=&#34;https://github.com/KusionStack/vscode-kcl&#34;&gt;IDE plugins&lt;/a&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Safety &amp;amp; maintainable&lt;/strong&gt;: Domain-oriented, no system-level functions such as native threads and IO, low noise and security risk, easy maintenance and governance.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Production-ready&lt;/strong&gt;: Widely used in production practices of platform engineering and automation at Ant Group.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;How to choose?&lt;/h2&gt; &#xA;&lt;p&gt;The simple answer:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;YAML is recommended if you need to write structured static K-V or use Kubernetes&#39; native tools.&lt;/li&gt; &#xA; &lt;li&gt;HCL is recommended if you want to use programming language convenience to remove boilerplate with good human readability or if you are already a Terraform user.&lt;/li&gt; &#xA; &lt;li&gt;CUE is recommended if you want to use a type system to improve stability and maintain scalable configurations.&lt;/li&gt; &#xA; &lt;li&gt;KCL is recommended if you want types and modeling like a modern language, scalable configurations, in-house pure functions and rules, and production-ready performance and automation.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;A detailed feature and scenario comparison is &lt;a href=&#34;https://kcl-lang.io/docs/user_docs/getting-started/intro&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/KusionStack/KCLVM/releases&#34;&gt;Download&lt;/a&gt; the latest release from GitHub and add &lt;code&gt;{install-location}/kclvm/bin&lt;/code&gt; to the environment &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Showcase&lt;/h2&gt; &#xA;&lt;p&gt;&lt;code&gt;./samples/kubernetes.k&lt;/code&gt; is an example of generating kubernetes manifests.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;apiVersion = &#34;apps/v1&#34;&#xA;kind = &#34;Deployment&#34;&#xA;metadata = {&#xA;    name = &#34;nginx&#34;&#xA;    labels.app = &#34;nginx&#34;&#xA;}&#xA;spec = {&#xA;    replicas = 3&#xA;    selector.matchLabels = metadata.labels&#xA;    template.metadata.labels = metadata.labels&#xA;    template.spec.containers = [&#xA;        {&#xA;            name = metadata.name&#xA;            image = &#34;${metadata.name}:1.14.2&#34;&#xA;            ports = [{ containerPort = 80 }]&#xA;        }&#xA;    ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We can execute the following command to get a YAML output.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kcl ./samples/kubernetes.k&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;YAML output&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: nginx&#xA;  labels:&#xA;    app: nginx&#xA;spec:&#xA;  replicas: 3&#xA;  selector:&#xA;    matchLabels:&#xA;      app: nginx&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: nginx&#xA;    spec:&#xA;      containers:&#xA;      - name: nginx&#xA;        image: nginx:1.14.2&#xA;        ports:&#xA;        - containerPort: 80&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Documentation&lt;/h2&gt; &#xA;&lt;p&gt;Detailed documentation is available at &lt;a href=&#34;https://kcl-lang.io/&#34;&gt;KCL Website&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/KusionStack/KCLVM/main/docs/dev_guide/1.about_this_guide.md&#34;&gt;Developing Guide&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Roadmap&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://github.com/KusionStack/KCLVM/issues/29&#34;&gt;KCL Roadmap&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Community&lt;/h2&gt; &#xA;&lt;p&gt;See the &lt;a href=&#34;https://github.com/KusionStack/community&#34;&gt;community&lt;/a&gt; for ways to join us.&lt;/p&gt;</summary>
  </entry>
</feed>