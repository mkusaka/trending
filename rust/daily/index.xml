<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-04-22T01:43:04Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>willcrichton/flowistry</title>
    <updated>2023-04-22T01:43:04Z</updated>
    <id>tag:github.com,2023-04-22:/willcrichton/flowistry</id>
    <link href="https://github.com/willcrichton/flowistry" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Flowistry is an IDE plugin for Rust that helps you focus on relevant code.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/663326/134070630-47b95f41-a4a7-4ded-a5cb-9884d1af2468.png&#34; height=&#34;25&#34;&gt; Flowistry: Information Flow for Rust&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/willcrichton/flowistry/actions/workflows/ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/willcrichton/flowistry/actions/workflows/tests.yml/badge.svg?sanitize=true&#34; alt=&#34;tests&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/flowistry&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/flowistry.svg?sanitize=true&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://willcrichton.net/flowistry/flowistry&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/docs-built-blue&#34; alt=&#34;docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Flowistry is a tool that analyzes the &lt;a href=&#34;https://en.wikipedia.org/wiki/Information_flow_(information_theory)&#34;&gt;information flow&lt;/a&gt; of Rust programs. Flowistry understands whether it&#39;s possible for one piece of code to affect another. Flowistry integrates into the IDE to provide a &#34;focus mode&#34; which helps you focus on the code that&#39;s related to your current task.&lt;/p&gt; &#xA;&lt;p&gt;For example, this GIF shows the focus mode when reading a function that unions two sets together:&lt;/p&gt; &#xA;&lt;kbd&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/663326/155062086-4d58a149-86c8-4a48-a6aa-a07cf027641c.gif&#34; height=&#34;180&#34;&gt; &lt;/kbd&gt; &#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;p&gt;When the user clicks a given variable or expression, Flowistry fades out all code that &lt;em&gt;does not influence&lt;/em&gt; that code, and &lt;em&gt;is not influenced by&lt;/em&gt; that code. For example, &lt;code&gt;orig_len&lt;/code&gt; is not influenced by the for-loop, while &lt;code&gt;set.len()&lt;/code&gt; is.&lt;/p&gt; &#xA;&lt;p&gt;Flowistry can be helpful when you&#39;re reading a function with a lot of code. For example, this GIF shows a real function in the Rust compiler. If you want to understand the role of a specific argument to the function, then Flowistry can filter out most of the code as irrelevant:&lt;/p&gt; &#xA;&lt;kbd&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/663326/155062527-6b42f64a-3429-4572-860f-7c2e244691d6.gif&#34; height=&#34;500&#34;&gt; &lt;/kbd&gt; &#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;p&gt;&lt;strong&gt;Table of contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#installation&#34;&gt;Installation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#ide-plugin&#34;&gt;IDE plugin&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#rustc-plugin&#34;&gt;Rustc plugin&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#startup&#34;&gt;Startup&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#entering-focus-mode&#34;&gt;Entering focus mode&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#setting-a-mark&#34;&gt;Setting a mark&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#selecting-the-focus-region&#34;&gt;Selecting the focus region&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#limitations&#34;&gt;Limitations&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#flowistry-does-not-completely-handle-interior-mutability&#34;&gt;Flowistry does not completely handle interior mutability&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#a-focus-region-may-include-more-code-than-you-expect&#34;&gt;A focus region may include more code than you expect&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#not-all-code-is-selectable&#34;&gt;Not all code is selectable&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#nested-functions-cannot-be-analyzed-together-including-closures-and-async&#34;&gt;Nested functions cannot be analyzed together (including closures and async)&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#faq&#34;&gt;FAQ&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#rustup-fails-on-installation&#34;&gt;rustup fails on installation&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#why-isnt-flowistry-part-of-rust-analyzer&#34;&gt;Why isn&#39;t Flowistry part of Rust Analyzer?&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#why-does-flowistry-highlight-or-not-this-code&#34;&gt;Why does Flowistry highlight (or not) this code?&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;IDE plugin&lt;/h3&gt; &#xA;&lt;p&gt;Flowistry is available as a VSCode plugin. You can install Flowistry from the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=wcrichton.flowistry&#34;&gt;Visual Studio Marketplace&lt;/a&gt; or the &lt;a href=&#34;https://open-vsx.org/extension/wcrichton/flowistry&#34;&gt;Open VSX Registry&lt;/a&gt;. In VSCode:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Go to the Extensions pane by clicking this button in the left margin: &lt;img width=&#34;30&#34; alt=&#34;Screen Shot 2021-09-20 at 9 30 43 AM&#34; src=&#34;https://user-images.githubusercontent.com/663326/134039225-68d11dce-be71-4f33-8057-569346ef26bc.png&#34;&gt;&lt;/li&gt; &#xA; &lt;li&gt;Search for &#34;Flowistry&#34; and then click &#34;Install&#34;.&lt;/li&gt; &#xA; &lt;li&gt;Open a Rust workspace and wait for the tool to finish installing.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Note on platform support:&lt;/strong&gt; Flowistry does not yet support NixOS. Flowistry cannot provide pre-built binaries for ARM targets like M1 Macs, so Flowistry must be installed from scratch on these targets (this is done for you, but will take a few more minutes than usual).&lt;/p&gt; &#xA;&lt;p&gt;Alternatively, you can install it from source:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Install flowistry binaries&#xA;git clone https://github.com/willcrichton/flowistry&#xA;cd flowistry&#xA;cargo install --path crates/flowistry_ide&#xA;&#xA;# Install vscode extension&#xA;cd ide&#xA;npm install&#xA;npm run build&#xA;ln -s $(pwd) ~/.vscode/extensions/flowistry&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Rustc plugin&lt;/h3&gt; &#xA;&lt;p&gt;If you are interested in the underlying analysis, you can use the &lt;code&gt;flowistry&lt;/code&gt; crate published to crates.io: &lt;a href=&#34;https://crates.io/crates/flowistry&#34;&gt;https://crates.io/crates/flowistry&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;The documentation is published here: &lt;a href=&#34;https://willcrichton.net/flowistry/flowistry/&#34;&gt;https://willcrichton.net/flowistry/flowistry/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Docs.rs doesn&#39;t support documentation for crates that use &lt;code&gt;#![feature(rustc_private)]&lt;/code&gt; so we have to host it ourselves.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;h3&gt;Startup&lt;/h3&gt; &#xA;&lt;p&gt;Once you have installed Flowistry, open a Rust workspace in VSCode. You should see this icon in the bottom toolbar:&lt;/p&gt; &#xA;&lt;kbd&gt; &lt;img width=&#34;121&#34; alt=&#34;Screen Shot 2022-02-22 at 11 46 12 AM&#34; src=&#34;https://user-images.githubusercontent.com/663326/155207447-4efb34b1-5e3d-4416-89aa-a0f7cd334ca4.png&#34;&gt; &lt;/kbd&gt; &#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;p&gt;Flowistry starts up by type-checking your codebase. This may take a few minutes if you have many dependencies.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Flowistry type-checking results are cached in the &lt;code&gt;target/flowistry&lt;/code&gt; directory. If you delete this folder, Flowistry will have to recompute types. Also for a large codebase this directory may take up a fair amount of disk space.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Entering focus mode&lt;/h3&gt; &#xA;&lt;p&gt;Once Flowistry has booted up, the loading icon will disappear. Then you can enter focus mode by running the &#34;Toggle focus mode&#34; command. By default the keyboard shortcut is Ctrl+R Ctrl+A (⌘+R ⌘+A on Mac), or you can use the Flowistry context menu:&lt;/p&gt; &#xA;&lt;kbd&gt; &lt;img width=&#34;450&#34; alt=&#34;Screen Shot 2022-02-22 at 11 52 39 AM&#34; src=&#34;https://user-images.githubusercontent.com/663326/155208449-83fceff7-86fe-4fe8-9fca-62552e6b0b43.png&#34;&gt; &lt;/kbd&gt; &#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;p&gt;In focus mode, Flowistry will automatically compute the information flow within a given function once you put your cursor there. Once Flowistry has finished analysis, the status bar will look like this:&lt;/p&gt; &#xA;&lt;kbd&gt; &lt;img width=&#34;120&#34; alt=&#34;Screen Shot 2022-02-22 at 11 55 36 AM&#34; src=&#34;https://user-images.githubusercontent.com/663326/155208955-1f47ab0c-f3ae-4028-82b3-6f67e6fc0db7.png&#34;&gt; &lt;/kbd&gt; &#xA;&lt;br&gt;&#xA;&lt;br&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Note: Flowistry can be a bit slow for larger functions. It may take up to 15 seconds to finish the analysis.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;Flowistry infers what you want to focus on based on your cursor. So if you click on a variable, you should see the focus region of that variable. Flowistry will highlight the focused code in gray, and then fade out code outside the focus region. For example, because the user&#39;s cursor is on &lt;code&gt;view_projection&lt;/code&gt;, that variable is highlighted in gray, and its focus region is shown.&lt;/p&gt; &#xA;&lt;kbd&gt; &lt;img width=&#34;900&#34; alt=&#34;Screen Shot 2022-02-22 at 12 00 22 PM&#34; src=&#34;https://user-images.githubusercontent.com/663326/155209805-75a23ed9-01ba-4100-b8bb-324b516f84cf.png&#34;&gt; &lt;/kbd&gt; &#xA;&lt;h3&gt;Setting a mark&lt;/h3&gt; &#xA;&lt;p&gt;Sometimes you want to keep the focus region where it is, and click on other code to inspect it without changing focus. For this purpose, Flowistry has a concept of a &#34;mark&#34;. Once you have selected code to focus on, you can run the &#34;Set mark&#34; command (Ctrl+R Ctrl+S / ⌘+R ⌘+S). Then a mark is set at your cursor&#39;s current position, and the focus will stay there until you run the &#34;Unset mark&#34; command (Ctrl+R Ctrl+D / ⌘+R ⌘+D).&lt;/p&gt; &#xA;&lt;h3&gt;Selecting the focus region&lt;/h3&gt; &#xA;&lt;p&gt;If you want to modify all the code in the focus region, e.g. to comment it out or copy it, then you can run the &#34;Select focused region&#34; command (Ctrl+R Ctrl+T / ⌘+R ⌘+T). This will add the entire focus region into your editor&#39;s selection.&lt;/p&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;Flowistry is an active research project into the applications of information flow analysis for Rust. It is continually evolving as we experiment with analysis techniques and interaction paradigms. So it&#39;s not quite as polished or efficient as tools like Rust Analyzer, but we hope you can still find it useful! Nevertheless, there are a number of important limitations you should understand when using Flowistry to avoid being surprised.&lt;/p&gt; &#xA;&lt;p&gt;If you have questions or issues, please &lt;a href=&#34;https://github.com/willcrichton/flowistry/issues&#34;&gt;file a Github issue&lt;/a&gt;, &lt;a href=&#34;https://discord.gg/XkcpkQn2Ah&#34;&gt;join our Discord&lt;/a&gt;, or &lt;a href=&#34;https://twitter.com/wcrichton&#34;&gt;DM @wcrichton on Twitter&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Flowistry does not completely handle interior mutability&lt;/h3&gt; &#xA;&lt;p&gt;When your code has references, Flowistry needs to understand what that reference points-to. Flowistry uses Rust&#39;s lifetime information to determine points-to information. However, data structures that use interior mutability such as &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; explicitly &lt;em&gt;do not&lt;/em&gt; share lifetimes between pointers to the same data. For example, in this snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x = Arc::new(Mutex::new(0));&#xA;let y = x.clone();&#xA;*x.lock().unwrap() = 1;&#xA;println!(&#34;{}&#34;, y.lock().unwrap());&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Flowistry &lt;em&gt;can&lt;/em&gt; determine that &lt;code&gt;*x.lock().unwrap() = 1&lt;/code&gt; is a mutation to &lt;code&gt;x&lt;/code&gt;, but it &lt;em&gt;can not&lt;/em&gt; determine that it is a mutation to &lt;code&gt;y&lt;/code&gt;. So if you focus on &lt;code&gt;y&lt;/code&gt;, the assignment to 1 would be faded out, even though it is relevant to the value of &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;We are researching methods to overcome this limitation, but for now just be aware that this is the main case where Flowistry is known to provide an incorrect answer.&lt;/p&gt; &#xA;&lt;h3&gt;A focus region may include more code than you expect&lt;/h3&gt; &#xA;&lt;p&gt;Flowistry&#39;s analysis tries to include all code that &lt;em&gt;could&lt;/em&gt; have an influence on a focal point. This analysis makes a number of assumptions for both practical and fundamental reasons. For example, in this snippet:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let mut v = vec![1, 2, 3];&#xA;let x = v.get_mut(0);&#xA;println!(&#34;{:?} {}&#34;, v, x);&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you focus on &lt;code&gt;v&lt;/code&gt; on line 3, it will include &lt;code&gt;v.get_mut(0)&lt;/code&gt; as an operation that could have modified &lt;code&gt;v&lt;/code&gt;. The reason is that Flowistry does not actually analyze the bodies of called functions, but rather approximates based on their type signatures. Because &lt;code&gt;get_mut&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as input, it assumes that the vector &lt;em&gt;could&lt;/em&gt; be modified.&lt;/p&gt; &#xA;&lt;p&gt;In general, you should use focus mode as a pruning tool. If code is faded out, then you don&#39;t have to read it (minus the limitation mentioned above!). If it isn&#39;t faded out, then it might be relevant to your task.&lt;/p&gt; &#xA;&lt;h3&gt;Not all code is selectable&lt;/h3&gt; &#xA;&lt;p&gt;Flowistry works by analyzing the &lt;a href=&#34;https://rustc-dev-guide.rust-lang.org/mir/index.html&#34;&gt;MIR&lt;/a&gt; graph for a given function using the Rust compiler&#39;s API. Then the IDE extension lifts the analysis results from the MIR level back to the source level. However, a lot of information about the program is lost in the journey from source code to MIR.&lt;/p&gt; &#xA;&lt;p&gt;For example, if the source contains an expression &lt;code&gt;foo.whomp.bar().baz()&lt;/code&gt;, it&#39;s possible that a temporary variable is only generated for the expression &lt;code&gt;foo.whomp.bar()&lt;/code&gt;. So if the user selects &lt;code&gt;foo&lt;/code&gt;, Flowistry may not be able to determine that this corresponds to the MIR &lt;a href=&#34;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/struct.Place.html&#34;&gt;place&lt;/a&gt; that represents &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;This is why the IDE extension highlights the focused code in gray, so you can understand what your cursor&#39;s selection actually maps to.&lt;/p&gt; &#xA;&lt;h3&gt;Nested functions cannot be analyzed together (including closures and async)&lt;/h3&gt; &#xA;&lt;p&gt;Flowistry analyzes a single function at a time. If a function contains other functions, e.g. &lt;code&gt;fn&lt;/code&gt; definitions, or closures, or implicitly via async, then Flowistry will only show you focus regions within the smallest function body containing your cursor. This is usually well defined for function definitions and closures, but may be confusing for async since that depends on how rustc decides to carve up your async function.&lt;/p&gt; &#xA;&lt;h2&gt;FAQ&lt;/h2&gt; &#xA;&lt;h3&gt;rustup fails on installation&lt;/h3&gt; &#xA;&lt;p&gt;If rustup fails, especially with an error like &#34;could not rename downloaded file&#34;, this is probably because Flowistry is running rustup concurrently with another tool (like rust-analyzer). Until &lt;a href=&#34;https://github.com/rust-lang/rustup/issues/988&#34;&gt;rustup#988&lt;/a&gt; is resolved, there is unfortunately no automated way around this.&lt;/p&gt; &#xA;&lt;p&gt;To solve the issue, go to the command line and run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;rustup toolchain install nightly-2023-04-12 -c rust-src -c rustc-dev -c llvm-tools-preview&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Then go back to VSCode and click &#34;Continue&#34; to let Flowistry continue installing.&lt;/p&gt; &#xA;&lt;h3&gt;Why isn&#39;t Flowistry part of Rust Analyzer?&lt;/h3&gt; &#xA;&lt;p&gt;Rust Analyzer does not support &lt;a href=&#34;https://rustc-dev-guide.rust-lang.org/mir/index.html&#34;&gt;MIR&lt;/a&gt; and the borrow checker, which are essential parts of Flowistry&#39;s analysis. That fact is unlikely to change for a &lt;a href=&#34;https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer/topic/How.20far.20is.20RA.20from.20MIR.3F&#34;&gt;long time&lt;/a&gt;, so Flowistry is a standalone tool.&lt;/p&gt; &#xA;&lt;h3&gt;Why does Flowistry highlight (or not) this code?&lt;/h3&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/willcrichton/flowistry/master/#limitations&#34;&gt;Limitations&lt;/a&gt; for known issues. If that doesn&#39;t explain what you&#39;re seeing, please post it in the &lt;a href=&#34;https://github.com/willcrichton/flowistry/issues/36&#34;&gt;unexpected highlights issue&lt;/a&gt; or ask on &lt;a href=&#34;https://discord.gg/XkcpkQn2Ah&#34;&gt;Discord&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nvzqz/condtype</title>
    <updated>2023-04-22T01:43:04Z</updated>
    <id>tag:github.com,2023-04-22:/nvzqz/condtype</id>
    <link href="https://github.com/nvzqz/condtype" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Choose Rust types via boolean conditions&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;code&gt;condtype&lt;/code&gt;&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.rs/condtype&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/condtype.svg?style=flat-square&amp;amp;label=docs&amp;amp;color=blue&amp;amp;logo=rust&#34; alt=&#34;docs.rs&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://crates.io/crates/condtype&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/d/condtype.svg?style=flat-square&#34; alt=&#34;crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/nvzqz/condtype&#34;&gt;&lt;img src=&#34;https://img.shields.io/github/stars/nvzqz/condtype.svg?style=flat-square&amp;amp;color=black&#34; alt=&#34;github&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Choose Rust types via boolean conditions, brought to you by &lt;a href=&#34;https://hachyderm.io/@nikolai&#34;&gt;Nikolai Vazquez&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you find this crate useful, consider &lt;a href=&#34;https://github.com/nvzqz/condtype&#34;&gt;starring it&lt;/a&gt; as well as &lt;a href=&#34;https://github.com/sponsors/nvzqz&#34;&gt;sponsoring&lt;/a&gt; or &lt;a href=&#34;https://paypal.me/nvzqz&#34;&gt;donating once&lt;/a&gt;. 💖&lt;/p&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;p&gt;This crate enables choosing a type based on a compile-time constant, just like &lt;a href=&#34;https://en.cppreference.com/w/cpp/types/conditional&#34;&gt;&lt;code&gt;std::conditional_t&lt;/code&gt; in C++&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use condtype::CondType;&#xA;&#xA;let str: CondType&amp;lt;true,  &amp;amp;str, i32&amp;gt; = &#34;hello&#34;;&#xA;let int: CondType&amp;lt;false, &amp;amp;str, i32&amp;gt; = 42;&#xA;&#xA;// Unsized types are also supported:&#xA;let str: &amp;amp;CondType&amp;lt;true, str, [u8]&amp;gt; = &#34;world&#34;;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Limitations&lt;/h2&gt; &#xA;&lt;p&gt;It is currently not possible to use &lt;code&gt;CondType&lt;/code&gt; with a generic constant, since Rust does not yet consider trait implementations based on booleans to be exhaustive (see &lt;a href=&#34;https://github.com/rust-lang/project-const-generics/issues/26&#34;&gt;issue&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;fn generic&amp;lt;const B: bool&amp;gt;() {&#xA;    let x: CondType&amp;lt;B, i32, u8&amp;gt; = ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Install&lt;/h2&gt; &#xA;&lt;p&gt;This crate is &lt;a href=&#34;https://crates.io/crates/condtype&#34;&gt;available on crates.io&lt;/a&gt; and can be used by running the following &lt;code&gt;cargo&lt;/code&gt; command in your project directory:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cargo add condtype&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or by manually adding the following to your project&#39;s &lt;a href=&#34;https://doc.rust-lang.org/cargo/reference/manifest.html&#34;&gt;&lt;code&gt;Cargo.toml&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]&#xA;condtype = &#34;1.0.0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;License&lt;/h2&gt; &#xA;&lt;p&gt;Like the Rust project, this library may be used under either the &lt;a href=&#34;https://github.com/nvzqz/condtype/raw/main/LICENSE-MIT&#34;&gt;MIT License&lt;/a&gt; or &lt;a href=&#34;https://github.com/nvzqz/condtype/raw/main/LICENSE-APACHE&#34;&gt;Apache License (Version 2.0)&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>a16z/magi</title>
    <updated>2023-04-22T01:43:04Z</updated>
    <id>tag:github.com,2023-04-22:/a16z/magi</id>
    <link href="https://github.com/a16z/magi" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A blazing fast OP Stack rollup client written in Rust&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Magi &amp;nbsp;&lt;span&gt;🟠&lt;/span&gt;&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/a16z/magi/actions/workflows/test.yml&#34;&gt;&lt;img src=&#34;https://github.com/a16z/magi/actions/workflows/test.yml/badge.svg?sanitize=true&#34; alt=&#34;build&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://opensource.org/license/agpl-v3/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/License-AGPL_v3-blue.svg?sanitize=true&#34; alt=&#34;license: AGPL v3&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://t.me/+6zrIsnaLO0hjNmZh&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/chat-telegram-blue&#34; alt=&#34;chat&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Magi is an OP Stack rollup client written in Rust, designed to perform the same functionality as op-node. It is compatible with execution clients like op-geth. As an independent implementation, Magi aims to enhance the safety and liveness of the entire OP Stack ecosystem. Magi is still new, so we expect to find some bugs in the coming months. For critical infrastructure, we recommend using op-node.&lt;/p&gt; &#xA;&lt;h2&gt;Running&lt;/h2&gt; &#xA;&lt;p&gt;For convenience, we provide a simple Docker setup to run Magi and op-geth together. This guide assumes you have both docker and git installed on your machine.&lt;/p&gt; &#xA;&lt;p&gt;Start by cloning the Magi repository and entering the docker subdirectory&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone git@github.com:a16z/magi.git &amp;amp;&amp;amp; cd magi/docker&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Next copy &lt;code&gt;.env.default&lt;/code&gt; to &lt;code&gt;.env&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cp .env.default .env&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In the &lt;code&gt;.env&lt;/code&gt; file, modify the &lt;code&gt;L1_RPC_URL&lt;/code&gt; field to contain a valid Ethereum RPC. For the Optimism and Base testnets, this must be a Goerli RPC URL. This RPC can either be from a local node, or a provider such as Alchemy or Infura.&lt;/p&gt; &#xA;&lt;p&gt;By default, the &lt;code&gt;NETWORK&lt;/code&gt; field in &lt;code&gt;.env&lt;/code&gt; is &lt;code&gt;optimism-goerli&lt;/code&gt;, however &lt;code&gt;base-goerli&lt;/code&gt; is also supported.&lt;/p&gt; &#xA;&lt;p&gt;Start the docker containers&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker compose up -d&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If the previous step fails with a permission denied error, try running the command with &lt;code&gt;sudo&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The docker setup contains a Grafana dashboard. To view sync progress, you can check the dashboard at &lt;code&gt;http://localhost:3000&lt;/code&gt; with the username &lt;code&gt;magi&lt;/code&gt; and password &lt;code&gt;op&lt;/code&gt;. Alternatively, you can view Magi&#39;s logs by running &lt;code&gt;docker logs magi --follow&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;All contributions to Magi are welcome. Before opening a PR, please submit an issue detailing the bug or feature. Please ensure that your contribution builds on the stable Rust toolchain, has been linted with &lt;code&gt;cargo fmt&lt;/code&gt;, passes &lt;code&gt;cargo clippy&lt;/code&gt;, and contains tests when applicable.&lt;/p&gt; &#xA;&lt;h2&gt;Disclaimer&lt;/h2&gt; &#xA;&lt;p&gt;&lt;em&gt;This code is being provided as is. No guarantee, representation or warranty is being made, express or implied, as to the safety or correctness of the code. It has not been audited and as such there can be no assurance it will work as intended, and users may experience delays, failures, errors, omissions or loss of transmitted information. Nothing in this repo should be construed as investment advice or legal advice for any particular facts or circumstances and is not meant to replace competent counsel. It is strongly advised for you to contact a reputable attorney in your jurisdiction for any questions or concerns with respect thereto. a16z is not liable for any use of the foregoing, and users should proceed with caution and use at their own risk. See a16z.com/disclosures for more info.&lt;/em&gt;&lt;/p&gt;</summary>
  </entry>
</feed>