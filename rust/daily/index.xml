<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Rust Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-20T01:42:08Z</updated>
  <subtitle>Daily Trending of Rust in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Totodore/socketioxide</title>
    <updated>2023-10-20T01:42:08Z</updated>
    <id>tag:github.com,2023-10-20:/Totodore/socketioxide</id>
    <link href="https://github.com/Totodore/socketioxide" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A socket.io server implementation in Rust that integrates with the Tower ecosystem and the Tokio stack.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;a href=&#34;https://github.com/totodore/socketioxide&#34;&gt;&lt;code&gt;Socketioxide&lt;/code&gt;&lt;/a&gt; üöÄü¶Ä&lt;/h1&gt; &#xA;&lt;p&gt;A &lt;a href=&#34;https://socket.io&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;socket.io&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt; server implementation in Rust that integrates with the &lt;a href=&#34;https://tokio.rs/#tk-lib-tower&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;Tower&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt; ecosystem and the &lt;a href=&#34;https://tokio.rs&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;Tokio stack&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;. It integrates with any server framework based on tower like &lt;a href=&#34;https://docs.rs/axum/latest/axum/&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;Axum&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/warp/latest/warp/&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;Warp&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt; or &lt;a href=&#34;https://docs.rs/hyper/latest/hyper/&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;Hyper&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;. Add any other tower based middleware on top of socketioxide such as CORS, authorization, compression, etc with &lt;a href=&#34;https://docs.rs/tower-http/latest/tower_http/&#34;&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;tower-http&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;‚ö†Ô∏è This crate is under active development and the API is not yet stable.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/socketioxide&#34;&gt;&lt;img src=&#34;https://img.shields.io/crates/v/socketioxide.svg?sanitize=true&#34; alt=&#34;Crates.io&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://docs.rs/socketioxide&#34;&gt;&lt;img src=&#34;https://docs.rs/socketioxide/badge.svg?sanitize=true&#34; alt=&#34;Documentation&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/Totodore/socketioxide/actions/workflows/github-ci.yml&#34;&gt;&lt;img src=&#34;https://github.com/Totodore/socketioxide/actions/workflows/github-ci.yml/badge.svg?sanitize=true&#34; alt=&#34;CI&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/solar.png&#34;&gt; &#xA;&lt;h2&gt;Features :&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Integrates with : &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.rs/axum/latest/axum/&#34;&gt;Axum&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/Totodore/socketioxide/main/examples/src/socketio-echo/axum_echo.rs&#34;&gt;üèìecho example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.rs/warp/latest/warp/&#34;&gt;Warp&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/Totodore/socketioxide/main/examples/src/socketio-echo/warp_echo.rs&#34;&gt;üèìecho example&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.rs/hyper/latest/hyper/&#34;&gt;Hyper&lt;/a&gt;: &lt;a href=&#34;https://raw.githubusercontent.com/Totodore/socketioxide/main/examples/src/socketio-echo/hyper_echo.rs&#34;&gt;üèìecho example&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Out of the box support for any other middleware based on tower : &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.rs/tower-http/latest/tower_http/cors&#34;&gt;üîìCORS&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.rs/tower-http/latest/tower_http/compression&#34;&gt;üìÅCompression&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://docs.rs/tower-http/latest/tower_http/auth&#34;&gt;üîêAuthorization&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Namespaces&lt;/li&gt; &#xA; &lt;li&gt;Rooms&lt;/li&gt; &#xA; &lt;li&gt;Ack and emit with ack&lt;/li&gt; &#xA; &lt;li&gt;Binary packets&lt;/li&gt; &#xA; &lt;li&gt;Polling &amp;amp; Websocket transports&lt;/li&gt; &#xA; &lt;li&gt;Extensions to add custom data to sockets&lt;/li&gt; &#xA; &lt;li&gt;Memory efficient http payload parsing with streams&lt;/li&gt; &#xA; &lt;li&gt;Api that mimics the &lt;a href=&#34;https://socket.io/docs/v4/server-api/&#34;&gt;socket.io&lt;/a&gt; javascript api as much as possible&lt;/li&gt; &#xA; &lt;li&gt;Well tested with the official &lt;a href=&#34;https://github.com/totodore/socketioxide/actions&#34;&gt;end to end test-suite&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Socket.io versions supported : &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://socket.io/docs/v4/&#34;&gt;üîåprotocol v5&lt;/a&gt; : based on engine.io v4 under the feature flag &lt;code&gt;v5&lt;/code&gt; (default), (socket.io js from v3.0.0..latest)&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://github.com/socketio/socket.io-protocol/tree/v4&#34;&gt;üîåprotocol v4&lt;/a&gt; : based on engine.io v3, feature flag &lt;code&gt;v4&lt;/code&gt;, (socket.io js from v1.0.3..latest)&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/solar.png&#34;&gt; &#xA;&lt;h2&gt;Planned features :&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Other adapter to share state between server instances (like redis adapter), currently only the in memory adapter is implemented&lt;/li&gt; &#xA; &lt;li&gt;State recovery when a socket reconnects&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/solar.png&#34;&gt; &#xA;&lt;h2&gt;Examples :&lt;/h2&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;code&gt;Chat app üí¨ (see full example &lt;a href=&#34;https://raw.githubusercontent.com/Totodore/socketioxide/main/examples/src/chat&#34;&gt;here&lt;/a&gt;)&lt;/code&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use std::sync::Arc;&#xA;&#xA;use serde::Deserialize;&#xA;use socketioxide::{adapter::LocalAdapter, Socket};&#xA;use tracing::info;&#xA;&#xA;#[derive(Deserialize, Clone, Debug)]&#xA;pub struct Nickname(String);&#xA;&#xA;#[derive(Deserialize)]&#xA;pub struct Auth {&#xA;    pub nickname: Nickname,&#xA;}&#xA;&#xA;pub async fn handler(socket: Arc&amp;lt;Socket&amp;lt;LocalAdapter&amp;gt;&amp;gt;, data: Option&amp;lt;Auth&amp;gt;) {&#xA;    info!(&#34;Socket connected on / with id: {}&#34;, socket.id);&#xA;    if let Some(data) = data {&#xA;        info!(&#34;Nickname: {:?}&#34;, data.nickname);&#xA;        socket.extensions.insert(data.nickname);&#xA;        socket.emit(&#34;message&#34;, &#34;Welcome to the chat!&#34;).ok();&#xA;        socket.join(&#34;default&#34;).unwrap();&#xA;    } else {&#xA;        info!(&#34;No nickname provided, disconnecting...&#34;);&#xA;        socket.disconnect().ok();&#xA;        return;&#xA;    }&#xA;&#xA;    socket.on(&#xA;        &#34;message&#34;,&#xA;        |socket, (room, message): (String, String), _, _| async move {&#xA;            let Nickname(ref nickname) = *socket.extensions.get().unwrap();&#xA;            info!(&#34;transfering message from {nickname} to {room}: {message}&#34;);&#xA;            info!(&#34;Sockets in room: {:?}&#34;, socket.local().sockets().unwrap());&#xA;            if let Some(dest) = socket.to(&#34;default&#34;).sockets().unwrap().iter().find(|s| {&#xA;                s.extensions&#xA;                    .get::&amp;lt;Nickname&amp;gt;()&#xA;                    .map(|n| n.0 == room)&#xA;                    .unwrap_or_default()&#xA;            }) {&#xA;                info!(&#34;Sending message to {}&#34;, room);&#xA;                dest.emit(&#34;message&#34;, format!(&#34;{}: {}&#34;, nickname, message))&#xA;                    .ok();&#xA;            }&#xA;&#xA;            socket&#xA;                .to(room)&#xA;                .emit(&#34;message&#34;, format!(&#34;{}: {}&#34;, nickname, message))&#xA;                .ok();&#xA;        },&#xA;    );&#xA;&#xA;    socket.on(&#34;join&#34;, |socket, room: String, _, _| async move {&#xA;        info!(&#34;Joining room {}&#34;, room);&#xA;        socket.join(room).unwrap();&#xA;    });&#xA;&#xA;    socket.on(&#34;leave&#34;, |socket, room: String, _, _| async move {&#xA;        info!(&#34;Leaving room {}&#34;, room);&#xA;        socket.leave(room).unwrap();&#xA;    });&#xA;&#xA;    socket.on(&#34;list&#34;, |socket, room: Option&amp;lt;String&amp;gt;, _, _| async move {&#xA;        if let Some(room) = room {&#xA;            info!(&#34;Listing sockets in room {}&#34;, room);&#xA;            let sockets = socket&#xA;                .within(room)&#xA;                .sockets()&#xA;                .unwrap()&#xA;                .iter()&#xA;                .filter_map(|s| s.extensions.get::&amp;lt;Nickname&amp;gt;())&#xA;                .fold(&#34;&#34;.to_string(), |a, b| a + &amp;amp;b.0 + &#34;, &#34;)&#xA;                .trim_end_matches(&#34;, &#34;)&#xA;                .to_string();&#xA;            socket.emit(&#34;message&#34;, sockets).ok();&#xA;        } else {&#xA;            let rooms = socket.rooms().unwrap();&#xA;            info!(&#34;Listing rooms: {:?}&#34;, &amp;amp;rooms);&#xA;            socket.emit(&#34;message&#34;, rooms).ok();&#xA;        }&#xA;    });&#xA;&#xA;    socket.on(&#34;nickname&#34;, |socket, nickname: Nickname, _, _| async move {&#xA;        let previous = socket.extensions.insert(nickname.clone());&#xA;        info!(&#34;Nickname changed from {:?} to {:?}&#34;, &amp;amp;previous, &amp;amp;nickname);&#xA;        let msg = format!(&#xA;            &#34;{} changed his nickname to {}&#34;,&#xA;            previous.map(|n| n.0).unwrap_or_default(),&#xA;            nickname.0&#xA;        );&#xA;        socket.to(&#34;default&#34;).emit(&#34;message&#34;, msg).ok();&#xA;    });&#xA;&#xA;    socket.on_disconnect(|socket, reason| async move {&#xA;        info!(&#34;Socket disconnected: {} {}&#34;, socket.id, reason);&#xA;        let Nickname(ref nickname) = *socket.extensions.get().unwrap();&#xA;        let msg = format!(&#34;{} left the chat&#34;, nickname);&#xA;        socket.to(&#34;default&#34;).emit(&#34;message&#34;, msg).ok();&#xA;    });&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt; &#xA; &lt;summary&gt;&lt;code&gt;Echo implementation with Axum üèì&lt;/code&gt;&lt;/summary&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;use axum::routing::get;&#xA;use axum::Server;&#xA;use serde_json::Value;&#xA;use socketioxide::SocketIo;&#xA;use tracing::info;&#xA;use tracing_subscriber::FmtSubscriber;&#xA;&#xA;#[tokio::main]&#xA;async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {&#xA;    tracing::subscriber::set_global_default(FmtSubscriber::default())?;&#xA;&#xA;    let (layer, io) = SocketIo::new_layer();&#xA;    io.ns(&#34;/&#34;, |socket, auth: Value| async move {&#xA;        info!(&#34;Socket.IO connected: {:?} {:?}&#34;, socket.ns(), socket.sid);&#xA;        socket.emit(&#34;auth&#34;, auth).ok();&#xA;&#xA;        socket.on(&#34;message&#34;, |socket, data: Value, bin, _| async move {&#xA;            info!(&#34;Received event: {:?} {:?}&#34;, data, bin);&#xA;            socket.bin(bin).emit(&#34;message-back&#34;, data).ok();&#xA;        });&#xA;&#xA;        socket.on(&#34;message-with-ack&#34;, |_, data: Value, bin, ack| async move {&#xA;            info!(&#34;Received event: {:?} {:?}&#34;, data, bin);&#xA;            ack.bin(bin).send(data).ok();&#xA;        });&#xA;&#xA;        socket.on_disconnect(|socket, reason| async move {&#xA;            info!(&#34;Socket.IO disconnected: {} {}&#34;, socket.sid, reason);&#xA;        });&#xA;    });&#xA;&#xA;    io.ns(&#34;/custom&#34;, |socket, auth: Value| async move {&#xA;        info!(&#34;Socket.IO connected on: {:?} {:?}&#34;, socket.ns(), socket.sid);&#xA;        socket.emit(&#34;auth&#34;, auth).ok();&#xA;    });&#xA;&#xA;    let app = axum::Router::new()&#xA;        .route(&#34;/&#34;, get(|| async { &#34;Hello, World!&#34; }))&#xA;        .layer(layer);&#xA;&#xA;    info!(&#34;Starting server&#34;);&#xA;&#xA;    Server::bind(&amp;amp;&#34;127.0.0.1:3000&#34;.parse().unwrap())&#xA;        .serve(app.into_make_service())&#xA;        .await?;&#xA;&#xA;    Ok(())&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;img src=&#34;https://raw.githubusercontent.com/andreasbm/readme/master/assets/lines/solar.png&#34;&gt; &#xA;&lt;h2&gt;Contributions and Feedback / Questions :&lt;/h2&gt; &#xA;&lt;p&gt;Any contribution is welcome, feel free to open an issue or a PR. If you want to contribute but don&#39;t know where to start, you can check the &lt;a href=&#34;https://github.com/totodore/socketioxide/issues&#34;&gt;issues&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If you have any question or feedback, please open a thread on the &lt;a href=&#34;https://github.com/totodore/socketioxide/discussions&#34;&gt;discussions&lt;/a&gt; page.&lt;/p&gt; &#xA;&lt;h2&gt;License üîê&lt;/h2&gt; &#xA;&lt;p&gt;This project is licensed under the &lt;a href=&#34;https://raw.githubusercontent.com/Totodore/socketioxide/main/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>