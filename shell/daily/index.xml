<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-08-17T01:36:38Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>EqualExperts/dbt-unit-testing</title>
    <updated>2023-08-17T01:36:38Z</updated>
    <id>tag:github.com,2023-08-17:/EqualExperts/dbt-unit-testing</id>
    <link href="https://github.com/EqualExperts/dbt-unit-testing" rel="alternate"></link>
    <summary type="html">&lt;p&gt;This dbt package contains macros to support unit testing that can be (re)used across dbt projects.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/EqualExperts/dbt-unit-testing/actions/workflows/main.yml&#34;&gt;&lt;img src=&#34;https://github.com/EqualExperts/dbt-unit-testing/actions/workflows/main.yml/badge.svg?sanitize=true&#34; alt=&#34;Dbt Unit Testing&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;!-- omit in toc --&gt; &#xA;&lt;h1&gt;DBT Unit Testing&lt;/h1&gt; &#xA;&lt;p&gt;Dbt Unit Testing is a dbt package that provides support for unit testing in &lt;a href=&#34;https://github.com/dbt-labs/dbt&#34;&gt;dbt&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;You can test models independently by mocking their dependencies (models, sources, snapshots, seeds).&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#more-about-dbt-unit-testing&#34;&gt;More About Dbt Unit Testing&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#purpose&#34;&gt;Purpose&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#sql-first&#34;&gt;SQL First&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#how&#34;&gt;How&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#main-features&#34;&gt;Main Features&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#documentation&#34;&gt;Documentation&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#anatomy-of-a-test&#34;&gt;Anatomy of a test&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#available-macros&#34;&gt;Available Macros&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#test-examples&#34;&gt;Test Examples&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#different-ways-to-build-mock-values&#34;&gt;Different ways to build mock values&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#mocking&#34;&gt;Mocking&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#database-dependencies-in-detail&#34;&gt;Database dependencies in detail&lt;/a&gt;&lt;/li&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#requirement&#34;&gt;Requirement&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#incremental-models&#34;&gt;Incremental Models&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#available-options&#34;&gt;Available Options&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#test-feedback&#34;&gt;Test Feedback&lt;/a&gt; &#xA;    &lt;ul&gt; &#xA;     &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#example&#34;&gt;Example&lt;/a&gt;&lt;/li&gt; &#xA;    &lt;/ul&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#known-limitations&#34;&gt;Known Limitations&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#compatibility&#34;&gt;Compatibility&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#license&#34;&gt;License&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;Add the following to packages.yml&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;packages:&#xA;  - git: &#34;https://github.com/EqualExperts/dbt-unit-testing&#34;&#xA;    revision: v0.3.2&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://docs.getdbt.com/docs/package-management&#34;&gt;read the docs&lt;/a&gt; for more information on installing packages.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: We recommend you to upgrade from 0.1.3. However 0.2.0 introduces breaking changes by removing the mocking strategies (you need to update and use the new options, see &lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#available-options&#34;&gt;Available Options&lt;/a&gt; and release notes).&lt;/p&gt; &#xA;&lt;h1&gt;More About Dbt Unit Testing&lt;/h1&gt; &#xA;&lt;h2&gt;Purpose&lt;/h2&gt; &#xA;&lt;p&gt;Neither the data tests nor the schema tests are suitable to test the models&#39; logic because the intention is to test the data flowing through the models. However, after coding a couple of models, we found the need to have unit tests for models to test the model logic with mocked data. Also, the expected behaviour of unit tests consists of:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Ability to mock dependencies&lt;/li&gt; &#xA; &lt;li&gt;Ability to run each test independently&lt;/li&gt; &#xA; &lt;li&gt;Fast feedback loop&lt;/li&gt; &#xA; &lt;li&gt;Good Test Feedback&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;SQL First&lt;/h2&gt; &#xA;&lt;p&gt;We believe using SQL for the tests is the best approach we can take, with some help from Jinja macros. It could be debatable, but we think using SQL requires less knowledge and a friendlier learning curve.&lt;/p&gt; &#xA;&lt;h2&gt;How&lt;/h2&gt; &#xA;&lt;p&gt;We have a set of Jinja macros that allow you to define your mocks and the test scenario. With your test definition, we generate a big SQL query representing the test and run the query against a dev environment. The tests can run in two different ways:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;without any dependencies of artifacts (models, sources, snapshots). You don&#39;t need models or sources on the dev environment for testing; it just uses the SQL Engine. However, you must mock all the dependencies and all the columns in tests.&lt;/li&gt; &#xA; &lt;li&gt;with dependencies of artifact definition (defined models, sources or snapshots). It means that we can use your model definition to make your test simpler. For instance, if you have a model with 20 columns to mock and just want to mock one, we can grab the missing columns from your model/source definition and save you the work. You also need to have them refreshed to run the tests.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Both strategies have pros and cons. We think you should use the tests without any dependencies till you think it&#39;s unusable and hard to maintain.&lt;/p&gt; &#xA;&lt;h2&gt;Main Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Use mocked inputs on any model, source or snapshot&lt;/li&gt; &#xA; &lt;li&gt;Define mock inputs with SQL or, if you prefer, in a tabular format within the test&lt;/li&gt; &#xA; &lt;li&gt;Run tests without the need to run dbt and install the models into a database.&lt;/li&gt; &#xA; &lt;li&gt;Focus the test on what&#39;s important&lt;/li&gt; &#xA; &lt;li&gt;Provide fast and valuable feedback&lt;/li&gt; &#xA; &lt;li&gt;Write more than one test on a dbt test file&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Documentation&lt;/h1&gt; &#xA;&lt;h2&gt;Anatomy of a test&lt;/h2&gt; &#xA;&lt;p&gt;The test is composed of a test setup (mocks) and expectations:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{{ config(tags=[&#39;unit-test&#39;]) }}&#xA;&#xA;{% call dbt_unit_testing.test (&#39;[Model to Test]&#39;,&#39;[Test Name]&#39;) %}&#xA;  {% call dbt_unit_testing.mock_ref (&#39;[model name]&#39;) %}&#xA;     select ...&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.mock_source(&#39;[source name]&#39;) %}&#xA;    select ...&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select  ...&#xA;  {% endcall %}&#xA;&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first line is boilerplate we can&#39;t avoid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{{ config(tags=[&#39;unit-test&#39;]) }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We leverage the command dbt test to run the unit tests; then, we need a way to isolate the unit tests. The rest of the lines are the test itself, the mocks (test setup) and expectations.&lt;/p&gt; &#xA;&lt;h2&gt;Available Macros&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;macro name&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbt_unit_testing.test&lt;/td&gt; &#xA;   &lt;td&gt;Defines a Test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbt_unit_testing.mock-ref&lt;/td&gt; &#xA;   &lt;td&gt;Mocks a &lt;strong&gt;model&lt;/strong&gt; / &lt;strong&gt;snapshot&lt;/strong&gt; / &lt;strong&gt;seed&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbt_unit_testing.mock-source&lt;/td&gt; &#xA;   &lt;td&gt;Mocks a &lt;strong&gt;source&lt;/strong&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;dbt_unit_testing.expect&lt;/td&gt; &#xA;   &lt;td&gt;Defines Test expectations&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;Test Examples&lt;/h2&gt; &#xA;&lt;p&gt;We&#39;ve created an illustrative test suite for the &lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/jaffle-shop/&#34;&gt;jaffle-shop&lt;/a&gt;. Let&#39;s pick one test to illustrate what we&#39;ve been talking about:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{{ config(tags=[&#39;unit-test&#39;]) }}&#xA;&#xA;{% call dbt_unit_testing.test(&#39;customers&#39;, &#39;should sum order values to calculate customer_lifetime_value&#39;) %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_customers&#39;) %}&#xA;    select 1 as customer_id, &#39;&#39; as first_name, &#39;&#39; as last_name&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_orders&#39;) %}&#xA;    select 1001 as order_id, 1 as customer_id, null as order_date&#xA;    UNION ALL&#xA;    select 1002 as order_id, 1 as customer_id, null as order_date&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_payments&#39;) %}&#xA;    select 1001 as order_id, 10 as amount&#xA;    UNION ALL&#xA;    select 1002 as order_id, 10 as amount&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 1 as customer_id, 20 as customer_lifetime_value&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Looking at the first macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;customers&#39;, &#39;should sum order values to calculate customer_lifetime_value&#39;) %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;You can see that the test is about the &#39;customers&#39; model, and the test description means that it tests the calculation of the customer_lifetime_value. The model customers has three dependencies:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&#39;stg_customers&#39;&lt;/li&gt; &#xA; &lt;li&gt;&#39;stg_orders&#39;&lt;/li&gt; &#xA; &lt;li&gt;&#39;stg_payments&#39;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Then the test setup consists of 3 mocks.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;&#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_customers&#39;) %}&#xA;    select 1 as customer_id, &#39;&#39; as first_name, &#39;&#39; as last_name&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_orders&#39;) %}&#xA;    select 1001 as order_id, 1 as customer_id, null as order_date&#xA;    UNION ALL&#xA;    select 1002 as order_id, 1 as customer_id, null as order_date&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_payments&#39;) %}&#xA;    select 1001 as order_id, 10 as amount&#xA;    UNION ALL&#xA;    select 1002 as order_id, 10 as amount&#xA;  {% endcall %}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It creates a scenario with a single user with two orders and two payments that we use to ensure the calculation is correct with the following expectation:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 1 as customer_id, 20 as customer_lifetime_value&#xA;  {% endcall %}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And that&#39;s the test decomposed by the main parts. In detail, you can look at our test examples &lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/jaffle-shop/tests/unit/tests.sql&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Different ways to build mock values&lt;/h2&gt; &#xA;&lt;p&gt;Instead of using standard SQL to define your input values, you can use a tabular format like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;customers&#39;, &#39;should sum order values to calculate customer_lifetime_value&#39;) %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_customers&#39;, {&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    customer_id, first_name, last_name&#xA;    1,&#39;&#39;,&#39;&#39;&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_orders&#39;, {&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    order_id,customer_id,order_date&#xA;    1001,1,null&#xA;    1002,1,null&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_payments&#39;, {&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    order_id,amount&#xA;    1001,10&#xA;    1002,10&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.expect({&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    customer_id,customer_lifetime_value&#xA;    1,20&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;All the unit testing macros (&lt;strong&gt;&lt;code&gt;mock_ref&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;mock_source&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;expect&lt;/code&gt;&lt;/strong&gt;) accept an &lt;code&gt;options&lt;/code&gt; parameter :&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;input_format&lt;/code&gt;: &#34;sql&#34; or &#34;csv&#34; (default = &#34;sql&#34;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;column_separator&lt;/code&gt; (default = &#34;,&#34;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;type_separator&lt;/code&gt; (default = &#34;::&#34;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;line_separator&lt;/code&gt; (default = &#34;\n&#34;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;(the last three options are used only for &lt;code&gt;csv&lt;/code&gt; format)&lt;/p&gt; &#xA;&lt;p&gt;These defaults can also be changed project-wise, in the vars section of your &lt;code&gt;dbt_project.yml&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;vars:&#xA;  unit_tests_config:&#xA;    input_format: &#34;csv&#34;&#xA;    column_separator: &#34;|&#34;&#xA;    line_separator: &#34;\n&#34;&#xA;    type_separator: &#34;::&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;With the above configuration, you could write your tests like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;customers&#39;, &#39;should sum order values to calculate customer_lifetime_value&#39;) %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_customers&#39;, {&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    customer_id | first_name | last_name&#xA;    1           | &#39;&#39;         | &#39;&#39;&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_orders&#39;, {&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    order_id | customer_id | order_date &#xA;    1        | 1           | null&#xA;    2        | 1           | null&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_payments&#39;, {&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    order_id | amount&#xA;    1        | 10&#xA;    2        | 10&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.expect({&#34;input_format&#34;: &#34;csv&#34;}) %}&#xA;    customer_id | customer_lifetime_value&#xA;    1           | 20&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Mocking&lt;/h2&gt; &#xA;&lt;p&gt;Mocks can be completely independent of the dev/test environment if you set up all the required dependencies (it&#39;s explained here &lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#how&#34;&gt;How&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Let&#39;s take a look into another &lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/jaffle-shop/&#34;&gt;jaffle-shop&lt;/a&gt; example, an almost dumb test, but it illustrates well:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;customers&#39;, &#39;should show customer_id without orders&#39;) %}&#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_customers&#39;) %}&#xA;    select 1 as customer_id, &#39;&#39; as first_name, &#39;&#39; as last_name&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_orders&#39;) %}&#xA;    select null::numeric as customer_id, null::numeric as order_id, null as order_date  &#xA;    where false&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_payments&#39;) %}&#xA;     select null::numeric as order_id, null::numeric as amount &#xA;     where false&#xA;  {% endcall %}&#xA;  &#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 1 as customer_id&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It tests the customer_id that comes from the stg_customers, but the setup contains other details that enable the test to run without any dependencies on existing models/sources.&lt;/p&gt; &#xA;&lt;p&gt;As mentioned, there&#39;s a possibility to improve the test setup. You can use the option &lt;strong&gt;&#39;include_missing_columns&#39;&lt;/strong&gt; in the mocks:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% set options = {&#34;include_missing_columns&#34;: true} %}&#xA;&#xA;{% call dbt_unit_testing.test(&#39;customers&#39;, &#39;should show customer_id without orders&#39;) %}&#xA;  &#xA;  {% call dbt_unit_testing.mock_ref (&#39;stg_customers&#39;, options) %}&#xA;    select 1 as customer_id&#xA;  {% endcall %}&#xA;&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 1 as customer_id&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Much simpler to read and maintain, but there&#39;s a cost! You need the &lt;strong&gt;sources&lt;/strong&gt; defined and updated in your test/dev env.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;&#39;include_missing_columns&#39;&lt;/strong&gt; inspects your models and sources to calculate what columns are missing in each mock. When a mock is missing, the framework infers the mock from the models and sources, if they exist.&lt;/p&gt; &#xA;&lt;p&gt;Each approach has pros and cons, so it&#39;s up to you to decide if you want to depend on the underlying table definitions.&lt;/p&gt; &#xA;&lt;h3&gt;Database dependencies in detail&lt;/h3&gt; &#xA;&lt;p&gt;The framework infers the missing columns and missing mocks by building the SQL of the underlying models recursively, down to the sources. This SQL can be a pretty complex query; sometimes, it&#39;s non-performant or even a blocker.&lt;/p&gt; &#xA;&lt;p&gt;You can use the option &lt;strong&gt;&#39;use-database-models&#39;&lt;/strong&gt; to avoid the recursive inspection and use the model defined in the database. Be aware that this makes a new dependency on the underlying model definition, and it needs to be updated each time you run a test.&lt;/p&gt; &#xA;&lt;h3&gt;Requirement&lt;/h3&gt; &#xA;&lt;p&gt;To be able to mock the models and sources in tests, in your dbt models you &lt;strong&gt;must&lt;/strong&gt; use the macros &lt;strong&gt;dbt_unit_testing.ref&lt;/strong&gt; and &lt;strong&gt;dbt_unit_testing.source&lt;/strong&gt;, for example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;&#xA;    select * from {{ dbt_unit_testing.ref(&#39;stg_customers&#39;) }}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternatively, if you prefer to keep using the standard &lt;code&gt;ref&lt;/code&gt; macro in the models, you can add these macros to your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% macro ref() %}&#xA;   {{ return(dbt_unit_testing.ref(*varargs, **kwargs)) }}&#xA;{% endmacro %}&#xA;&#xA;{% macro source() %}&#xA;   {{ return(dbt_unit_testing.source(*varargs, **kwargs)) }}&#xA;{% endmacro %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you need to use the original dbt &lt;em&gt;ref&lt;/em&gt; macro for some reason (in &lt;em&gt;dbt_utils.star&lt;/em&gt; macro, for instance), you can use &lt;em&gt;builtins.ref&lt;/em&gt;, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;select {{ dbt_utils.star(builtins.ref(&#39;some_model&#39;)) }}&#xA;from {{ ref(&#39;some_model&#39;) }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Model versions&lt;/h2&gt; &#xA;&lt;p&gt;You can specify a model version on the &lt;code&gt;dbt_unit_testing.ref&lt;/code&gt; macro, the same way you do on the dbt ref macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.ref(&#39;some_model&#39;, version=3) %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.ref(&#39;some_model&#39;, v=3) %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;if you are overriding the ref and source macros in your project, please use the new way of doing it (&lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/#requirement&#34;&gt;here&lt;/a&gt;). This is necessary for the version parameter to work:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% macro ref() %}&#xA;   {{ return(dbt_unit_testing.ref(*varargs, **kwargs)) }}&#xA;{% endmacro %}&#xA;&#xA;{% macro source() %}&#xA;   {{ return(dbt_unit_testing.source(*varargs, **kwargs)) }}&#xA;{% endmacro %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Testing Model versions&lt;/h3&gt; &#xA;&lt;p&gt;You can test a specific model version by specifying the &lt;code&gt;version&lt;/code&gt; parameter on the &lt;code&gt;dbt_unit_testing.test&lt;/code&gt; macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;some_model&#39;, &#39;should return 1&#39;, version=3) %}&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 1&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;version&lt;/code&gt; is not specified, the test will run against the latest version of the model.&lt;/p&gt; &#xA;&lt;p&gt;It is also possible to mock a specific model version, again by specifying the &lt;code&gt;version&lt;/code&gt; parameter on the &lt;code&gt;dbt_unit_testing.mock_ref&lt;/code&gt; macro:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.mock_ref(&#39;some_model&#39;, version=3) %}&#xA;  select 1&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If &lt;code&gt;version&lt;/code&gt; is not specified, the latest version of the model will be mocked.&lt;/p&gt; &#xA;&lt;h2&gt;Incremental models&lt;/h2&gt; &#xA;&lt;p&gt;You can write unit tests for incremental models. To enable this functionality, you should add the following code to your project:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% macro is_incremental() %}&#xA;  {{ return (dbt_unit_testing.is_incremental()) }}&#xA;{% endmacro %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Here&#39;s an example of how you can test a model using this approach.&lt;/p&gt; &#xA;&lt;p&gt;Consider the following model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{{ config (materialized = &#39;incremental&#39; ) }}&#xA;&#xA;select c from {{ dbt_unit_testing.ref(&#39;some_model&#39;) }}&#xA;&#xA;{% if is_incremental() %}&#xA;  where c &amp;gt; (select max(c) from {{ this }})&#xA;{% endif %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When writing a test for this model, it will simulate the model running in &lt;code&gt;full-refresh&lt;/code&gt; mode, without the &lt;code&gt;is_incremental&lt;/code&gt; section:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;incremental_model&#39;, &#39;full refresh test&#39;) %}&#xA;  {% call dbt_unit_testing.mock_ref (&#39;model_for_incremental&#39;) %}&#xA;    select 10 as c&#xA;    UNION ALL&#xA;    select 20 as c&#xA;    UNION ALL&#xA;    select 30 as c&#xA;  {% endcall %}&#xA;  {% call dbt_unit_testing.mock_ref (&#39;incremental_model&#39;) %}&#xA;    select 15 as c&#xA;    UNION ALL&#xA;    select 25 as c&#xA;  {% endcall %}&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 10 as c&#xA;    UNION ALL&#xA;    select 20 as c&#xA;    UNION ALL&#xA;    select 30 as c&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As you can observe, the existing rows for the incremental_model were deleted, and the model performed a &lt;code&gt;full-refresh&lt;/code&gt; operation, which is reflected in the expectations.&lt;/p&gt; &#xA;&lt;p&gt;To test the &lt;code&gt;is_incremental&lt;/code&gt; section of your model, you must include the option {&#34;run_as_incremental&#34;: &#34;True&#34;} in your test. Here&#39;s an example using the above model:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;incremental_model&#39;, &#39;incremental test&#39;, options={&#34;run_as_incremental&#34;: &#34;True&#34;}) %}&#xA;  {% call dbt_unit_testing.mock_ref (&#39;some_model&#39;) %}&#xA;    select 10 as c&#xA;    UNION ALL&#xA;    select 20 as c&#xA;    UNION ALL&#xA;    select 30 as c&#xA;  {% endcall %}&#xA;  {% call dbt_unit_testing.mock_ref (&#39;incremental_model&#39;) %}&#xA;    select 10 as c&#xA;  {% endcall %}&#xA;  {% call dbt_unit_testing.expect() %}&#xA;    select 20 as c&#xA;    UNION ALL&#xA;    select 30 as c&#xA;  {% endcall %}&#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in this case, we are also mocking the model being tested (&lt;code&gt;incremental_model&lt;/code&gt;) to ensure the incremental logic functions correctly. It is necessary to mock the model itself when writing a test for the &lt;code&gt;is_incremental&lt;/code&gt; part of the model.&lt;/p&gt; &#xA;&lt;h2&gt;Available Options&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;option&lt;/th&gt; &#xA;   &lt;th&gt;description&lt;/th&gt; &#xA;   &lt;th&gt;default&lt;/th&gt; &#xA;   &lt;th&gt;scope*&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;include_missing_columns&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use the definition of the model to grab the columns not specified in a mock. The columns will be added automatically with &lt;em&gt;null&lt;/em&gt; values (this option will increase the number of roundtrips to the database when running the test).&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;project/test/mock&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;use_database_models&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use the models in the database instead of the model SQL. &lt;br&gt; This option is used to simplify the final test query if needed&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;project/test/mock&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;input_format&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;strong&gt;sql&lt;/strong&gt;: use &lt;em&gt;SELECT&lt;/em&gt; statements to define the mock values. &lt;br&gt; &lt;br&gt; &lt;em&gt;SELECT 10::int as c1, 20 as c2 &lt;br&gt; UNION ALL &lt;br&gt; SELECT 30::int as c1, 40 as c2&lt;/em&gt; &lt;br&gt; &lt;br&gt; &lt;strong&gt;csv&lt;/strong&gt;: Use tabular form to specify mock values. &lt;br&gt; &lt;br&gt; c1::int | c2 &lt;br&gt; 10 | 20 &lt;br&gt; 30 | 40&lt;/td&gt; &#xA;   &lt;td&gt;sql&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;column_separator&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Defines the column separator for csv format&lt;/td&gt; &#xA;   &lt;td&gt;,&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;line_separator&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Defines the line separator for csv format&lt;/td&gt; &#xA;   &lt;td&gt;\n&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;type_separator&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Defines the type separator for csv format&lt;/td&gt; &#xA;   &lt;td&gt;::&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;use_qualified_sources&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Use qualified names (source_name + table_name) for sources when building the CTEs for the test query. It allows you to have source models with the same name in different sources/schema.&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;disable_cache&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Disable cache&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;project&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;diff_column&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The name of the &lt;code&gt;diff&lt;/code&gt; column in the test report&lt;/td&gt; &#xA;   &lt;td&gt;diff&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;count_column&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;The name of the &lt;code&gt;count&lt;/code&gt; column in the test report&lt;/td&gt; &#xA;   &lt;td&gt;count&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;strong&gt;run_as_incremental&lt;/strong&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Runs the model in &lt;code&gt;incremental&lt;/code&gt; mode (it has no effect if the model is not incremental)&lt;/td&gt; &#xA;   &lt;td&gt;false&lt;/td&gt; &#xA;   &lt;td&gt;project/test&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Notes:&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;   &lt;td&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;scope&lt;/strong&gt; is the place where the option can be defined: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;if the scope is project you can define the option as a global setting in the project.yml&lt;/li&gt; &#xA;   &lt;li&gt;if the scope is test you can define/override the option at the test level&lt;/li&gt; &#xA;   &lt;li&gt;if the scope is mock you can define/override the option at the mock level&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;Qualified sources&lt;/strong&gt; You must use an alias when referencing sources if you use this option.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Test Feedback&lt;/h2&gt; &#xA;&lt;p&gt;Good test feedback is what allows us to be productive when developing unit tests and developing our models. The test macro provides visual feedback when a test fails, showing what went wrong by comparing the lines of the expectations with the actuals. To make the feedback even more readable, you can provide &lt;code&gt;output_sort_field&lt;/code&gt; in parameters specifying the field to sort by:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;{% call dbt_unit_testing.test(&#39;some_model&#39;, &#39;smoke test&#39;, {&#34;output_sort_field&#34;: &#34;business_id&#34;}) %}&#xA;&#xA;  ...&#xA;  &#xA;{% endcall %}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The result will be displayed the way to compare two adjacent lines conveniently.&lt;/p&gt; &#xA;&lt;h3&gt;Example&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;MODEL: customers&#xA;TEST:  should sum order values to calculate customer_lifetime_value&#xA;Rows mismatch:&#xA;| diff | count | customer_id | customer_lifetime_value |&#xA;| ---- | ----- | ----------- | ----------------------- |&#xA;| +    |     1 |           1 |                      20 |&#xA;| -    |     1 |           1 |                      30 |&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first line was not on the model, but the second line was.&lt;/p&gt; &#xA;&lt;h1&gt;Known Limitations&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;You can not have a &lt;em&gt;model&lt;/em&gt; with the same name as a &lt;em&gt;source&lt;/em&gt; or a &lt;em&gt;seed&lt;/em&gt; (unless you set the &lt;em&gt;use_qualified_sources&lt;/em&gt; option to &lt;em&gt;true&lt;/em&gt;).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;With our current approach, there&#39;s an extra step that you need to take if you want to use the builtins &lt;em&gt;ref&lt;/em&gt; or &lt;em&gt;source&lt;/em&gt; macros in your models (in &lt;em&gt;dbt_utils.star&lt;/em&gt;, for instance). Otherwise, you&#39;ll get an error like this one:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;Compilation Error in test some_model_test (tests/unit/some_model_test.sql)&#xA;    dbt was unable to infer all dependencies for the model &#34;some_model_test&#34;.&#xA;    This typically happens when ref() is placed within a conditional block.&#xA;    &#xA;    To fix this, add the following hint to the top of the model &#34;some_model_test&#34;:&#xA;    &#xA;    -- depends_on: {{ ref(&#39;some_model&#39;) }}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this situation, you need to add this line to the top of your &lt;strong&gt;test&lt;/strong&gt; (&lt;strong&gt;not the model!&lt;/strong&gt;):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-jinja&#34;&gt;-- depends_on: {{ ref(&#39;some_model&#39;) }}&#xA;{{&#xA;    config(&#xA;        tags=[&#39;unit-test&#39;]&#xA;    )&#xA;}}&#xA;&#xA;{% call dbt_unit_testing.test(&#39;model_being_tested&#39;, &#39;sample test&#39;) %}&#xA;&#xA;... ... ... ... ... &#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h1&gt;Compatibility&lt;/h1&gt; &#xA;&lt;p&gt;[x] dbt &amp;gt; 0.20&lt;/p&gt; &#xA;&lt;p&gt;[x] BigQuery&lt;/p&gt; &#xA;&lt;p&gt;[x] Snowflake&lt;/p&gt; &#xA;&lt;p&gt;[x] Postgres&lt;/p&gt; &#xA;&lt;p&gt;[ ] Redshift&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;This project is &lt;a href=&#34;https://raw.githubusercontent.com/EqualExperts/dbt-unit-testing/master/LICENSE&#34;&gt;licensed&lt;/a&gt; under the &lt;a href=&#34;https://mit-license.org/&#34;&gt;MIT License&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>