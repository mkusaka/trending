<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-02-03T01:46:23Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>Mrmineduce21/Oracle_OneKey_Active</title>
    <updated>2023-02-03T01:46:23Z</updated>
    <id>tag:github.com,2023-02-03:/Mrmineduce21/Oracle_OneKey_Active</id>
    <link href="https://github.com/Mrmineduce21/Oracle_OneKey_Active" rel="alternate"></link>
    <summary type="html">&lt;p&gt;为了应对甲骨文最新回收机制而作的垃圾脚本&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Oracle_OneKey_Active&lt;/h1&gt; &#xA;&lt;p&gt;为了应对甲骨文最新回收机制而作的垃圾脚本&lt;/p&gt; &#xA;&lt;p&gt;说在前面： 由于甲骨文目前对不活跃机器实行回收，本脚本的作用就是 通过下载文件，上传，cpu跑分让甲骨文以为你是&#34;活跃用户&#34; 脚本仅做辅助，无法保证不被删机&lt;/p&gt; &#xA;&lt;p&gt;转载请标明原出处&lt;/p&gt; &#xA;&lt;p&gt;以下三个脚本都是执行后 在后台静默运行，脚本不会开机自启动，请重启后手动运行脚本&lt;/p&gt; &#xA;&lt;p&gt;----============================ C P U ===============================----&lt;/p&gt; &#xA;&lt;p&gt;OneKeyFuck_OCPU.sh&lt;/p&gt; &#xA;&lt;p&gt;一键吃掉CPU（可精准控制）【OracleLinux不可用】&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO OneKeyFuck_OCPU.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/OneKeyFuck_OCPU.sh &amp;amp;&amp;amp; chmod +x OneKeyFuck_OCPU.sh &amp;amp;&amp;amp; bash OneKeyFuck_OCPU.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;释放CPU资源&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;pid=$(ps -ef | grep &#34;bash&#34; | grep &#39;/bin/bash&#39; | grep -v grep | awk &#39;{print $2}&#39;) &amp;amp;&amp;amp; kill -9 $pid&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;当ssh终端出现 nohup: appending output to &#39;nohup.out&#39; 时按回车即可&lt;/p&gt; &#xA;&lt;p&gt;============================================================&lt;/p&gt; &#xA;&lt;p&gt;cpu_usage.sh(无法做到精确控制占用)&lt;/p&gt; &#xA;&lt;p&gt;使用之前使用命令先查询下cpu的个数&lt;/p&gt; &#xA;&lt;p&gt;cat /proc/cpuinfo | grep “processor”|wc -l&lt;/p&gt; &#xA;&lt;p&gt;或 grep processor /proc/cpuinfo |wc -l&lt;/p&gt; &#xA;&lt;p&gt;一键吃掉1核心&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO cpu_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/cpu_usage.sh &amp;amp;&amp;amp; chmod +x cpu_usage.sh &amp;amp;&amp;amp; bash cpu_usage.sh consume 1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;取消CPU消耗&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO cpu_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/cpu_usage.sh &amp;amp;&amp;amp; chmod +x cpu_usage.sh &amp;amp;&amp;amp; bash cpu_usage.sh release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;需要构造消耗2颗cpu的资源运行脚本sh cpu_usage.sh consume 2，此时运行top命令查看cpu的使用率。如果要释放cpu资源 运行sh cpu_usage.sh release即可释放cpu资源。&lt;/p&gt; &#xA;&lt;p&gt;============================================================&lt;/p&gt; &#xA;&lt;p&gt;Fuck_OCPU.sh（第一个脚本的手动版本）&lt;/p&gt; &#xA;&lt;p&gt;运行方法 bash Fuck_OCPU.sh &#xA; &lt;cores&gt;&lt;/cores&gt;&lt;/p&gt; &#xA;&lt;p&gt;需要自行安装CPUlimit&lt;/p&gt; &#xA;&lt;p&gt;----=================== M e m o r y =========================----&lt;/p&gt; &#xA;&lt;p&gt;OneKey_FuckMemory.sh 脚本将自动获取系统可用内存的10%（不满1G按1G算） 并消耗掉这部分内存 警告：Amd服务器（内存小于2G）请勿使用此脚本，对此照成的封号，机器失联，卡死等问题作者概不负责&lt;/p&gt; &#xA;&lt;p&gt;真--一键吃内存&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO OneKey_FuckMemory.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/OneKey_FuckMemory.sh &amp;amp;&amp;amp; chmod +x OneKey_FuckMemory.sh &amp;amp;&amp;amp; bash OneKey_FuckMemory.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;取消内存消耗(释放内存)&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO memory_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/memory_usage.sh &amp;amp;&amp;amp; chmod +x memory_usage.sh &amp;amp;&amp;amp; bash memory_usage.sh release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;============================================================&lt;/p&gt; &#xA;&lt;p&gt;memory_usage.sh 使用方法： 需要root 权限 启动&lt;/p&gt; &#xA;&lt;p&gt;bash memory_usage.sh consume 内存大小&lt;/p&gt; &#xA;&lt;p&gt;eg : bash memory_usage.sh consume 1G 即消耗1G 的内存&lt;/p&gt; &#xA;&lt;p&gt;一键吃内存（100MB）&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO memory_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/memory_usage.sh &amp;amp;&amp;amp; chmod +x memory_usage.sh &amp;amp;&amp;amp; bash memory_usage.sh consume 100M&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;一键吃内存（2G）&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO memory_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/memory_usage.sh &amp;amp;&amp;amp; chmod +x memory_usage.sh &amp;amp;&amp;amp; bash memory_usage.sh consume 2G&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;一键吃内存（20G）[适用于24G内存]&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO memory_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/memory_usage.sh &amp;amp;&amp;amp; chmod +x memory_usage.sh &amp;amp;&amp;amp; bash memory_usage.sh consume 20G&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;取消内存消耗&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO memory_usage.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/memory_usage.sh &amp;amp;&amp;amp; chmod +x memory_usage.sh &amp;amp;&amp;amp; bash memory_usage.sh release&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;----================== N E T W O R K =======================----&lt;/p&gt; &#xA;&lt;p&gt;FuckNetWork.sh&lt;/p&gt; &#xA;&lt;p&gt;原理：每间隔二十分钟下载一次大小为1G的 VULTR 测速文件（限速10MB/S） 下次下载开始前将会删除上次下载的文件&lt;/p&gt; &#xA;&lt;p&gt;一键浪费网络&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;cd /root &amp;amp;&amp;amp; wget -qO FuckNetWork.sh https://raw.githubusercontent.com/Mrmineduce21/Oracle_OneKey_Active/main/FuckNetWork.sh &amp;amp;&amp;amp; chmod +x FuckNetWork.sh &amp;amp;&amp;amp; nohup ./FuckNetWork.sh &amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;停止运行&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;FNpid=$(ps -ef | grep &#34;FuckNetWork.sh&#34; | grep &#39;/bin/bash&#39; | grep -v grep | awk &#39;{print $2}&#39;) &amp;amp;&amp;amp; kill -9 $FNpid &amp;amp;&amp;amp; rm -f /root/nohup.out&#xA;&lt;/code&gt;&lt;/pre&gt;</summary>
  </entry>
  <entry>
    <title>elementary/os</title>
    <updated>2023-02-03T01:46:23Z</updated>
    <id>tag:github.com,2023-02-03:/elementary/os</id>
    <link href="https://github.com/elementary/os" rel="alternate"></link>
    <summary type="html">&lt;p&gt;The OS build system&lt;/p&gt;&lt;hr&gt;&lt;div align=&#34;center&#34;&gt; &#xA; &lt;a href=&#34;https://elementary.io&#34; align=&#34;center&#34;&gt; &#xA;  &lt;center align=&#34;center&#34;&gt; &#xA;   &lt;picture&gt; &#xA;    &lt;source media=&#34;(prefers-color-scheme: dark)&#34; srcset=&#34;https://raw.githubusercontent.com/elementary/brand/master/logomark-white.png&#34;&gt; &#xA;    &lt;source media=&#34;(prefers-color-scheme: light)&#34; srcset=&#34;https://raw.githubusercontent.com/elementary/brand/master/logomark-black.png&#34;&gt; &#xA;    &lt;img src=&#34;https://raw.githubusercontent.com/elementary/brand/master/logomark-black.png&#34; alt=&#34;elementary&#34; align=&#34;center&#34; height=&#34;200&#34;&gt; &#xA;   &lt;/picture&gt; &#xA;  &lt;/center&gt; &lt;/a&gt; &#xA; &lt;br&gt; &#xA; &lt;h1 align=&#34;center&#34;&gt;&#xA;  &lt;center&gt;&#xA;   elementary OS&#xA;  &lt;/center&gt;&lt;/h1&gt; &#xA; &lt;h3 align=&#34;center&#34;&gt;&#xA;  &lt;center&gt;&#xA;   Build scripts for image creation&#xA;  &lt;/center&gt;&lt;/h3&gt; &#xA; &lt;br&gt; &#xA; &lt;br&gt; &#xA;&lt;/div&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://github.com/elementary/os/workflows/stable/badge.svg?sanitize=true&#34; alt=&#34;Stable&#34;&gt; &lt;img src=&#34;https://github.com/elementary/os/actions/workflows/daily-7.0.yml/badge.svg?sanitize=true&#34; alt=&#34;Daily 7.0&#34;&gt; &lt;img src=&#34;https://github.com/elementary/os/actions/workflows/daily-6.1-arm.yml/badge.svg?sanitize=true&#34; alt=&#34;Daily 7.0&#34;&gt; &lt;/p&gt; &#xA;&lt;hr&gt; &#xA;&lt;h2&gt;Building Locally&lt;/h2&gt; &#xA;&lt;p&gt;As elementary OS is built with the Debian version of &lt;code&gt;live-build&lt;/code&gt;, not the Ubuntu patched version, it&#39;s easiest to build an elementary .iso in a Debian VM or container. This prevents messing up your host system too.&lt;/p&gt; &#xA;&lt;p&gt;The following examples assume you have Docker correctly installed and set up, and that your current working directory is this repo. When done, your image will be in the &lt;code&gt;builds&lt;/code&gt; folder.&lt;/p&gt; &#xA;&lt;h3&gt;64-bit AMD/Intel&lt;/h3&gt; &#xA;&lt;p&gt;Configure the channel in the &lt;code&gt;etc/terraform.conf&lt;/code&gt; (stable, daily), then run:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --privileged -i -v /proc:/proc \&#xA;    -v ${PWD}:/working_dir \&#xA;    -w /working_dir \&#xA;    debian:latest \&#xA;    /bin/bash -s etc/terraform.conf &amp;lt; build.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Raspberry Pi 4&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --privileged -i -v /proc:/proc \&#xA;    -v ${PWD}:/working_dir \&#xA;    -w /working_dir \&#xA;    ubuntu:20.04 \&#xA;    ./build-rpi.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Pinebook Pro&lt;/h3&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --privileged -i -v /proc:/proc \&#xA;    -v ${PWD}:/working_dir \&#xA;    -w /working_dir \&#xA;    ubuntu:20.04 \&#xA;    ./build-pinebookpro.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Further Information&lt;/h2&gt; &#xA;&lt;p&gt;More information about the concepts behind &lt;code&gt;live-build&lt;/code&gt; and the technical decisions made to arrive at this set of tools to build an .iso can be found &lt;a href=&#34;https://github.com/elementary/os/wiki/Building-iso-Images&#34;&gt;on the wiki&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>