<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-28T01:48:56Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>blackhatethicalhacking/SSRFPwned</title>
    <updated>2023-06-28T01:48:56Z</updated>
    <id>tag:github.com,2023-06-28:/blackhatethicalhacking/SSRFPwned</id>
    <link href="https://github.com/blackhatethicalhacking/SSRFPwned" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Checks for SSRF using built-in custom Payloads after fetching URLs from Multiple Passive Sources &amp; applying complex patterns aimed at SSRF&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;BHEH&#39;s SSRFPwned&lt;/h1&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;a href=&#34;https://www.blackhatethicalhacking.com&#34;&gt;&lt;img src=&#34;https://www.blackhatethicalhacking.com/wp-content/uploads/2022/06/BHEH_logo.png&#34; width=&#34;300px&#34; alt=&#34;BHEH&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; SSRFPwned is written by Chris &#34;SaintDruG&#34; Abou-Chabké from Black Hat Ethical Hacking and is designed for Offensive Security attacks. &lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://camo.githubusercontent.com/82291b0fe831bfc6781e07fc5090cbd0a8b912bb8b8d4fec0696c881834f81ac/68747470733a2f2f70726f626f742e6d656469612f394575424971676170492e676966&#34; width=&#34;350&#34; height=&#34;1&#34;&gt; &lt;/p&gt; &#xA;&lt;h2 align=&#34;center&#34;&gt;&lt;u&gt;Black Hat Ethical Hacking&lt;/u&gt; &lt;p&gt;&lt;img src=&#34;https://github-profile-summary-cards.vercel.app/api/cards/profile-details?username=blackhatethicalhacking&amp;amp;theme=monokai&#34; alt=&#34;summary&#34;&gt;&lt;/p&gt; &lt;p align=&#34;center&#34;&gt; &lt;a align=&#34;center&#34; href=&#34;https://github.com/blackhatethicalhacking&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Github-blackhatethicalhacking-green?style=for-the-badge&amp;amp;logo=github&#34;&gt;&lt;/a&gt; &lt;/p&gt; &#xA; &lt;!--&#xA;**blackhatethicalhacking** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.&#xA;&#xA;Here are some ideas to get you started:&#xA;&#xA;- 🔭 I’m currently working on ...&#xA;- 🌱 I’m currently learning ...&#xA;- 👯 I’m looking to collaborate on ...&#xA;- 🤔 I’m looking for help with ...&#xA;- 💬 Ask me about ...&#xA;- 📫 How to reach me: ...&#xA;- 😄 Pronouns: ...&#xA;- ⚡ Fun fact: ...&#xA;--&gt; &lt;/h2&gt;&#xA;&lt;h1&gt;Description&lt;/h1&gt; &#xA;&lt;p&gt;SSRFPwned is a Penetration Testing and Bug Bounty Offensive Security Tool that automates the process of testing for Server Side Request Forgery (SSRF) vulnerabilities. SSRF is a type of vulnerability that allows attackers to make unauthorized requests to the internal resources of a server by manipulating user-supplied input. SSRFPwned automates the testing of thousands of URLs to identify potential SSRF vulnerabilities. It does this by injecting payloads into the query parameters of each URL and checking the response code to determine if a vulnerability exists. The Payloads are custom ones with multiple attack vectors, and you could also add more wordlists in case you want to even test for more, as it will copy the wordlist, merge them then start the attack.&lt;/p&gt; &#xA;&lt;h1&gt;What Makes SSRFPwned Unique:&lt;/h1&gt; &#xA;&lt;p&gt;SSRFPwned is unique because it combines multiple sources for URL discovery, including the Wayback Machine, URLScan, and AlienVault. The tool is also highly customizable, allowing users to add their own payloads for testing specific types of SSRF vulnerabilities. Additionally, the tool is designed to be efficient and scalable, allowing users to test thousands of URLs at once. It is also special because of the way it filters the URLs based on using GF to specifically filter out with Regex only the ones that match the SSRF Pattern, but also cleaning the parameters from values so it can then inject it there. The way it checks also if it is vulnerable or not, checks also for reflected traces of the payload in the response and if it has 200 codes to give the result.&lt;/p&gt; &#xA;&lt;p&gt;It is also Special well because you will:&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/13942386/222453411-18efb5a7-6546-4ed0-8bed-5eb6431597bc.gif&#34; alt=&#34;giphy&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;The Flow &amp;amp; Methodology&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Discovery - The tool begins by discovering URLs to test for SSRF vulnerabilities. It does this by using multiple sources including Wayback Machine, AlienVault, and URLScan.&lt;/li&gt; &#xA; &lt;li&gt;Filtering - The tool filters out URLs that are not relevant for testing SSRF vulnerabilities, such as image files or CSS files.&lt;/li&gt; &#xA; &lt;li&gt;It also greps using GF the patterns with Regex that matches the SSRF model and cleans the values of the parameters.&lt;/li&gt; &#xA; &lt;li&gt;Payload Injection - The tool then injects a variety of custom payloads into the query parameters of each URL. The payloads are designed to test for specific types of SSRF vulnerabilities.&lt;/li&gt; &#xA; &lt;li&gt;Testing - The tool tests each URL and payload combination by sending a request to the URL with the injected payload. It then checks the response code to determine if a vulnerability exists.&lt;/li&gt; &#xA; &lt;li&gt;Reporting - The tool generates a report of vulnerable URLs and the payloads that were successful in exploiting the vulnerability.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Features:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Automatic testing of thousands of URLs for SSRF vulnerabilities&lt;/li&gt; &#xA; &lt;li&gt;Supports multiple sources for URL discovery&lt;/li&gt; &#xA; &lt;li&gt;Automatic payload injection into query parameters of each URL&lt;/li&gt; &#xA; &lt;li&gt;Customizable payload list for testing specific types of SSRF vulnerabilities&lt;/li&gt; &#xA; &lt;li&gt;Supports HTTP and HTTPS protocols&lt;/li&gt; &#xA; &lt;li&gt;Provides detailed output including vulnerable URLs and payload used&lt;/li&gt; &#xA; &lt;li&gt;Saves results in an easily readable format for further analysis&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Expansion&lt;/h1&gt; &#xA;&lt;p&gt;Feel free to expand more Pocs, and integrate it, the idea is speed, and sending 1 curl, send a push!&lt;/p&gt; &#xA;&lt;h1&gt;Requirements:&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;waybackurls: This tool can be installed by running &lt;code&gt;go install github.com/tomnomnom/waybackurls@latest&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;cURL: This tool is commonly pre-installed on Kali Linux and Ubuntu, but can be installed by running &lt;code&gt;apt-get install curl&lt;/code&gt; on Ubuntu or &lt;code&gt;brew install curl&lt;/code&gt; on MacOS&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;httpx: is a fast and multi-purpose HTTP toolkit that allows running multiple probes using the retryable HTTP library. To install it: &lt;code&gt;go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;lolcat: &lt;code&gt;pip install lolcat&lt;/code&gt; for rainbow beauty&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;gf: &lt;code&gt;go install -v github.com/tomnomnom/gf@latest&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;Installation&lt;/h1&gt; &#xA;&lt;p&gt;&lt;code&gt;git clone https://github.com/blackhatethicalhacking/SSRFPwned.git&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;cd SSRFPwned&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;chmod +x SSRFPwned.sh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;./SSRFPwned.sh&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Screenshot&lt;/h1&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/blackhatethicalhacking/SSRFPwned/assets/13942386/e7bcbfa9-2420-48a3-976f-b49c23050f7b&#34; alt=&#34;Screenshot 2023-06-22 at 9 59 56 PM&#34;&gt;&lt;/p&gt; &#xA;&lt;h1&gt;Compatibility:&lt;/h1&gt; &#xA;&lt;p&gt;This tool has been tested on Kali Linux, Ubuntu, and MacOS.&lt;/p&gt; &#xA;&lt;h1&gt;Disclaimer&lt;/h1&gt; &#xA;&lt;p&gt;This tool is provided for educational and research purposes only. The author of this project is in no way responsible for any misuse of this tool. We use it to test under NDA agreements with clients and their consents for pentesting purposes and we never encourage misuse or take responsibility for any damage caused!&lt;/p&gt; &#xA;&lt;h1&gt;Support&lt;/h1&gt; &#xA;&lt;p&gt;If you would like to support us, you can always buy us coffee(s)! &lt;span&gt;😊&lt;/span&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://www.buymeacoffee.com/bheh&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://cdn.buymeacoffee.com/buttons/default-orange.png&#34; alt=&#34;Buy Me A Coffee&#34; height=&#34;41&#34; width=&#34;174&#34;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>EtherDream/jsproxy</title>
    <updated>2023-06-28T01:48:56Z</updated>
    <id>tag:github.com,2023-06-28:/EtherDream/jsproxy</id>
    <link href="https://github.com/EtherDream/jsproxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;更新&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;2019-07-24 &lt;a href=&#34;https://github.com/EtherDream/jsproxy/raw/master/changelogs/v0.1.0.md&#34;&gt;v0.1.0&lt;/a&gt; 发布，主要修复了缓存失效的问题。网络接口和之前版本不兼容，请及时更新服务端和 cfworker。&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;2019-06-22 &lt;a href=&#34;https://raw.githubusercontent.com/EtherDream/jsproxy/master/cf-worker&#34;&gt;cfworker 无服务器版&lt;/a&gt; 发布，长期使用演示服务的请使用该版本。&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/EtherDream/jsproxy/master/changelogs&#34;&gt;查看更多&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;安装&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl https://raw.githubusercontent.com/EtherDream/jsproxy/0.1.0/i.sh | bash&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;自动安装目前只支持 Linux x64，并且需要 root 权限&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;安装过程中 80 端口能被外网访问（申请 HTTPS 证书）&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;无法满足上述条件，或想了解安装细节，可尝试&lt;a href=&#34;https://raw.githubusercontent.com/EtherDream/jsproxy/master/docs/setup.md&#34;&gt;手动安装&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;p&gt;测试: &lt;code&gt;https://服务器IP.xip.io:8443&lt;/code&gt;（具体参考脚本输出）&lt;/p&gt; &#xA;&lt;h3&gt;自定义域名&lt;/h3&gt; &#xA;&lt;p&gt;将域名 &lt;code&gt;example.com&lt;/code&gt; 解析到服务器 IP，然后执行：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl https://raw.githubusercontent.com/EtherDream/jsproxy/master/i.sh | bash -s example.com&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;访问: &lt;code&gt;https://example.com:8443&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h3&gt;自定义端口&lt;/h3&gt; &#xA;&lt;p&gt;默认端口为 8443 (HTTPS) 和 8080 (HTTP) ，如需改成 443 和 80，推荐使用端口转发：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;iptables -A PREROUTING -t nat -p tcp --dport 443 -j REDIRECT --to-ports 8443&#xA;iptables -A PREROUTING -t nat -p tcp --dport 80 -j REDIRECT --to-ports 8080&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;同时修改 &lt;code&gt;www.conf&lt;/code&gt; 中的 &lt;code&gt;:8443&lt;/code&gt; 为 &lt;code&gt;:443&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;h3&gt;使用 GitHub Pages 前端&lt;/h3&gt; &#xA;&lt;p&gt;本项目支持前后端分离，前端部分（&lt;code&gt;www&lt;/code&gt; 目录下的文件）可部署在第三方 Web 服务器上。&lt;/p&gt; &#xA;&lt;p&gt;例如演示站点的前端部署于 GitHub Pages 服务，从而可使用个性域名（*.github.io），还能减少一定的流量开销。&lt;/p&gt; &#xA;&lt;p&gt;Fork 本项目，进入 &lt;code&gt;gh-pages&lt;/code&gt; 分支（该分支内容和 &lt;code&gt;www&lt;/code&gt; 目录相同），编辑 &lt;code&gt;conf.js&lt;/code&gt; 文件：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;节点列表（&lt;code&gt;node_map&lt;/code&gt; 字段，包括节点 id 和节点主机）&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;默认节点（&lt;code&gt;node_default&lt;/code&gt; 字段，指定节点 id）&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;访问 &lt;code&gt;https://用户名.github.io/jsproxy&lt;/code&gt; 预览。&lt;/p&gt; &#xA;&lt;h1&gt;维护&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 切换到 jsproxy 用户&#xA;su - jsproxy&#xA;&#xA;# 重启服务&#xA;./run.sh reload&#xA;&#xA;# 关闭服务（参数和 nginx -s 相同）&#xA;./run.sh quit&#xA;&#xA;# 启动服务&#xA;./run.sh&#xA;&#xA;# 查看代理日志&#xA;tail server/nginx/logs/proxy.log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;目前暂未实现开机自启动。&lt;/p&gt; &#xA;&lt;h1&gt;禁止外链&lt;/h1&gt; &#xA;&lt;p&gt;默认情况下，代理接口允许所有 &lt;code&gt;github.io&lt;/code&gt; 子站点调用，这可能导致不必要的流量消耗。&lt;/p&gt; &#xA;&lt;p&gt;如果希望只给自己网站使用，可编辑 &lt;code&gt;allowed-sites.conf&lt;/code&gt;。（重启服务生效）&lt;/p&gt; &#xA;&lt;h1&gt;安全策略&lt;/h1&gt; &#xA;&lt;p&gt;如果不希望代理访问内网（避免 SSRF 风险），可执行 &lt;code&gt;setup-ipset.sh&lt;/code&gt;：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/home/jsproxy/server/setup-ipset.sh&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;需要 root 权限，依赖 &lt;code&gt;ipset&lt;/code&gt; 命令&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;该脚本可禁止 &lt;code&gt;jsporxy&lt;/code&gt; 用户访问保留 IP 段（针对 TCP）。nginx 之外的程序也生效，但不影响其他用户。&lt;/p&gt; &#xA;&lt;h1&gt;相关文章&lt;/h1&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/EtherDream/jsproxy/raw/master/docs/blogs/js-hook.md&#34;&gt;基于 JS Hook 技术，打造最先进的在线代理&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;项目特点&lt;/h1&gt; &#xA;&lt;p&gt;相比传统在线代理，本项目具有以下特点：&lt;/p&gt; &#xA;&lt;h2&gt;服务端开销低&lt;/h2&gt; &#xA;&lt;p&gt;传统在线代理几乎都是在服务端替换 HTML/JS/CSS 等资源中的 URL。这不仅需要对内容做大量的分析和处理，还需对流量进行解压和再压缩，消耗大量 CPU 资源。并且由于逻辑较复杂，通常使用 Python/PHP 等编程语言自己实现。&lt;/p&gt; &#xA;&lt;p&gt;为降低服务端开销，本项目使用浏览器的一个黑科技 —— Service Worker。它能让 JS 拦截网页产生的请求，并能自定义返回内容，相当于在浏览器内部实现一个反向代理。这使得绝大部分的内容处理都可以在浏览器上完成，服务器只需纯粹的转发流量。&lt;/p&gt; &#xA;&lt;p&gt;因此本项目服务端直接使用 nginx，并且转发过程不修改内容（只修改 HTTP 头），避免了内容处理产生的巨大开销。同时得益于 nginx 丰富的功能，很多常用需求无需重新造轮子，通过简单配置即可实现。并且无论性能还是稳定性，都远高于自己实现。&lt;/p&gt; &#xA;&lt;h2&gt;API 虚拟化&lt;/h2&gt; &#xA;&lt;p&gt;传统在线代理大多只针对静态 URL 的替换，忽视了动态 URL 以及和 URL 相关的网页 API。例如 a.com 反向代理 google.com，但页面中 JS 读取 &lt;code&gt;document.domain&lt;/code&gt; 得到的仍是 a.com。这可能导致某些业务逻辑出现问题。&lt;/p&gt; &#xA;&lt;p&gt;为缓解这个问题，本代理在页面头部注入一个 JS，用以重写绝大部分和 URL 相关的 API，使得页面中的 JS 获取到的仍是原始 URL：&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/EtherDream/jsproxy-localtest/temp/hook.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;对于有些无法重写的 API，例如 &lt;code&gt;location&lt;/code&gt;，本代理会将代码中字面出现的 &lt;code&gt;location&lt;/code&gt; 替换成 &lt;code&gt;__location&lt;/code&gt;，从而将操作转移到自定义对象上。当然对于非字面的情况（例如 &lt;code&gt;this[&#39;lo&#39; + &#39;cation&#39;]&lt;/code&gt;），目前还无法处理。&lt;/p&gt; &#xA;&lt;h1&gt;类似项目&lt;/h1&gt; &#xA;&lt;p&gt;目前找到的都是传统后端替换 URL 的方案。当然后端替换也有不少优点，例如浏览器兼容性高，甚至低版本的 IE 都可以使用。&lt;/p&gt; &#xA;&lt;h2&gt;zmirror&lt;/h2&gt; &#xA;&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/aploium/zmirror&#34;&gt;https://github.com/aploium/zmirror&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;php-proxy&lt;/h2&gt; &#xA;&lt;p&gt;GitHub: &lt;a href=&#34;https://github.com/jenssegers/php-proxy&#34;&gt;https://github.com/jenssegers/php-proxy&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;项目意义&lt;/h1&gt; &#xA;&lt;p&gt;本项目主要用于以下技术的研究：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;网站镜像 / 沙盒化&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;钓鱼网站检测技术&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;前端资源访问加速&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;当然请勿将本项目用于非法用途，否则后果自负。&lt;/p&gt; &#xA;&lt;p&gt;Demo 页面文明使用，不要进行登陆等涉及隐私的操作。&lt;/p&gt; &#xA;&lt;h1&gt;License&lt;/h1&gt; &#xA;&lt;p&gt;MIT&lt;/p&gt;</summary>
  </entry>
</feed>