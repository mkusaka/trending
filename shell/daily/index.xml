<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-18T01:43:06Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>zfl9/ss-tproxy</title>
    <updated>2023-03-18T01:43:06Z</updated>
    <id>tag:github.com,2023-03-18:/zfl9/ss-tproxy</id>
    <link href="https://github.com/zfl9/ss-tproxy" rel="alternate"></link>
    <summary type="html">&lt;p&gt;搭建 SS/SSR/V2Ray/Socks5 透明代理环境的简易脚本&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Linux 透明代理&lt;/h1&gt; &#xA;&lt;h2&gt;什么是正向代理？&lt;/h2&gt; &#xA;&lt;p&gt;代理软件通常分为客户端（client）和服务端（server），server 运行在境外服务器（通常为 Linux 服务器），client 运行在本地主机（如 Windows、Linux、Android、iOS），client 与 server 之间通常使用 tcp 或 udp 协议进行数据通信。大多数 client 被实现为一个 http、socks5 代理服务器，一个软件如果想通过 client 进行科学上网，需要使用 http、socks5 协议与 client 进行数据交互，这是绝大多数人的使用方式。这种代理方式，我们称之为 &lt;strong&gt;正向代理&lt;/strong&gt;。所谓正向代理就是，一个软件如果想要使用 client 的代理服务，需要经过特定的设置，否则不会经过 client 的代理。&lt;/p&gt; &#xA;&lt;h2&gt;什么是透明代理？&lt;/h2&gt; &#xA;&lt;p&gt;在正向代理中，一个软件如果想走 client 的代理服务，我们必须显式配置该软件，对该软件来说，有没有走代理是很明确的，大家都“心知肚明”。而透明代理则与正向代理相反，当我们设置好合适的防火墙规则（仅以 Linux 的 iptables 为例），我们将不再需要显式配置这些软件来让其经过代理或者不经过代理（直连），因为这些软件发出的流量会自动被 iptables 规则所处理，那些我们认为需要代理的流量，会被通过合适的方法发送到 client 进程，而那些我们不需要代理的流量，则直接放行（直连）。这个过程对于我们使用的软件来说是完全透明的，软件自身对其一无所知。这就叫做 &lt;strong&gt;透明代理&lt;/strong&gt;。注意，所谓透明是对我们使用的软件透明，而非对 client、server 或目标网站透明，理解这一点非常重要。&lt;/p&gt; &#xA;&lt;h2&gt;透明代理如何工作？&lt;/h2&gt; &#xA;&lt;p&gt;在正向代理中，期望使用代理的软件会通过 http、socks5 协议与 client 进程进行交互，以此完成代理操作。而在透明代理中，我们的软件发出的流量是完全正常的流量，并没有像正向代理那样，使用 http、socks5 等专用协议，这些流量经过 iptables 规则的处理后，会被通过“合适的方法”发送给 client 进程（当然是指那些我们认为需要走代理的流量）。注意，此时 client 进程接收到不再是 http、socks5 协议数据，而是经过 iptables 处理的“透明代理数据”，“透明代理数据”从本质上来说与正常数据没有区别，只是多了一些“元数据”在里面，使得 client 进程可以通过 netfilter 或操作系统提供的 API 接口来获取这些元数据（元数据其实就是原始目的地址和原始目的端口）。那么这个“合适的方法”是什么？目前来说有两种：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;REDIRECT：只支持 TCP 协议的透明代理。&lt;/li&gt; &#xA; &lt;li&gt;TPROXY：支持 TCP 和 UDP 协议的透明代理。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;因此，对于 TCP 透明代理，有两种实现方式，一种是 REDIRECT，一种是 TPROXY；而对于 UDP 透明代理，只能通过 TPROXY 方式来实现。为方便叙述，本文以 &lt;strong&gt;纯 TPROXY 模式&lt;/strong&gt; 指代 TCP 和 UDP 都使用 TPROXY 来实现，以 &lt;strong&gt;REDIRECT + TPROXY 模式&lt;/strong&gt; 指代 TCP 使用 REDIRECT 实现，而 UDP 使用 TPROXY 来实现，有时候简称 &lt;strong&gt;REDIRECT 模式&lt;/strong&gt;，它们都是一个意思。&lt;/p&gt; &#xA;&lt;h2&gt;此脚本的作用及由来&lt;/h2&gt; &#xA;&lt;p&gt;通过上面的介绍，其实可以知道，在构建透明代理的过程中，需要的仅仅是 iptables、iproute2 以及 ss/ssr/v2ray 等支持透明代理的软件，那 ss-tproxy 脚本的作用是什么呢？如果你尝试搭建过透明代理，那么你就会体会到，这一过程其实并不容易，你需要设置许多繁琐的 iptables 规则，还要应对国内复杂的 DNS 环境，另外还要考虑 UDP 透明代理的支持，此外你通常还希望这个透明代理能实现分流操作，而不是一股脑的全走代理。于是就有了 ss-tproxy 脚本，该脚本的目的就是辅助大家快速地搭建一个透明代理环境，该透明代理支持 gfwlist、chnroute 等常见分流模式，以及一个无污染的 DNS 解析服务；除此之外，ss-tproxy 脚本不做任何其它事情；因此你仍然需要 iptables、iproute2 以及 ss/ssr/v2ray 等支持透明代理的软件，因为透明代理的底层服务是由它们共同运作的，理解这一点非常重要。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;为什么叫做 &lt;code&gt;ss-tproxy&lt;/code&gt;？因为该脚本最早的时候只支持 ss 的透明代理，当然现在它并不局限于特定的代理软件。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;另外还有一点需要注意，透明代理使用的 client 与正向代理使用的 client 通常是不同的，因为正向代理的 client 是 http、socks5 服务器，而透明代理的 client 则是透明代理服务器，它们之间有本质上的区别。对于 ss，你需要使用 ss-libev 版本（ss-redir），ssr 则需要使用 ssr-libev 版本（ssr-redir），而对于 v2ray，配置好 &lt;code&gt;dokodemo-door&lt;/code&gt; 入站协议即可。再次强调，透明代理只是 client 不同，并不关心你的 server 是什么版本，因此你的 vps 上，可以运行所有与之兼容的 server 版本，以 ss/ssr 为例，你可以使用 python 版的 ss、ssr，也可以使用 golang 版的 ss、ssr 等等，只要它们之间可以兼容。&lt;/p&gt; &#xA;&lt;p&gt;如果没有条件使用 ss-libev、ssr-libev，或者只有 socks5 client，也可以使用 redsocks/redsocks2/ipt2socks 等工具将 iptables 透明代理数据转换为 socks5 协议数据，这样就可以与后端的 socks5 client 进行交互了。&lt;a href=&#34;https://github.com/darkk/redsocks&#34;&gt;redsocks&lt;/a&gt; 目前只支持 TCP 透明代理，&lt;a href=&#34;https://github.com/semigodking/redsocks&#34;&gt;redsocks2&lt;/a&gt; 支持 TCP、UDP 透明代理，&lt;a href=&#34;https://github.com/zfl9/ipt2socks&#34;&gt;ipt2socks&lt;/a&gt; 支持 TCP、UDP 透明代理。其中 ipt2socks 是我自己利用业余时间写的一个小工具，编译、配置、使用方法都比前两者简单，并且只有一个核心功能：&lt;code&gt;iptables-to-socks5&lt;/code&gt;，没有附带任何不必要的功能（redsocks2 集成了很多我不想要的东西）。&lt;code&gt;iptables-to-socks5&lt;/code&gt; 的具体配置方法见 FAQ。&lt;/p&gt; &#xA;&lt;p&gt;ss-tproxy 可以运行在 Linux 软路由/网关、Linux 物理机、Linux 虚拟机等环境中，可以透明代理 ss-tproxy 主机本身以及所有网关指向 ss-tproxy 主机的其它主机的 TCP、UDP 流量。也就是说，你可以在任意一台 Linux 主机上部署 ss-tproxy 脚本，然后同一局域网内的其它主机可以随时将其网关及 DNS 指向 ss-tproxy 主机，这样它们的 TCP 和 UDP 流量就会自动走代理了。&lt;/p&gt; &#xA;&lt;h2&gt;脚本简介&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;添加 &lt;code&gt;global&lt;/code&gt; 分流模式、&lt;code&gt;tcponly&lt;/code&gt; 代理模式&lt;/li&gt; &#xA; &lt;li&gt;支持 IPv4、IPv6 双栈透明代理（v4.0 优化版）&lt;/li&gt; &#xA; &lt;li&gt;无需指定内网网段，利用 &lt;code&gt;addrtype&lt;/code&gt; 模块进行匹配&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;v4.6.1+&lt;/code&gt;版本起不再需要指定代理服务器的地址信息&lt;/li&gt; &#xA; &lt;li&gt;使用 &lt;a href=&#34;https://github.com/zfl9/chinadns-ng&#34;&gt;chinadns-ng&lt;/a&gt; 替代原版 chinadns，修复若干问题&lt;/li&gt; &#xA; &lt;li&gt;完美兼容&#34;端口映射&#34;，只代理&#34;主动出站&#34;的流量，规则更加细致化&lt;/li&gt; &#xA; &lt;li&gt;支持配置要代理的黑名单端口，这样可以比较好的处理 BT/PT 流量&lt;/li&gt; &#xA; &lt;li&gt;支持自定义 dnsmasq/chinadns 端口，支持加载外部 dnsmasq 配置&lt;/li&gt; &#xA; &lt;li&gt;ss-tproxy stop 后，支持重定向内网主机发出的 DNS 到本地直连 DNS&lt;/li&gt; &#xA; &lt;li&gt;支持网络可用性检查，无需利用其它的 hook 来避免脚本自启失败问题&lt;/li&gt; &#xA; &lt;li&gt;脚本逻辑优化及结构调整，尽量提高脚本的可移植性，去除非核心依赖&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;v4.0/v4.6 仍支持 &lt;code&gt;global&lt;/code&gt;、&lt;code&gt;gfwlist&lt;/code&gt;、&lt;code&gt;chnroute&lt;/code&gt;、&lt;code&gt;chnlist&lt;/code&gt; 4 种分流模式：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;global&lt;/code&gt; 分流模式：除保留地址外，其它所有流量都走代理出去，即全局模式。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gfwlist&lt;/code&gt; 分流模式：&lt;code&gt;gfwlist.txt&lt;/code&gt; 中的域名走代理，其余走直连，即黑名单模式。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chnroute&lt;/code&gt; 分流模式：除了国内地址、保留地址之外，其余均走代理，即白名单模式。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chnlist&lt;/code&gt; 分流模式：本质还是 &lt;code&gt;gfwlist&lt;/code&gt; 模式，只是域名列表为国内域名，即回国模式。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;有人可能会疑问，为什么使用 ss-tproxy 后，可以访问谷歌，但无法 ping 谷歌？&lt;br&gt; 因为 ping 走的是 ICMP 协议，几乎没有代理软件会处理 ICMP，所以 ICMP 走直连。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;相关依赖&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;iptables&lt;/code&gt;：用于配置 IPv4 透明代理规则，仅在启用 IPv4 透明代理时需要。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ip6tables&lt;/code&gt;：用于配置 IPv6 透明代理规则，仅在启用 IPv6 透明代理时需要。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ipset&lt;/code&gt;：用于存储 gfwlist/chnlist 的黑名单 IP、global/chnroute 的白名单 IP。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;xt_TPROXY&lt;/code&gt;：TPROXY 内核模块，在 redirect + tcponly 模式下，不需要此依赖。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ip&lt;/code&gt;：用于配置策略路由(TPROXY)，在 redirect + tcponly 模式下，不需要此依赖。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dnsmasq&lt;/code&gt;：DNS 服务，对于 gfwlist/chnlist 模式，该 dnsmasq 需支持 &lt;code&gt;--ipset&lt;/code&gt; 选项。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chinadns-ng&lt;/code&gt;：chnroute 模式的 DNS 服务，注意是 &lt;a href=&#34;https://github.com/zfl9/chinadns-ng&#34;&gt;chinadns-ng&lt;/a&gt;，不是原版 chinadns。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dns2tcp&lt;/code&gt;：将 DNS 查询从 UDP 转为 TCP，仅在 tcponly 模式需要，注意是 &lt;a href=&#34;https://github.com/zfl9/dns2tcp&#34;&gt;zfl9/dns2tcp&lt;/a&gt;。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;使用内置命令更新 gfwlist/chnlist/chnroute 列表时，会用到这些依赖：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;curl&lt;/code&gt;：用于更新 chnlist、gfwlist、chnroute 分流模式的相关列表。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;base64&lt;/code&gt;：用于更新 gfwlist 的域名列表，gfwlist.txt 是 &lt;code&gt;base64&lt;/code&gt; 格式编码的。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;perl&lt;/code&gt;：用于更新 gfwlist 的域名列表，gfwlist.txt 是 &lt;code&gt;adblock plus&lt;/code&gt; 规则，要进行转换。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;如果某些模式你基本不用，那么对应的依赖就不用管。比如，你不打算使用 IPv6 透明代理，则无需关心 ip6tables，又比如你不打算使用 chnroute 模式，也无需关心 chinadns-ng。ss-tproxy 脚本在启动时会检查当前配置所需的依赖，只需要根据提示安装缺少的依赖即可。&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zfl9/ss-tproxy/wiki/Linux-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96&#34;&gt;ss-tproxy 脚本相关依赖的安装方式参考&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;下载脚本&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/zfl9/ss-tproxy&#xA;cd ss-tproxy&#xA;chmod +x ss-tproxy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;安装脚本&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;请确保当前用户有权限读写以下目录，如没有，请先运行&lt;code&gt;sudo su&lt;/code&gt;进入超级用户(root)。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;install命令可用&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;install ss-tproxy /usr/local/bin&#xA;install -d /etc/ss-tproxy&#xA;install -m 644 ss-tproxy.conf gfwlist* chnroute* ignlist* /etc/ss-tproxy&#xA;install -m 644 ss-tproxy.service /etc/systemd/system # 可选，安装 service 文件&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;install命令不可用&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp -af ss-tproxy /usr/local/bin&#xA;mkdir -p /etc/ss-tproxy&#xA;cp -af ss-tproxy.conf gfwlist* chnroute* ignlist* /etc/ss-tproxy&#xA;cp -af ss-tproxy.service /etc/systemd/system # 可选，安装 service 文件&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;卸载脚本&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ss-tproxy stop&#xA;ss-tproxy flush-postrule&#xA;ss-tproxy delete-gfwlist&#xA;rm -fr /usr/local/bin/ss-tproxy # 删除脚本&#xA;rm -fr /etc/ss-tproxy # 删除配置(做好备份)&#xA;rm -fr /etc/systemd/system/ss-tproxy.service # service文件&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;升级脚本&lt;/h2&gt; &#xA;&lt;p&gt;脚本目前没有自我更新能力，只能卸载后重新安装，后续也许会添加自我更新指令。&lt;/p&gt; &#xA;&lt;h2&gt;文件列表&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy&lt;/code&gt;：shell 脚本，欢迎各位大佬一起来改进这个脚本。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy.conf&lt;/code&gt;：配置文件，本质是 shell 脚本，修改需重启生效。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy.service&lt;/code&gt;：systemd 服务文件，用于 ss-tproxy 的开机自启。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chnroute.set&lt;/code&gt;：存储大陆地址段的 ipset 文件（IPv4），不要手动修改。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;chnroute6.set&lt;/code&gt;：存储大陆地址段的 ipset 文件（IPv6），不要手动修改。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gfwlist.txt&lt;/code&gt;：存储 gfwlist、chnlist 分流模式的黑名单域名，不要手动修改。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;gfwlist.ext&lt;/code&gt;：存储 gfwlist、chnlist 分流模式的扩展黑名单，可配置，重启生效。&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ignlist.ext&lt;/code&gt;：存储 global、chnroute 分流模式的扩展白名单，可配置，重启生效。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;ss-tproxy 只是一个 shell 脚本，并不是常驻后台的服务，因此所有的修改都需要 restart 来生效。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;配置说明&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;注意，配置文件在 /etc/ss-tproxy/ 目录，不是 git clone 下来的目录！&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;配置项有点多，但通常只需修改 ss-tproxy.conf 前面的少数配置项（开头至&lt;code&gt;proxy&lt;/code&gt;配置段）&lt;/p&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;注释&lt;/summary&gt; &#xA; &lt;p&gt;井号开头的行为注释行，配置文件本质上是一个 shell 脚本，对于同名变量或函数，后定义的会覆盖先定义的。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;mode&lt;/summary&gt; &#xA; &lt;p&gt;分流模式，默认为 chnroute 模式，可根据需要修改为 global/gfwlist 模式。&lt;/p&gt; &#xA; &lt;p&gt;如果需要使用 &lt;code&gt;chnlist&lt;/code&gt; 回国模式，则 mode 依旧为 &lt;code&gt;gfwlist&lt;/code&gt;，具体的：&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;gfwlist 模式与 chnlist 模式共享 &lt;code&gt;gfwlist.txt&lt;/code&gt;、&lt;code&gt;gfwlist.ext&lt;/code&gt; 文件&lt;/li&gt; &#xA;  &lt;li&gt;首先执行 &lt;code&gt;ss-tproxy update-chnlist&lt;/code&gt; 将 gfwlist.txt 替换为国内域名列表&lt;/li&gt; &#xA;  &lt;li&gt;手动编辑 gfwlist.ext 扩展黑名单，将其中的 Telegram IPv4/IPv6 地址段注释&lt;/li&gt; &#xA;  &lt;li&gt;手动修改 &lt;code&gt;dns_direct/dns_direct6&lt;/code&gt; 配置项，改为本地 DNS（如 Google DNS）&lt;/li&gt; &#xA;  &lt;li&gt;手动修改 &lt;code&gt;dns_remote/dns_remote6&lt;/code&gt; 配置项，改为大陆 DNS（如 114 DNS，走代理）&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;如果需要从 chnlist 回国模式切换为 gfwlist 国内模式，则进行相反的操作（update-gfwlist）&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ipv4、ipv6&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;启用 IPv4/IPv6 透明代理，你需要确保本机代理进程能正确处理 IPv4/IPv6 相关数据包，脚本不检查它&lt;/li&gt; &#xA;  &lt;li&gt;启用 IPv6 透明代理应检查当前的 Linux 内核版本是否为 &lt;code&gt;v3.9.0+&lt;/code&gt;，以及 ip6tables 的版本是否为 &lt;code&gt;v1.4.18+&lt;/code&gt;&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;tproxy&lt;/summary&gt; &#xA; &lt;p&gt;true 为纯 TPROXY，false 为 REDIRECT/TPROXY 混合（具体解释前面有）：&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;ss/ssr/trojan 目前是 REDIRECT/TPROXY 混合模式&lt;/li&gt; &#xA;  &lt;li&gt;v2ray 经配置后可使用纯 TPROXY 模式（见下）&lt;/li&gt; &#xA;  &lt;li&gt;ipt2socks 默认配置是纯 TPROXY 模式&lt;/li&gt; &#xA;  &lt;li&gt;其他代理软件请各位自己辨别测试&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;ss-libev v3.3.5+ 已加入纯 tproxy 支持，在启动参数中增加&lt;code&gt;-T&lt;/code&gt;或在json文件中添加&lt;code&gt;&#34;tcp_tproxy&#34;: true&lt;/code&gt;配置行，即可启用&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;tcponly&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;true 表示仅代理 TCP 流量（需要依赖 dns2tcp）&lt;/li&gt; &#xA;  &lt;li&gt;false 表示代理 TCP 和 UDP 流量（这是默认值）&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;selfonly&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;true 表示仅代理 ss-tproxy 主机自身的流量&lt;/li&gt; &#xA;  &lt;li&gt;false 表示代理 ss-tproxy 主机自身以及所有网关指向 ss-tproxy 主机的流量&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;proxy_procuser、proxy_procgroup&lt;/summary&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;strong&gt;v4.6.1新增&lt;/strong&gt;：替代之前的&lt;code&gt;proxy_svraddr/proxy_svrport&lt;/code&gt;配置，用来实现&lt;code&gt;本机代理进程&lt;/code&gt;流量放行&lt;/li&gt; &#xA;  &lt;li&gt;现在只需要让&lt;code&gt;本机代理进程&lt;/code&gt;以指定user/group身份运行，即可&#39;放行&#39;它们传出的流量（避免环路）&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;proxy_procuser&lt;/code&gt;填写&lt;code&gt;本机代理进程&lt;/code&gt;的user/uid，&lt;code&gt;proxy_procgroup&lt;/code&gt;填写&lt;code&gt;本机代理进程&lt;/code&gt;的group/gid&lt;/li&gt; &#xA;  &lt;li&gt;两者选其一(不建议都填)；此文档使用&lt;code&gt;proxy&lt;/code&gt;用户(组)，见&lt;code&gt;proxy_startcmd/proxy_stopcmd&lt;/code&gt;配置说明&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;proxy_svraddr4、proxy_svraddr6&lt;/summary&gt; &#xA; &lt;p&gt;&lt;strong&gt;不建议使用此机制，请使用&lt;code&gt;proxy_procuser&lt;/code&gt;/&lt;code&gt;proxy_procgroup&lt;/code&gt;&lt;/strong&gt;：填写 VPS 服务器的外网 IPv4/IPv6 地址，IP 或域名都可以，填域名要注意，这个域名最好不要有多个 IP 地址与之对应，因为脚本内部只会获取其中某个 IP，这极有可能与本机代理进程解析出来的 IP 不一致，这可能会导致 iptables 规则死循环，应尽量避免这种情况，比如你可以将该域名与其中某个 IP 的映射关系写到 ss-tproxy 主机的 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中，这样解析结果就是可预期的。允许填写多个 VPS 地址，用空格隔开，填写多个地址的目的是方便切换代理，比如我现在有两个 VPS，A、B，假设你先使用 A，因为某些因素，导致 A 的网络性能低下，那么你可能需要切换到 B，如果只填写了 A 的地址，就需要去修改 ss-tproxy.conf，将地址改为 B，修改启动与关闭命令，最后还得重启 ss-tproxy 脚本，很麻烦，更麻烦的是，如果现在 A 的网络又好了，那么你可能又想切换回 A，那么你又得重复上述步骤。但现在，你不需要这么做，你完全可以在 &lt;code&gt;proxy_svraddr&lt;/code&gt; 中填写 A 和 B 的地址，假设你默认使用 A（&lt;code&gt;proxy_startcmd&lt;/code&gt; 启动 A 代理进程），那么启动 ss-tproxy 后，使用的就是 A，此后如果想切换为 B，仅需停止 A 代理进程，再启动 B 代理进程（切回来的步骤则相反），该过程无需操作 ss-tproxy；这种配置下应注意 &lt;code&gt;proxy_stopcmd&lt;/code&gt;，stopcmd 最好能停止 A 和 B 进程，不然切换进程后执行 ss-tproxy stop 可能不会正确停止相关的代理进程。另外，你只需填写实际会使用到的 VPS 地址，比如本机代理进程仅使用 IPv4 访问 VPS，则 &lt;code&gt;proxy_svraddr6&lt;/code&gt; 可能是空的，反之，如果本机代理进程仅使用 IPv6 访问 VPS，则 &lt;code&gt;proxy_svraddr4&lt;/code&gt; 可能是空的；这两个数组是否为空与 &lt;code&gt;ipv4&lt;/code&gt;、&lt;code&gt;ipv6&lt;/code&gt; 选项没有必然的联系，比如你可以启用 IPv4 和 IPv6 透明代理，但是本机代理进程仅使用 IPv4 访问 VPS，这是完全可以的，但不允许 &lt;code&gt;proxy_svraddr4&lt;/code&gt; 与 &lt;code&gt;proxy_svraddr6&lt;/code&gt; 都为空，你至少需要填写一个地址。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;proxy_svrport&lt;/summary&gt; &#xA; &lt;p&gt;&lt;strong&gt;不建议使用此机制，请使用&lt;code&gt;proxy_procuser&lt;/code&gt;/&lt;code&gt;proxy_procgroup&lt;/code&gt;&lt;/strong&gt;：填写 VPS 上代理服务器的外部监听端口，格式同 &lt;code&gt;ipts_proxy_dst_port&lt;/code&gt;，填写不正确会导致 iptables 规则死循环。如果是 v2ray 动态端口，如端口号 1000 到 2000 都是代理监听端口，则填 &lt;code&gt;1000:2000&lt;/code&gt;（含边界）。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;proxy_tcpport、proxy_udpport&lt;/summary&gt; &#xA; &lt;p&gt;&lt;code&gt;本机代理进程&lt;/code&gt;的 &lt;strong&gt;透明代理&lt;/strong&gt; 监听端口，前者为 TCP 端口，后者为 UDP 端口，通常情况下这两端口是相同的。&lt;br&gt; 如果 UDP 隧道不稳定，或无法使用 UDP 代理，可使用 &lt;code&gt;tcponly&lt;/code&gt; 模式，这种情况下，&lt;code&gt;proxy_udpport&lt;/code&gt; 将被忽略。&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;此端口必须支持透明代理(REDIRECT/TPROXY)，请不要填写其他传入协议的端口，如&lt;code&gt;socks5&lt;/code&gt;。&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;proxy_startcmd、proxy_stopcmd&lt;/summary&gt; &#xA; &lt;p&gt;前者是启动&lt;code&gt;本机代理进程&lt;/code&gt;的 shell 命令，后者是关闭&lt;code&gt;本机代理进程&lt;/code&gt;的 shell 命令&lt;br&gt; 这些命令应该能快速执行完毕，防止卡住脚本(长时间处于半启动或半关闭状态)&lt;br&gt;&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;具体命令例子，见 &lt;a href=&#34;https://raw.githubusercontent.com/zfl9/ss-tproxy/master/#%E4%BB%A3%E7%90%86%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE&#34;&gt;代理软件配置&lt;/a&gt;&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;dnsmasq_bind_port&lt;/summary&gt; &#xA; &lt;p&gt;dnsmasq 监听端口，默认 53，如果端口已被占用则修改为其它未占用的端口，如 &lt;code&gt;60053&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;dnsmasq_conf_dir、dnsmasq_conf_file&lt;/summary&gt; &#xA; &lt;p&gt;dnsmasq 外部配置文件/目录，被作为 dnsmasq 的 &lt;code&gt;conf-dir&lt;/code&gt;、&lt;code&gt;conf-file&lt;/code&gt; 选项的值。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;dnsmasq_conf_string&lt;/summary&gt; &#xA; &lt;p&gt;shell 数组，每个元素都是一行独立的 dnsmasq 配置，多个用空白符隔开，如果元素内容包含空白符，请用引号包围。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;chinadns_gfwlist_mode&lt;/summary&gt; &#xA; &lt;p&gt;是否启用 chinadns-ng 的 gfwlist 黑名单匹配模式。如果需要在 Android 上使用 Google Play，建议打开此选项，否则可能会遇到 &lt;code&gt;从服务器检索信息时出错，DF-DFERH-01&lt;/code&gt; 错误，导致 Google Play 无法使用，究其原因是因为 &lt;code&gt;services.googleapis.cn&lt;/code&gt; 这个域名的解析没有走代理导致的（连到了谷歌中国）。启用 gfwlist 匹配模式后就正常了，因为 &lt;code&gt;gfwlist.txt&lt;/code&gt; 包含了 &lt;code&gt;services.googleapis.cn&lt;/code&gt; 这个域名。当然也可以使用 dnsmasq 的 &lt;code&gt;--server&lt;/code&gt; 选项来解决这个问题，只不过会稍微多几个步骤，这里就不详细介绍了。&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;如非特殊情况，建议始终启用其模式，可以最大限度的提高 chinadns-ng 准确性，极大减少 dns 污染可能性&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;chinadns_privaddr4、chinadns_privaddr6&lt;/summary&gt; &#xA; &lt;p&gt;如果希望&lt;code&gt;chinadns-ng&lt;/code&gt;接受&lt;strong&gt;包含保留地址的解析记录&lt;/strong&gt;(如&lt;code&gt;192.168.1.1&lt;/code&gt;)，请在此配置加入对应保留地址(段)，如&lt;code&gt;192.168.1.0/24&lt;/code&gt;。前者为 IPv4 地址段数组、后者为 IPv6 地址段数组，多个用空格隔开，默认为空数组。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ipts_set_snat&lt;/summary&gt; &#xA; &lt;p&gt;是否设置 IPv4 的 MASQUERADE 规则（true设置，false不设置），通常 false 即可。有两种情况需要将其设置为 true：&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;ss-tproxy 部署在出口路由位置且确实需要 MASQUERADE 规则（即至少两张网卡，一张连内网，一张连公网，需要源地址转换）&lt;/li&gt; &#xA;  &lt;li&gt;在设置为 false 的情况下，代理不正常，典型的如：白名单地址无法访问（如百度），黑名单地址正常访问，也需要将其改为 true&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;注意，MASQUERADE 规则在 ss-tproxy stop 仍然是有效的，如果你想清空这些残留规则，可以执行 &lt;code&gt;ss-tproxy flush-postrule&lt;/code&gt; 命令&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ipts_set_snat6&lt;/summary&gt; &#xA; &lt;p&gt;是否设置 IPv6 的 MASQUERADE 规则（true设置，false不设置），通常 false 即可。&lt;br&gt; v4.6 版本的 IPv6 透明代理不再需要配置 ULA 私有地址，可直接使用 GUA 公网地址。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ipts_reddns_onstop&lt;/summary&gt; &#xA; &lt;p&gt;当 ss-tproxy stop 之后，是否将内网主机发往 ss-tproxy 主机的 DNS 请求重定向至本地直连 DNS（&lt;code&gt;dns_direct/dns_direct6&lt;/code&gt;），为什么要这么做呢？因为其它内网主机的 DNS 是指向 ss-tproxy 主机的，但是现在我们已经关闭了 ss-tproxy（dnsmasq 关闭了），所以这些内网主机会无法解析 DNS 而无法上网；设置此选项后，这些 DNS 请求会被重定向给 114.114.114.114 等国内直连 DNS，这样它们就又可以正常上网了，在下次执行 ss-tproxy start 时，这些规则会被脚本自动删除，如果你需要手动删除这些规则，可以执行 &lt;code&gt;ss-tproxy flush-postrule&lt;/code&gt; 命令。该选项的默认值为 true，如果 ss-tproxy 主机上有正常运行的 DNS 服务，那么这个选项应该设置为 false。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ipts_proxy_dst_port&lt;/summary&gt; &#xA; &lt;p&gt;要代理黑名单地址的哪些目的端口。所谓黑名单地址，对于 gfwlist/chnlist 模式来说，就是 gfwlist.txt/gfwlist.ext 里面的域名、IP、网段，对于 chnroute 模式来说，就是国外 IP 地址。默认值为 &lt;code&gt;1:65535&lt;/code&gt;，因此只要我们访问黑名单地址，就会走代理，因为所有端口号都在其中。如果觉得端口范围太大，那么你可以修改这个选项的值，比如设置为 &lt;code&gt;1:1023,8080&lt;/code&gt;，在这种配置下，只有当我们访问黑名单地址的 1 到 1023 和 8080 这些目的端口时才会走代理，访问黑名单地址的其它目的端口是不会走代理的，因此可以利用此选项来放行 BT、PT 流量，因为这些流量的目的端口通常都在 1024 以上。修改此选项需要足够小心，配置不当会导致某些常用软件无法正常走代理，因为它们使用的端口号可能不在你所指定的范围之内，因此指定为 &lt;code&gt;1:65535&lt;/code&gt; 可能是最保险的一种做法。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;opts_ss_netstat&lt;/summary&gt; &#xA; &lt;p&gt;告诉 ss-tproxy，使用 ss 还是 netstat 命令进行端口检测，目前检测&lt;code&gt;本机代理进程&lt;/code&gt;是否正常运行的方式是直接检测其是否已监听对应的端口，虽然这种方式有时并不准确，但我现在并没有其它更好的便携方法来做这个事情。选项的默认值为 &lt;code&gt;auto&lt;/code&gt;，表示自动模式，所谓自动模式就是，如果当前系统有 ss 命令则使用 ss 命令进行检测，如果没有 ss 命令但是有 netstat 命令则使用 netstat 命令进行检测，而 &lt;code&gt;ss&lt;/code&gt; 选项值则是明确告诉 ss-tproxy 使用 &lt;code&gt;ss&lt;/code&gt; 进行检测，同理，&lt;code&gt;netstat&lt;/code&gt; 选项也是明确告诉 ss-tproxy 使用 &lt;code&gt;netstat&lt;/code&gt; 进行端口检测。通常情况下保持 &lt;code&gt;auto&lt;/code&gt; 即可。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;opts_ping_cmd_to_use&lt;/summary&gt; &#xA; &lt;p&gt;告诉 ss-tproxy，使用何种 ping 命令（主要是 ping6 的问题）。默认为 &lt;code&gt;auto&lt;/code&gt;，如果存在 &lt;code&gt;ping6&lt;/code&gt; 且 &lt;code&gt;ping6&lt;/code&gt; 并非软链接文件，则使用 &lt;code&gt;ping&lt;/code&gt; 处理 ipv4 地址/域名，使用 &lt;code&gt;ping6&lt;/code&gt; 来处理 ipv6 地址/域名，如果不存在 &lt;code&gt;ping6&lt;/code&gt; 或 &lt;code&gt;ping6&lt;/code&gt; 是 &lt;code&gt;ping&lt;/code&gt; 的软链接文件，则使用 &lt;code&gt;ping -4&lt;/code&gt; 处理 ipv4 地址/域名，使用 &lt;code&gt;ping -6&lt;/code&gt; 处理 ipv6 地址/域名。如果选项值为 &lt;code&gt;standalone&lt;/code&gt; 则明确使用 &lt;code&gt;ping/ping6&lt;/code&gt; 方案，如果选项值为 &lt;code&gt;parameter&lt;/code&gt; 则明确使用 &lt;code&gt;ping -4/-6&lt;/code&gt; 方案。一般情况下，保持默认即可，除非遇到运行时错误等问题（如 &lt;code&gt;ping -4/-6&lt;/code&gt; 选项不支持）。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;opts_hostname_resolver&lt;/summary&gt; &#xA; &lt;p&gt;告诉 ss-tproxy，使用哪个工具来解析 &lt;code&gt;proxy_svraddr4/6&lt;/code&gt; 中的域名(&lt;code&gt;proxy_procuser/group&lt;/code&gt;模式下不需要)；默认为 &lt;code&gt;auto&lt;/code&gt;，auto 模式的查找优先级为 &lt;code&gt;dig&lt;/code&gt;、&lt;code&gt;getent&lt;/code&gt;、&lt;code&gt;ping&lt;/code&gt;，只要找到其中一个就停止搜寻；dig 需要安装 bind-utils/dnsutils 包，getent 大多数发行版都自带，ping 基本上是个系统都有；如果你的系统只有 ping 命令，且能明显感受到 1 秒左右的解析延迟，那么请安装 dig 实用工具（Debian/Ubuntu 系列基本上都有这个问题，busybox 版本的 ping 也一样）。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;opts_overwrite_resolv&lt;/summary&gt; &#xA; &lt;p&gt;如果设置为 true，则表示直接使用 I/O 重定向方式修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 文件，这个操作是不可逆的，但是可移植性好；如果设置为 false，则表示使用 &lt;code&gt;mount -o bind&lt;/code&gt; 魔法来暂时性修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 文件，当 ss-tproxy stop 之后，&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 会恢复为原来的文件，也就是说这个修改操作是可逆的，但是这个方式可能某些系统会不支持，默认为 &lt;code&gt;false&lt;/code&gt;，如果遇到问题请修改为 &lt;code&gt;true&lt;/code&gt;；此选项留空则不操作 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;opts_ip_for_check_net&lt;/summary&gt; &#xA; &lt;p&gt;指定一个允许 Ping 的 IP 地址（IPv4 或 IPv6 都行），用于检查外部网络的连通情况，如果此选项留空则表示跳过网络可用性检查（不建议）。默认为 &lt;code&gt;223.5.5.5&lt;/code&gt;，注意这个 IP 地址应该为公网 IP，如果你填一个私有 IP，即使检测成功，也不能保证外网是可访问的，因为这仅代表我可以访问这个内网。根据实际网络环境进行更改，一般改为延迟较低且较稳定的一个 IP。&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;h2&gt;代理软件配置&lt;/h2&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ss-libev&lt;/summary&gt; &#xA; &lt;p&gt;&lt;code&gt;ss-redir&lt;/code&gt;配置文件&lt;code&gt;/etc/ss.json&lt;/code&gt;，例如&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;&lt;code&gt;本地监听端口&lt;/code&gt;请确保与&lt;code&gt;ss-tproxy.conf&lt;/code&gt;文件中的&lt;code&gt;proxy_tcpport&lt;/code&gt;、&lt;code&gt;proxy_udpport&lt;/code&gt;配置项保持一致&lt;/li&gt; &#xA;  &lt;li&gt;若使用&lt;code&gt;proxy_svraddr/svrport&lt;/code&gt;机制(不建议)，请确保&lt;code&gt;服务器地址/端口&lt;/code&gt;与&lt;code&gt;proxy_svraddr/svrport&lt;/code&gt;一致&lt;/li&gt; &#xA;  &lt;li&gt;&lt;code&gt;本地监听地址&lt;/code&gt;填&lt;code&gt;127.0.0.1&lt;/code&gt;；对于&lt;code&gt;v4.6.1&lt;/code&gt;以前的版本，填&lt;code&gt;0.0.0.0&lt;/code&gt;，若只代理ss-tproxy自身，可填回环&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;    &#34;server&#34;: &#34;服务器地址&#34;,&#xA;    &#34;server_port&#34;: 服务器端口,&#xA;    &#34;local_address&#34;: &#34;本地监听地址&#34;,&#xA;    &#34;local_port&#34;: 本地监听端口,&#xA;    &#34;method&#34;: &#34;加密方式&#34;,&#xA;    &#34;password&#34;: &#34;用户密码&#34;,&#xA;    &#34;no_delay&#34;: true,&#xA;    &#34;fast_open&#34;: true,&#xA;    &#34;reuse_port&#34;: true&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;ss-tproxy.conf&lt;/code&gt;启动和停止命令，例如&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#老版本(v4.6.0及以下)&#xA;#请确保proxy_svraddr/svrport与&#39;服务器地址/端口&#39;一致&#xA;#proxy_startcmd=&#39;(ss-redir -c /etc/ss.json -u -v &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/ss-redir.log &amp;amp;)&#39; # -v 表示记录详细日志&#xA;proxy_startcmd=&#39;(ss-redir -c /etc/ss.json -u &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/ss-redir.log &amp;amp;)&#39; # 这里就不记录详细日志了&#xA;proxy_stopcmd=&#39;kill -9 $(pidof ss-redir)&#39;&#xA;&#xA;#新版本(v4.6.1及以上)&#xA;#第一次运行时，请执行下面这两个操作&#xA;#1.创建proxy用户和组: useradd -Mr -d/tmp -s/bin/bash proxy&#xA;#2.授予透明代理相关权限: setcap cap_net_bind_service,cap_net_admin+ep /path/to/ss-redir&#xA;#&amp;gt;&amp;gt; 若setcap不可用，可使用suid权限位，此时需配置：proxy_procuser=&#39;&#39;、proxy_procgroup=&#39;proxy&#39;&#xA;#&amp;gt;&amp;gt; 将所有者(组)改为root，并授予suid权限：chown root:root /path/to/ss-redir &amp;amp;&amp;amp; chmod 4755 /path/to/ss-redir&#xA;proxy_procuser=&#39;proxy&#39;&#xA;#proxy_startcmd=&#39;su proxy -c&#34;(ss-redir -c /etc/ss.json -u -v &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/tmp/ss-redir.log &amp;amp;)&#34;&#39; # -v 表示记录详细日志&#xA;proxy_startcmd=&#39;su proxy -c&#34;(ss-redir -c /etc/ss.json -u &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/tmp/ss-redir.log &amp;amp;)&#34;&#39; # 这里就不记录详细日志了&#xA;proxy_stopcmd=&#39;kill -9 $(pidof ss-redir)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;ssr-libev&lt;/summary&gt; &#xA; &lt;p&gt;&lt;code&gt;ssr-redir&lt;/code&gt;配置文件&lt;code&gt;/etc/ssr.json&lt;/code&gt;，例如&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;基本同ss-libev，这里就不详细贴出了，随便一搜就有，注意事项也同ss-libev&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;ss-tproxy.conf&lt;/code&gt;启动和停止命令，例如&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#老版本(v4.6.0及以下)&#xA;#请确保proxy_svraddr/svrport与&#39;服务器地址/端口&#39;一致&#xA;#proxy_startcmd=&#39;(ssr-redir -c /etc/ssr.json -u -v &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/ssr-redir.log &amp;amp;)&#39;&#xA;proxy_startcmd=&#39;(ssr-redir -c /etc/ssr.json -u &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/ssr-redir.log &amp;amp;)&#39;&#xA;proxy_stopcmd=&#39;kill -9 $(pidof ssr-redir)&#39;&#xA;&#xA;#新版本(v4.6.1及以上)&#xA;#第一次运行时，请执行下面这两个操作&#xA;#1.创建proxy用户和组: useradd -Mr -d/tmp -s/bin/bash proxy&#xA;#2.授予透明代理相关权限: setcap cap_net_bind_service,cap_net_admin+ep /path/to/ssr-redir&#xA;#&amp;gt;&amp;gt; 若setcap不可用，可使用suid权限位，此时需配置：proxy_procuser=&#39;&#39;、proxy_procgroup=&#39;proxy&#39;&#xA;#&amp;gt;&amp;gt; 将所有者(组)改为root，并授予suid权限：chown root:root /path/to/ssr-redir &amp;amp;&amp;amp; chmod 4755 /path/to/ssr-redir&#xA;proxy_procuser=&#39;proxy&#39;&#xA;#proxy_startcmd=&#39;su proxy -c&#34;(ssr-redir -c /etc/ssr.json -u -v &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/tmp/ssr-redir.log &amp;amp;)&#34;&#39; # -v 表示记录详细日志&#xA;proxy_startcmd=&#39;su proxy -c&#34;(ssr-redir -c /etc/ssr.json -u &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/tmp/ssr-redir.log &amp;amp;)&#34;&#39; # 这里就不记录详细日志了&#xA;proxy_stopcmd=&#39;kill -9 $(pidof ssr-redir)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;v2ray&lt;/summary&gt; &#xA; &lt;p&gt;v2ray 的透明代理配置比较简单，只需在原有客户端配置加上 &lt;code&gt;dokodemo-door&lt;/code&gt; 入站协议，例如&lt;/p&gt; &#xA; &lt;blockquote&gt; &#xA;  &lt;p&gt;由于 v2ray 配置复杂，在报告问题之前，请检查配置是否有问题，这里不解答任何 v2ray 配置问题&lt;br&gt; &lt;strong&gt;原则上不建议在 v2ray 上配置任何分流或路由规则&lt;/strong&gt;，脚本会为你做这些事，否则出问题请自行解决&lt;br&gt; 据反馈，&lt;code&gt;dokodemo-door&lt;/code&gt; 的 UDP 存在断流 bug，可尝试使用 &lt;code&gt;redsocks2/ipt2socks + socks5&lt;/code&gt; 来缓解&lt;/p&gt; &#xA; &lt;/blockquote&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;  &#34;log&#34;: {&#xA;    &#34;access&#34;: &#34;/var/log/v2ray/access.log&#34;,&#xA;    &#34;error&#34;: &#34;/var/log/v2ray/error.log&#34;,&#xA;    &#34;loglevel&#34;: &#34;info&#34; // 调试时请改为 debug&#xA;  },&#xA;&#xA;  &#34;inbounds&#34;: [&#xA;    {&#xA;      &#34;protocol&#34;: &#34;dokodemo-door&#34;,&#xA;      &#34;listen&#34;: &#34;0.0.0.0&#34;, // 如果只代理本机，可填写回环地址&#xA;      //&#34;listen&#34;: &#34;127.0.0.1&#34;, // v4.6.1+版本可填写回环地址&#xA;      &#34;port&#34;: 60080, // 必须与proxy_tcpport/udpport保持一致&#xA;      &#34;settings&#34;: {&#xA;        &#34;network&#34;: &#34;tcp,udp&#34;, // 注意这里是 tcp + udp&#xA;        &#34;followRedirect&#34;: true&#xA;      },&#xA;      &#34;streamSettings&#34;: {&#xA;        &#34;sockopt&#34;: {&#xA;          //&#34;tproxy&#34;: &#34;tproxy&#34; // tproxy + tproxy 模式 (纯tproxy)&#xA;          &#34;tproxy&#34;: &#34;redirect&#34; // redirect + tproxy 模式 (redirect)&#xA;        }&#xA;      }&#xA;    }&#xA;  ],&#xA;&#xA;  &#34;outbounds&#34;: [&#xA;    {&#xA;      &#34;protocol&#34;: &#34;shadowsocks&#34;,&#xA;      &#34;settings&#34;: {&#xA;        &#34;servers&#34;: [&#xA;          {&#xA;            &#34;address&#34;: &#34;node.proxy.net&#34;, // 服务器地址 (如果是v4.6.1之前的版本，请与proxy_svraddr一致)&#xA;            &#34;port&#34;: 12345,               // 服务器端口 (如果是v4.6.1之前的版本，请与proxy_svrport一致)&#xA;            &#34;method&#34;: &#34;aes-128-gcm&#34;,     // 加密方式&#xA;            &#34;password&#34;: &#34;password&#34;       // 用户密码&#xA;          }&#xA;        ]&#xA;      }&#xA;    }&#xA;  ]&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;ss-tproxy.conf&lt;/code&gt;启动和停止命令，例如&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#老版本(v4.6.0及以下)&#xA;#请确保proxy_svraddr/svrport与&#39;服务器地址/端口&#39;一致&#xA;proxy_startcmd=&#39;systemctl start v2ray&#39;&#xA;proxy_stopcmd=&#39;systemctl stop v2ray&#39;&#xA;&#xA;#新版本(v4.6.1及以上)&#xA;#第一次运行时，请执行下面这两个操作&#xA;#1.创建proxy用户和组: useradd -Mr -d/tmp -s/bin/bash proxy&#xA;#2.授予透明代理相关权限: setcap cap_net_bind_service,cap_net_admin+ep /path/to/{v2ray,v2ctl}&#xA;#&amp;gt;&amp;gt; 若setcap不可用，可使用suid权限位，此时需配置：proxy_procuser=&#39;&#39;、proxy_procgroup=&#39;proxy&#39;&#xA;#&amp;gt;&amp;gt; 将所有者(组)改为root，并授予suid权限：chown root:root /path/to/{v2ray,v2ctl} &amp;amp;&amp;amp; chmod 4755 /path/to/{v2ray,v2ctl}&#xA;proxy_procuser=&#39;proxy&#39;&#xA;proxy_startcmd=&#39;su proxy -c&#34;(v2ray -config /etc/v2ray.json &amp;lt;/dev/null &amp;amp;&amp;gt;/dev/null &amp;amp;)&#34;&#39;&#xA;proxy_stopcmd=&#39;kill -9 $(pidof v2ray) $(pidof v2ctl)&#39;&#xA;#当然也可以使用systemctl来封装上述startcmd/stopcmd，具体不再细说。&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;socks5&lt;/summary&gt; &#xA; &lt;p&gt;对于socks5代理（如：非libev版本的ss/ssr，或其他代理软件），可使用 &lt;a href=&#34;https://github.com/zfl9/ipt2socks&#34;&gt;ipt2socks&lt;/a&gt; 作为其前端，提供透明代理传入支持。以trojan为例（trojan支持nat传入，但只支持tcp，因此与ipt2socks配合用），配置例子来自trojan官方文档：&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{&#xA;    &#34;run_type&#34;: &#34;client&#34;,&#xA;    &#34;local_addr&#34;: &#34;127.0.0.1&#34;,&#xA;    &#34;local_port&#34;: 1080,&#xA;    &#34;remote_addr&#34;: &#34;example.com&#34;, // 服务器地址 (如果是v4.6.1之前的版本，请与proxy_svraddr一致)&#xA;    &#34;remote_port&#34;: 443, // 服务器端口 (如果是v4.6.1之前的版本，请与proxy_svrport一致)&#xA;    &#34;password&#34;: [&#xA;        &#34;password1&#34; // 用户密码&#xA;    ],&#xA;    &#34;log_level&#34;: 1,&#xA;    &#34;ssl&#34;: {&#xA;        &#34;verify&#34;: true,&#xA;        &#34;verify_hostname&#34;: true,&#xA;        &#34;cert&#34;: &#34;&#34;,&#xA;        &#34;cipher&#34;: &#34;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:AES128-SHA:AES256-SHA:DES-CBC3-SHA&#34;,&#xA;        &#34;cipher_tls13&#34;: &#34;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&#34;,&#xA;        &#34;sni&#34;: &#34;&#34;,&#xA;        &#34;alpn&#34;: [&#xA;            &#34;h2&#34;,&#xA;            &#34;http/1.1&#34;&#xA;        ],&#xA;        &#34;reuse_session&#34;: true,&#xA;        &#34;session_ticket&#34;: false,&#xA;        &#34;curves&#34;: &#34;&#34;&#xA;    },&#xA;    &#34;tcp&#34;: {&#xA;        &#34;no_delay&#34;: true,&#xA;        &#34;keep_alive&#34;: true,&#xA;        &#34;reuse_port&#34;: false,&#xA;        &#34;fast_open&#34;: false,&#xA;        &#34;fast_open_qlen&#34;: 20&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;ss-tproxy.conf&lt;/code&gt;启动和停止命令，例如&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#老版本(v4.6.0及以下)&#xA;#请确保proxy_svraddr/svrport与&#39;服务器地址/端口&#39;一致&#xA;tproxy=&#39;true&#39; #ipt2socks默认为tproxy模式&#xA;proxy_startcmd=&#39;(trojan -c /etc/trojan.json &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/trojan.log &amp;amp; ipt2socks &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/ipt2socks.log &amp;amp;)&#39;&#xA;proxy_stopcmd=&#39;kill -9 $(pidof trojan) $(pidof ipt2socks)&#39;&#xA;&#xA;#新版本(v4.6.1及以上)&#xA;#第一次运行时，请执行下面这两个操作&#xA;#1.创建proxy用户和组: useradd -Mr -d/tmp -s/bin/bash proxy&#xA;#2.授予透明代理相关权限: setcap cap_net_bind_service,cap_net_admin+ep /path/to/{trojan,ipt2socks}&#xA;#&amp;gt;&amp;gt; 若setcap不可用，可使用suid权限位，此时需配置：proxy_procuser=&#39;&#39;、proxy_procgroup=&#39;proxy&#39;&#xA;#&amp;gt;&amp;gt; 将所有者(组)改为root，并授予suid权限：chown root:root /path/to/{trojan,ipt2socks} &amp;amp;&amp;amp; chmod 4755 /path/to/{trojan,ipt2socks}&#xA;tproxy=&#39;true&#39; #ipt2socks默认为tproxy模式&#xA;proxy_procuser=&#39;proxy&#39;&#xA;proxy_startcmd=&#39;su proxy -c&#34;(trojan -c /etc/trojan.json &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/trojan.log &amp;amp; ipt2socks &amp;lt;/dev/null &amp;amp;&amp;gt;&amp;gt;/var/log/ipt2socks.log &amp;amp;)&#34;&#39;&#xA;proxy_stopcmd=&#39;kill -9 $(pidof trojan) $(pidof ipt2socks)&#39;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;/details&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;如果觉得配置和修改&lt;code&gt;proxy_startcmd&lt;/code&gt;、&lt;code&gt;proxy_stopcmd&lt;/code&gt;太麻烦（如经常切换节点），可参考：&lt;a href=&#34;https://raw.githubusercontent.com/zfl9/ss-tproxy/master/#%E5%88%87%E6%8D%A2%E4%BB%A3%E7%90%86%E5%B0%8F%E6%8A%80%E5%B7%A7&#34;&gt;切换代理小技巧&lt;/a&gt;&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;IPv6 透明代理的实施方式&lt;/h2&gt; &#xA;&lt;p&gt;ss-tproxy v4.0 版本需要利用 ULA 地址进行 IPv6 透明代理，而且还有许多要注意的事项，体验不是很好；但 v4.6 版本不需要任何额外的配置，如果想使用 IPv6 透明代理，直接启用 &lt;code&gt;ipv6&lt;/code&gt; 选项即可，使用方法完全同 IPv4 透明代理。当然，v4.6 版本依旧可以使用 ULA 地址来进行 IPv6 透明代理（比如忍受不了 GUA 地址总是变化），使用 ULA 地址做透明代理时需要注意一点：将 ss-tproxy.conf 中的 &lt;code&gt;ipts_set_snat6&lt;/code&gt; 选项设为 true，作用是防止 ULA 地址在公网上被路由。&lt;/p&gt; &#xA;&lt;h2&gt;非标准的 IPv4 内网地址段&lt;/h2&gt; &#xA;&lt;p&gt;标准内网地址段如：&lt;code&gt;10.0.0.0/8&lt;/code&gt;、&lt;code&gt;172.16.0.0/12&lt;/code&gt;、&lt;code&gt;192.168.0.0/16&lt;/code&gt;，如果你将其它 IP 段作为内网使用（有人甚至将公网 IP 段作为内网使用），那么强烈建议你纠正这个错误，这不仅会导致透明代理出问题，也会隐藏其它 bug（很多软件设计者并没有考虑到你使用的是一个非标准内网地址段）。如果因为各种原因无法更改（比如公司内部），那么解决办法只有一个，编辑 ss-tproxy.conf，添加 &lt;code&gt;post_start()&lt;/code&gt; 钩子函数，将当前使用的非标网段加入到 &lt;code&gt;privaddr&lt;/code&gt; 这个 ipset 中。如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;post_start() {&#xA;    if is_global_mode || is_chnroute_mode; then&#xA;        # 假设非标网段为 172.172.172.0/24&#xA;        ipset add privaddr 172.172.172.0/24&#xA;    fi&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;钩子函数&lt;/h2&gt; &#xA;&lt;p&gt;ss-tproxy 脚本支持 4 个钩子函数，分别是：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;pre_start&lt;/code&gt;：启动前执行&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;post_start&lt;/code&gt;：启动后执行&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;pre_stop&lt;/code&gt;：停止前执行&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;post_stop&lt;/code&gt;：停止后执行&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;需要注意的是，shell 中的函数是不允许重复定义的，虽然这不会有任何报错，但是实际只有最后一个函数生效&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;举个例子，我需要在 ss-tproxy 启动后添加某些规则，在 ss-tproxy 停止后删除这些规则，则修改 ss-tproxy.conf，添加：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;post_start() {&#xA;    iptables -A ...&#xA;    iptables -A ...&#xA;    iptables -A ...&#xA;}&#xA;&#xA;post_stop() {&#xA;    iptables -D ...&#xA;    iptables -D ...&#xA;    iptables -D ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;当然，对于这种需要添加 iptables 规则的情况，可以考虑将 iptables 规则添加到 ss-tproxy 的自定义链上，这些自定义链在 ss-tproxy 停止后会自动删除，因此你只需要关心 &lt;code&gt;post_start()&lt;/code&gt; 钩子函数的内容；目前有这几个自定义链：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ipts -t mangle -N SSTP_PREROUTING&#xA;$ipts -t mangle -N SSTP_OUTPUT&#xA;$ipts -t nat    -N SSTP_PREROUTING&#xA;$ipts -t nat    -N SSTP_OUTPUT&#xA;$ipts -t nat    -N SSTP_POSTROUTING&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;它们分别挂接到去掉 &lt;code&gt;SSTP_&lt;/code&gt; 前缀的同名预定义链上，如下：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ipts -t mangle -A PREROUTING  -j SSTP_PREROUTING&#xA;$ipts -t mangle -A OUTPUT      -j SSTP_OUTPUT&#xA;$ipts -t nat    -A PREROUTING  -j SSTP_PREROUTING&#xA;$ipts -t nat    -A OUTPUT      -j SSTP_OUTPUT&#xA;$ipts -t nat    -A POSTROUTING -j SSTP_POSTROUTING&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;脚本开机自启&lt;/h2&gt; &#xA;&lt;p&gt;对于 &lt;code&gt;SysVinit&lt;/code&gt; 发行版，直接在 &lt;code&gt;/etc/rc.d/rc.local&lt;/code&gt; 开机脚本中加上 ss-tproxy 的启动命令即可：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/usr/local/bin/ss-tproxy start&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;对于 &lt;code&gt;Systemd&lt;/code&gt; 发行版，将 ss-tproxy.service 文件放到 &lt;code&gt;/etc/systemd/system/ss-tproxy.service&lt;/code&gt;，执行：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl daemon-reload&#xA;systemctl enable ss-tproxy&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;不建议使用 &lt;code&gt;systemctl start|stop|restart ss-tproxy&lt;/code&gt; 来操作 ss-tproxy，此服务文件应仅作开机自启用。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;脚本命令行选项&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy help&lt;/code&gt;：查看帮助信息&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy version&lt;/code&gt;：查看版本号&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy start&lt;/code&gt;：启动透明代理&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy stop&lt;/code&gt;：关闭透明代理&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy restart&lt;/code&gt;：重启透明代理&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy status&lt;/code&gt;：查看代理状态&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy show-iptables&lt;/code&gt;：查看当前的 iptables 规则&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy flush-postrule&lt;/code&gt;：清空遗留的 iptables 规则&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy flush-dnscache&lt;/code&gt;：清空 dnsmasq 的查询缓存&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy delete-gfwlist&lt;/code&gt;：删除 gfwlist 黑名单 ipset&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy update-chnlist&lt;/code&gt;：更新 chnlist（restart 生效）&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy update-gfwlist&lt;/code&gt;：更新 gfwlist（restart 生效）&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ss-tproxy update-chnroute&lt;/code&gt;：更新 chnroute（restart 生效）&lt;/li&gt; &#xA; &lt;li&gt;在任意位置指定 &lt;code&gt;-x&lt;/code&gt; 选项可启用调试，如 &lt;code&gt;ss-tproxy start -x&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;在任意位置指定 &lt;code&gt;-c cfgfile&lt;/code&gt; 可使用给定路径的 ss-tproxy.conf&lt;/li&gt; &#xA; &lt;li&gt;在任意位置指定 &lt;code&gt;NAME=VALUE&lt;/code&gt; 可覆盖 ss-tproxy.conf 中的同名配置&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;何时使用&lt;code&gt;delete-gfwlist&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;在&lt;code&gt;gfwlist/chnlist&lt;/code&gt;模式下，执行了&lt;code&gt;update-gfwlist|update-chnlist&lt;/code&gt;或修改了&lt;code&gt;/etc/ss-tproxy/gfwlist.ext&lt;/code&gt;，则建议&lt;code&gt;start&lt;/code&gt;前执行此指令，防止遗留的&lt;code&gt;gfwlist&lt;/code&gt;列表导致问题。注意，执行此指令后，可能还需清空内网主机的dns缓存，并重启相关被代理的应用，如正在使用的浏览器。&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;关于特殊配置项与&lt;code&gt;restart&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;如果需要修改某些特殊配置项，请先&lt;code&gt;ss-tproxy stop&lt;/code&gt;，再修改，再&lt;code&gt;ss-tproxy start&lt;/code&gt;生效；&lt;br&gt; 不要直接改配置并执行&lt;code&gt;ss-tproxy restart&lt;/code&gt;，这会导致不可预估的错误，需要遵循约定的有：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;ipv4&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ipv6&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;proxy_stopcmd&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ipts_rt_tab&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;ipts_rt_mark&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;opts_overwrite_resolv&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;file_dnsserver_pid&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;对于其它配置项，都可以在改完配置后，执行&lt;code&gt;ss-tproxy restart&lt;/code&gt;命令来生效，无需遵循上述约定&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;黑名单、白名单说明&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;对于 global 模式，白名单文件为 &lt;code&gt;ignlist.ext&lt;/code&gt;，没有黑名单文件，因为默认都走代理。&lt;/li&gt; &#xA; &lt;li&gt;对于 gfwlist 模式，黑名单文件为 &lt;code&gt;gfwlist.txt/ext&lt;/code&gt;，没有白名单文件，因为其它都走直连。&lt;/li&gt; &#xA; &lt;li&gt;对于 chnroute 模式，白名单文件为 &lt;code&gt;ignlist.ext&lt;/code&gt;，没有黑名单文件，但允许开启此功能，见下。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;如果想让 chnroute 模式支持黑名单扩展，请打开 chinadns-ng 的 gfwlist 模式（&lt;code&gt;chinadns_gfwlist_mode&lt;/code&gt;）；开启 gfwlist 模式后，chinadns-ng 会读取 &lt;code&gt;gfwlist.txt/ext&lt;/code&gt; 黑名单文件中的&lt;strong&gt;域名模式&lt;/strong&gt;；当 chinadns-ng 收到域名解析请求时，会先检查给定域名是否在黑名单中，如果是则只向可信 DNS 发出解析请求（也就是 &lt;code&gt;dns_remote/dns_remote6&lt;/code&gt;），因此解析出来的会是国外 IP（不一定，具体要看给定域名的A/AAAA记录以及其dns解析设定），然后当客户端访问该 IP 时就会走代理出去了（如果解析的地址是国外地址）。&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;&lt;code&gt;chinadns_gfwlist_mode&lt;/code&gt;的本意其实并不是为了支持&#39;黑名单&#39;，而是为了提高 chinadns-ng 的准确性，降低 dns 污染的可能性&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;内网主机tcp限速&lt;/h2&gt; &#xA;&lt;p&gt;首先限速的原理很简单，就是将超过规定速率的包给丢掉（限速一般只针对tcp，udp很少有这种需求），丢掉超过规定速率的包之后，在TCP发送方看来，就是对方(接收方)没收到我发出去的包，也就是“丢包”了，于是会触发TCP的重传机制，于是就达到了限速的目的。&lt;/p&gt; &#xA;&lt;p&gt;一个简单的例子（这些iptables规则在ss-tproxy主机设置）：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 连接级别&#xA;# 192.168.1.0/24网段的主机，每条tcp连接，上传限速100kb/s&#xA;iptables -t mangle -I PREROUTING -p tcp -s 192.168.1.0/24 -m hashlimit --hashlimit-name upload --hashlimit-mode srcip,srcport --hashlimit-above 100kb/s -j DROP&#xA;&#xA;# 192.168.1.0/24网段的主机，每条tcp连接，下载限速100kb/s&#xA;iptables -t mangle -I POSTROUTING -p tcp -d 192.168.1.0/24 -m hashlimit --hashlimit-name download --hashlimit-mode dstip,dstport --hashlimit-above 100kb/s -j DROP&#xA;&#xA;## 主机级别&#xA;# 192.168.1.0/24网段的主机，每个内网ip，上传限速100kb/s&#xA;iptables -t mangle -I PREROUTING -p tcp -s 192.168.1.0/24 -m hashlimit --hashlimit-name upload --hashlimit-mode srcip --hashlimit-above 100kb/s -j DROP&#xA;&#xA;# 192.168.1.0/24网段的主机，每个内网ip，下载限速100kb/s&#xA;iptables -t mangle -I POSTROUTING -p tcp -d 192.168.1.0/24 -m hashlimit --hashlimit-name download --hashlimit-mode dstip --hashlimit-above 100kb/s -j DROP&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;如果是要限制从直连网站下载的速度，要设置一条snat规则，不然限速是不会有效的 ( 因为数据包直接由光猫/路由器发到内网客户机了，不会经过ss-tproxy主机）：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;iptables -t nat -A POSTROUTING -p tcp -s 192.168.1.0/24 -j MASQUERADE&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;可以利用&lt;code&gt;post_start&lt;/code&gt;钩子函数来设置这些规则，然后利用&lt;code&gt;post_stop&lt;/code&gt;来清理这些规则（把&lt;code&gt;-I&lt;/code&gt;/&lt;code&gt;-A&lt;/code&gt;改为&lt;code&gt;-D&lt;/code&gt;就是删除）。&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;钩子函数小技巧&lt;/h2&gt; &#xA;&lt;p&gt;1、某些系统的 TPROXY 模块可能需要手动加载，对于这种情况，可以利用 &lt;code&gt;pre_start()&lt;/code&gt; 钩子来加载它：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pre_start() {&#xA;    # 加载 TPROXY 模块&#xA;    modprobe xt_TPROXY&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;2、不想让某些内网主机走 ss-tproxy 的透明代理，即使它们将网关设为 ss-tproxy 主机，那么可以这么做：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;post_start() {&#xA;    if is_false &#34;$selfonly&#34;; then&#xA;        if is_true &#34;$ipv4&#34;; then&#xA;            # 定义要放行的 IPv4 地址&#xA;            local intranet_ignore_list=(192.168.1.100 192.168.1.200)&#xA;            for ipaddr in &#34;${intranet_ignore_list[@]}&#34;; do&#xA;                iptables -t mangle -I SSTP_PREROUTING -s $ipaddr -j RETURN&#xA;                iptables -t nat    -I SSTP_PREROUTING -s $ipaddr -j RETURN&#xA;            done&#xA;        fi&#xA;&#xA;        if is_true &#34;$ipv6&#34;; then&#xA;            # 定义要放行的 IPv6 地址&#xA;            local intranet_ignore_list6=(fd00&lt;span&gt;🔡&lt;/span&gt;:1111 fd00&lt;span&gt;🔡&lt;/span&gt;:2222)&#xA;            for ipaddr in &#34;${intranet_ignore_list6[@]}&#34;; do&#xA;                ip6tables -t mangle -I SSTP_PREROUTING -s $ipaddr -j RETURN&#xA;                ip6tables -t nat    -I SSTP_PREROUTING -s $ipaddr -j RETURN&#xA;            done&#xA;        fi&#xA;    fi&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;切换代理小技巧&lt;/h2&gt; &#xA;&lt;p&gt;如果觉得切换代理要修改 ss-tproxy.conf 很麻烦，可以这么做：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;将&lt;code&gt;proxy_startcmd&lt;/code&gt;和&lt;code&gt;proxy_stopcmd&lt;/code&gt;改为空调用，即&lt;code&gt;proxy_startcmd=&#39;true&#39;&lt;/code&gt;、&lt;code&gt;proxy_stopcmd=&#39;true&#39;&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;然后配好&lt;code&gt;proxy_procuser/group&lt;/code&gt;或&lt;code&gt;proxy_svraddr/port&lt;/code&gt;(不建议用此机制)，将所有可能会用到的值都填进去&lt;/li&gt; &#xA; &lt;li&gt;最后执行&lt;code&gt;ss-tproxy start&lt;/code&gt;启动，因为我们没有填写任何代理进程的启动和停止命令，所以会显示代理进程未运行，没关系，现在我们要做的就是启动对应的代理进程，假设为 ss-redir 且使用 systemd 管理，则执行 &lt;code&gt;systemctl start ss-redir&lt;/code&gt;，现在你再执行 &lt;code&gt;ss-tproxy status&lt;/code&gt; 就会看到对应的状态正常了，当然代理应该也是正常的，如果需要换为 v2ray，假设也是使用 systemd 管理，那么只需要先关闭 ss-redir，然后再启动 v2ray 就行了，即 &lt;code&gt;systemctl stop ss-redir&lt;/code&gt;、&lt;code&gt;systemctl start v2ray&lt;/code&gt;。有点类似于启动一个代理框架，后面切换代理就无需再操作 ss-tproxy，直接切换&lt;code&gt;本机代理进程&lt;/code&gt;即可&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;常见问题解答&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/zfl9/ss-tproxy/wiki/Linux-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&#34;&gt;ss-tproxy 常见问题解答&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;如果透明代理未正常工作，请先自行按照如下顺序进行一个简单的排查：&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;检查 ss-tproxy.conf 以及代理软件的配置是否正确，此文详细说明了许多配置细节，它们并不是废话，请务必仔细阅读此文。如果确认配置无误，那么请务必开启代理进程的详细日志（debug/verbose logging），以及 dnsmasq、chinadns-ng、dns2tcp 的详细日志（ss-tproxy.conf），日志是调试的基础。&lt;/li&gt; &#xA; &lt;li&gt;如果 ss-tproxy 在配置正确的情况下出现运行时报错，请在执行 ss-tproxy 相关命令时带上 &lt;code&gt;-x&lt;/code&gt; 调试选项，以查看是哪条命令报的错。出现这种错误通常是脚本自身的问题，可直接通过 issue 报告此错误，但是你需要提供尽可能详细的信息，别一句话就应付了我，这等同于应付了你自己。&lt;/li&gt; &#xA; &lt;li&gt;如果 ss-tproxy status 显示的状态不正常，那么通常都是配置问题，&lt;code&gt;pxy/tcp&lt;/code&gt; 显示 stopped 表示代理进程的 TCP 端口未监听，&lt;code&gt;pxy/udp&lt;/code&gt; 显示 stopped 表示代理进程的 UDP 端口未监听，&lt;code&gt;dnsmasq&lt;/code&gt;、&lt;code&gt;chinadns-ng&lt;/code&gt;、&lt;code&gt;dns2tcp&lt;/code&gt; 显示 stopped 时请查看它们各自的日志文件，可能是监听端口被占用了，等等。&lt;/li&gt; &#xA; &lt;li&gt;在 ss-tproxy 主机上检查 DNS 是否正常，域名解析是访问互联网的第一步，这一步如果出问题，后面的就不用测试了。这里选择 dig 作为 DNS 调试工具，因此请先安装 dig 工具。在调试 DNS 之前，先开启几个终端，分别 &lt;code&gt;tail -f&lt;/code&gt; 代理进程、dnsmasq、chinadns-ng、dns2tcp 的日志；然后再开一个终端，执行 &lt;code&gt;dig www.baidu.com&lt;/code&gt;、&lt;code&gt;dig www.google.com&lt;/code&gt;，观察 dig 以及前面几个终端的日志输出，发现不对的地方可以先尝试自行解决，如果解决不了，请通过 issue 报告它。如果启用了 udp 透明代理，要特别注意代理的 udp relay 是否正常，udp relay 不正常会导致 &lt;code&gt;dig www.google.com&lt;/code&gt; 解析失败；如果确认已开启 udp relay，那么你还要注意是否出现了 udp 丢包，某些 ISP 会对 udp 数据包进行恶意性丢弃，检查 udp 是否丢包通常需要检查本地以及 vps 上的代理进程的详细日志输出。实在不行就只能使用 tcponly 模式了。&lt;/li&gt; &#xA; &lt;li&gt;如果 ss-tproxy 主机的 DNS 工作正常，说明 UDP 透明代理应该是正常的，那么接下来应该检查 TCP 透明代理，最简单的方式就是使用 curl 工具进行检测，首先安装 curl 工具，然后执行 &lt;code&gt;curl -4vsSkL https://www.baidu.com&lt;/code&gt;、&lt;code&gt;curl -4vsSkL https://www.google.com&lt;/code&gt;，如果启用了 ss-tproxy 的 IPv6 透明代理支持，则还应该进行 IPv6 的网页浏览测试，即执行 &lt;code&gt;curl -6vsSkL https://ipv6.baidu.com&lt;/code&gt;、&lt;code&gt;curl -6vsSkL https://ipv6.google.com&lt;/code&gt;，观察它们的输出是否正常（即是否能够正常获取 HTML 源码），同时观察代理进程、dnsmasq、chinadns-ng、dns2tcp 的日志输出。&lt;/li&gt; &#xA; &lt;li&gt;如果 ss-tproxy 主机的 DNS 以及 curl 测试都没问题，那么就进行最后一步，在其它内网主机上分别测试 DNS 以及 TCP 透明代理（最简单的就是浏览器访问百度、谷歌），同时你也应该观察代理进程、dnsmasq、chinadns-ng、dns2tcp 的日志输出。对于某些系统，可能会优先使用 IPv6 网络（特别是解析 DNS 时），因此如果你没有启用 ss-tproxy 的 IPv6 透明代理，那么请通过各种手段禁用 IPv6（或者进行其它一些妥当的处理），否则会影响透明代理的正常使用。&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;在报告问题时，请务必提供详细信息，而不是单纯一句话，xxx 不能工作，这对于问题的解决没有任何帮助。&lt;/p&gt; &#xA;&lt;/blockquote&gt;</summary>
  </entry>
</feed>