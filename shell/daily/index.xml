<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2024-06-09T01:37:16Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>hackerb9/lsix</title>
    <updated>2024-06-09T01:37:16Z</updated>
    <id>tag:github.com,2024-06-09:/hackerb9/lsix</id>
    <link href="https://github.com/hackerb9/lsix" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Like &#34;ls&#34;, but for images. Shows thumbnails in terminal using sixel graphics.&lt;/p&gt;&lt;hr&gt;&lt;img align=&#34;right&#34; src=&#34;https://raw.githubusercontent.com/hackerb9/lsix/master/README.md.d/thumb.png&#34;&gt; &#xA;&lt;h1&gt;lsix&lt;/h1&gt; &#xA;&lt;p&gt;Like &#34;ls&#34;, but for images. Shows thumbnails in terminal using &lt;a href=&#34;https://en.wikipedia.org/wiki/Sixel&#34;&gt;sixel&lt;/a&gt; graphics.&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;lsix [ FILES ... ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Examples&lt;/h2&gt; &#xA;&lt;h3&gt;Basic Usage&lt;/h3&gt; &#xA;&lt;p&gt;Just typing &lt;code&gt;lsix&lt;/code&gt; will show images in the current working directory. You can also specify filenames and, of course, use shell wild cards (e.g., &lt;code&gt;lsix *jpg *png&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Because lsix uses ImageMagick pretty much any image format will be supported. However, some may be slow to render (like PDF), so lsix doesn&#39;t show them unless you ask specifically. If you want to force a listing of a certain type of image simply specify the filenames or use a wildcard (&lt;code&gt;*.pdf&lt;/code&gt; in the example below),.&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hackerb9/lsix/master/README.md.d/example1.png&#34; alt=&#34;Example 1 of lsix usage&#34; title=&#34;Most basic usage&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Expanding GIFs&lt;/h3&gt; &#xA;&lt;p&gt;If you specify a GIF (or actually any file that has multiple images in it) on the command line, all the frames will get expanded and shown in a montage. For example, &lt;code&gt;lsix nyancat.gif&lt;/code&gt; shows all the frames. Note that GIF stores some frames as only the pixels that differ from the previous frame. &lt;img src=&#34;https://raw.githubusercontent.com/hackerb9/lsix/master/README.md.d/example2.png&#34; alt=&#34;Example 2 of lsix usage&#34; title=&#34;GIFs get expanded&#34;&gt;&lt;/p&gt; &#xA;&lt;h3&gt;Terminal background color is detected&lt;/h3&gt; &#xA;&lt;p&gt;You may have noticed that PNGs and SVG files have correct alpha channel for the terminal background. That is because lsix uses terminal escape sequences to try to figure out your foreground and background colors. (Foreground is used for the text fill color.)&lt;/p&gt; &#xA;&lt;p&gt;In the first example below, after running &lt;code&gt;lsix&lt;/code&gt; in a white on black xterm, I sent an escape sequence to swap foreground and background colors. When I ran it again, &lt;code&gt;lsix&lt;/code&gt; detected it and changed the background color to white. Of course, you can pick whatever default colors you want (e.g., &lt;code&gt;xterm -bg blue&lt;/code&gt;, in the second example below).&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hackerb9/lsix/master/README.md.d/example3.png&#34; alt=&#34;Example 3 of lsix usage&#34; title=&#34;Reverse video works&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/hackerb9/lsix/master/README.md.d/example4.png&#34; alt=&#34;Example 4 of lsix usage&#34; title=&#34;Even &#39;xterm -bg blue&#39; works&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;Detects if your terminal can display SIXEL graphics inline using &lt;a href=&#34;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Sixel-Graphics&#34;&gt;control sequences&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Works great over ssh. Perfect for manipulating those images on the web server when you can&#39;t quite remember what each one was.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Non-bitmap graphics often work fine (.svg, .eps, .pdf, .xcf).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatically detects if your terminal, like xterm, can increase the number of color registers to improve the image quality and does so.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Automatically detects terminal&#39;s foreground and background colors.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;In terminals that support dtterm WindowOps, the number of tiles per row will adjust appropriately to the window width.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If there are many images in a directory (&amp;gt;21), lsix will display them one row at a time so you don&#39;t need to wait for the entire montage to be created.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If your filenames are too long, lsix will wrap the text before passing it into ImageMagick&#39;s &lt;code&gt;montage&lt;/code&gt;. (Without lsix, &lt;code&gt;montage&lt;/code&gt; just jumbles long filenames on top of one another.)&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;You can easily change things like the width of each tile in the montage, the font family, and point size by editing simple variables at the top of the file. &lt;em&gt;(Tip: try &lt;code&gt;convert -list font&lt;/code&gt; to see what fonts you have on your machine.)&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Unicode filenames work fine, as long as your font has the glyphs.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;Just put the &lt;a href=&#34;https://raw.githubusercontent.com/hackerb9/lsix/master/lsix&#34;&gt;&lt;code&gt;lsix&lt;/code&gt;&lt;/a&gt; file in your path (e.g., /usr/local/bin) and run it. It&#39;s just a BASH shell script.&lt;/p&gt; &#xA;&lt;p&gt;The only prerequisite software is ImageMagick. If you don&#39;t have it yet, your OS&#39;s package manager will make it easy to get. (E.g., &lt;code&gt;apt-get install imagemagick&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;MacOS users may prefer to install lsix using &lt;code&gt;brew install lsix&lt;/code&gt; which installs ImageMagick, if necessary.&lt;/p&gt; &#xA;&lt;h2&gt;Your Terminal must support Sixel graphics&lt;/h2&gt; &#xA;&lt;p&gt;I developed this using &lt;a href=&#34;https://invisible-island.net/xterm/&#34;&gt;xterm&lt;/a&gt; in vt340 emulation mode, but I believe this should work on any Sixel compatible terminal. You may test your terminal by viewing a single image, like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;convert  foo.jpg  -geometry 800x480  sixel:- &#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;XTerm&lt;/h3&gt; &#xA;&lt;p&gt;Note that xterm does not have Sixel mode enabled by default, so you need to either run it like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;xterm -ti vt340&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Or, make vt340 the default terminal type for xterm. Add the following to your &lt;code&gt;.Xresources&lt;/code&gt; file and run &lt;code&gt;xrdb -merge .Xresources&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;! Allow sixel graphics. (Try: &#34;convert -colors 16 foo.jpg sixel:-&#34;).&#xA;xterm*decTerminalID&#x9;:&#x9;vt340&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Further, some distributions, such as Fedora, appear to not compile &lt;code&gt;xterm&lt;/code&gt; with sixel support. In that case, try an alternate terminal, such as &lt;code&gt;foot&lt;/code&gt; or &lt;code&gt;mlterm&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;SIXEL compatible terminals&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;XTerm (tested)&lt;/li&gt; &#xA; &lt;li&gt;MLterm (tested)&lt;/li&gt; &#xA; &lt;li&gt;foot (tested)&lt;/li&gt; &#xA; &lt;li&gt;Wezterm (tested)&lt;/li&gt; &#xA; &lt;li&gt;Contour (tested)&lt;/li&gt; &#xA; &lt;li&gt;iTerm2 for Apple MacOS (tested)&lt;/li&gt; &#xA; &lt;li&gt;Konsole (reported)&lt;/li&gt; &#xA; &lt;li&gt;yakuake (reported)&lt;/li&gt; &#xA; &lt;li&gt;WSLtty for Microsoft Windows (reported)&lt;/li&gt; &#xA; &lt;li&gt;MinTTY for Cygwin (Microsoft Windows) (reported)&lt;/li&gt; &#xA; &lt;li&gt;Yaft for Linux framebuffer (tested)&lt;/li&gt; &#xA; &lt;li&gt;VTE (special compilation, reported)&lt;/li&gt; &#xA; &lt;li&gt;sixel-tmux (fork of tmux, reported)&lt;/li&gt; &#xA; &lt;li&gt;ttyd (reported)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;SIXEL incompatible terminals&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;MacOS Terminal, kitty&lt;/li&gt; &#xA; &lt;li&gt;All standard libvte based terminals &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;gnome-terminal&lt;/li&gt; &#xA;   &lt;li&gt;terminator&lt;/li&gt; &#xA;   &lt;li&gt;lxterm&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Alacritty (might work with &lt;a href=&#34;https://github.com/alacritty/alacritty/pull/4763&#34;&gt;a patch&lt;/a&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;Because &lt;code&gt;lsix&lt;/code&gt; is currently designed to be very simple, there are no command line flags, no configuration files, no knobs to twiddle, or frobs to frobnosticate. However, since the script is so simple, if you want to make a change, it&#39;s pretty easy to do just by editing the file. Everything is nicely commented with the most common default variables at the top.&lt;/p&gt; &#xA;&lt;h2&gt;Contact the author&lt;/h2&gt; &#xA;&lt;p&gt;I welcome feedback. If you use lsix and like it or have suggestions for how it can be improved, please go ahead and send your thoughts to me &lt;a href=&#34;https://github.com/hackerb9/lsix/issues/new&#34;&gt;@hackerb9&lt;/a&gt; via GitHub.&lt;/p&gt; &#xA;&lt;h2&gt;Bugs&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;XTerm&#39;s reverse video mode (&lt;code&gt;xterm -rv&lt;/code&gt;) is different from specifying the foreground and background explicitly. There is a way to detect the latter, but not the former. That means the background color will be incorrect for folks who use XTerm&#39;s reverseVideo resource. (See issue #20).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;XTerm&#39;s screen width is currently limited to 1000px due to a misfeature which causes it to silently show nothing. This limitation will be removed once xterm can handle images greater than 1000x1000. [Last tested with XTerm(344)].&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Filenames that begin with &#34;@&#34; are special to ImageMagick and it&#39;ll freak out if you don&#39;t prepend a directory. (&lt;code&gt;lsix ./@foo.png&lt;/code&gt;) (This is a bug in ImageMagick, not lsix).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Specifying the empty string &lt;code&gt;&#34;&#34;&lt;/code&gt; as a filename makes ImageMagick hang. (This appears to be an ImageMagick bug / misfeature).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Long filenames are wrapped, but not intelligently. Would it complicate this script too much to make it prefer to wrap on whites space, dashes, underscores, and periods? Maybe.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;Directories specified on the command line are processed as if the user had cd&#39;d to that directory. It wouldn&#39;t be hard to implement recursion, but is there actually a need? I&#39;m reluctant to complicate such a simple script with command line flags.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;If you run &lt;code&gt;lsix foo.avi&lt;/code&gt;, you&#39;re asking for trouble.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Future Issues&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;The Sixel standard doesn&#39;t appear to have a way to query the size of the graphics screen. Reading the VT340 documentation, it appears your program has to already know the resolution of the device you&#39;re rendering on.&lt;/p&gt; &lt;p&gt;XTerm, as of version 344, has added &lt;a href=&#34;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Functions-using-CSI-_-ordered-by-the-final-character_s_&#34;&gt;a control sequence&lt;/a&gt; that solves the problem — &lt;code&gt;CSI ? Pi ; Pa ; Pv S&lt;/code&gt; — but some terminals, for example &lt;code&gt;mlterm&lt;/code&gt;, haven&#39;t yet implemented it.&lt;/p&gt; &lt;p&gt;There is an alternate way to read the window size using the dtterm WindowOps extension but it is not quite the right solution as the geometry of the Sixel graphics screen is not necessarily the same as the window size. (For example, xterm limits the graphics geometry to 1000x1000, even though the window can actually be larger.) To help with terminals such as mlterm, &lt;code&gt;lsix&lt;/code&gt; will use the dtterm WindowOps as a fallback.&lt;/p&gt; &lt;p&gt;If neither solution works, &lt;code&gt;lsix&lt;/code&gt; will assume you are on a VT340 (800x480) and can fit only 6 tiles per row.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The Sixel standard also lacks a way to query the number of color registers available. I used the extensions from &lt;code&gt;xterm&lt;/code&gt; to do so, but I do not know how widely implemented they are. If a terminal does not respond, &lt;code&gt;lsix&lt;/code&gt; presumes you&#39;re on an original vt340 and uses only 16 color registers. (Sorry, 4-gray vt330 users! Time to upgrade. ;-) )&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;The &lt;a href=&#34;https://kermitproject.org/&#34;&gt;Kermit project&lt;/a&gt; created a MS-DOS terminal emulator that was popular in the late 1980s/early 1990s. Its sixel implementation is not compatible with lsix because it shows the graphics on a screen separate from the text. However, I noticed one feature in its documentation: an escape sequence to request the current graphics window size and number of colors:&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code&gt; ESC [ ? 256 n                  Request screen size report&#xA;&#xA;        Report is ESC [ ? 256; Ph; Pw; Pc n     for graphics systems&#xA;&#xA;        where   Ph is screen height in dots&#xA;                Pw is screen width in dots&#xA;                Pc is number of colors (0, 1 or 16, for none, b/w, ega/vga)&#xA;&#xA;        Report is ESC [ ? 24; 80; 0 n  for pure text mono systems.&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Did any other terminal emulators ever use the sequence? Would it be worthwhile to add to &lt;code&gt;lsix&lt;/code&gt;?&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/saitoha/libsixel&#34;&gt;libsixel&lt;/a&gt; is an excellent project for writing programs that can output optimized Sixel graphics commands. Because I have a lot of respect for the project, I feel I should explain why &lt;code&gt;lsix&lt;/code&gt; does not use libsixel.&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;(a) I wanted lsix to work everywhere easily. Bash and imagemagick are ubiquitous, so a shell script is a natural solution.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;(b) I wanted &lt;code&gt;lsix&lt;/code&gt; to be simple enough that it could be easily customized and extended by other people. (Including myself.)&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;(c) ImageMagick has better support for reading different formats than stb_image (the library used by libsixel&#39;s &lt;code&gt;img2sixel&lt;/code&gt;). (For example: xpm, svg, 16-bit png, and even sixel files are not recognized by img2sixel). Since ImageMagick can read all of those and write sixel output directly, it made sense to use it for both.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;(d) While libsixel is optimized and would surely be faster than ImageMagick, it&#39;s overkill. For a simple directory listing, this is plenty fast enough.&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Resources&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&#34;&gt;XTerm Control Sequences&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://imagemagick.org/&#34;&gt;ImageMagick&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://vt100.net/docs/vt3xx-gp/&#34;&gt;VT340 Programmer&#39;s Reference&lt;/a&gt;:&lt;/p&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://vt100.net/docs/vt3xx-gp/chapter14.html&#34;&gt;Chapter 14&lt;/a&gt;. Sixel Graphics.&lt;/p&gt; &lt;/li&gt; &#xA;   &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://vt100.net/docs/vt3xx-gp/chapter16.html#S16.3&#34;&gt;Chapter 16&lt;/a&gt; Difference between Level 1 and Level 2 Sixel implementations.&lt;/p&gt; &lt;p&gt;&lt;em&gt;Nota bene: this reference has the sense for DECSDM (sixel display mode) reversed! The actual behaviour of the VT340 is that when DECSDM is reset (the default), sixel scrolling is enabled. This can be done by sending &lt;em&gt;&lt;code&gt;Esc[?80l&lt;/code&gt;&lt;/em&gt;, but lsix does not do so as it would break many current terminal emulators. See issue #41 for details.&lt;/em&gt;&lt;/p&gt; &lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://archive.org/details/bitsavers_decstandar0VideoSystemsReferenceManualDec91_74264381&#34;&gt;DEC STD 070 Video Systems Reference Manual&lt;/a&gt;. A weighty tome which covers nearly everything in exacting detail. I referred mostly to sections 4 (escape sequences) and 9 (sixel programming).&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;https://github.com/hackerb9/vt340test&#34;&gt;VT340 Test&lt;/a&gt;, a project to document the actual behaviour of the DEC VT340 hardware.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;a href=&#34;http://www.vaxhaven.com/images/f/f7/EK-PPLV2-PM-B01.pdf&#34;&gt;Digital ANSI-Compliant Printing Protocol: Level 2 Programming Reference Manual&lt;/a&gt;, Chapter 5: Sixel Graphics. An excellent and reasonably clear discussion for anyone who wants to generate or parse sixel graphics.&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>DaoCloud/public-image-mirror</title>
    <updated>2024-06-09T01:37:16Z</updated>
    <id>tag:github.com,2024-06-09:/DaoCloud/public-image-mirror</id>
    <link href="https://github.com/DaoCloud/public-image-mirror" rel="alternate"></link>
    <summary type="html">&lt;p&gt;很多镜像都在国外。比如 gcr 。国内下载很慢，需要加速。&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;public-image-mirror&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/DaoCloud/public-image-mirror/raw/gh-pages/daocloud-sync.log&#34;&gt;&lt;img src=&#34;https://github.com/DaoCloud/public-image-mirror/raw/gh-pages/daocloud-sync-badge.svg?sanitize=true&#34; alt=&#34;Sync&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Sync: 定期同步列表里的 image tag 的同步率, 只要 tag 存在就是同步的.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;!!!!!!!!!!!!!!!!!!!!!!!!通知!!!!!!!!!!!!!!!!!!!!!!!!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;由于近期个别 Image 和 IP 存在大流量, 近期将会进行屏蔽 如果有大量需求的&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/wzshiming/crproxy/tree/master/examples/default&#34;&gt;可以自己搭建服务器&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;或者提个 Issue 商量或邮件联系&lt;/li&gt; &#xA; &lt;li&gt;当前 IP 限流 20r/m (每分钟20个请求)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;背景&lt;/h2&gt; &#xA;&lt;p&gt;很多镜像都在国外。比如 gcr 。国内下载很慢，需要加速。&lt;/p&gt; &#xA;&lt;h2&gt;目标&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;一个简洁有效的方法能够加速这些包。简洁的名称映射&lt;/li&gt; &#xA; &lt;li&gt;易于添加，添加新的包，不需要去修改代码。&lt;/li&gt; &#xA; &lt;li&gt;稳定可靠，更新实时。每天检查同步情况。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;快速开始&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker run -d -P m.daocloud.io/docker.io/library/nginx&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;使用方法&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;增加前缀&lt;/strong&gt; (推荐方式)。比如：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;k8s.gcr.io/coredns/coredns =&amp;gt; m.daocloud.io/k8s.gcr.io/coredns/coredns&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;或者 支持的镜像仓库 的 &lt;em&gt;前缀替换&lt;/em&gt; 就可以使用。比如：&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;k8s.gcr.io/coredns/coredns =&amp;gt; k8s-gcr.m.daocloud.io/coredns/coredns&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;单次单镜像同步&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;!!!!!!!!!!!!!!!!!!!!!!!!强烈推荐!!!!!!!!!!!!!!!!!!!!!!!!&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;您可以根据 &lt;a href=&#34;https://github.com/DaoCloud/public-image-mirror/issues/new?labels=sync+image&amp;amp;template=sync-image.yml&#34;&gt;镜像同步 Issue 模板&lt;/a&gt; 创建一个 Issue, 将会有机器人帮您优先主动同步指定的镜像&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;原先已经在下的镜像还是会继续走原来的, 需要重启 docker 再重新拉取才能走已经同步好的缓存过, 所以推荐先单次同步再尝试拉取 对于 latest 这种经常内容会发生变更的 tag 变更后会需要重新同步&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;每个 Issue &lt;strong&gt;带宽&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;国际带宽 3 * 50 Mbps&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;懒加载&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;仅推荐用于小于 20MiB 的镜像 这条通道主要用于保持 image 是最新的, 每次拉取都会检查是否和上游保持同步&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;如果您看到下没有进度这是由于带宽有限只要有几人在下较大的文件就会阻塞后续的下载, 可以尝试&lt;a href=&#34;https://raw.githubusercontent.com/DaoCloud/public-image-mirror/main/#%E5%8D%95%E6%AC%A1%E5%8D%95%E9%95%9C%E5%83%8F%E5%90%8C%E6%AD%A5&#34;&gt;单次单镜像同步&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;就算没同步也能 &lt;strong&gt;直接拉取&lt;/strong&gt;, 初次拉取会比已经同步过的慢.&lt;/p&gt; &#xA;&lt;p&gt;所有懒加载 &lt;strong&gt;带宽&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;国际带宽 3 * 30 Mbps&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;定期同步列表&lt;/h2&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;不推荐, 由于数量已经比较多了初次提交, 到被同步到需要很长时间&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;p&gt;强烈建议使用&lt;a href=&#34;https://raw.githubusercontent.com/DaoCloud/public-image-mirror/main/#%E5%8D%95%E6%AC%A1%E5%8D%95%E9%95%9C%E5%83%8F%E5%90%8C%E6%AD%A5&#34;&gt;单次单镜像同步&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/DaoCloud/public-image-mirror/main/mirror.txt&#34;&gt;mirror.txt&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;如果想要新增, 提 PR 修改即可。例如 &lt;a href=&#34;https://github.com/DaoCloud/public-image-mirror/pull/1/&#34;&gt;PR#1&lt;/a&gt;， 并请在 PR 提交前排序： &lt;code&gt;./hack/fmt.sh mirror.txt&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;支持前缀替换的 Registry&lt;/h2&gt; &#xA;&lt;p&gt;前缀替换的 Registry 的规则, 这是人工配置的, 有需求提 Issue.&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;源站&lt;/th&gt; &#xA;   &lt;th&gt;替换为&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;cr.l5d.io&lt;/td&gt; &#xA;   &lt;td&gt;l5d.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker.elastic.co&lt;/td&gt; &#xA;   &lt;td&gt;elastic.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;docker.io&lt;/td&gt; &#xA;   &lt;td&gt;docker.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;gcr.io&lt;/td&gt; &#xA;   &lt;td&gt;gcr.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;ghcr.io&lt;/td&gt; &#xA;   &lt;td&gt;ghcr.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;k8s.gcr.io&lt;/td&gt; &#xA;   &lt;td&gt;k8s-gcr.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;registry.k8s.io&lt;/td&gt; &#xA;   &lt;td&gt;k8s.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;mcr.microsoft.com&lt;/td&gt; &#xA;   &lt;td&gt;mcr.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;nvcr.io&lt;/td&gt; &#xA;   &lt;td&gt;nvcr.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;quay.io&lt;/td&gt; &#xA;   &lt;td&gt;quay.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;registry.jujucharms.com&lt;/td&gt; &#xA;   &lt;td&gt;jujucharms.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;rocks.canonical.com&lt;/td&gt; &#xA;   &lt;td&gt;rocks-canonical.m.daocloud.io&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;最佳实践&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;通过 加速 安装 kubeadm&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeadm config images pull --image-repository k8s-gcr.m.daocloud.io&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;通过 加速 安装 kind&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kind create cluster --name kind --image m.daocloud.io/docker.io/kindest/node:v1.22.1&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;通过 加速 部署 应用(这里以 Ingress 为例)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget -O image-filter.sh https://github.com/DaoCloud/public-image-mirror/raw/main/hack/image-filter.sh &amp;amp;&amp;amp; chmod +x image-filter.sh&#xA;&#xA;wget -O deploy.yaml https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.0/deploy/static/provider/baremetal/deploy.yaml&#xA;&#xA;cat ./deploy.yaml | ./image-filter.sh | kubectl apply -f -&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Docker 加速&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;添加到 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &#34;registry-mirrors&#34;: [&#xA;    &#34;https://docker.m.daocloud.io&#34;&#xA;  ]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;[友情链接]加速三剑客&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;镜像加速：&lt;a href=&#34;https://github.com/DaoCloud/public-image-mirror&#34;&gt;https://github.com/DaoCloud/public-image-mirror&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;二进制文件加速：&lt;a href=&#34;https://github.com/DaoCloud/public-binary-files-mirror&#34;&gt;https://github.com/DaoCloud/public-binary-files-mirror&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;Helm 加速：&lt;a href=&#34;https://github.com/DaoCloud/public-helm-charts-mirror&#34;&gt;https://github.com/DaoCloud/public-helm-charts-mirror&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;贡献者&lt;/h2&gt; &#xA;&lt;a href=&#34;https://github.com/DaoCloud/public-image-mirror/graphs/contributors&#34;&gt; &lt;img src=&#34;https://contrib.rocks/image?repo=DaoCloud/public-image-mirror&#34;&gt; &lt;/a&gt; &#xA;&lt;p&gt;Made with &lt;a href=&#34;https://contrib.rocks&#34;&gt;contrib.rocks&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>