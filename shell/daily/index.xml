<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2025-06-07T01:37:56Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>laude-institute/terminal-bench</title>
    <updated>2025-06-07T01:37:56Z</updated>
    <id>tag:github.com,2025-06-07:/laude-institute/terminal-bench</id>
    <link href="https://github.com/laude-institute/terminal-bench" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A benchmark for LLMs on complicated tasks in the terminal&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;terminal-bench&lt;/h1&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;#####################################################################&#xA;#  _____                   _             _     ______________       #&#xA;# |_   _|__ _ __ _ __ ___ (_)_ __   __ _| |   ||            ||      #&#xA;#   | |/ _ \ &#39;__| &#39;_ ` _ \| | &#39;_ \ / _` | |   || &amp;gt;          ||      #&#xA;#   | |  __/ |  | | | | | | | | | | (_| | |   ||            ||      #&#xA;#   |_|\___|_|  |_| |_| |_|_|_| |_|\__,_|_|   ||____________||      #&#xA;#   ____                  _                   |______________|      #&#xA;#  | __ )  ___ _ __   ___| |__                 \\############\\     #&#xA;#  |  _ \ / _ \ &#39;_ \ / __| &#39;_ \                 \\############\\    # &#xA;#  | |_) |  __/ | | | (__| | | |                 \      ____    \   #&#xA;#  |____/ \___|_| |_|\___|_| |_|                  \_____\___\____\  #&#xA;#                                                                   #&#xA;#####################################################################&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://discord.gg/6xWPKhGDbA&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Join_our_discord-5865F2?style=for-the-badge&amp;amp;logo=discord&amp;amp;logoColor=white&#34; alt=&#34;Discord&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://github.com/laude-institute/terminal-bench&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/T--Bench-000000?style=for-the-badge&amp;amp;logo=github&amp;amp;logoColor=000&amp;amp;logoColor=white&#34; alt=&#34;Github&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.tbench.ai/docs&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/Docs-000000?style=for-the-badge&amp;amp;logo=mdbook&amp;amp;color=105864&#34; alt=&#34;Docs&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;Terminal-Bench is the benchmark for testing AI agents in real terminal environments. From compiling code to training models and setting up servers, Terminal-Bench evaluates how well agents can handle real-world, end-to-end tasks - autonomously.&lt;/p&gt; &#xA;&lt;p&gt;Whether you&#39;re building LLM agents, benchmarking frameworks, or stress-testing system-level reasoning, Terminal-Bench gives you a reproducible task suite and execution harness designed for practical, real-world evaluation.&lt;/p&gt; &#xA;&lt;p&gt;Terminal-Bench consists of two parts: a &lt;strong&gt;dataset of tasks&lt;/strong&gt;, and an &lt;strong&gt;execution harness&lt;/strong&gt; that connects a language model to our terminal sandbox.&lt;/p&gt; &#xA;&lt;p&gt;Terminal-Bench is currently in an &lt;strong&gt;early beta phase&lt;/strong&gt; with ~100 tasks. Over the coming months, we are going to expand Terminal-Bench into comprehensive testbed for AI agents in text-based environments. Any contributions are welcome, especially new and challenging tasks!&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Our &lt;a href=&#34;https://www.tbench.ai/docs/installation&#34;&gt;Quickstart Guide&lt;/a&gt; will walk you through installing the repo and contributing.&lt;/p&gt; &#xA;&lt;h2&gt;Further Documentation&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.tbench.ai/tasks&#34;&gt;Task Gallery&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.tbench.ai/docs/task-ideas&#34;&gt;Task Ideas&lt;/a&gt; - Browse community-sourced task ideas&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.tbench.ai/docs/dashboard&#34;&gt;Dashboard Documentation&lt;/a&gt; - Information about the Terminal-Bench dashboard&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Core Components&lt;/h2&gt; &#xA;&lt;h3&gt;Dataset of Tasks&lt;/h3&gt; &#xA;&lt;p&gt;Each task in Terminal-Bench includes&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;a description in English,&lt;/li&gt; &#xA; &lt;li&gt;a test script to verify if the language model / agent completed the task successfully,&lt;/li&gt; &#xA; &lt;li&gt;a reference (&#34;oracle&#34;) solution that solves the task.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Tasks are located in the &lt;a href=&#34;https://raw.githubusercontent.com/laude-institute/terminal-bench/main/tasks&#34;&gt;&lt;code&gt;dataset/tasks&lt;/code&gt;&lt;/a&gt; folder of the repository, and the aforementioned list of current tasks gives an overview that is easy to browse.&lt;/p&gt; &#xA;&lt;h3&gt;Execution Harness&lt;/h3&gt; &#xA;&lt;p&gt;The harness connects language models to a sandboxed terminal environment. After &lt;a href=&#34;https://www.tbench.ai/docs/installation&#34;&gt;installing the terminal-bench package&lt;/a&gt; (along with the dependencies &lt;code&gt;uv&lt;/code&gt; and &lt;code&gt;Docker&lt;/code&gt;) you can view how to run the harness using:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tb run --help&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For detailed information about running the harness and its options, see the &lt;a href=&#34;https://www.tbench.ai/docs/first-steps&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;terminal-bench-core v0.1.0&lt;/h3&gt; &#xA;&lt;p&gt;Terminal-Bench-Core v0.1.0 is the set of tasks for Terminal-Bench&#39;s beta release and corresponds to the current leaderboard. To evaluate on it pass &lt;code&gt;--dataset-name terminal-bench-core&lt;/code&gt; and &lt;code&gt;--dataset-version 0.1.0&lt;/code&gt; to the harness. For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tb run \&#xA;    --agent terminus \&#xA;    --model-name anthropic/claude-3-7-latest \&#xA;    --dataset-name terminal-bench-core&#xA;    --dataset-version 0.1.0&#xA;    --n-concurrent-trials 8&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;For more information on Terminal-Bench datasets and versioning view our &lt;a href=&#34;https://www.tbench.ai/docs/registry&#34;&gt;registry overview&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Creating New Tasks&lt;/h2&gt; &#xA;&lt;p&gt;View our &lt;a href=&#34;https://www.tbench.ai/docs/task-quickstart&#34;&gt;task contribution quickstart&lt;/a&gt; to create a new task.&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>graphql/graphql-spec</title>
    <updated>2025-06-07T01:37:56Z</updated>
    <id>tag:github.com,2025-06-07:/graphql/graphql-spec</id>
    <link href="https://github.com/graphql/graphql-spec" rel="alternate"></link>
    <summary type="html">&lt;p&gt;GraphQL is a query language and execution engine tied to any backend service.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;a href=&#34;https://graphql.org/conf/2025/?utm_source=github&amp;amp;utm_medium=graphql_js&amp;amp;utm_campaign=readme&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/graphql/graphql-spec/main/assets/graphql.org_conf_2025_.png&#34; alt=&#34;GraphQLConf 2025 Banner: September 08-10, Amsterdam. Hosted by the GraphQL Foundation&#34;&gt;&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;GraphQL&lt;/h1&gt; &#xA;&lt;img alt=&#34;GraphQL Logo&#34; align=&#34;right&#34; src=&#34;https://graphql.org/img/logo.svg?sanitize=true&#34; width=&#34;15%&#34;&gt; &#xA;&lt;p&gt;The GraphQL specification is edited in the markdown files found in &lt;a href=&#34;https://raw.githubusercontent.com/graphql/graphql-spec/main/spec&#34;&gt;&lt;code&gt;/spec&lt;/code&gt;&lt;/a&gt; the latest release of which is published at &lt;a href=&#34;https://graphql.github.io/graphql-spec/&#34;&gt;https://graphql.github.io/graphql-spec/&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The latest draft specification can be found at &lt;a href=&#34;https://graphql.github.io/graphql-spec/draft/&#34;&gt;https://graphql.github.io/graphql-spec/draft/&lt;/a&gt; which tracks the latest commit to the main branch in this repository.&lt;/p&gt; &#xA;&lt;p&gt;Previous releases of the GraphQL specification can be found at permalinks that match their &lt;a href=&#34;https://github.com/graphql/graphql-spec/releases&#34;&gt;release tag&lt;/a&gt;. For example, &lt;a href=&#34;https://graphql.github.io/graphql-spec/October2016/&#34;&gt;https://graphql.github.io/graphql-spec/October2016/&lt;/a&gt;. If you are linking directly to the GraphQL specification, it&#39;s best to link to a tagged permalink for the particular referenced version.&lt;/p&gt; &#xA;&lt;h2&gt;Overview&lt;/h2&gt; &#xA;&lt;p&gt;This is a Working Draft of the Specification for GraphQL, a query language for APIs created by Facebook.&lt;/p&gt; &#xA;&lt;p&gt;The target audience for this specification is not the client developer, but those who have, or are actively interested in, building their own GraphQL implementations and tools.&lt;/p&gt; &#xA;&lt;p&gt;In order to be broadly adopted, GraphQL will have to target a wide variety of backend environments, frameworks, and languages, which will necessitate a collaborative effort across projects and organizations. This specification serves as a point of coordination for this effort.&lt;/p&gt; &#xA;&lt;p&gt;Looking for help? Find resources &lt;a href=&#34;https://graphql.org/community/&#34;&gt;from the community&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Getting Started&lt;/h2&gt; &#xA;&lt;p&gt;GraphQL consists of a type system, query language and execution semantics, static validation, and type introspection, each outlined below. To guide you through each of these components, we&#39;ve written an example designed to illustrate the various pieces of GraphQL.&lt;/p&gt; &#xA;&lt;p&gt;This example is not comprehensive, but it is designed to quickly introduce the core concepts of GraphQL, to provide some context before diving into the more detailed specification or the &lt;a href=&#34;https://github.com/graphql/graphql-js&#34;&gt;GraphQL.js&lt;/a&gt; reference implementation.&lt;/p&gt; &#xA;&lt;p&gt;The premise of the example is that we want to use GraphQL to query for information about characters and locations in the original Star Wars trilogy.&lt;/p&gt; &#xA;&lt;h3&gt;Type System&lt;/h3&gt; &#xA;&lt;p&gt;At the heart of any GraphQL implementation is a description of what types of objects it can return, described in a GraphQL type system and returned in the GraphQL Schema.&lt;/p&gt; &#xA;&lt;p&gt;For our Star Wars example, the &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/__tests__/starWarsSchema.ts&#34;&gt;starWarsSchema.ts&lt;/a&gt; file in GraphQL.js defines this type system.&lt;/p&gt; &#xA;&lt;p&gt;The most basic type in the system will be &lt;code&gt;Human&lt;/code&gt;, representing characters like Luke, Leia, and Han. All humans in our type system will have a name, so we define the &lt;code&gt;Human&lt;/code&gt; type to have a field called &#34;name&#34;. This returns a String, and we know that it is not null (since all &lt;code&gt;Human&lt;/code&gt;s have a name), so we will define the &#34;name&#34; field to be a non-nullable String. Using a shorthand notation that we will use throughout the spec and documentation, we would describe the human type as:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;type Human {&#xA;  name: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This shorthand is convenient for describing the basic shape of a type system; the JavaScript implementation is more full-featured, and allows types and fields to be documented. It also sets up the mapping between the type system and the underlying data; for a test case in GraphQL.js, the underlying data is a &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/__tests__/starWarsData.ts&#34;&gt;set of JavaScript objects&lt;/a&gt;, but in most cases the backing data will be accessed through some service, and this type system layer will be responsible for mapping from types and fields to that service.&lt;/p&gt; &#xA;&lt;p&gt;A common pattern in many APIs, and indeed in GraphQL is to give objects an ID that can be used to refetch the object. So let&#39;s add that to our Human type. We&#39;ll also add a string for their home planet.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;type Human {&#xA;  id: String&#xA;  name: String&#xA;  homePlanet: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since we&#39;re talking about the Star Wars trilogy, it would be useful to describe the episodes in which each character appears. To do so, we&#39;ll first define an enum, which lists the three episodes in the trilogy:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;enum Episode {&#xA;  NEWHOPE&#xA;  EMPIRE&#xA;  JEDI&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we want to add a field to &lt;code&gt;Human&lt;/code&gt; describing what episodes they were in. This will return a list of &lt;code&gt;Episode&lt;/code&gt;s:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;type Human {&#xA;  id: String&#xA;  name: String&#xA;  appearsIn: [Episode]&#xA;  homePlanet: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now, let&#39;s introduce another type, &lt;code&gt;Droid&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;type Droid {&#xA;  id: String&#xA;  name: String&#xA;  appearsIn: [Episode]&#xA;  primaryFunction: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now we have two types! Let&#39;s add a way of going between them: humans and droids both have friends. But humans can be friends with both humans and droids. How do we refer to either a human or a droid?&lt;/p&gt; &#xA;&lt;p&gt;If we look, we note that there&#39;s common functionality between humans and droids; they both have IDs, names, and episodes in which they appear. So we&#39;ll add an interface, &lt;code&gt;Character&lt;/code&gt;, and make both &lt;code&gt;Human&lt;/code&gt; and &lt;code&gt;Droid&lt;/code&gt; implement it. Once we have that, we can add the &lt;code&gt;friends&lt;/code&gt; field, that returns a list of &lt;code&gt;Character&lt;/code&gt;s.&lt;/p&gt; &#xA;&lt;p&gt;Our type system so far is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;enum Episode {&#xA;  NEWHOPE&#xA;  EMPIRE&#xA;  JEDI&#xA;}&#xA;&#xA;interface Character {&#xA;  id: String&#xA;  name: String&#xA;  friends: [Character]&#xA;  appearsIn: [Episode]&#xA;}&#xA;&#xA;type Human implements Character {&#xA;  id: String&#xA;  name: String&#xA;  friends: [Character]&#xA;  appearsIn: [Episode]&#xA;  homePlanet: String&#xA;}&#xA;&#xA;type Droid implements Character {&#xA;  id: String&#xA;  name: String&#xA;  friends: [Character]&#xA;  appearsIn: [Episode]&#xA;  primaryFunction: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One question we might ask, though, is whether any of those fields can return &lt;code&gt;null&lt;/code&gt;. By default, &lt;code&gt;null&lt;/code&gt; is a permitted value for any type in GraphQL, since fetching data to fulfill a GraphQL query often requires talking to different services that may or may not be available. However, if the type system can guarantee that a type is never null, then we can mark it as Non Null in the type system. We indicate that in our shorthand by adding an &#34;!&#34; after the type. We can update our type system to note that the &lt;code&gt;id&lt;/code&gt; is never null.&lt;/p&gt; &#xA;&lt;p&gt;Note that while in our current implementation, we can guarantee that more fields are non-null (since our current implementation has hard-coded data), we didn&#39;t mark them as non-null. One can imagine we would eventually replace our hardcoded data with a backend service, which might not be perfectly reliable; by leaving these fields as nullable, we allow ourselves the flexibility to eventually return null to indicate a backend error, while also telling the client that the error occurred.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;enum Episode {&#xA;  NEWHOPE&#xA;  EMPIRE&#xA;  JEDI&#xA;}&#xA;&#xA;interface Character {&#xA;  id: String!&#xA;  name: String&#xA;  friends: [Character]&#xA;  appearsIn: [Episode]&#xA;}&#xA;&#xA;type Human implements Character {&#xA;  id: String!&#xA;  name: String&#xA;  friends: [Character]&#xA;  appearsIn: [Episode]&#xA;  homePlanet: String&#xA;}&#xA;&#xA;type Droid implements Character {&#xA;  id: String!&#xA;  name: String&#xA;  friends: [Character]&#xA;  appearsIn: [Episode]&#xA;  primaryFunction: String&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;re missing one last piece: an entry point into the type system.&lt;/p&gt; &#xA;&lt;p&gt;When we define a schema, we define an object type that is the basis for all query operations. The name of this type is &lt;code&gt;Query&lt;/code&gt; by convention, and it describes our public, top-level API. Our &lt;code&gt;Query&lt;/code&gt; type for this example will look like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;type Query {&#xA;  hero(episode: Episode): Character&#xA;  human(id: String!): Human&#xA;  droid(id: String!): Droid&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In this example, there are three top-level operations that can be done on our schema:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;hero&lt;/code&gt; returns the &lt;code&gt;Character&lt;/code&gt; who is the hero of the Star Wars trilogy; it takes an optional argument that allows us to fetch the hero of a specific episode instead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;human&lt;/code&gt; accepts a non-null string as a query argument, a human&#39;s ID, and returns the human with that ID.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;droid&lt;/code&gt; does the same for droids.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;These fields demonstrate another feature of the type system, the ability for a field to specify arguments that configure their behavior.&lt;/p&gt; &#xA;&lt;p&gt;When we package the whole type system together, defining the &lt;code&gt;Query&lt;/code&gt; type above as our entry point for queries, this creates a GraphQL Schema.&lt;/p&gt; &#xA;&lt;p&gt;This example just scratched the surface of the type system. The specification goes into more detail about this topic in the &#34;Type System&#34; section, and the &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/type&#34;&gt;type&lt;/a&gt; directory in GraphQL.js contains code implementing a specification-compliant GraphQL type system.&lt;/p&gt; &#xA;&lt;h3&gt;Query Syntax&lt;/h3&gt; &#xA;&lt;p&gt;GraphQL queries declaratively describe what data the issuer wishes to fetch from whoever is fulfilling the GraphQL query.&lt;/p&gt; &#xA;&lt;p&gt;For our Star Wars example, the &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/__tests__/starWarsQuery-test.ts&#34;&gt;starWarsQueryTests.js&lt;/a&gt; file in the GraphQL.js repository contains a number of queries and responses. That file is a test file that uses the schema discussed above and a set of sample data, located in &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/__tests__/starWarsData.ts&#34;&gt;starWarsData.js&lt;/a&gt;. This test file can be run to exercise the reference implementation.&lt;/p&gt; &#xA;&lt;p&gt;An example query on the above schema would be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query HeroNameQuery {&#xA;  hero {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The initial line, &lt;code&gt;query HeroNameQuery&lt;/code&gt;, defines a query with the operation name &lt;code&gt;HeroNameQuery&lt;/code&gt; that starts with the schema&#39;s root query type; in this case, &lt;code&gt;Query&lt;/code&gt;. As defined above, &lt;code&gt;Query&lt;/code&gt; has a &lt;code&gt;hero&lt;/code&gt; field that returns a &lt;code&gt;Character&lt;/code&gt;, so we&#39;ll query for that. &lt;code&gt;Character&lt;/code&gt; then has a &lt;code&gt;name&lt;/code&gt; field that returns a &lt;code&gt;String&lt;/code&gt;, so we query for that, completing our query. The result of this query would then be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hero&#34;: {&#xA;    &#34;name&#34;: &#34;R2-D2&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Specifying the &lt;code&gt;query&lt;/code&gt; keyword and an operation name is only required when a GraphQL document defines multiple operations. We therefore could have written the previous query with the query shorthand:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;{&#xA;  hero {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Assuming that the backing data for the GraphQL server identified R2-D2 as the hero. The response continues to vary based on the request; if we asked for R2-D2&#39;s ID and friends with this query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query HeroNameAndFriendsQuery {&#xA;  hero {&#xA;    id&#xA;    name&#xA;    friends {&#xA;      id&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;then we&#39;ll get back a response like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hero&#34;: {&#xA;    &#34;id&#34;: &#34;2001&#34;,&#xA;    &#34;name&#34;: &#34;R2-D2&#34;,&#xA;    &#34;friends&#34;: [&#xA;      {&#xA;        &#34;id&#34;: &#34;1000&#34;,&#xA;        &#34;name&#34;: &#34;Luke Skywalker&#34;&#xA;      },&#xA;      {&#xA;        &#34;id&#34;: &#34;1002&#34;,&#xA;        &#34;name&#34;: &#34;Han Solo&#34;&#xA;      },&#xA;      {&#xA;        &#34;id&#34;: &#34;1003&#34;,&#xA;        &#34;name&#34;: &#34;Leia Organa&#34;&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;One of the key aspects of GraphQL is its ability to nest queries. In the above query, we asked for R2-D2&#39;s friends, but we can ask for more information about each of those objects. So let&#39;s construct a query that asks for R2-D2&#39;s friends, gets their name and episode appearances, then asks for each of &lt;em&gt;their&lt;/em&gt; friends.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query NestedQuery {&#xA;  hero {&#xA;    name&#xA;    friends {&#xA;      name&#xA;      appearsIn&#xA;      friends {&#xA;        name&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;which will give us the nested response&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hero&#34;: {&#xA;    &#34;name&#34;: &#34;R2-D2&#34;,&#xA;    &#34;friends&#34;: [&#xA;      {&#xA;        &#34;name&#34;: &#34;Luke Skywalker&#34;,&#xA;        &#34;appearsIn&#34;: [&#34;NEWHOPE&#34;, &#34;EMPIRE&#34;, &#34;JEDI&#34;],&#xA;        &#34;friends&#34;: [&#xA;          { &#34;name&#34;: &#34;Han Solo&#34; },&#xA;          { &#34;name&#34;: &#34;Leia Organa&#34; },&#xA;          { &#34;name&#34;: &#34;C-3PO&#34; },&#xA;          { &#34;name&#34;: &#34;R2-D2&#34; }&#xA;        ]&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Han Solo&#34;,&#xA;        &#34;appearsIn&#34;: [&#34;NEWHOPE&#34;, &#34;EMPIRE&#34;, &#34;JEDI&#34;],&#xA;        &#34;friends&#34;: [&#xA;          { &#34;name&#34;: &#34;Luke Skywalker&#34; },&#xA;          { &#34;name&#34;: &#34;Leia Organa&#34; },&#xA;          { &#34;name&#34;: &#34;R2-D2&#34; }&#xA;        ]&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Leia Organa&#34;,&#xA;        &#34;appearsIn&#34;: [&#34;NEWHOPE&#34;, &#34;EMPIRE&#34;, &#34;JEDI&#34;],&#xA;        &#34;friends&#34;: [&#xA;          { &#34;name&#34;: &#34;Luke Skywalker&#34; },&#xA;          { &#34;name&#34;: &#34;Han Solo&#34; },&#xA;          { &#34;name&#34;: &#34;C-3PO&#34; },&#xA;          { &#34;name&#34;: &#34;R2-D2&#34; }&#xA;        ]&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;Query&lt;/code&gt; type above defined a way to fetch a human given their ID. We can use it by hard-coding the ID in the query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query FetchLukeQuery {&#xA;  human(id: &#34;1000&#34;) {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;to get&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;human&#34;: {&#xA;    &#34;name&#34;: &#34;Luke Skywalker&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Alternately, we could have defined the query to have a query parameter:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query FetchSomeIDQuery($someId: String!) {&#xA;  human(id: $someId) {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This query is now parameterized by &lt;code&gt;$someId&lt;/code&gt;; to run it, we must provide that ID. If we ran it with &lt;code&gt;$someId&lt;/code&gt; set to &#34;1000&#34;, we would get Luke; set to &#34;1002&#34;, we would get Han. If we passed an invalid ID here, we would get &lt;code&gt;null&lt;/code&gt; back for the &lt;code&gt;human&lt;/code&gt;, indicating that no such object exists.&lt;/p&gt; &#xA;&lt;p&gt;Notice that the key in the response is the name of the field, by default. It is sometimes useful to change this key, for clarity or to avoid key collisions when fetching the same field with different arguments.&lt;/p&gt; &#xA;&lt;p&gt;We can do that with field aliases, as demonstrated in this query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query FetchLukeAliased {&#xA;  luke: human(id: &#34;1000&#34;) {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We aliased the result of the &lt;code&gt;human&lt;/code&gt; field to the key &lt;code&gt;luke&lt;/code&gt;. Now the response is:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;luke&#34;: {&#xA;    &#34;name&#34;: &#34;Luke Skywalker&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Notice the key is &#34;luke&#34; and not &#34;human&#34;, as it was in our previous example where we did not use the alias.&lt;/p&gt; &#xA;&lt;p&gt;This is particularly useful if we want to use the same field twice with different arguments, as in the following query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query FetchLukeAndLeiaAliased {&#xA;  luke: human(id: &#34;1000&#34;) {&#xA;    name&#xA;  }&#xA;  leia: human(id: &#34;1003&#34;) {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We aliased the result of the first &lt;code&gt;human&lt;/code&gt; field to the key &lt;code&gt;luke&lt;/code&gt;, and the second to &lt;code&gt;leia&lt;/code&gt;. So the result will be:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;luke&#34;: {&#xA;    &#34;name&#34;: &#34;Luke Skywalker&#34;&#xA;  },&#xA;  &#34;leia&#34;: {&#xA;    &#34;name&#34;: &#34;Leia Organa&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Now imagine we wanted to ask for Luke and Leia&#39;s home planets. We could do so with this query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query DuplicateFields {&#xA;  luke: human(id: &#34;1000&#34;) {&#xA;    name&#xA;    homePlanet&#xA;  }&#xA;  leia: human(id: &#34;1003&#34;) {&#xA;    name&#xA;    homePlanet&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;but we can already see that this could get unwieldy, since we have to add new fields to both parts of the query. Instead, we can extract out the common fields into a fragment, and include the fragment in the query, like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query UseFragment {&#xA;  luke: human(id: &#34;1000&#34;) {&#xA;    ...HumanFragment&#xA;  }&#xA;  leia: human(id: &#34;1003&#34;) {&#xA;    ...HumanFragment&#xA;  }&#xA;}&#xA;&#xA;fragment HumanFragment on Human {&#xA;  name&#xA;  homePlanet&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Both of those queries give this result:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;luke&#34;: {&#xA;    &#34;name&#34;: &#34;Luke Skywalker&#34;,&#xA;    &#34;homePlanet&#34;: &#34;Tatooine&#34;&#xA;  },&#xA;  &#34;leia&#34;: {&#xA;    &#34;name&#34;: &#34;Leia Organa&#34;,&#xA;    &#34;homePlanet&#34;: &#34;Alderaan&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The &lt;code&gt;UseFragment&lt;/code&gt; and &lt;code&gt;DuplicateFields&lt;/code&gt; queries will both get the same result, but &lt;code&gt;UseFragment&lt;/code&gt; is less verbose; if we wanted to add more fields, we could add it to the common fragment rather than copying it into multiple places.&lt;/p&gt; &#xA;&lt;p&gt;We defined the type system above, so we know the type of each object in the output; the query can ask for that type using the special field &lt;code&gt;__typename&lt;/code&gt;, defined on every object.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query CheckTypeOfR2 {&#xA;  hero {&#xA;    __typename&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Since R2-D2 is a droid, this will return&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hero&#34;: {&#xA;    &#34;__typename&#34;: &#34;Droid&#34;,&#xA;    &#34;name&#34;: &#34;R2-D2&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This was particularly useful because &lt;code&gt;hero&lt;/code&gt; was defined to return a &lt;code&gt;Character&lt;/code&gt;, which is an interface; we might want to know what concrete type was actually returned. If we instead asked for the hero of Episode V:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query CheckTypeOfLuke {&#xA;  hero(episode: EMPIRE) {&#xA;    __typename&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We would find that it was Luke, who is a Human:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;hero&#34;: {&#xA;    &#34;__typename&#34;: &#34;Human&#34;,&#xA;    &#34;name&#34;: &#34;Luke Skywalker&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;As with the type system, this example just scratched the surface of the query language. The specification goes into more detail about this topic in the &#34;Language&#34; section, and the &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/language&#34;&gt;language&lt;/a&gt; directory in GraphQL.js contains code implementing a specification-compliant GraphQL query language parser and lexer.&lt;/p&gt; &#xA;&lt;h3&gt;Validation&lt;/h3&gt; &#xA;&lt;p&gt;By using the type system, it can be predetermined whether a GraphQL query is valid or not. This allows servers and clients to effectively inform developers when an invalid query has been created, without having to rely on runtime checks.&lt;/p&gt; &#xA;&lt;p&gt;For our Star Wars example, the file &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/__tests__/starWarsValidation-test.ts&#34;&gt;starWarsValidationTests.js&lt;/a&gt; contains a number of demonstrations of invalid operations, and is a test file that can be run to exercise the reference implementation&#39;s validator.&lt;/p&gt; &#xA;&lt;p&gt;To start, let&#39;s take a complex valid query. This is the &lt;code&gt;NestedQuery&lt;/code&gt; example from the above section, but with the duplicated fields factored out into a fragment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query NestedQueryWithFragment {&#xA;  hero {&#xA;    ...NameAndAppearances&#xA;    friends {&#xA;      ...NameAndAppearances&#xA;      friends {&#xA;        ...NameAndAppearances&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;fragment NameAndAppearances on Character {&#xA;  name&#xA;  appearsIn&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And this query is valid. Let&#39;s take a look at some invalid queries!&lt;/p&gt; &#xA;&lt;p&gt;When we query for fields, we have to query for a field that exists on the given type. So as &lt;code&gt;hero&lt;/code&gt; returns a &lt;code&gt;Character&lt;/code&gt;, we have to query for a field on &lt;code&gt;Character&lt;/code&gt;. That type does not have a &lt;code&gt;favoriteSpaceship&lt;/code&gt; field, so this query:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;# INVALID: favoriteSpaceship does not exist on Character&#xA;query HeroSpaceshipQuery {&#xA;  hero {&#xA;    favoriteSpaceship&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;is invalid.&lt;/p&gt; &#xA;&lt;p&gt;Whenever we query for a field and it returns something other than a scalar or an enum, we need to specify what data we want to get back from the field. Hero returns a &lt;code&gt;Character&lt;/code&gt;, and we&#39;ve been requesting fields like &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;appearsIn&lt;/code&gt; on it; if we omit that, the query will not be valid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;# INVALID: hero is not a scalar, so fields are needed&#xA;query HeroNoFieldsQuery {&#xA;  hero&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Similarly, if a field is a scalar, it doesn&#39;t make sense to query for additional fields on it, and doing so will make the query invalid:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;# INVALID: name is a scalar, so fields are not permitted&#xA;query HeroFieldsOnScalarQuery {&#xA;  hero {&#xA;    name {&#xA;      firstCharacterOfName&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Earlier, it was noted that a query can only query for fields on the type in question; when we query for &lt;code&gt;hero&lt;/code&gt; which returns a &lt;code&gt;Character&lt;/code&gt;, we can only query for fields that exist on &lt;code&gt;Character&lt;/code&gt;. What happens if we want to query for R2-D2s primary function, though?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;# INVALID: primaryFunction does not exist on Character&#xA;query DroidFieldOnCharacter {&#xA;  hero {&#xA;    name&#xA;    primaryFunction&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;That query is invalid, because &lt;code&gt;primaryFunction&lt;/code&gt; is not a field on &lt;code&gt;Character&lt;/code&gt;. We want some way of indicating that we wish to fetch &lt;code&gt;primaryFunction&lt;/code&gt; if the &lt;code&gt;Character&lt;/code&gt; is a &lt;code&gt;Droid&lt;/code&gt;, and to ignore that field otherwise. We can use the fragments we introduced earlier to do this. By setting up a fragment defined on &lt;code&gt;Droid&lt;/code&gt; and including it, we ensure that we only query for &lt;code&gt;primaryFunction&lt;/code&gt; where it is defined.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query DroidFieldInFragment {&#xA;  hero {&#xA;    name&#xA;    ...DroidFields&#xA;  }&#xA;}&#xA;&#xA;fragment DroidFields on Droid {&#xA;  primaryFunction&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This query is valid, but it&#39;s a bit verbose; named fragments were valuable above when we used them multiple times, but we&#39;re only using this one once. Instead of using a named fragment, we can use an inline fragment; this still allows us to indicate the type we are querying on, but without naming a separate fragment:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query DroidFieldInInlineFragment {&#xA;  hero {&#xA;    name&#xA;    ... on Droid {&#xA;      primaryFunction&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This has just scratched the surface of the validation system; there are a number of validation rules in place to ensure that a GraphQL query is semantically meaningful. The specification goes into more detail about this topic in the &#34;Validation&#34; section, and the &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/validation&#34;&gt;validation&lt;/a&gt; directory in GraphQL.js contains code implementing a specification-compliant GraphQL validator.&lt;/p&gt; &#xA;&lt;h3&gt;Introspection&lt;/h3&gt; &#xA;&lt;p&gt;It&#39;s often useful to ask a GraphQL schema for information about what queries it supports. GraphQL allows us to do so using the introspection system!&lt;/p&gt; &#xA;&lt;p&gt;For our Star Wars example, the file &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/__tests__/starWarsIntrospection-test.ts&#34;&gt;starWarsIntrospectionTests.js&lt;/a&gt; contains a number of queries demonstrating the introspection system, and is a test file that can be run to exercise the reference implementation&#39;s introspection system.&lt;/p&gt; &#xA;&lt;p&gt;We designed the type system, so we know what types are available, but if we didn&#39;t, we can ask GraphQL, by querying the &lt;code&gt;__schema&lt;/code&gt; field, always available on the root type of a Query. Let&#39;s do so now, and ask what types are available.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionTypeQuery {&#xA;  __schema {&#xA;    types {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__schema&#34;: {&#xA;    &#34;types&#34;: [&#xA;      {&#xA;        &#34;name&#34;: &#34;Query&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Character&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Human&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;String&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Episode&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Droid&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__Schema&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__Type&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__TypeKind&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;Boolean&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__Field&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__InputValue&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__EnumValue&#34;&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;__Directive&#34;&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Wow, that&#39;s a lot of types! What are they? Let&#39;s group them:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;Query, Character, Human, Episode, Droid&lt;/strong&gt; - These are the ones that we defined in our type system.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;String, Boolean&lt;/strong&gt; - These are built-in scalars that the type system provided.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;&lt;code&gt;__Schema&lt;/code&gt;, &lt;code&gt;__Type&lt;/code&gt;, &lt;code&gt;__TypeKind&lt;/code&gt;, &lt;code&gt;__Field&lt;/code&gt;, &lt;code&gt;__InputValue&lt;/code&gt;, &lt;code&gt;__EnumValue&lt;/code&gt;, &lt;code&gt;__Directive&lt;/code&gt;&lt;/strong&gt; - These all are preceded with a double underscore, indicating that they are part of the introspection system.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Now, let&#39;s try and figure out a good place to start exploring what queries are available. When we designed our type system, we specified what type all queries would start at; let&#39;s ask the introspection system about that!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionQueryTypeQuery {&#xA;  __schema {&#xA;    queryType {&#xA;      name&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__schema&#34;: {&#xA;    &#34;queryType&#34;: {&#xA;      &#34;name&#34;: &#34;Query&#34;&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And that matches what we said in the type system section, that the &lt;code&gt;Query&lt;/code&gt; type is where we will start! Note that the naming here was just by convention; we could have named our &lt;code&gt;Query&lt;/code&gt; type anything else, and it still would have been returned here if we had specified it as the starting type for queries. Naming it &lt;code&gt;Query&lt;/code&gt;, though, is a useful convention.&lt;/p&gt; &#xA;&lt;p&gt;It is often useful to examine one specific type. Let&#39;s take a look at the &lt;code&gt;Droid&lt;/code&gt; type:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionDroidTypeQuery {&#xA;  __type(name: &#34;Droid&#34;) {&#xA;    name&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__type&#34;: {&#xA;    &#34;name&#34;: &#34;Droid&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;What if we want to know more about Droid, though? For example, is it an interface or an object?&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionDroidKindQuery {&#xA;  __type(name: &#34;Droid&#34;) {&#xA;    name&#xA;    kind&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__type&#34;: {&#xA;    &#34;name&#34;: &#34;Droid&#34;,&#xA;    &#34;kind&#34;: &#34;OBJECT&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;kind&lt;/code&gt; returns a &lt;code&gt;__TypeKind&lt;/code&gt; enum, one of whose values is &lt;code&gt;OBJECT&lt;/code&gt;. If we asked about &lt;code&gt;Character&lt;/code&gt; instead:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionCharacterKindQuery {&#xA;  __type(name: &#34;Character&#34;) {&#xA;    name&#xA;    kind&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__type&#34;: {&#xA;    &#34;name&#34;: &#34;Character&#34;,&#xA;    &#34;kind&#34;: &#34;INTERFACE&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;We&#39;d find that it is an interface.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s useful for an object to know what fields are available, so let&#39;s ask the introspection system about &lt;code&gt;Droid&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionDroidFieldsQuery {&#xA;  __type(name: &#34;Droid&#34;) {&#xA;    name&#xA;    fields {&#xA;      name&#xA;      type {&#xA;        name&#xA;        kind&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__type&#34;: {&#xA;    &#34;name&#34;: &#34;Droid&#34;,&#xA;    &#34;fields&#34;: [&#xA;      {&#xA;        &#34;name&#34;: &#34;id&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: null,&#xA;          &#34;kind&#34;: &#34;NON_NULL&#34;&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;name&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: &#34;String&#34;,&#xA;          &#34;kind&#34;: &#34;SCALAR&#34;&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;friends&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: null,&#xA;          &#34;kind&#34;: &#34;LIST&#34;&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;appearsIn&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: null,&#xA;          &#34;kind&#34;: &#34;LIST&#34;&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;primaryFunction&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: &#34;String&#34;,&#xA;          &#34;kind&#34;: &#34;SCALAR&#34;&#xA;        }&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Those are our fields that we defined on &lt;code&gt;Droid&lt;/code&gt;!&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;id&lt;/code&gt; looks a bit weird there, it has no name for the type. That&#39;s because it&#39;s a &#34;wrapper&#34; type of kind &lt;code&gt;NON_NULL&lt;/code&gt;. If we queried for &lt;code&gt;ofType&lt;/code&gt; on that field&#39;s type, we would find the &lt;code&gt;String&lt;/code&gt; type there, telling us that this is a non-null String.&lt;/p&gt; &#xA;&lt;p&gt;Similarly, both &lt;code&gt;friends&lt;/code&gt; and &lt;code&gt;appearsIn&lt;/code&gt; have no name, since they are the &lt;code&gt;LIST&lt;/code&gt; wrapper type. We can query for &lt;code&gt;ofType&lt;/code&gt; on those types, which will tell us what these are lists of.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionDroidWrappedFieldsQuery {&#xA;  __type(name: &#34;Droid&#34;) {&#xA;    name&#xA;    fields {&#xA;      name&#xA;      type {&#xA;        name&#xA;        kind&#xA;        ofType {&#xA;          name&#xA;          kind&#xA;        }&#xA;      }&#xA;    }&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;and we get back:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__type&#34;: {&#xA;    &#34;name&#34;: &#34;Droid&#34;,&#xA;    &#34;fields&#34;: [&#xA;      {&#xA;        &#34;name&#34;: &#34;id&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: null,&#xA;          &#34;kind&#34;: &#34;NON_NULL&#34;,&#xA;          &#34;ofType&#34;: {&#xA;            &#34;name&#34;: &#34;String&#34;,&#xA;            &#34;kind&#34;: &#34;SCALAR&#34;&#xA;          }&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;name&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: &#34;String&#34;,&#xA;          &#34;kind&#34;: &#34;SCALAR&#34;,&#xA;          &#34;ofType&#34;: null&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;friends&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: null,&#xA;          &#34;kind&#34;: &#34;LIST&#34;,&#xA;          &#34;ofType&#34;: {&#xA;            &#34;name&#34;: &#34;Character&#34;,&#xA;            &#34;kind&#34;: &#34;INTERFACE&#34;&#xA;          }&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;appearsIn&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: null,&#xA;          &#34;kind&#34;: &#34;LIST&#34;,&#xA;          &#34;ofType&#34;: {&#xA;            &#34;name&#34;: &#34;Episode&#34;,&#xA;            &#34;kind&#34;: &#34;ENUM&#34;&#xA;          }&#xA;        }&#xA;      },&#xA;      {&#xA;        &#34;name&#34;: &#34;primaryFunction&#34;,&#xA;        &#34;type&#34;: {&#xA;          &#34;name&#34;: &#34;String&#34;,&#xA;          &#34;kind&#34;: &#34;SCALAR&#34;,&#xA;          &#34;ofType&#34;: null&#xA;        }&#xA;      }&#xA;    ]&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Let&#39;s end with a feature of the introspection system particularly useful for tooling; let&#39;s ask the system for documentation!&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-graphql&#34;&gt;query IntrospectionDroidDescriptionQuery {&#xA;  __type(name: &#34;Droid&#34;) {&#xA;    name&#xA;    description&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;yields&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&#xA;  &#34;__type&#34;: {&#xA;    &#34;name&#34;: &#34;Droid&#34;,&#xA;    &#34;description&#34;: &#34;A mechanical creature in the Star Wars universe.&#34;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;So we can access the documentation about the type system using introspection, and create documentation browsers, or rich IDE experiences.&lt;/p&gt; &#xA;&lt;p&gt;This has just scratched the surface of the introspection system; we can query for enum values, what interfaces a type implements, and more. We can even introspect on the introspection system itself. The specification goes into more detail about this topic in the &#34;Introspection&#34; section, and the &lt;a href=&#34;https://github.com/graphql/graphql-js/raw/main/src/type/introspection.ts&#34;&gt;introspection&lt;/a&gt; file in GraphQL.js contains code implementing a specification-compliant GraphQL query introspection system.&lt;/p&gt; &#xA;&lt;h3&gt;Additional Content&lt;/h3&gt; &#xA;&lt;p&gt;This README walked through the GraphQL.js reference implementation&#39;s type system, query execution, validation, and introspection systems. There&#39;s more in both &lt;a href=&#34;https://github.com/graphql/graphql-js/&#34;&gt;GraphQL.js&lt;/a&gt; and specification, including a description and implementation for executing queries, how to format a response, explaining how a type system maps to an underlying implementation, and how to format a GraphQL response, as well as the grammar for GraphQL.&lt;/p&gt; &#xA;&lt;h3&gt;Contributing to this repo&lt;/h3&gt; &#xA;&lt;p&gt;This repository is managed by EasyCLA. Project participants must sign the free (&lt;a href=&#34;https://preview-spec-membership.graphql.org&#34;&gt;GraphQL Specification Membership agreement&lt;/a&gt; before making a contribution. You only need to do this one time, and it can be signed by &lt;a href=&#34;https://individual-spec-membership.graphql.org/&#34;&gt;individual contributors&lt;/a&gt; or their &lt;a href=&#34;https://corporate-spec-membership.graphql.org/&#34;&gt;employers&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;To initiate the signature process please open a PR against this repo. The EasyCLA bot will block the merge if we still need a membership agreement from you.&lt;/p&gt; &#xA;&lt;p&gt;You can find &lt;a href=&#34;https://github.com/graphql/graphql-wg/tree/main/membership&#34;&gt;detailed information here&lt;/a&gt;. If you have issues, please email &lt;a href=&#34;mailto:operations@graphql.org&#34;&gt;operations@graphql.org&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;If your company benefits from GraphQL and you would like to provide essential financial support for the systems and people that power our community, please also consider membership in the &lt;a href=&#34;https://foundation.graphql.org/join&#34;&gt;GraphQL Foundation&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>