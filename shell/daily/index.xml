<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2022-09-16T01:40:07Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>lm317379829/TVBoxDIY</title>
    <updated>2022-09-16T01:40:07Z</updated>
    <id>tag:github.com,2022-09-16:/lm317379829/TVBoxDIY</id>
    <link href="https://github.com/lm317379829/TVBoxDIY" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;TVBoxDIY&lt;/h1&gt; &#xA;&lt;p&gt;Fork：&lt;a href=&#34;https://github.com/CatVodTVOfficial/TVBoxOSC.git&#34;&gt;https://github.com/CatVodTVOfficial/TVBoxOSC.git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;源码：&lt;a href=&#34;https://github.com/lm317379829/TVBoxOSC.git&#34;&gt;https://github.com/lm317379829/TVBoxOSC.git&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h1&gt;说明&lt;/h1&gt; &#xA;&lt;p&gt;APK-J Build为本地爬虫-俊版，APK-T Build为本地爬虫taka版，APK-O Build为本地爬虫原版。APK-TV Build为本地爬虫Fongmi/TV版（暂时有问题，待修复）。&lt;/p&gt; &#xA;&lt;p&gt;diy-J.sh、diy-T.sh、diy-O.sh、diy-TV.sh分别为俊版、taka版、原版自定义脚本，可自行修改apk名、背景、图标以及其他源码内容。&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>MaherAzzouzi/CVE-2022-37706-LPE-exploit</title>
    <updated>2022-09-16T01:40:07Z</updated>
    <id>tag:github.com,2022-09-16:/MaherAzzouzi/CVE-2022-37706-LPE-exploit</id>
    <link href="https://github.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A reliable exploit + write-up to elevate privileges to root. (Tested on Ubuntu 22.04)&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;CVE-2022-37706&lt;/strong&gt;&lt;br&gt;&lt;br&gt; &lt;img src=&#34;https://user-images.githubusercontent.com/62230190/189902773-f603dffe-1a44-4c32-9052-d01dd40df02e.gif&#34; alt=&#34;CVE-2022-37706-poc-zoom&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;Hello guys, this time I&#39;m gonna talk about a recent 0-day I found in one of the&lt;br&gt; main window managers of Linux called Enlightenment (&lt;a href=&#34;https://www.enlightenment.org/&#34;&gt;https://www.enlightenment.org/&lt;/a&gt;).&lt;br&gt; This 0-day gonna take any user to root privileges very easily and instantly.&lt;br&gt; The exploit is tested on Ubuntu 22.04, but should work just fine on any distro.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;First of all Enlightenment is a Window Manager, Compositor and Minimal Desktop &lt;br&gt; for Linux (the primary platform), BSD and any other compatible UNIX system.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;I installed this window manager to experiment a bit with it. It was interesting&lt;br&gt; for me as it contain a lot of tools and it looks pretty neat to be honest.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;After I installed the package using &lt;code&gt;apt install enlightenment&lt;/code&gt; I examined the&lt;br&gt; installed files and directory on my system, a lot of modules and a lot of helper&lt;br&gt; binaries, but what is most interesting is :&lt;br&gt;&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;➜  enlightenment cd /usr/lib/x86_64-linux-gnu/enlightenment/&#xA;➜  enlightenment find . -perm -4000                         &#xA;./utils/enlightenment_ckpasswd&#xA;./utils/enlightenment_system&#xA;./utils/enlightenment_sys&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;It installs some SUID binaries, then I was thinking if I can use one of those&lt;br&gt; to escalate to root, the binaries were all secure looking and well coded.&lt;br&gt; The binary we will be talking about is enlightenment_sys.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;As any other target we choose a strategy to apply after doing some pre-assessment&lt;br&gt; see my blog here if not yet (&lt;a href=&#34;https://pwn-maher.blogspot.com/2020/10/vulnerability-assessment.html&#34;&gt;https://pwn-maher.blogspot.com/2020/10/vulnerability-assessment.html&lt;/a&gt;)&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;I audited the code on a Top-Down approach.&lt;br&gt; And because this window manager is open source, the source code will be available&lt;br&gt; for all those binaries and modules.&lt;br&gt; So first thing I did was &lt;code&gt;apt source enlightenment&lt;/code&gt; to get all the source code,&lt;br&gt; and with a bit of digging we can get to the target binary code.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;But to debug the binary I load it to Ghidra for analysis and to have addresses&lt;br&gt; to set breakpoints and all.&lt;br&gt; No symbols were found first try but yeah no need for those as it turned out to&lt;br&gt; be a relatively small binary.&lt;br&gt; Surprisingly, I found it very pleasing to look at the decompiled pseudo-code of&lt;br&gt; Ghidra than looking directly at the src (avoid macros, avoid also those checks&lt;br&gt; against the OS being used to compile a specific block of code).&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;So let&#39;s start analysis.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;1- Play with the binary.&lt;br&gt; Let&#39;s run the file to see some information about our target:&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/file_command.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Running the binary do not give any output:&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/running_bin.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Giving --help argument gave this output:&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/running_help.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt; Sorry, I will use it to get root.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Next let&#39;s just strace and see if it will use any suspicious syscalls like&lt;br&gt; execve or openat:&lt;br&gt; strace ./enlightenment_sys 2&amp;gt;&amp;amp;1 | grep open &lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/strace_open.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt; It just opens known libraries at places we don&#39;t have permission to tamper with.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;strace ./enlightenment_sys 2&amp;gt;&amp;amp;1 | grep exec&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/strace_exec.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;2- Let&#39;s reverse engineer the binary and then exploit it.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;I created a new Ghidra project, and I loaded this specific binary.&lt;br&gt; Because symbols were not found, we can spot the main function using entry.&lt;br&gt; The first argument to entry function is main itself.&lt;br&gt; I renamed it to main for future references.&lt;br&gt; Scrolling a bit down I can already spot system() function being used.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;As a pwner I spend days on challenges to spawn this specific function x)&lt;br&gt; I reversed the binary looking for a memory corruption bug or some heap problems&lt;br&gt; , but actually it was a weird Command Injection.&lt;br&gt; The binary take all security precautions before running system, but sadly we&lt;br&gt; can always inject our input in there.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/system_ghidra.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Ok, now let&#39;s walk the binary from top up to our system function, trying to&lt;br&gt; inject our input in there.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;First the binary just checks if the first arg is --help or -h and shows that&lt;br&gt; message we saw earlier.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/help_decompilation.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Second it elevate it&#39;s privileges to root.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/elev_decompilation.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Next it unset almost all environment variables (security precautions) to not&lt;br&gt; invoke another non-intended binary.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/unset_decompilation.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;So if the first arg we entered is &#34;mount&#34; it will enter this branch, check some&lt;br&gt; flags given, those flags gonna be set on the stack.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Next it checks if the next param after mount is UUID= we don&#39;t want to enter&lt;br&gt; here, so we gave &#34;/dev/../tmp/;/tmp/exploit&#34;.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/strncmp_uuid.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt; Like this we pass the check at line 410. the strncmp check.&lt;br&gt; Because if it don&#39;t start with /dev/ the binary will exit.&lt;br&gt; Next there is a call to stat64 on that file we provided, note that we can&lt;br&gt; create a folder called &#34;;&#34; and that will be causing the command injection.&lt;br&gt; Until now, the exploit already created this file /dev/../tmp/;/tmp/exploit,&lt;br&gt; but this is not the exploit that will be called.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/stat64_ghidra.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/stat64_gdb.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;We&#39;re getting closer to system() now.&lt;br&gt; Now p (pointer), gets updated to the last argument given to our SUID binary,&lt;br&gt; /tmp///net.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Why providing /tmp///net when we can pass /tmp/net?&lt;br&gt; We will bypass this check:&lt;br&gt; &lt;code&gt;if (((next_next == (char *)0x0) || (next_next[1] == &#39;\0&#39;)) || ((long)next_next - (long)p != 6))&lt;/code&gt;&lt;br&gt; We needed /tmp/net to exist and /tmp/// to be on length 6.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now the last stat64 will check for the existence of &#34;/dev/net&#34;&lt;br&gt; __snprintf_chk(cmd,0x1000,1,0x1000,&#34;/dev%s&#34;,next_next);&lt;br&gt; And it will find it, so we pass that last check.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now it will check for the availability for some files, but that&#39;s not important&lt;br&gt; at this point, because we&#39;re all set and all close to trigger arbitrary Command&lt;br&gt; Execution.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Now eina_strbuf_new() will just initialize the command that will be passed to&lt;br&gt; system, the problem here is that we entered it as:&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;/bin/mount -o noexec,nosuid,utf8,nodev,iocharset=utf8,utf8=0,utf8=1,uid=$(id -u), &#34;/dev/../tmp/;/tmp/exploit&#34; /tmp///net&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;But the binary calls eina_strbuf_append_printf() for several times and becomes&lt;br&gt; /bin/mount -o noexec,nosuid,utf8,nodev,iocharset=utf8,utf8=0,utf8=1,uid=$(id -u), /dev/../tmp/;/tmp/exploit /tmp///net&lt;br&gt; Notice that double quotes are removed, and we will be able to call /tmp/exploit&lt;br&gt; as root.&lt;br&gt; &lt;img src=&#34;https://raw.githubusercontent.com/MaherAzzouzi/CVE-2022-37706-LPE-exploit/main/screenshots/system_gdb.png&#34; alt=&#34;Screenshot&#34;&gt;&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;The binary tried it&#39;s best to mitigate any non-intended behavior but as usual&lt;br&gt; anything can be pwned. I wasn&#39;t expecting to exploit this using a logical bug&lt;br&gt; like this.&lt;br&gt; I want the next CVE to be a memory corruption leading to LPE root.&lt;br&gt;&lt;/p&gt; &#xA;&lt;p&gt;Twitter disclosure: &lt;a href=&#34;https://twitter.com/maherazz2/status/1569665311707734023&#34;&gt;https://twitter.com/maherazz2/status/1569665311707734023&lt;/a&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>KISS1996/trexminer</title>
    <updated>2022-09-16T01:40:07Z</updated>
    <id>tag:github.com,2022-09-16:/KISS1996/trexminer</id>
    <link href="https://github.com/KISS1996/trexminer" rel="alternate"></link>
    <summary type="html">&lt;p&gt;【全网最强】minerproxy矿池中转，原创minerproxy，唯一正版，性能强大, 功能齐全, 9000台无压力不崩溃，BTC ETC ETH LTC ERGO RVN CFX ETC等全币种无损抽水，体验拉满的minerproxy, 软防CC, 动态难度调整抽水，不爆内存。支持绝大部分币种的转发、加密、自定义抽水、精确到单台设备的24小时数据统计、自定义隧道推送工具、修改矿池本地算力..&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;T-REX MinerProxy&lt;/h2&gt; &#xA;&lt;p&gt;⚡ 原创正版，功能强大，性能强劲。支持无损BTC ETC ETH LTC ERG CFX RVN SERO XMR CKB BEAM ALPH KASPA等多个币种抽水，不爆内存，体验拉满，9000台无压力不崩溃，精确到单台设备的24小时数据统计、自定义隧道推送工具等强大功能。TEHW ETF等分叉币直接使用ETH转发就行了&lt;/p&gt; &#xA;&lt;h2&gt;Linux一键工具箱&lt;/h2&gt; &#xA;&lt;p&gt;bash &amp;lt;(curl -s -L &lt;a href=&#34;https://raw.githubusercontent.com/KISS1996/trexminer/main/install.sh&#34;&gt;https://raw.githubusercontent.com/KISS1996/trexminer/main/install.sh&lt;/a&gt;) &lt;img src=&#34;https://user-images.githubusercontent.com/97815657/184542394-63f8fbe5-570e-4039-a7a6-3ffdfc97387e.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;安装完成后会提示端口号，控制页面登录就是您的服务器IP+端口号&lt;/p&gt; &#xA;&lt;h2&gt;核心功能&lt;/h2&gt; &#xA;&lt;p&gt;全币种无损抽水 先进的内存管理机制, 单机最高8000台稳定运行至今 精确到单台设备的24小时数据统计分析 TLS/SSL/ShadowMiner加密 配套的本地端加密工具 预置各币种矿池（随时更新） 软防cc 多钱包配置 替换指定钱包 统一钱包 矿池模式 快捷导入到出所有配置 修改矿池内本地算力 IP黑名单 自定义RSA加密密钥 自定义证书 自定义配置 掉线提醒 矿池官网一样的观察者地址 超低的手续费 已支持抽水的币种 BTC ETC ETH LTC ERG CFX RVN SERO XMR CKB BEAM ALPH KASPA ...&lt;/p&gt; &#xA;&lt;h2&gt;Linux&lt;/h2&gt; &#xA;&lt;p&gt;root用户直接执行以下命令, 根据提示选择对应功能即可。&lt;/p&gt; &#xA;&lt;p&gt;bash &amp;lt;(curl -s -L &lt;a href=&#34;https://raw.githubusercontent.com/KISS1996/trexminer/main/install.sh&#34;&gt;https://raw.githubusercontent.com/KISS1996/trexminer/main/install.sh&lt;/a&gt;) 安装完成之后, 请立即修改登录账号、密码以及启动端口，防止被爆破。&lt;/p&gt; &#xA;&lt;p&gt;支持的Linux&lt;/p&gt; &#xA;&lt;p&gt;Ubuntu 64 18.04+ Centos 64 7+&lt;/p&gt; &#xA;&lt;h2&gt;Windows&lt;/h2&gt; &#xA;&lt;p&gt;下载完后直接启动即可，程序自带进程守护，进入网页端配置&lt;/p&gt; &#xA;&lt;h2&gt;常见问题&lt;/h2&gt; &#xA;&lt;p&gt;进程守护 程序自带了进程守护, 不要！不要！不要使用supervisor或相关工具维护进程，否则会导致进程重复开启。&lt;/p&gt; &#xA;&lt;p&gt;安装时提示 curl: command not found 安装时提示 curl: command not found， 说明你的linux没有安装curl&lt;/p&gt; &#xA;&lt;p&gt;先执行 apt-get update&lt;/p&gt; &#xA;&lt;p&gt;然后执行 apt install curl&lt;/p&gt; &#xA;&lt;p&gt;等待命令执行完毕，即可执行安装脚本&lt;/p&gt; &#xA;&lt;h2&gt;修改端口启动&lt;/h2&gt; &#xA;&lt;p&gt;安装完成后尽快进入设置页面修改端口号。 &lt;img src=&#34;https://user-images.githubusercontent.com/97815657/184565818-bc373de5-f5d6-4843-a820-cde692f5c121.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;修改密码&lt;/h2&gt; &#xA;&lt;p&gt;安装完后请尽快前往设置页修改密码。 &lt;img src=&#34;https://user-images.githubusercontent.com/97815657/184565756-c46587ad-ef21-4908-b58a-23b62f7e9c6f.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;WEB访问长时间卡在LOADING界面。&lt;/h2&gt; &#xA;&lt;p&gt;安装或更新后，第一次访问web界面加载时间可能会有些长，如果很长时间没有进去，请更换chrome浏览器。&lt;/p&gt; &#xA;&lt;h2&gt;默认账号密码&lt;/h2&gt; &#xA;&lt;p&gt;默认账号: admin&lt;/p&gt; &#xA;&lt;p&gt;默认密码: admin123&lt;/p&gt; &#xA;&lt;h2&gt;开发费用及算力损耗&lt;/h2&gt; &#xA;&lt;p&gt;开发费用恒定至千分之三&lt;/p&gt; &#xA;&lt;p&gt;多种原因会造成算力损耗，检查以下项，不要什么屎盆子都往开发者头上扣&lt;/p&gt; &#xA;&lt;p&gt;观察矿池内延迟份额的比例，如果延迟率高于百分1请ping服务器检查延迟&lt;/p&gt; &#xA;&lt;p&gt;抽水的算力因池而异，如果两个池子难度不同，也会导致算力差异&lt;/p&gt; &#xA;&lt;h2&gt;IP黑名单&lt;/h2&gt; &#xA;&lt;p&gt;前往设置页面, IP黑名单选项卡可主动加入IP黑名单 &lt;img src=&#34;https://user-images.githubusercontent.com/97815657/184778098-6e768dbc-1d56-47f1-b32c-676ebf1f53ef.png&#34; alt=&#34;image&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;ETH、ETC芯片机&lt;/h2&gt; &#xA;&lt;p&gt;常见的如奶牛、茉莉、亚米等机型, 需要用ETH端口, 芯动系列或其他的机型请选择ETH(GetWork)端口&lt;/p&gt; &#xA;&lt;p&gt;如果设备无法正常接入，不同类型的端口可以交替着试一下。&lt;/p&gt; &#xA;&lt;h2&gt;芯动A11系列相关问题&lt;/h2&gt; &#xA;&lt;p&gt;A11抽水矿池需要和目标矿池相同。&lt;/p&gt; &#xA;&lt;p&gt;如果同池还存在高无效的情况, 请降级或升级固件至a11_20211026_060307版本, mx需要降级或升级至 a11mx_20211220_124402版本。&lt;/p&gt; &#xA;&lt;h2&gt;本地算力修改&lt;/h2&gt; &#xA;&lt;p&gt;添加或编辑端口时, 在【高级】选项卡下可进行ETH、ETC的本地算力修改&lt;/p&gt; &#xA;&lt;h2&gt;服务迁移&lt;/h2&gt; &#xA;&lt;p&gt;无论使用任何方式迁移程序, 迁移之后请将新的目录下license文件删除, 然后重启程序&lt;/p&gt; &#xA;&lt;h2&gt;内存相关&lt;/h2&gt; &#xA;&lt;p&gt;目前单台设备内存占用峰值控制在1.5M, 处于长期观察调整阶段, 之后会根据实际情况调低占用, 请根据接入设备数&lt;/p&gt; &#xA;&lt;p&gt;量来决定硬件配置&lt;/p&gt; &#xA;&lt;h2&gt;观察者链接&lt;/h2&gt; &#xA;&lt;p&gt;打开 端口设置-高级设置 ， 找到观察者链接，打开并保存，端口详情页内左下角找即可找到观察者链接。&lt;/p&gt; &#xA;&lt;h2&gt;算力跑不够的常见原因&lt;/h2&gt; &#xA;&lt;p&gt;如果测试下来24小时均值和设置的差距过大的话, 比如设置抽百分之1, 均值却少了很多, 有很多原因会导致这种情况发生，需要自己一步步排查。&lt;/p&gt; &#xA;&lt;p&gt;通常检查本地是否中招，或是设备出现问题，例如中转里某些设备无效率很高，这种情况通常是卡出问题了, 找到到这种情况通常比较容易排查，在trexminer中找到高无效的设备，点开后看下日志里是否有很多POW相关的关键字，如果有的话那么就说明这台设备的硬件出问题了，导致无效引发算力偏低。&lt;/p&gt; &#xA;&lt;p&gt;更常见的一种原因是本地中招，这个非常容易遇到但是不好排查，可以在trexminer里建立一个纯转发的端口，用纯转发的端口测试设备24小时均值，如果纯转发的端口24小时跑不够，那么大概率是本地中招，本地重新安装干净的系统解决。&lt;/p&gt; &#xA;&lt;h2&gt;电报：&lt;a href=&#34;https://t.me/ethasiapool&#34;&gt;https://t.me/ethasiapool&lt;/a&gt;&lt;/h2&gt;</summary>
  </entry>
</feed>