<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-06-09T01:48:02Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>kdave/btrfsmaintenance</title>
    <updated>2023-06-09T01:48:02Z</updated>
    <id>tag:github.com,2023-06-09:/kdave/btrfsmaintenance</id>
    <link href="https://github.com/kdave/btrfsmaintenance" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Scripts for btrfs maintenance tasks like periodic scrub, balance, trim or defrag on selected mountpoints or directories.&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Btrfs maintenance toolbox&lt;/h1&gt; &#xA;&lt;p&gt;Table of contents:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kdave/btrfsmaintenance/master/#quick-start&#34;&gt;Quick start&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kdave/btrfsmaintenance/master/#distro-integration&#34;&gt;Distro integration&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kdave/btrfsmaintenance/master/#tuning-periodic-snapshotting&#34;&gt;Tuning periodic snapshotting&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This is a set of scripts supplementing the btrfs filesystem and aims to automate a few maintenance tasks. This means the &lt;em&gt;scrub&lt;/em&gt;, &lt;em&gt;balance&lt;/em&gt;, &lt;em&gt;trim&lt;/em&gt; or &lt;em&gt;defragmentation&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Each of the tasks can be turned on/off and configured independently. The default config values were selected to fit the default installation profile with btrfs on the root filesystem.&lt;/p&gt; &#xA;&lt;p&gt;Overall tuning of the default values should give a good balance between effects of the tasks and low impact of other work on the system. If this does not fit your needs, please adjust the settings.&lt;/p&gt; &#xA;&lt;h2&gt;Tasks&lt;/h2&gt; &#xA;&lt;p&gt;The following sections will describe the tasks in detail. There&#39;s one config option that affects the task concurrency, &lt;code&gt;BTRFS_ALLOW_CONCURRENCY&lt;/code&gt;. This is to avoid extra high resource consumption or unexpected interaction among the tasks and will serialize them in the order they&#39;re started by timers.&lt;/p&gt; &#xA;&lt;h3&gt;scrub&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Scrub operation reads all data and metadata from the devices and verifies the checksums. It&#39;s not mandatory, but may point out problems with faulty hardware early as it touches data that might not be in use and bit rot.&lt;/p&gt; &#xA;&lt;p&gt;If there&#39;s a redundancy of data/metadata, ie. the &lt;em&gt;DUP&lt;/em&gt; or &lt;em&gt;RAID1/5/6&lt;/em&gt; profiles, scrub is able to repair the data automatically if there&#39;s a good copy available.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Impact when active:&lt;/strong&gt; Intense read operations take place and may slow down or block other filesystem activies, possibly only for short periods.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tuning:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the recommended period is once in a month but a weekly period is also acceptable&lt;/li&gt; &#xA; &lt;li&gt;you can turn off the automatic repair (&lt;code&gt;BTRFS_SCRUB_READ_ONLY&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;the default IO priority is set to &lt;em&gt;idle&lt;/em&gt; but scrub may take long to finish, you can change priority to &lt;em&gt;normal&lt;/em&gt; (&lt;code&gt;BTRFS_SCRUB_PRIORITY&lt;/code&gt;)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Related commands:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;you can check status of last scrub run (either manual or through the cron job) by &lt;code&gt;btrfs scrub status /path&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;you can cancel a running scrub anytime if you find it inconvenient (&lt;code&gt;btrfs scrub cancel /path&lt;/code&gt;), the progress state is saved each 5 seconds and next time scrub will start from that point&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;balance&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; The balance command can do a lot of things, in general moves data around in big chunks. Here we use it to reclaim back the space of the underused chunks so it can be allocated again according to current needs.&lt;/p&gt; &#xA;&lt;p&gt;The point is to prevent some corner cases where it&#39;s not possible to eg. allocate new metadata chunks because the whole device space is reserved for all the chunks, although the total space occupied is smaller and the allocation should succeed.&lt;/p&gt; &#xA;&lt;p&gt;The balance operation needs enough workspace so it can shuffle data around. By workspace we mean device space that has no filesystem chunks on it, not to be confused by free space as reported eg. by &lt;code&gt;df&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Impact when active:&lt;/strong&gt; Possibly big. There&#39;s a mix of read and write operations, is seek-heavy on rotational devices. This can interfere with other work in case the same set of blocks is affected.&lt;/p&gt; &#xA;&lt;p&gt;The balance command uses filters to do the work in smaller batches.&lt;/p&gt; &#xA;&lt;p&gt;Before kernel version 5.2, the impact with quota groups enabled can be extreme. The balance operation performs quota group accounting for every extent being relocated, which can have the impact of stalling the file system for an extended period of time.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Expected result:&lt;/strong&gt; If possible all the underused chunks are removed, the value of &lt;code&gt;total&lt;/code&gt; in output of &lt;code&gt;btrfs fi df /path&lt;/code&gt; should be lower than before. Check the logs.&lt;/p&gt; &#xA;&lt;p&gt;The balance command may fail with &lt;em&gt;no space&lt;/em&gt; reason but this is considered a minor fault as the internal filesystem layout may prevent the command to find enough workspace. This might be a time for manual inspection of space.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tuning:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;you can make the space reclaim more aggressive by adding higher percentage to &lt;code&gt;BTRFS_BALANCE_DUSAGE&lt;/code&gt; or &lt;code&gt;BTRFS_BALANCE_MUSAGE&lt;/code&gt;. Higher value means bigger impact on your system and becomes very noticeable.&lt;/li&gt; &#xA; &lt;li&gt;the metadata chunks usage pattern is different from data and it&#39;s not necessary to reclaim metadata block groups that are more than 30 full. The default maximum is 10 which should not degrade performance too much but may be suboptimal if the metadata usage varies wildly over time. The assumption is that underused metadata chunks will get used at some point so it&#39;s not absolutely required to do the reclaim.&lt;/li&gt; &#xA; &lt;li&gt;the useful period highly depends on the overall data change pattern on the filesystem&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;&lt;strong&gt;Changed defaults since 0.5:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;Versions up to 0.4.2 had usage filter set up to 50% for data and up to 30% for metadata. Based on user feedback, the numbers have been reduced to 10% (data) and 5% (metadata). The system load during the balance service will be smaller and the result of space compaction still reasonable. Multiple data chunks filled to less than 10% can be merged into fewer chunks. The file data can change in large volumes, eg. deleting a big file can free a lot of space. If the space is left unused for the given period, it&#39;s desirable to make it more compact. Metadata consumption follows a different pattern and reclaiming only the almost unused chunks makes more sense, otherwise there&#39;s enough reserved metadata space for operations like reflink or snapshotting.&lt;/p&gt; &#xA;&lt;p&gt;A convenience script is provided to update the unchanged defaults, &lt;code&gt;/usr/share/btrfsmaintenance/update-balance-usage-defaults.sh&lt;/code&gt; .&lt;/p&gt; &#xA;&lt;h3&gt;trim&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; The TRIM operation (aka. &lt;em&gt;discard&lt;/em&gt;) can instruct the underlying device to optimize blocks that are not used by the filesystem. This task is performed on-demand by the &lt;em&gt;fstrim&lt;/em&gt; utility.&lt;/p&gt; &#xA;&lt;p&gt;This makes sense for SSD devices or other type of storage that can translate the TRIM action to something useful (eg. thin-provisioned storage).&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Impact when active:&lt;/strong&gt; Should be low, but depends on the amount of blocks being trimmed.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Tuning:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;the recommended period is weekly, but monthly is also fine&lt;/li&gt; &#xA; &lt;li&gt;the trim commands might not have an effect and are up to the device, eg. a block range too small or other constraints that may differ by device type/vendor/firmware&lt;/li&gt; &#xA; &lt;li&gt;the default configuration is &lt;em&gt;off&lt;/em&gt; because of the the system fstrim.timer&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;defrag&lt;/h3&gt; &#xA;&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Run defragmentation on configured directories. This is for convenience and not necessary as defragmentation needs are usually different for various types of data.&lt;/p&gt; &#xA;&lt;p&gt;Please note that the defragmentation process does not descend to other mount points and nested subvolumes or snapshots. All nested paths would need to be enumerated in the respective config variable. The command utilizes &lt;code&gt;find -xdev&lt;/code&gt;, you can use that to verify in advance which paths will the defragmentation affect.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;Special case:&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;p&gt;There&#39;s a separate defragmentation task that happens automatically and defragments only the RPM database files. This is done via a &lt;em&gt;zypper&lt;/em&gt; plugin and the defrag pass triggers at the end of the installation.&lt;/p&gt; &#xA;&lt;p&gt;This improves reading the RPM databases later, but the installation process fragments the files very quickly so it&#39;s not likely to bring a significant speedup here.&lt;/p&gt; &#xA;&lt;h2&gt;Periodic scheduling&lt;/h2&gt; &#xA;&lt;p&gt;There are now two ways how to schedule and run the periodic tasks: cron and systemd timers. Only one can be active on a system and this should be decided at the installation time.&lt;/p&gt; &#xA;&lt;h3&gt;Cron&lt;/h3&gt; &#xA;&lt;p&gt;Cron takes care of periodic execution of the scripts, but they can be run any time directly from &lt;code&gt;/usr/share/btrfsmaintenance/&lt;/code&gt;, respecting the configured values in &lt;code&gt;/etc/sysconfig/btrfsmaintenance&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The changes to configuration file need to be reflected in the &lt;code&gt;/etc/cron&lt;/code&gt; directories where the scripts are linked for the given period.&lt;/p&gt; &#xA;&lt;p&gt;If the period is changed, the cron symlinks have to be refreshed:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;manually -- use &lt;code&gt;systemctl restart btrfsmaintenance-refresh&lt;/code&gt; (or the &lt;code&gt;rcbtrfsmaintenance-refresh&lt;/code&gt; shortcut)&lt;/li&gt; &#xA; &lt;li&gt;in &lt;em&gt;yast2&lt;/em&gt; -- sysconfig editor triggers the refresh automatically&lt;/li&gt; &#xA; &lt;li&gt;using a file watcher -- if you install &lt;code&gt;btrfsmaintenance-refresh.path&lt;/code&gt;, this will utilize the file monitor to detect changes and will run the refresh&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Systemd timers&lt;/h3&gt; &#xA;&lt;p&gt;There&#39;s a set of timer units that run the respective task script. The periods are configured in the &lt;code&gt;/etc/sysconfig/btrfsmaintenance&lt;/code&gt; file as well. The timers have to be installed using a similar way as cron. Please note that the &#39;&lt;em&gt;.timer&#39; and respective &#39;&lt;/em&gt;.service&#39; files have to be installed so the timers work properly.&lt;/p&gt; &#xA;&lt;h2&gt;Quick start&lt;/h2&gt; &#xA;&lt;p&gt;The tasks&#39; periods and other parameters should fit most use cases and do not need to be touched. Review the mount points (variables ending with &lt;code&gt;_MOUNTPOINTS&lt;/code&gt;) whether you want to run the tasks there or not.&lt;/p&gt; &#xA;&lt;h2&gt;Distro integration&lt;/h2&gt; &#xA;&lt;p&gt;Currently the support for widely used distros is present. More distros can be added. This section describes how the pieces are put together and should give some overview.&lt;/p&gt; &#xA;&lt;h3&gt;Installation&lt;/h3&gt; &#xA;&lt;p&gt;For debian based systems, run &lt;code&gt;dist-install.sh&lt;/code&gt; as root.&lt;/p&gt; &#xA;&lt;p&gt;For non-debian based systems, check for distro provided package or do manual installation of files as described below.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;btrfs-*.sh&lt;/code&gt; task scripts are expected at &lt;code&gt;/usr/share/btrfsmaintenance&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;sysconfig.btrfsmaintenance&lt;/code&gt; configuration template is put to:&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/etc/sysconfig/btrfsmaintenance&lt;/code&gt; on SUSE and RedHat based systems or derivatives&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/etc/default/btrfsmaintenance&lt;/code&gt; on Debian and derivatives&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/usr/lib/zypp/plugins/commit/btrfs-defrag-plugin.sh&lt;/code&gt; or &lt;code&gt;/usr/lib/zypp/plugins/commit/btrfs-defrag-plugin.py&lt;/code&gt; post-update script for zypper (the package manager), applies to SUSE-based distros for now&lt;/li&gt; &#xA; &lt;li&gt;cron refresh scripts are installed (see bellow)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The defrag plugin has a shell and python implementation, choose what suits the installation better.&lt;/p&gt; &#xA;&lt;h3&gt;cron jobs&lt;/h3&gt; &#xA;&lt;p&gt;The periodic execution of the tasks is done by the &#39;cron&#39; service. Symlinks to the task scripts are located in the respective directories in &lt;code&gt;/etc/cron.&amp;lt;PERIOD&amp;gt;&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The script &lt;code&gt;btrfsmaintenance-refresh-cron.sh&lt;/code&gt; will synchronize the symlinks according to the configuration files. This can be called automatically by a GUI configuration tool if it&#39;s capable of running post-change scripts or services. In that case there&#39;s &lt;code&gt;btrfsmaintenance-refresh.service&lt;/code&gt; systemd service.&lt;/p&gt; &#xA;&lt;p&gt;This service can also be automatically started upon any modification of the configuration file in &lt;code&gt;/etc/sysconfig/btrfsmaintenance&lt;/code&gt; by installing the &lt;code&gt;btrfsmaintenance-refresh.path&lt;/code&gt; systemd watcher.&lt;/p&gt; &#xA;&lt;h3&gt;Post-update defragmentation&lt;/h3&gt; &#xA;&lt;p&gt;The package database files tend to be updated in a random way and get fragmented, which particularly hurts on btrfs. For rpm-based distros this means files in &lt;code&gt;/var/lib/rpm&lt;/code&gt;. The script or plugin simply runs a defragmentation on the affected files. See &lt;code&gt;btrfs-defrag-plugin.sh&lt;/code&gt; or &lt;code&gt;btrfs-defrag-plugin.py&lt;/code&gt; for more details.&lt;/p&gt; &#xA;&lt;p&gt;At the moment the &#39;zypper&#39; package manager plugin exists. As the package managers differ significantly, there&#39;s no single plugin/script to do that.&lt;/p&gt; &#xA;&lt;h3&gt;Settings&lt;/h3&gt; &#xA;&lt;p&gt;The settings are copied to the expected system location from the template (&lt;code&gt;sysconfig.btrfsmaintenance&lt;/code&gt;). This is a shell script and can be sourced to obtain values of the variables.&lt;/p&gt; &#xA;&lt;p&gt;The template contains descriptions of the variables, default and possible values and can be deployed without changes (expecting the root filesystem to be btrfs).&lt;/p&gt; &#xA;&lt;h2&gt;Tuning periodic snapshotting&lt;/h2&gt; &#xA;&lt;p&gt;There are various tools and handwritten scripts to manage periodic snapshots and cleaning. The common problem is tuning the retention policy constrained by the filesystem size and not running out of space.&lt;/p&gt; &#xA;&lt;p&gt;This section will describe factors that affect that, using &lt;a href=&#34;https://snapper.io&#34;&gt;snapper&lt;/a&gt; as an example, but adapting to other tools should be straightforward.&lt;/p&gt; &#xA;&lt;h3&gt;Intro&lt;/h3&gt; &#xA;&lt;p&gt;Snapper is a tool to manage snapshots of btrfs subvolumes. It can create snapshots of given subvolume manually, periodically or in a pre/post way for a given command. It can be configured to retain existing snapshots according to time-based settings. As the retention policy can be very different for various use cases, we need to be able to find matching settings.&lt;/p&gt; &#xA;&lt;p&gt;The settings should satisfy user&#39;s expectation about storing previous copies of the subvolume but not taking too much space. In an extreme, consuming the whole filesystem space and preventing some operations to finish.&lt;/p&gt; &#xA;&lt;p&gt;In order to avoid such situations, the snapper settings should be tuned according to the expected use case and filesystem size.&lt;/p&gt; &#xA;&lt;h3&gt;Sample problem&lt;/h3&gt; &#xA;&lt;p&gt;Default settings of snapper on default root partition size can easily lead to no-space conditions (all TIMELINE values set to 10). Frequent system updates make it happen earlier, but this also affects long-term use.&lt;/p&gt; &#xA;&lt;h3&gt;Factors affecting space consumption&lt;/h3&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;frequency of snapshotting&lt;/li&gt; &#xA; &lt;li&gt;amount of data changes between snapshots (delta)&lt;/li&gt; &#xA; &lt;li&gt;snapshot retention settings&lt;/li&gt; &#xA; &lt;li&gt;size of the filesystem&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;Each will be explained below.&lt;/p&gt; &#xA;&lt;p&gt;The way how the files are changed affects the space consumption. When a new data overwrite existing, the new data will be pinned by the following snapshot, while the original data will belong to previous snapshot. This means that the allocated file blocks are freed after the last snapshot pointing to them is gone.&lt;/p&gt; &#xA;&lt;h3&gt;Tuning&lt;/h3&gt; &#xA;&lt;p&gt;The administrator/user is supposed to know the approximate use of the partition with snapshots enabled.&lt;/p&gt; &#xA;&lt;p&gt;The decision criteria for tuning is space consumption and we&#39;re optimizing to maximize retention without running out of space.&lt;/p&gt; &#xA;&lt;p&gt;All the factors are intertwined and we cannot give definite answers but rather describe the tendencies.&lt;/p&gt; &#xA;&lt;h4&gt;Snapshotting frequency&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;automatic&lt;/strong&gt;: if turned on with the &lt;code&gt;TIMELINE&lt;/code&gt; config option, the periodic snapshots are taken hourly. The daily/weekly/monthly/yearly periods will keep the first hourly snapshot in the given period.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;at package update&lt;/strong&gt;: package manager with snapper support will create pre/post snapshots before/after an update happens.&lt;/p&gt; &lt;/li&gt; &#xA; &lt;li&gt; &lt;p&gt;&lt;strong&gt;manual&lt;/strong&gt;: the user can create a snapshot manually with &lt;code&gt;snapper create&lt;/code&gt;, with a given snapshot type (ie. single, pre, post).&lt;/p&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Amount of data change&lt;/h4&gt; &#xA;&lt;p&gt;This is a parameter hard to predict and calculate. We work with rough estimates, eg. megabytes, gigabytes etc.&lt;/p&gt; &#xA;&lt;h4&gt;Retention settings&lt;/h4&gt; &#xA;&lt;p&gt;The user is supposed to know possible needs of recovery or examination of previous file copies stored in snapshots.&lt;/p&gt; &#xA;&lt;p&gt;It&#39;s not recommended to keep too old snapshots, eg. monthly or even yearly if there&#39;s no apparent need for that. The yearly snapshots should not substitute backups, as they reside on the same partition and cannot be used for recovery.&lt;/p&gt; &#xA;&lt;h4&gt;Filesystem size&lt;/h4&gt; &#xA;&lt;p&gt;Bigger filesystem allows for longer retention, higher frequency updates and amount of data changes.&lt;/p&gt; &#xA;&lt;p&gt;As an example of a system root partition, the recommended size is 30 GiB, but 50 GiB is selected by the installer if the snapshots are turned on.&lt;/p&gt; &#xA;&lt;p&gt;For non-system partition it is recommended to watch remaining free space. Although getting an accurate value on btrfs is tricky, due to shared extents and snapshots, the output of &lt;code&gt;df&lt;/code&gt; gives a rough idea. Low space, like under a few gigabytes is more likely to lead to no-space conditions, so it&#39;s a good time to delete old snapshots or review the snapper settings.&lt;/p&gt; &#xA;&lt;h3&gt;Typical use cases&lt;/h3&gt; &#xA;&lt;h4&gt;A rolling distro&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;frequency of updates: high, multiple times per week&lt;/li&gt; &#xA; &lt;li&gt;amount of data changed between updates: high&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Suggested values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TIMELINE_LIMIT_HOURLY=&#34;12&#34;&#xA;TIMELINE_LIMIT_DAILY=&#34;5&#34;&#xA;TIMELINE_LIMIT_WEEKLY=&#34;2&#34;&#xA;TIMELINE_LIMIT_MONTHLY=&#34;1&#34;&#xA;TIMELINE_LIMIT_YEARLY=&#34;0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The size of root partition should be at least 30GiB, but more is better.&lt;/p&gt; &#xA;&lt;h4&gt;Regular/enterprise distro&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;frequency of updates: low, a few times per month&lt;/li&gt; &#xA; &lt;li&gt;amount of data changed between updates: low to moderate&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Most data changes come probably from the package updates, in the range of hundreds of megabytes per update.&lt;/p&gt; &#xA;&lt;p&gt;Suggested values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TIMELINE_LIMIT_HOURLY=&#34;12&#34;&#xA;TIMELINE_LIMIT_DAILY=&#34;7&#34;&#xA;TIMELINE_LIMIT_WEEKLY=&#34;4&#34;&#xA;TIMELINE_LIMIT_MONTHLY=&#34;6&#34;&#xA;TIMELINE_LIMIT_YEARLY=&#34;1&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h4&gt;Big file storage&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;frequency of updates: moderate to high&lt;/li&gt; &#xA; &lt;li&gt;amount of data changed between updates: no changes in files, new files added, old deleted&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Suggested values:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TIMELINE_LIMIT_HOURLY=&#34;12&#34;&#xA;TIMELINE_LIMIT_DAILY=&#34;7&#34;&#xA;TIMELINE_LIMIT_WEEKLY=&#34;4&#34;&#xA;TIMELINE_LIMIT_MONTHLY=&#34;6&#34;&#xA;TIMELINE_LIMIT_YEARLY=&#34;0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note, that deleting a big file that has been snapshotted will not free the space until all relevant snapshots are deleted.&lt;/p&gt; &#xA;&lt;h4&gt;Mixed&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;frequency of updates: unpredictable&lt;/li&gt; &#xA; &lt;li&gt;amount of data changed between updates: unpredictable&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Examples:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;home directory with small files (in range of kilobytes to megabytes), large files (hundreds of megabytes to gigabytes).&lt;/li&gt; &#xA; &lt;li&gt;git trees, bare and checked out repositories&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Not possible to suggest config numbers as it really depends on user expectations. Keeping a few hourly snapshots should not consume too much space and provides a copy of files, eg. to restore after accidental deletion.&lt;/p&gt; &#xA;&lt;p&gt;Starting point:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;TIMELINE_LIMIT_HOURLY=&#34;12&#34;&#xA;TIMELINE_LIMIT_DAILY=&#34;7&#34;&#xA;TIMELINE_LIMIT_WEEKLY=&#34;1&#34;&#xA;TIMELINE_LIMIT_MONTHLY=&#34;0&#34;&#xA;TIMELINE_LIMIT_YEARLY=&#34;0&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Summary&lt;/h3&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Type&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Hourly&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Daily&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Weekly&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Monthly&lt;/th&gt; &#xA;   &lt;th align=&#34;right&#34;&gt;Yearly&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Rolling&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;12&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;5&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;2&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Regular&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;12&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;7&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;4&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Big files&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;12&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;7&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;4&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;6&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;Mixed&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;12&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;7&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;1&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0&lt;/td&gt; &#xA;   &lt;td align=&#34;right&#34;&gt;0&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;h2&gt;About&lt;/h2&gt; &#xA;&lt;p&gt;The goal of this project is to help administering btrfs filesystems. It is not supposed to be distribution specific. Common scripts/configs are preferred but per-distro exceptions will be added when necessary.&lt;/p&gt; &#xA;&lt;p&gt;License: &lt;a href=&#34;https://www.gnu.org/licenses/gpl-2.0.html&#34;&gt;GPL 2&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kdave/btrfsmaintenance/master/CONTRIBUTING.md&#34;&gt;Contributing guide&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>