<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-10-11T01:39:54Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>TrionesType/zhuque</title>
    <updated>2023-10-11T01:39:54Z</updated>
    <id>tag:github.com,2023-10-11:/TrionesType/zhuque</id>
    <link href="https://github.com/TrionesType/zhuque" rel="alternate"></link>
    <summary type="html">&lt;p&gt;朱雀仿宋/朱雀宋朝/Zhuque Fangsong: An open-source Fansong typeface project&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;朱雀仿宋&lt;/h1&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://raw.githubusercontent.com/TrionesType/zhuque/main/docs/README-en.md&#34;&gt;English&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/TrionesType/zhuque/main/docs/README-zh-Hant.md&#34;&gt;繁體中文&lt;/a&gt; | &lt;a href=&#34;https://raw.githubusercontent.com/TrionesType/zhuque/main/docs/README-ja.md&#34;&gt;日本語&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/TrionesType/zhuque/main/docs/preview.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;p&gt;「朱雀仿宋」是&lt;a href=&#34;http://trionestype.com/&#34;&gt;璇玑造字&lt;/a&gt;的开源仿宋字体计划，志在最终提供高质量的、支持多语言的正文仿宋解决方案。&lt;/p&gt; &#xA;&lt;p&gt;仿宋作为「宋黑仿楷」中文四大基础字体之一，长期缺乏开源许可证下的选择。我们希望「朱雀仿宋」可以弥补这一空缺，为开源软件与 TeX 社区贡献一份力。&lt;/p&gt; &#xA;&lt;p&gt;上世纪初，仿宋活字一度品类繁盛，开发、应用风行一时。然而时过境迁，市面上的仿宋最终收敛于「华丰真宋」一系，这也是今天大多数人所熟悉的仿宋样貌。「朱雀仿宋」则以民国仿宋活字「南宋」为蓝本，在满足现代排印需求的前提下，尝试为正文仿宋字库带来一缕新鲜空气。&lt;/p&gt; &#xA;&lt;p&gt;当前我们发布的「朱雀仿宋」仍为「预览测试版」，尚处于项目早期阶段；无论是设计风格、字数，还是字形、排版质量，都不代表正式版情况。因此，&lt;/p&gt; &#xA;&lt;h2&gt;「朱雀」的未来，由你定义&lt;/h2&gt; &#xA;&lt;p&gt;如果您有任何问题、意见建议、合作意向，我们也欢迎您加入「朱雀仿宋反馈」微信群；或移步 &lt;a href=&#34;https://github.com/TrionesType/zhuque/issues&#34;&gt;Issues&lt;/a&gt; 提出。&lt;/p&gt; &#xA;&lt;p align=&#34;center&#34;&gt; &lt;img src=&#34;https://raw.githubusercontent.com/TrionesType/zhuque/main/docs/wechat_qr.png&#34; width=&#34;150px&#34;&gt; &lt;/p&gt; &#xA;&lt;p&gt;璇玑正在尝试一种全新中文字库设计模式。得益于我们开发的最新技术，璇玑的设计师可以直接将人工智能作为设计工具去使用，我们也因此能以迭代的方式开发「朱雀」。&lt;/p&gt; &#xA;&lt;p&gt;即便有技术加持，我们宏伟的目标也让「朱雀」项目有着难以想象的工作量。为了让项目推进更快、更可持续，我们也希望能获得更多的支持。&lt;/p&gt; &#xA;&lt;h2&gt;下载&lt;/h2&gt; &#xA;&lt;p&gt;版本与下载链接将会更新在 &lt;a href=&#34;https://github.com/TrionesType/zhuque/releases&#34;&gt;Releases 发布页&lt;/a&gt;。&lt;/p&gt; &#xA;&lt;h2&gt;设计故事&lt;/h2&gt; &#xA;&lt;p&gt;开发一套开源仿宋字库的想法最早始于 2021 年初，是继&lt;a href=&#34;https://github.com/welai/glow-sans&#34;&gt;「未来荧黑」&lt;/a&gt;项目之后，我们认为更有意义、也更具难度的挑战。随着设计研究的深入与技术进步，特别是去年以来 AIGC 技术的爆发，实现这一想法在今日遂成可能。&lt;/p&gt; &#xA;&lt;p&gt;「朱雀仿宋」改刻自民国活字「南宋」，试图为这套沉睡数十年的字体赋予新生。「南宋」于 1932 年由「百宋铸字印刷局」推出，韩佑之设计原稿，邹根培雕刻字模。一经面世，即广泛用于书籍、期刊排印。「南宋」与大多数正文字体的设定不同，重心略靠右下；结构中宫收紧、撇捺舒展，笔画的粗细变化强烈；含蓄秀美而充满力量感，在排印标题和正文时展现出浓厚的「书卷气」。&lt;/p&gt; &#xA;&lt;p&gt;在「南宋」活字的基础上，「朱雀仿宋」稍稍削弱了笔画的对比度，适当地规整了字形结构与版面效果，同时最大程度地保留了「南宋」的独特气质与活字趣味。&lt;/p&gt; &#xA;&lt;p&gt;「朱雀」是中国传统文化中「四象」之一，南方七宿之神。「朱雀」之名，与「南宋」渊源以及「璇玑造字」的品牌名相合。&lt;/p&gt; &#xA;&lt;h3&gt;参考文献&lt;/h3&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;孙明远：《中国近现代平面设计和文字设计发展历程研究——从一八〇五年至一九四九年》，厦门大学出版社，2021 年第 1 版，第 168～172 页&lt;/li&gt; &#xA; &lt;li&gt;周博：《中国现代文字设计图史》，北京大学出版社，2018 年第 1 版，第 122～124 页&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;许可证&lt;/h2&gt; &#xA;&lt;p&gt;© 2023 &lt;a href=&#34;https://jadefoci.com/&#34;&gt;智琮科技&lt;/a&gt;，以 &lt;a href=&#34;http://scripts.sil.org/OFL&#34;&gt;SIL Open Font License 1.1&lt;/a&gt; 发布。&lt;/p&gt; &#xA;&lt;p&gt;您&lt;strong&gt;可以&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;strong&gt;免费商用本字体&lt;/strong&gt;，无论是用于印刷、LOGO、软件、网页还是视频。&lt;/li&gt; &#xA; &lt;li&gt;复制与再分发本字体。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;您&lt;strong&gt;不可以&lt;/strong&gt;：&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;单独销售字体的原始版本或是修改版本。&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;授权方式以 &lt;a href=&#34;http://scripts.sil.org/OFL&#34;&gt;SIL Open Font License 1.1 的英文原文&lt;/a&gt;为准。&lt;/p&gt; &#xA;&lt;p&gt;我们恳请您&lt;strong&gt;暂时不要&lt;/strong&gt;在「朱雀仿宋」正式版发布之前大量传播非「朱雀」团队所修改的本字体。如果您有改进「朱雀仿宋」意愿，我们非常欢迎您提出宝贵的意见建议——包括与我们讨论如何参与到朱雀的设计工作。&lt;/p&gt; &#xA;&lt;p&gt;朱雀的西文与符号暂采用 &lt;a href=&#34;https://github.com/huertatipografica/Alegreya&#34;&gt;Alegreya&lt;/a&gt; 的一个外插值实例。Alegreya 由 Huerta Tipográfica 的 Juan Pablo del Peral 创作，同样以 SIL Open Font License 1.1 发布。&lt;/p&gt; &#xA;&lt;h2&gt;「朱雀」团队&lt;/h2&gt; &#xA;&lt;p&gt;&lt;strong&gt;主创：&lt;/strong&gt;&lt;a href=&#34;https://github.com/Lottin0113&#34;&gt;余俊益&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;假名与符号（制作中）：&lt;/strong&gt;&lt;a href=&#34;https://github.com/yeongsy&#34;&gt;韩泳思&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;技术：&lt;/strong&gt;&lt;a href=&#34;https://github.com/celestialphineas&#34;&gt;殷叶航&lt;/a&gt;、&lt;a href=&#34;https://github.com/Lottin0113&#34;&gt;余俊益&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;关于璇玑造字&lt;/h2&gt; &#xA;&lt;p&gt;&lt;a href=&#34;http://trionestype.com/&#34;&gt;「璇玑造字」&lt;/a&gt;是&lt;a href=&#34;https://jadefoci.com/&#34;&gt;智琮科技&lt;/a&gt;的字库品牌。我们以传统文化为立足基本，从自然风物汲取设计灵感，藉前沿科技更新文字风景。无论技术如何变迁，我们将始终把「人」置于第一位，关心设计者的创意与读者的体验。&lt;/p&gt; &#xA;&lt;p&gt;欢迎你来和璇玑造字一起塑造属于未来的文字！&lt;/p&gt; &#xA;&lt;h2&gt;致谢&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;特别鸣谢：特里王，在「南宋」活字收集、整理、研究上的贡献。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/Siphercase&#34;&gt;Siphercase&lt;/a&gt; 补充了部分国际音标字形。&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/lxgw&#34;&gt;落霞孤鹜&lt;/a&gt;的&lt;a href=&#34;https://github.com/lxgw/LxgwWenKai&#34;&gt;「霞鹜文楷」&lt;/a&gt;、&lt;a href=&#34;https://github.com/fontworks-fonts/Klee&#34;&gt;Fontworks Klee One&lt;/a&gt;、&lt;a href=&#34;https://github.com/adobe-fonts/source-han-serif&#34;&gt;思源宋体&lt;/a&gt;，这些开源字体是本项目人与机在设计过程中的写法参考。&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
  <entry>
    <title>just-containers/s6-overlay</title>
    <updated>2023-10-11T01:39:54Z</updated>
    <id>tag:github.com,2023-10-11:/just-containers/s6-overlay</id>
    <link href="https://github.com/just-containers/s6-overlay" rel="alternate"></link>
    <summary type="html">&lt;p&gt;s6 overlay for containers (includes execline, s6-linux-utils &amp; a custom init)&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;Table of Contents&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#quickstart&#34;&gt;Quickstart&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#compatibility-with-v2&#34;&gt;Compatibility with v2&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#goals&#34;&gt;Goals&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#features&#34;&gt;Features&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#the-docker-way&#34;&gt;The Docker Way?&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#init-stages&#34;&gt;Init stages&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#installation&#34;&gt;Installation&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#usage&#34;&gt;Usage&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#using-cmd&#34;&gt;Using &lt;code&gt;CMD&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#writing-a-service-script&#34;&gt;Writing a service script&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#setting-the-exit-code-of-the-container-to-the-exit-code-of-your-main-service&#34;&gt;Setting the exit code of the container to the exit code of your main service&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#fixing-ownership-and-permissions&#34;&gt;Fixing ownership and permissions&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#executing-initialization-and-finalization-tasks&#34;&gt;Executing initialization and finalization tasks&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#writing-an-optional-finish-script&#34;&gt;Writing an optional finish script&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#logging&#34;&gt;Logging&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#dropping-privileges&#34;&gt;Dropping privileges&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#read-only-root-filesystem&#34;&gt;Read-only Root Filesystem&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#container-environment&#34;&gt;Container environment&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#customizing-s6-overlay-behaviour&#34;&gt;Customizing s6-overlay&#39;s behaviour&lt;/a&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#syslog&#34;&gt;syslog&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#performance&#34;&gt;Performance&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#verifying-downloads&#34;&gt;Verifying Downloads&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#notes&#34;&gt;Notes&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#releases&#34;&gt;Releases&lt;/a&gt; &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#which-architecture-to-use-depending-on-your-targetarch&#34;&gt;Which architecture to use depending on your TARGETARCH&lt;/a&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#contributing&#34;&gt;Contributing&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#building-the-overlay-yourself&#34;&gt;Building the overlay yourself&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#upgrade-notes&#34;&gt;Upgrade notes&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h1&gt;s6-overlay &lt;a href=&#34;https://travis-ci.org/just-containers/s6-overlay&#34;&gt;&lt;img src=&#34;https://api.travis-ci.org/just-containers/s6-overlay.svg?branch=master&#34; alt=&#34;Build Status&#34;&gt;&lt;/a&gt;&lt;/h1&gt; &#xA;&lt;p&gt;s6-overlay is an easy-to-install (just extract a tarball or two!) set of scripts and utilities allowing you to use existing Docker images while using &lt;a href=&#34;https://skarnet.org/software/s6/overview.html&#34;&gt;s6&lt;/a&gt; as a pid 1 for your container and process supervisor for your services.&lt;/p&gt; &#xA;&lt;h2&gt;Quickstart&lt;/h2&gt; &#xA;&lt;p&gt;Build the following Dockerfile and try it out:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;# Use your favorite image&#xA;FROM ubuntu&#xA;ARG S6_OVERLAY_VERSION=3.1.5.0&#xA;&#xA;RUN apt-get update &amp;amp;&amp;amp; apt-get install -y nginx xz-utils&#xA;RUN echo &#34;daemon off;&#34; &amp;gt;&amp;gt; /etc/nginx/nginx.conf&#xA;CMD [&#34;/usr/sbin/nginx&#34;]&#xA;&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp&#xA;RUN tar -C / -Jxpf /tmp/s6-overlay-noarch.tar.xz&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp&#xA;RUN tar -C / -Jxpf /tmp/s6-overlay-x86_64.tar.xz&#xA;ENTRYPOINT [&#34;/init&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker-host $ docker build -t demo .&#xA;docker-host $ docker run --name s6demo -d -p 80:80 demo&#xA;docker-host $ docker top s6demo acxf&#xA;PID                 TTY                 STAT                TIME                COMMAND&#xA;11735               ?                   Ss                  0:00                \_ s6-svscan&#xA;11772               ?                   S                   0:00                \_ s6-supervise&#xA;11773               ?                   Ss                  0:00                | \_ s6-linux-init-s&#xA;11771               ?                   Ss                  0:00                \_ rc.init&#xA;11812               ?                   S                   0:00                | \_ nginx&#xA;11814               ?                   S                   0:00                | \_ nginx&#xA;11816               ?                   S                   0:00                | \_ nginx&#xA;11813               ?                   S                   0:00                | \_ nginx&#xA;11815               ?                   S                   0:00                | \_ nginx&#xA;11779               ?                   S                   0:00                \_ s6-supervise&#xA;11785               ?                   Ss                  0:00                | \_ s6-ipcserverd&#xA;11778               ?                   S                   0:00                \_ s6-supervise&#xA;docker-host $ curl --head http://127.0.0.1/&#xA;HTTP/1.1 200 OK&#xA;Server: nginx/1.18.0 (Ubuntu)&#xA;Date: Mon, 17 Jan 2022 13:33:58 GMT&#xA;Content-Type: text/html&#xA;Content-Length: 612&#xA;Last-Modified: Mon, 17 Jan 2022 13:32:11 GMT&#xA;Connection: keep-alive&#xA;ETag: &#34;61e56fdb-264&#34;&#xA;Accept-Ranges: bytes&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Compatibility with v2&lt;/h2&gt; &#xA;&lt;p&gt;If you&#39;re migrating from a previous version of s6-overlay (&lt;em&gt;v2&lt;/em&gt;) to the new version (&lt;em&gt;v3&lt;/em&gt;), you may need to make some changes to your services or the way you use s6-overlay in order for everything to work smoothly. This document tries to be accurate on how v3 works, but we have a &lt;a href=&#34;https://github.com/just-containers/s6-overlay/raw/master/MOVING-TO-V3.md&#34;&gt;separate page&lt;/a&gt; listing the main differences, and things you&#39;re likely to notice. Please read it if you&#39;re in this situation!&lt;/p&gt; &#xA;&lt;h2&gt;Goals&lt;/h2&gt; &#xA;&lt;p&gt;The project has the following goals:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Be usable on top of &lt;em&gt;any&lt;/em&gt; Docker image&lt;/li&gt; &#xA; &lt;li&gt;Make it easy to create new images, that will operate like any other images&lt;/li&gt; &#xA; &lt;li&gt;Provide users with a turnkey s6 installation that will give them a stable pid 1, a fast and orderly init sequence and shutdown sequence, and the power of process supervision and automatically rotated logs.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Features&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;A simple init process which allows the end-user to execute tasks like initialization (&lt;code&gt;cont-init.d&lt;/code&gt;), finalization (&lt;code&gt;cont-finish.d&lt;/code&gt;) and their own services with dependencies between them&lt;/li&gt; &#xA; &lt;li&gt;The s6-overlay provides proper &lt;code&gt;PID 1&lt;/code&gt; functionality &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;You&#39;ll never have zombie processes hanging around in your container, they will be properly cleaned up.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;Multiple processes in a single container&lt;/li&gt; &#xA; &lt;li&gt;Able to operate in &#34;The Docker Way&#34;&lt;/li&gt; &#xA; &lt;li&gt;Usable with all base images - Ubuntu, CentOS, Fedora, Alpine, Busybox...&lt;/li&gt; &#xA; &lt;li&gt;Distributed as a small number of .tar.xz files depending on what exact functionality you need - to keep your image&#39;s number of layers small.&lt;/li&gt; &#xA; &lt;li&gt;A whole set of utilities included in &lt;code&gt;s6&lt;/code&gt; and &lt;code&gt;s6-portable-utils&lt;/code&gt;. They include handy and composable utilities which make our lives much, much easier.&lt;/li&gt; &#xA; &lt;li&gt;Log rotating out-of-the-box through &lt;code&gt;logutil-service&lt;/code&gt; which uses &lt;a href=&#34;https://skarnet.org/software/s6/s6-log.html&#34;&gt;&lt;code&gt;s6-log&lt;/code&gt;&lt;/a&gt; under the hood.&lt;/li&gt; &#xA; &lt;li&gt;Some support for Docker&#39;s &lt;code&gt;USER&lt;/code&gt; directive, to run your whole process tree as a specific user. Not compatible with all features, details in the &lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#notes&#34;&gt;notes&lt;/a&gt; section.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;The Docker Way?&lt;/h2&gt; &#xA;&lt;p&gt;One of the oft-repeated Docker mantras is &#34;one process per container&#34;, but we disagree. There&#39;s nothing inherently &lt;em&gt;bad&lt;/em&gt; about running multiple processes in a container. The more abstract &#34;one &lt;em&gt;thing&lt;/em&gt; per container&#34; is our policy - a container should do one thing, such as &#34;run a chat service&#34; or &#34;run gitlab.&#34; This may involve multiple processes, which is fine.&lt;/p&gt; &#xA;&lt;p&gt;The other reason image authors shy away from process supervisors is they believe a process supervisor &lt;em&gt;must&lt;/em&gt; restart failed services, meaning the Docker container will never die.&lt;/p&gt; &#xA;&lt;p&gt;This does effectively break the Docker ecosystem - most images run one process that will exit when there&#39;s an error. By exiting on error, you allow the system administrator to handle failures however they prefer. If your image will never exit, you now need some alternative method of error recovery and failure notification.&lt;/p&gt; &#xA;&lt;p&gt;Our policy is that if &#34;the thing&#34; fails, then the container should fail, too. We do this by determining which processes can restart, and which should bring down the container. For example, if &lt;code&gt;cron&lt;/code&gt; or &lt;code&gt;syslog&lt;/code&gt; fails, your container can most likely restart it without any ill effects, but if &lt;code&gt;ejabberd&lt;/code&gt; fails, the container should exit so the system administrator can take action.&lt;/p&gt; &#xA;&lt;p&gt;Our interpretation of &#34;The Docker Way&#34; is thus:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Containers should do one thing&lt;/li&gt; &#xA; &lt;li&gt;Containers should stop when that thing stops&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;and our init system is designed to do exactly that. Your images will behave like other Docker images and fit in with the existing ecosystem of images.&lt;/p&gt; &#xA;&lt;p&gt;See &#34;Writing an optional finish script&#34; under the &lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#usage&#34;&gt;Usage&lt;/a&gt; section for details on stopping &#34;the thing.&#34;&lt;/p&gt; &#xA;&lt;h2&gt;Init stages&lt;/h2&gt; &#xA;&lt;p&gt;Our overlay init is a properly customized one to run appropriately in containerized environments. This section briefly explains how stages work but if you want to know how a complete init system should work, you can read this article: &lt;a href=&#34;https://skarnet.org/software/s6/s6-svscan-1.html&#34;&gt;How to run s6-svscan as process 1&lt;/a&gt;&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;strong&gt;stage 1&lt;/strong&gt;: Its purpose is to set up the image to execute the supervision tree which will handle all the auxiliary services, and to launch stage 2. Stage 1 is where all the black magic happens, all the container setup details that we handle for you so that you don&#39;t have to care about them.&lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;stage 2&lt;/strong&gt;: This is where most of the end-user provided files are meant to be executed: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Execute legacy oneshot user scripts contained in &lt;code&gt;/etc/cont-init.d&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Run user s6-rc services declared in &lt;code&gt;/etc/s6-overlay/s6-rc.d&lt;/code&gt;, following dependencies&lt;/li&gt; &#xA;   &lt;li&gt;Copy legacy longrun user services (&lt;code&gt;/etc/services.d&lt;/code&gt;) to a temporary directory and have s6 start (and supervise) them.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;strong&gt;stage 3&lt;/strong&gt;: This is the shutdown stage. When the container is supposed to exit, it will: &#xA;  &lt;ol&gt; &#xA;   &lt;li&gt;Send a TERM signal to all legacy longrun services and, if required, wait for them to exit.&lt;/li&gt; &#xA;   &lt;li&gt;Bring down user s6-rc services in an orderly fashion.&lt;/li&gt; &#xA;   &lt;li&gt;Run any finalization scripts contained in &lt;code&gt;/etc/cont-finish.d&lt;/code&gt;.&lt;/li&gt; &#xA;   &lt;li&gt;Send all remaining processes a &lt;code&gt;TERM&lt;/code&gt; signal. There should not be any remaining processes anyway.&lt;/li&gt; &#xA;   &lt;li&gt;Sleep for a small grace time, to allow stray processes to exit cleanly.&lt;/li&gt; &#xA;   &lt;li&gt;Send all processes a &lt;code&gt;KILL&lt;/code&gt; signal. Then the container exits.&lt;/li&gt; &#xA;  &lt;/ol&gt; &lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;p&gt;s6-overlay comes as a set of tarballs that you can extract onto your image. The tarballs you need are a function of the image you use; most people will need the first two, and the other ones are extras you can use at your convenience.&lt;/p&gt; &#xA;&lt;ol&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-noarch.tar.xz&lt;/code&gt;: this tarball contains the scripts implementing the overlay. We call it &#34;noarch&#34; because it is architecture- independent: it only contains scripts and other text files. Everyone who wants to run s6-overlay needs to extract this tarball.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-x86_64.tar.xz&lt;/code&gt;: replace &lt;code&gt;x86_64&lt;/code&gt; with your system&#39;s architecture. This tarball contains all the necessary binaries from the s6 ecosystem, all linked statically and out of the way of your image&#39;s binaries. Unless you know for sure that your image already comes with all the packages providing the binaries used in the overlay, you need to extract this tarball.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-symlinks-noarch.tar.xz&lt;/code&gt;: this tarball contains symlinks to the s6-overlay scripts so they are accessible via &lt;code&gt;/usr/bin&lt;/code&gt;. It is normally not needed, all the scripts are accessible via the PATH environment variable, but if you have old user scripts containing shebangs such as &lt;code&gt;#!/usr/bin/with-contenv&lt;/code&gt;, installing these symlinks will make them work.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-symlinks-arch.tar.xz&lt;/code&gt;: this tarball contains symlinks to the binaries from the s6 ecosystem provided by the second tarball, to make them accessible via &lt;code&gt;/usr/bin&lt;/code&gt;. It is normally not needed, but if you have old user scripts containing shebangs such as &lt;code&gt;#!/usr/bin/execlineb&lt;/code&gt;, installing these symlinks will make them work.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;syslogd-overlay-noarch.tar.xz&lt;/code&gt;: this tarball contains definitions for a &lt;code&gt;syslogd&lt;/code&gt; service. If you are running daemons that cannot log to stderr to take advantage of the s6 logging infrastructure, but hardcode the use of the old &lt;code&gt;syslog()&lt;/code&gt; mechanism, you can extract this tarball, and your container will run a lightweight emulation of a &lt;code&gt;syslogd&lt;/code&gt; daemon, so your syslog logs will be caught and stored to disk.&lt;/li&gt; &#xA;&lt;/ol&gt; &#xA;&lt;p&gt;To install those tarballs, add lines to your Dockerfile that correspond to the functionality you want to install. For instance, most people would use the following:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp&#xA;RUN tar -C / -Jxpf /tmp/s6-overlay-noarch.tar.xz&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp&#xA;RUN tar -C / -Jxpf /tmp/s6-overlay-x86_64.tar.xz&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Make sure to preserve file permissions when extracting (i.e. to use the &lt;code&gt;-p&lt;/code&gt; option to &lt;code&gt;tar&lt;/code&gt;.)&lt;/p&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;The project is distributed as a set of standard .tar.xz files, which you extract at the root of your image. (You need the xz-utils package for &lt;code&gt;tar&lt;/code&gt; to understand &lt;code&gt;.tar.xz&lt;/code&gt; files; it is available in every distribution, but not always in the default container images, so you may need to &lt;code&gt;apt install xz-utils&lt;/code&gt; or &lt;code&gt;apk add xz-utils&lt;/code&gt;, or equivalent, before you can expand the archives.)&lt;/p&gt; &#xA;&lt;p&gt;Afterwards, set your &lt;code&gt;ENTRYPOINT&lt;/code&gt; to &lt;code&gt;/init&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Right now, we recommend using Docker&#39;s &lt;code&gt;ADD&lt;/code&gt; directive instead of running &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;curl&lt;/code&gt; in a &lt;code&gt;RUN&lt;/code&gt; directive - Docker is able to handle the https URL when you use &lt;code&gt;ADD&lt;/code&gt;, whereas your base image might not be able to use https, or might not even have &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;curl&lt;/code&gt; installed at all.&lt;/p&gt; &#xA;&lt;p&gt;From there, you have a couple of options:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If you want the container to exit when your program exits: run the program as your image&#39;s &lt;code&gt;CMD&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;If you want the container to run until told to exit, and your program to be supervised by s6: write a service script for your program.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Using &lt;code&gt;CMD&lt;/code&gt;&lt;/h3&gt; &#xA;&lt;p&gt;Using &lt;code&gt;CMD&lt;/code&gt; is a convenient way to take advantage of the overlay. Your &lt;code&gt;CMD&lt;/code&gt; can be given at build time in the Dockerfile, or at run time on the command line, either way is fine. It will be run as a normal process in the environment set up by s6; when it fails or exits, the container will shut down cleanly and exit. You can run interactive programs in this manner: only the CMD will receive your interactive command, the support processes will be unimpacted.&lt;/p&gt; &#xA;&lt;p&gt;For example:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;FROM busybox&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp&#xA;RUN tar -C / -Jxpf /tmp/s6-overlay-noarch.tar.xz&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp&#xA;RUN tar -C / -Jxpf /tmp/s6-overlay-x86_64.tar.xz&#xA;ENTRYPOINT [&#34;/init&#34;]&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code&gt;docker-host $ docker build -t s6demo .&#xA;docker-host $ docker run -ti s6demo /bin/sh&#xA;/package/admin/s6-overlay/libexec/preinit: notice: /var/run is not a symlink to /run, fixing it&#xA;s6-rc: info: service s6rc-oneshot-runner: starting&#xA;s6-rc: info: service s6rc-oneshot-runner successfully started&#xA;s6-rc: info: service fix-attrs: starting&#xA;s6-rc: info: service fix-attrs successfully started&#xA;s6-rc: info: service legacy-cont-init: starting&#xA;s6-rc: info: service legacy-cont-init successfully started&#xA;s6-rc: info: service legacy-services: starting&#xA;s6-rc: info: service legacy-services successfully started&#xA;/ # ps&#xA;PID   USER     TIME  COMMAND&#xA;    1 root      0:00 /package/admin/s6/command/s6-svscan -d4 -- /run/service&#xA;   17 root      0:00 {rc.init} /bin/sh -e /run/s6/basedir/scripts/rc.init top /bin/sh&#xA;   18 root      0:00 s6-supervise s6-linux-init-shutdownd&#xA;   20 root      0:00 /package/admin/s6-linux-init/command/s6-linux-init-shutdownd -c /run/s6/basedir -g 3000 -C -B&#xA;   24 root      0:00 s6-supervise s6rc-fdholder&#xA;   25 root      0:00 s6-supervise s6rc-oneshot-runner&#xA;   31 root      0:00 /package/admin/s6/command/s6-ipcserverd -1 -- /package/admin/s6/command/s6-ipcserver-access -v0 -E -l0 -i data/rules -- /packa&#xA;   58 root      0:00 /bin/sh&#xA;   66 root      0:00 ps&#xA;/ # exit&#xA;s6-rc: info: service legacy-services: stopping&#xA;s6-rc: info: service legacy-services successfully stopped&#xA;s6-rc: info: service legacy-cont-init: stopping&#xA;s6-rc: info: service legacy-cont-init successfully stopped&#xA;s6-rc: info: service fix-attrs: stopping&#xA;s6-rc: info: service fix-attrs successfully stopped&#xA;s6-rc: info: service s6rc-oneshot-runner: stopping&#xA;s6-rc: info: service s6rc-oneshot-runner successfully stopped&#xA;docker-host $&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Writing a service script&lt;/h3&gt; &#xA;&lt;p&gt;The other way to use a container with s6-overlay is to make your services supervised. You can supervise any number of services; usually they&#39;re just support services for the main daemon you run as a CMD, but if that&#39;s what you want, nothing prevents you from having an empty CMD and running your main daemon as a supervised service as well. In that case, the daemon will be restarted by s6 whenever it exits; the container will only stop when you tell it to do so, either via a &lt;code&gt;docker stop&lt;/code&gt; command, or from inside the container with the &lt;code&gt;/run/s6/basedir/bin/halt&lt;/code&gt; command.&lt;/p&gt; &#xA;&lt;p&gt;There are two ways of making a supervised service. The old way, which is still supported, is to make a &#34;pure s6&#34; service directory. Create a directory with the name of your service in &lt;code&gt;/etc/services.d&lt;/code&gt; and put an executable &lt;code&gt;run&lt;/code&gt; file into it; this is the file in which you&#39;ll put your long-lived process execution. For details of supervision of service directories, and how you can configure how s6 handles your daemon, you can take a look at the &lt;a href=&#34;https://skarnet.org/software/s6/servicedir.html&#34;&gt;servicedir&lt;/a&gt; documentation. A simple example would look like this:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/services.d/myapp/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/command/execlineb -P&#xA;nginx -g &#34;daemon off;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The new way is to make an &lt;a href=&#34;https://skarnet.org/software/s6-rc/&#34;&gt;s6-rc&lt;/a&gt; &lt;em&gt;source definition directory&lt;/em&gt; in the &lt;code&gt;/etc/s6-overlay/s6-rc.d&lt;/code&gt; directory, and add the name of that directory to the &lt;code&gt;user&lt;/code&gt; bundle, i.e. create an empty file with the same name in the &lt;code&gt;/etc/s6-overlay/s6-rc.d/user/contents.d&lt;/code&gt; directory. The format of a &lt;em&gt;source definition directory&lt;/em&gt; is described in &lt;a href=&#34;https://skarnet.org/software/s6-rc/s6-rc-compile.html&#34;&gt;this page&lt;/a&gt;. Note that you can define &lt;em&gt;longruns&lt;/em&gt;, i.e. daemons that will get supervised by s6 just like with the &lt;code&gt;/etc/services.d&lt;/code&gt; method, but also &lt;em&gt;oneshots&lt;/em&gt;, i.e. programs that will run once and exit. Your main service is probably a &lt;em&gt;longrun&lt;/em&gt;, not a &lt;em&gt;oneshot&lt;/em&gt;: you probably need a daemon to stick around.&lt;/p&gt; &#xA;&lt;p&gt;The advantage of this new format is that it allows you to define dependencies between services: if &lt;em&gt;B&lt;/em&gt; depends on &lt;em&gt;A&lt;/em&gt;, then &lt;em&gt;A&lt;/em&gt; will start first, then &lt;em&gt;B&lt;/em&gt; will start when &lt;em&gt;A&lt;/em&gt; is ready, and when the container is told to exit, &lt;em&gt;B&lt;/em&gt; will stop first, then &lt;em&gt;A&lt;/em&gt;. If you have a complex architecture where various processes depends on one another, or simply where you have to mix &lt;em&gt;oneshots&lt;/em&gt; and &lt;em&gt;longruns&lt;/em&gt; in a precise order, this may be for you.&lt;/p&gt; &#xA;&lt;p&gt;The example above could be rewritten this way:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/type&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;longrun&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/command/execlineb -P&#xA;nginx -g &#34;daemon off;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/user/contents.d/myapp&lt;/code&gt;: empty file. (This adds &lt;code&gt;myapp&lt;/code&gt; to the set of services that s6-rc will start at container boot.)&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/dependencies.d/base&lt;/code&gt;: empty file. (This tells s6-rc to only start &lt;code&gt;myapp&lt;/code&gt; when all the base services are ready: it prevents race conditions.)&lt;/p&gt; &#xA;&lt;p&gt;We encourage you to switch to the new format, but if you don&#39;t need its benefits, you can stick with regular service directories in &lt;code&gt;/etc/services.d&lt;/code&gt;, it will work just as well.&lt;/p&gt; &#xA;&lt;h3&gt;Setting the exit code of the container to the exit code of your main service&lt;/h3&gt; &#xA;&lt;p&gt;If you run your main service as a CMD, you have nothing to do: when your CMD exits, or when you run &lt;code&gt;docker stop&lt;/code&gt;, the container will naturally exit with the same exit code as your service. (Be aware, however, that in the &lt;code&gt;docker stop&lt;/code&gt; case, your service will get a SIGTERM, in which case the exit code will entirely depend on how your service handles it - it could trap it and exit 0, trap it and exit something else, or not trap it and let the shell exit its own code for it - normally 130.)&lt;/p&gt; &#xA;&lt;p&gt;If you run your main service as a supervised service, however, things are different, and you need to tell the container what code to exit with when you send it a &lt;code&gt;docker stop&lt;/code&gt; command. To do that, you need to write a &lt;code&gt;finish&lt;/code&gt; script:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;If your service is a legacy service in &lt;code&gt;/etc/services.d&lt;/code&gt;, you need an executable &lt;code&gt;/etc/services.d/myapp/finish&lt;/code&gt; script.&lt;/li&gt; &#xA; &lt;li&gt;If your service is an s6-rc one, you need a &lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/finish&lt;/code&gt; file containing your script (the file may or may not be executable).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;This &lt;code&gt;finish&lt;/code&gt; script will be run when your service exits, and will take two arguments:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The first argument will be the exit code of your service, or 256 if your service was killed by an uncaught signal.&lt;/li&gt; &#xA; &lt;li&gt;The second argument is only meaningful if your service was killed by an uncaught signal, and contains the number of said signal.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In the &lt;code&gt;finish&lt;/code&gt; script, you need to write the container exit code you want to the &lt;code&gt;/run/s6-linux-init-container-results/exitcode&lt;/code&gt; file - and that&#39;s it.&lt;/p&gt; &#xA;&lt;p&gt;For instance, the &lt;code&gt;finish&lt;/code&gt; script for the &lt;code&gt;myapp&lt;/code&gt; service above could be something like this:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh&#xA;&#xA;if test &#34;$1&#34; -eq 256 ; then&#xA;  e=$((128 + $2))&#xA;else&#xA;  e=&#34;$1&#34;&#xA;fi&#xA;&#xA;echo &#34;$e&#34; &amp;gt; /run/s6-linux-init-container-results/exitcode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;When you send a &lt;code&gt;docker stop&lt;/code&gt; command to your container, the &lt;code&gt;myapp&lt;/code&gt; service will be killed and this script will be run; it will write either &lt;code&gt;myapp&lt;/code&gt;&#39;s exit code (if &lt;code&gt;myapp&lt;/code&gt; catches the TERM signal) or 130 (if &lt;code&gt;myapp&lt;/code&gt; does not catch the TERM signal) to the special &lt;code&gt;/run/s6-linux-init-container-results/exitcode&lt;/code&gt; file, which will be read by s6-overlay at the end of the container shutdown procedure, and your container will exit with that value.&lt;/p&gt; &#xA;&lt;h3&gt;Fixing ownership and permissions&lt;/h3&gt; &#xA;&lt;p&gt;This section describes a functionality from the versions of s6-overlay that are &lt;strong&gt;anterior to&lt;/strong&gt; v3. fix-attrs is still supported in v3, but is &lt;strong&gt;deprecated&lt;/strong&gt;, for several reasons: one of them is that it&#39;s generally not good policy to change ownership dynamically when it can be done statically. Another reason is that it doesn&#39;t work with USER containers. Instead of fix-attrs, we now recommend you to take care of ownership and permissions on host mounts &lt;em&gt;offline, before running the container&lt;/em&gt;. This should be done in your Dockerfile, when you have all the needed information.&lt;/p&gt; &#xA;&lt;p&gt;That said, here is what we wrote for previous versions and that is still applicable today (but please stop depending on it):&lt;/p&gt; &#xA;&lt;p&gt;Sometimes it&#39;s interesting to fix ownership &amp;amp; permissions before proceeding because, for example, you have mounted/mapped a host folder inside your container. Our overlay provides a way to tackle this issue using files in &lt;code&gt;/etc/fix-attrs.d&lt;/code&gt;. This is the pattern format followed by fix-attrs files:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;path recurse account fmode dmode&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;path&lt;/code&gt;: File or dir path.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;recurse&lt;/code&gt;: (Set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) If a folder is found, recurse through all containing files &amp;amp; folders in it.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;account&lt;/code&gt;: Target account. It&#39;s possible to default to fallback &lt;code&gt;uid:gid&lt;/code&gt; if the account isn&#39;t found. For example, &lt;code&gt;nobody,32768:32768&lt;/code&gt; would try to use the &lt;code&gt;nobody&lt;/code&gt; account first, then fallback to &lt;code&gt;uid 32768&lt;/code&gt; instead. If, for instance, &lt;code&gt;daemon&lt;/code&gt; account is &lt;code&gt;UID=2&lt;/code&gt; and &lt;code&gt;GID=2&lt;/code&gt;, these are the possible values for &lt;code&gt;account&lt;/code&gt; field: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;code&gt;daemon: UID=2 GID=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;daemon,3:4: UID=2 GID=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;2:2,3:4: UID=2 GID=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;daemon:11111,3:4: UID=2 GID=11111&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;11111:daemon,3:4: UID=11111 GID=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;daemon:daemon,3:4: UID=2 GID=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;daemon:unexisting,3:4: UID=2 GID=4&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;unexisting:daemon,3:4: UID=3 GID=2&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;&lt;code&gt;11111:11111,3:4: UID=11111 GID=11111&lt;/code&gt;&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;fmode&lt;/code&gt;: Target file mode. For example, &lt;code&gt;0644&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;dmode&lt;/code&gt;: Target dir/folder mode. For example, &lt;code&gt;0755&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Here you have some working examples:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/fix-attrs.d/01-mysql-data-dir&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/var/lib/mysql true mysql 0600 0700&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/fix-attrs.d/02-mysql-log-dirs&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;/var/log/mysql-error-logs true nobody,32768:32768 0644 2700&#xA;/var/log/mysql-general-logs true nobody,32768:32768 0644 2700&#xA;/var/log/mysql-slow-query-logs true nobody,32768:32768 0644 2700&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Executing initialization and finalization tasks&lt;/h3&gt; &#xA;&lt;p&gt;Here is the old way of doing it:&lt;/p&gt; &#xA;&lt;p&gt;After fixing attributes (through &lt;code&gt;/etc/fix-attrs.d/&lt;/code&gt;) and before starting user provided services (through s6-rc or &lt;code&gt;/etc/services.d&lt;/code&gt;) our overlay will execute all the scripts found in &lt;code&gt;/etc/cont-init.d&lt;/code&gt;, for example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/just-containers/nginx-loadbalancer/raw/master/rootfs/etc/cont-init.d/02-confd-onetime&#34;&gt;&lt;code&gt;/etc/cont-init.d/02-confd-onetime&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/command/execlineb -P&#xA;&#xA;with-contenv&#xA;s6-envuidgid nginx&#xA;multisubstitute&#xA;{&#xA;  import -u -D0 UID&#xA;  import -u -D0 GID&#xA;  import -u CONFD_PREFIX&#xA;  define CONFD_CHECK_CMD &#34;/usr/sbin/nginx -t -c {{ .src }}&#34;&#xA;}&#xA;confd --onetime --prefix=&#34;${CONFD_PREFIX}&#34; --tmpl-uid=&#34;${UID}&#34; --tmpl-gid=&#34;${GID}&#34; --tmpl-src=&#34;/etc/nginx/nginx.conf.tmpl&#34; --tmpl-dest=&#34;/etc/nginx/nginx.conf&#34; --tmpl-check-cmd=&#34;${CONFD_CHECK_CMD}&#34; etcd&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This way is still supported. However, there is now a more generic and efficient way to do it: writing your oneshot initialization and finalization tasks as s6-rc services, by adding service definition directories in &lt;code&gt;/etc/s6-overlay/s6-rc.d&lt;/code&gt;, making them part of the &lt;code&gt;user&lt;/code&gt; bundle (so they are actually started when the container boots), and making them depend on the &lt;code&gt;base&lt;/code&gt; bundle (so they are only started after &lt;code&gt;base&lt;/code&gt;).&lt;/p&gt; &#xA;&lt;p&gt;All the information on s6-rc can be found &lt;a href=&#34;https://skarnet.org/software/s6-rc/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;When the container is started, the operations are performed in this order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;(deprecated) Attribute fixing is performed according to files in &lt;code&gt;/etc/fix-attrs.d&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;(legacy) One-shot initialization scripts in &lt;code&gt;/etc/cont-init.d&lt;/code&gt; are run sequentially.&lt;/li&gt; &#xA; &lt;li&gt;Services in the &lt;code&gt;user&lt;/code&gt; bundle are started by s6-rc, in an order defined by dependencies. Services can be oneshots (initialization tasks) or longruns (daemons that will run throughout the container&#39;s lifetime). If the services depend on &lt;code&gt;base&lt;/code&gt;, they are guaranteed to start at this point and not earlier; if they do not, they might have been started earlier, which may cause race conditions - so it&#39;s recommended to always make them depend on &lt;code&gt;base&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;(legacy) Longrun services in &lt;code&gt;/etc/services.d&lt;/code&gt; are started.&lt;/li&gt; &#xA; &lt;li&gt;Services in the &lt;code&gt;user2&lt;/code&gt; bundle with the correct dependency are started. (Most people don&#39;t need to use this; if you are not sure, stick to the &lt;code&gt;user&lt;/code&gt; bundle.)&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;When the container is stopped, either because the admin sent a stop command or because the CMD exited, the operations are performed in the reverse order:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Services in the &lt;code&gt;user2&lt;/code&gt; bundle with the correct dependency are stopped.&lt;/li&gt; &#xA; &lt;li&gt;(legacy) Longrun services in &lt;code&gt;/etc/services.d&lt;/code&gt; are stopped.&lt;/li&gt; &#xA; &lt;li&gt;All s6-rc services are stopped, in an order defined by dependencies. For oneshots, that means that the &lt;code&gt;down&lt;/code&gt; script in the source definition directory is executed; that&#39;s how s6-rc can perform finalization tasks.&lt;/li&gt; &#xA; &lt;li&gt;(legacy) One shot finalization scripts in &lt;code&gt;/etc/cont-finish.d&lt;/code&gt; are run sequentially.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;The point of the &lt;code&gt;user2&lt;/code&gt; bundle is to allow user services declared in it to start &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;/etc/services.d&lt;/code&gt; ones; but in order to do so, every service in &lt;code&gt;user2&lt;/code&gt; needs to declare a dependency to &lt;code&gt;legacy-services&lt;/code&gt;. In other words, for a service &lt;code&gt;foobar&lt;/code&gt; to start late, you need to:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Define it in &lt;code&gt;/etc/s6-overlay/s6-rc.d/foobar&lt;/code&gt; like any other s6-rc service.&lt;/li&gt; &#xA; &lt;li&gt;Add an &lt;code&gt;/etc/s6-overlay/s6-rc.d/foobar/dependencies.d/legacy-services&lt;/code&gt; file&lt;/li&gt; &#xA; &lt;li&gt;Add an &lt;code&gt;/etc/s6-overlay/s6-rc.d/user2/contents.d/foobar&lt;/code&gt; file.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;That will ensure that &lt;code&gt;foobar&lt;/code&gt; will start &lt;em&gt;after&lt;/em&gt; everything in &lt;code&gt;/etc/services.d&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Writing an optional finish script&lt;/h3&gt; &#xA;&lt;p&gt;By default, services created in &lt;code&gt;/etc/services.d&lt;/code&gt; will automatically restart. If a service should bring the container down, you should probably run it as a CMD instead; but if you&#39;d rather run it as a supervised service, then you&#39;ll need to write a &lt;code&gt;finish&lt;/code&gt; script, which will be run when the service is down; to make the container stop, the &lt;code&gt;/run/s6/basedir/bin/halt&lt;/code&gt; command must be invoked. Here&#39;s an example finish script:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/services.d/myapp/finish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/command/execlineb -S0&#xA;&#xA;foreground { redirfd -w 1 /run/s6-linux-init-container-results/exitcode echo 0 }&#xA;/run/s6/basedir/bin/halt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;The first line of the script writes &lt;code&gt;0&lt;/code&gt; to the &lt;code&gt;/run/s6-linux-init-container-results/exitcode&lt;/code&gt; file. The second line stops the container. When you stop the container via the &lt;code&gt;/run/s6/basedir/bin/halt&lt;/code&gt; command run from inside the container, &lt;code&gt;/run/s6-linux-init-container-results/exitcode&lt;/code&gt; is read and its contents are used as the exit code for the &lt;code&gt;docker run&lt;/code&gt; command that launched the container. If the file doesn&#39;t exist, or if the container is stopped with &lt;code&gt;docker stop&lt;/code&gt; or another reason, that exit code defaults to 0.&lt;/p&gt; &#xA;&lt;p&gt;It is possible to do more advanced operations in a finish script. For example, here&#39;s a script from that only brings down the service when it exits nonzero:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/services.d/myapp/finish&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/command/execlineb -S1&#xA;if { eltest ${1} -ne 0 -a ${1} -ne 256 }&#xA;/run/s6/basedir/bin/halt&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Note that in general, finish scripts should only be used for local cleanups after a daemon dies. If a service is so important that the container needs to stop when it dies, we really recommend running it as the CMD.&lt;/p&gt; &#xA;&lt;h3&gt;Logging&lt;/h3&gt; &#xA;&lt;p&gt;Every service can have its dedicated logger. A logger is a s6 service that automatically reads from the &lt;em&gt;stdout&lt;/em&gt; of your service, and logs the data to an automatically rotated file in the place you want. Note that daemons usually log to stderr, not stdout, so you should probably start your service&#39;s run script with &lt;code&gt;exec 2&amp;gt;&amp;amp;1&lt;/code&gt; in shell, or with &lt;code&gt;fdmove -c 2 1&lt;/code&gt; in execline, in order to catch &lt;em&gt;stderr&lt;/em&gt;.&lt;/p&gt; &#xA;&lt;p&gt;s6-overlay provides a utility called &lt;code&gt;logutil-service&lt;/code&gt; which is a wrapper over the &lt;a href=&#34;https://skarnet.org/software/s6/s6-log.html&#34;&gt;&lt;code&gt;s6-log&lt;/code&gt;&lt;/a&gt; program. This helper does the following:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;read how s6-log should proceed reading the logging script contained in &lt;code&gt;S6_LOGGING_SCRIPT&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;drop privileges to the &lt;code&gt;nobody&lt;/code&gt; user (defaulting to &lt;code&gt;65534:65534&lt;/code&gt; if it doesn&#39;t exist)&lt;/li&gt; &#xA; &lt;li&gt;clean all the environments variables&lt;/li&gt; &#xA; &lt;li&gt;execute into s6-log.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;s6-log will then run forever, reading data from your service and writing it to the directory you specified to &lt;code&gt;logutil-service&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Please note:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Since the privileges are dropped automatically, there is no need to switch users with &lt;code&gt;s6-setuidgid&lt;/code&gt;&lt;/li&gt; &#xA; &lt;li&gt;You should ensure the log folder either: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;exists, and is writable by the &lt;code&gt;nobody&lt;/code&gt; user&lt;/li&gt; &#xA;   &lt;li&gt;does not exist, but the parent folder is writable by the &lt;code&gt;nobody&lt;/code&gt; user.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You can create log folders in &lt;code&gt;cont-init.d&lt;/code&gt; scripts, or as s6-rc oneshots. Here is an example of a logged service &lt;code&gt;myapp&lt;/code&gt; implemented the old way:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/cont-init.d/myapp-log-prepare&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh -e&#xA;mkdir -p /var/log/myapp&#xA;chown nobody:nogroup /var/log/myapp&#xA;chmod 02755 /var/log/myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/services.d/myapp/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh&#xA;exec 2&amp;gt;&amp;amp;1&#xA;exec mydaemon-in-the-foreground-and-logging-to-stderr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/services.d/myapp/log/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh&#xA;exec logutil-service /var/log/myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;And here is the same service, myapp, implemented in s6-rc.&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log-prepare/dependencies.d/base&lt;/code&gt;: empty file&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log-prepare/type&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;oneshot&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log-prepare/up&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;if { mkdir -p /var/log/myapp }&#xA;if { chown nobody:nogroup /var/log/myapp }&#xA;chmod 02755 /var/log/myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;details&gt;&#xA; &lt;summary&gt;(Click here for an explanation of the weird syntax or if you don&#39;t understand why your `up` file isn&#39;t working.)&lt;/summary&gt; &#xA; &lt;p&gt; &lt;/p&gt;&#xA; &lt;p&gt;(Beginning of the detailed section.)&lt;/p&gt; &#xA; &lt;p&gt;So, the &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; files are special: they&#39;re not shell scripts, but single command lines interpreted by &lt;a href=&#34;https://skarnet.org/software/execline/execlineb.html&#34;&gt;execlineb&lt;/a&gt;. You should not have to worry about execline; you should only remember that an &lt;code&gt;up&lt;/code&gt; file contains a single command line. So if you need a script with several instructions, here&#39;s how to do it:&lt;/p&gt; &#xA; &lt;ul&gt; &#xA;  &lt;li&gt;Write your script in the language of your choice, in a location of your choice&lt;/li&gt; &#xA;  &lt;li&gt;Make it executable&lt;/li&gt; &#xA;  &lt;li&gt;Call that script in the &lt;code&gt;up&lt;/code&gt; file.&lt;/li&gt; &#xA; &lt;/ul&gt; &#xA; &lt;p&gt;Here is how you would normally proceed to write the &lt;code&gt;up&lt;/code&gt; file for &lt;code&gt;myapp-log-prepare&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log-prepare/up&lt;/code&gt;:&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code&gt;/etc/s6-overlay/scripts/myapp-log-prepare&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;&lt;code&gt;/etc/s6-overlay/scripts/myapp-log-prepare&lt;/code&gt;: (needs to be executable)&lt;/p&gt; &#xA; &lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh -e&#xA;mkdir -p /var/log/myapp&#xA;chown nobody:nogroup /var/log/myapp&#xA;chmod 02755 /var/log/myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA; &lt;p&gt;The location of the actual script is arbitrary, it just needs to match what you&#39;re writing in the &lt;code&gt;up&lt;/code&gt; file.&lt;/p&gt; &#xA; &lt;p&gt;But here, it just so happens that the script is simple enough that it can fit entirely in the &lt;code&gt;up&lt;/code&gt; file without making it too complex or too difficult to understand. So, we chose to include it as an example to show that there&#39;s more that you can do with &lt;code&gt;up&lt;/code&gt; files, if you are so inclined. You can read the full documentation for the execline language &lt;a href=&#34;https://skarnet.org/software/execline/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA; &lt;p&gt;(End of the detailed section, click the triangle above again to collapse.)&lt;/p&gt; &#xA; &lt;p&gt;&lt;/p&gt; &#xA;&lt;/details&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/dependencies.d/base&lt;/code&gt;: empty file&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log/dependencies.d/myapp-log-prepare&lt;/code&gt;: empty file&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/type&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;longrun&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh&#xA;exec 2&amp;gt;&amp;amp;1&#xA;exec mydaemon-in-the-foreground-and-logging-to-stderr&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp/producer-for&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;myapp-log&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log/type&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;longrun&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log/run&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh&#xA;exec logutil-service /var/log/myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log/consumer-for&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;myapp&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/myapp-log/pipeline-name&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;myapp-pipeline&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/s6-overlay/s6-rc.d/user/contents.d/myapp-pipeline&lt;/code&gt;: empty file&lt;/p&gt; &#xA;&lt;p&gt;That&#39;s a lot of files! A summary of what it all means is:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;myapp-log-prepare is a oneshot, preparing the logging directory. It is a dependency of myapp-log, so it will be started &lt;em&gt;before&lt;/em&gt; myapp-log.&lt;/li&gt; &#xA; &lt;li&gt;myapp is a producer for myapp-log and myapp-log is a consumer for myapp, so what myapp writes to its stdout will go to myapp-log&#39;s stdin. Both are longruns, i.e. daemons that will be supervised by s6.&lt;/li&gt; &#xA; &lt;li&gt;The &lt;code&gt;myapp | myapp-log&lt;/code&gt; pipeline is given a name, &lt;code&gt;myapp-pipeline&lt;/code&gt;, and this name is declared as a part of the &lt;code&gt;user&lt;/code&gt; bundle, so it will be started when the container starts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;myapp-log-prepare&lt;/code&gt;, &lt;code&gt;myapp-log&lt;/code&gt; and &lt;code&gt;myapp&lt;/code&gt; all depend on the &lt;code&gt;base&lt;/code&gt; bundle, which means they will only be started when the system is actually ready to start them.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;It really accomplishes the same things as the &lt;code&gt;/etc/cont-init.d&lt;/code&gt; plus &lt;code&gt;/etc/services.d&lt;/code&gt; method, but it&#39;s a lot cleaner underneath, and can handle much more complex dependency graphs, so whenever you get the opportunity, we recommend you familiarize yourself with the &lt;a href=&#34;https://skarnet.org/software/s6-rc/&#34;&gt;s6-rc&lt;/a&gt; way of declaring your services and your loggers. The full syntax of a service definition directory, including declaring whether your service is a longrun or a oneshot, declaring pipelines, adding service-specific timeouts if you need them, etc., can be found &lt;a href=&#34;https://skarnet.org/software/s6-rc/s6-rc-compile.html#source&#34;&gt;here&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Dropping privileges&lt;/h3&gt; &#xA;&lt;p&gt;When it comes to executing a service, no matter whether it&#39;s a service or a logger, a good practice is to drop privileges before executing it. &lt;code&gt;s6&lt;/code&gt; already includes utilities to do exactly these kind of things:&lt;/p&gt; &#xA;&lt;p&gt;In &lt;code&gt;execline&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;#!/command/execlineb -P&#xA;s6-setuidgid daemon&#xA;myservice&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In &lt;code&gt;sh&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh&#xA;exec s6-setuidgid daemon myservice&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;If you want to know more about these utilities, please take a look at: &lt;a href=&#34;http://skarnet.org/software/s6/s6-setuidgid.html&#34;&gt;&lt;code&gt;s6-setuidgid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;http://skarnet.org/software/s6/s6-envuidgid.html&#34;&gt;&lt;code&gt;s6-envuidgid&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;http://skarnet.org/software/s6/s6-applyuidgid.html&#34;&gt;&lt;code&gt;s6-applyuidgid&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Container environment&lt;/h3&gt; &#xA;&lt;p&gt;If you want your custom script to have container environments available: you can use the &lt;code&gt;with-contenv&lt;/code&gt; helper, which will push all of those into your execution environment, for example:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;/etc/cont-init.d/01-contenv-example&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/command/with-contenv sh&#xA;env&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;This script will output the contents of your container environment.&lt;/p&gt; &#xA;&lt;h3&gt;Read-Only Root Filesystem&lt;/h3&gt; &#xA;&lt;p&gt;Recent versions of Docker allow running containers with a read-only root filesystem. If your container is in such a case, you should set &lt;code&gt;S6_READ_ONLY_ROOT=1&lt;/code&gt; to inform s6-overlay that it should not attempt to write to certain areas - instead, it will perform copies into a tmpfs mounted on &lt;code&gt;/run&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;Note that s6-overlay assumes that:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;/run&lt;/code&gt; exists and is writable. If it is not, it will attempt to mount a tmpfs there.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;/var/run&lt;/code&gt; is a symbolic link to &lt;code&gt;/run&lt;/code&gt;, for compatibility with previous versions. If it is not, it will make it so.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;In general your default docker settings should already provide a suitable tmpfs in &lt;code&gt;/run&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Customizing s6-overlay behaviour&lt;/h3&gt; &#xA;&lt;p&gt;It is possible somehow to tweak s6-overlay&#39;s behaviour by providing an already predefined set of environment variables to the execution context:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;PATH&lt;/code&gt; (default = &lt;code&gt;/command:/usr/bin:/bin&lt;/code&gt;): this is the default PATH that all the services in the container, including the CMD, will have. Set this variable if you have a lot of services that depend on binaries stored in another directory, e.g. &lt;code&gt;/usr/sbin&lt;/code&gt;. Note that &lt;code&gt;/command&lt;/code&gt;, &lt;code&gt;/usr/bin&lt;/code&gt; and &lt;code&gt;/bin&lt;/code&gt; will always be added to that path if they&#39;re not already in the one you provide.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_KEEP_ENV&lt;/code&gt; (default = 0): if set, then environment is not reset and whole supervision tree sees original set of env vars. It switches &lt;code&gt;with-contenv&lt;/code&gt; into a nop.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_LOGGING&lt;/code&gt; (default = 0): &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;: Outputs everything to stdout/stderr.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;: Uses an internal &lt;code&gt;catch-all&lt;/code&gt; logger and persists everything on it, it is located in &lt;code&gt;/var/log/s6-uncaught-logs&lt;/code&gt;. Anything run as a &lt;code&gt;CMD&lt;/code&gt; is still output to stdout/stderr.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;2&lt;/code&gt;&lt;/strong&gt;: Uses an internal &lt;code&gt;catch-all&lt;/code&gt; logger and persists everything on it, including the output of &lt;code&gt;CMD&lt;/code&gt;. Absolutely nothing is written to stdout/stderr.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_CATCHALL_USER&lt;/code&gt; (default = root): if set, and if &lt;code&gt;S6_LOGGING&lt;/code&gt; is 1 or 2, then the catch-all logger is run as this user, which must be defined in your image&#39;s &lt;code&gt;/etc/passwd&lt;/code&gt;. Every bit of privilege separation helps a little with security.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_BEHAVIOUR_IF_STAGE2_FAILS&lt;/code&gt; (default = 0): determines what the container should do if one of the service scripts fails. This includes: &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;if anything fails in &lt;code&gt;fix-attrs&lt;/code&gt;&lt;/li&gt; &#xA;   &lt;li&gt;if any old-style &lt;code&gt;/etc/cont-init.d&lt;/code&gt; or new-style &lt;a href=&#34;https://skarnet.org/software/s6-rc/&#34;&gt;s6-rc&lt;/a&gt; oneshot fails&lt;/li&gt; &#xA;   &lt;li&gt;if any old-style &lt;code&gt;/etc/services.d&lt;/code&gt; or new-style &lt;a href=&#34;https://skarnet.org/software/s6-rc/&#34;&gt;s6-rc&lt;/a&gt; longrun is marked as expecting readiness notification, and fails to become &lt;em&gt;ready&lt;/em&gt; in the allotted time (see &lt;code&gt;S6_CMD_WAIT_FOR_SERVICES_MAXTIME&lt;/code&gt; below). The valid values for &lt;code&gt;S6_BEHAVIOUR_IF_STAGE2_FAILS&lt;/code&gt; are the following:&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;: Continue silently even if a script has failed.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;: Continue but warn with an annoying error message.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;2&lt;/code&gt;&lt;/strong&gt;: Stop the container.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_KILL_FINISH_MAXTIME&lt;/code&gt; (default = 5000): How long (in milliseconds) the system should wait, at shutdown time, for a script in &lt;code&gt;/etc/cont-finish.d&lt;/code&gt; to finish naturally. After this duration, the script will be sent a SIGKILL. Bear in mind that scripts in &lt;code&gt;/etc/cont.finish.d&lt;/code&gt; are run sequentially, and the shutdown sequence will potentially wait for &lt;code&gt;S6_KILL_FINISH_MAXTIME&lt;/code&gt; milliseconds for &lt;em&gt;each&lt;/em&gt; script.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_SERVICES_READYTIME&lt;/code&gt; (default = 50): With services declared in &lt;code&gt;/etc/services.d&lt;/code&gt;, there is an unavoidable race condition between the moment when services are started and the moment when they can be tested for readiness. To avoid that race, we sleep a little time, by default 50 milliseconds, before testing for readiness. If your machine is slow or very busy, you may get errors looking like &lt;code&gt;s6-svwait: fatal: unable to s6_svstatus_read: No such file or directory&lt;/code&gt;. In that case, you should increase the sleeping time, by declaring it (in milliseconds) in the &lt;code&gt;S6_SERVICES_READYTIME&lt;/code&gt; variable. Note that it only concerns &lt;code&gt;/etc/services.d&lt;/code&gt;; s6-rc is immune to the race condition.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_SERVICES_GRACETIME&lt;/code&gt; (default = 3000): How long (in milliseconds) &lt;code&gt;s6&lt;/code&gt; should wait, at shutdown time, for services declared in &lt;code&gt;/etc/services.d&lt;/code&gt; to die before proceeding with the rest of the shutdown.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_KILL_GRACETIME&lt;/code&gt; (default = 3000): How long (in milliseconds) &lt;code&gt;s6&lt;/code&gt; should wait, at the end of the shutdown procedure when all the processes have received a TERM signal, for them to die before sending a &lt;code&gt;KILL&lt;/code&gt; signal to make &lt;em&gt;sure&lt;/em&gt; they&#39;re dead.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_LOGGING_SCRIPT&lt;/code&gt; (default = &#34;n20 s1000000 T&#34;): This env decides what to log and how, by default every line will prepend with ISO8601, rotated when the current logging file reaches 1mb and archived, at most, with 20 files.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_CMD_ARG0&lt;/code&gt; (default = not set): Value of this env var will be prepended to any &lt;code&gt;CMD&lt;/code&gt; args passed by docker. Use it if you are migrating an existing image to s6-overlay and want to make it a drop-in replacement: setting this variable to the value of a previously used ENTRYPOINT will help you transition.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_CMD_USE_TERMINAL&lt;/code&gt; (default = 0): Set this value to &lt;strong&gt;1&lt;/strong&gt; if you have a CMD that needs a terminal for its output (typically when you&#39;re running your container with &lt;code&gt;docker run -it&lt;/code&gt;), and you have set &lt;code&gt;S6_LOGGING&lt;/code&gt; to a nonzero value. This setting will make your CMD actually output to your terminal; the drawback is that its output will not be logged. By default (when this variable is &lt;strong&gt;0&lt;/strong&gt; or not set), the stdout and stderr of your CMD are logged when &lt;code&gt;S6_LOGGING&lt;/code&gt; is nonzero, which means they go to a pipe even if you&#39;re running it in an interactive terminal.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_FIX_ATTRS_HIDDEN&lt;/code&gt; (default = 0): Controls how &lt;code&gt;fix-attrs.d&lt;/code&gt; scripts process files and directories. &#xA;  &lt;ul&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;: Hidden files and directories are excluded.&lt;/li&gt; &#xA;   &lt;li&gt;&lt;strong&gt;&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;: All files and directories are processed.&lt;/li&gt; &#xA;  &lt;/ul&gt; &lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_CMD_WAIT_FOR_SERVICES&lt;/code&gt; (default = 0): By default when the container starts, services in &lt;code&gt;/etc/services.d&lt;/code&gt; will be started and execution will proceed to starting the &lt;code&gt;user2&lt;/code&gt; bundle and the CMD, if any of these is defined. If &lt;code&gt;S6_CMD_WAIT_FOR_SERVICES&lt;/code&gt; is nonzero, however, the container starting sequence will wait until the services in &lt;code&gt;/etc/services.d&lt;/code&gt; are &lt;em&gt;ready&lt;/em&gt; before proceeding with the rest of the sequence. Note that this is only significant if the services in &lt;code&gt;/etc/services.d&lt;/code&gt; &lt;a href=&#34;https://skarnet.org/software/s6/notifywhenup.html&#34;&gt;notify their readiness&lt;/a&gt; to s6.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_CMD_WAIT_FOR_SERVICES_MAXTIME&lt;/code&gt; (default = 5000): The maximum time (in milliseconds) the services could take to bring up before proceding to CMD executing. Note that this value also includes the time setting up legacy container initialization (&lt;code&gt;/etc/cont-init.d&lt;/code&gt;) and services (&lt;code&gt;/etc/services.d&lt;/code&gt;), and that it is taken into account even if you are not running a CMD. In other words: no matter whether you&#39;re running a CMD or not, if you have scripts in &lt;code&gt;/etc/cont-init.d&lt;/code&gt; that take a long time to run, you should set this variable to either 0, or a value high enough so that your scripts have time to finish without s6-overlay interrupting them and diagnosing an error.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_READ_ONLY_ROOT&lt;/code&gt; (default = 0): When running in a container whose root filesystem is read-only, set this env to &lt;strong&gt;1&lt;/strong&gt; to inform init stage 2 that it should copy user-provided initialization scripts from &lt;code&gt;/etc&lt;/code&gt; to &lt;code&gt;/run/s6/etc&lt;/code&gt; before it attempts to change permissions, etc. See &lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/#read-only-root-filesystem&#34;&gt;Read-Only Root Filesystem&lt;/a&gt; for more information.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_SYNC_DISKS&lt;/code&gt; (default = 0): Set this env to &lt;strong&gt;1&lt;/strong&gt; to inform init stage 3 that it should attempt to sync filesystems before stopping the container. Note: this will likely sync all filesystems on the host.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_STAGE2_HOOK&lt;/code&gt; (default = none): If this variable exists, its contents will be interpreted as a shell excerpt that will be run in the early stage 2, before services are started. This can be used, for instance, to dynamically patch the service database at run-time right before it is compiled and run. The wrong value can prevent your container from running or endanger your security, so only use this if you know exactly what you are doing. When in doubt, leave this variable undefined.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_VERBOSITY&lt;/code&gt; (default = 2): controls the verbosity of s6-rc, and potentially other tools, at container start and stop time. The default, 2, is normally verbose: it will list the service start and stop operations. You can make the container quieter by decreasing this number: 1 will only print warnings and errors, and 0 will only print errors. You can also make the container &lt;em&gt;more&lt;/em&gt; verbose, i.e. print tracing and debug information, by increasing this number up to 5, but the output will quickly become &lt;em&gt;very&lt;/em&gt; noisy, and most people shouldn&#39;t need this.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;S6_CMD_RECEIVE_SIGNALS&lt;/code&gt; (default = 0): decides whether signals sent to the container should be sent to the container&#39;s pid 1 or to the CMD. By default, when you perform for instance a &lt;code&gt;docker stop&lt;/code&gt;, a TERM signal will be sent to the container&#39;s pid 1, which will trigger the full container shutdown sequence - but if a CMD is present, it will be among the last processes to be killed, only when everything else is down and the container is about to exit. If this variable is 1 or more, signals are diverted from pid 1 to the CMD, which means that &lt;code&gt;docker stop&lt;/code&gt; will send a SIGTERM to the CMD instead, and the container will only trigger its shutdown procedure when the CMD is dead. Note that only SIGTERM, SIGQUIT, SIGINT, SIGUSR1, SIGUSR2, SIGPWR and SIGWINCH are diverted; other signals either are ignored or cannot be diverted and are necessarily handled by pid 1. Please be aware that using this option may prevent interactive CMDs from working at all - in other words, if you&#39;re running an interactive CMD in a terminal, don&#39;t set this variable; but that should be fine since in this case you already have interactive ways of stopping your CMD.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;syslog&lt;/h3&gt; &#xA;&lt;p&gt;If software running in your container requires syslog, extract the &lt;code&gt;syslogd-overlay-noarch.tar.xz&lt;/code&gt; tarball: that will give you a small syslogd emulation. Logs will be found under various subdirectories of &lt;code&gt;/var/log/syslogd&lt;/code&gt;, for instance messages will be found in the &lt;code&gt;/var/log/syslogd/messages/&lt;/code&gt; directory, the latest logs being available in the &lt;code&gt;/var/log/syslogd/messages/current&lt;/code&gt; file. Logging directories are used rather than files so that logs can be automatically rotated without race conditions (that is a feature of &lt;a href=&#34;https://skarnet.org/software/s6/s6-log.html&#34;&gt;s6-log&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;It is recommended to add &lt;code&gt;syslog&lt;/code&gt; and &lt;code&gt;sysllog&lt;/code&gt; users to your image, for privilege separation; the syslogd emulation processes will run as these users if they exist. Otherwise they will default to &lt;code&gt;32760:32760&lt;/code&gt; and &lt;code&gt;32761:32761&lt;/code&gt;, numeric uids/gids that may already exist on your system.&lt;/p&gt; &#xA;&lt;h2&gt;Performance&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;The noarch and symlinks tarballs are all tiny. The biggest tarball is the one that contains the binaries; it&#39;s around 650 kB.&lt;/li&gt; &#xA; &lt;li&gt;Uncompressed on a tmpfs, the overlay scripts use about 120 kB, and the binaries for x86_64 use about 5.7 MB.&lt;/li&gt; &#xA; &lt;li&gt;We haven&#39;t yet measured the time it takes for the container to be up and running once you run &lt;code&gt;docker run&lt;/code&gt;, but you will notice it&#39;s fast. Faster than previous versions of s6-overlay, with fewer delays. And if you convert your &lt;code&gt;/etc/cont-init.d&lt;/code&gt; scripts to the s6-rc format, they will be able to run in parallel, so you will gain even more performance. If you have benchmarks, please send them to us!&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Verifying Downloads&lt;/h2&gt; &#xA;&lt;p&gt;The s6-overlay releases have a checksum files you can use to verify the download using SHA256:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz.sha256 /tmp&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp&#xA;ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz.sha256 /tmp&#xA;RUN cd /tmp &amp;amp;&amp;amp; sha256sum -c *.sha256&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Notes&lt;/h2&gt; &#xA;&lt;h3&gt;&lt;code&gt;USER&lt;/code&gt; directive&lt;/h3&gt; &#xA;&lt;p&gt;As of version 3.1.5.0, s6-overlay has limited support for running as a user other than &lt;code&gt;root&lt;/code&gt;:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Tools like &lt;code&gt;fix-attrs&lt;/code&gt; and &lt;code&gt;logutil-service&lt;/code&gt; are unlikely to work (they rely on being able to change UIDs).&lt;/li&gt; &#xA; &lt;li&gt;The syslogd emulation will not work.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;Generally speaking, if you&#39;re running a simple container with a main application and one or two support services, you may benefit from the &lt;code&gt;USER&lt;/code&gt; directive if that is your preferred way of running containers. However, if you&#39;re running more than a few services, or daemons that expect a real system with complete Unix infrastructure, then USER is probably not a good idea and you would benefit more from using privilege separation between services in your container.&lt;/p&gt; &#xA;&lt;h2&gt;Releases&lt;/h2&gt; &#xA;&lt;p&gt;Over on the releases tab, we have a number of tarballs:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-noarch.tar.xz&lt;/code&gt;: the s6-overlay scripts.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-${arch}.tar.xz&lt;/code&gt;: the binaries for platform &lt;em&gt;${arch}&lt;/em&gt;. They are statically compiled and will work with any Linux distribution.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-symlinks-noarch.tar.xz&lt;/code&gt;: &lt;code&gt;/usr/bin&lt;/code&gt; symlinks to the s6-overlay scripts. Totally optional.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-symlinks-arch.tar.xz&lt;/code&gt;: &lt;code&gt;/usr/bin&lt;/code&gt; symlinks to the skaware binaries. Totally optional.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;syslogd-overlay-noarch.tar.xz&lt;/code&gt;: the syslogd emulation. Totally optional.&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;s6-overlay-${version}.tar.xz&lt;/code&gt;: the s6-overlay source. Download it if you want to build s6-overlay yourself.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;We have binaries for at least x86_64, aarch64, arm32, i486, i686, riscv64, and s390x. The full list of supported arches can be found in &lt;a href=&#34;https://github.com/just-containers/s6-overlay/raw/master/conf/toolchains&#34;&gt;conf/toolchains&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Which architecture to use depending on your TARGETARCH&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;code&gt;${arch}&lt;/code&gt; part in the &lt;code&gt;s6-overlay-${arch}.tar.xz&lt;/code&gt; tarball uses the naming conventions of gcc, which are not the ones that Docker uses. (Everyone does something different in this field depending on their needs, and no solution is better than any other, but the Docker one is &lt;em&gt;worse&lt;/em&gt; than others because its naming is inconsistent. The gcc convention is better for us because it simplifies our builds greatly and makes them more maintainable.)&lt;/p&gt; &#xA;&lt;p&gt;The following table should help you find the right tarball for you if you&#39;re using the TARGETARCH value provided by Docker:&lt;/p&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;${TARGETARCH}&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;${arch}&lt;/th&gt; &#xA;   &lt;th align=&#34;left&#34;&gt;Notes&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;amd64&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;x86_64&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;arm64&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;aarch64&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;arm/v7&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;arm&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;armv7 with soft-float&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;arm/v6&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;armhf&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;Raspberry Pi 1&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;386&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;i686&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;i486 for very old hw&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;riscv64&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;riscv64&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;s390x&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;s390x&lt;/td&gt; &#xA;   &lt;td align=&#34;left&#34;&gt;&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt; &#xA;&lt;p&gt;If you need another architecture, ask us and we&#39;ll try to make a toolchain for it. In particular, we know that armv7 is a mess and needs a flurry of options depending on your precise target (and this is one of the reasons why the Docker naming system isn&#39;t good, although arguably the gcc naming system isn&#39;t much better on that aspect).&lt;/p&gt; &#xA;&lt;h2&gt;Contributing&lt;/h2&gt; &#xA;&lt;p&gt;Any way you want! Open issues, open PRs, we welcome all contributors!&lt;/p&gt; &#xA;&lt;h2&gt;Building the overlay yourself&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Download the [s6-overlay source].&lt;/li&gt; &#xA; &lt;li&gt;Check the &lt;a href=&#34;https://github.com/just-containers/s6-overlay/raw/master/conf/defaults.mk&#34;&gt;conf/defaults.mk&lt;/a&gt; file for variables you may want to change. Do not modify the file itself.&lt;/li&gt; &#xA; &lt;li&gt;Call &lt;code&gt;make&lt;/code&gt; followed by your variable assignments. Example: &lt;code&gt;make ARCH=riscv64-linux-musl&lt;/code&gt; to build the overlay for RISCV64.&lt;/li&gt; &#xA; &lt;li&gt;The tarballs will be in the &lt;code&gt;output&lt;/code&gt; subdirectory, unless you changed the &lt;code&gt;OUTPUT&lt;/code&gt; variable.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Upgrade Notes&lt;/h2&gt; &#xA;&lt;p&gt;Please see &lt;a href=&#34;https://raw.githubusercontent.com/just-containers/s6-overlay/master/CHANGELOG.md&#34;&gt;CHANGELOG&lt;/a&gt;.&lt;/p&gt;</summary>
  </entry>
</feed>