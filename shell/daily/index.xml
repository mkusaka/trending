<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-11-08T01:41:22Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>CentOS/centos-boot</title>
    <updated>2023-11-08T01:41:22Z</updated>
    <id>tag:github.com,2023-11-08:/CentOS/centos-boot</id>
    <link href="https://github.com/CentOS/centos-boot" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Goals&lt;/h1&gt; &#xA;&lt;p&gt;This project&#39;s toplevel goal is to create base &lt;em&gt;bootable&lt;/em&gt; container images from Fedora ELN and CentOS Stream packages.&lt;/p&gt; &#xA;&lt;h2&gt;Status&lt;/h2&gt; &#xA;&lt;p&gt;This is an in-development project not intended for production use yet.&lt;/p&gt; &#xA;&lt;h2&gt;Trying it out&lt;/h2&gt; &#xA;&lt;p&gt;See &lt;a href=&#34;https://raw.githubusercontent.com/CentOS/centos-boot/main/install.md&#34;&gt;install.md&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Differences from Fedora CoreOS&lt;/h2&gt; &#xA;&lt;p&gt;Fedora CoreOS today is not small; there are multiple reasons for this, but primarily because it was created in a pre-bootable-container time. Not everyone wants e.g. moby-engine.&lt;/p&gt; &#xA;&lt;p&gt;But going beyond size, the images produced by this project will focus on a container-native flow. We will ship a (container) image that does not include Ignition for example.&lt;/p&gt; &#xA;&lt;h2&gt;Differences from RHEL CoreOS&lt;/h2&gt; &#xA;&lt;p&gt;We sometimes say that RHEL CoreOS &lt;a href=&#34;https://github.com/openshift/os/raw/master/docs/faq.md#q-what-is-coreos&#34;&gt;has FCOS as an upstream&lt;/a&gt; but this is only kind of true; RHEL CoreOS includes a subset of FCOS content, and is lifecycled with OCP.&lt;/p&gt; &#xA;&lt;p&gt;An explicit goal of this project is to produce bootable container images that can be used as &lt;em&gt;base images&lt;/em&gt; for RHEL CoreOS; for more on this, see e.g. &lt;a href=&#34;https://github.com/openshift/os/issues/799&#34;&gt;https://github.com/openshift/os/issues/799&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Differences from RHEL for Edge&lt;/h2&gt; &#xA;&lt;p&gt;It is an explicit goal that CentOS boot also becomes a &#34;base input&#34; to RHEL for Edge.&lt;/p&gt; &#xA;&lt;h2&gt;What does CentOS boot means&lt;/h2&gt; &#xA;&lt;p&gt;From &lt;a href=&#34;https://en.wikipedia.org/wiki/Bamboo_Forest_(Kyoto,_Japan)&#34;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Bamboo Forest, Arashiyama Bamboo Grove or CentOS boot Bamboo Forest, is a natural forest of bamboo in Arashiyama, Kyoto, Japan&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h2&gt;Demonstration base images for Project CentOS boot&lt;/h2&gt; &#xA;&lt;p&gt;These images are technology demonstrators, not for production use. The intention is that these images are generated by the OS vendor or distribution.&lt;br&gt; Or, you can fork this repository and generate your own via &lt;code&gt;rpm-ostree compose image&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h2&gt;Operating system sources&lt;/h2&gt; &#xA;&lt;p&gt;At the moment these demonstration builds use Fedora ELN and CentOS Stream 9.&lt;/p&gt; &#xA;&lt;h2&gt;Tiers&lt;/h2&gt; &#xA;&lt;h3&gt;Tier 0&lt;/h3&gt; &#xA;&lt;p&gt;This is the basic tier; it has effectively just:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;kernel systemd selinux-policy-targeted bootc&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;You are generally going to need to generate derived images from this; installing it on its own will boot to a system with no automatic networking support, no SSH, and no default passwords etc.&lt;/p&gt; &#xA;&lt;h3&gt;Tier 1&lt;/h3&gt; &#xA;&lt;p&gt;This is larger system.&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;NetworkManager, chrony&lt;/li&gt; &#xA; &lt;li&gt;rpm-ostree (to install packages and in case it&#39;s useful &#34;day 2&#34;)&lt;/li&gt; &#xA; &lt;li&gt;openssh-server&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;At the current time, it does not include Ignition or cloud-init; so you will still need to derive from it in order to inject a mechanism to log in in many cases. However, it will work to install it using e.g. Anaconda and set up users and passwords that way.&lt;/p&gt; &#xA;&lt;h2&gt;Image matrix (Fedora)&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;quay.io/centos-boot/fedora-tier-1:eln&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;More about image sources&lt;/h3&gt; &#xA;&lt;p&gt;The current manifest definitions &lt;a href=&#34;https://raw.githubusercontent.com/CentOS/centos-boot/main/tier-0&#34;&gt;tier-0&lt;/a&gt; and &lt;a href=&#34;https://raw.githubusercontent.com/CentOS/centos-boot/main/tier-1&#34;&gt;tier-1&lt;/a&gt; were forked from Fedora CoreOS, but significantly cut down.&lt;/p&gt; &#xA;&lt;p&gt;The existing content set is obviously subject to change and debate.&lt;/p&gt; &#xA;&lt;h2&gt;Building&lt;/h2&gt; &#xA;&lt;p&gt;Here&#39;s an example command:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo rpm-ostree compose image --authfile ~/.config/containers/myquay.json --cachedir=cache -i --format=ociarchive centos-tier-0-stream9.yaml centos-tier-0-stream9.ociarchive&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;In some situations, copying to a local &lt;code&gt;.ociarchive&lt;/code&gt; file is convenient. You can also push to a registry with &lt;code&gt;--format=registry&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;p&gt;More information at &lt;a href=&#34;https://coreos.github.io/rpm-ostree/container/&#34;&gt;https://coreos.github.io/rpm-ostree/container/&lt;/a&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Badges&lt;/h2&gt; &#xA;&lt;table&gt; &#xA; &lt;thead&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;th&gt;Badge&lt;/th&gt; &#xA;   &lt;th&gt;Description&lt;/th&gt; &#xA;   &lt;th&gt;Service&lt;/th&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/thead&gt; &#xA; &lt;tbody&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://renovatebot.com&#34;&gt;&lt;img src=&#34;https://github.com/openshift/os/raw/master/docs/faq.md#q-what-is-coreos&#34; alt=&#34;Renovate&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Dependencies&lt;/td&gt; &#xA;   &lt;td&gt;Renovate&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA;  &lt;tr&gt; &#xA;   &lt;td&gt;&lt;a href=&#34;https://pre-commit.com/&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&#34; alt=&#34;Pre-commit&#34;&gt;&lt;/a&gt;&lt;/td&gt; &#xA;   &lt;td&gt;Static quality gates&lt;/td&gt; &#xA;   &lt;td&gt;pre-commit&lt;/td&gt; &#xA;  &lt;/tr&gt; &#xA; &lt;/tbody&gt; &#xA;&lt;/table&gt;</summary>
  </entry>
  <entry>
    <title>apernet/tcp-brutal</title>
    <updated>2023-11-08T01:41:22Z</updated>
    <id>tag:github.com,2023-11-08:/apernet/tcp-brutal</id>
    <link href="https://github.com/apernet/tcp-brutal" rel="alternate"></link>
    <summary type="html">&lt;p&gt;&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;&lt;img src=&#34;https://raw.githubusercontent.com/apernet/tcp-brutal/master/logo.png&#34; alt=&#34;TCP Brutal&#34;&gt;&lt;/h1&gt; &#xA;&lt;p&gt;TCP Brutal is &lt;a href=&#34;https://hysteria.network/&#34;&gt;Hysteria&lt;/a&gt;&#39;s congestion control algorithm ported to TCP, as a Linux kernel module. Information about Brutal itself can be found in the &lt;a href=&#34;https://hysteria.network/docs/advanced/Full-Server-Config/#bandwidth-behavior-explained&#34;&gt;Hysteria documentation&lt;/a&gt;. As an official subproject of Hysteria, TCP Brutal is actively maintained to be in sync with the Brutal implementation in Hysteria.&lt;/p&gt; &#xA;&lt;p&gt;&lt;strong&gt;中文文档：&lt;a href=&#34;https://raw.githubusercontent.com/apernet/tcp-brutal/master/README.zh.md&#34;&gt;README.zh.md&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; &#xA;&lt;h2&gt;For users&lt;/h2&gt; &#xA;&lt;p&gt;Installation script:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash &amp;lt;(curl -fsSL https://tcp.hy2.sh/)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;Manual compilation and loading:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Make sure kernel headers are installed&#xA;# Ubuntu: apt install linux-headers-$(uname -r)&#xA;make &amp;amp;&amp;amp; make load&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;blockquote&gt; &#xA; &lt;p&gt;Kernel version 5.8 or later is required.&lt;/p&gt; &#xA;&lt;/blockquote&gt; &#xA;&lt;h3&gt;Do I need a new proxy protocol?&lt;/h3&gt; &#xA;&lt;p&gt;No. TCP Brutal supports all existing TCP proxy protocols, &lt;strong&gt;but requires support from both the client and server software&lt;/strong&gt; (to provide bandwidth options, exchange bandwidth information, etc.). Ask the developers of the proxy software you use to add support.&lt;/p&gt; &#xA;&lt;h3&gt;Speed test&lt;/h3&gt; &#xA;&lt;p&gt;The &lt;a href=&#34;https://raw.githubusercontent.com/apernet/tcp-brutal/master/example&#34;&gt;example&lt;/a&gt; directory contains a simple speed test server+client in Python. Usage:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Server, listening on TCP port 1234&#xA;python server.py -p 1234&#xA;&#xA;# Client, connect to example.com:1234, request download speed of 50 Mbps&#xA;python client.py -p 1234 example.com 50&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;Do I need to configure sysctl? / Can I set TCP Brutal as the system&#39;s default congestion control?&lt;/h3&gt; &#xA;&lt;p&gt;You don&#39;t need to, and shouldn&#39;t. Unlike BBR, TCP Brutal can only work properly if the program sets the bandwidth using a special sockopt, which most programs don&#39;t support unless otherwise specified. Setting it as the default congestion control would slow down all connections to 1 Mbps. Programs that do support it will actively switch to using TCP Brutal congestion control on their own.&lt;/p&gt; &#xA;&lt;h2&gt;For developers&lt;/h2&gt; &#xA;&lt;p&gt;This kernel module adds a new &#34;brutal&#34; TCP congestion control algorithm to the system, which programs can enable using TCP_CONGESTION sockopt.&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s.setsockopt(socket.IPPROTO_TCP, TCP_CONGESTION, &#34;brutal&#34;.encode())&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To set the send rate and congestion window gain (we recommend a default value of 1.5x to 2x, which is expressed as 15/20 since the kernel doesn&#39;t support floating point):&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct brutal_params&#xA;{&#xA;    u64 rate;      // Send rate in bytes per second&#xA;    u32 cwnd_gain; // CWND gain in tenths (10=1.0)&#xA;} __packed;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;TCP_BRUTAL_PARAMS = 23301&#xA;&#xA;rate = 2000000 # 2 MB/s&#xA;cwnd_gain = 15&#xA;brutal_params_value = struct.pack(&#34;QI&#34;, rate, cwnd_gain)&#xA;conn.setsockopt(socket.IPPROTO_TCP, TCP_BRUTAL_PARAMS, brutal_params_value)&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h3&gt;For proxy developers (important)&lt;/h3&gt; &#xA;&lt;p&gt;Like Hysteria, Brutal is designed for environments where the user knows the bandwidth of their connection, as this information is essential for Brutal to work. While Hysteria&#39;s protocol is designed with this in mind, none of the existing TCP proxy protocols (at the time of this writing) have such a mechanism for exchanging bandwidth information between client and server, so that a client can tell the server how fast it should send and vice versa.&lt;/p&gt; &#xA;&lt;p&gt;To work around this, we suggest using the &#34;destination address&#34; field, which every proxy protocol has in one form or another. Clients and servers supporting TCP Brutal can use a special address (e.g. &lt;code&gt;_BrutalBwExchange&lt;/code&gt;) to indicate that they want to exchange bandwidth information. For example, the client can create a &lt;code&gt;_BrutalBwExchange&lt;/code&gt; connection request and, if the server accepts, use that connection to exchange bandwidth information with the server.&lt;/p&gt; &#xA;&lt;p&gt;The following link shows how this is implemented in sing-box:&lt;/p&gt; &#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/SagerNet/sing-mux/commit/ae2745a33479b125453cb918e6d40b8305c09dff&#34;&gt;https://github.com/SagerNet/sing-mux/commit/ae2745a33479b125453cb918e6d40b8305c09dff&lt;/a&gt;&lt;/p&gt; &#xA;&lt;p&gt;An important aspect to understand about TCP Brutal&#39;s rate setting is that it applies to each individual connection. &lt;strong&gt;This makes it suitable only for protocols that support multiplexing (mux), which allows a client to consolidate all proxy connections into a single TCP connection.&lt;/strong&gt; For protocols that require a separate connection for each proxy connection, using TCP Brutal will overwhelm the receiver if multiple connections are active at the same time.&lt;/p&gt; &#xA;&lt;h3&gt;Compatibility&lt;/h3&gt; &#xA;&lt;p&gt;TCP Brutal is only a congestion control algorithm for TCP and does not alter the TCP protocol itself. Clients and servers can use TCP Brutal unilaterally. The congestion control algorithm controls the sending of data, and since proxy users typically download far more data than they upload, implementing TCP Brutal on the server side alone can reap most of the benefits. (Clients using TCP Brutal could achieve better upload speeds, but many users are on Windows, MacOS, or phones where installing kernel modules is impractical).&lt;/p&gt;</summary>
  </entry>
</feed>