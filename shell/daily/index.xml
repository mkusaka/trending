<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>GitHub Shell Daily Trending</title>
  <id>http://mshibanami.github.io/GitHubTrendingRSS</id>
  <updated>2023-03-13T01:43:07Z</updated>
  <subtitle>Daily Trending of Shell in GitHub</subtitle>
  <link href="http://mshibanami.github.io/GitHubTrendingRSS"></link>
  <entry>
    <title>IvanGlinkin/Domain_checker</title>
    <updated>2023-03-13T01:43:07Z</updated>
    <id>tag:github.com,2023-03-13:/IvanGlinkin/Domain_checker</id>
    <link href="https://github.com/IvanGlinkin/Domain_checker" rel="alternate"></link>
    <summary type="html">&lt;p&gt;Domain_checker application is the trial/demo version for the new EASM (External Attack Surface Management) system called HydrAttack (hydrattack.com), the main idea of which is, based only on the domain name, find almost all of the subdomains and their top 100 open ports&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;Domain_checker&lt;/h1&gt; &#xA;&lt;p&gt;Domain_checker application is the trial/demo version for the new EASM (External Attack Surface Management) system called HydrAttack (hydrattack.com), the main idea of which is, based only on the domain name, find almost all of the subdomains and their top 100 open ports&lt;/p&gt; &#xA;&lt;h2&gt;Usage example:&lt;/h2&gt; &#xA;&lt;pre&gt;&lt;code&gt;chmod +x domain_checker.sh&#xA;./domain_checker.sh&#xA;&amp;gt; Enter the domain you want to enumerate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;or&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;bash ./domain_checker.sh&#xA;&amp;gt; Enter the domain you want to enumerate&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;h2&gt;Video example:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/IvanGlinkin/media_support/raw/main/Domain_checker_Video.gif?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Screenshots:&lt;/h2&gt; &#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/IvanGlinkin/media_support/raw/main/Domain_checker_image.png?raw=true&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</summary>
  </entry>
  <entry>
    <title>nichobi/sponsorblockcast</title>
    <updated>2023-03-13T01:43:07Z</updated>
    <id>tag:github.com,2023-03-13:/nichobi/sponsorblockcast</id>
    <link href="https://github.com/nichobi/sponsorblockcast" rel="alternate"></link>
    <summary type="html">&lt;p&gt;A shell script that skips sponsored YouTube content on all local Chromecasts&lt;/p&gt;&lt;hr&gt;&lt;h1&gt;sponsorblockcast&lt;/h1&gt; &#xA;&lt;p&gt;A POSIX shell script that skips sponsored YouTube content and skippable ads on all local Chromecasts, using the &lt;a href=&#34;https://github.com/ajayyy/SponsorBlock&#34;&gt;SponsorBlock&lt;/a&gt; API. It was inspired by &lt;a href=&#34;https://github.com/stephen304/castblock&#34;&gt;CastBlock&lt;/a&gt; but written from scratch to avoid some of its pitfalls (see &lt;a href=&#34;https://raw.githubusercontent.com/nichobi/sponsorblockcast/main/#differences-from-castblock&#34;&gt;Differences from CastBlock&lt;/a&gt;).&lt;/p&gt; &#xA;&lt;p&gt;Care was taken to ensure it&#39;s fully POSIX-compatible, so it can run on lighter shells such as &lt;a href=&#34;https://wiki.archlinux.org/index.php/Dash&#34;&gt;Dash&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;p&gt;The script will scan for all Chromecasts on the LAN, and launches a process for each one to efficiently poll it status every second. If a Chromecast is found to be playing a YouTube video, sponsor segments are fetched from the SponsorBlock API and stored in a temporary file. Whenever the Chromecast reaches a sponsored segment, the script tells it to seek to the end of the segment.&lt;/p&gt; &#xA;&lt;p&gt;Additionally, sponsorblockcast will look for skippable YouTube ads, and automatically hit the skip button when it becomes avilable.&lt;/p&gt; &#xA;&lt;h2&gt;Installation&lt;/h2&gt; &#xA;&lt;h3&gt;Arch Linux&lt;/h3&gt; &#xA;&lt;p&gt;Install &lt;a href=&#34;https://aur.archlinux.org/packages/sponsorblockcast-git&#34;&gt;sponsorblockcast-git&lt;/a&gt; with your &lt;a href=&#34;https://wiki.archlinux.org/index.php/AUR_helpers&#34;&gt;AUR helper&lt;/a&gt; of choice or with &lt;a href=&#34;https://wiki.archlinux.org/index.php/Arch_User_Repository#Installing_and_upgrading_packages&#34;&gt;makepkg&lt;/a&gt;.&lt;/p&gt; &#xA;&lt;h3&gt;Docker image&lt;/h3&gt; &#xA;&lt;p&gt;You can &lt;a href=&#34;https://docs.docker.com/engine/install/&#34;&gt;install Docker&lt;/a&gt; directly or use &lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;Docker Compose&lt;/a&gt; (Or use Podman, Portainer, etc). Please note you &lt;em&gt;MUST&lt;/em&gt; use the &#39;host&#39; network as shown below for CLI Docker or in the example for &lt;code&gt;docker-compose&lt;/code&gt;.&lt;/p&gt; &#xA;&lt;h4&gt;Docker&lt;/h4&gt; &#xA;&lt;p&gt;Run the below commands as root or a member of the &lt;code&gt;docker&lt;/code&gt; group&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker run --network=host --name sponsorblockcast ghcr.io/nichobi/sponsorblockcast:latest&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Docker Compose&lt;/h4&gt; &#xA;&lt;p&gt;First you will need a &lt;code&gt;docker-compose.yaml&lt;/code&gt; file, such as the example included. Run the below commands as root or a member of the &lt;code&gt;docker&lt;/code&gt; group&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;docker-compose up -d&lt;/code&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h3&gt;Manual installation&lt;/h3&gt; &#xA;&lt;h4&gt;Dependencies&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://github.com/vishen/go-chromecast&#34;&gt;go-chromecast&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://stedolan.github.io/jq&#34;&gt;jq&lt;/a&gt;&lt;/li&gt; &#xA; &lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/bc&#34;&gt;bc&lt;/a&gt;&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h4&gt;Instructions&lt;/h4&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Copy &lt;a href=&#34;https://raw.githubusercontent.com/nichobi/sponsorblockcast/main/sponsorblockcast.sh&#34;&gt;sponsorblockcast.sh&lt;/a&gt; to &lt;code&gt;/usr/bin/sponsorblockcast&lt;/code&gt;.&lt;/li&gt; &#xA; &lt;li&gt;Copy &lt;a href=&#34;https://raw.githubusercontent.com/nichobi/sponsorblockcast/main/sponsorblockcast.service&#34;&gt;sponsorblockcast.service&lt;/a&gt; to &lt;code&gt;/usr/lib/systemd/system/sponsorblockcast.service&lt;/code&gt;.&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;h2&gt;Usage&lt;/h2&gt; &#xA;&lt;p&gt;Run &lt;code&gt;sponsorblockcast&lt;/code&gt; from a terminal or activate the service with &lt;code&gt;systemctl enable --now sponsorblockcast&lt;/code&gt;&lt;/p&gt; &#xA;&lt;h2&gt;Configuration&lt;/h2&gt; &#xA;&lt;p&gt;You can configure the following parameters by setting the appropriate environment values:&lt;/p&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;&lt;code&gt;SBCPOLLINTERVAL&lt;/code&gt; - Time to wait between each polling of the Chromecasts&#39; status (default=&lt;code&gt;1&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SBCSCANINTERVAL&lt;/code&gt; - Time to wait between each scan for available Chromecast (default=&lt;code&gt;300&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SBCDIR&lt;/code&gt; - Directory where temporary files are stored (default=&lt;code&gt;/tmp/sponsorblockcast&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SBCCATEGORIES&lt;/code&gt; - Space-separated SponsorBlock categories to skip, see &lt;a href=&#34;https://github.com/ajayyy/SponsorBlock/raw/master/config.json.example&#34;&gt;category list&lt;/a&gt; (default=&lt;code&gt;sponsor&lt;/code&gt;)&lt;/li&gt; &#xA; &lt;li&gt;&lt;code&gt;SBCYOUTUBEAPIKEY&lt;/code&gt; - &lt;a href=&#34;https://developers.google.com/youtube/registering_an_application&#34;&gt;YouTube API key&lt;/a&gt; for fallback video identification (required on some Chromecast devices).&lt;/li&gt; &#xA;&lt;/ul&gt; &#xA;&lt;p&gt;To run from the terminal with custom parameters you can use &lt;code&gt;env&lt;/code&gt; like so: &lt;code&gt;env SBCSCANINTERVAL=10 SBCPOLLINTERVAL=100 SBCCATEGORIES=&#34;sponsor selfpromo&#34; sponsorblockcast&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;To modify the variables when running as a systemd service, create an override for the service with:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;sudo systemctl edit sponsorblockcast.service&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;This will open a blank override file where you can specify Environment values like so:&lt;/p&gt; &#xA;&lt;pre&gt;&lt;code&gt;[Service]&#xA;Environment=&#34;SBCPOLLINTERVAL=10&#34;&#xA;Environment=&#34;SBCSCANINTERVAL=100&#34;&#xA;Environment=&#34;SBCCATEGORIES=sponsor selfpromo&#34;&#xA;Environment=&#34;SBCYOUTUBEAPIKEY=&amp;lt;your private API key&amp;gt;&#34;&#xA;&lt;/code&gt;&lt;/pre&gt; &#xA;&lt;p&gt;To modify the variables when running as a Docker container, you can add arguments to the &lt;code&gt;docker run&lt;/code&gt; command like so:&lt;/p&gt; &#xA;&lt;p&gt;&lt;code&gt;docker run --network=host --env SBCPOLLINTERVAL=10 --env SBCSCANINTERVAL=100 --name sponsorblockcast sponsorblockcast:latest&lt;/code&gt;&lt;/p&gt; &#xA;&lt;p&gt;When using &lt;code&gt;docker-compose.yaml&lt;/code&gt; you can simply edit the &lt;code&gt;environment&lt;/code&gt; directive as shown in the example file.&lt;/p&gt; &#xA;&lt;h2&gt;Differences from CastBlock&lt;/h2&gt; &#xA;&lt;ul&gt; &#xA; &lt;li&gt;Regular scans to find new Chromecasts while the script is running&lt;/li&gt; &#xA; &lt;li&gt;Allows configuring parameters&lt;/li&gt; &#xA; &lt;li&gt;Specify which SponsorBlock categories to skip&lt;/li&gt; &#xA; &lt;li&gt;More efficient polling, through using &lt;code&gt;go-chromecast&lt;/code&gt;&#39;s &lt;code&gt;watch&lt;/code&gt; command, avoiding expensive startup costs. This lets us poll much more often, without any large performance costs.&lt;/li&gt; &#xA; &lt;li&gt;Full POSIX-compatibility&lt;/li&gt; &#xA;&lt;/ul&gt;</summary>
  </entry>
</feed>